//
// System.Collections.Generic.SortedList
//
// Author:
//    Felix Marthaler
//
// (C) 2005 Felix Marthaler (felix@marfix.net)
//

//
// Copyright (C) 2005 Felix Marthaler
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#if NET_2_0
using System;
using System.Collections;
using System.Runtime.Serialization;
using System.Runtime.InteropServices;

namespace System.Collections.Generic
{
        [SerializableAttribute, ComVisibleAttribute(false)] 
        public class SortedList<TKey,TValue> : IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IDictionary, ICollection, IEnumerable
        {
                
                private IComparer<TKey> comparer = null;
                private uint size = 0;
                private uint capacity = 0;
                private uint version = 0;
                private TKey[] sortedKeys = null;
                private TValue[] sortedValues = null;
                private object syncRoot = null;
                
                public SortedList()
                {
                        if (this.capacity == 0)
                                this.Capacity = 8;
                        if (this.sortedKeys == null && this.sortedValues == null)
                        {
                                this.sortedKeys = new TKey[this.Capacity];
                                this.sortedValues = new TValue[this.Capacity];
                        }
                        if (this.comparer == null)
                                this.comparer = Comparer<TKey>.Default;
                        this.syncRoot = new object();
                }
        
                public SortedList(IComparer<TKey> comparer) : this()
                {
                        if (comparer != null)
                                this.comparer = comparer;
                }
        
                public SortedList(IDictionary<TKey, TValue> dictionary) : this()
                {
                        foreach( KeyValuePair<TKey, TValue> entry in dictionary )
                        {
                                this.Add(entry.Key, entry.Value);
                        }
                }
 
                public SortedList(int capacity) : this()
                {
                        this.Capacity = capacity;
                }
        
                public SortedList(IDictionary<TKey, TValue> dictionary, IComparer<TKey> comparer) : this(dictionary)
                {
                        if (comparer != null)
                                this.comparer = comparer;
                }
        
                public SortedList(int capacity, IComparer<TKey> comparer) : this(comparer)
                {
                        this.Capacity = capacity;
                }
        
                public void Add(TKey key, TValue value)
                {
                        if (key == null)
                                throw new ArgumentNullException();
                        int pos = Array.BinarySearch(this.sortedKeys, 0, (int)this.size, key, this.comparer);
                        if (pos >= 0)
                                throw new ArgumentException("key allready exists");
                        this.InsertAt(~pos, key, value);
                        this.version++;
                }
        
                void IDictionary.Add(object key, object value)
                {
                        if (!(key is TKey && value is TValue))
                                throw new ArgumentException();
                        this.Add((TKey)key, (TValue)value);
                }
        
                void ICollection<KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey,TValue> kvPair)
                {
                        this.Add(kvPair.Key, kvPair.Value);
                }
        
                public void Clear()
                {
                        this.size = 0;
                        Array.Clear(this.sortedKeys, 0, this.Capacity);
                        Array.Clear(this.sortedValues, 0, this.Capacity);
                        this.version++;
                }
        
                public bool ContainsKey(TKey key)
                {
                        int pos = Array.BinarySearch(this.sortedKeys, key);
                        if (pos >= 0 && pos < this.size)
                                return true;
                        return false;
                }
        
                public bool ContainsValue(TValue value)
                {
                        int pos = Array.BinarySearch(this.sortedValues, value);
                        if (pos >= 0 && pos < this.size)
                                return true;
                        return false;
                }
        
                bool IDictionary.Contains(object key)
                {
                        if (!(key is TKey))
                                throw new ArgumentException();
                        return this.ContainsKey((TKey) key);
                }
        
                bool ICollection<KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey,TValue> kvPair)
                {
                        if (this.ContainsValue(kvPair.Value) && this.ContainsKey(kvPair.Key))
                                return true;
                        return false;
                }
        
                public int IndexOfKey(TKey key)
                {
                        return Array.IndexOf(this.sortedKeys, key);
                }
        
                public int IndexOfValue(TValue value)
                {
                        return Array.IndexOf(this.sortedValues, value);
                }
        
                void IDictionary.Remove(object key)
                {
                        if (!(key is TKey))
                                throw new ArgumentException();
                        this.Remove((TKey) key);
                }
        
                bool ICollection<KeyValuePair<TKey, TValue>>.Remove(KeyValuePair<TKey, TValue> entry)
                {
                        return this.Remove(entry.Key);
                }
        
                /// <summary>
                /// removes the Key and Value with the given paramer as key
                /// </summary>
                /// <exception>
                /// ArgumentNullException if the given parameter key is null
                /// </exception>
                public bool Remove(TKey key)
                {
                        if (key == null)
                                throw new ArgumentNullException();
                        int pos = this.IndexOfKey(key);
                        if (pos >= 0) {
                                this.size--;
                                Array.Copy(this.sortedKeys, (pos + 1), this.sortedKeys, pos, (this.size - (pos - 1)));
                                Array.Copy(this.sortedValues, (pos + 1), this.sortedValues, pos, (this.size - (pos - 1)));
                                this.version++;
                                return true;
                        }
                        else {
                                return false;
                        }
                }
        
                /// <summary>
                /// removes the element with the index from the parameter
                /// </summary>
                public bool RemoveAt(int pos)
                {
                        if (pos >= 0 && pos < this.size) {
                                this.size--;
                                Array.Copy(this.sortedKeys, (pos + 1), this.sortedKeys, pos, (this.size - (pos - 1)));
                                Array.Copy(this.sortedValues, (pos + 1), this.sortedValues, pos, (this.size - (pos - 1)));
                                this.version++;
                                return true;
                        }
                        else {
                                return false;
                        }
                }
       
                /// <summary> 
                /// Sets the Capacity to the current size of the SortedList, if the size is less then 90 procent of the Capacity
                /// </summary>
                public void TrimExcess()
                {
                        if (((this.Capacity / 10) * 9) > this.size)
                                this.Capacity = (int)this.size;
                }
                
                /// <summary>
                /// Sets the Capacity to the current size.
                /// </summary>
                public void TrimToSize()
                {
                        this.Capacity = (int)this.size;
                }
        
                public bool TryGetValue(TKey key, out TValue value)
                {
                        int pos = Array.BinarySearch(this.sortedKeys, key);
                        if (pos >= 0 && pos < this.size) {
                                value = this.sortedValues[pos];
                                return true;
                        }
                        else {
                                value = default(TValue);
                                return false;
                        }
                }
        
                void ICollection.CopyTo(System.Array to, int arrayIndex)
                {
                        if (arrayIndex < 0)
                                throw new ArgumentOutOfRangeException();
                        if (to == null)
                                throw new ArgumentNullException();
                        if (to.Length <= arrayIndex || (this.Count + arrayIndex) > to.Length)
                                throw new ArgumentException();
                        IEnumerator<KeyValuePair<TKey, TValue>> enumerator = this.GetEnumerator();
                        for(; enumerator.MoveNext(); arrayIndex++) {
                                to.SetValue(enumerator.Current, arrayIndex);
                        }
                }
        
                void ICollection<KeyValuePair<TKey, TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] to, int arrayIndex)
                {
                        if (arrayIndex < 0)
                                throw new ArgumentOutOfRangeException();
                        if (to == null)
                                throw new ArgumentNullException();
                        if (to.Length <= arrayIndex || (this.Count + arrayIndex) > to.Length)
                                throw new ArgumentException();
                        IEnumerator<KeyValuePair<TKey, TValue>> enumerator = this.GetEnumerator();
                        for(; enumerator.MoveNext(); arrayIndex++) {
                                to.SetValue(enumerator.Current, arrayIndex);
                        }
                }
        
                private void InsertAt(int pos, TKey key, TValue value)
                {
                        if (this.size == this.sortedKeys.Length) {
                                this.ResetCapacity((int)this.size + 1);
                        }
                        if (pos < this.size) {
                                Array.Copy(this.sortedKeys, pos, this.sortedKeys, (pos + 1), (int) (this.size - pos));
                                Array.Copy(this.sortedValues, pos, this.sortedValues, (pos + 1), (int) (this.size - pos));
                        }
                        this.sortedKeys[pos] = key;
                        this.sortedValues[pos] = value;
                        this.size++;
                        this.version++;
                }
    
                private void ResetCapacity(int newSize)
                {
                        if (this.sortedKeys.Length == 0)
                                this.Capacity = 8;
                        else
                                this.Capacity = newSize * 2;
                }
        
                public int Capacity {
                        get {
                                return (int)this.capacity;
                        } 
                        set {
                                if (value < 0)
                                        throw new ArgumentOutOfRangeException();
                                TKey[] tmpKeyArray = new TKey[value];
                                TValue[] tmpValueArray = new TValue[value];
                                if (this.size > 0) {
                                        Array.Copy(this.sortedKeys, 0, tmpKeyArray, 0, this.size);
                                        Array.Copy(this.sortedValues, 0, tmpValueArray, 0, this.size);
                                }
                                this.sortedKeys = tmpKeyArray;
                                this.sortedValues = tmpValueArray;
                                this.version++;
                        } 
                }
        
                public IComparer<TKey> Comparer { 
                        get { 
                                return this.comparer; 
                        }
                }
        
                public int Count { 
                        get { 
                                return (int)this.size; 
                        }
                }
        
                public TValue this[TKey key] {
                        get {
                                int pos = Array.BinarySearch(this.sortedKeys, key);
                                if (pos < 0 || pos >= this.size)
                                        throw new KeyNotFoundException();
                                return this.sortedValues[pos];
                        } 
                        set {
                                if (key == null)
                                        throw new ArgumentNullException();
                                int pos  = Array.BinarySearch(this.sortedKeys, 0,(int) this.size, key, this.comparer);
                                if (pos >= 0 && pos < this.size)
                                        this.sortedValues[pos] = value;
                                if (pos < 0) 
                                        this.InsertAt(~pos, key, value);
                                this.version++;
                        }
                }
        
                object IDictionary.this[object key] {
                        get {
                                if (!(key is TKey))
                                        throw new ArgumentException();
                                return (object)this[(TKey) key];
                        }
                        set {
                                if (!(key is TKey && value is TValue))
                                        throw new ArgumentException();
                                int pos = Array.BinarySearch(this.sortedKeys, key);
                                if (pos < 0 || pos >= this.size)
                                        this.Add((TKey) key, (TValue) value);
                                else 
                                        this.sortedValues[pos] = (TValue) value;
                        }
                }
        
                public IList<TKey> Keys { 
                        get {
                                return new SortedList<TKey, TValue>.KeyList(this);
                        } 
                }
        
                ICollection<TKey> IDictionary<TKey,TValue>.Keys {
                        get {
                                return (ICollection<TKey>) this.Keys;
                        }
                } 
        
                ICollection IDictionary.Keys {
                        get {
                                return (ICollection) this.Keys;
                        }
                }
        
                public IList<TValue> Values {
                        get {
                                return new SortedList<TKey, TValue>.ValueList(this);
                        } 
                }
        
                ICollection<TValue> IDictionary<TKey,TValue>.Values {
                        get {
                                return (ICollection<TValue>) this.Values;
                        }
                }  
        
                ICollection IDictionary.Values {
                        get {
                                return (ICollection) this.Values;
                        }
                }

                IEnumerator IEnumerable.GetEnumerator ()
                {
                        return this.GetEnumerator ();
                }
    	
                IDictionaryEnumerator IDictionary.GetEnumerator ()
                {
                   return (IDictionaryEnumerator) this.GetEnumerator ();
                }

                public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
                {
                        return new SortedList<TKey, TValue>.Enumerator(this);
                }    	
    	
                bool IDictionary.IsReadOnly {
                   get {
                       return false;
                   }
                }
    	
                bool ICollection<KeyValuePair<TKey, TValue>>.IsReadOnly {
                        get { 
                                return false;
                        }
                }
    	
                bool IDictionary.IsFixedSize { 
                        get {
                                return false;
                        } 
                }

                bool ICollection.IsSynchronized {
                        get { 
                                return false; 
                        }
                }

                object ICollection.SyncRoot {
                        get {
                                return this.syncRoot; 
                        }
                }
  
                [Serializable, StructLayout(LayoutKind.Sequential)]
                public class Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>, IDisposable, IDictionaryEnumerator, IEnumerator
                {
                        
                        private SortedList <TKey, TValue> parent;
                        private TKey currentKey = default(TKey);
                        private TValue currentValue = default(TValue);
                        private int index;
                        private uint version;
                        
                        internal Enumerator (SortedList <TKey, TValue> parent)
                        {
                                this.parent = parent;
                                index = -1;
                                version = parent.version;
                        }
                        
                        public KeyValuePair<TKey, TValue> Current {
                                get {
                                        if (this.parent == null)
                                                throw new ObjectDisposedException (null);
                                        if (this.index >= this.parent.Count)
                                                throw new InvalidOperationException ();
                                        return new KeyValuePair<TKey, TValue>(this.currentKey, this.currentValue);
                                }
                        }
                        
                        object IEnumerator.Current {
                                get { 
                                        return new KeyValuePair<TKey, TValue>(this.currentKey, this.currentValue);
                                }
                        }
                        
                        DictionaryEntry IDictionaryEnumerator.Entry {
                                get {
                                        return new DictionaryEntry(this.currentKey, this.currentValue);
                                }
                        }
                        
                        object IDictionaryEnumerator.Key {
                                get {
                                        return this.currentKey;
                                }
                        }
                        
                        object IDictionaryEnumerator.Value {
                                get {
                                        return this.currentValue;
                                }
                        }
                        
                        public bool MoveNext ()
                        {
                                if (this.parent == null)
                                        throw new ObjectDisposedException (null);
                                if (this.version != this.parent.version)
                                        throw new InvalidOperationException ("list modified");
                                else if (this.index < (this.parent.size - 1) && this.index >= 0)
                                {
                                        this.currentKey = this.parent.sortedKeys[this.index];
                                        this.currentValue = this.parent.sortedValues[this.index];
                                        this.index++;
                                        return true;
                                }
                                this.currentKey = default(TKey);
                                this.currentValue = default(TValue);
                                return false;
                        }
        
                        void IEnumerator.Reset ()
                        {
                                if (this.parent == null)
                                        throw new ObjectDisposedException (null);
                                if (this.version != this.parent.version)
                                        throw new InvalidOperationException ("list modified");
                                this.currentKey = default(TKey);
                                this.currentValue = default(TValue);
                                this.index = -1;
                        }
        
                        public void Dispose ()
                        {
                                if (this.parent == null)
                                        throw new ObjectDisposedException (null);
                                this.currentKey = default(TKey);
                                this.currentValue = default(TValue);
                                this.parent = null;
                        }
                }

                [Serializable]
                private class ValueList : IList<TValue>, ICollection<TValue>, IEnumerable<TValue>, ICollection, IEnumerable
                {
                
                        private SortedList<TKey, TValue> parent = null;
                        private int index = -1;
                        private uint version = 0;
                        
                        internal ValueList(SortedList<TKey, TValue> parent)
                        {
                                this.parent = parent;
                                this.version = this.parent.version;
                        }
                        
                        public void Add(TValue key)
                        {
                                throw new NotSupportedException();
                        }
   
                        public void Clear()
                        {
                                throw new NotSupportedException();
                        }

                        public bool Contains(TValue value)
                        {
                                return this.parent.ContainsValue(value);
                        }

                        public void CopyTo(TValue[] array, int arrayIndex)
                        {
                                Array.Copy(this.parent.sortedValues, array, arrayIndex);
                        }
                              
                        void ICollection<TValue>.CopyTo(TValue[] array, int arrayIndex)
                        {
                                Array.Copy(this.parent.sortedValues, array, arrayIndex);
                        }
        
                        void ICollection.CopyTo(Array array, int arrayIndex)
                        {
                                Array.Copy(this.parent.sortedValues, array, arrayIndex);
                        }

                        public IEnumerator<TValue> GetEnumerator()
                        {
                                return new ValueList.Enumerator(this.parent);
                        }
                        
                        public int IndexOf(TValue value)
                        {
                                return this.parent.IndexOfValue(value);
                        }
                              
                        public void Insert(int index, TValue value)
                        {
                                throw new NotSupportedException();
                        }
                              
                        public bool Remove(TValue value)
                        {
                                throw new NotSupportedException();
                        }
        
                        public void RemoveAt(int index)
                        {
                                throw new NotSupportedException();
                        }

                        IEnumerator IEnumerable.GetEnumerator()
                        {
                                return this.GetEnumerator();
                        }
                        
                        public int Count { 
                                get {
                                        return (int)this.parent.size;
                                }
                        }
        
                        public bool IsReadOnly { 
                                get {
                                        return true;
                                }
                        }

                        public TValue this[int index] { 
                                get {
                                        return this.parent.sortedValues[index];
                                }
                                set {
                                        this.parent.sortedValues[index] = value;
                                }
                        }
        
                        bool ICollection.IsSynchronized {
                                get { return false; }
                        }
        
                        object ICollection.SyncRoot { 
                                get {
                                        return this.parent.syncRoot;
                                }
                        }
        
                        [Serializable]
                        private class Enumerator : IEnumerator<TValue>, IDisposable, IEnumerator
                        {
                                private SortedList<TKey, TValue> parent;
                                private int index;
                                private uint version;
                                    
                                internal Enumerator(SortedList<TKey, TValue> parent)
                                {
                                        this.parent = parent;
                                        this.version = this.parent.version;
                                        this.index = -1;
                                }
        
                                public void Dispose ()
                                {
                                        if (this.parent == null)
                                                throw new ObjectDisposedException (null);
                                        this.index = -1;
                                        this.version = 0;
                                        this.parent = null;
                                }
        
                                public bool MoveNext()
                                {
                                        if (this.index < (this.parent.size - 1)) {
                                                this.index++;
                                                return true;
                                        }
                                        return false;
                                }
                                     
                                void IEnumerator.Reset()
                                {
                                        this.index = -1;
                                }
                                
                                public TValue Current { 
                                        get {
                                                return this.parent.sortedValues[this.index];
                                        }
                                }

                                object IEnumerator.Current { 
                                        get {
                                                return this.Current;
                                        }
                                }
                        }
                }

                [Serializable]
                private class KeyList : IList<TKey>, ICollection<TKey>, IEnumerable<TKey>, ICollection, IEnumerable
                {
                
                        private SortedList<TKey, TValue> parent = null;
                        private int index = -1;
                        private uint version = 0;
                
                        internal KeyList(SortedList<TKey, TValue> parent)
                        {
                                this.parent = parent;
                                this.version = this.parent.version;
                        }
                
                        public void Add(TKey key)
                        {
                                throw new NotSupportedException();
                        }
                
                        public void Clear()
                        {
                                throw new NotSupportedException();
                        }
                        
                        public bool Contains(TKey value)
                        {
                                return this.parent.ContainsKey(value);
                        }
                
                        public void CopyTo(TKey[] array, int arrayIndex)
                        {
                                Array.Copy(this.parent.sortedKeys, array, arrayIndex);
                        }
                
                        void ICollection<TKey>.CopyTo(TKey[] array, int arrayIndex)
                        {
                                Array.Copy(this.parent.sortedKeys, array, arrayIndex);
                        }
                
                        void ICollection.CopyTo(Array array, int arrayIndex)
                        {
                                Array.Copy(this.parent.sortedKeys, array, arrayIndex);
                        }
                
                        public IEnumerator<TKey> GetEnumerator()
                        {
                                return new KeyList.Enumerator(this.parent);
                        }
                
                        public int IndexOf(TKey value)
                        {
                                return this.parent.IndexOfKey(value);
                        }
                
                        public void Insert(int index, TKey value)
                        {
                                throw new NotSupportedException();
                        }
                
                        public bool Remove(TKey value)
                        {
                                throw new NotSupportedException();
                        }
                
                        public void RemoveAt(int index)
                        {
                                throw new NotSupportedException();
                        }
                
                        IEnumerator IEnumerable.GetEnumerator()
                        {
                                return this.GetEnumerator();
                        }
        
                        public int Count { 
                                get { 
                                        return this.parent.Count;
                                }
                        }
                
                        public bool IsReadOnly { 
                                get {
                                        return true;
                                }
                        }
                
                        public TKey this[int index] { 
                                get {
                                        return this.parent.sortedKeys[index];
                                }
                                set {
                                        throw new NotSupportedException();
                                }
                        }
                
                        bool ICollection.IsSynchronized {
                                get { return false; }
                        }
                
                        object ICollection.SyncRoot { 
                                get {
                                        return this.parent.syncRoot;
                                }
                        }
                
                        [Serializable]
                        private class Enumerator : IEnumerator<TKey>, IDisposable, IEnumerator
                        {
                                private SortedList<TKey, TValue> parent;
                                private int index;
                                private uint version;
                        
                                internal Enumerator(SortedList<TKey, TValue> parent)
                                {
                                        this.parent = parent;
                                        this.version = this.parent.version;
                                        this.index = -1;
                                }
                        
                                public void Dispose ()
                                {
                                        if (this.parent == null)
                                                throw new ObjectDisposedException (null);
                                        this.index = -1;
                                        this.version = 0;
                                        this.parent = null;
                                }
                
                                public bool MoveNext()
                                {
                                        if (this.index < (this.parent.size - 1)) {
                                                this.index++;
                                                return true;
                                        }
                                        return false;
                                }
                        
                                void IEnumerator.Reset()
                                {
                                        this.index = -1;
                                }
                
                                public TKey Current {
                                        get {
                                                return this.parent.sortedKeys[this.index];
                                        }
                                }
                        
                                object IEnumerator.Current {
                                        get {
                                                return this.Current;
                                        }
                                }
                        }
                }
        }
}
#endif
