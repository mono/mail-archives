Index: StringBuilder.cs
===================================================================
--- StringBuilder.cs	(revision 38648)
+++ StringBuilder.cs	(working copy)
@@ -83,7 +83,7 @@
 			_length = length;
 		}
 
-		public StringBuilder () : this (String.Empty, 0, 0, 0) {}
+		public StringBuilder () : this (null) {}
 
 		public StringBuilder(int capacity) : this (String.Empty, 0, 0, capacity) {}
 
@@ -94,7 +94,13 @@
 			_maxCapacity = maxCapacity;
 		}
 
-		public StringBuilder( string value ) : this(value, 0, value == null ? 0 : value.Length, value == null? 0 : value.Length) {
+		public StringBuilder (string value)
+		{
+			if (null == value)
+				value = "";
+			
+			_length = value.Length;
+			_str = _cached_str = value;
 		}
 	
 		public StringBuilder( string value, int capacity) : this(value, 0, value.Length, capacity) {}
@@ -108,6 +114,9 @@
 
 		public int Capacity {
 			get {
+				if (_str.Length == 0)
+					return constDefaultCapacity;
+				
 				return _str.Length;
 			}
 
@@ -311,6 +320,12 @@
 		{
 			if (value == null)
 				return this;
+			
+			if (_length == 0 && value.Length < _maxCapacity && value.Length > _str.Length) {
+				_length = value.Length;
+				_str = _cached_str = value;
+				return this;
+			}
 
 			int needed_cap = _length + value.Length;
 			if (null != _cached_str || _str.Length < needed_cap)
@@ -627,6 +642,13 @@
 				// Try double buffer, if that doesn't work, set the length as capacity
 				if (size > capacity) 
 				{
+					
+					// The first time a string is appended, we just set _cached_str
+					// and _str to it. This allows us to do some optimizations.
+					// Below, we take this into account.
+					if (_cached_str == _str && capacity < constDefaultCapacity)
+						capacity = constDefaultCapacity;
+					
 					capacity = capacity << 1;
 					if (size > capacity)
 						capacity = size;
