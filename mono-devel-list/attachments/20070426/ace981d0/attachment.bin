Index: eglib/test/ptrarray.c
===================================================================
--- eglib/test/ptrarray.c	(revision 76322)
+++ eglib/test/ptrarray.c	(working copy)
@@ -17,7 +17,7 @@
 	NULL
 };
 
-static GPtrArray *ptrarray_alloc_and_fill(gint *item_count)
+static GPtrArray *ptrarray_alloc_and_fill(guint *item_count)
 {
 	GPtrArray *array = g_ptr_array_new();
 	gint i;
@@ -33,9 +33,9 @@
 	return array;
 }
 
-static gint guess_size(gint length)
+static guint guess_size(guint length)
 {
-	gint size = 1;
+	guint size = 1;
 
 	while(size < length) {
 		size <<= 1;
@@ -47,7 +47,7 @@
 RESULT ptrarray_alloc()
 {
 	GPtrArrayPriv *array;
-	gint i;
+	guint i;
 	
 	array = (GPtrArrayPriv *)ptrarray_alloc_and_fill(&i);
 	
@@ -68,7 +68,7 @@
 RESULT ptrarray_for_iterate()
 {
 	GPtrArray *array = ptrarray_alloc_and_fill(NULL);
-	gint i;
+	guint i;
 
 	for(i = 0; i < array->len; i++) {
 		char *item = (char *)g_ptr_array_index(array, i);
@@ -120,7 +120,7 @@
 RESULT ptrarray_set_size()
 {
 	GPtrArray *array = g_ptr_array_new();
-	gint i, grow_length = 50;
+	guint i, grow_length = 50;
 	
 	g_ptr_array_add(array, (gpointer)items[0]);
 	g_ptr_array_add(array, (gpointer)items[1]);
@@ -148,7 +148,7 @@
 RESULT ptrarray_remove_index()
 {
 	GPtrArray *array;
-	gint i;
+	guint i;
 	
 	array = ptrarray_alloc_and_fill(&i);
 	
@@ -173,7 +173,7 @@
 RESULT ptrarray_remove()
 {
 	GPtrArray *array;
-	gint i;
+	guint i;
 	
 	array = ptrarray_alloc_and_fill(&i);
 
@@ -206,7 +206,7 @@
 RESULT ptrarray_sort()
 {
 	GPtrArray *array = g_ptr_array_new();
-	gint i;
+	guint i;
 	gchar *letters [] = { "A", "B", "C", "D", "E" };
 	
 	g_ptr_array_add(array, letters[0]);
@@ -242,3 +242,4 @@
 
 DEFINE_TEST_GROUP_INIT(ptrarray_tests_init, ptrarray_tests)
 
+
Index: eglib/test/string.c
===================================================================
--- eglib/test/string.c	(revision 76322)
+++ eglib/test/string.c	(working copy)
@@ -95,8 +95,8 @@
 	ret = g_string_free (s, FALSE);
 	g_free (ret);
 
- 	s = g_string_new_len ("H\000H", 3);
-	g_string_append_len (s, "1\0002", 3);
+ 	s = g_string_new_len ("H" "\000" "H", 3);
+	g_string_append_len (s, "1" "\000" "2", 3);
 	sfail ('H', 0);
 	sfail ( 0, 1);
 	sfail ('H', 2);
@@ -137,7 +137,7 @@
 	s = g_string_truncate (s, 10);
 	if (strlen (s->str) != 1)
 		return FAILED ("The size is not 1");
-	g_string_truncate (s, -1);
+	g_string_truncate (s, (gsize)-1);
 	if (strlen (s->str) != 1)
 		return FAILED ("The size is not 1");
 	g_string_truncate (s, 0);
@@ -205,7 +205,7 @@
 test_macros ()
 {
 	char *s = g_strdup (G_STRLOC);
-	char *p = strchr (s, ':');
+	char *p = strchr (s + 2, ':');
 	int n;
 	
 	if (p == NULL)
@@ -215,7 +215,7 @@
 		return FAILED ("did not find a valid line number");
 
 	*p = 0;
-	if (strcmp (s, "string.c") != 0)
+	if (strcmp (s + strlen(s) - 8 , "string.c") != 0)
 		return FAILED ("This did not store the filename on G_STRLOC");
 	
 	g_free (s);
Index: eglib/test/list.c
===================================================================
--- eglib/test/list.c	(revision 76322)
+++ eglib/test/list.c	(working copy)
@@ -315,10 +315,12 @@
 
 static gboolean verify_sort (GList *list, int len)
 {
+	int prev;
+
 	if (list->prev)
 		return FALSE;
 
-	int prev = GPOINTER_TO_INT (list->data);
+	prev = GPOINTER_TO_INT (list->data);
 	len--;
 	for (list = list->next; list; list = list->next) {
 		int curr = GPOINTER_TO_INT (list->data);
Index: eglib/test/pattern.c
===================================================================
--- eglib/test/pattern.c	(revision 76322)
+++ eglib/test/pattern.c	(working copy)
@@ -1,7 +1,10 @@
+#include <config.h>
 #include <glib.h>
 #include <string.h>
 #include <stdlib.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 #include <stdio.h>
 #include "test.h"
 
@@ -55,3 +58,4 @@
 
 DEFINE_TEST_GROUP_INIT(pattern_tests_init, pattern_tests)
 
+
Index: eglib/test/dir.c
===================================================================
--- eglib/test/dir.c	(revision 76322)
+++ eglib/test/dir.c	(working copy)
@@ -1,8 +1,13 @@
+#include <config.h>
 #include <glib.h>
 #include <string.h>
 #include <stdio.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
+#ifdef G_OS_UNIX
 #include <pthread.h>
+#endif
 #include "test.h"
 
 /* This test is just to be used with valgrind */
@@ -58,3 +63,4 @@
 
 DEFINE_TEST_GROUP_INIT(dir_tests_init, dir_tests)
 
+
Index: eglib/test/file.c
===================================================================
--- eglib/test/file.c	(revision 76322)
+++ eglib/test/file.c	(working copy)
@@ -1,10 +1,18 @@
+#include <config.h>
 #include <glib.h>
 #include <string.h>
 #include <stdlib.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 #include <stdio.h>
 #include "test.h"
 
+#ifdef G_OS_WIN32
+#include <io.h>
+#define close _close
+#endif
+
 RESULT
 test_file_get_contents ()
 {
@@ -12,6 +20,11 @@
 	gchar *content;
 	gboolean ret;
 	gsize length;
+#ifdef G_OS_WIN32
+	const gchar *filename = "c:\\Windows\\system.ini";
+#else
+	const gchar *filename = "/etc/hosts";
+#endif
 
 	/*
 	filename != NULL
@@ -33,7 +46,7 @@
 
 	g_error_free (error);
 	error = NULL;
-	ret = g_file_get_contents ("/etc/hosts", &content, &length, &error);
+	ret = g_file_get_contents (filename, &content, &length, &error);
 	if (!ret)
 		return FAILED ("The error is %d %s\n", error->code, error->message);
 	if (error != NULL)
@@ -98,8 +111,12 @@
 {
 	gboolean res;
 	const gchar *tmp;
-	gchar *path, *sympath;
+	gchar *path;
+
+#ifndef G_OS_WIN32 /* FIXME */
+	gchar *sympath;
 	gint ignored;
+#endif
 
 	res = g_file_test (NULL, 0);
 	if (res)
@@ -156,6 +173,7 @@
 	if (res)
 		return FAILED ("3 %s should not be a symlink", path);
 
+#ifndef G_OS_WIN32 /* FIXME */
 	sympath = g_strconcat (path, "-link", NULL);
 	ignored = symlink (path, sympath);
 	res = g_file_test (sympath, G_FILE_TEST_EXISTS);
@@ -192,8 +210,9 @@
 	if (!res)
 		return FAILED ("5 %s should be a symlink", sympath);
 	unlink (sympath);
+	g_free (sympath);
+#endif
 	g_free (path);
-	g_free (sympath);
 	return OK;
 }
 
@@ -206,3 +225,4 @@
 
 DEFINE_TEST_GROUP_INIT(file_tests_init, file_tests)
 
+
Index: eglib/test/test.c
===================================================================
--- eglib/test/test.c	(revision 76322)
+++ eglib/test/test.c	(working copy)
@@ -26,15 +26,23 @@
  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+#include <config.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
+#include <glib.h>
+#ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
-#include <glib.h>
+#endif
+#ifdef G_OS_WIN32
+#include <winsock2.h>
+#endif
 
 #include "test.h"
 
+extern gint global_passed, global_tests;
+
 static gchar *last_result = NULL;
 
 gboolean 
@@ -75,7 +83,7 @@
 	start_time_group = get_timestamp();
 
 	for(i = 0; tests[i].name != NULL; i++) {
-		gchar *result;
+		gchar *result = "";
 		gboolean iter_pass, run;
 	
 		iter_pass = FALSE;
@@ -132,6 +140,9 @@
 		}
 	}
 
+	global_passed += passed;
+	global_tests += total;
+
 	if(!quiet) {
 		gdouble pass_percentage = ((gdouble)passed / (gdouble)total) * 100.0;
 		if(time) {
@@ -172,9 +183,15 @@
 gdouble
 get_timestamp()
 {
+	/* FIXME: We should use g_get_current_time here */
+#ifdef G_OS_WIN32
+	long int l = GetTickCount();
+	return (gdouble)(l / 1000) + (1.e-6) * ((l % 1000) * 1000);
+#else
 	struct timeval tp;
 	gettimeofday(&tp, NULL);
 	return (gdouble)tp.tv_sec + (1.e-6) * tp.tv_usec;
+#endif
 }
 
 /* 
@@ -189,7 +206,7 @@
 	gchar *strtok_save, **vector;
 	gchar *token, *token_c;
 	gint size = 1;
-	gint token_length;
+	size_t token_length;
 
 	g_return_val_if_fail(string != NULL, NULL);
 	g_return_val_if_fail(delimiter != NULL, NULL);
@@ -251,3 +268,4 @@
 }
 
 
+
Index: eglib/test/timer.c
===================================================================
--- eglib/test/timer.c	(revision 76322)
+++ eglib/test/timer.c	(working copy)
@@ -1,9 +1,18 @@
+#include <config.h>
 #include <glib.h>
 #include <string.h>
 #include <math.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 #include <stdlib.h>
 #include <stdio.h>
+
+#ifdef G_OS_WIN32
+#include <windows.h>
+#define sleep(t)                 Sleep((t) * 1000)
+#endif
+
 #include "test.h"
 
 RESULT
@@ -43,3 +52,4 @@
 
 DEFINE_TEST_GROUP_INIT(timer_tests_init, timer_tests)
 
+
Index: eglib/test/string-util.c
===================================================================
--- eglib/test/string-util.c	(revision 76322)
+++ eglib/test/string-util.c	(working copy)
@@ -254,6 +254,7 @@
 test_ascii_xdigit_value ()
 {
 	int i;
+	gchar j;
 
 	i = g_ascii_xdigit_value ('9' + 1);
 	if (i != -1)
@@ -274,20 +275,20 @@
 	if (i != -1)
 		return FAILED ("'F' + 1");
 
-	for (i = '0'; i < '9'; i++) {
-		int c = g_ascii_xdigit_value (i);
-		if (c  != (i - '0'))
-			return FAILED ("Digits %c -> %d", i, c);
+	for (j = '0'; j < '9'; j++) {
+		int c = g_ascii_xdigit_value (j);
+		if (c  != (j - '0'))
+			return FAILED ("Digits %c -> %d", j, c);
 	}
-	for (i = 'a'; i < 'f'; i++) {
-		int c = g_ascii_xdigit_value (i);
-		if (c  != (i - 'a' + 10))
-			return FAILED ("Lower %c -> %d", i, c);
+	for (j = 'a'; j < 'f'; j++) {
+		int c = g_ascii_xdigit_value (j);
+		if (c  != (j - 'a' + 10))
+			return FAILED ("Lower %c -> %d", j, c);
 	}
-	for (i = 'A'; i < 'F'; i++) {
-		int c = g_ascii_xdigit_value (i);
-		if (c  != (i - 'A' + 10))
-			return FAILED ("Upper %c -> %d", i, c);
+	for (j = 'A'; j < 'F'; j++) {
+		int c = g_ascii_xdigit_value (j);
+		if (c  != (j - 'A' + 10))
+			return FAILED ("Upper %c -> %d", j, c);
 	}
 	return OK;
 }
@@ -310,18 +311,18 @@
 	return OK;
 }
 
-#define TEXT "0123456789"
+#define NUMBERS "0123456789"
 
 RESULT
 test_strlcpy ()
 {
 	const gchar *src = "onetwothree";
 	gchar *dest;
-	int i;
+	gsize i;
 
 	dest = g_malloc (strlen (src) + 1);
 	memset (dest, 0, strlen (src) + 1);
-	i = g_strlcpy (dest, src, -1);
+	i = g_strlcpy (dest, src, (gsize)-1);
 	if (i != strlen (src))
 		return FAILED ("Test1 got %d", i);
 
@@ -348,9 +349,9 @@
 	g_free (dest);
 
 	/* This is a test for g_filename_from_utf8, even if it does not look like it */
-	dest = g_filename_from_utf8 (TEXT, strlen (TEXT), NULL, NULL, NULL);
-	if (0 != strcmp (dest, TEXT))
-		return FAILED ("problem [%s] and [%s]", dest, TEXT);
+	dest = g_filename_from_utf8 (NUMBERS, strlen (NUMBERS), NULL, NULL, NULL);
+	if (0 != strcmp (dest, NUMBERS))
+		return FAILED ("problem [%s] and [%s]", dest, NUMBERS);
 	g_free (dest);
 	
 	return OK;
@@ -420,3 +421,4 @@
 
 DEFINE_TEST_GROUP_INIT(strutil_tests_init, strutil_tests)
 
+
Index: eglib/test/test.h
===================================================================
--- eglib/test/test.h	(revision 76322)
+++ eglib/test/test.h	(working copy)
@@ -29,9 +29,18 @@
 #ifndef _TEST_H
 #define _TEST_H
 
+#include <config.h>
 #include <stdarg.h>
 #include <glib.h>
 
+#ifdef _MSC_VER
+/* disable the following warnings 
+ * C4100: The formal parameter is not referenced in the body of the function. The unreferenced parameter is ignored. 
+ * C4127: conditional expression is constant (test macros produce a lot of these)
+*/
+#pragma warning(disable:4100 4127)
+#endif
+
 typedef gchar * RESULT;
 
 typedef struct _Test Test;
@@ -52,6 +61,7 @@
 
 gboolean run_group(Group *group, gint iterations, gboolean quiet, 
 	gboolean time, gchar *tests);
+#undef FAILED
 RESULT FAILED(const gchar *format, ...);
 gdouble get_timestamp();
 gchar ** eg_strsplit (const gchar *string, const gchar *delimiter, gint max_tokens);
@@ -67,3 +77,4 @@
 
 #endif /* _TEST_H */
 
+
Index: eglib/test/module.c
===================================================================
--- eglib/test/module.c	(revision 76322)
+++ eglib/test/module.c	(working copy)
@@ -1,3 +1,4 @@
+#include <config.h>
 #include <glib.h>
 #include <gmodule.h>
 #include <string.h>
@@ -2,3 +3,5 @@
 #include <stdio.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 #include "test.h"
@@ -58,3 +61,4 @@
 
 DEFINE_TEST_GROUP_INIT(module_tests_init, module_tests)
 
+
Index: eglib/test/utf8.c
===================================================================
--- eglib/test/utf8.c	(revision 76322)
+++ eglib/test/utf8.c	(working copy)
@@ -183,7 +183,7 @@
 	gunichar2 *dst;
 
 	printf ("got: %s\n", src);
-	dst = g_utf8_to_utf16 (src, strlen (src), &in_read, &out_read, &error);
+	dst = g_utf8_to_utf16 (src, (glong)strlen (src), &in_read, &out_read, &error);
 	if (error != NULL){
 		return error->message;
 	}
@@ -229,6 +229,9 @@
 	char *s = g_convert ("\242\241\243\242\241\243\242\241\243\242\241\243", -1, "UTF-8", "ISO-8859-1", NULL, &n, NULL);
 	guchar *u = (guchar *) s;
 	
+	if (!s)
+		return FAILED ("Expected 24 bytes, got: NULL");
+
 	if (strlen (s) != 24)
 		return FAILED ("Expected 24 bytes, got: %d", strlen (s));
 
@@ -256,3 +259,4 @@
 
 DEFINE_TEST_GROUP_INIT(utf8_tests_init, utf8_tests)
 
+
Index: eglib/test/spawn.c
===================================================================
--- eglib/test/spawn.c	(revision 76322)
+++ eglib/test/spawn.c	(working copy)
@@ -1,9 +1,18 @@
+#include <config.h>
 #include <glib.h>
 #include <string.h>
 #include <stdio.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 #include "test.h"
 
+#ifdef G_OS_WIN32
+#include <io.h>
+#define read _read
+#define close _close
+#endif
+
 RESULT
 test_spawn_sync ()
 {
@@ -70,3 +79,4 @@
 
 DEFINE_TEST_GROUP_INIT(spawn_tests_init, spawn_tests)
 
+
Index: eglib/test/driver.c
===================================================================
--- eglib/test/driver.c	(revision 76322)
+++ eglib/test/driver.c	(working copy)
@@ -25,14 +25,22 @@
  * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
- 
-#include <stdio.h>
-#include <glib.h>
-#include <getopt.h>
 
+#include <config.h>
 #include "test.h"
 #include "tests.h"
 
+#include <stdio.h>
+#include <getopt.h>
+
+#if defined(HAVE_UNISTD_H)
+#include <unistd.h>
+#endif
+
+#ifndef DRIVER_NAME
+#define DRIVER_NAME "EGlib"
+#endif
+
 typedef struct _StringArray {
 	gchar **strings;
 	gint length;
@@ -57,6 +65,8 @@
 	return array;
 }
 
+gint global_passed = 0, global_tests = 0;
+
 static void
 string_array_free(StringArray *array)
 {
@@ -155,8 +165,8 @@
 			for(k = 0; k < tests_to_run->length; k++) {	
 				gchar *user = tests_to_run->strings[k];
 				const gchar *table = test_groups[j].name;
-				gint user_len = strlen(user);
-				gint table_len = strlen(table);
+				size_t user_len = strlen(user);
+				size_t table_len = strlen(table);
 				
 				if(strncmp(user, table, table_len) == 0) {
 					if(user_len > table_len && user[table_len] != ':') {
@@ -171,6 +181,7 @@
 		}
 	
 		if(run) {
+			gboolean passed;
 			gchar **split = NULL;
 			
 			if(debug && test_groups[j].handler != fake_tests_init) {
@@ -195,7 +206,7 @@
 				}
 			}
 			
-			gboolean passed = run_group(&(test_groups[j]), 
+			passed = run_group(&(test_groups[j]), 
 				iterations, quiet, report_time, tests);
 
 			if(tests != NULL) {
@@ -209,8 +220,9 @@
 	}
 	
 	if(!quiet) {
+		gdouble pass_percentage = ((gdouble)global_passed / (gdouble)global_tests) * 100.0;
 		printf("=============================\n");
-		printf("Overall result: %s\n", global_failure ? "FAILED" : "OK");
+		printf("Overall result: %s : %d / %d (%g%%)\n", global_failure ? "FAILED" : "OK", global_passed, global_tests, pass_percentage);
 	}
 	
 	if(report_time) {
@@ -229,3 +241,4 @@
 	return 0;
 }
 
+
Index: eglib/test/path.c
===================================================================
--- eglib/test/path.c	(revision 76322)
+++ eglib/test/path.c	(working copy)
@@ -1,10 +1,20 @@
+#include <config.h>
 #include <glib.h>
 #include <string.h>
 #include <stdio.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
+#ifdef G_OS_UNIX
 #include <pthread.h>
+#endif
 #include "test.h"
 
+#ifdef G_OS_WIN32
+#include <direct.h>
+#define chdir _chdir
+#endif
+
 /* This test is just to be used with valgrind */
 RESULT
 test_buildpath ()
@@ -82,7 +92,6 @@
 	if (strcmp (s, "/a/c/") != 0)
 		return FAILED ("14 Got wrong result, got: %s", s);
 	g_free (s);
-        return OK;
 	
 	return OK;
 }
@@ -93,7 +102,11 @@
 	char *s;
 	
 	s = g_build_filename ("a", "b", "c", "d", NULL);
+#ifdef G_OS_WIN32
+	if (strcmp (s, "a\\b\\c\\d") != 0)
+#else
 	if (strcmp (s, "a/b/c/d") != 0)
+#endif
 		return FAILED ("1 Got wrong result, got: %s", s);
 	g_free (s);
 	
@@ -105,6 +118,26 @@
 {
 	char *s;
 
+#ifdef G_OS_WIN32
+	s = g_path_get_dirname ("c:\\home\\miguel");
+	if (strcmp (s, "c:\\home") != 0)
+		return FAILED ("Expected c:\\home, got %s", s);
+	g_free (s);
+
+	s = g_path_get_dirname ("c:\\home\\dingus\\");
+	if (strcmp (s, "c:\\home\\dingus") != 0)
+		return FAILED ("Expected c:\\home\\dingus, got %s", s);
+	g_free (s);
+
+	s = g_path_get_dirname ("dir.c");
+	if (strcmp (s, ".") != 0)
+		return FAILED ("Expected `.', got %s", s);
+	g_free (s);
+
+	s = g_path_get_dirname ("c:\\index.html");
+	if (strcmp (s, "c:") != 0)
+		return FAILED ("Expected [c:], got [%s]", s);
+#else
 	s = g_path_get_dirname ("/home/miguel");
 	if (strcmp (s, "/home") != 0)
 		return FAILED ("Expected /home, got %s", s);
@@ -123,7 +156,7 @@
 	s = g_path_get_dirname ("/index.html");
 	if (strcmp (s, "/") != 0)
 		return FAILED ("Expected [/], got [%s]", s);
-	
+#endif	
 	return OK;
 }
 
@@ -132,11 +165,27 @@
 {
 	char *s;
 
+#ifdef G_OS_WIN32
 	s = g_path_get_basename ("");
 	if (strcmp (s, ".") != 0)
 		return FAILED ("Expected `.', got %s", s);
 	g_free (s);
 
+	s = g_path_get_basename ("c:\\home\\dingus\\");
+	if (strcmp (s, "dingus") != 0)
+		return FAILED ("1 Expected dingus, got %s", s);
+	g_free (s);
+
+	s = g_path_get_basename ("c:\\home\\dingus");
+	if (strcmp (s, "dingus") != 0)
+		return FAILED ("2 Expected dingus, got %s", s);
+	g_free (s);
+#else
+	s = g_path_get_basename ("");
+	if (strcmp (s, ".") != 0)
+		return FAILED ("Expected `.', got %s", s);
+	g_free (s);
+
 	s = g_path_get_basename ("/home/dingus/");
 	if (strcmp (s, "dingus") != 0)
 		return FAILED ("1 Expected dingus, got %s", s);
@@ -146,7 +195,7 @@
 	if (strcmp (s, "dingus") != 0)
 		return FAILED ("2 Expected dingus, got %s", s);
 	g_free (s);
-
+#endif
 	return OK;
 }
 
@@ -154,10 +203,14 @@
 test_ppath ()
 {
 	char *s;
-	
-	s = g_find_program_in_path ("ls");
+#ifdef G_OS_WIN32
+	const gchar *searchfor = "explorer.exe";
+#else
+	const gchar *searchfor = "ls";
+#endif
+	s = g_find_program_in_path (searchfor);
 	if (s == NULL)
-		return FAILED ("No shell on this system (This assumes Unix)?");
+		return FAILED ("No %s on this system?", searchfor);
 	g_free (s);
 	return OK;
 }
@@ -167,6 +220,11 @@
 {
 	char *s;
 	const char *path = g_getenv ("PATH");
+#ifdef G_OS_WIN32
+	const gchar *searchfor = "test_eglib.exe";
+#else
+	const gchar *searchfor = "test-glib";
+#endif
 	
 	g_setenv ("PATH", "", TRUE);
 	s = g_find_program_in_path ("ls");
@@ -175,10 +233,10 @@
 		return FAILED ("Found something interesting here: %s", s);
 	}
 	g_free (s);
-	s = g_find_program_in_path ("test-glib");
+	s = g_find_program_in_path (searchfor);
 	if (s == NULL) {
 		g_setenv ("PATH", path, TRUE);
-		return FAILED ("It should find 'test-glib' in the current directory.");
+		return FAILED ("It should find '%s' in the current directory.", searchfor);
 	}
 	g_free (s);
 	g_setenv ("PATH", path, TRUE);
@@ -189,17 +247,22 @@
 test_cwd ()
 {
 	char *dir = g_get_current_dir ();
+#ifdef G_OS_WIN32
+	const gchar *newdir = "C:\\Windows";
+#else
+	const gchar *newdir = "/bin";
+#endif
 
 	if (dir == NULL)
 		return FAILED ("No current directory?");
 	g_free (dir);
 	
-	if (chdir ("/bin") == -1)
-		return FAILED ("No /bin?");
+	if (chdir (newdir) == -1)
+		return FAILED ("No %s?", newdir);
 	
 	dir = g_get_current_dir ();
-	if (strcmp (dir, "/bin") != 0)
-		return FAILED("Did not go to /bin?");
+	if (strcmp (dir, newdir) != 0)
+		return FAILED("Did not go to %s?", newdir);
 	g_free (dir);
 	
 	return OK;
@@ -234,3 +297,4 @@
 
 DEFINE_TEST_GROUP_INIT(path_tests_init, path_tests)
 
+
Index: eglib/test/sizes.c
===================================================================
--- eglib/test/sizes.c	(revision 76322)
+++ eglib/test/sizes.c	(working copy)
@@ -4,7 +4,9 @@
  * These depend on -Werror, -Wall being set to catch the build error.
  */
 #include <stdio.h>
+#ifndef _MSC_VER
 #include <stdint.h>
+#endif
 #include <string.h>
 #include <glib.h>
 #include "test.h"
Index: eglib/configure.ac
===================================================================
--- eglib/configure.ac	(revision 76322)
+++ eglib/configure.ac	(working copy)
@@ -50,6 +50,8 @@
 AC_CHECK_SIZEOF(void *)
 AC_CHECK_FUNCS(strlcpy)
 
+AC_CHECK_HEADERS(getopt.h sys/time.h sys/wait.h pwd.h)
+
 if test $ac_cv_sizeof_void_p != $ac_cv_sizeof_int; then
    GPOINTER_TO_INT="((gint)(long) (ptr))"
    GPOINTER_TO_UINT="((guint)(long) (ptr))"
Index: eglib/src/eglib-config.h.in
===================================================================
--- eglib/src/eglib-config.h.in	(revision 76322)
+++ eglib/src/eglib-config.h.in	(working copy)
@@ -1,3 +1,6 @@
+#ifndef __EGLIB_CONFIG_H
+#define __EGLIB_CONFIG_H
+
 /*
  * System-dependent settings
  */
@@ -21,3 +24,13 @@
 
 #define G_GSIZE_FORMAT   @GSIZE_FORMAT@
 #define G_GUINT64_FORMAT @G_GUINT64_FORMAT@
+
+/* TODO: add configure checks? */
+#define G_HAVE_UNISTD_H 1
+#define G_HAVE_GETOPT_H 1
+#define G_HAVE_SYS_TIME_H 1
+#define G_HAVE_SYS_WAIT_H 1
+#define G_HAVE_PWD_H 1
+#define G_HAVE_STRNDUP 1
+
+#endif
Index: eglib/src/gspawn.c
===================================================================
--- eglib/src/gspawn.c	(revision 76322)
+++ eglib/src/gspawn.c	(working copy)
@@ -25,20 +25,38 @@
  * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <sys/types.h>
-#ifdef _MSC_VER
-#include <winsock2.h>
-#else
+
+#include <glib.h>
+
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
+
+#ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
+#endif
+
+#ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
 #endif
-#include <glib.h>
 
+#ifdef G_OS_WIN32
+#include <io.h>
+#include <winsock2.h>
+#define open _open
+#define close _close
+#define read _read
+#define write _write
+/* windows pipe api details: http://msdn2.microsoft.com/en-us/library/edze9h7e(VS.80).aspx */
+#define pipe(x) _pipe(x, 256, 0)
+#endif
+
 #define set_error(msg, ...) do { if (error != NULL) *error = g_error_new (G_LOG_DOMAIN, 1, msg, __VA_ARGS__); } while (0)
 #define set_error_cond(cond,msg, ...) do { if ((cond) && error != NULL) *error = g_error_new (G_LOG_DOMAIN, 1, msg, __VA_ARGS__); } while (0)
 #define set_error_status(status,msg, ...) do { if (error != NULL) *error = g_error_new (G_LOG_DOMAIN, status, msg, __VA_ARGS__); } while (0)
@@ -83,12 +101,21 @@
 		if (out_closed && err_closed)
 			break;
 
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable:4389)
+#endif
+
 		FD_ZERO (&rfds);
 		if (!out_closed && outfd >= 0)
 			FD_SET (outfd, &rfds);
 		if (!err_closed && errfd >= 0)
 			FD_SET (errfd, &rfds);
 
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+
 		res = select (MAX (outfd, errfd) + 1, &rfds, NULL, NULL, NULL);
 		if (res > 0) {
 			if (buffer == NULL)
@@ -150,6 +177,8 @@
 				gint *exit_status,
 				GError **error)
 {
+#ifdef G_OS_WIN32
+#else
 	pid_t pid;
 	gchar **argv;
 	gint argc;
@@ -223,7 +252,7 @@
 	if (WIFEXITED (status) && exit_status) {
 		*exit_status = WEXITSTATUS (status);
 	}
-
+#endif
 	return TRUE;
 }
 
@@ -244,6 +273,8 @@
 			gint *standard_error,
 			GError **error)
 {
+#ifdef G_OS_WIN32
+#else
 	pid_t pid;
 	int info_pipe [2];
 	int in_pipe [2] = { -1, -1 };
@@ -411,7 +442,8 @@
 		*standard_output = out_pipe [0];
 	if (standard_error)
 		*standard_error = err_pipe [0];
-
+#endif
 	return TRUE;
 }
 
+
Index: eglib/src/gmisc.c
===================================================================
--- eglib/src/gmisc.c	(revision 76322)
+++ eglib/src/gmisc.c	(working copy)
@@ -29,21 +29,66 @@
 #include <stdlib.h>
 #include <glib.h>
 
+#ifdef G_OS_WIN32
+#include <windows.h>
+#endif
+
 const gchar *
 g_getenv(const gchar *variable)
 {
+#ifdef G_OS_WIN32
+	gunichar2 *var, *buffer;
+	gchar* val = NULL;
+	gint32 buffer_size = 1024;
+	gint32 retval;
+	var = u8to16(variable); 
+	buffer = g_malloc(buffer_size*sizeof(gunichar2));
+	retval = GetEnvironmentVariable (var, buffer, buffer_size);
+	if (retval != 0) {
+		if (retval > buffer_size) {
+			g_free (buffer);
+			buffer_size = retval;
+			buffer = g_malloc(buffer_size*sizeof(gunichar2));
+			retval = GetEnvironmentVariable (var, buffer, buffer_size);
+		}
+		val = u16to8 (buffer);
+	}
+	g_free(var);
+	g_free(buffer);
+	return val; 
+#else
 	return getenv(variable);
+#endif
 }
 
 gboolean
 g_setenv(const gchar *variable, const gchar *value, gboolean overwrite)
 {
+#ifdef G_OS_WIN32
+	gunichar2 *var, *val;
+	gboolean result;
+	var = u8to16(variable); 
+	val = u8to16(value);
+	result = (SetEnvironmentVariable(var, val) != 0) ? TRUE : FALSE;
+	g_free(var);
+	g_free(val);
+	return result;
+#else
 	return setenv(variable, value, overwrite) == 0;
+#endif
 }
 
 void
 g_unsetenv(const gchar *variable)
 {
+#ifdef G_OS_WIN32
+	gunichar2 *var;
+	var = u8to16(variable); 
+	SetEnvironmentVariable(var, TEXT(""));
+	g_free(var);
+#else
 	unsetenv(variable);
+#endif
 }
 
+
Index: eglib/src/ghashtable.c
===================================================================
--- eglib/src/ghashtable.c	(revision 76322)
+++ eglib/src/ghashtable.c	(working copy)
@@ -51,7 +51,7 @@
 	GDestroyNotify value_destroy_func, key_destroy_func;
 };
 
-static const int prime_tbl[] = {
+static const guint prime_tbl[] = {
 	11, 19, 37, 73, 109, 163, 251, 367, 557, 823, 1237,
 	1861, 2777, 4177, 6247, 9371, 14057, 21089, 31627,
 	47431, 71143, 106721, 160073, 240101, 360163,
Index: eglib/src/gpath.c
===================================================================
--- eglib/src/gpath.c	(revision 76322)
+++ eglib/src/gpath.c	(working copy)
@@ -25,23 +25,36 @@
  * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
+#include <config.h>
 #include <stdio.h>
 #include <glib.h>
 #include <errno.h>
 #include <sys/types.h>
 
-#ifndef _MSC_VER
+#ifdef G_OS_UNIX
 #include <pthread.h>
-#include <unistd.h>
+#endif
+
+#ifdef HAVE_PWD_H
 #include <pwd.h>
 #endif
 
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#ifdef G_OS_WIN32
+#include <direct.h>
+#include <io.h>
+#endif
+
+
 gchar *
 g_build_path (const gchar *separator, const gchar *first_element, ...)
 {
 	GString *result;
 	const char *s, *p, *next;
-	int slen;
+	size_t slen;
 	va_list args;
 	
 	g_return_val_if_fail (separator != NULL, NULL);
@@ -80,7 +93,7 @@
 g_path_get_dirname (const gchar *filename)
 {
 	char *p, *r;
-	int count;
+	size_t count;
 	g_return_val_if_fail (filename != NULL, NULL);
 
 	p = strrchr (filename, G_DIR_SEPARATOR);
@@ -139,7 +152,7 @@
 gchar *
 g_find_program_in_path (const gchar *program)
 {
-	char *p = g_strdup (getenv ("PATH"));
+	char *p = g_strdup (g_getenv ("PATH"));
 	char *x = p, *l;
 	gchar *curdir = NULL;
 	char *save;
@@ -156,7 +169,7 @@
 		
 		x = NULL;
 		probe_path = g_build_path (G_DIR_SEPARATOR_S, l, program, NULL);
-		if (access (probe_path, X_OK) == 0){
+		if (access (probe_path, X_OK) == 0){ /* FIXME: on windows this is just a read permissions test */
 			g_free (curdir);
 			g_free (p);
 			return probe_path;
@@ -177,7 +190,7 @@
 	
 	do {
 		buffer = g_realloc (buffer, s);
-		r = getcwd  (buffer, s);
+		r = getcwd (buffer, s);
 		fail = (r == NULL && errno == ERANGE);
 		if (fail) {
 			s <<= 1;
@@ -190,7 +203,7 @@
 #if defined (G_OS_UNIX)
 
 static pthread_mutex_t home_lock = PTHREAD_MUTEX_INITIALIZER;
-static char *home_dir;
+static const gchar *home_dir;
 
 /* Give preference to /etc/passwd than HOME */
 const gchar *
@@ -216,7 +229,7 @@
 			}
 			endpwent ();
 			if (home_dir == NULL)
-				home_dir = getenv ("HOME");
+				home_dir = g_getenv ("HOME");
 			pthread_mutex_unlock (&home_lock);
 		}
 	}
@@ -230,7 +243,18 @@
 g_get_home_dir (void)
 {
 	/* FIXME */
-	return getenv ("HOME");
+	const gchar *drive = g_getenv ("HOMEDRIVE");
+	const gchar *path = g_getenv ("HOMEPATH");
+	gchar *home_dir = NULL;
+	
+	if (drive && path) {
+		home_dir = malloc(strlen(drive) + strlen(path) +1);
+		if (home_dir) {
+			sprintf(home_dir, "%s%s", drive, path);
+		}
+	}
+
+	return home_dir;
 }
 
 #else
@@ -244,10 +268,9 @@
 
 #endif
 
-static char *tmp_dir;
-#ifdef _MSC_VER
-/* FIXME */
-#else
+static const char *tmp_dir;
+
+#ifdef G_OS_UNIX
 static pthread_mutex_t tmp_lock = PTHREAD_MUTEX_INITIALIZER;
 #endif
 
@@ -255,25 +278,25 @@
 g_get_tmp_dir (void)
 {
 	if (tmp_dir == NULL){
-#ifdef _MSC_VER
-/* FIXME */
-#else
+#ifdef G_OS_UNIX
 		pthread_mutex_lock (&tmp_lock);
 #endif
 		if (tmp_dir == NULL){
-			tmp_dir = getenv ("TMPDIR");
+			tmp_dir = g_getenv ("TMPDIR");
 			if (tmp_dir == NULL){
-				tmp_dir = getenv ("TMP");
+				tmp_dir = g_getenv ("TMP");
 				if (tmp_dir == NULL){
-					tmp_dir = getenv ("TEMP");
+					tmp_dir = g_getenv ("TEMP");
 					if (tmp_dir == NULL)
+#if defined (G_OS_WIN32)
+						tmp_dir = "C:\\temp";
+#else
 						tmp_dir = "/tmp";
+#endif
 				}
 			}
 		}
-#ifdef _MSC_VER
-/* FIXME */
-#else
+#ifdef G_OS_UNIX
 		pthread_mutex_unlock (&tmp_lock);
 #endif
 	}
@@ -283,7 +306,7 @@
 const char *
 g_get_user_name (void)
 {
-	return getenv ("USER");
+	return g_getenv ("USER");
 }
 
 static char *name;
Index: eglib/src/gmarkup.c
===================================================================
--- eglib/src/gmarkup.c	(revision 76322)
+++ eglib/src/gmarkup.c	(working copy)
@@ -122,7 +122,7 @@
 		;
 	if (p == end)
 		return end;
-	l = p - start;
+	l = (int)(p - start);
 	p++;
 	*value = malloc (l + 1);
 	if (*value == NULL)
@@ -143,7 +143,7 @@
 	if (p == end)
 		return end;
 
-	l = p - start;
+	l = (int)(p - start);
 	*value = malloc (l + 1);
 	if (*value == NULL)
 		return end;
@@ -311,7 +311,7 @@
 					set_error ("%s", "Unfinished sequence");
 				goto fail;
 			}
-			l = element_end - element_start;
+			l = (int)(element_end - element_start);
 			ename = malloc (l + 1);
 			if (ename == NULL)
 				goto fail;
Index: eglib/src/gptrarray.c
===================================================================
--- eglib/src/gptrarray.c	(revision 76322)
+++ eglib/src/gptrarray.c	(working copy)
@@ -38,7 +38,7 @@
 static void 
 g_ptr_array_grow(GPtrArrayPriv *array, guint length)
 {
-	gint new_length = array->len + length;
+	guint new_length = array->len + length;
 
 	g_return_if_fail(array != NULL);
 
@@ -101,7 +101,7 @@
 {
 	g_return_if_fail(array != NULL);
 
-	if(length > array->len) {
+	if((size_t)length > array->len) {
 		g_ptr_array_grow((GPtrArrayPriv *)array, length);
 		memset(array->pdata + array->len, 0, (length - array->len) 
 			* sizeof(gpointer));
@@ -159,7 +159,7 @@
 void 
 g_ptr_array_foreach(GPtrArray *array, GFunc func, gpointer user_data)
 {
-	gint i;
+	guint i;
 
 	for(i = 0; i < array->len; i++) {
 		func(g_ptr_array_index(array, i), user_data);
@@ -180,3 +180,4 @@
 }
 
 
+
Index: eglib/src/gstr.c
===================================================================
--- eglib/src/gstr.c	(revision 76322)
+++ eglib/src/gstr.c	(working copy)
@@ -26,6 +26,7 @@
  * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
+#include <config.h>
 #include <stdio.h>
 #include <string.h>
 #include <ctype.h>
@@ -35,7 +36,18 @@
 gchar *
 g_strndup (const gchar *str, gsize n)
 {
+#ifdef HAVE_STRNDUP
 	return strndup (str, n);
+#else
+	if (str) {
+		char *retval = malloc(n);
+		if (retval) {
+			strncpy(retval, str, n)[n] = 0;
+		}
+		return retval;
+	}
+	return NULL;
+#endif
 }
 
 void
@@ -63,8 +75,8 @@
 gboolean
 g_str_has_suffix(const gchar *str, const gchar *suffix)
 {
-	gint str_length;
-	gint suffix_length;
+	size_t str_length;
+	size_t suffix_length;
 	
 	g_return_val_if_fail(str != NULL, FALSE);
 	g_return_val_if_fail(suffix != NULL, FALSE);
@@ -80,8 +92,8 @@
 gboolean
 g_str_has_prefix(const gchar *str, const gchar *prefix)
 {
-	gint str_length;
-	gint prefix_length;
+	size_t str_length;
+	size_t prefix_length;
 	
 	g_return_val_if_fail(str != NULL, FALSE);
 	g_return_val_if_fail(prefix != NULL, FALSE);
@@ -133,7 +145,7 @@
 g_strconcat (const gchar *first, ...)
 {
 	va_list args;
-	int total = 0;
+	size_t total = 0;
 	char *s, *ret;
 	g_return_val_if_fail (first != NULL, NULL);
 
@@ -166,7 +178,7 @@
 	gchar *strtok_save, **vector;
 	gchar *token, *token_c;
 	gint size = 1;
-	gint token_length;
+	size_t token_length;
 
 	g_return_val_if_fail(string != NULL, NULL);
 	g_return_val_if_fail(delimiter != NULL, NULL);
@@ -227,8 +239,8 @@
 gchar *
 g_strreverse (gchar *str)
 {
-	guint len, half;
-	gint i;
+	size_t len, half;
+	size_t i;
 	gchar c;
 
 	if (str == NULL)
@@ -250,7 +262,7 @@
 {
 	va_list args;
 	char *res, *s;
-	int len, slen;
+	size_t len, slen;
 
 	if (separator != NULL)
 		slen = strlen (separator);
@@ -288,7 +300,7 @@
 g_strjoinv (const gchar *separator, gchar **str_array)
 {
 	char *res;
-	int slen, len, i;
+	size_t slen, len, i;
 	
 	if (separator != NULL)
 		slen = strlen (separator);
@@ -318,7 +330,7 @@
 gchar *
 g_strchug (gchar *str)
 {
-	gint len;
+	size_t len;
 	gchar *tmp;
 
 	if (str == NULL)
@@ -399,7 +411,7 @@
 	return ret;
 }
 
-static const char const hx [] = { '0', '1', '2', '3', '4', '5', '6', '7',
+static const char hx [] = { '0', '1', '2', '3', '4', '5', '6', '7',
 				  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
 
 static gboolean
@@ -419,7 +431,7 @@
 gchar *
 g_filename_to_uri (const gchar *filename, const gchar *hostname, GError **error)
 {
-	int n;
+	size_t n;
 	char *ret, *rp;
 	const char *p;
 	
@@ -507,7 +519,7 @@
 
 	for (p = uri + 8, r = result + 1; *p; p++){
 		if (*p == '%'){
-			*r++ = (decode (p [1]) << 4) | decode (p [2]);
+			*r++ = (char)((decode (p [1]) << 4) | decode (p [2]));
 			p += 2;
 		} else
 			*r++ = *p;
@@ -522,7 +534,7 @@
 	g_return_if_fail (string != NULL);
 
 	while (*string){
-		*string = tolower (*string);
+		*string = (gchar)tolower (*string);
 		string++;
 	}
 }
@@ -553,7 +565,7 @@
 gint
 g_ascii_strncasecmp (const gchar *s1, const gchar *s2, gsize n)
 {
-	int i;
+	gsize i;
 	
 	g_return_val_if_fail (s1 != NULL, 0);
 	g_return_val_if_fail (s2 != NULL, 0);
@@ -592,10 +604,12 @@
 	return string;
 }
 
-#ifndef HAVE_STRLCPY
 gsize 
 g_strlcpy (gchar *dest, const gchar *src, gsize dest_size)
 {
+#ifdef HAVE_STRLCPY
+	return strlcpy (dest, src, dest_size);
+#else
 	gchar *d;
 	const gchar *s;
 	gchar c;
@@ -622,8 +636,8 @@
 	/* we need to return the length of src here */
 	while (*s++) ; /* instead of a plain strlen, we use 's' */
 	return s - src - 1;
+#endif
 }
-#endif
 
 static const gchar escaped_dflt [256] = {
 	1, 1, 1, 1, 1, 1, 1, 1, 'b', 't', 'n', 1, 'f', 'r', 1, 1,
@@ -650,7 +664,7 @@
 	gchar escaped [256];
 	const gchar *ptr;
 	gchar c;
-	int op;
+	gchar op;
 	gchar *result;
 	gchar *res_ptr;
 
@@ -702,3 +716,4 @@
 }
 
 
+
Index: eglib/src/glib.h
===================================================================
--- eglib/src/glib.h	(revision 76322)
+++ eglib/src/glib.h	(working copy)
@@ -7,16 +7,21 @@
 #include <stdio.h>
 #include <stddef.h>
 #include <ctype.h>
-#ifndef _MSC_VER
+
+#ifdef _MSC_VER
+#pragma include_alias(<eglib-config.h>, <eglib-config.hw>)
+#else
 #include <stdint.h>
-#include <eglib-config.h>
 #endif
 
+#include <eglib-config.h>
+
 #ifndef offsetof
 #   define offsetof(s_name,n_name) (size_t)(char *)&(((s_name*)0)->m_name)
 #endif
 
 #define __EGLIB_X11 1
+
 /*
  * Basic data types
  */
@@ -44,51 +49,6 @@
 typedef float				gfloat;
 typedef double				gdouble;
 typedef unsigned __int16	gunichar2;
-/*
- * System-dependent settings
- */
-/*
-#define G_GNUC_PRETTY_FUNCTION   @GNUC_PRETTY@
-#define G_GNUC_UNUSED            @GNUC_UNUSED@
-#define G_BYTE_ORDER             @ORDER@
-#define G_GNUC_NORETURN          @GNUC_NORETURN@
-#define G_BREAKPOINT()           @BREAKPOINT@
-#define G_OS_@OS@
-#define GPOINTER_TO_INT(ptr)   @GPOINTER_TO_INT@
-#define GPOINTER_TO_UINT(ptr)  @GPOINTER_TO_UINT@
-#define GINT_TO_POINTER(v)     @GINT_TO_POINTER@
-#define GUINT_TO_POINTER(v)    @GUINT_TO_POINTER@
-*/
-typedef uintptr_t gsize;
-typedef intptr_t gssize;
-typedef int pid_t;
-
-#define G_DIR_SEPARATOR          '\\'
-#define G_DIR_SEPARATOR_S        "\\"
-#define G_SEARCHPATH_SEPARATOR_S ";"
-#define G_SEARCHPATH_SEPARATOR   ';'
-#define G_GSIZE_FORMAT   "d"
-#define G_GUINT64_FORMAT "d"
-
-#define INT32_MAX 2147483647
-#define INT32_MIN (~ INT32_MAX)
-#define INT64_MAX 9223372036854775807i64
-#define INT64_MIN (~INT64_MAX)
-
-#define STDOUT_FILENO stdout
-#define STDERR_FILENO stderr
-
-/* FIXME: what should this be ?*/
-#define X_OK 1
-#define WNOHANG 1
-#define F_SETFD 1
-#define FD_CLOEXEC 1
-
-#undef inline
-#define inline __inline
-
-#define G_OS_WIN32 1
-
 #else
 /* Types defined in terms of the stdint.h */
 typedef int8_t         gint8;
@@ -103,6 +63,7 @@
 typedef double         gdouble;
 typedef uint16_t       gunichar2;
 #endif
+
 /*
  * Macros
  */
@@ -273,11 +234,7 @@
 #define g_vsnprintf vsnprintf
 #define g_vasprintf vasprintf
 
-#ifdef HAVE_STRLCPY
-#define g_strlcpy	strlcpy
-#else
 gsize       g_strlcpy          (gchar *dest, const gchar *src, gsize dest_size);
-#endif
 
 gchar  *g_ascii_strdown      (const gchar *str, gssize len);
 gint    g_ascii_strncasecmp  (const gchar *s1, const gchar *s2, gsize n);
@@ -288,11 +245,19 @@
 #define g_ascii_isxdigit(c)  (isxdigit (c) != 0)
 
 /* FIXME: g_strcasecmp supports utf8 unicode stuff */
+#ifdef _MSC_VER
+#define g_strcasecmp stricmp
+#define g_ascii_strcasecmp stricmp
+#define g_strncasecmp strnicmp
+#define g_strstrip(a) g_strchug (g_strchomp (a))
+#else
 #define g_strcasecmp strcasecmp
 #define g_ascii_strcasecmp strcasecmp
 #define g_strncasecmp strncasecmp
 #define g_strstrip(a) g_strchug (g_strchomp (a))
+#endif
 
+
 #define	G_STR_DELIMITERS "_-|> <."
 
 /*
@@ -559,6 +524,14 @@
 gunichar2 *g_utf8_to_utf16 (const gchar *str, glong len, glong *items_read, glong     *items_written, GError **error);
 gchar     *g_utf16_to_utf8 (const gunichar2 *str, glong len, glong *items_read, glong     *items_written, GError **error);
 
+#define u8to16(str) g_utf8_to_utf16(str, (glong)strlen(str), NULL, NULL, NULL)
+
+#ifdef G_OS_WIN32
+#define u16to8(str) g_utf16_to_utf8(str, (glong)wcslen(str), NULL, NULL, NULL)
+#else
+#define u16to8(str) g_utf16_to_utf8(str, (glong)strlen(str), NULL, NULL, NULL)
+#endif
+
 /*
  * Path
  */
@@ -797,3 +770,4 @@
  
 #endif
 
+
Index: eglib/src/gdate.c
===================================================================
--- eglib/src/gdate.c	(revision 76322)
+++ eglib/src/gdate.c	(working copy)
@@ -28,7 +28,7 @@
 #include <stdio.h>
 #include <glib.h>
 
-#ifdef _MSC_VER
+#ifdef G_OS_WIN32
 #include <winsock2.h>
 #else
 #include <sys/time.h>
@@ -37,11 +37,19 @@
 void
 g_get_current_time (GTimeVal *result)
 {
+#ifdef G_OS_WIN32
+	long int l = GetTickCount();
+
+	g_return_if_fail (result != NULL);
+
+	result->tv_sec = l / 1000;
+	result->tv_usec = (l % 1000) * 1000;
+#else
 	struct timeval tv;
 
 	g_return_if_fail (result != NULL);
 	gettimeofday (&tv, NULL);
 	result->tv_sec = tv.tv_sec;
 	result->tv_usec = tv.tv_usec;
+#endif
 }
-
Index: eglib/src/gpattern.c
===================================================================
--- eglib/src/gpattern.c	(revision 76322)
+++ eglib/src/gpattern.c	(working copy)
@@ -53,7 +53,7 @@
 compile_pattern (const gchar *pattern)
 {
 	GSList *list;
-	gint i, len;
+	size_t i, len;
 	PData *data;
 	gchar c;
 	MatchType last = -1;
@@ -157,9 +157,9 @@
 }
 
 static gboolean
-match_string (GSList *list, const gchar *str, gint idx, gint max)
+match_string (GSList *list, const gchar *str, size_t idx, size_t max)
 {
-	gint len;
+	size_t len;
 
 	while (list && idx < max) {
 		PData *data = (PData *) list->data;
@@ -209,3 +209,4 @@
 	return match_string (pspec->pattern, string, 0, strlen (string));
 }
 
+
Index: eglib/src/gdir.c
===================================================================
--- eglib/src/gdir.c	(revision 76322)
+++ eglib/src/gdir.c	(working copy)
@@ -34,12 +34,19 @@
 #ifndef _MSC_VER
 #include <unistd.h>
 #include <dirent.h>
+#else
+#include <io.h>
 #endif
 
+#ifdef G_OS_WIN32
+#include <winsock2.h>
+#endif
+
 struct _GDir {
 #ifdef G_OS_WIN32
-	/* FIXME */
-	int dir;
+	HANDLE handle;
+	gchar* current;
+	gchar* next;
 #else
 	DIR *dir;
 #endif
@@ -49,7 +56,54 @@
 g_dir_open (const gchar *path, guint flags, GError **error)
 {
 #ifdef G_OS_WIN32
-	return NULL;
+	GDir *dir;
+	gunichar2* path_utf16;
+	gunichar2* path_utf16_search;
+	WIN32_FIND_DATA find_data;
+
+	g_return_val_if_fail (path != NULL, NULL);
+	g_return_val_if_fail (error == NULL || *error == NULL, NULL);
+	dir = g_new0 (GDir, 1);
+
+	path_utf16 = u8to16 (path);
+
+	dir->handle = FindFirstFile (path_utf16, &find_data);
+	if (dir->handle == INVALID_HANDLE_VALUE) {
+		if (error) {
+			gint err = errno;
+			*error = g_error_new (G_LOG_DOMAIN, g_file_error_from_errno (err), strerror (err));
+		}
+		g_free (dir);
+		g_free (path_utf16);
+		return NULL;
+	}
+
+	/* now get files */
+	FindClose (dir->handle);
+	path_utf16_search = g_malloc ((wcslen(path_utf16) + 3)*sizeof(gunichar2));
+	wcscpy (path_utf16_search, path_utf16);
+	wcscat (path_utf16_search, L"\\*");
+
+	dir->handle = FindFirstFile (path_utf16_search, &find_data);
+	g_free (path_utf16_search);
+
+	while ((wcscmp (find_data.cFileName, L".") == 0) || (wcscmp (find_data.cFileName, L"..") == 0)) {
+		if (!FindNextFile (dir->handle, &find_data)) {
+			if (error) {
+				gint err = errno;
+				*error = g_error_new (G_LOG_DOMAIN, g_file_error_from_errno (err), strerror (err));
+			}
+			g_free (dir);
+			g_free (path_utf16);
+			return NULL;
+		}
+	}
+
+	dir->current = NULL;
+	dir->next = u16to8 (find_data.cFileName);
+
+	g_free (path_utf16);
+	return dir;
 #else
 	GDir *dir;
 
@@ -75,7 +129,30 @@
 g_dir_read_name (GDir *dir)
 {
 #ifdef G_OS_WIN32
-	return NULL;
+	WIN32_FIND_DATA find_data;
+
+	g_return_val_if_fail (dir != NULL && dir->handle != 0, NULL);
+
+	if (dir->current)
+		g_free (dir->current);
+	dir->current = NULL;
+
+	dir->current = dir->next;
+
+	if (!dir->current)
+		return NULL;
+
+	dir->next = NULL;
+
+	do {
+		if (!FindNextFile (dir->handle, &find_data)) {
+			dir->next = NULL;
+			return dir->current;
+		}
+	} while ((wcscmp (find_data.cFileName, L".") == 0) || (wcscmp (find_data.cFileName, L"..") == 0));
+
+	dir->next = u16to8 (find_data.cFileName);
+	return dir->current;
 #else
 	struct dirent *entry;
 
@@ -104,11 +181,23 @@
 g_dir_close (GDir *dir)
 {
 #ifdef G_OS_WIN32
+	g_return_if_fail (dir != NULL && dir->handle != 0);
+	
+	if (dir->current)
+		g_free (dir->current);
+	dir->current = NULL;
+	if (dir->next)
+		g_free (dir->next);
+	dir->next = NULL;
+	FindClose (dir->handle);
+	dir->handle = 0;
+	g_free (dir);
 #else
-	g_return_if_fail (dir != NULL && dir->dir != NULL);
+	g_return_if_fail (dir != NULL && dir->dir != 0);
 	closedir (dir->dir);
 	dir->dir = NULL;
 	g_free (dir);
 #endif
 }
 
+
Index: eglib/src/gfile.c
===================================================================
--- eglib/src/gfile.c	(revision 76322)
+++ eglib/src/gfile.c	(working copy)
@@ -25,6 +25,7 @@
  * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
+#include <config.h>
 #include <glib.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -32,10 +33,15 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
-#ifdef _MSC_VER
+
+#ifdef G_OS_WIN32
 #include <io.h>
 #define open _open
-#else
+#define S_ISREG(x) ((x &  _S_IFMT) == _S_IFREG)
+#define S_ISDIR(x) ((x &  _S_IFMT) == _S_IFDIR)
+#endif
+
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
@@ -158,13 +164,35 @@
 	return TRUE;
 }
 
+#ifdef _MSC_VER
+int mkstemp (char *tmp_template)
+{
+	int fd;
+	gunichar2* utf16_template;
+
+	utf16_template  = u8to16 (tmp_template);
+
+	fd = -1;
+	utf16_template = _wmktemp( utf16_template);
+	if (utf16_template && *utf16_template) {
+		/* FIXME: _O_TEMPORARY causes file to disappear on close causing a test to fail */
+		fd = _wopen( utf16_template, _O_BINARY | _O_CREAT /*| _O_TEMPORARY*/ | _O_EXCL, _S_IREAD | _S_IWRITE);
+	}
+
+	sprintf (tmp_template + strlen (tmp_template) - 6, "%S", utf16_template + wcslen (utf16_template) - 6);
+
+	g_free (utf16_template);
+	return fd;
+}
+#endif
+
 gint
 g_file_open_tmp (const gchar *tmpl, gchar **name_used, GError **error)
 {
 	const static gchar *default_tmpl = ".XXXXXX";
 	gchar *t;
 	gint fd;
-	gint len;
+	size_t len;
 
 	g_return_val_if_fail (error == NULL || *error == NULL, -1);
 
@@ -187,7 +215,9 @@
 	}
 
 	t = g_build_filename (g_get_tmp_dir (), tmpl, NULL);
+
 	fd = mkstemp (t);
+
 	if (fd == -1) {
 		if (error) {
 			int err = errno;
@@ -205,9 +235,55 @@
 	return fd;
 }
 
+#ifdef _MSC_VER
+#pragma warning(disable:4701)
+#endif
+
 gboolean
 g_file_test (const gchar *filename, GFileTest test)
 {
+#ifdef G_OS_WIN32
+	struct _stat64 stat;
+	int ret = 0;
+	gunichar2* utf16_filename = NULL;
+
+	if (filename == NULL || test == 0)
+		return FALSE;
+
+	utf16_filename = u8to16 (filename);
+	ret = _wstati64 (utf16_filename, &stat);
+	g_free (utf16_filename);
+
+	if ((test & G_FILE_TEST_EXISTS) != 0) {
+		if (ret == 0)
+			return TRUE;
+	}
+
+	if (ret != 0)
+		return FALSE;
+
+	if ((test & G_FILE_TEST_IS_EXECUTABLE) != 0) {
+		if (stat.st_mode & _S_IEXEC)
+			return TRUE;
+	}
+
+	if ((test & G_FILE_TEST_IS_REGULAR) != 0) {
+		if (stat.st_mode & _S_IFREG)
+			return TRUE;
+	}
+
+	if ((test & G_FILE_TEST_IS_DIR) != 0) {
+		if (stat.st_mode & _S_IFDIR)
+			return TRUE;
+	}
+
+	/* make this last in case it is OR'd with something else */
+	if ((test & G_FILE_TEST_IS_SYMLINK) != 0) {
+		return FALSE;
+	}
+
+	return FALSE;
+#else
 	struct stat st;
 	gboolean have_stat;
 
@@ -215,8 +291,7 @@
 		return FALSE;
 
 	have_stat = FALSE;
-#ifdef G_OS_WIN32
-#else
+
 	if ((test & G_FILE_TEST_EXISTS) != 0) {
 		if (access (filename, F_OK) == 0)
 			return TRUE;
@@ -231,7 +306,6 @@
 		if (have_stat && S_ISLNK (st.st_mode))
 			return TRUE;
 	}
-#endif
 
 	if ((test & G_FILE_TEST_IS_REGULAR) != 0) {
 		if (!have_stat)
@@ -246,5 +320,7 @@
 			return TRUE;
 	}
 	return FALSE;
+#endif
 }
 
+
Index: eglib/src/gtimer.c
===================================================================
--- eglib/src/gtimer.c	(revision 76322)
+++ eglib/src/gtimer.c	(working copy)
@@ -27,14 +27,19 @@
  */
 #include <glib.h>
 #ifdef _MSC_VER
-#include <winsock2.h>
+#include <windows.h>
 #else
 #include <sys/time.h>
 #endif
 
 struct _GTimer {
+#ifdef _MSC_VER
+	guint64 start;
+	guint64 stop;
+#else
 	struct timeval start;
 	struct timeval stop;
+#endif
 };
 
 GTimer *g_timer_new (void)
@@ -57,23 +62,51 @@
 g_timer_start (GTimer *timer)
 {
 	g_return_if_fail (timer != NULL);
+#ifdef _MSC_VER
+	QueryPerformanceCounter ((LARGE_INTEGER*)&timer->start);
+#else
 	gettimeofday (&timer->start, NULL);
 	memset (&timer->stop, 0, sizeof (struct timeval));
+#endif
+
 }
 
 void
 g_timer_stop (GTimer *timer)
 {
 	g_return_if_fail (timer != NULL);
+#ifdef _MSC_VER
+	QueryPerformanceCounter ((LARGE_INTEGER*)&timer->stop);
+#else
 	gettimeofday (&timer->stop, NULL);
+#endif
 }
 
 gdouble
 g_timer_elapsed (GTimer *timer, gulong *microseconds)
 {
+#ifdef _MSC_VER
+	guint64 stop;
+	guint64 freq;
+	gdouble seconds;
+	if (timer->stop == 0) {
+		QueryPerformanceCounter ((LARGE_INTEGER*)&stop);
+	}
+	else {
+		stop = timer->stop;
+	}
+
+	QueryPerformanceFrequency ((LARGE_INTEGER*)&freq);
+	seconds = 1.0 * (stop - timer->start) / freq;
+
+	if (microseconds) {
+		*microseconds = (gulong)(1000000.0 * (stop - timer->start) / freq);
+	}
+	return seconds;
+#else
 	struct timeval tv;
 	gulong seconds;
-	gulong usec;
+	long usec;
 	gdouble result;
 
 	g_return_val_if_fail (timer != NULL, 0.0);
@@ -84,7 +117,7 @@
 		tv = timer->stop;
 	}
 
-	usec = tv.tv_usec - timer->start.tv_usec;
+	usec = (tv.tv_usec) - (timer->start.tv_usec);
 	seconds = tv.tv_sec - timer->start.tv_sec;
 	if (microseconds) {
 		if (usec < 0) {
@@ -95,5 +128,7 @@
 	}
 	result = seconds * 1000000 + usec;
 	return (result / 1000000);
+#endif
 }
 
+
Index: eglib/src/gmodule.c
===================================================================
--- eglib/src/gmodule.c	(revision 76322)
+++ eglib/src/gmodule.c	(working copy)
@@ -118,8 +118,11 @@
 		return NULL;
 
 	if (file != NULL) {
+		gunichar2 *file16;
+		file16 = u8to16(file); 
 		module->main_module = FALSE;
-		module->handle = LoadLibrary (file);
+		module->handle = LoadLibrary (file16);
+		g_free(file16);
 		if (!module->handle) {
 			g_free (module);
 			return NULL;
@@ -169,7 +172,7 @@
 	}
 
 	for (i = 0; i < needed / sizeof (HANDLE); i++) {
-		gpointer proc = GetProcAddress (modules [i], symbol_name);
+		gpointer proc = (gpointer)(intptr_t)GetProcAddress (modules [i], symbol_name);
 		if (proc != NULL) {
 			g_free (modules);
 			return proc;
@@ -187,14 +190,14 @@
 		return FALSE;
 
 	if (module->main_module) {
-		*symbol = GetProcAddress (module->handle, symbol_name);
+		*symbol = (gpointer)(intptr_t)GetProcAddress (module->handle, symbol_name);
 		if (*symbol != NULL)
 			return TRUE;
 
 		*symbol = w32_find_symbol (symbol_name);
 		return *symbol != NULL;
 	} else {
-		*symbol = GetProcAddress (module->handle, symbol_name);
+		*symbol = (gpointer)(intptr_t)GetProcAddress (module->handle, symbol_name);
 		return *symbol != NULL;
 	}
 }
@@ -209,7 +212,7 @@
 	FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL, 
 		code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buf, 0, NULL);
 
-	ret = g_strdup (buf);
+	ret = u16to8 (buf);
 	LocalFree(buf);
 
 	return ret;
Index: eglib/src/gunicode.c
===================================================================
--- eglib/src/gunicode.c	(revision 76322)
+++ eglib/src/gunicode.c	(working copy)
@@ -67,11 +67,14 @@
 	   const gchar *to_codeset, const gchar *from_codeset,
 	   gsize *bytes_read, gsize *bytes_written, GError **error)
 {
+	char *result = NULL;
+#ifdef G_OS_WIN32
+#else
 	iconv_t convertor;
-	char *buffer, *result, *output;
+	char *buffer, *output;
 	const char *strptr = (const char *) str;
-	int str_len = len == -1 ? strlen (str) : len;
-	int buffer_size;
+	size_t str_len = len == -1 ? strlen (str) : len;
+	size_t buffer_size;
 	size_t left, out_left;
 	
 	convertor = iconv_open (to_codeset, from_codeset);
@@ -91,8 +94,8 @@
 		if (res == (size_t) -1){
 			if (errno == E2BIG){
 				char *n;
-				int extra_space = 8 + left;
-				int output_used = output - buffer;
+				size_t extra_space = 8 + left;
+				size_t output_used = output - buffer;
 				
 				buffer_size += extra_space;
 				
@@ -131,6 +134,7 @@
 	result = buffer;
  leave:
 	iconv_close (convertor);
+#endif
 	return result;
 }
 
@@ -153,6 +157,8 @@
 gboolean
 g_get_charset (G_CONST_RETURN char **charset)
 {
+#ifdef G_OS_WIN32
+#else
 	if (my_charset == NULL){
 		my_charset = g_strdup (nl_langinfo (CODESET));
 		is_utf8 = strcmp (my_charset, "UTF-8") == 0;
@@ -161,6 +167,7 @@
 	if (charset != NULL)
 		*charset = my_charset;
 
+#endif
 	return is_utf8;
 }
 
Index: eglib/src/gutf8.c
===================================================================
--- eglib/src/gutf8.c	(revision 76322)
+++ eglib/src/gutf8.c	(working copy)
@@ -86,12 +86,12 @@
 				if (--mb_remain == 0) {
 					/* multi byte character is fully consumed now. */
 					if (codepoint < 0x10000) {
-						ret [out_pos++] = codepoint % 0x10000;
+						ret [out_pos++] = (gunichar2)(codepoint % 0x10000);
 					} else if (codepoint < 0x110000) {
 						/* surrogate pair */
 						codepoint -= 0x10000;
-						ret [out_pos++] = (codepoint >> 10) + 0xD800;
-						ret [out_pos++] = (codepoint & 0x3FF) + 0xDC00;
+						ret [out_pos++] = (gunichar2)((codepoint >> 10) + 0xD800);
+						ret [out_pos++] = (gunichar2)((codepoint & 0x3FF) + 0xDC00);
 					} else {
 						/* invalid utf-8 sequence (excess) */
 						codepoint = 0;
@@ -247,7 +247,7 @@
 	gchar *ret;
 	glong in_pos, out_pos;
 	gunichar2 ch;
-	guint32 codepoint;
+	guint32 codepoint = 0;
 	gboolean surrogate;
 
 	in_pos = 0;
@@ -279,7 +279,7 @@
 			if (ch < 0x80) {
 				for (; len < 0 ? str [in_pos] : in_pos < len; in_pos++) {
 					if (str [in_pos] < 0x80)
-						ret [out_pos++] = str [in_pos];
+						ret [out_pos++] = (gchar)(str [in_pos]);
 					else
 						break;
 				}
Index: eglib/winconfig.h
===================================================================
--- eglib/winconfig.h	(revision 0)
+++ eglib/winconfig.h	(revision 0)
@@ -0,0 +1,74 @@
+/* config.h.  Generated by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <pwd.h> header file. */
+/* #undef HAVE_PWD_H 1 */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+/* #undef HAVE_STRLCPY */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+/* #undef HAVE_SYS_TIME_H */
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+/* #undef HAVE_SYS_WAIT_H */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+/* #undef HAVE_UNISTD_H */
+
+/* Name of package */
+#define PACKAGE "eglib"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* The size of a `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of a `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 4
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "0.1"

Property changes on: eglib/winconfig.h
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Index: msvc/test_eglib.vcproj
===================================================================
--- msvc/test_eglib.vcproj	(revision 76312)
+++ msvc/test_eglib.vcproj	(working copy)
@@ -43,7 +43,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="../eglib/src;../eglib/test;../msvc"
+				AdditionalIncludeDirectories="../eglib/src;../eglib/test;../eglib;../msvc"
 				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;_FORTIFY_SOURCE=2"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -97,12 +97,11 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Release|Win32"
+			Name="Debug|x64"
 			OutputDirectory="./bin/$(ProjectName)/$(PlatformName)/$(ConfigurationName)"
 			IntermediateDirectory="./obj/$(ProjectName)/$(PlatformName)/$(ConfigurationName)"
 			ConfigurationType="1"
 			CharacterSet="1"
-			WholeProgramOptimization="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -118,12 +117,16 @@
 			/>
 			<Tool
 				Name="VCMIDLTool"
+				TargetEnvironment="3"
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="../eglib/src;../eglib/test;../msvc"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;_FORTIFY_SOURCE=2"
-				RuntimeLibrary="2"
+				Optimization="0"
+				AdditionalIncludeDirectories="../eglib/src;../eglib/test;../eglib;../msvc"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;_FORTIFY_SOURCE=2"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
 				UsePrecompiledHeader="0"
 				WarningLevel="4"
 				WarnAsError="true"
@@ -142,6 +145,11 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalDependencies="Ws2_32.lib Psapi.lib"
+				GenerateDebugInformation="true"
+				OptimizeReferences="1"
+				EnableCOMDATFolding="1"
+				OptimizeForWindows98="1"
+				TargetMachine="17"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -169,11 +177,12 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Debug|x64"
+			Name="Release|Win32"
 			OutputDirectory="./bin/$(ProjectName)/$(PlatformName)/$(ConfigurationName)"
 			IntermediateDirectory="./obj/$(ProjectName)/$(PlatformName)/$(ConfigurationName)"
 			ConfigurationType="1"
 			CharacterSet="1"
+			WholeProgramOptimization="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -189,16 +198,12 @@
 			/>
 			<Tool
 				Name="VCMIDLTool"
-				TargetEnvironment="3"
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../eglib/src;../eglib/test;../msvc"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;_FORTIFY_SOURCE=2"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
+				AdditionalIncludeDirectories="../eglib/src;../eglib/test;../eglib;../msvc"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;_FORTIFY_SOURCE=2"
+				RuntimeLibrary="2"
 				UsePrecompiledHeader="0"
 				WarningLevel="4"
 				WarnAsError="true"
@@ -217,11 +222,6 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalDependencies="Ws2_32.lib Psapi.lib"
-				GenerateDebugInformation="true"
-				OptimizeReferences="1"
-				EnableCOMDATFolding="1"
-				OptimizeForWindows98="1"
-				TargetMachine="17"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -274,7 +274,7 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="../eglib/src;../eglib/test;../msvc"
+				AdditionalIncludeDirectories="../eglib/src;../eglib/test;../eglib;../msvc"
 				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE;_FORTIFY_SOURCE=2"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="0"
@@ -364,10 +364,6 @@
 				>
 			</File>
 			<File
-				RelativePath="..\eglib\src\gettimeofday.c"
-				>
-			</File>
-			<File
 				RelativePath="..\eglib\test\hashtable.c"
 				>
 			</File>
Index: msvc/getopt.c
===================================================================
--- msvc/getopt.c	(revision 0)
+++ msvc/getopt.c	(revision 0)
@@ -0,0 +1,123 @@
+/* $PostgreSQL: pgsql/src/port/getopt.c,v 1.11 2007/03/26 21:44:11 momjian Exp $ */
+
+/* This is used by psql under Win32 */
+
+/*
+ * Copyright (c) 1987, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *	  may be used to endorse or promote products derived from this software
+ *	  without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.	IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#ifdef _MSC_VER
+/* disable the following warnings 
+ * C4706: assignment within conditional expression
+*/
+#pragma warning(disable:4706)
+#endif
+
+
+
+int			opterr = 1,			/* if error message should be printed */
+			optind = 1,			/* index into parent argv vector */
+			optopt,				/* character checked for validity */
+			optreset;			/* reset getopt */
+char	   *optarg;				/* argument associated with option */
+
+#define BADCH	(int)'?'
+#define BADARG	(int)':'
+#define EMSG	""
+
+/*
+ * getopt
+ *	Parse argc/argv argument vector.
+ */
+int
+getopt(int nargc, char * const *nargv, const char *ostr)
+{
+	static char *place = EMSG;	/* option letter processing */
+	char	   *oli;			/* option letter list index */
+
+	if (optreset || !*place)
+	{							/* update scanning pointer */
+		optreset = 0;
+		if (optind >= nargc || *(place = nargv[optind]) != '-')
+		{
+			place = EMSG;
+			return -1;
+		}
+		if (place[1] && *++place == '-' && place[1] == '\0')
+		{						/* found "--" */
+			++optind;
+			place = EMSG;
+			return -1;
+		}
+	}							/* option letter okay? */
+	if ((optopt = (int) *place++) == (int) ':' ||
+		!(oli = strchr(ostr, optopt)))
+	{
+		/*
+		 * if the user didn't specify '-' as an option, assume it means -1.
+		 */
+		if (optopt == (int) '-')
+			return -1;
+		if (!*place)
+			++optind;
+		if (opterr && *ostr != ':')
+			(void) fprintf(stderr,
+						   "illegal option -- %c\n", optopt);
+		return BADCH;
+	}
+	if (*++oli != ':')
+	{							/* don't need argument */
+		optarg = NULL;
+		if (!*place)
+			++optind;
+	}
+	else
+	{							/* need an argument */
+		if (*place)				/* no white space */
+			optarg = place;
+		else if (nargc <= ++optind)
+		{						/* no arg */
+			place = EMSG;
+			if (*ostr == ':')
+				return BADARG;
+			if (opterr)
+				(void) fprintf(stderr,
+							   "option requires an argument -- %c\n",
+							   optopt);
+			return BADCH;
+		}
+		else
+			/* white space */
+			optarg = nargv[optind];
+		place = EMSG;
+		++optind;
+	}
+	return optopt;				/* dump back option letter */
+}
\ No newline at end of file

Property changes on: msvc/getopt.c
___________________________________________________________________
Name: svn:eol-style
   + native

Index: msvc/eglib.vcproj
===================================================================
--- msvc/eglib.vcproj	(revision 76312)
+++ msvc/eglib.vcproj	(working copy)
@@ -27,6 +27,7 @@
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
+				CommandLine="copy ..\eglib\winconfig.h ..\eglib\config.h"
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
@@ -43,7 +44,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="../eglib/src"
+				AdditionalIncludeDirectories="../eglib/src;../eglib"
 				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -83,15 +84,15 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Release|Win32"
+			Name="Debug|x64"
 			OutputDirectory="./bin/$(ProjectName)/$(PlatformName)/$(ConfigurationName)"
 			IntermediateDirectory="./obj/$(ProjectName)/$(PlatformName)/$(ConfigurationName)"
 			ConfigurationType="4"
 			CharacterSet="1"
-			WholeProgramOptimization="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
+				CommandLine="copy ..\eglib\winconfig.h ..\eglib\config.h"
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
@@ -104,12 +105,16 @@
 			/>
 			<Tool
 				Name="VCMIDLTool"
+				TargetEnvironment="3"
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="../eglib/src"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE"
-				RuntimeLibrary="2"
+				Optimization="0"
+				AdditionalIncludeDirectories="../eglib/src;../eglib"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
 				UsePrecompiledHeader="0"
 				WarningLevel="4"
 				WarnAsError="true"
@@ -145,14 +150,16 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Debug|x64"
+			Name="Release|Win32"
 			OutputDirectory="./bin/$(ProjectName)/$(PlatformName)/$(ConfigurationName)"
 			IntermediateDirectory="./obj/$(ProjectName)/$(PlatformName)/$(ConfigurationName)"
 			ConfigurationType="4"
 			CharacterSet="1"
+			WholeProgramOptimization="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
+				CommandLine="copy ..\eglib\winconfig.h ..\eglib\config.h"
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
@@ -165,16 +172,12 @@
 			/>
 			<Tool
 				Name="VCMIDLTool"
-				TargetEnvironment="3"
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../eglib/src"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
+				AdditionalIncludeDirectories="../eglib/src;../eglib"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE"
+				RuntimeLibrary="2"
 				UsePrecompiledHeader="0"
 				WarningLevel="4"
 				WarnAsError="true"
@@ -219,6 +222,7 @@
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
+				CommandLine="copy ..\eglib\winconfig.h ..\eglib\config.h"
 			/>
 			<Tool
 				Name="VCCustomBuildTool"
@@ -235,7 +239,7 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="../eglib/src"
+				AdditionalIncludeDirectories="../eglib/src;../eglib"
 				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="0"
@@ -298,10 +302,6 @@
 				>
 			</File>
 			<File
-				RelativePath="..\eglib\src\gettimeofday.c"
-				>
-			</File>
-			<File
 				RelativePath="..\eglib\src\gfile.c"
 				>
 			</File>
@@ -382,10 +382,6 @@
 				>
 			</File>
 			<File
-				RelativePath="..\eglib\src\mkstemp.c"
-				>
-			</File>
-			<File
 				RelativePath="..\eglib\src\vasprintf.c"
 				>
 			</File>
Index: msvc/getopt.h
===================================================================
--- msvc/getopt.h	(revision 0)
+++ msvc/getopt.h	(revision 0)
@@ -0,0 +1,9 @@
+#ifndef GETOPT_H
+#define GETOPT_H
+
+int getopt(int argc, char * const argv[], const char *optstring);
+extern char *optarg;
+extern int optind, opterr, optopt;
+#include <getopt_long.h>
+
+#endif   /* GETOPT_H */

Property changes on: msvc/getopt.h
___________________________________________________________________
Name: svn:eol-style
   + native

Index: msvc/getopt_long.c
===================================================================
--- msvc/getopt_long.c	(revision 0)
+++ msvc/getopt_long.c	(revision 0)
@@ -0,0 +1,198 @@
+/*
+ * getopt_long() -- long options parser
+ *
+ * Portions Copyright (c) 1987, 1993, 1994
+ * The Regents of the University of California.  All rights reserved.
+ *
+ * Portions Copyright (c) 2003
+ * PostgreSQL Global Development Group
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *	  may be used to endorse or promote products derived from this software
+ *	  without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.	IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $PostgreSQL: pgsql/src/port/getopt_long.c,v 1.6 2007/03/26 21:44:11 momjian Exp $
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include "getopt_long.h"
+
+#ifndef HAVE_INT_OPTRESET
+int			optreset;
+#endif
+
+#define BADCH	'?'
+#define BADARG	':'
+#define EMSG	""
+
+
+int
+getopt_long(int argc, char *const argv[],
+			const char *optstring,
+			const struct option * longopts, int *longindex)
+{
+	static char *place = EMSG;	/* option letter processing */
+	char	   *oli;			/* option letter list index */
+
+	if (optreset || !*place)
+	{							/* update scanning pointer */
+		optreset = 0;
+
+		if (optind >= argc)
+		{
+			place = EMSG;
+			return -1;
+		}
+
+		place = argv[optind];
+
+		if (place[0] != '-')
+		{
+			place = EMSG;
+			return -1;
+		}
+
+		place++;
+
+		if (place[0] && place[0] == '-' && place[1] == '\0')
+		{						/* found "--" */
+			++optind;
+			place = EMSG;
+			return -1;
+		}
+
+		if (place[0] && place[0] == '-' && place[1])
+		{
+			/* long option */
+			size_t		namelen;
+			int			i;
+
+			place++;
+
+			namelen = strcspn(place, "=");
+			for (i = 0; longopts[i].name != NULL; i++)
+			{
+				if (strlen(longopts[i].name) == namelen
+					&& strncmp(place, longopts[i].name, namelen) == 0)
+				{
+					if (longopts[i].has_arg)
+					{
+						if (place[namelen] == '=')
+							optarg = place + namelen + 1;
+						else if (optind < argc - 1)
+						{
+							optind++;
+							optarg = argv[optind];
+						}
+						else
+						{
+							if (optstring[0] == ':')
+								return BADARG;
+							if (opterr)
+								fprintf(stderr,
+								   "%s: option requires an argument -- %s\n",
+										argv[0], place);
+							place = EMSG;
+							optind++;
+							return BADCH;
+						}
+					}
+					else
+					{
+						optarg = NULL;
+						if (place[namelen] != 0)
+						{
+							/* XXX error? */
+						}
+					}
+
+					optind++;
+
+					if (longindex)
+						*longindex = i;
+
+					place = EMSG;
+
+					if (longopts[i].flag == NULL)
+						return longopts[i].val;
+					else
+					{
+						*longopts[i].flag = longopts[i].val;
+						return 0;
+					}
+				}
+			}
+
+			if (opterr && optstring[0] != ':')
+				fprintf(stderr,
+						"%s: illegal option -- %s\n", argv[0], place);
+			place = EMSG;
+			optind++;
+			return BADCH;
+		}
+	}
+
+	/* short option */
+	optopt = (int) *place++;
+
+	oli = strchr(optstring, optopt);
+	if (!oli)
+	{
+		if (!*place)
+			++optind;
+		if (opterr && *optstring != ':')
+			fprintf(stderr,
+					"%s: illegal option -- %c\n", argv[0], optopt);
+		return BADCH;
+	}
+
+	if (oli[1] != ':')
+	{							/* don't need argument */
+		optarg = NULL;
+		if (!*place)
+			++optind;
+	}
+	else
+	{							/* need an argument */
+		if (*place)				/* no white space */
+			optarg = place;
+		else if (argc <= ++optind)
+		{						/* no arg */
+			place = EMSG;
+			if (*optstring == ':')
+				return BADARG;
+			if (opterr)
+				fprintf(stderr,
+						"%s: option requires an argument -- %c\n",
+						argv[0], optopt);
+			return BADCH;
+		}
+		else
+			/* white space */
+			optarg = argv[optind];
+		place = EMSG;
+		++optind;
+	}
+	return optopt;
+}

Property changes on: msvc/getopt_long.c
___________________________________________________________________
Name: svn:eol-style
   + native

Index: msvc/getopt_long.h
===================================================================
--- msvc/getopt_long.h	(revision 0)
+++ msvc/getopt_long.h	(revision 0)
@@ -0,0 +1,46 @@
+/*
+ * Portions Copyright (c) 1987, 1993, 1994
+ * The Regents of the University of California.  All rights reserved.
+ *
+ * Portions Copyright (c) 2003-2007, PostgreSQL Global Development Group
+ *
+ * $PostgreSQL: pgsql/src/include/getopt_long.h,v 1.8 2007/01/05 22:19:50 momjian Exp $
+ */
+#ifndef GETOPT_LONG_H
+#define GETOPT_LONG_H
+
+#ifdef HAVE_GETOPT_H
+#include <getopt.h>
+#endif
+
+/* These are picked up from the system's getopt() facility. */
+extern int	opterr;
+extern int	optind;
+extern int	optopt;
+extern char *optarg;
+
+/* Some systems have this, otherwise you need to define it somewhere. */
+extern int	optreset;
+
+#ifndef HAVE_STRUCT_OPTION
+
+struct option
+{
+	const char *name;
+	int			has_arg;
+	int		   *flag;
+	int			val;
+};
+
+#define no_argument 0
+#define required_argument 1
+#endif
+
+#ifndef HAVE_GETOPT_LONG
+
+extern int getopt_long(int argc, char *const argv[],
+			const char *optstring,
+			const struct option * longopts, int *longindex);
+#endif
+
+#endif   /* GETOPT_LONG_H */

Property changes on: msvc/getopt_long.h
___________________________________________________________________
Name: svn:eol-style
   + native
