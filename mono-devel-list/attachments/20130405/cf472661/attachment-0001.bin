using System;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.CompilerServices;

public static class TypeExtensions
{
	public static string GetAssemblyName (this Type self)
	{
		var attrs = self.GetCustomAttributes(typeof (TypeForwardedFromAttribute), false);
		if (attrs.Length == 0)
			return self.Assembly.FullName;
		else
			return ((TypeForwardedFromAttribute)attrs [0]).AssemblyFullName;
	}
}

[TypeForwardedFrom("SomeOtherAssembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null")]
[Serializable]
public class TestClass
{
}

public class Program
{
	static void Main ()
	{
		Console.WriteLine ("TypeForwardedFrom:");
		Console.WriteLine (typeof (TestClass).GetAssemblyName ());

		Console.WriteLine ("Serialization dump:");
		Dump (new TestClass ());
	}

	static void Dump (object obj)
	{
		using (var stm = new MemoryStream ()) {
			var fmt = new BinaryFormatter ();
			fmt.Serialize (stm, obj);
			Dump (stm.ToArray (), 72);
		}
	}

	static void Dump(byte[] bytes, int width)
	{
		for (int i = 0; i < bytes.Length; i++) {

			byte b = bytes[i];
			if (b < 32)
				b = (byte) '.';

			Console.Write (Convert.ToChar(b));
			
			if ((i + 1) % width == 0)
				Console.WriteLine ();
		}
		if (bytes.Length % width != 0)
			Console.WriteLine ();
	}
}
