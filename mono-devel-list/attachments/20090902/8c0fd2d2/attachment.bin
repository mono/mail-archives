Index: assembly.c
===================================================================
--- assembly.c	(revision 141154)
+++ assembly.c	(working copy)
@@ -1609,6 +1609,10 @@
 	bitlen = read32 (header + 12) >> 3;
 	if ((bitlen + 16 + 4) != pkeylen)
 		return FALSE;
+
+	/* parsing is OK and the public key itself is not requested back */
+	if (!pubkey)
+		return TRUE;
 		
 	/* Encode the size of the blob */
 	offset = 0;
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 141154)
+++ ChangeLog	(working copy)
@@ -1,3 +1,14 @@
+2009-09-02  Sebastien Pouliot  <sebastien@ximian.com>
+
+	* assembly.c (parse_public_key): Avoid allocating (and not 
+	freeing) the public key array when it's not requested by the 
+	caller.
+	* icall.c (ves_icall_MonoGenericClass_GetInterfaces): Avoid 
+	possibly dereferencing a null pointer (tb)
+	* threads.c (mono_thread_manage, mono_thread_create_internal, 
+	ves_icall_System_Threading_Thread_Thread_internal): Free 
+	allocated memory on error.
+
 2009-09-01  Rodrigo Kumpera  <rkumpera@novell.com>
 
 	* metadata-verify.c (verify_method_table): Check for abstract + final.
@@ -25,6 +36,7 @@
 	calculating interface offsets instead of the number of methods. This way we
 	avoid bubles on the layout.
 
+>>>>>>> .r141154
 2009-08-31  Rodrigo Kumpera  <rkumpera@novell.com>
 
 	* metadata-verify.c (verify_metadata_header): Some very smart
Index: threads.c
===================================================================
--- threads.c	(revision 141154)
+++ threads.c	(working copy)
@@ -753,6 +753,7 @@
 	mono_threads_lock ();
 	if (shutting_down) {
 		mono_threads_unlock ();
+		g_free (start_info);
 		return NULL;
 	}
 	if (threads_starting_up == NULL) {
@@ -1009,6 +1010,7 @@
 		if(this->start_notify==NULL) {
 			LeaveCriticalSection (this->synch_cs);
 			g_warning ("%s: CreateSemaphore error 0x%x", __func__, GetLastError ());
+			g_free (start_info);
 			return(NULL);
 		}
 
@@ -2911,6 +2913,7 @@
 	if(threads==NULL) {
 		THREAD_DEBUG (g_message("%s: No threads", __func__));
 		mono_threads_unlock ();
+		g_free (wait);
 		return;
 	}
 	mono_threads_unlock ();
Index: icall.c
===================================================================
--- icall.c	(revision 141154)
+++ icall.c	(working copy)
@@ -2603,7 +2603,7 @@
 	g_assert (gclass->is_dynamic);
 
 	tb = type->generic_type;
-	icount = tb->interfaces ? mono_array_length (tb->interfaces) : 0;
+	icount = tb && tb->interfaces ? mono_array_length (tb->interfaces) : 0;
 
 	res = mono_array_new (domain, System_Reflection_MonoGenericClass, icount);
 
