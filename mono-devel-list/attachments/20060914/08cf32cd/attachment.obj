Index: config.h.win
===================================================================
--- config.h.win	(revision 0)
+++ config.h.win	(revision 0)
@@ -0,0 +1,62 @@
+/* config.h.  Generated by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Name of package */
+#define PACKAGE "eglib"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* The size of a `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of a `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 4
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "0.1"
Index: eglib.vcproj
===================================================================
--- eglib.vcproj	(revision 0)
+++ eglib.vcproj	(revision 0)
@@ -0,0 +1,276 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="eglib"
+	ProjectGUID="{158073ED-99AE-4196-9EDC-DDB2344F8466}"
+	RootNamespace="eglib"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="src"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+				DisableSpecificWarnings="4244;4267"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="src"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_DEPRECATE"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\src\garray.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gdate.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gdir.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gerror.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gfile.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\ghashtable.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\glist.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gmarkup.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gmem.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gmisc.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gmodule.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\goutput.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gpath.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gpattern.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gptrarray.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gqueue.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gshell.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gslist.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gspawn.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gstr.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gstring.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gtimer.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gunicode.c"
+				>
+			</File>
+			<File
+				RelativePath=".\src\gutf8.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\src\eglib-config.h"
+				>
+			</File>
+			<File
+				RelativePath=".\src\glib.h"
+				>
+			</File>
+			<File
+				RelativePath=".\src\sort.frag.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
Index: src/eglib-config.h.win
===================================================================
--- src/eglib-config.h.win	(revision 0)
+++ src/eglib-config.h.win	(revision 0)
@@ -0,0 +1,92 @@
+/*
+ * System-dependent settings
+ */
+
+#if  _MSC_VER < 1300
+#ifndef __FUNCTION__
+#define __FUNCTION__ ""
+#endif
+#endif
+
+#define G_GNUC_PRETTY_FUNCTION   __FUNCTION__
+#define G_GNUC_UNUSED            
+#define G_BYTE_ORDER             G_LITTLE_ENDIAN
+#define G_GNUC_NORETURN          
+#define G_SEARCHPATH_SEPARATOR_S ";"
+#define G_SEARCHPATH_SEPARATOR   ';'
+#define G_DIR_SEPARATOR          '\\'
+#define G_DIR_SEPARATOR_S        "\\"
+#define G_BREAKPOINT             
+#define G_OS_WIN32
+#define GPOINTER_TO_INT(ptr)   ((gint) (ptr))
+#define GPOINTER_TO_UINT(ptr)  ((guint) (ptr))
+#define GINT_TO_POINTER(v)     ((gpointer) (v))
+#define GUINT_TO_POINTER(v)    ((gpointer) (v))
+
+typedef unsigned int gsize;
+typedef signed   int gssize;
+
+#define G_GSIZE_FORMAT   "u"
+#define G_GUINT64_FORMAT "llu"
+
+#if (_MSC_VER >= 1400) // VC8+
+#ifndef _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_DEPRECATE
+#endif
+#ifndef _CRT_NONSTDC_NO_DEPRECATE
+#define _CRT_NONSTDC_NO_DEPRECATE
+#endif
+#endif // VC8+
+
+typedef	__int8				int8_t;
+typedef unsigned __int8		uint8_t;
+typedef __int16				int16_t;
+typedef unsigned __int16	uint16_t;
+typedef __int32				int32_t;
+typedef unsigned __int32	uint32_t;
+typedef __int64				int64_t;
+typedef unsigned __int64	uint64_t;
+#define inline __inline
+typedef int pid_t;
+typedef int gid_t;
+typedef int uid_t;
+#define INT32_MAX		0x7fffffff
+#define INT32_MIN		(-0x7fffffff - 1)
+#define STDIN_FILENO  0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+#define WNOHANG 1
+
+#define mkstemp _mktemp
+
+#ifndef S_ISREG
+#define S_ISREG(mode)	(((mode) & S_IFMT) == S_IFREG)
+#endif
+
+#ifndef S_ISDIR
+#define S_ISDIR(mode)	(((mode)&S_IFMT) == S_IFDIR)
+#endif
+
+#ifndef X_OK
+#define X_OK 1
+#endif
+
+struct passwd {
+        char *pw_name;   /* login user id  */
+        char *pw_passwd; /* login password */
+        char *pw_dir;    /* home directory */
+        char *pw_shell;  /* login shell    */
+        char *pw_gecos;
+        int   pw_gid;
+        int   pw_uid;
+};
+
+#include <io.h>
+#include <direct.h>
+
+#define open _open
+#define close _close
+#define read _read
+#define write _write
+#define getpid GetCurrentProcess
+#define chdir _chdir
\ No newline at end of file
Index: src/gdate.c
===================================================================
--- src/gdate.c	(revision 65362)
+++ src/gdate.c	(working copy)
@@ -27,8 +27,23 @@
  */
 #include <stdio.h>
 #include <glib.h>
+#ifdef _MSC_VER
+#include <time.h>
+#include <Winsock2.h>
+int gettimeofday
+      (struct timeval* tp, void* tzp) {
+    DWORD t;
+    t = timeGetTime();
+    tp->tv_sec = t / 1000;
+    tp->tv_usec = t % 1000;
+    /* 0 indicates success. */
+    return 0;
+}
+#else
 #include <sys/time.h>
+#endif
 
+
 void
 g_get_current_time (GTimeVal *result)
 {
Index: src/gdir.c
===================================================================
--- src/gdir.c	(revision 65362)
+++ src/gdir.c	(working copy)
@@ -28,14 +28,17 @@
 #include <glib.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#include <dirent.h>
+#endif
 #include <errno.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <dirent.h>
 
 struct _GDir {
 #ifdef G_OS_WIN32
+	char *dir;
 #else
 	DIR *dir;
 #endif
Index: src/gfile.c
===================================================================
--- src/gfile.c	(revision 65362)
+++ src/gfile.c	(working copy)
@@ -28,7 +28,9 @@
 #include <glib.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#endif
 #include <errno.h>
 #include <sys/types.h>
 #include <sys/stat.h>
Index: src/glib.h
===================================================================
--- src/glib.h	(revision 65362)
+++ src/glib.h	(working copy)
@@ -5,7 +5,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
+#ifndef _MSC_VER
 #include <stdint.h>
+#endif
 #include <ctype.h>
 #include <eglib-config.h>
 
@@ -394,11 +396,11 @@
 void           g_logv                 (const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args);
 void           g_log                  (const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, ...);
 
-#define g_error(format...)    g_log (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, format)
-#define g_critical(format...) g_log (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, format)
-#define g_warning(format...)  g_log (G_LOG_DOMAIN, G_LOG_LEVEL_WARNING, format)
-#define g_message(format...)  g_log (G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE, format)
-#define g_debug(format...)    g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG, format)
+#define g_error(format, ...)    g_log (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, format, __VA_ARGS__)
+#define g_critical(format, ...) g_log (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, format, __VA_ARGS__)
+#define g_warning(format, ...)  g_log (G_LOG_DOMAIN, G_LOG_LEVEL_WARNING, format, __VA_ARGS__)
+#define g_message(format, ...)  g_log (G_LOG_DOMAIN, G_LOG_LEVEL_MESSAGE, format, __VA_ARGS__)
+#define g_debug(format, ...)    g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG, format, ...)
 
 /*
  * Conversions
@@ -467,7 +469,7 @@
  * Path
  */
 gchar  *g_build_path           (const gchar *separator, const gchar *first_element, ...);
-#define g_build_filename(x...) g_build_path(G_DIR_SEPARATOR_S, x)
+#define g_build_filename(x, ...) g_build_path(G_DIR_SEPARATOR_S, x, __VA_ARGS__)
 gchar  *g_path_get_dirname     (const gchar *filename);
 gchar  *g_path_get_basename    (const char *filename);
 gchar  *g_find_program_in_path (const gchar *program);
Index: src/glist.c
===================================================================
--- src/glist.c	(revision 65362)
+++ src/glist.c	(working copy)
@@ -205,7 +205,8 @@
 {
 	GList *prev = NULL;
 	GList *current;
-	
+	GList *node;
+
 	if (!func)
 		return list;
 
@@ -216,7 +217,7 @@
 		prev = current;
 	}
 
-	GList *node = new_node (prev, data, current);
+	node = new_node (prev, data, current);
 	return list == current ? node : list;
 }
 
Index: src/gmarkup.c
===================================================================
--- src/gmarkup.c	(revision 65362)
+++ src/gmarkup.c	(working copy)
@@ -42,7 +42,7 @@
 #include <stdio.h>
 #include <glib.h>
 
-#define set_error(msg...) do { if (error != NULL) *error = g_error_new (GINT_TO_POINTER (1), 1, msg); } while (0);
+#define set_error(msg, ...) do { if (error != NULL) *error = g_error_new (GINT_TO_POINTER (1), 1, msg); } while (0);
 
 typedef enum {
 	START,
Index: src/gpath.c
===================================================================
--- src/gpath.c	(revision 65362)
+++ src/gpath.c	(working copy)
@@ -28,11 +28,13 @@
 #define _GNU_SOURCE
 #include <stdio.h>
 #include <glib.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#include <sys/time.h>
+#endif
+#include <pthread.h>
 #include <errno.h>
 #include <sys/types.h>
-#include <pwd.h>
-#include <pthread.h>
 
 gchar *
 g_build_path (const gchar *separator, const gchar *first_element, ...)
Index: src/gpattern.c
===================================================================
--- src/gpattern.c	(revision 65362)
+++ src/gpattern.c	(working copy)
@@ -28,7 +28,9 @@
 #include <glib.h>
 #include <stdio.h>
 #include <stdlib.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#endif
 #include <errno.h>
 
 typedef enum {
Index: src/gspawn.c
===================================================================
--- src/gspawn.c	(revision 65362)
+++ src/gspawn.c	(working copy)
@@ -29,17 +29,21 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
+#ifdef _MSC_VER
+#include <time.h>
+#include <Winsock2.h>
+#else
 #include <unistd.h>
-#include <unistd.h>
-#include <fcntl.h>
 #include <sys/time.h>
 #include <sys/wait.h>
+#endif
+#include <fcntl.h>
 #include <sys/types.h>
 #include <glib.h>
 
-#define set_error(msg...) do { if (error != NULL) *error = g_error_new (G_LOG_DOMAIN, 1, msg); } while (0)
-#define set_error_cond(cond,msg...) do { if ((cond) && error != NULL) *error = g_error_new (G_LOG_DOMAIN, 1, msg); } while (0)
-#define set_error_status(status,msg...) do { if (error != NULL) *error = g_error_new (G_LOG_DOMAIN, status, msg); } while (0)
+#define set_error(msg,...) do { if (error != NULL) *error = g_error_new (G_LOG_DOMAIN, 1, msg); } while (0)
+#define set_error_cond(cond,msg,...) do { if ((cond) && error != NULL) *error = g_error_new (G_LOG_DOMAIN, 1, msg); } while (0)
+#define set_error_status(status,msg,...) do { if (error != NULL) *error = g_error_new (G_LOG_DOMAIN, status, msg); } while (0)
 #define NO_INTR(var,cmd) do { (var) = (cmd); } while ((var) == -1 && errno == EINTR)
 #define CLOSE_PIPE(p) do { close (p [0]); close (p [1]); } while (0)
 
@@ -148,7 +152,7 @@
 				gint *exit_status,
 				GError **error)
 {
-	pid_t pid;
+	GPid pid;
 	gchar **argv;
 	gint argc;
 	int stdout_pipe [2] = { -1, -1 };
@@ -231,7 +235,7 @@
 			gint *standard_error,
 			GError **error)
 {
-	pid_t pid;
+	GPid pid;
 	int info_pipe [2];
 	int in_pipe [2] = { -1, -1 };
 	int out_pipe [2] = { -1, -1 };
@@ -295,11 +299,14 @@
 			 * a 0 read on the parent. We're not supposed to keep it open forever.
 			 * If exec fails, we still can write the error to it before closing.
 			 */
+#ifdef G_OS_WIN32
+#else
 			fcntl (info_pipe [1], F_SETFD, FD_CLOEXEC);
+#endif
 
 			if ((flags & G_SPAWN_DO_NOT_REAP_CHILD) == 0) {
 				pid = getpid ();
-				NO_INTR (unused, write (info_pipe [1], &pid, sizeof (pid_t)));
+				NO_INTR (unused, write (info_pipe [1], &pid, sizeof (GPid)));
 			}
 
 			if (working_directory && chdir (working_directory) == -1) {
@@ -375,7 +382,7 @@
 
 	if ((flags & G_SPAWN_DO_NOT_REAP_CHILD) == 0) {
 		int x;
-		NO_INTR (x, read (info_pipe [0], &pid, sizeof (pid_t))); /* if we read < sizeof (pid_t)... */
+		NO_INTR (x, read (info_pipe [0], &pid, sizeof (GPid))); /* if we read < sizeof (GPid)... */
 	}
 
 	if (child_pid) {
Index: src/gstr.c
===================================================================
--- src/gstr.c	(revision 65362)
+++ src/gstr.c	(working copy)
@@ -133,10 +133,10 @@
 gchar *
 g_strconcat (const gchar *first, ...)
 {
-	g_return_val_if_fail (first != NULL, NULL);
 	va_list args;
 	int total = 0;
 	char *s, *ret;
+	g_return_val_if_fail (first != NULL, NULL);
 
 	total += strlen (first);
 	va_start (args, first);
Index: src/gtimer.c
===================================================================
--- src/gtimer.c	(revision 65362)
+++ src/gtimer.c	(working copy)
@@ -26,8 +26,13 @@
  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 #include <glib.h>
+#ifdef _MSC_VER
+#include <time.h>
+#include <Winsock2.h>
+int gettimeofday(struct timeval* tp, void* tzp);
+#else
 #include <sys/time.h>
-
+#endif
 struct _GTimer {
 	struct timeval start;
 	struct timeval stop;
Index: src/gunicode.c
===================================================================
--- src/gunicode.c	(revision 65362)
+++ src/gunicode.c	(working copy)
@@ -26,6 +26,8 @@
  * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+#include <glib.h>
+
 GUnicodeType 
 g_unichar_type (gunichar c)
 {
Index: src/gutf8.c
===================================================================
--- src/gutf8.c	(revision 65362)
+++ src/gutf8.c	(working copy)
@@ -1,366 +1,366 @@
-/*
- * gutf8.c: UTF-8 conversion
- *
- * Author:
- *   Atsushi Enomoto  <atsushi@ximian.com>
- *
- * (C) 2006 Novell, Inc.
- */
-
-#include <stdio.h>
-#include <glib.h>
-
-gpointer error_quark = "ERROR";
-
-gpointer
-g_convert_error_quark ()
-{
-	return error_quark;
-}
-
-gunichar2*
-g_utf8_to_utf16 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
-{
-	/* The conversion logic is almost identical to UTF8Encoding.GetChars(),
-	   but error check is always done at utf8_to_utf16_len() so that
-	   the conversion core below simply resets erroreous bits */
-	glong utf16_len;
-	gunichar2 *ret;
-	gchar ch, mb_size, mb_remain;
-	guint32 codepoint;
-	glong in_pos, out_pos;
-
-	utf16_len = 0;
-	mb_size = 0;
-	mb_remain = 0;
-	in_pos = 0;
-	out_pos = 0;
-
-	if (error)
-		*error = NULL;
-
-	utf16_len = utf8_to_utf16_len (str, len, items_read, error);
-	if (error)
-		if (*error)
+/*
+ * gutf8.c: UTF-8 conversion
+ *
+ * Author:
+ *   Atsushi Enomoto  <atsushi@ximian.com>
+ *
+ * (C) 2006 Novell, Inc.
+ */
+
+#include <stdio.h>
+#include <glib.h>
+
+gpointer error_quark = "ERROR";
+
+gpointer
+g_convert_error_quark ()
+{
+	return error_quark;
+}
+
+gunichar2*
+g_utf8_to_utf16 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error)
+{
+	/* The conversion logic is almost identical to UTF8Encoding.GetChars(),
+	   but error check is always done at utf8_to_utf16_len() so that
+	   the conversion core below simply resets erroreous bits */
+	glong utf16_len;
+	gunichar2 *ret;
+	gchar ch, mb_size, mb_remain;
+	guint32 codepoint;
+	glong in_pos, out_pos;
+
+	utf16_len = 0;
+	mb_size = 0;
+	mb_remain = 0;
+	in_pos = 0;
+	out_pos = 0;
+
+	if (error)
+		*error = NULL;
+
+	utf16_len = utf8_to_utf16_len (str, len, items_read, error);
+	if (error)
+		if (*error)
 			return NULL;
 	if (utf16_len < 0)
-		return NULL;
-
-	ret = g_malloc (utf16_len * sizeof (gunichar2));
-
-	for (in_pos = 0; len < 0 ? str [in_pos] : in_pos < len; in_pos++) {
-		ch = (guchar) str [in_pos];
-		if (mb_size == 0) {
-			if (0 < ch)
-				ret [out_pos++] = ch;
-			else if ((ch & 0xE0) == 0xC0) {
-				codepoint = ch & 0x1F;
-				mb_remain = mb_size = 2;
-			} else if ((ch & 0xF0) == 0xE0) {
-				codepoint = ch & 0x0F;
-				mb_remain = mb_size = 3;
-			} else if ((ch & 0xF8) == 0xF0) {
-				codepoint = ch & 7;
-				mb_remain = mb_size = 4;
-			} else if ((ch & 0xFC) == 0xF8) {
-				codepoint = ch & 3;
-				mb_remain = mb_size = 5;
-			} else if ((ch & 0xFE) == 0xFC) {
-				codepoint = ch & 3;
-				mb_remain = mb_size = 6;
-			} else {
-				/* invalid utf-8 sequence */
-				codepoint = 0;
-				mb_remain = mb_size = 0;
-			}
-		} else {
-			if ((ch & 0xC0) == 0x80) {
-				codepoint = (codepoint << 6) | (ch & 0x3F);
-				if (--mb_remain == 0) {
-					/* multi byte character is fully consumed now. */
-					if (codepoint < 0x10000) {
-						ret [out_pos++] = codepoint;
-					} else if (codepoint < 0x110000) {
-						/* surrogate pair */
-						codepoint -= 0x10000;
-						ret [out_pos++] = (codepoint >> 10) + 0xD800;
-						ret [out_pos++] = (codepoint & 0x3FF) + 0xDC00;
-					} else {
-						/* invalid utf-8 sequence (excess) */
-						codepoint = 0;
-						mb_remain = mb_size = 0;
-					}
-				}
-			} else {
-				/* invalid utf-8 sequence */
-				codepoint = 0;
-				mb_remain = mb_size = 0;
-			}
-		}
-	}
-
-	if (items_written)
-		*items_written = out_pos;
-	return ret;
-}
-
-glong
-utf8_to_utf16_len (const gchar *str, glong len, glong *items_read, GError **error)
-{
-	/* It is almost identical to UTF8Encoding.GetCharCount() */
-	guchar ch, mb_size, mb_remain;
-	gboolean overlong;
-	guint32 codepoint;
-	glong in_pos, ret;
-
-	mb_size = 0;
-	mb_remain = 0;
-	overlong = 0;
-	in_pos = 0;
-	ret = 0;
-
-	for (in_pos = 0; len < 0 ? str [in_pos] : in_pos < len; in_pos++) {
-		ch = str [in_pos];
-		if (mb_size == 0) {
-			if (ch < 0x80)
-				ret++;
-			else if ((ch & 0xE0) == 0xC0) {
-				codepoint = ch & 0x1F;
-				mb_remain = mb_size = 2;
-			} else if ((ch & 0xF0) == 0xE0) {
-				codepoint = ch & 0x0F;
-				mb_remain = mb_size = 3;
-			} else if ((ch & 0xF8) == 0xF0) {
-				codepoint = ch & 7;
-				mb_remain = mb_size = 4;
-			} else if ((ch & 0xFC) == 0xF8) {
-				codepoint = ch & 3;
-				mb_remain = mb_size = 5;
-			} else if ((ch & 0xFE) == 0xFC) {
-				codepoint = ch & 3;
-				mb_remain = mb_size = 6;
-			} else {
-				/* invalid utf-8 sequence */
-				if (error) {
-					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-8 sequence at %d", in_pos);
-					if (items_read)
-						*items_read = in_pos;
-					return -1;
-				} else {
-					codepoint = 0;
-					mb_remain = mb_size = 0;
-				}
-			}
-		} else {
-			if ((ch & 0xC0) == 0x80) {
-				codepoint = (codepoint << 6) | (ch & 0x3F);
-				if (--mb_remain == 0) {
-					/* multi byte character is fully consumed now. */
-					if (codepoint < 0x10000) {
-						switch (mb_size) {
-						case 2:
-							overlong = codepoint < 0x7F;
-							break;
-						case 3:
-							overlong = codepoint < 0x7FF;
-							break;
-						case 4:
-							overlong = codepoint < 0xFFFF;
-							break;
-						case 5:
-							overlong = codepoint < 0x1FFFFF;
-							break;
-						case 6:
-							overlong = codepoint < 0x03FFFFFF;
-							break;
-						}
-						if (overlong) {
-							/* invalid utf-8 sequence (overlong) */
-							if (error) {
-								g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-8 sequence at %d (overlong)", in_pos);
-								if (items_read)
-									*items_read = in_pos;
-								return -1;
-							} else {
-								codepoint = 0;
-								mb_remain = mb_size = 0;
-								overlong = FALSE;
-							}
-						}
-						else
-							ret++;
-					} else if (codepoint < 0x110000) {
-						/* surrogate pair */
-						ret += 2;
-					} else {
-						/* invalid utf-8 sequence (excess) */
-						if (error) {
-							g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-8 sequence at %d (codepoint range excess)", in_pos);
-							if (items_read)
-								*items_read = in_pos;
-							return -1;
-						} else {
-							codepoint = 0;
-							mb_remain = mb_size = 0;
-						}
-					}
-				}
-			} else {
-				/* invalid utf-8 sequence */
-				if (error) {
-					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-8 sequence at %d", in_pos);
-					if (items_read)
-						*items_read = in_pos;
-					return -1;
-				} else {
-					codepoint = 0;
-					mb_remain = mb_size = 0;
-				}
-			}
-		}
-	}
-
-	if (items_read)
-		*items_read = in_pos;
-	return ret;
-}
-
-gchar*
-g_utf16_to_utf8 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
-{
-	/* The conversion logic is almost identical to UTF8Encoding.GetBytes(),
-	   but error check is always done at utf16_to_utf8_len() so that
-	   the conversion core below simply resets erroreous bits */
-	glong utf8_len;
-	gchar *ret;
-	glong in_pos, out_pos;
-	gunichar2 ch;
-	guint32 codepoint;
-	gboolean surrogate;
-
-	in_pos = 0;
-	out_pos = 0;
-	surrogate = FALSE;
-
-	utf8_len = utf16_to_utf8_len (str, len, items_read, error);
-	if (error)
-		if (*error)
-			return NULL;
+		return NULL;
+
+	ret = g_malloc (utf16_len * sizeof (gunichar2));
+
+	for (in_pos = 0; len < 0 ? str [in_pos] : in_pos < len; in_pos++) {
+		ch = (guchar) str [in_pos];
+		if (mb_size == 0) {
+			if (0 < ch)
+				ret [out_pos++] = ch;
+			else if ((ch & 0xE0) == 0xC0) {
+				codepoint = ch & 0x1F;
+				mb_remain = mb_size = 2;
+			} else if ((ch & 0xF0) == 0xE0) {
+				codepoint = ch & 0x0F;
+				mb_remain = mb_size = 3;
+			} else if ((ch & 0xF8) == 0xF0) {
+				codepoint = ch & 7;
+				mb_remain = mb_size = 4;
+			} else if ((ch & 0xFC) == 0xF8) {
+				codepoint = ch & 3;
+				mb_remain = mb_size = 5;
+			} else if ((ch & 0xFE) == 0xFC) {
+				codepoint = ch & 3;
+				mb_remain = mb_size = 6;
+			} else {
+				/* invalid utf-8 sequence */
+				codepoint = 0;
+				mb_remain = mb_size = 0;
+			}
+		} else {
+			if ((ch & 0xC0) == 0x80) {
+				codepoint = (codepoint << 6) | (ch & 0x3F);
+				if (--mb_remain == 0) {
+					/* multi byte character is fully consumed now. */
+					if (codepoint < 0x10000) {
+						ret [out_pos++] = codepoint;
+					} else if (codepoint < 0x110000) {
+						/* surrogate pair */
+						codepoint -= 0x10000;
+						ret [out_pos++] = (codepoint >> 10) + 0xD800;
+						ret [out_pos++] = (codepoint & 0x3FF) + 0xDC00;
+					} else {
+						/* invalid utf-8 sequence (excess) */
+						codepoint = 0;
+						mb_remain = mb_size = 0;
+					}
+				}
+			} else {
+				/* invalid utf-8 sequence */
+				codepoint = 0;
+				mb_remain = mb_size = 0;
+			}
+		}
+	}
+
+	if (items_written)
+		*items_written = out_pos;
+	return ret;
+}
+
+glong
+utf8_to_utf16_len (const gchar *str, glong len, glong *items_read, GError **error)
+{
+	/* It is almost identical to UTF8Encoding.GetCharCount() */
+	guchar ch, mb_size, mb_remain;
+	gboolean overlong;
+	guint32 codepoint;
+	glong in_pos, ret;
+
+	mb_size = 0;
+	mb_remain = 0;
+	overlong = 0;
+	in_pos = 0;
+	ret = 0;
+
+	for (in_pos = 0; len < 0 ? str [in_pos] : in_pos < len; in_pos++) {
+		ch = str [in_pos];
+		if (mb_size == 0) {
+			if (ch < 0x80)
+				ret++;
+			else if ((ch & 0xE0) == 0xC0) {
+				codepoint = ch & 0x1F;
+				mb_remain = mb_size = 2;
+			} else if ((ch & 0xF0) == 0xE0) {
+				codepoint = ch & 0x0F;
+				mb_remain = mb_size = 3;
+			} else if ((ch & 0xF8) == 0xF0) {
+				codepoint = ch & 7;
+				mb_remain = mb_size = 4;
+			} else if ((ch & 0xFC) == 0xF8) {
+				codepoint = ch & 3;
+				mb_remain = mb_size = 5;
+			} else if ((ch & 0xFE) == 0xFC) {
+				codepoint = ch & 3;
+				mb_remain = mb_size = 6;
+			} else {
+				/* invalid utf-8 sequence */
+				if (error) {
+					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-8 sequence at %d", in_pos);
+					if (items_read)
+						*items_read = in_pos;
+					return -1;
+				} else {
+					codepoint = 0;
+					mb_remain = mb_size = 0;
+				}
+			}
+		} else {
+			if ((ch & 0xC0) == 0x80) {
+				codepoint = (codepoint << 6) | (ch & 0x3F);
+				if (--mb_remain == 0) {
+					/* multi byte character is fully consumed now. */
+					if (codepoint < 0x10000) {
+						switch (mb_size) {
+						case 2:
+							overlong = codepoint < 0x7F;
+							break;
+						case 3:
+							overlong = codepoint < 0x7FF;
+							break;
+						case 4:
+							overlong = codepoint < 0xFFFF;
+							break;
+						case 5:
+							overlong = codepoint < 0x1FFFFF;
+							break;
+						case 6:
+							overlong = codepoint < 0x03FFFFFF;
+							break;
+						}
+						if (overlong) {
+							/* invalid utf-8 sequence (overlong) */
+							if (error) {
+								g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-8 sequence at %d (overlong)", in_pos);
+								if (items_read)
+									*items_read = in_pos;
+								return -1;
+							} else {
+								codepoint = 0;
+								mb_remain = mb_size = 0;
+								overlong = FALSE;
+							}
+						}
+						else
+							ret++;
+					} else if (codepoint < 0x110000) {
+						/* surrogate pair */
+						ret += 2;
+					} else {
+						/* invalid utf-8 sequence (excess) */
+						if (error) {
+							g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-8 sequence at %d (codepoint range excess)", in_pos);
+							if (items_read)
+								*items_read = in_pos;
+							return -1;
+						} else {
+							codepoint = 0;
+							mb_remain = mb_size = 0;
+						}
+					}
+				}
+			} else {
+				/* invalid utf-8 sequence */
+				if (error) {
+					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-8 sequence at %d", in_pos);
+					if (items_read)
+						*items_read = in_pos;
+					return -1;
+				} else {
+					codepoint = 0;
+					mb_remain = mb_size = 0;
+				}
+			}
+		}
+	}
+
+	if (items_read)
+		*items_read = in_pos;
+	return ret;
+}
+
+gchar*
+g_utf16_to_utf8 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
+{
+	/* The conversion logic is almost identical to UTF8Encoding.GetBytes(),
+	   but error check is always done at utf16_to_utf8_len() so that
+	   the conversion core below simply resets erroreous bits */
+	glong utf8_len;
+	gchar *ret;
+	glong in_pos, out_pos;
+	gunichar2 ch;
+	guint32 codepoint;
+	gboolean surrogate;
+
+	in_pos = 0;
+	out_pos = 0;
+	surrogate = FALSE;
+
+	utf8_len = utf16_to_utf8_len (str, len, items_read, error);
+	if (error)
+		if (*error)
+			return NULL;
 	if (utf8_len < 0)
-		return NULL;
-
-	ret = g_malloc (utf8_len * sizeof (gchar));
-
-	while (len < 0 ? str [in_pos] : in_pos < len) {
-		ch = str [in_pos];
-		if (surrogate) {
-			surrogate = 0;
-			if (ch >= 0xDC00 && ch <= 0xDFFF)
-				codepoint = 0x10000 + (ch - 0xDC00) + ((surrogate - 0xD800) << 10);
-			else
-				/* invalid surrogate pair */
-				continue;
-		} else {
-			/* fast path optimization */
-			if (ch < 0x80) {
-				for (; len < 0 ? str [in_pos] : in_pos < len; in_pos++) {
-					if (str [in_pos] < 0x80)
-						ret [out_pos++] = str [in_pos];
-					else
-						break;
-				}
-				continue;
-			}
-			else if (ch >= 0xD800 && ch <= 0xDBFF)
-				surrogate = ch;
-			else if (ch >= 0xDC00 && ch <= 0xDFFF) {
-				/* invalid surrogate pair */
-				continue;
-			}
-			else
-				codepoint = ch;
-		}
-		in_pos++;
-
-		if (codepoint < 0x80)
-			ret [out_pos++] = (gchar) codepoint;
-		else if (codepoint < 0x0800) {
-			ret [out_pos++] = (gchar) (0xC0 | (codepoint >> 6));
-			ret [out_pos++] = (gchar) (0x80 | (codepoint & 0x3F));
-		} else if (codepoint < 0x10000) {
-			ret [out_pos++] = (gchar) (0xE0 | (codepoint >> 12));
-			ret [out_pos++] = (gchar) (0x80 | ((codepoint >> 6) & 0x3F));
-			ret [out_pos++] = (gchar) (0x80 | (codepoint & 0x3F));
-		} else {
-			ret [out_pos++] = (gchar) (0xF0 | (codepoint >> 18));
-			ret [out_pos++] = (gchar) (0x80 | ((codepoint >> 12) & 0x3F));
-			ret [out_pos++] = (gchar) (0x80 | ((codepoint >> 6) & 0x3F));
-			ret [out_pos++] = (gchar) (0x80 | (codepoint & 0x3F));
-		}
-	}
-
-	if (items_written)
-		*items_written = out_pos;
-	return ret;
-}
-
-glong
-utf16_to_utf8_len (const gunichar2 *str, glong len, glong *items_read, GError **error)
-{
-	glong ret, in_pos;
-	gunichar2 ch;
-	gboolean surrogate;
-
-	ret = 0;
-	in_pos = 0;
-	surrogate = FALSE;
-
-	while (len < 0 ? str [in_pos] : in_pos < len) {
-		ch = str [in_pos];
-		if (surrogate) {
-			if (ch >= 0xDC00 && ch <= 0xDFFF) {
-				ret += 4;
-			} else {
-				/* invalid surrogate pair */
-				if (error) {
-					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-16 sequence at %d (missing surrogate tail)", in_pos);
-					if (items_read)
-						*items_read = in_pos;
-					return -1;
-				} /* otherwise just ignore. */
-			}
-			surrogate = FALSE;
-		} else {
-			/* fast path optimization */
-			if (ch < 0x80) {
-				for (; len < 0 ? str [in_pos] : in_pos < len; in_pos++) {
-					if (str [in_pos] < 0x80)
-						++ret;
-					else
-						break;
-				}
-				continue;
-			}
-			else if (ch < 0x0800)
-				ret += 2;
-			else if (ch >= 0xD800 && ch <= 0xDBFF)
-				surrogate = TRUE;
-			else if (ch >= 0xDC00 && ch <= 0xDFFF) {
-				/* invalid surrogate pair */
-				if (error) {
-					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-16 sequence at %d (missing surrogate head)", in_pos);
-					if (items_read)
-						*items_read = in_pos;
-					return -1;
-				} /* otherwise just ignore. */
-			}
-			else
-				ret += 3;
-		}
-		in_pos++;
-	}
-
-	if (items_read)
-		*items_read = in_pos;
-	return ret;
-}
+		return NULL;
+
+	ret = g_malloc (utf8_len * sizeof (gchar));
+
+	while (len < 0 ? str [in_pos] : in_pos < len) {
+		ch = str [in_pos];
+		if (surrogate) {
+			surrogate = 0;
+			if (ch >= 0xDC00 && ch <= 0xDFFF)
+				codepoint = 0x10000 + (ch - 0xDC00) + ((surrogate - 0xD800) << 10);
+			else
+				/* invalid surrogate pair */
+				continue;
+		} else {
+			/* fast path optimization */
+			if (ch < 0x80) {
+				for (; len < 0 ? str [in_pos] : in_pos < len; in_pos++) {
+					if (str [in_pos] < 0x80)
+						ret [out_pos++] = str [in_pos];
+					else
+						break;
+				}
+				continue;
+			}
+			else if (ch >= 0xD800 && ch <= 0xDBFF)
+				surrogate = ch;
+			else if (ch >= 0xDC00 && ch <= 0xDFFF) {
+				/* invalid surrogate pair */
+				continue;
+			}
+			else
+				codepoint = ch;
+		}
+		in_pos++;
+
+		if (codepoint < 0x80)
+			ret [out_pos++] = (gchar) codepoint;
+		else if (codepoint < 0x0800) {
+			ret [out_pos++] = (gchar) (0xC0 | (codepoint >> 6));
+			ret [out_pos++] = (gchar) (0x80 | (codepoint & 0x3F));
+		} else if (codepoint < 0x10000) {
+			ret [out_pos++] = (gchar) (0xE0 | (codepoint >> 12));
+			ret [out_pos++] = (gchar) (0x80 | ((codepoint >> 6) & 0x3F));
+			ret [out_pos++] = (gchar) (0x80 | (codepoint & 0x3F));
+		} else {
+			ret [out_pos++] = (gchar) (0xF0 | (codepoint >> 18));
+			ret [out_pos++] = (gchar) (0x80 | ((codepoint >> 12) & 0x3F));
+			ret [out_pos++] = (gchar) (0x80 | ((codepoint >> 6) & 0x3F));
+			ret [out_pos++] = (gchar) (0x80 | (codepoint & 0x3F));
+		}
+	}
+
+	if (items_written)
+		*items_written = out_pos;
+	return ret;
+}
+
+glong
+utf16_to_utf8_len (const gunichar2 *str, glong len, glong *items_read, GError **error)
+{
+	glong ret, in_pos;
+	gunichar2 ch;
+	gboolean surrogate;
+
+	ret = 0;
+	in_pos = 0;
+	surrogate = FALSE;
+
+	while (len < 0 ? str [in_pos] : in_pos < len) {
+		ch = str [in_pos];
+		if (surrogate) {
+			if (ch >= 0xDC00 && ch <= 0xDFFF) {
+				ret += 4;
+			} else {
+				/* invalid surrogate pair */
+				if (error) {
+					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-16 sequence at %d (missing surrogate tail)", in_pos);
+					if (items_read)
+						*items_read = in_pos;
+					return -1;
+				} /* otherwise just ignore. */
+			}
+			surrogate = FALSE;
+		} else {
+			/* fast path optimization */
+			if (ch < 0x80) {
+				for (; len < 0 ? str [in_pos] : in_pos < len; in_pos++) {
+					if (str [in_pos] < 0x80)
+						++ret;
+					else
+						break;
+				}
+				continue;
+			}
+			else if (ch < 0x0800)
+				ret += 2;
+			else if (ch >= 0xD800 && ch <= 0xDBFF)
+				surrogate = TRUE;
+			else if (ch >= 0xDC00 && ch <= 0xDFFF) {
+				/* invalid surrogate pair */
+				if (error) {
+					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE, "invalid utf-16 sequence at %d (missing surrogate head)", in_pos);
+					if (items_read)
+						*items_read = in_pos;
+					return -1;
+				} /* otherwise just ignore. */
+			}
+			else
+				ret += 3;
+		}
+		in_pos++;
+	}
+
+	if (items_read)
+		*items_read = in_pos;
+	return ret;
+}
Index: TODO
===================================================================
--- TODO	(revision 65362)
+++ TODO	(working copy)
@@ -67,3 +67,4 @@
 
        We're missing a native windows implementation. The unix one is in place.
 
+	vasprintf:  there is a public domain implementation in freetds.  Is this acceptable?
\ No newline at end of file
