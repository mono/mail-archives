Index: mcs/ChangeLog
from  Raja R Harinath  <rharinath@novell.com>

	* expression.cs (Invocation.BetterConversion): Return the Type of 
	the better conversion.  Implement section 14.4.2.3 more faithfully.
	(Invocation.BetterFunction): Make boolean.  Make correspondence to
	section 14.4.2.2 explicit.
	(Invocation.OverloadResolve): Update.

Index: mcs/expression.cs
--- mcs/expression.cs	23 Sep 2004 19:47:46 -0000	1.617
+++ mcs/expression.cs	30 Sep 2004 12:11:01 -0000
@@ -4154,10 +4154,11 @@
 		/// <summary>
 		///   Determines "better conversion" as specified in 7.4.2.3
 		///
-                ///    Returns : 1 if a->p is better
-		///              0 if a->q or neither is better 
+                ///    Returns : p    if a->p is better,
+ 		///              q    if a->q is better,
+		///              null if neither is better
 		/// </summary>
-		static int BetterConversion (EmitContext ec, Argument a, Type p, Type q, Location loc)
+		static Type BetterConversion (EmitContext ec, Argument a, Type p, Type q, Location loc)
 		{
 			Type argument_type = a.Type;
 			Expression argument_expr = a.Expr;
@@ -4169,71 +4170,82 @@
 			if (p == null || q == null)
 				throw new InternalErrorException ("BetterConversion Got a null conversion");
 
-			//
-			// This is a special case since csc behaves this way.
-			//
-			if (argument_expr is NullLiteral &&
-                            p == TypeManager.string_type &&
-                            q == TypeManager.object_type)
-				return 1;
-			else if (argument_expr is NullLiteral &&
-                                 p == TypeManager.object_type &&
-                                 q == TypeManager.string_type)
-				return 0;
-			
-                        //
-                        // csc behaves this way so we emulate it. Basically, if the argument
-                        // is null and one of the types to compare is 'object' and the other
-                        // is a reference type, we prefer the other.
-                        //
-                        // I can't find this anywhere in the spec but we can interpret this
-                        // to mean that null can be of any type you wish in such a context
-                        //
-			if (argument_expr is NullLiteral &&
-			    !p.IsValueType &&
-			    q == TypeManager.object_type)
-				return 1;
-			else if (argument_expr is NullLiteral &&
-				 !q.IsValueType &&
-				 p == TypeManager.object_type)
-				return 0;
+			if (p == q)
+				return null;
 
+			if (argument_expr is NullLiteral) {
+				//
+				// If the argument is null and one of the types to compare is 'object' and
+				// the other is a reference type, we prefer the other.
+				//
+				// This follows from the usual rules:
+				//   * There is an implicit conversion from 'null' to type 'object'
+				//   * There is an implicit conversion from 'null' to any reference type
+				//   * There is an implicit conversion from any reference type to type 'object'
+				//   * There is no implicit conversion from type 'object' to other reference types
+				//  => Conversion of 'null' to a reference type is better than conversion to 'object'
+				//
+				//  FIXME: This probably isn't necessary, since the type of a NullLiteral is 'System.Null'.
+				//         I think it used to be 'object' and thus needed a special case to avoid the
+				//         immediately following two checks.
+				//
+				if (!p.IsValueType && q == TypeManager.object_type)
+					return p;
+				if (!q.IsValueType && p == TypeManager.object_type)
+					return q;
+			}
                                 
-			if (p == q)
-				return 0;
-			
 			if (argument_type == p)
-				return 1;
+				return p;
 
 			if (argument_type == q)
-				return 0;
+				return q;
 
 			Expression p_tmp = new EmptyExpression (p);
 			Expression q_tmp = new EmptyExpression (q);
-			
-			if (Convert.ImplicitConversionExists (ec, p_tmp, q) == true &&
-			    Convert.ImplicitConversionExists (ec, q_tmp, p) == false)
-				return 1;
+
+			bool p_to_q = Convert.ImplicitConversionExists (ec, p_tmp, q);
+			bool q_to_p = Convert.ImplicitConversionExists (ec, q_tmp, p);
+
+			if (p_to_q && !q_to_p)
+				return p;
+
+			if (q_to_p && !p_to_q)
+				return q;
 
 			if (p == TypeManager.sbyte_type)
 				if (q == TypeManager.byte_type || q == TypeManager.ushort_type ||
 				    q == TypeManager.uint32_type || q == TypeManager.uint64_type)
-					return 1;
+					return p;
+			if (q == TypeManager.sbyte_type)
+				if (p == TypeManager.byte_type || p == TypeManager.ushort_type ||
+				    p == TypeManager.uint32_type || p == TypeManager.uint64_type)
+					return q;
 
 			if (p == TypeManager.short_type)
 				if (q == TypeManager.ushort_type || q == TypeManager.uint32_type ||
 				    q == TypeManager.uint64_type)
-					return 1;
+					return p;
+			if (q == TypeManager.short_type)
+				if (p == TypeManager.ushort_type || p == TypeManager.uint32_type ||
+				    p == TypeManager.uint64_type)
+					return q;
 
 			if (p == TypeManager.int32_type)
 				if (q == TypeManager.uint32_type || q == TypeManager.uint64_type)
-					return 1;
+					return p;
+			if (q == TypeManager.int32_type)
+				if (p == TypeManager.uint32_type || p == TypeManager.uint64_type)
+					return q;
 
 			if (p == TypeManager.int64_type)
 				if (q == TypeManager.uint64_type)
-					return 1;
+					return p;
+			if (q == TypeManager.int64_type)
+				if (p == TypeManager.uint64_type)
+					return q;
 
-			return 0;
+			return null;
 		}
 		
 		/// <summary>
@@ -4242,12 +4254,12 @@
 		/// </summary>
 		/// <remarks>
 		///    Returns an integer indicating :
-		///     0 if candidate ain't better
-		///     1 if candidate is better than the current best match
+		///     false if candidate ain't better
+		///     true if candidate is better than the current best match
 		/// </remarks>
-		static int BetterFunction (EmitContext ec, ArrayList args, int argument_count,
-					   MethodBase candidate, bool candidate_params,
-					   MethodBase best, bool best_params, Location loc)
+		static bool BetterFunction (EmitContext ec, ArrayList args, int argument_count,
+					    MethodBase candidate, bool candidate_params,
+					    MethodBase best, bool best_params, Location loc)
 		{
 			ParameterData candidate_pd = GetParameterData (candidate);
 			ParameterData best_pd = GetParameterData (best);
@@ -4276,19 +4288,15 @@
 			// Trim (); is better than Trim (params char[] chars);
                         //
 			if (cand_count == 0 && argument_count == 0)
-				return best_params ? 1 : 0;
+				return !candidate_params && best_params;
 
 			if ((candidate_pd.ParameterModifier (cand_count - 1) != Parameter.Modifier.PARAMS) &&
 			    (candidate_pd.ParameterModifier (cand_count - 1) != Parameter.Modifier.ARGLIST))
 				if (cand_count != argument_count)
-					return 0;
-
+					return false;
 
-			int rating1 = 0, rating2 = 0;
-			
+			bool better_at_least_one = false;
 			for (int j = 0; j < argument_count; ++j) {
-				int x, y;
-				
 				Argument a = (Argument) args [j];
 
 				Type ct = candidate_pd.ParameterType (j);
@@ -4302,14 +4310,17 @@
 					if (best_params)
 						bt = TypeManager.GetElementType (bt);
 
-				x = BetterConversion (ec, a, ct, bt, loc);
-				y = BetterConversion (ec, a, bt, ct, loc);
+				Type better = BetterConversion (ec, a, ct, bt, loc);
 
-				if (x < y)
-					return 0;
-				
-				rating1 += x;
-				rating2 += y;
+				// for each argument, the conversion to 'ct' should be no worse than 
+				// the conversion to 'bt'.
+				if (better == bt)
+					return false;
+
+				// for at least one argument, the conversion to 'ct' should be better than 
+				// the conversion to 'bt'.
+				if (better == ct)
+					better_at_least_one = true;
 			}
 
                         //
@@ -4320,12 +4331,9 @@
                         // force it to select the candidate
                         //
                         if (!candidate_params && best_params && cand_count == argument_count)
-                                return 1;
+                                return true;
 
-			if (rating1 > rating2)
-				return 1;
-			else
-				return 0;
+			return better_at_least_one;
 		}
 
 		public static string FullMethodDesc (MethodBase mb)
@@ -4762,7 +4770,7 @@
                                 
 				if (BetterFunction (ec, Arguments, arg_count, 
 						    candidate, cand_params,
-						    method, method_params, loc) != 0) {
+						    method, method_params, loc)) {
 					method = candidate;
 					method_params = cand_params;
 				}
@@ -4780,10 +4788,10 @@
                                         continue;
 
                                 bool cand_params = candidate_to_form != null && candidate_to_form.Contains (candidate);
-				if (BetterFunction (ec, Arguments, arg_count,
-						    method, method_params,
-						    candidate, cand_params,
-						    loc) != 1) {
+				if (!BetterFunction (ec, Arguments, arg_count,
+						     method, method_params,
+						     candidate, cand_params,
+						     loc)) {
 					Report.SymbolRelatedToPreviousError (candidate);
 					ambiguous = true;
 				}
