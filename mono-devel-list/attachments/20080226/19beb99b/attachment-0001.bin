Index: System/MonoCustomAttrs.cs
===================================================================
--- System/MonoCustomAttrs.cs	(revision 96538)
+++ System/MonoCustomAttrs.cs	(working copy)
@@ -305,6 +305,31 @@
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
 		internal static extern bool IsDefinedInternal (ICustomAttributeProvider obj, Type AttributeType);
 
+		static PropertyInfo GetBasePropertyDefinition (PropertyInfo property)
+		{
+			MethodInfo method = property.GetGetMethod (true);
+			if (method == null || !method.IsVirtual)
+				method = property.GetSetMethod (true);
+			if (method == null || !method.IsVirtual)
+				return null;
+
+			MethodInfo baseMethod = method.GetBaseDefinition ();
+			if (baseMethod != null && baseMethod != method) {
+				ParameterInfo[] parameters = property.GetIndexParameters ();
+				if (parameters != null && parameters.Length > 0) {
+					Type[] paramTypes = new Type[parameters.Length];
+					for (int i=0; i < paramTypes.Length; i++)
+						paramTypes[i] = parameters[i].ParameterType;
+					return baseMethod.DeclaringType.GetProperty (property.Name, property.PropertyType, 
+										     paramTypes);
+				} else {
+					return baseMethod.DeclaringType.GetProperty (property.Name, property.PropertyType);
+				}
+			}
+			return null;
+
+		}
+
 		// Handles Type, MonoProperty and MonoMethod.
 		// The runtime has also cases for MonoEvent, MonoField, Assembly and ParameterInfo,
 		// but for those we return null here.
@@ -318,25 +343,9 @@
 
 			MethodInfo method = null;
 			if (obj is MonoProperty)
-			{
-				MonoProperty prop = (MonoProperty) obj;
-				method = prop.GetGetMethod (true);
-				if (method == null)
-					method = prop.GetSetMethod (true);
-/*
-				MonoProperty prop = (MonoProperty) obj;
-				if (prop.DeclaringType.BaseType != null) {
-					PropertyInfo baseProp = prop.DeclaringType.BaseType.GetProperty (prop.Name);
-					if (baseProp != prop)
-						return baseProp;
-				}
-				return null;
-*/
-			}
+				return GetBasePropertyDefinition ((MonoProperty) obj);
 			else if (obj is MonoMethod)
-			{
 				method = (MethodInfo) obj;
-			}
 
 			/**
 			 * ParameterInfo -> null
Index: System/ChangeLog
===================================================================
--- System/ChangeLog	(revision 96538)
+++ System/ChangeLog	(working copy)
@@ -1,3 +1,12 @@
+2008-02-25  Ivan N. Zlatev  <contact@i-nz.net>
+
+	* Attribute.cs, MonoCustomAttrs: MS ignores the inherit param in 
+	PropertyInfo's ICustomAttributeProvider implementation, but not 
+	in the Attributes, so directly get the attributes from 
+	MonoCustomAttrs instead of going throught the PropertyInfo's 
+	ICustomAttributeProvider.
+	[Fixes bugs #324472 and #322464]
+
 2008-02-25  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* DateTime.cs, DateTimeUtils.cs : make Kind value from parse result
Index: System/Attribute.cs
===================================================================
--- System/Attribute.cs	(revision 96538)
+++ System/Attribute.cs	(working copy)
@@ -224,6 +224,13 @@
 			// element parameter is not allowed to be null
 			CheckParameters (element, type);
 
+			// MS ignores the inherit param in PropertyInfo's ICustomAttributeProvider 
+			// implementation, but not in the Attributes, so directly get the attributes
+			// from MonoCustomAttrs instead of going throught the PropertyInfo's 
+			// ICustomAttributeProvider
+			MemberTypes mtype = element.MemberType;
+			if (mtype == MemberTypes.Property)
+				return (Attribute []) MonoCustomAttrs.GetCustomAttributes (element, type, inherit);
 			return (Attribute []) element.GetCustomAttributes (type, inherit);
 		}
 
@@ -248,6 +255,13 @@
 			// element parameter is not allowed to be null
 			CheckParameters (element, typeof (Attribute));
 
+			// MS ignores the inherit param in PropertyInfo's ICustomAttributeProvider 
+			// implementation, but not in the Attributes, so directly get the attributes
+			// from MonoCustomAttrs instead of going throught the PropertyInfo's 
+			// ICustomAttributeProvider
+			MemberTypes mtype = element.MemberType;
+			if (mtype == MemberTypes.Property)
+				return (Attribute []) MonoCustomAttrs.GetCustomAttributes (element, inherit);
 			return (Attribute []) element.GetCustomAttributes (inherit);
 		}
 
@@ -301,7 +315,14 @@
 				mtype != MemberTypes.NestedType)
 				throw new NotSupportedException (Locale.GetText (
 					"Element is not a constructor, method, property, event, type or field."));
-
+#if NET_2_0
+			// MS ignores the inherit param in PropertyInfo's ICustomAttributeProvider 
+			// implementation, but not in the Attributes, so directly get the attributes
+			// from MonoCustomAttrs instead of going throught the PropertyInfo's 
+			// ICustomAttributeProvider
+			if (mtype == MemberTypes.Property)
+				return MonoCustomAttrs.IsDefined (element, attributeType, inherit);
+#endif
 			return ((MemberInfo) element).IsDefined (attributeType, inherit);
 		}
 
Index: Test/System/AttributeTest.cs
===================================================================
--- Test/System/AttributeTest.cs	(revision 96538)
+++ Test/System/AttributeTest.cs	(working copy)
@@ -129,9 +129,6 @@
 		}
 
 		[Test]
-#if NET_2_0
-		[Category ("NotWorking")] // bug #81797
-#endif
 		public void IsDefined_PropertyInfo_Override ()
 		{
 			PropertyInfo pi = typeof (TestSub).GetProperty ("PropBase3");
@@ -218,7 +215,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")] // bug #81797
 		public void GetCustomAttribute_PropertyInfo_Override ()
 		{
 			PropertyInfo pi = typeof (TestSub).GetProperty ("PropBase3");
@@ -607,7 +603,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")] // bug #81797
 		public void GetCustomAttributes_PropertyInfo_Override ()
 		{
 			object [] attrs;
Index: Test/System/ChangeLog
===================================================================
--- Test/System/ChangeLog	(revision 96538)
+++ Test/System/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2008-02-25  Ivan N. Zlatev  <contact@i-nz.net>
+
+	* AttributeTest.cs: Remove NotWorking as we pass those tests now.
+
 2008-02-25  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* DateTimeTest.cs : enable Bug3522210() and add new test for the bug,
Index: System.Reflection/ChangeLog
===================================================================
--- System.Reflection/ChangeLog	(revision 96538)
+++ System.Reflection/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2008-02-25  Ivan N. Zlatev  <contact@i-nz.net>
+
+	* MonoProperty.cs: MS ignores the inherit parameter and defaults to false
+	for GetCustomAttributes.
+	[Fixes bugs #324472 and #322464]
+
 2008-02-20  Zoltan Varga  <vargaz@gmail.com>
 
 	* AssemblyName.cs (ReferenceMatchesDefinition): Add error checking and some 
Index: System.Reflection/MonoProperty.cs
===================================================================
--- System.Reflection/MonoProperty.cs	(revision 96538)
+++ System.Reflection/MonoProperty.cs	(working copy)
@@ -193,20 +193,23 @@
 			else
 				return null;
 		}
-		
+
+		// According to MSDN the inherit parameter is ignored here and
+		// the behavior always defaults to inherit = false
+		//
 		public override bool IsDefined (Type attributeType, bool inherit)
 		{
-			return MonoCustomAttrs.IsDefined (this, attributeType, inherit);
+			return MonoCustomAttrs.IsDefined (this, attributeType, false);
 		}
 
 		public override object[] GetCustomAttributes (bool inherit)
 		{
-			return MonoCustomAttrs.GetCustomAttributes (this, inherit);
+			return MonoCustomAttrs.GetCustomAttributes (this, false);
 		}
 		
 		public override object[] GetCustomAttributes (Type attributeType, bool inherit)
 		{
-			return MonoCustomAttrs.GetCustomAttributes (this, attributeType, inherit);
+			return MonoCustomAttrs.GetCustomAttributes (this, attributeType, false);
 		}
 
 		public override object GetValue (object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)