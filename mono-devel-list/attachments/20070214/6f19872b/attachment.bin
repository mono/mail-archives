Index: mono/mono/mini/inssel-alpha.brg
===================================================================
--- mono/mono/mini/inssel-alpha.brg	(revision 72791)
+++ mono/mono/mini/inssel-alpha.brg	(working copy)
@@ -53,6 +53,10 @@
         /* microcoded in mini-arm.c */
         tree->sreg1 = mono_regstate_next_int (s->rs);
         tree->dreg = state->reg1;
+
+	if (tree->flags & MONO_INST_INIT)
+	    tree->sreg2 = mono_regstate_next_int (s->rs);
+
         MONO_EMIT_NEW_ICONST (s, tree->sreg1, state->left->tree->inst_c0);
         mono_bblock_add_inst (s->cbb, tree);
 }
@@ -60,6 +64,10 @@
 reg: OP_LOCALLOC (reg) {
         tree->dreg = state->reg1;
         tree->sreg1 = state->left->reg1;
+
+        if (tree->flags & MONO_INST_INIT)
+            tree->sreg2 = mono_regstate_next_int (s->rs);
+
         mono_bblock_add_inst (s->cbb, tree);
 }
 
@@ -276,6 +284,11 @@
         MONO_EMIT_UNALU (s, tree, OP_BR_REG, -1, target_reg);
 }
 
+stmt: CEE_STIND_I8 (OP_REGVAR, reg) {
+        MONO_EMIT_NEW_UNALU (s, OP_MOVE, state->left->tree->dreg,
+		state->right->reg1);
+}
+
 reg: CEE_LDIND_I1 (OP_REGVAR) {
         MONO_EMIT_UNALU (s, tree, OP_SEXT_I1, state->reg1,
 	state->left->tree->dreg);
@@ -287,60 +300,21 @@
 }
 
 
-#stmt: CEE_BEQ (fpcflags) {
-#        tree->opcode = OP_FBEQ;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
-#
-#stmt: CEE_BNE_UN (fpcflags) {
-#        tree->opcode = OP_FBNE_UN;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
-#
-#stmt: CEE_BLT (fpcflags) {
-#        tree->opcode = OP_FBLT;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
-#
-#stmt: CEE_BLT_UN (fpcflags) {
-#        tree->opcode = OP_FBLT_UN;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
-#
-#stmt: CEE_BGT (fpcflags) {
-#        tree->opcode = OP_FBGT;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
-#
-#stmt: CEE_BGT_UN (fpcflags) {
-#        tree->opcode = OP_FBGT_UN;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
-#
-#stmt: CEE_BGE  (fpcflags) {
-#        tree->opcode = OP_FBGE;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
-#
-#stmt: CEE_BGE_UN (fpcflags) {
-#        tree->opcode = OP_FBGE_UN;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
-#
-#stmt: CEE_BLE  (fpcflags) {
-#        tree->opcode = OP_FBLE;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
-#
-#stmt: CEE_BLE_UN (fpcflags) {
-#        tree->opcode = OP_FBLE_UN;
-#        mono_bblock_add_inst (s->cbb, tree);
-#}
 
 #stmt: CEE_BEQ (OP_LCOMPARE(reg, OP_I8CONST)) {
 #	printf("Found match for CEE_BEQ (OP_LCOMPARE(reg, OP_I8CONST))\n");
 #}
 
+# Compare floats sequences (comments from Zoltan Varga)
+#
+# non-un comparisions should return false if the arguments are not
+# comparable, ie. 1.0 < nan is false. The un comparisions are needed
+# to implement the opposite of normal comparisions, i.e.
+# (a < b) is bl, while !(a < b) is translated into bge.un. This is 
+# because fp comparirions can return 4 values, not just three: lesser,
+# greater, equal or unordered 
+
+
 stmt: CEE_BLT_UN (OP_COMPARE (freg, freg)) {
         MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_UN_SU, (alpha_at+1),
                 state->left->left->reg1, state->left->right->reg1);
@@ -351,6 +325,17 @@
 	MONO_EMIT_UNALU (s, tree, OP_FBLT_UN, -1, -1);
 }
 
+stmt: CEE_BLT (OP_COMPARE (freg, freg)) {
+        MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_UN_SU, (alpha_at+1),
+                state->left->left->reg1, state->left->right->reg1);
+        MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_LT_SU, alpha_at,
+                state->left->left->reg1, state->left->right->reg1);
+        MONO_EMIT_NEW_UNALU (s, OP_ALPHA_TRAPB, -1, -1);
+
+        MONO_EMIT_UNALU (s, tree, OP_FBLT, -1, -1);
+}
+
+
 stmt: CEE_BLE_UN (OP_COMPARE (freg, freg)) {
 	MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_UN_SU, (alpha_at+1),
                 state->left->left->reg1, state->left->right->reg1);
@@ -361,6 +346,16 @@
         MONO_EMIT_UNALU (s, tree, OP_FBLE_UN, -1, -1);
 }
 
+stmt: CEE_BLE (OP_COMPARE (freg, freg)) {
+        MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_UN_SU, (alpha_at+1),
+                state->left->left->reg1, state->left->right->reg1);
+        MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_LE_SU, alpha_at,
+                state->left->left->reg1, state->left->right->reg1);
+        MONO_EMIT_NEW_UNALU (s, OP_ALPHA_TRAPB, -1, -1);
+
+        MONO_EMIT_UNALU (s, tree, OP_FBLE, -1, -1);
+}
+
 stmt: CEE_BGT_UN (OP_COMPARE (freg, freg)) {
         MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_UN_SU, (alpha_at+1),
                 state->left->left->reg1, state->left->right->reg1);
@@ -371,6 +366,16 @@
         MONO_EMIT_UNALU (s, tree, OP_FBGT_UN, -1, -1);
 }
 
+stmt: CEE_BGT (OP_COMPARE (freg, freg)) {
+        MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_UN_SU, (alpha_at+1),
+                state->left->left->reg1, state->left->right->reg1);
+        MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_LE_SU, alpha_at,
+                state->left->left->reg1, state->left->right->reg1);
+        MONO_EMIT_NEW_UNALU (s, OP_ALPHA_TRAPB, -1, -1);
+
+        MONO_EMIT_UNALU (s, tree, OP_FBGT, -1, -1);
+}
+
 stmt: CEE_BGE_UN (OP_COMPARE (freg, freg)) {
         MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_UN_SU, (alpha_at+1),
                 state->left->left->reg1, state->left->right->reg1);
@@ -381,6 +386,16 @@
         MONO_EMIT_UNALU (s, tree, OP_FBGE_UN, -1, -1);
 }
 
+stmt: CEE_BGE (OP_COMPARE (freg, freg)) {
+	MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_UN_SU, (alpha_at+1),
+                state->left->left->reg1, state->left->right->reg1);
+        MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_LT_SU, alpha_at,
+                state->left->left->reg1, state->left->right->reg1);
+        MONO_EMIT_NEW_UNALU (s, OP_ALPHA_TRAPB, -1, -1);
+
+        MONO_EMIT_UNALU (s, tree, OP_FBGE, -1, -1);
+}
+
 reg: OP_CEQ (OP_COMPARE (freg, freg)) {
         MONO_EMIT_NEW_BIALU (s, OP_ALPHA_CMPT_EQ_SU, alpha_at,
                 state->left->left->reg1, state->left->right->reg1);
Index: mono/mono/mini/cpu-alpha.md
===================================================================
--- mono/mono/mini/cpu-alpha.md	(revision 72791)
+++ mono/mono/mini/cpu-alpha.md	(working copy)
@@ -103,8 +103,8 @@
 conv.i2: dest:i src1:i len:12
 conv.i4: dest:i src1:i len:4
 conv.i8: dest:i src1:i len:4
-conv.r4: dest:f src1:i len:20
-conv.r8: dest:f src1:i len:20
+conv.r4: dest:f src1:i len:24
+conv.r8: dest:f src1:i len:24
 conv.u4: dest:i src1:i len:4
 conv.u8: dest:i src1:i len:4
 conv.r.un: dest:f src1:i len:8
@@ -126,7 +126,7 @@
 cgt.un: dest:c len:8
 clt: dest:c len:8
 clt.un: dest:c len:8
-localloc: dest:i src1:i len:20
+localloc: dest:i src1:i src2:i len:40 clob:1
 compare: src1:i src2:i len:4
 lcompare: src1:i src2:i len:4
 icompare: src1:i src2:i len:4
@@ -247,8 +247,8 @@
 long_shl: dest:i src1:i src2:i len:4
 long_shr: dest:i src1:i src2:i len:4
 long_shr_un: dest:i src1:i src2:i len:4
-long_conv_to_r4: dest:f src1:i len:20
-long_conv_to_r8: dest:f src1:i len:20
+long_conv_to_r4: dest:f src1:i len:24
+long_conv_to_r8: dest:f src1:i len:24
 long_conv_to_ovf_i: dest:i src1:i src2:i len:40
 long_mul_ovf: dest:i src1:i src2:i clob:1 len:16
 long_mul_ovf_un: dest:i src1:i src2:i len:22
@@ -266,11 +266,11 @@
 float_bge_un: len:12
 float_ble: len:4
 float_ble_un: len:12
-float_add: dest:f src1:f src2:f len:4
-float_sub: dest:f src1:f src2:f len:4
+float_add: dest:f src1:f src2:f len:8
+float_sub: dest:f src1:f src2:f len:8
 float_mul: dest:f src1:f src2:f len:5
-float_div: dest:f src1:f src2:f len:5
-float_div_un: dest:f src1:f src2:f len:5
+float_div: dest:f src1:f src2:f len:8
+float_div_un: dest:f src1:f src2:f len:8
 float_rem: dest:f src1:f src2:f len:19
 float_rem_un: dest:f src1:f src2:f len:19
 float_neg: dest:f src1:f len:23
@@ -378,7 +378,7 @@
 int_and: dest:i src1:i src2:i len:4
 int_or: dest:i src1:i src2:i len:4
 int_xor: dest:i src1:i src2:i len:4
-int_shl: dest:i src1:i src2:i len:4
+int_shl: dest:i src1:i src2:i len:8
 int_shr: dest:i src1:i src2:i len:8
 int_shr_un: dest:i src1:i src2:i len:8
 int_adc: dest:i src1:i src2:i clob:1 len:64
@@ -397,7 +397,7 @@
 int_and_imm: dest:i src1:i len:4
 int_or_imm: dest:i src1:i len:4
 int_xor_imm: dest:i src1:i len:4
-int_shl_imm: dest:i src1:i len:4
+int_shl_imm: dest:i src1:i len:8
 int_shr_imm: dest:i src1:i len:8
 int_shr_un_imm: dest:i src1:i len:8
 int_neg: dest:i src1:i len:4
Index: mono/mono/mini/mini-alpha.c
===================================================================
--- mono/mono/mini/mini-alpha.c	(revision 72791)
+++ mono/mono/mini/mini-alpha.c	(working copy)
@@ -199,11 +199,11 @@
                gboolean is_return,
                guint32 *gr, guint32 *fr, guint32 *stack_size)
 {
-  guint32 size, i;
+  guint32 size;
   MonoClass *klass;
   MonoMarshalType *info;
-  gboolean is_hfa = TRUE;
-  guint32 hfa_type = 0;
+  //gboolean is_hfa = TRUE;
+  //guint32 hfa_type = 0;
 
   klass = mono_class_from_mono_type (type);
   if (type->type == MONO_TYPE_TYPEDBYREF)
@@ -1487,7 +1487,7 @@
    /* Save (global) regs */
    offset = cfg->arch.reg_save_area_offset;
 
-   for (i = 0; i < MONO_MAX_VREGS; ++i)
+   for (i = 0; i < MONO_MAX_IREGS; ++i)
      if (ALPHA_IS_CALLEE_SAVED_REG (i) &&
          (cfg->used_int_regs & (1 << i)) &&
          !( ALPHA_ARGS_REGS & (1 << i)) )
@@ -1818,7 +1818,7 @@
   // Restore saved regs
   offset = cfg->arch.reg_save_area_offset;
    
-  for (i = 0; i < MONO_MAX_VREGS; ++i)
+  for (i = 0; i < MONO_MAX_IREGS; ++i)
     if (ALPHA_IS_CALLEE_SAVED_REG (i) &&
 	(cfg->used_int_regs & (1 << i)) &&
 	!( ALPHA_ARGS_REGS & (1 << i)) )
@@ -2300,6 +2300,7 @@
            CFG_DEBUG(4) g_print("ALPHA_CHECK: [int_shl] dreg=%d, sreg1=%d, sreg2=%d\n",
                   ins->dreg, ins->sreg1, ins->sreg2);
            alpha_sll(code, ins->sreg1, ins->sreg2, ins->dreg);
+	   alpha_addl_(code, ins->dreg, 0, ins->dreg);
            break;
 
 	 case OP_ISHL_IMM:
@@ -2308,6 +2309,7 @@
            CFG_DEBUG(4) g_print("ALPHA_CHECK: [int_shl_imm] dreg=%d, sreg1=%d, const=%ld\n",
                   ins->dreg, ins->sreg1, ins->inst_imm);
            alpha_sll_(code, ins->sreg1, ins->inst_imm, ins->dreg);
+	   alpha_addl_(code, ins->dreg, 0, ins->dreg);
            break;
 
 	 case OP_SHL_IMM:
@@ -2999,14 +3001,16 @@
 	   // Later check different rounding and exc modes
 	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [float_add] sreg1=%d, sreg2=%d, dreg=%d\n",
 		  ins->sreg1, ins->sreg2, ins->dreg);
-	   alpha_addt(code, ins->sreg1, ins->sreg2, ins->dreg);
+	   alpha_addt_su(code, ins->sreg1, ins->sreg2, ins->dreg);
+	   alpha_trapb(code);
 	   break;
 
 	 case OP_FSUB:
 	   // Later check different rounding and exc modes
 	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [float_sub] sreg1=%d, sreg2=%d, dreg=%d\n",
 				 ins->sreg1, ins->sreg2, ins->dreg);
-	   alpha_subt(code, ins->sreg1, ins->sreg2, ins->dreg);
+	   alpha_subt_su(code, ins->sreg1, ins->sreg2, ins->dreg);
+	   alpha_trapb(code);
            break;
 
 	 case OP_FMUL:
@@ -3144,7 +3148,7 @@
            break;
 
          case OP_ALPHA_CMP_IMM_ULE:
-           CFG_DEBUG(4) g_print("ALPHA_CHECK: [alpha_cmp_imm_ule] sreg1=%d, const=%0lX, dreg=%\d\n",
+           CFG_DEBUG(4) g_print("ALPHA_CHECK: [alpha_cmp_imm_ule] sreg1=%d, const=%0lX, dreg=%d\n",
                   ins->sreg1, ins->inst_imm, ins->dreg);
            alpha_cmpule_(code, ins->sreg1, ins->inst_imm, alpha_at);
            break;
@@ -3175,7 +3179,7 @@
 
 
          case OP_ALPHA_CMP_IMM_LE:
-           CFG_DEBUG(4) g_print("ALPHA_CHECK: [alpha_cmp_imm_le] sreg1=%d, const=%0lX, dreg=%\d\n",
+           CFG_DEBUG(4) g_print("ALPHA_CHECK: [alpha_cmp_imm_le] sreg1=%d, const=%0lX, dreg=%d\n",
                   ins->sreg1, ins->inst_imm, ins->dreg);
            alpha_cmple_(code, ins->sreg1, ins->inst_imm, alpha_at);
            break;
@@ -3421,6 +3425,7 @@
 	   alpha_ldt(code, ins->dreg, alpha_sp, 0);
 	   alpha_lda(code, alpha_sp, alpha_sp, 8);
 	   alpha_cvtqs(code, ins->dreg, ins->dreg);
+	   alpha_trapb(code);
 	   break;
 
          case CEE_CONV_R8:
@@ -3433,13 +3438,15 @@
            alpha_ldt(code, ins->dreg, alpha_sp, 0);
            alpha_lda(code, alpha_sp, alpha_sp, 8);
            alpha_cvtqt(code, ins->dreg, ins->dreg);
+	   alpha_trapb(code);
            break;
 
 	 case OP_FCONV_TO_R4:
 	   // Convert 64 bit float to 32 bit float (T -> S)
 	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [fconv_r4] sreg=%d, dreg=%d\n",
 				 ins->sreg1, ins->dreg);
-	   alpha_cvtts(code, ins->sreg1, ins->dreg);
+	   alpha_cvtts_su(code, ins->sreg1, ins->dreg);
+	   alpha_trapb(code);
 	   break;
 
 	 case OP_LOCALLOC:
@@ -3448,11 +3455,33 @@
 	   // top of stack is used for call params
 	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [localloc] sreg=%d, dreg=%d\n",
 				ins->sreg1, ins->dreg);
+
 	   alpha_addq_(code, ins->sreg1, (MONO_ARCH_LOCALLOC_ALIGNMENT - 1), ins->sreg1);
-	   alpha_and_(code, ins->sreg1, ~(MONO_ARCH_LOCALLOC_ALIGNMENT - 1), ins->sreg1);
+	   alpha_bic_(code, ins->sreg1, (MONO_ARCH_LOCALLOC_ALIGNMENT - 1), ins->sreg1);
+	   if (ins->flags & MONO_INST_INIT)
+	       alpha_mov1(code, ins->sreg1, ins->sreg2);
+
 	   alpha_subq(code, alpha_sp, ins->sreg1, alpha_sp);
-	   alpha_lda(code, ins->dreg, alpha_zero, (cfg->arch.params_stack_size));
-	   alpha_addq(code, alpha_sp, ins->dreg, ins->dreg);
+	   if (cfg->arch.params_stack_size > 0)
+	   {
+	       alpha_lda(code, ins->dreg, alpha_zero,
+			(cfg->arch.params_stack_size));
+	       alpha_addq(code, alpha_sp, ins->dreg, ins->dreg);
+	   }
+	   else
+	       alpha_mov1(code, alpha_sp, ins->dreg);
+
+	   if (ins->flags & MONO_INST_INIT)
+	   {
+		// TODO: Optimize it later
+		alpha_lda(code, ins->sreg2, ins->sreg2,
+			-(MONO_ARCH_LOCALLOC_ALIGNMENT));
+		alpha_blt(code, ins->sreg2, 3);
+		alpha_addq(code, ins->sreg2, ins->dreg, alpha_at);
+		alpha_stq(code, alpha_zero, alpha_at, 0);
+		alpha_br(code, alpha_zero, -5);
+	   }
+
 	   break;
 
 	 case OP_MOVE:
@@ -3564,6 +3593,12 @@
            EMIT_ALPHA_BRANCH(ins, alpha_at, fbeq);
            break;
 
+	 case OP_FBGE:
+	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [fbge] [");
+	   alpha_fbne(code, (alpha_at+1), 1);
+	   EMIT_ALPHA_BRANCH(ins, alpha_at, fbeq);
+           break;
+
          case OP_FBLE_UN:
            CFG_DEBUG(4) g_print("ALPHA_CHECK: [fble_un] [");
            alpha_fbeq(code, (alpha_at+1), 1);
@@ -3571,6 +3606,12 @@
            EMIT_ALPHA_BRANCH(ins, alpha_at, fbne);
            break;
 
+         case OP_FBLE:
+           CFG_DEBUG(4) g_print("ALPHA_CHECK: [fble] [");
+           alpha_fbne(code, (alpha_at+1), 1);
+           EMIT_ALPHA_BRANCH(ins, alpha_at, fbne);
+           break;
+
          case OP_FBLT_UN:
            CFG_DEBUG(4) g_print("ALPHA_CHECK: [fblt_un] [");
            alpha_fbeq(code, (alpha_at+1), 1);
@@ -3578,6 +3619,12 @@
            EMIT_ALPHA_BRANCH(ins, alpha_at, fbne);
            break;
 
+         case OP_FBLT:
+           CFG_DEBUG(4) g_print("ALPHA_CHECK: [fblt] [");
+           alpha_fbne(code, (alpha_at+1), 1);
+           EMIT_ALPHA_BRANCH(ins, alpha_at, fbne);
+           break;
+
          case OP_FBGT_UN:
            CFG_DEBUG(4) g_print("ALPHA_CHECK: [fbgt_un] [");
            alpha_fbeq(code, (alpha_at+1), 1);
@@ -3585,6 +3632,12 @@
            EMIT_ALPHA_BRANCH(ins, alpha_at, fbeq);
            break;
 
+         case OP_FBGT:
+           CFG_DEBUG(4) g_print("ALPHA_CHECK: [fbgt] [");
+           alpha_fbne(code, (alpha_at+1), 1);
+           EMIT_ALPHA_BRANCH(ins, alpha_at, fbeq);
+           break;
+
 	 case OP_IBEQ:
 	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [ibeq] [");
 	   EMIT_ALPHA_BRANCH(ins, alpha_at, beq);
@@ -3889,7 +3942,22 @@
 	   CFG_DEBUG(4) g_print("ALPHA_CHECK: [mb]\n");
 	   alpha_mb(code);
 	   break;
-	   
+	  
+	 case CEE_CKFINITE:
+	   // Float register contains a value which we need to check
+	   CFG_DEBUG(4) g_print("ALPHA_TODO: [chfinite] sreg1=%d\n", ins->sreg1);
+ 	   alpha_cmptun_su(code, ins->sreg1, ins->sreg1, alpha_at);
+	   alpha_trapb(code);
+	   EMIT_COND_EXC_BRANCH(fbeq, alpha_at, "ArithmeticException");
+
+	   break;
+	 case OP_FDIV:
+	   CFG_DEBUG(4) g_print("ALPHA_TODO: [fdiv] dest=%d, sreg1=%d, sreg2=%d\n",
+		ins->dreg, ins->sreg1, ins->sreg2);
+	   alpha_divt_su(code, ins->sreg1, ins->sreg2, ins->dreg);
+	   alpha_trapb(code);
+
+	   break;
 	 default:
 	   g_warning ("unknown opcode %s in %s()\n",
 		      mono_inst_name (ins->opcode), __FUNCTION__);
@@ -4763,7 +4831,7 @@
 	 if ((i >= sig->hasthis) &&
 	     (MONO_TYPE_ISSTRUCT(arg_type)))
 	   {
-	     gint align;
+	     guint align;
 	     guint32 size;
 	     
 	     if (arg_type->type == MONO_TYPE_TYPEDBYREF) {
@@ -5038,42 +5106,6 @@
 
 /*========================= End of Function ========================*/
 
-static gboolean
-is_regsize_var (MonoType *t)
-{
-  if (t->byref)
-    return TRUE;
-
-  t = mono_type_get_underlying_type (t);
-  switch (t->type) {
-  case MONO_TYPE_I1:
-  case MONO_TYPE_U1:
-  case MONO_TYPE_I2:
-  case MONO_TYPE_U2:
-  case MONO_TYPE_I4:
-  case MONO_TYPE_U4:
-  case MONO_TYPE_I:
-  case MONO_TYPE_U:
-  case MONO_TYPE_PTR:
-  case MONO_TYPE_FNPTR:
-  case MONO_TYPE_BOOLEAN:
-    return TRUE;
-  case MONO_TYPE_OBJECT:
-  case MONO_TYPE_STRING:
-  case MONO_TYPE_CLASS:
-  case MONO_TYPE_SZARRAY:
-  case MONO_TYPE_ARRAY:
-    return TRUE;
-  case MONO_TYPE_VALUETYPE:
-    return FALSE;
-  }
-
-  return FALSE;
-}
-
-
-
-
 /*------------------------------------------------------------------*/
 /*                                                                  */
 /* Name         - mono_arch_get_allocatable_int_vars                */
@@ -5130,7 +5162,7 @@
 	   (ins->opcode != OP_LOCAL && ins->opcode != OP_ARG))
 	 continue;
 
-       if (is_regsize_var (ins->inst_vtype))
+       if (mono_is_regsize_var (ins->inst_vtype))
 	 {
 	   g_assert (MONO_VARINFO (cfg, i)->reg == -1);
 	   g_assert (i == vmv->idx);
@@ -5672,7 +5704,7 @@
    CFG_DEBUG(3) g_print ("ALPHA: reg_save_area_offset at %d(%x)\n", offset, offset);
    
    // Reserve space for caller saved registers 
-   for (i = 0; i < MONO_MAX_VREGS; ++i)
+   for (i = 0; i < MONO_MAX_IREGS; ++i)
      if ((ALPHA_IS_CALLEE_SAVED_REG (i)) &&
 	 (cfg->used_int_regs & (1 << i)))
        {
@@ -5862,7 +5894,7 @@
 	  pc, regs);
 
   // Check if we have parameters on stack
-  if (pc[-2] & 0xFFFF0000 == 0x23DE0000)     // lda     sp,-n(sp)
+  if ((pc[-2] & 0xFFFF0000) == 0x23DE0000)     // lda     sp,-n(sp)
     start_index = -3;
 
   // Check for (call_membase):
Index: mono/mono/mini/mini-alpha.h
===================================================================
--- mono/mono/mini/mini-alpha.h	(revision 72791)
+++ mono/mono/mini/mini-alpha.h	(working copy)
@@ -300,7 +300,7 @@
 
 #define MONO_ARCH_EMULATE_CONV_R8_UN     1
 #define MONO_ARCH_EMULATE_LCONV_TO_R8_UN 1
-#define MONO_ARCH_EMULATE_LCONV_TO_R8    1
+//#define MONO_ARCH_EMULATE_LCONV_TO_R8    1
 #define MONO_ARCH_EMULATE_FREM           1
 #define MONO_ARCH_EMULATE_MUL_DIV        1
 #define MONO_ARCH_EMULATE_LONG_MUL_OPTS  1
Index: mono/mono/arch/alpha/alpha-codegen.h
===================================================================
--- mono/mono/arch/alpha/alpha-codegen.h	(revision 72791)
+++ mono/mono/arch/alpha/alpha-codegen.h	(working copy)
@@ -547,6 +547,10 @@
 #define alpha_cmptlt(ins, Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x0A6, Rsrc1, Rsrc2, Rdest )
 #define alpha_cmptle(ins, Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x0A7, Rsrc1, Rsrc2, Rdest )
 
+#define alpha_addt_su(ins, Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x5A0, Rsrc1, Rsrc2, Rdest )
+#define alpha_subt_su(ins, Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x5A1, Rsrc1, Rsrc2, Rdest )
+
+
 #define alpha_cmptun_su(ins, Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x5A4, Rsrc1, Rsrc2, Rdest )
 #define alpha_cmpteq_su(ins, Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x5A5, Rsrc1, Rsrc2, Rdest )
 #define alpha_cmptlt_su(ins, Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x5A6, Rsrc1, Rsrc2, Rdest )
@@ -557,7 +561,10 @@
 #define alpha_cvtqs(ins, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x0BC, alpha_fzero, Rsrc2, Rdest )
 #define alpha_cvtqt(ins, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x0BE, alpha_fzero, Rsrc2, Rdest )
 
+#define alpha_divt_su(ins, Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x5A3, Rsrc1, Rsrc2, Rdest )
 
+#define alpha_cvtts_su(ins, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x16, 0x5AC, alpha_fzero, Rsrc2, Rdest )
+
 #define alpha_cpys(ins,  Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x17, 0x020, Rsrc1, Rsrc2, Rdest )
 #define alpha_cpysn(ins,  Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x17, 0x021, Rsrc1, Rsrc2, Rdest )
 #define alpha_cpyse(ins,  Rsrc1, Rsrc2, Rdest) alpha_encode_fpop( ins, 0x17, 0x022, Rsrc1, Rsrc2, Rdest )
