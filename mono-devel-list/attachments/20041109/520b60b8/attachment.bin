? Test/System.Collections.Generic
Index: ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/ChangeLog,v
retrieving revision 1.239
diff -u -r1.239 ChangeLog
--- ChangeLog	29 Oct 2004 10:46:40 -0000	1.239
+++ ChangeLog	9 Nov 2004 08:36:23 -0000
@@ -1,3 +1,8 @@
+2004-11-08  Sureshkumar T  <tsureshkumar@novell.com>
+
+	* corlib_test.dll.sources: Added DictionaryTest.cs for Generic
+	Dictioary Test.
+
 2004-10-29  Raja R Harinath  <rharinath@novell.com>
 
 	* Makefile: Move support for building net_2_0_bootstrap libraries
Index: corlib_test.dll.sources
===================================================================
RCS file: /cvs/public/mcs/class/corlib/corlib_test.dll.sources,v
retrieving revision 1.62
diff -u -r1.62 corlib_test.dll.sources
--- corlib_test.dll.sources	14 Oct 2004 19:47:31 -0000	1.62
+++ corlib_test.dll.sources	9 Nov 2004 08:36:23 -0000
@@ -26,6 +26,7 @@
 System.Collections/ReadOnlyCollectionBaseTest.cs
 System.Collections/SortedListTest.cs
 System.Collections/StackTest.cs
+System.Collections.Generic/DictionaryTest.cs
 System/ConsoleTest.cs
 System/ConvertTest.cs
 System/DateTimeTest.cs
Index: System.Collections.Generic/ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Collections.Generic/ChangeLog,v
retrieving revision 1.22
diff -u -r1.22 ChangeLog
--- System.Collections.Generic/ChangeLog	20 Sep 2004 19:14:57 -0000	1.22
+++ System.Collections.Generic/ChangeLog	9 Nov 2004 08:36:23 -0000
@@ -1,3 +1,9 @@
+2004-11-08  Sureshkumar T  <tsureshkumar@novell.com>
+
+	* Dictionary.cs : Implemented Dictionary <K,V> based on LList.
+
+	* IDictionary.cs : corrected interface definitions
+
 2004-09-20  Gert Driesen <drieseng@users.sourceforge.net>
 
 	* ReadOnlyCollection.cs: Moved to System assembly
Index: System.Collections.Generic/Dictionary.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Collections.Generic/Dictionary.cs,v
retrieving revision 1.1
diff -u -r1.1 Dictionary.cs
--- System.Collections.Generic/Dictionary.cs	5 Sep 2004 12:01:13 -0000	1.1
+++ System.Collections.Generic/Dictionary.cs	9 Nov 2004 08:36:23 -0000
@@ -2,10 +2,10 @@
 // System.Collections.Generic.Dictionary
 //
 // Authors:
-//	Marek Safar (marek.safar@seznam.cz)
+//      Sureshkumar T (tsureshkumar@novell.com)
+//	Marek Safar (marek.safar@seznam.cz) (stubs)
 //
 //
-
 //
 // Copyright (C) 2004 Novell, Inc (http://www.novell.com)
 //
@@ -30,16 +30,450 @@
 //
 
 #if NET_2_0
+
 using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+
 
 namespace System.Collections.Generic
 {
-	[CLSCompliant(false)]
-	public class Dictionary <K, V> {
+        [Serializable, CLSCompliant (false)]
+        public class Dictionary<K, V> : IDictionary<K, V>,
+                ICollection<KeyValuePair<K, V>>,
+                IEnumerable<KeyValuePair<K, V>>,
+                IDictionary,
+                ICollection,
+                IEnumerable,
+                ISerializable,
+                IDeserializationCallback
+        {
+
+                #region Constants
+
+                private const int INITIAL_SIZE = 10;
+                private const int GROW_SIZE = 10;
+
+                #endregion // Constants
+
+                #region Fields
+        
+                private int _count = 0;
+                private int _capacity = 0;
+                private KeyValuePair<K, V> [] _values;
+
+                #endregion // Fields
+
+                #region Properties
+        
+                public int Count
+                {
+                        get { return _count; }
+                }
+
+                public int Capacity
+                {
+                        get { return _capacity; }
+                }
+
+                public V this [K key]
+                {
+                        get { return _values [IndexOf (key)].Value; }
+                        set
+                        {
+                                try {
+                                        int index = IndexOf (key);
+                                        _values [index].Value = value;
+                                } catch (KeyNotFoundException e) {
+                                }
+                        }
+                }
+
+                #endregion // Properties
+
+                #region Constructors
+                public Dictionary ()
+                {
+                        Init ();
+                }
+        
+                public Dictionary (IComparer<K> comparer)
+                {
+                        Init ();
+                }
+        
+                public Dictionary (IDictionary<K, V> dictionary)
+                {
+                        Init ();
+                }
+        
+                public Dictionary (int capacity)
+                {
+                        Init (capacity);
+                }
+        
+                public Dictionary (IDictionary<K, V> dictionary, IComparer<K> comparer)
+                {
+                        Init ();
+                }
+        
+                public Dictionary (int capacity, IComparer<K> comparer)
+                {
+                        Init (capacity);
+                }
+        
+                protected Dictionary (SerializationInfo info, StreamingContext context)
+                {
+                        Init ();
+                }
+                #endregion // Constructors
+
+                #region Private Methods
+
+                private void Init ()
+                {
+                        Init (INITIAL_SIZE);
+                }
+
+                private void Init (int capacity)
+                {
+                        _capacity = capacity;
+                        _values = new KeyValuePair<K, V> [_capacity];
+                }
+
+                private ICollection<V> GetValues ()
+                {
+                        List<V> collection = new List<V> ();
+                        for (int i = 0; i < Count; i++)
+                                collection.Add (_values [i].Value);
+                        return collection;
+                }
+        
+                private ICollection<K> GetKeys ()
+                {
+                        List<K> collection = new List<K> ();
+                        for (int i = 0; i < Count; i++)
+                                collection.Add (_values [i].Key);
+                        return collection;
+                }
+
+
+                private void CopyTo (KeyValuePair<K, V> [] array, int index)
+                {
+                        if (Count <= 0)
+                                return;
+                        Array.Copy (_values, 0, array, index, Count);
+                }
+
+                protected void Resize ()
+                {
+                        if (Count >= Capacity) {
+                                int newCapacity = Capacity + GROW_SIZE;
+                                KeyValuePair<K, V> [] newValues = new KeyValuePair<K, V> [newCapacity];
+                                _values.CopyTo (newValues, 0);
+                                _values = newValues;
+                                _capacity = newCapacity;
+                        }
+                }
+
+                internal KeyValuePair<K, V> this [int index]
+                {
+                        get
+                        {
+                                if (index < 0 || index >= Count)
+                                        throw new IndexOutOfRangeException ();
+                                return _values [index];
+                        }
+                }
+
+                #endregion // Private Methods
+
+                #region Methods
+
+        
+                public void Add (K key, V value)
+                {
+                        _values [NextSlot ()] = new KeyValuePair<K, V> (key, value);
+                }
+
+                internal int NextSlot ()
+                {
+                        if (Count >= Capacity)
+                                Resize ();
+                        return _count++;
+                }
+
+                public void Clear ()
+                {
+                        for (int i = 0; i < Count; i++)
+                                _values [i] = default (KeyValuePair<K,V>);
+
+                        _count = 0;
+                }
+                public bool ContainsKey (K key)
+                {
+                        try {
+                                int index = IndexOf (key);
+                        } catch (KeyNotFoundException e) {
+                                return false;
+                        }
+                        return true;
+                }
+                public bool ContainsValue (V value)
+                {
+                        for (int i = 0; i < Count; i++)
+                                if (_values [i].Value.Equals (value))
+                                        return true;
+                        return false;
+                }
+
+                public virtual void GetObjectData (SerializationInfo info, StreamingContext context)
+                {
+                        throw new NotImplementedException ();
+                }
+        
+                public virtual void OnDeserialization (object sender)
+                {
+                        throw new NotImplementedException ();
+                }
+
+                public bool Remove (K key)
+                {
+                        bool ret = true;
+                        try {
+                                int index = IndexOf (key);
+                                int rest = Count - index;
+                                if (rest > 0)
+                                        Array.Copy (_values, index + 1, _values, index, rest);
+                                _count--;
+                        } catch (KeyNotFoundException e) {
+                                ret = false;
+                        }
+                        return ret;
+                }
+
+                internal int IndexOf (K key)
+                {
+                        int count = 0;
+                        for (count = 0; count < Count; count++) {
+                                KeyValuePair<K, V> keyValue = _values [count];
+                                if (keyValue.Key.Equals (key))
+                                        return count;
+                        }
+                        throw new KeyNotFoundException ("key not found!");
+                }
+        
+        
+                public bool TryGetValue (K key, out V value)
+                {
+                        try {
+                                value = this [key];
+                        } catch (KeyNotFoundException e) {
+                                value = default (V);
+                                return false;
+                        }
+                        return true;
+                }
+        
+                #endregion // Methods
+
+                #region IDictionary Implementation
+        
+                ICollection<K> IDictionary<K, V>.Keys
+                {
+                        get { return GetKeys (); }
+                }
+
+                ICollection<V> IDictionary<K, V>.Values
+                {
+                        get { return GetValues (); }
+                }
+                bool IDictionary.IsFixedSize
+                {
+                        get { return false; }
+                }
+                bool IDictionary.IsReadOnly
+                {
+                        get { return false; }
+                }
+                object IDictionary.this [object key]
+                {
+                        get { return (object) this [(K) key]; }
+                        set { this [(K) key] = (V) value; }
+                }
+                ICollection IDictionary.Keys
+                {
+                        get { return GetKeys () as ICollection; }
+                }
+                ICollection IDictionary.Values
+                {
+                        get { return GetValues () as ICollection; }
+                }
+
+                void IDictionary.Add (object key, object value)
+                {
+                        if (!(key is K))
+                                throw new ArgumentException (
+                                                             String.Format ("The value \"{0}\" is not of type \"{1}\" and cannot be used in this generic collection",
+                                                                            key, typeof (K).ToString ()));
+                        if (!(value is V))
+                                throw new ArgumentException (
+                                                             String.Format ("The value \"{0}\" is not of type \"{1}\" and cannot be used in this generic collection",
+                                                                            value, typeof (V).ToString ()));
+                        Add ((K) key, (V) value);
+                }
+
+                bool IDictionary.Contains (object key)
+                {
+                        if (!(key is K))
+                                throw new ArgumentException (
+                                                             String.Format ("The value \"{0}\" is not of type \"{1}\" and cannot be used in this generic collection",
+                                                                            key, typeof (K).ToString ()));
+                        return ContainsKey ((K) key);
+                }
+
+                void IDictionary.Remove (object key)
+                {
+                        if (!(key is K))
+                                throw new ArgumentException (
+                                                             String.Format ("The value \"{0}\" is not of type \"{1}\" and cannot be used in this generic collection",
+                                                                            key, typeof (K).ToString ()));
+                        Remove ((K) key);
+                }
+
+        
+                #endregion // IDictionary Implementation
+
+                #region ICollection Implementation
+        
+                bool ICollection.IsSynchronized
+                {
+                        get { throw new NotImplementedException (); }
+                }
+                object ICollection.SyncRoot
+                {
+                        get { throw new NotImplementedException (); }
+                }
+
+                void ICollection.CopyTo (Array array, int index)
+                {
+                        CopyTo ((KeyValuePair<K, V> []) array, index);
+                }
+                bool ICollection<KeyValuePair<K, V>>.IsReadOnly
+                {
+                        get { return false; }
+                }
+
+                void ICollection<KeyValuePair<K, V>>.Add (KeyValuePair<K, V> keyValuePair)
+                {
+                        Add (keyValuePair.Key, keyValuePair.Value);
+                }
+
+                bool ICollection<KeyValuePair<K, V>>.Contains (KeyValuePair<K, V> keyValuePair)
+                {
+                        return ContainsKey (keyValuePair.Key);
+                }
+
+                void ICollection<KeyValuePair<K, V>>.CopyTo (KeyValuePair<K, V> [] array, int index)
+                {
+                        CopyTo (array, index);
+                }
+
+                bool ICollection<KeyValuePair<K, V>>.Remove (KeyValuePair<K, V> keyValuePair)
+                {
+                        return Remove (keyValuePair.Key);
+                }
+
+                #endregion // ICollection Implementation
+
+                #region Enumerator Implementation
+
+                [MonoTODO]
+                IEnumerator<KeyValuePair<K, V>> IEnumerable<KeyValuePair<K, V>>.GetEnumerator ()
+                {
+                        // FIXME : This gives compiler error. This should be fixed.
+                        //return (IEnumerator<KeyValuePair<K, V>>) GetEnumerator ();
+                        return null;
+                }
+
+                public Enumerator<K, V> GetEnumerator ()
+                {
+                        return new Enumerator<K, V> (this);
+                }
+                IDictionaryEnumerator IDictionary.GetEnumerator ()
+                {
+                        return (IDictionaryEnumerator) GetEnumerator ();
+                }
+
+                IEnumerator IEnumerable.GetEnumerator ()
+                {
+                        return (IEnumerator) GetEnumerator ();
+                }
+
+                #endregion // Enumerator Implementation
+
+                #region Nested Structures
+
+                [Serializable]
+                public struct Enumerator<K, V> : IEnumerator<KeyValuePair<K, V>>, IDisposable, IDictionaryEnumerator, IEnumerator
+                {
+                        private Dictionary<K, V> _dictionary;
+                        private int _index;
+
+                        public Enumerator (Dictionary<K, V> dictionary)
+                        {
+                                _index = -1;
+                                _dictionary = dictionary;
+                        }
+            
+                        public bool MoveNext ()
+                        {
+                                return ++_index < _dictionary.Count;
+                        }
+            
+                        public KeyValuePair<K, V> Current
+                        {
+                                get { return _dictionary [_index]; }
+                        }
+            
+                        object IEnumerator.Current
+                        {
+                                get { return ( (IDictionaryEnumerator) this).Entry as object; }
+                        }
+
+                        DictionaryEntry IDictionaryEnumerator.Entry
+                        {
+                                get
+                                {
+                                        KeyValuePair <K, V> keyValuePair = Current;
+                                        DictionaryEntry entry = new DictionaryEntry (keyValuePair.Key, keyValuePair.Value);
+                                        return entry;
+                                }
+                        }
+
+                        void IEnumerator.Reset ()
+                        {
+                                _index = -1;
+                        }
+
+                        object IDictionaryEnumerator.Key
+                        {
+                                get { return Current.Key; }
+                        }
+                        object IDictionaryEnumerator.Value
+                        {
+                                get { return Current.Value; }
+                        }
+
+                        public void Dispose ()
+                        {
+
+                        }
+                }
+
+                #endregion // Nested Structures
 
-		public Dictionary ()
-		{
-		}
-	}
+        }
 }
 #endif
Index: System.Collections.Generic/IDictionary.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Collections.Generic/IDictionary.cs,v
retrieving revision 1.5
diff -u -r1.5 IDictionary.cs
--- System.Collections.Generic/IDictionary.cs	11 Jun 2004 01:59:48 -0000	1.5
+++ System.Collections.Generic/IDictionary.cs	9 Nov 2004 08:36:23 -0000
@@ -37,16 +37,18 @@
 namespace System.Collections.Generic {
 	[CLSCompliant(false)]
 	[ComVisible(false)]
-	public interface IDictionary<K,V> : ICollection<KeyValuePair<K,V>> {
+	public interface IDictionary<K,V> 
+	// FIXME : the interface inheritance has been removed, since gmcs currently
+	// does not support the implementation of Dictionary class.
+	//public interface IDictionary<K,V>  :  ICollection<KeyValuePair<K, V>>, IEnumerable<KeyValuePair<K, V>>
+        {
 		void Add (K key, V value);
 		void Clear ();
 		bool ContainsKey (K key);
 		bool Remove (K key);
-		bool IsFixedSize { get; }
-		bool IsReadOnly { get; }
 		V this[K key] { get; set; }
-		ICollection<KeyValuePair<K,V>> Keys { get; }
-		ICollection<KeyValuePair<K,V>> Values { get; }
+		ICollection<K> Keys { get; }
+		ICollection<V> Values { get; }
 	}
 }
 #endif
Index: Test/ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/Test/ChangeLog,v
retrieving revision 1.94
diff -u -r1.94 ChangeLog
--- Test/ChangeLog	14 Nov 2003 07:36:29 -0000	1.94
+++ Test/ChangeLog	9 Nov 2004 08:36:24 -0000
@@ -1,3 +1,10 @@
+2004-11-08  Sureshkumar T  <tsureshkumar@novell.com>
+
+	* System.Collections.Generic/ : Added a directory for Generics
+	Test
+	* System.Collections.Generic/DictionaryTest.cs : Test for Generic
+	Dicitionary Class
+
 2003-11-14  Gonzalo Paniagua Javier <gonzalo@ximian.com>
 
 	* corlib_linux_test.args: Removed file.
