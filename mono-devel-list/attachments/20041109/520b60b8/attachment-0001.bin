//
// MonoTests.System.Collections.Generic.Test.DictionaryTest
//
// Authors:
//      Sureshkumar T (tsureshkumar@novell.com)
//
// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#if NET_2_0

#region Using directives

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

using NUnit.Framework;

#endregion // Using directives

namespace MonoTests.System.Collections.Generic.Test
{
    [TestFixture]
    public class DictionaryTest
    {
        Dictionary<string, object> _dictionary = null;

        [SetUp]
        public void SetUp ()
        {
            _dictionary = new Dictionary<string, object> ();
        }

        [Test]
        public void AddTest ()
        {
            _dictionary.Add ("key1", (object) "value");
            Assert.AreEqual ("value", _dictionary ["key1"].ToString (), "Add failed!");
        }

        [Test, ExpectedException (typeof (KeyNotFoundException))]
        public void RemoveTest ()
        {
            _dictionary.Add ("key1", (object) "value1");
            _dictionary.Add ("key2", (object) "value2");
            _dictionary.Add ("key3", (object) "value3");
            _dictionary.Add ("key4", (object) "value4");
            _dictionary.Remove ("key3");
            Assert.AreEqual (3, _dictionary.Count);
            string value = _dictionary ["key3"].ToString ();
        }

        [Test, ExpectedException (typeof (KeyNotFoundException))]
        public void ClearTest ()
        {
            _dictionary.Add ("key1", (object) "value1");
            _dictionary.Add ("key2", (object) "value2");
            _dictionary.Add ("key3", (object) "value3");
            _dictionary.Add ("key4", (object) "value4");
            _dictionary.Clear ();
            Assert.AreEqual (0, _dictionary.Count, "Clear method failed!");
            string value = _dictionary ["key2"].ToString ();
        }

        [Test]
        public void ContainsKeyTest ()
        {
            _dictionary.Add ("key1", (object) "value1");
            _dictionary.Add ("key2", (object) "value2");
            _dictionary.Add ("key3", (object) "value3");
            _dictionary.Add ("key4", (object) "value4");
            bool contains = _dictionary.ContainsKey ("key4");
            Assert.IsTrue (contains, "ContainsKey does not return correct value!");
            contains = _dictionary.ContainsKey ("key5");
            Assert.IsFalse (contains, "ContainsKey for non existant does not return correct value!");
        }

        [Test]
        public void ContainsValueTest ()
        {
            _dictionary.Add ("key1", (object) "value1");
            _dictionary.Add ("key2", (object) "value2");
            _dictionary.Add ("key3", (object) "value3");
            _dictionary.Add ("key4", (object) "value4");
            bool contains = _dictionary.ContainsValue ("value2");
            Assert.IsTrue (contains, "ContainsValue does not return correct value!");
            contains = _dictionary.ContainsValue ("@@daisofja@@");
            Assert.IsFalse (contains, "ContainsValue for non existant does not return correct value!");
        }

        [Test]
        public void TryGetValueTest ()
        {
            _dictionary.Add ("key1", (object) "value1");
            _dictionary.Add ("key2", (object) "value2");
            _dictionary.Add ("key3", (object) "value3");
            _dictionary.Add ("key4", (object) "value4");
            object value = "";
            _dictionary.TryGetValue ("key4", out value);
            Assert.AreEqual ("value4", (string) value, "TryGetValue does not return value!");

            _dictionary.TryGetValue ("key7", out value);
            Assert.IsNull (value, "value for non existant value should be null!");

        }

        private class MyTest
        {
            public string Name;
            public int RollNo;

            public MyTest (string name, int number)
            {
                Name = name;
                RollNo = number;
            }

            public override bool Equals (object obj)
            {
                MyTest myt = obj as MyTest;
                return myt.Name.Equals (this.Name) &&
                            myt.RollNo.Equals (this.RollNo);
            }

        }
        
        [Test]
        public void ObjectAsKeyTest ()
        {
            Dictionary<object, object> dict = new Dictionary<object, object> ();
            MyTest key1, key2, key3;
            dict.Add ((object) (key1 = new MyTest ("key1", 234)),   (object) "value1");
            dict.Add ((object) (key2 = new MyTest ("key2", 444)),   (object) "value2");
            dict.Add ((object) (key3 = new MyTest ("key3", 5655)),  (object) "value3");

            Assert.AreEqual ((object) "value2", dict [key2], "value is not returned!");
            // FIXME : here the behaviour deviates! 
            Assert.AreEqual ((object) "value3", dict [ (object) new MyTest ("key3", 5655)], "neg: exception should not be thrown!");
        }

        [Test, ExpectedException (typeof (ArgumentException))]
        public void IDictionaryAddTest ()
        {
            IDictionary iDict = _dictionary as IDictionary;
            iDict.Add ((object) "key1", (object) "value1");
            iDict.Add ((object) "key2", (object) "value3");
            Assert.AreEqual (2, iDict.Count, "IDictioanry interface add is not working!");

            //Negative test case
            iDict.Add ((object) 12, (object) "value");
            iDict.Add ((object) "key", (object) 34);
        }

        [Test]
        public void IEnumeratorTest ()
        {
            _dictionary.Add ("key1", (object) "value1");
            _dictionary.Add ("key2", (object) "value2");
            _dictionary.Add ("key3", (object) "value3");
            _dictionary.Add ("key4", (object) "value4");
            IEnumerator itr = ((IEnumerable) _dictionary).GetEnumerator ();
            while (itr.MoveNext ()) {
                object o = itr.Current;
                Assert.AreEqual (typeof (DictionaryEntry), o.GetType (), "Current should return a type of DictionaryEntry");
                DictionaryEntry entry = (DictionaryEntry) itr.Current;
                if ( entry.Key.ToString () == "key4")
                    entry.Value = "value33";
            }
            Assert.AreEqual ("value4", _dictionary ["key4"].ToString (), "");
        }

        [Test]
        public void IEnumeratorGenericTest ()
        {
            _dictionary.Add ("key1", (object) "value1");
            _dictionary.Add ("key2", (object) "value2");
            _dictionary.Add ("key3", (object) "value3");
            _dictionary.Add ("key4", (object) "value4");
            IEnumerator<KeyValuePair<string, object>> itr = ((IEnumerable<KeyValuePair<string, object>>) _dictionary).GetEnumerator ();
            while (itr.MoveNext ()) {
                object o = itr.Current;
                Assert.AreEqual (typeof (KeyValuePair<string, object>), o.GetType (), "Current should return a type of DictionaryEntry");
                KeyValuePair<string, object> entry = (KeyValuePair<string, object>) itr.Current;
                if (entry.Key.ToString () == "key4")
                    entry.Value = "value33";
            }
            Assert.AreEqual ("value4", _dictionary ["key4"].ToString (), "");

        }

        [Test]
        public void IDictionaryEnumeratorTest ()
        {
            _dictionary.Add ("key1", (object) "value1");
            _dictionary.Add ("key2", (object) "value2");
            _dictionary.Add ("key3", (object) "value3");
            _dictionary.Add ("key4", (object) "value4");
            IDictionaryEnumerator itr = ((IDictionary) _dictionary).GetEnumerator ();
            while (itr.MoveNext ()) {
                object o = itr.Current;
                Assert.AreEqual (typeof (DictionaryEntry), o.GetType (), "Current should return a type of DictionaryEntry");
                DictionaryEntry entry = (DictionaryEntry) itr.Current;
                if (entry.Key.ToString () == "key4")
                    entry.Value = "value33";
            }
            Assert.AreEqual ("value4", _dictionary ["key4"].ToString (), "");

        }

        [Test]
        public void ForEachTest ()
        {
            _dictionary.Add ("key1", (object) "value1");
            _dictionary.Add ("key2", (object) "value2");
            _dictionary.Add ("key3", (object) "value3");
            _dictionary.Add ("key4", (object) "value4");
            foreach (KeyValuePair<string, object> entry in _dictionary) {
            }

            foreach (DictionaryEntry entry in ((IEnumerable) _dictionary)) {
            }

            foreach (DictionaryEntry entry in ((IDictionary) _dictionary)) {
            }
        }
    }
}

#endif // NET_2_0
