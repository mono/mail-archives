Index: DriveInfo.cs
===================================================================
--- DriveInfo.cs	(revision 90804)
+++ DriveInfo.cs	(working copy)
@@ -27,6 +27,7 @@
 using System.Text;
 using System.Runtime.Serialization;
 using System.Runtime.InteropServices;
+using System.Runtime.CompilerServices;
 
 namespace System.IO {
 	[SerializableAttribute] 
@@ -48,7 +49,18 @@
 
 		public DriveInfo (string driveName)
 		{
+			if (null == driveName)
+				throw new ArgumentNullException("driveName");
+
 			DriveInfo [] drives = GetDrives ();
+			// A quite hackish solution to the fact that WindowsGetDrives returns identifiers
+			// like C:\, while this method may well receive C or C:
+			if (Environment.IsRunningOnWindows) {
+				if (driveName.Length == 1)
+					driveName += ":\\";
+				else if (driveName.Length == 2 && driveName[1] == ':')
+					driveName += "\\";
+			}
 
 			foreach (DriveInfo d in drives){
 				if (d.path == driveName){
@@ -69,28 +81,21 @@
 			Windows,
 		}
 		
-		[MonoTODO("Always returns infinite")]
 		public long AvailableFreeSpace {
 			get {
-				if (DriveType == DriveType.CDRom || DriveType == DriveType.Ram || DriveType == DriveType.Unknown)
-					return 0;
-				return Int64.MaxValue;
+				return (long)GetFSUsage(this.path, GetFSUsage_Field.AvailFree);
 			}
 		}
 
-		[MonoTODO("Always returns infinite")]
 		public long TotalFreeSpace {
 			get {
-				if (DriveType == DriveType.CDRom || DriveType == DriveType.Ram || DriveType == DriveType.Unknown)
-					return 0;
-				return Int64.MaxValue;
+				return (long)GetFSUsage(this.path, GetFSUsage_Field.TotalFree);
 			}
 		}
 
-		[MonoTODO("Always returns infinite")]
 		public long TotalSize {
 			get {
-				return Int64.MaxValue;
+				return (long)GetFSUsage(this.path, GetFSUsage_Field.TotalSize);
 			}
 		}
 
@@ -199,6 +204,8 @@
 				string line;
 				
 				while ((line = mounts.ReadLine ()) != null){
+					// Skip the virtual, kernel-defined "rootfs" because it does not refer to
+					// the mounted / fs: there will be another line for that one
 					if (line.StartsWith ("rootfs"))
 						continue;
 					int p;
@@ -216,6 +223,7 @@
 					if (p == -1)
 						continue;
 					string fstype = rest.Substring (0, p);
+
 					drives.Add (new DriveInfo (_DriveType.Linux, path, fstype));
 				}
 
@@ -228,10 +236,10 @@
 			DriveInfo [] di = null;
 
 			try {
-				using (StreamReader linux_ostype = TryOpen ("/proc/sys/kernel/ostype")){
-					Console.WriteLine ("here {0}", linux_ostype);
-					if (linux_ostype != null){
-						string line = linux_ostype.ReadLine ();
+				using (StreamReader detect_ostype = TryOpen ("/proc/sys/kernel/ostype")){
+					Console.WriteLine ("here {0}", detect_ostype);
+					if (detect_ostype != null){
+						string line = detect_ostype.ReadLine ();
 
 						Console.WriteLine ("L: {0}", line);
 						if (line == "Linux")
@@ -252,23 +260,31 @@
 			return unknown;
 		}
 
+		[MonoTODO ("Add filesystem type detection")]
 		static DriveInfo [] WindowsGetDrives ()
 		{
-			throw new NotImplementedException ();
+			string [] driveLetters = Environment.GetLogicalDrives ();
+			DriveInfo [] retVal = new DriveInfo [driveLetters.Length];
+			for (int i = 0; i < driveLetters.Length; i++)
+				retVal [i] = new DriveInfo (_DriveType.Windows, driveLetters [i], "");
+			return retVal;
 		}
-		
-		[MonoTODO("Currently only implemented on Mono/Linux")]
-		public static DriveInfo[] GetDrives ()
+
+		public static DriveInfo[] GetDrives()
 		{
 			int platform = (int) Environment.Platform;
 
+			// This ugly hack is required because the Unix platform enum value was not defined in .NET 1.0, so Mono
+			// assigned it a value presumably non-conflicting valule of 128, but then in .NET 2.0 Microsoft decided to
+			// include it and defined it as the next available enum value, that is, 4. So we check for both values,
+			// which should work for both versions 1 and 2+, without the need of an even uglier #if
 			if (platform == 4 || platform == 128)
 				return UnixGetDrives ();
 			else
 				return WindowsGetDrives ();
 		}
 
-		void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
+		void ISerializable.GetObjectData (SerializationInfo info, StreamingContext context)
 		{
 			throw new NotImplementedException ();
 		}
@@ -277,6 +293,16 @@
 		{
 			return(Name);
 		}
+
+		private enum GetFSUsage_Field
+		{
+			TotalSize = 1,
+			TotalFree = 2,
+			AvailFree = 3
+		}
+
+		[MethodImpl (MethodImplOptions.InternalCall)]
+		private extern static ulong GetFSUsage (string path, GetFSUsage_Field field);
 	}
 }
 