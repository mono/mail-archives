Index: Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncReceiveTest.cs
===================================================================
--- Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncReceiveTest.cs	(revision 0)
+++ Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncReceiveTest.cs	(revision 0)
@@ -0,0 +1,130 @@
+//
+// Test.Mono.Messaging.RabbitMQ
+//
+// Authors:
+//	  Michael Barker (mike@middlesoft.co.uk)
+//
+// (C) 2008 Michael Barker
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Messaging;
+using System.Reflection;
+using System.Threading;
+using System.Text.RegularExpressions;
+
+using NUnit.Framework;
+
+namespace MonoTests.Mono.Messaging.RabbitMQ
+{
+	[TestFixture]
+	public class AsyncReceiveTest {
+
+		private Message m;
+		private string failureMessage = null;
+		private string state = null;
+		
+		private void HandleMessage (object source, ReceiveCompletedEventArgs args) {
+			try {
+				MessageQueue q = (MessageQueue) source;
+				m = q.EndReceive (args.AsyncResult);
+				state = (string) args.AsyncResult.AsyncState;
+			} catch (Exception e) {
+				failureMessage = e.Message;
+			}
+		}
+
+		[Test]
+		public void BeginReceive()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-receive-1");
+			Message s = new Message (new BinaryMessageFormatter ());
+			string body = "foo-" + DateTime.Now.ToString ();
+			s.Body = body;
+			q.Send (s);
+			
+			q.ReceiveCompleted += new ReceiveCompletedEventHandler (HandleMessage);
+			IAsyncResult result = q.BeginReceive ();
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndReceive (result);
+			Assert.IsNotNull (rMsg, "No message received");
+			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
+		}
+		
+		[Test]
+		public void BeginReceiveWithTimeout()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-receive-2");
+			Message s = new Message (new BinaryMessageFormatter ());
+			string body = "foo-" + DateTime.Now.ToString ();
+			s.Body = body;
+			q.Send (s);
+			
+			IAsyncResult result = q.BeginReceive (new TimeSpan (0, 0, 2));
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndReceive (result);
+			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
+		}
+		
+		[Test]
+		public void BeginReceiveWithStateAndTimeout()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-receive-3");
+			Message s = new Message (new BinaryMessageFormatter ());
+			string body = "foo-" + DateTime.Now.ToString ();
+			s.Body = body;
+			q.Send (s);
+			
+			IAsyncResult result = q.BeginReceive (new TimeSpan (0, 0, 2), "foo");
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndReceive (result);
+			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
+			Assert.AreEqual ("foo", result.AsyncState, "State not passed properly");
+		}
+		
+		private bool success = false;
+		
+		public void TestCallback (IAsyncResult result)
+		{
+			success = true;
+		}
+		
+		[Test]
+		public void BeginReceiveWithStateAndTimeoutAndCallback()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-receive-4");
+			Message s = new Message (new BinaryMessageFormatter ());
+			string body = "foo-" + DateTime.Now.ToString ();
+			s.Body = body;
+			q.Send (s);
+			AsyncCallback ac = new AsyncCallback (TestCallback);
+			IAsyncResult result = q.BeginReceive (new TimeSpan (0, 0, 2), "foo", ac);
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndReceive (result);
+			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
+			Assert.AreEqual ("foo", result.AsyncState, "State not passed properly");
+			Assert.IsTrue (success, "Callback not run");
+		}
+	}
+}
Index: Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncPeekTest.cs
===================================================================
--- Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncPeekTest.cs	(revision 0)
+++ Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncPeekTest.cs	(revision 0)
@@ -0,0 +1,129 @@
+//
+// Test.Mono.Messaging.RabbitMQ
+//
+// Authors:
+//	  Michael Barker (mike@middlesoft.co.uk)
+//
+// (C) 2008 Michael Barker
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Messaging;
+using System.Reflection;
+using System.Threading;
+using System.Text.RegularExpressions;
+
+using NUnit.Framework;
+
+namespace MonoTests.Mono.Messaging.RabbitMQ
+{
+	[TestFixture]
+	public class AsyncPeekTest {
+
+		bool eventCalled = false;
+		
+		private void HandleMessage (object source, PeekCompletedEventArgs args) {
+			eventCalled = true;
+		}
+
+		[Test]
+		public void BeginPeek()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-peek-1");
+			Message s = new Message (new BinaryMessageFormatter ());
+			string body = "foo-" + DateTime.Now.ToString ();
+			s.Body = body;
+			q.Send (s);
+			
+			q.PeekCompleted += new PeekCompletedEventHandler (HandleMessage);
+			IAsyncResult result = q.BeginPeek ();
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndPeek (result);
+			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
+			Assert.IsTrue (eventCalled, "Handle Message not called");
+			q.Purge ();
+		}
+		
+		[Test]
+		public void BeginPeekWithTimeout()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-peek-2");
+			Message s = new Message (new BinaryMessageFormatter ());
+			string body = "foo-" + DateTime.Now.ToString ();
+			s.Body = body;
+			q.Send (s);
+			
+			IAsyncResult result = q.BeginPeek (new TimeSpan (0, 0, 2));
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndPeek (result);
+			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
+			
+			q.Purge ();
+		}
+		
+		[Test]
+		public void BeginPeekWithStateAndTimeout()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-peek-3");
+			Message s = new Message (new BinaryMessageFormatter ());
+			string body = "foo-" + DateTime.Now.ToString ();
+			s.Body = body;
+			q.Send (s);
+			
+			IAsyncResult result = q.BeginPeek (new TimeSpan (0, 0, 2), "foo");
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndPeek (result);
+			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
+			Assert.AreEqual ("foo", result.AsyncState, "State not passed properly");
+			
+			q.Purge ();
+		}
+		
+		private bool success = false;
+		
+		public void TestCallback (IAsyncResult result)
+		{
+			success = true;
+		}
+		
+		[Test]
+		public void BeginPeekWithStateAndTimeoutAndCallback()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-peek-4");
+			Message s = new Message (new BinaryMessageFormatter ());
+			string body = "foo-" + DateTime.Now.ToString ();
+			s.Body = body;
+			q.Send (s);
+			AsyncCallback ac = new AsyncCallback (TestCallback);
+			IAsyncResult result = q.BeginPeek (new TimeSpan (0, 0, 2), "foo", ac);
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndPeek (result);
+			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
+			Assert.AreEqual ("foo", result.AsyncState, "State not passed properly");
+			Assert.IsTrue (success, "Callback not run");
+			
+			q.Purge ();			
+		}
+	}
+}
Index: Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/ChangeLog
===================================================================
--- Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/ChangeLog	(revision 121964)
+++ Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2008-12-20  Michael Barker  <mike@middlesoft.co.uk>
+
+	* AsyncReceiveTest.cs:  New, tests for Asynchronous Receive methods.
+	* AsyncPeekTest.cs:  New, tests for Asynchronous Peek methods.
+	* MessageQueueEnumeratorTest.cs:  Removed unecesary logging.
+
 2008-12-06  Michael Barker  <mike@middlesoft.co.uk>
 
 	* AdminTest.cs:  Updated to run against MS.NET
Index: Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/MessageEnumeratorTest.cs
===================================================================
--- Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/MessageEnumeratorTest.cs	(revision 121964)
+++ Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/MessageEnumeratorTest.cs	(working copy)
@@ -81,7 +81,6 @@
 			
 			Message m1 = me1.Current;
 			m1.Formatter = new BinaryMessageFormatter ();
-			Console.WriteLine ("{0}", m1.Body);
 			Assert.AreEqual ("message 4", (String) m1.Body, "body incorrect");
 			
 			mq1.Purge ();
Index: Mono.Messaging.RabbitMQ/Mono.Messaging.RabbitMQ_test.dll.sources
===================================================================
--- Mono.Messaging.RabbitMQ/Mono.Messaging.RabbitMQ_test.dll.sources	(revision 121964)
+++ Mono.Messaging.RabbitMQ/Mono.Messaging.RabbitMQ_test.dll.sources	(working copy)
@@ -6,4 +6,6 @@
 Mono.Messaging.RabbitMQ/MessageEnumeratorTest.cs
 Mono.Messaging.RabbitMQ/PeekTest.cs
 Mono.Messaging.RabbitMQ/TransactionMessagingTest.cs
-Mono.Messaging.RabbitMQ/SelectorTest.cs
\ No newline at end of file
+Mono.Messaging.RabbitMQ/SelectorTest.cs
+Mono.Messaging.RabbitMQ/AsyncReceiveTest.cs
+Mono.Messaging.RabbitMQ/AsyncPeekTest.cs
\ No newline at end of file
Index: Mono.Messaging.RabbitMQ/Mono.Messaging.RabbitMQ/RabbitMQMessageQueue.cs
===================================================================
--- Mono.Messaging.RabbitMQ/Mono.Messaging.RabbitMQ/RabbitMQMessageQueue.cs	(revision 121964)
+++ Mono.Messaging.RabbitMQ/Mono.Messaging.RabbitMQ/RabbitMQMessageQueue.cs	(working copy)
@@ -43,7 +43,7 @@
 
 namespace Mono.Messaging.RabbitMQ {
 
-	public class RabbitMQMessageQueue : IMessageQueue {
+	public class RabbitMQMessageQueue : MessageQueueBase, IMessageQueue {
 		
 		private bool authenticate = false;
 		private short basePriority = 0;
@@ -83,6 +83,10 @@
 			this.qRef = qRef;
 			this.transactional = transactional;
 		}
+		
+		protected override IMessageQueue Queue {
+			get { return this; }
+		}
 
 		public bool Authenticate {
 			get { return authenticate; }
@@ -324,29 +328,11 @@
 		public IMessage Peek (TimeSpan timeout)
 		{
 			return Run (Peeker (timeout));
-//			ConnectionFactory cf = new ConnectionFactory ();
-//
-//			using (IConnection cn = cf.CreateConnection (QRef.Host)) {
-//				using (IModel ch = cn.CreateModel ()) {
-//					if (timeout == TimeSpan.MaxValue) {
-//						return Receive (ch, -1, false);
-//					} else {
-//						return Receive (ch, (int) timeout.TotalMilliseconds, false);
-//					}
-//				}
-//			}
 		}
 		
 		public IMessage PeekById (string id)
 		{
 			return Run (Peeker (ById (id)));
-//			ConnectionFactory cf = new ConnectionFactory ();
-//
-//			using (IConnection cn = cf.CreateConnection (QRef.Host)) {
-//				using (IModel ch = cn.CreateModel ()) {
-//					return Receive (ch, 500, true, new IdMatcher (id).MatchById);
-//				}
-//			}
 		}
 
 		public IMessage PeekById (string id, TimeSpan timeout)
@@ -357,14 +343,6 @@
 		public IMessage PeekByCorrelationId (string id)
 		{
 			return Run (Peeker (ByCorrelationId (id)));
-//			ConnectionFactory cf = new ConnectionFactory ();
-//
-//			using (IConnection cn = cf.CreateConnection (QRef.Host)) {
-//				using (IModel ch = cn.CreateModel ()) {
-//					return Receive (ch, 500, false, 
-//					                new CorrelationIdMatcher (id).MatchById);
-//				}
-//			}
 		}
 
 		public IMessage PeekByCorrelationId (string id, TimeSpan timeout)
@@ -694,8 +672,6 @@
 		
 		private IMessage Receive (IModel model, int timeout, bool doAck)
 		{
-			Console.WriteLine ("{0}, {1}", timeout, doAck);
-			
 			ushort ticket = model.AccessRequest (realm);
 			string finalName = model.QueueDeclare (ticket, QRef.Queue, false);
 			
@@ -715,8 +691,6 @@
 		private IMessage Receive (IModel model, int timeout, 
 		                          bool doAck, IsMatch matcher)
 		{
-			Console.WriteLine ("{0}, {1}", timeout, doAck);
-			
 			ushort ticket = model.AccessRequest (realm);
 			string finalName = model.QueueDeclare (ticket, QRef.Queue, false);
 			
Index: Mono.Messaging.RabbitMQ/Mono.Messaging.RabbitMQ/ChangeLog
===================================================================
--- Mono.Messaging.RabbitMQ/Mono.Messaging.RabbitMQ/ChangeLog	(revision 121964)
+++ Mono.Messaging.RabbitMQ/Mono.Messaging.RabbitMQ/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2008-12-22  Michael Barker  <mike@middlesoft.co.uk>
+
+	* RabbitMQMessageQueue.cs:  Changed to extend MessageQueueBase to make use
+	of default asynchronous Receive/Peek methods.
+
 2008-12-07  Michael Barker  <mike@middlesoft.co.uk>
 
 	* RabbitMQMessageQueue.cs:  Throw MessageUnavailableException when there are