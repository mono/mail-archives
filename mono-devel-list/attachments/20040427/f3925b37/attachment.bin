Index: inssel-x86.brg
===================================================================
RCS file: /cvs/public/mono/mono/mini/inssel-x86.brg,v
retrieving revision 1.19
diff -u -r1.19 inssel-x86.brg
--- inssel-x86.brg	13 Apr 2004 20:15:05 -0000	1.19
+++ inssel-x86.brg	26 Apr 2004 03:02:56 -0000
@@ -407,6 +407,36 @@
 	}
 }
 
+reg: CEE_LDELEMA (OP_ICONST, reg) {
+	guint32 size = mono_class_array_element_size (tree->klass);
+	if (size == 1) {
+		tree->opcode = OP_X86_LEA_MEMBASE;
+		tree->sreg1 = state->right->reg1;
+		tree->inst_imm = G_STRUCT_OFFSET (MonoArray, vector) + state->left->tree->inst_c0;
+		tree->dreg = state->reg1;
+		mono_bblock_add_inst (s->cbb, tree);
+	} else if (size == 2 || size == 4 || size == 8) {
+		static const int fast_log2 [] = { 1, 0, 1, -1, 2, -1, -1, -1, 3 };
+		tree->opcode = OP_X86_LEA;
+		tree->dreg = state->reg1;
+		tree->sreg1 = X86_NOBASEREG;
+		tree->sreg2 = state->right->reg1;
+		tree->inst_imm = G_STRUCT_OFFSET (MonoArray, vector) + state->left->tree->inst_c0;
+		tree->unused = fast_log2 [size];
+		mono_bblock_add_inst (s->cbb, tree);
+	} else {
+		int mult_reg = mono_regstate_next_int (s->rs);
+		int add_reg = mono_regstate_next_int (s->rs);
+		MONO_EMIT_NEW_BIALU_IMM (s, OP_MUL_IMM, mult_reg, state->right->reg1, size);
+		MONO_EMIT_NEW_BIALU_IMM (s, OP_ADD_IMM, state->reg1, add_reg, G_STRUCT_OFFSET (MonoArray, vector) + state->left->tree->inst_c0);
+	}
+} cost {
+	MBCOND (mono_array_length (((MonoArray*)state->left->tree->inst_p0)) >= 256);
+	MBCOND (state->right->tree->opcode == CEE_LDIND_U1);
+	
+	return 5;
+}
+
 stmt: CEE_STIND_R8 (OP_REGVAR, freg) {
 	/* nothing to do: the value is already on the FP stack */
 }
