Index: System.Text/StringBuilder.cs
===================================================================
--- System.Text/StringBuilder.cs	(revision 94486)
+++ System.Text/StringBuilder.cs	(working copy)
@@ -86,7 +86,7 @@
 
 			_str = String.InternalAllocateStr ((length > capacity) ? length : capacity);
 			if (length > 0)
-				String.InternalStrcpy(_str, 0, value, startIndex, length);
+				String.CharCopy (_str, 0, value, startIndex, length);
 			
 			_length = length;
 		}
@@ -258,7 +258,7 @@
 			// Copy everything after the 'removed' part to the start 
 			// of the removed part and truncate the sLength
 			if (_length - (startIndex + length) > 0)
-				String.InternalStrcpy (_str, startIndex, _str, startIndex + length, _length - (startIndex + length));
+				String.CharCopy (_str, startIndex, _str, startIndex + length, _length - (startIndex + length));
 
 			_length -= length;
 
@@ -309,8 +309,8 @@
 
 			string end = _str.Substring (startIndex + count, _length - startIndex - count );
 
-			String.InternalStrcpy (_str, startIndex, replace);
-			String.InternalStrcpy (_str, startIndex + replace.Length, end);
+			String.CharCopy (_str, startIndex, replace, 0, replace.Length);
+			String.CharCopy (_str, startIndex + replace.Length, end, 0, end.Length);
 			
 			_length = replace.Length + (_length - count);
 
@@ -328,7 +328,7 @@
 			if (null != _cached_str || _str.Length < needed_cap)
 				InternalEnsureCapacity (needed_cap);
 			
-			String.InternalStrcpy (_str, _length, value);
+			String.CharCopy (_str, _length, value, 0, value.Length);
 			_length = needed_cap;
 
 			return this;
@@ -349,7 +349,7 @@
 			if (null != _cached_str || _str.Length < needed_cap)
 				InternalEnsureCapacity (needed_cap);
 
-			String.InternalStrcpy (_str, _length, value);
+			String.CharCopy (_str, _length, value, 0, value.Length);
 			_length = needed_cap;
 			return this;
 		}
@@ -453,7 +453,7 @@
 			int needed_cap = _length + charCount;
 			InternalEnsureCapacity (needed_cap);
 
-			String.InternalStrcpy (_str, _length, value, startIndex, charCount);
+			String.CharCopy (_str, _length, value, startIndex, charCount);
 			_length = needed_cap;
 
 			return this;
@@ -475,7 +475,7 @@
 			if (null != _cached_str || _str.Length < needed_cap)
 				InternalEnsureCapacity (needed_cap);
 
-			String.InternalStrcpy (_str, _length, value, startIndex, count);
+			String.CharCopy (_str, _length, value, startIndex, count);
 			
 			_length = needed_cap;
 
@@ -557,10 +557,10 @@
 			InternalEnsureCapacity (_length + value.Length);
 
 			// Move everything to the right of the insert point across
-			String.InternalStrcpy (_str, index + value.Length, _str, index, _length - index);
+			String.CharCopyReverse (_str, index + value.Length, _str, index, _length - index);
 			
 			// Copy in stuff from the insert buffer
-			String.InternalStrcpy (_str, index, value);
+			String.CharCopy (_str, index, value, 0, value.Length);
 			
 			_length += value.Length;
 
@@ -583,7 +583,7 @@
 			InternalEnsureCapacity (_length + 1);
 			
 			// Move everything to the right of the insert point across
-			String.InternalStrcpy (_str, index + 1, _str, index, _length - index);
+			String.CharCopyReverse (_str, index + 1, _str, index, _length - index);
 			
 			_str.InternalSetChar (index, value);
 			_length++;
@@ -698,7 +698,7 @@
 
 				string tmp = String.InternalAllocateStr (capacity);
 				if (_length > 0)
-					String.InternalStrcpy (tmp, 0, _str, 0, _length);
+					String.CharCopy (tmp, 0, _str, 0, _length);
 
 				_str = tmp;
 			}
Index: System/String.cs
===================================================================
--- System/String.cs	(revision 94486)
+++ System/String.cs	(working copy)
@@ -7,6 +7,7 @@
 //   Dan Lewis (dihlewis@yahoo.co.uk)
 //   Sebastien Pouliot  <sebastien@ximian.com>
 //   Marek Safar (marek.safar@seznam.cz)
+//   Andreas Nahr (Classdevelopment@A-SoftTech.com)
 //
 // (C) 2001 Ximian, Inc.  http://www.ximian.com
 // Copyright (C) 2004-2005 Novell (http://www.novell.com)
@@ -156,9 +157,8 @@
 			return TypeCode.String;
 		}
 
-		public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count)
+		public unsafe void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count)
 		{
-			// LAMESPEC: should I null-terminate?
 			if (destination == null)
 				throw new ArgumentNullException ("destination");
 
@@ -172,15 +172,19 @@
 			if (destinationIndex > destination.Length - count)
 				throw new ArgumentOutOfRangeException ("destinationIndex + count > destination.Length");
 
-			InternalCopyTo (sourceIndex, destination, destinationIndex, count);
+			fixed (char* dest = destination, src = this)
+				CharCopy (dest + destinationIndex, src + sourceIndex, count);
 		}
 
-		public char[] ToCharArray ()
+		public unsafe char[] ToCharArray ()
 		{
-			return ToCharArray (0, length);
+			char[] tmp = new char [length];
+			fixed (char* dest = tmp, src = this)
+				CharCopy (dest, src, length);
+			return tmp;
 		}
 
-		public char[] ToCharArray (int startIndex, int length)
+		public unsafe char[] ToCharArray (int startIndex, int length)
 		{
 			if (startIndex < 0)
 				throw new ArgumentOutOfRangeException ("startIndex", "< 0"); 
@@ -191,59 +195,55 @@
 				throw new ArgumentOutOfRangeException ("startIndex + length > this.length"); 
 
 			char[] tmp = new char [length];
-
-			InternalCopyTo (startIndex, tmp, 0, length);
-
+			fixed (char* dest = tmp, src = this)
+				CharCopy (dest + startIndex, src, length);
 			return tmp;
 		}
 
 		public String [] Split (params char [] separator)
 		{
-			return Split (separator, Int32.MaxValue);
+			if (separator == null || separator.Length == 0)
+				separator = null;
+			return SplitKeepEmpty (length, separator);
 		}
 
 		public String[] Split (char[] separator, int count)
 		{
-			if (separator == null || separator.Length == 0)
-				separator = WhiteChars;
-
 			if (count < 0)
 				throw new ArgumentOutOfRangeException ("count");
 
-			if (count == 0) 
+			if (count == 0)
 				return new String[0];
 
-			if (count == 1) 
-				return new String[1] { ToString() };
+			if (separator == null || separator.Length == 0)
+				separator = null;
 
-			return InternalSplit (separator, count, 0);
+			return SplitKeepEmpty (count - 1, separator);
 		}
 
 #if NET_2_0
 		[ComVisible (false)]
-		[MonoDocumentationNote ("code should be moved to managed")]
 		public String[] Split (char[] separator, int count, StringSplitOptions options)
 		{
-			if (separator == null || separator.Length == 0)
-				return Split (WhiteChars, count, options);
-
 			if (count < 0)
 				throw new ArgumentOutOfRangeException ("count", "Count cannot be less than zero.");
 			if ((options != StringSplitOptions.None) && (options != StringSplitOptions.RemoveEmptyEntries))
 				throw new ArgumentException ("options must be one of the values in the StringSplitOptions enumeration", "options");
 
 			if (count == 0)
-				return new string [0];
+				return new String[0];
 
-			return InternalSplit (separator, count, (int)options);
+			if (separator == null || separator.Length == 0)
+				separator = null;
+
+			if (options == StringSplitOptions.RemoveEmptyEntries)
+				return SplitRemoveEmpty (count - 1, separator);
+			return SplitKeepEmpty (count - 1, separator);
 		}
 
 		[ComVisible (false)]
 		public String[] Split (string[] separator, int count, StringSplitOptions options)
 		{
-			if (separator == null || separator.Length == 0)
-				return Split (WhiteChars, count, options);
-
 			if (count < 0)
 				throw new ArgumentOutOfRangeException ("count", "Count cannot be less than zero.");
 			if ((options != StringSplitOptions.None) && (options != StringSplitOptions.RemoveEmptyEntries))
@@ -254,6 +254,12 @@
 			if (count == 0 || (this == String.Empty && removeEmpty))
 				return new String [0];
 
+			if (separator == null || separator.Length == 0) {
+				if (removeEmpty)
+					return SplitRemoveEmpty (count - 1, null);
+				return SplitKeepEmpty (count - 1, null);
+			}
+
 			ArrayList arr = new ArrayList ();
 
 			int pos = 0;
@@ -281,7 +287,7 @@
 					pos = matchPos + separator [matchIndex].Length;
 				}
 				else {
-					arr.Add (this.Substring (pos, matchPos - pos));
+					arr.Add (this.SubstringUnchecked (pos, matchPos - pos));
 
 					pos = matchPos + separator [matchIndex].Length;
 
@@ -313,35 +319,212 @@
 		[ComVisible (false)]
 		public String[] Split (char[] separator, StringSplitOptions options)
 		{
-			return Split (separator, Int32.MaxValue, options);
+			if ((options != StringSplitOptions.None) && (options != StringSplitOptions.RemoveEmptyEntries))
+				throw new ArgumentException ("options must be one of the values in the StringSplitOptions enumeration", "options");
+
+			if (separator == null || separator.Length == 0)
+				separator = null;
+
+			if (options == StringSplitOptions.RemoveEmptyEntries)
+				return SplitRemoveEmpty (length, separator);
+			return SplitKeepEmpty (length, separator);
 		}
 
 		[ComVisible (false)]
 		public String[] Split (String[] separator, StringSplitOptions options)
 		{
+			if ((options != StringSplitOptions.None) && (options != StringSplitOptions.RemoveEmptyEntries))
+				throw new ArgumentException ("options must be one of the values in the StringSplitOptions enumeration", "options");
+
+			if (separator == null || separator.Length == 0) {
+				if (options == StringSplitOptions.RemoveEmptyEntries)
+					return SplitRemoveEmpty (length, null);
+				return SplitKeepEmpty (length, null);
+			}
+
 			return Split (separator, Int32.MaxValue, options);
 		}
 #endif
 
-		public unsafe String Substring (int startIndex)
+		private unsafe String[] SplitKeepEmpty (int maxCount, char[] separator)
 		{
+			if (maxCount == 0) return new String[1] { this };
+			int found = 0;
+			int maxLocal = Math.Min (maxCount, 1000);
+			int* dat = stackalloc int[maxLocal];
+			fixed (char* source = this, toTest = separator) {
+				int i = 0;
+				for (int charCount = 0; i < length; i++) {
+					bool isSeparator = false;
+					if (separator == null)
+						isSeparator = Char.IsWhiteSpace (source[i]);
+					else {
+						for (int k = 0; k < separator.Length; k++)
+							if (source[i] == toTest[k]) {
+								isSeparator = true;
+								break;
+							}
+					}
+					if (isSeparator) {
+						dat[found++] = charCount;
+						if (found == maxLocal) {
+							if (found == maxCount)
+								break;
+							return SplitFallback (maxCount, true, separator, found - 1, i);
+						}
+						charCount = 0;
+					}
+					else
+						charCount++;
+				}
+				if (found == 0)
+					return new String[1] { this };
+
+				String[] ret = new String[found + 1];
+				int pos = 0;
+				for (int j = 0; j < found; j++) {
+					ret[j] = SubstringUnchecked (pos, dat[j]);
+					pos += dat[j] + 1;
+				}
+				ret[found] = SubstringUnchecked (pos, length - pos);
+				return ret;
+			}
+		}
+
+		private unsafe String[] SplitRemoveEmpty (int maxCount, char[] separator)
+		{
+			if (length == 0) return new String[0];
+			if (maxCount == 0) return new String[1] { this };
+			int found = 0;
+			maxCount++;
+			int maxLocal = Math.Min (maxCount, 500);
+			int* datS = stackalloc int[maxLocal];
+			int* datL = stackalloc int[maxLocal];
+			fixed (char* source = this, toTest = separator) {
+				int i = 0;
+				int charCount = 0;
+				for (; i < length; i++) {
+					bool isSeparator = false;
+					if (separator == null)
+						isSeparator = Char.IsWhiteSpace (source[i]);
+					else {
+						for (int k = 0; k < separator.Length; k++)
+							if (source[i] == toTest[k]) {
+								isSeparator = true;
+								break;
+							}
+					}
+					if (isSeparator) {
+						if (charCount != 0) {
+							datL[found] = charCount;
+							datS[found++] = i - charCount;
+							if (found == maxLocal) {
+								if (found == maxCount)
+									break;
+								return SplitFallback (maxCount, false, separator, found - 1, i);
+							}
+							charCount = 0;
+						}
+					}
+					else
+						charCount++;
+				}
+				if (found == 0) {
+					if (charCount == 0)
+						return new String[0];
+					else if (charCount == length)
+						return new String[1] { this };
+					return new String[1] { SubstringUnchecked (length - charCount, charCount) };
+				}
+
+				String[] ret = new String[found];
+				found--;
+				for (int j = 0; j < found; j++)
+					ret[j] = SubstringUnchecked (datS[j], datL[j]);
+
+				if (charCount == 0) // We ended without hitting maxCount
+					ret[found] = SubstringUnchecked (datS[found], datL[found]);
+				else { // Add the remaining data
+					ret[found] = SubstringUnchecked (datS[found], length - datS[found]);
+				}
+				return ret;
+			}
+		}
+
+		private unsafe String[] SplitFallback (int maxCount, bool keepEmpty, char[] separator, int found, int startPos)
+		{
+			fixed (char* source = this, toTest = separator) {
+				int charCountPrimary = 0;
+				for (int i = startPos; i < length; i++) {
+					bool isSeparator = false;
+					if (separator == null)
+						isSeparator = Char.IsWhiteSpace (source[i]);
+					else {
+						for (int k = 0; k < separator.Length; k++)
+							if (source[i] == toTest[k]) {
+								isSeparator = true;
+								break;
+							}
+					}
+					if (isSeparator) {
+						if (keepEmpty)
+							found++;
+						else
+							if (charCountPrimary > 0)
+								found++;
+						charCountPrimary = 0;
+						if (found == maxCount)
+							break; //FIXME: Case where only empty follows and removeempty
+					}
+					else
+						charCountPrimary++;
+				}
+
+				String[] ret = new String[found + 1];
+				int charCount = 0;
+				int resultPos = 0;
+
+				int charPos = 0;
+				for (; resultPos < found; charPos++) {
+					bool isSeparator = false;
+					if (separator == null)
+						isSeparator = Char.IsWhiteSpace (source[charPos]);
+					else {
+						for (int k = 0; k < separator.Length; k++)
+							if (source[charPos] == toTest[k]) {
+								isSeparator = true;
+								break;
+							}
+					}
+					if (isSeparator) {
+						if (charCount > 0) {
+							ret[resultPos++] = SubstringUnchecked (charPos - charCount, charCount);
+							charCount = 0;
+						}
+						else
+							if (keepEmpty)
+								ret[resultPos++] = String.Empty;
+					}
+					else
+						charCount++;
+				}
+				ret[resultPos] = SubstringUnchecked (charPos, length - charPos);
+				return ret;
+			}
+		}
+
+		public String Substring (int startIndex)
+		{
 			if (startIndex == 0)
 				return this;
 
 			if (startIndex < 0 || startIndex > this.length)
 				throw new ArgumentOutOfRangeException ("startIndex");
 
-			int newlen = this.length - startIndex;
-			string tmp = InternalAllocateStr (newlen);
-			if (newlen != 0) {
-				fixed (char *dest = tmp, src = this) {
-					memcpy ((byte*)dest, (byte*)(src + startIndex), newlen * 2);
-				}
-			}
-			return tmp;
+			return SubstringUnchecked (startIndex, this.length - startIndex);
 		}
 
-		public unsafe String Substring (int startIndex, int length)
+		public String Substring (int startIndex, int length)
 		{
 			if (length < 0)
 				throw new ArgumentOutOfRangeException ("length", "< 0");
@@ -351,54 +534,136 @@
 			if (startIndex > this.length - length)
 				throw new ArgumentOutOfRangeException ("startIndex + length > this.length");
 
+			return SubstringUnchecked (startIndex, length);
+		}
+
+		internal unsafe String SubstringUnchecked (int startIndex, int length)
+		{
 			if (length == 0)
 				return String.Empty;
 
 			string tmp = InternalAllocateStr (length);
-			fixed (char *dest = tmp, src = this) {
-				memcpy ((byte*)dest, (byte*)(src + startIndex), length * 2);
+			fixed (char* dest = tmp, src = this) {
+				CharCopy (dest, src + startIndex, length);
 			}
-
 			return tmp;
-		}	
+		}
 
-		private static readonly char[] WhiteChars = { (char) 0x9, (char) 0xA, (char) 0xB, (char) 0xC, (char) 0xD,
-#if NET_2_0
-			(char) 0x85, (char) 0x1680, (char) 0x2028, (char) 0x2029,
-#endif
-			(char) 0x20, (char) 0xA0, (char) 0x2000, (char) 0x2001, (char) 0x2002, (char) 0x2003, (char) 0x2004,
-			(char) 0x2005, (char) 0x2006, (char) 0x2007, (char) 0x2008, (char) 0x2009, (char) 0x200A, (char) 0x200B,
-			(char) 0x3000, (char) 0xFEFF };
-
 		public String Trim ()
 		{
-			return InternalTrim (WhiteChars, 0);
+			if (length == 0) 
+				return String.Empty;
+			int start = FindNotWhiteSpace (0, length, 1);
+
+			if (start == length)
+				return String.Empty;
+
+			int end = FindNotWhiteSpace (length - 1, start, -1);
+
+			int newLength = end - start + 1;
+			if (newLength == length)
+				return this;
+
+			return SubstringUnchecked (start, newLength);
 		}
 
 		public String Trim (params char[] trimChars)
 		{
 			if (trimChars == null || trimChars.Length == 0)
-				trimChars = WhiteChars;
+				return Trim ();
 
-			return InternalTrim (trimChars, 0);
+			if (length == 0) 
+				return String.Empty;
+			int start = FindNotInTable (0, length, 1, trimChars);
+
+			if (start == length)
+				return String.Empty;
+
+			int end = FindNotInTable (length - 1, start, -1, trimChars);
+
+			int newLength = end - start + 1;
+			if (newLength == length)
+				return this;
+
+			return SubstringUnchecked (start, newLength);
 		}
 
 		public String TrimStart (params char[] trimChars)
 		{
+			if (length == 0) 
+				return String.Empty;
+			int start;
 			if (trimChars == null || trimChars.Length == 0)
-				trimChars = WhiteChars;
+				start = FindNotWhiteSpace (0, length, 1);
+			else
+				start = FindNotInTable (0, length, 1, trimChars);
 
-			return InternalTrim (trimChars, 1);
+			if (start == 0)
+				return this;
+
+			return SubstringUnchecked (start, length - start);
 		}
 
 		public String TrimEnd (params char[] trimChars)
 		{
+			if (length == 0) 
+				return String.Empty;
+			int end;
 			if (trimChars == null || trimChars.Length == 0)
-				trimChars = WhiteChars;
+				end = FindNotWhiteSpace (length - 1, -1, -1);
+			else
+				end = FindNotInTable (length - 1, -1, -1, trimChars);
 
-			return InternalTrim (trimChars, 2);
+			end++;
+			if (end == length)
+				return this;
+
+			return SubstringUnchecked (0, end);
 		}
 
+		private int FindNotWhiteSpace (int pos, int target, int change)
+		{
+			while (pos != target) {
+				char c = this[pos];
+				if (c < 0x85) {
+					if (c != 0x20) {
+						if (c < 0x9 || c > 0xD)
+							return pos;					
+					}
+				}
+				else {
+					if (c != 0xA0 && c != 0xFEFF && c != 0x3000) {
+#if NET_2_0
+						if (c != 0x85 && c != 0x1680 && c != 0x2028 && c != 0x2029)
+#endif
+							if (c < 0x2000 || c > 0x200B)
+								return pos;
+					}
+				}
+				pos += change;
+			}
+			return pos;
+		}
+
+		private unsafe int FindNotInTable (int pos, int target, int change, char[] table)
+		{
+			fixed (char* tablePtr = table) {
+				while (pos != target) {
+					char c = this[pos];
+					int x = 0;
+					while (x < table.Length) {
+						if (c == tablePtr[x])
+							break;
+						x++;
+					}
+					if (x == table.Length)
+						return pos;
+					pos += change;
+				}
+			}
+			return pos;
+		}
+
 		public static int Compare (String strA, String strB)
 		{
 			return Compare (strA, strB, false, CultureInfo.CurrentCulture);
@@ -706,6 +971,8 @@
 				return IndexOfImpl(anyOf[0], startIndex, count);
 
 			fixed (char* any = anyOf) {
+				// FIXME: My assumption is this may fail on 64-bit Systems
+				// Switch to char*
 				int highest = *any;
 				int lowest = *any;
 
@@ -749,19 +1016,19 @@
 
 
 #if NET_2_0
-		public int IndexOf (string value, StringComparison comparison)
+		public int IndexOf (string value, StringComparison comparisonType)
 		{
-			return IndexOf (value, 0, this.Length, comparison);
+			return IndexOf (value, 0, this.Length, comparisonType);
 		}
 
-		public int IndexOf (string value, int startIndex, StringComparison comparison)
+		public int IndexOf (string value, int startIndex, StringComparison comparisonType)
 		{
-			return IndexOf (value, startIndex, this.Length - startIndex, comparison);
+			return IndexOf (value, startIndex, this.Length - startIndex, comparisonType);
 		}
 
-		public int IndexOf (string value, int startIndex, int count, StringComparison comparison)
+		public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType)
 		{
-			switch (comparison) {
+			switch (comparisonType) {
 			case StringComparison.CurrentCulture:
 				return CultureInfo.CurrentCulture.CompareInfo.IndexOf (this, value, startIndex, count, CompareOptions.None);
 			case StringComparison.CurrentCultureIgnoreCase:
@@ -774,23 +1041,25 @@
 				return CultureInfo.InvariantCulture.CompareInfo.IndexOf (this, value, startIndex, count, CompareOptions.Ordinal);
 			case StringComparison.OrdinalIgnoreCase:
 				return CultureInfo.InvariantCulture.CompareInfo.IndexOf (this, value, startIndex, count, CompareOptions.OrdinalIgnoreCase);
+			default:
+				string msg = Locale.GetText ("Invalid value '{0}' for StringComparison", comparisonType);
+				throw new ArgumentException ("comparisonType", msg);
 			}
-			throw new SystemException ("INTERNAL ERROR: should not reach here ...");
 		}
 
-		public int LastIndexOf (string value, StringComparison comparison)
+		public int LastIndexOf (string value, StringComparison comparisonType)
 		{
-			return LastIndexOf (value, value.Length - 1, value.Length, comparison);
+			return LastIndexOf (value, value.Length - 1, value.Length, comparisonType);
 		}
 
-		public int LastIndexOf (string value, int startIndex, StringComparison comparison)
+		public int LastIndexOf (string value, int startIndex, StringComparison comparisonType)
 		{
-			return LastIndexOf (value, startIndex, startIndex + 1, comparison);
+			return LastIndexOf (value, startIndex, startIndex + 1, comparisonType);
 		}
 
-		public int LastIndexOf (string value, int startIndex, int count, StringComparison comparison)
+		public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType)
 		{
-			switch (comparison) {
+			switch (comparisonType) {
 			case StringComparison.CurrentCulture:
 				return CultureInfo.CurrentCulture.CompareInfo.LastIndexOf (this, value, startIndex, count, CompareOptions.None);
 			case StringComparison.CurrentCultureIgnoreCase:
@@ -803,8 +1072,10 @@
 				return CultureInfo.InvariantCulture.CompareInfo.LastIndexOf (this, value, startIndex, count, CompareOptions.Ordinal);
 			case StringComparison.OrdinalIgnoreCase:
 				return CultureInfo.InvariantCulture.CompareInfo.LastIndexOf (this, value, startIndex, count, CompareOptions.OrdinalIgnoreCase);
+			default:
+				string msg = Locale.GetText ("Invalid value '{0}' for StringComparison", comparisonType);
+				throw new ArgumentException ("comparisonType", msg);
 			}
-			throw new SystemException ("INTERNAL ERROR: should not reach here ...");
 		}
 #endif
 
@@ -816,19 +1087,17 @@
 			return IndexOfImpl (value, 0, this.length);
 		}
 
-		public int IndexOf (String value)
-		{
-			return IndexOf (value, 0, this.length);
-		}
-
 		public int IndexOf (char value, int startIndex)
 		{
-			return IndexOf (value, startIndex, this.length - startIndex);
-		}
+			if (startIndex < 0)
+				throw new ArgumentOutOfRangeException ("startIndex", "< 0");
+			if (startIndex > this.length)
+				throw new ArgumentOutOfRangeException ("startIndex", "startIndex > this.length");
 
-		public int IndexOf (String value, int startIndex)
-		{
-			return IndexOf (value, startIndex, this.length - startIndex);
+			if ((startIndex == 0 && this.length == 0) || (startIndex == this.length))
+				return -1;
+
+			return IndexOfImpl (value, startIndex, this.length - startIndex);
 		}
 
 		/* This method is culture-insensitive */
@@ -889,6 +1158,22 @@
 			}
 		}
 
+		public int IndexOf (String value)
+		{
+			if (value == null)
+				throw new ArgumentNullException ("value");
+			if (value.length == 0)
+				return 0;
+			if (this.length == 0)
+				return -1;
+			return CultureInfo.CurrentCulture.CompareInfo.IndexOf (this, value, 0, length);
+		}
+
+		public int IndexOf (String value, int startIndex)
+		{
+			return IndexOf (value, startIndex, this.length - startIndex);
+		}
+
 		/* But this one is culture-sensitive */
 		public int IndexOf (String value, int startIndex, int count)
 		{
@@ -919,7 +1204,7 @@
 			if (anyOf == null)
 				throw new ArgumentNullException ("anyOf");
 
-			return InternalLastIndexOfAny (anyOf, this.length - 1, this.length);
+			return LastIndexOfAnyUnchecked (anyOf, this.length - 1, this.length);
 		}
 
 		public int LastIndexOfAny (char [] anyOf, int startIndex)
@@ -933,7 +1218,7 @@
 			if (this.length == 0)
 				return -1;
 
-			return InternalLastIndexOfAny (anyOf, startIndex, startIndex + 1);
+			return LastIndexOfAnyUnchecked (anyOf, startIndex, startIndex + 1);
 		}
 
 		public int LastIndexOfAny (char [] anyOf, int startIndex, int count)
@@ -951,9 +1236,31 @@
 			if (this.length == 0)
 				return -1;
 
-			return InternalLastIndexOfAny (anyOf, startIndex, count);
+			return LastIndexOfAnyUnchecked (anyOf, startIndex, count);
 		}
 
+		/* This method is culture-insensitive */
+		unsafe int LastIndexOfAnyUnchecked (char [] anyOf, int startIndex, int count)
+		{
+			fixed (char* start = this, testStart = anyOf) {
+				char* ptr = start + startIndex;
+				char* ptrEnd = ptr - count;
+				char* test;
+				char* testEnd = testStart + anyOf.Length;
+
+				while (ptr != ptrEnd) {
+					test = testStart;
+					while (test != testEnd) {
+						if (*test == *ptr)
+							return (int)(ptr - start);
+						test++;
+					}
+					ptr--;
+				}
+				return -1;
+			}
+		}
+
 		public int LastIndexOf (char value)
 		{
 			if (this.length == 0)
@@ -962,30 +1269,11 @@
 			return LastIndexOfImpl (value, this.length - 1, this.length);
 		}
 
-		public int LastIndexOf (String value)
-		{
-			if (this.length == 0)
-				/* This overload does additional checking */
-				return LastIndexOf (value, 0, 0);
-			else
-				return LastIndexOf (value, this.length - 1, this.length);
-		}
-
 		public int LastIndexOf (char value, int startIndex)
 		{
 			return LastIndexOf (value, startIndex, startIndex + 1);
 		}
 
-		public int LastIndexOf (String value, int startIndex)
-		{
-			if (value == null)
-				throw new ArgumentNullException ("value");
-			int max = startIndex;
-			if (max < this.Length)
-				max++;
-			return LastIndexOf (value, startIndex, max);
-		}
-
 		/* This method is culture-insensitive */
 		public int LastIndexOf (char value, int startIndex, int count)
 		{
@@ -1045,6 +1333,25 @@
 			}
 		}
 
+		public int LastIndexOf (String value)
+		{
+			if (this.length == 0)
+				/* This overload does additional checking */
+				return LastIndexOf (value, 0, 0);
+			else
+				return LastIndexOf (value, this.length - 1, this.length);
+		}
+
+		public int LastIndexOf (String value, int startIndex)
+		{
+			if (value == null)
+				throw new ArgumentNullException ("value");
+			int max = startIndex;
+			if (max < this.Length)
+				max++;
+			return LastIndexOf (value, startIndex, max);
+		}
+
 		/* But this one is culture-sensitive */
 		public int LastIndexOf (String value, int startIndex, int count)
 		{
@@ -1141,15 +1448,25 @@
 			return PadLeft (totalWidth, ' ');
 		}
 
-		public String PadLeft (int totalWidth, char paddingChar)
+		public unsafe String PadLeft (int totalWidth, char paddingChar)
 		{
 			if (totalWidth < 0)
 				throw new ArgumentOutOfRangeException ("totalWidth", "< 0");
 
 			if (totalWidth < this.length)
-				return String.Copy (this);
+				return this;
 
-			return InternalPad (totalWidth, paddingChar, false);
+			String tmp = InternalAllocateStr (totalWidth);
+
+			fixed (char* dest = tmp, src = this) {
+				char* padPos = dest;
+				char* padTo = dest + (totalWidth - length);
+				while (padPos != padTo)
+					*padPos++ = paddingChar;
+
+				CharCopy (padTo, src, length);
+			}
+			return tmp;
 		}
 
 		public String PadRight (int totalWidth)
@@ -1157,15 +1474,25 @@
 			return PadRight (totalWidth, ' ');
 		}
 
-		public String PadRight (int totalWidth, char paddingChar)
+		public unsafe String PadRight (int totalWidth, char paddingChar)
 		{
 			if (totalWidth < 0)
 				throw new ArgumentOutOfRangeException ("totalWidth", "< 0");
 
 			if (totalWidth < this.length)
-				return String.Copy (this);
+				return this;
 
-			return InternalPad (totalWidth, paddingChar, true);
+			String tmp = InternalAllocateStr (totalWidth);
+
+			fixed (char* dest = tmp, src = this) {
+				CharCopy (dest, src, length);
+
+				char* padPos = dest + length;
+				char* padTo = dest + totalWidth;
+				while (padPos != padTo)
+					*padPos++ = paddingChar;
+			}
+			return tmp;
 		}
 
 		public bool StartsWith (String value)
@@ -1191,7 +1518,8 @@
 			case StringComparison.OrdinalIgnoreCase:
 				return CultureInfo.CurrentCulture.CompareInfo.IsPrefix (this, value, CompareOptions.OrdinalIgnoreCase);
 			default:
-				return false;
+				string msg = Locale.GetText ("Invalid value '{0}' for StringComparison", comparisonType);
+				throw new ArgumentException ("comparisonType", msg);
 			}
 		}
 
@@ -1212,7 +1540,8 @@
 			case StringComparison.OrdinalIgnoreCase:
 				return CultureInfo.CurrentCulture.CompareInfo.IsSuffix (this, value, CompareOptions.OrdinalIgnoreCase);
 			default:
-				return false;
+				string msg = Locale.GetText ("Invalid value '{0}' for StringComparison", comparisonType);
+				throw new ArgumentException ("comparisonType", msg);
 			}
 		}
 
@@ -1249,7 +1578,7 @@
 			string tmp = InternalAllocateStr(length);
 			fixed (char* dest = tmp, src = &start_char) {
 				if (start_pos != 0)
-					memcpy((byte*)dest, (byte*)src, start_pos * 2);
+					CharCopy(dest, src, start_pos);
 
 				char* end_ptr = dest + length;
 				char* dest_ptr = dest + start_pos;
@@ -1300,10 +1629,10 @@
 
 			fixed (char *dest = tmp, src = this) {
 				char *dst = dest;
-				memcpy ((byte*)dst, (byte*)src, startIndex * 2);
+				CharCopy (dst, src, startIndex);
 				int skip = startIndex + count;
 				dst += startIndex;
-				memcpy ((byte*)dst, (byte*)(src + skip), (length - skip) * 2);
+				CharCopy (dst, src + skip, length - skip);
 			}
 			return tmp;
 		}
@@ -1318,9 +1647,9 @@
 			if (culture == null)
 				throw new ArgumentNullException ("culture");
 
-			if (culture.LCID == 0x007F) { // Invariant
+			if (culture.LCID == 0x007F) // Invariant
 				return ToLowerInvariant ();
-			}
+
 			return culture.TextInfo.ToLower (this);
 		}
 
@@ -1355,9 +1684,9 @@
 			if (culture == null)
 				throw new ArgumentNullException ("culture");
 
-			if (culture.LCID == 0x007F) { // Invariant
+			if (culture.LCID == 0x007F) // Invariant
 				return ToUpperInvariant ();
-			}
+
 			return culture.TextInfo.ToUpper (this);
 		}
 
@@ -1510,7 +1839,7 @@
 			String tmp = InternalAllocateStr (length);
 			if (length != 0) {
 				fixed (char *dest = tmp, src = str) {
-					memcpy ((byte*)dest, (byte*)src, length * 2);
+					CharCopy (dest, src, length);
 				}
 			}
 			return tmp;
@@ -1542,12 +1871,12 @@
 			String tmp = InternalAllocateStr (s1.Length + s2.Length);
 			if (s1.Length != 0) {
 				fixed (char *dest = tmp, src = s1) {
-					memcpy ((byte*)dest, (byte*)src, s1.length * 2);
+					CharCopy (dest, src, s1.length);
 				}
 			}
 			if (s2.Length != 0) {
 				fixed (char *dest = tmp, src = s2) {
-					memcpy ((byte*)(dest + s1.Length), (byte*)src, s2.length * 2);
+					CharCopy (dest + s1.Length, src, s2.length);
 				}
 			}
 
@@ -1628,16 +1957,10 @@
 
 			String tmp = InternalAllocateStr (s1.length + s2.length);
 
-			if (s1.Length != 0) {
-				fixed (char *dest = tmp, src = s1) {
-					memcpy ((byte*)dest, (byte*)src, s1.length * 2);
-				}
-			}
-			if (s2.Length != 0) {
-				fixed (char *dest = tmp, src = s2) {
-					memcpy ((byte*)(dest + s1.Length), (byte*)src, s2.length * 2);
-				}
-			}
+			fixed (char *dest = tmp, src = s1)
+				CharCopy (dest, src, s1.length);
+			fixed (char *dest = tmp, src = s2)
+				CharCopy (dest + s1.Length, src, s2.length);
 
 			return tmp;
 		}
@@ -1671,17 +1994,17 @@
 
 			if (s1.Length != 0) {
 				fixed (char *dest = tmp, src = s1) {
-					memcpy ((byte*)dest, (byte*)src, s1.length * 2);
+					CharCopy (dest, src, s1.length);
 				}
 			}
 			if (s2.Length != 0) {
 				fixed (char *dest = tmp, src = s2) {
-					memcpy ((byte*)(dest + s1.Length), (byte*)src, s2.length * 2);
+					CharCopy (dest + s1.Length, src, s2.length);
 				}
 			}
 			if (s3.Length != 0) {
 				fixed (char *dest = tmp, src = s3) {
-					memcpy ((byte*)(dest + s1.Length + s2.Length), (byte*)src, s3.length * 2);
+					CharCopy (dest + s1.Length + s2.Length, src, s3.length);
 				}
 			}
 
@@ -1706,22 +2029,22 @@
 
 			if (s1.Length != 0) {
 				fixed (char *dest = tmp, src = s1) {
-					memcpy ((byte*)dest, (byte*)src, s1.length * 2);
+					CharCopy (dest, src, s1.length);
 				}
 			}
 			if (s2.Length != 0) {
 				fixed (char *dest = tmp, src = s2) {
-					memcpy ((byte*)(dest + s1.Length), (byte*)src, s2.length * 2);
+					CharCopy (dest + s1.Length, src, s2.length);
 				}
 			}
 			if (s3.Length != 0) {
 				fixed (char *dest = tmp, src = s3) {
-					memcpy ((byte*)(dest + s1.Length + s2.Length), (byte*)src, s3.length * 2);
+					CharCopy (dest + s1.Length + s2.Length, src, s3.length);
 				}
 			}
 			if (s4.Length != 0) {
 				fixed (char *dest = tmp, src = s4) {
-					memcpy ((byte*)(dest + s1.Length + s2.Length + s3.Length), (byte*)src, s4.length * 2);
+					CharCopy (dest + s1.Length + s2.Length + s3.Length, src, s4.length);
 				}
 			}
 
@@ -1780,11 +2103,11 @@
 
 			fixed (char *dest = tmp, src = this, val = value) {
 				char *dst = dest;
-				memcpy ((byte*)dst, (byte*)src, startIndex * 2);
+				CharCopy (dst, src, startIndex);
 				dst += startIndex;
-				memcpy ((byte*)dst, (byte*)val, value.length * 2);
+				CharCopy (dst, val, value.length);
 				dst += value.length;
-				memcpy ((byte*)dst, (byte*)(src + startIndex), (length - startIndex) * 2);
+				CharCopy (dst, src + startIndex, length - startIndex);
 			}
 			return tmp;
 		}
@@ -2065,18 +2388,17 @@
 
 		internal unsafe int GetCaseInsensitiveHashCode ()
 		{
-			TextInfo ti = CultureInfo.InvariantCulture.TextInfo;
 			fixed (char * c = this) {
 				char * cc = c;
 				char * end = cc + length - 1;
 				int h = 0;
 				for (;cc < end; cc += 2) {
-					h = (h << 5) - h + ti.ToUpper (*cc);
-					h = (h << 5) - h + ti.ToUpper (cc [1]);
+					h = (h << 5) - h + Char.ToUpperInvariant (*cc);
+					h = (h << 5) - h + Char.ToUpperInvariant (cc [1]);
 				}
 				++end;
 				if (cc < end)
-					h = (h << 5) - h + ti.ToUpper (*cc);
+					h = (h << 5) - h + Char.ToUpperInvariant (*cc);
 				return h;
 			}
 		}
@@ -2175,7 +2497,7 @@
 
 			if (i != 0) {
 				fixed (char *dest = result) {
-					memcpy ((byte*)dest, (byte*)value, i * 2);
+					CharCopy (dest, value, i);
 				}
 			}
 			return result;
@@ -2195,7 +2517,7 @@
 			string result = InternalAllocateStr (length);
 
 			fixed (char *dest = result) {
-				memcpy ((byte*)dest, (byte*)(value + startIndex), length * 2);
+				CharCopy (dest, value + startIndex, length);
 			}
 			return result;
 		}
@@ -2216,7 +2538,7 @@
 			string result = InternalAllocateStr (length);
 
 			fixed (char *dest = result, src = val) {
-				memcpy ((byte*)dest, (byte*)(src + startIndex), length * 2);
+				CharCopy (dest, src + startIndex, length);
 			}
 			return result;
 		}
@@ -2230,7 +2552,7 @@
 			string result = InternalAllocateStr (val.Length);
 
 			fixed (char *dest = result, src = val) {
-				memcpy ((byte*)dest, (byte*)src, val.Length * 2);
+				CharCopy (dest, src, val.Length);
 			}
 			return result;
 		}
@@ -2354,7 +2676,7 @@
 			if (size > 0)
 				((byte*)dest) [0] = ((byte*)src) [0];
 		}
-		static unsafe void memcpy1 (byte *dest, byte *src, int size) {
+		internal static unsafe void memcpy1 (byte *dest, byte *src, int size) {
 			while (size >= 8) {
 				((byte*)dest) [0] = ((byte*)src) [0];
 				((byte*)dest) [1] = ((byte*)src) [1];
@@ -2409,6 +2731,55 @@
 			memcpy4 (dest, src, size);
 		}
 
+		internal static unsafe void CharCopy (char *dest, char *src, int count) {
+			// Same rules as for memcpy, but with the premise that 
+			// chars can only be aligned to even addresses if their
+			// enclosing types are correctly aligned
+			if ((((int)dest | (int)src) & 3) != 0) {
+				if (((int)dest & 2) != 0 && ((int)src & 2) != 0 && count > 0) {
+					((short*)dest) [0] = ((short*)src) [0];
+					dest++;
+					src++;
+					count--;
+				}
+				if ((((int)dest | (int)src) & 2) != 0) {
+					memcpy2 ((byte*)dest, (byte*)src, count * 2);
+					return;
+				}
+			}
+			memcpy4 ((byte*)dest, (byte*)src, count * 2);
+		}
+
+		internal static unsafe void CharCopyReverse (char *dest, char *src, int count)
+		{
+			dest += count;
+			src += count;
+			for (int i = count; i > 0; i--) {
+				dest--;
+				src--;
+				*dest = *src;
+			}	
+		}
+
+		internal static unsafe void CharCopy (String target, int targetIndex, String source, int sourceIndex, int count)
+		{
+			fixed (char* dest = target, src = source)
+				CharCopy (dest + targetIndex, src + sourceIndex, count);
+		}
+
+		internal static unsafe void CharCopy (String target, int targetIndex, Char[] source, int sourceIndex, int count)
+		{
+			fixed (char* dest = target, src = source)
+				CharCopy (dest + targetIndex, src + sourceIndex, count);
+		}
+
+		// Use this method if you cannot block copy from left to right (e.g. because you are coping within the same string)
+		internal static unsafe void CharCopyReverse (String target, int targetIndex, String source, int sourceIndex, int count)
+		{
+			fixed (char* dest = target, src = source)
+				CharCopyReverse (dest + targetIndex, src + sourceIndex, count);
+		}
+
 		[CLSCompliant (false), MethodImplAttribute (MethodImplOptions.InternalCall)]
 		unsafe public extern String (char *value);
 
@@ -2440,36 +2811,9 @@
 		private extern String InternalReplace (String oldValue, string newValue, CompareInfo comp);
 
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		private extern void InternalCopyTo (int sIndex, char[] dest, int destIndex, int count);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		private extern String[] InternalSplit (char[] separator, int count, int options);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		private extern String InternalTrim (char[] chars, int typ);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		private extern int InternalLastIndexOfAny (char [] anyOf, int sIndex, int count);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		private extern String InternalPad (int width, char chr, bool right);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
 		internal extern static String InternalAllocateStr (int length);
 
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		internal extern static void InternalStrcpy (String dest, int destPos, String src);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		internal extern static void InternalStrcpy (String dest, int destPos, char[] chars);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		internal extern static void InternalStrcpy (String dest, int destPos, String src, int sPos, int count);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		internal extern static void InternalStrcpy (String dest, int destPos, char[] chars, int sPos, int count);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
 		private extern static string InternalIntern (string str);
 
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
Index: Test/System/StringTest.cs
===================================================================
--- Test/System/StringTest.cs	(revision 94486)
+++ Test/System/StringTest.cs	(working copy)
@@ -1,4 +1,4 @@
-// StringTest.cs - NUnit Test Cases for the System.String class
+﻿// StringTest.cs - NUnit Test Cases for the System.String class
 //
 // Authors:
 //   Jeffrey Stedfast <fejj@ximian.com>
@@ -532,7 +532,15 @@
 		"Mono".CopyTo (0, dest, 0, Int32.MaxValue);
 	}
 
+#if NET_2_0
 	[Test]
+	[ExpectedException (typeof (ArgumentException))]
+	public void TestEndsWithWrongParameter () {
+		"ABC".EndsWith ("C", (StringComparison)80);
+	}
+#endif
+
+	[Test]
 	public void EndsWith()
 	{
 		string s1 = "original";
@@ -791,6 +799,13 @@
 	}
 
 #if NET_2_0
+	[Test]
+	[ExpectedException (typeof (ArgumentException))]
+	public void IndexOf_StringComparison () 
+	{
+		" ".IndexOf ("", 0, 1, (StringComparison)Int32.MinValue);
+	}
+
 	public void IndexOfStringComparison ()
 	{
 		string text = "testing123456";
@@ -1168,7 +1183,16 @@
 		AssertEquals ("bug #77412", 0, s3.LastIndexOf ("test123"));
 	}
 
+#if NET_2_0
 	[Test]
+	[ExpectedException (typeof (ArgumentException))]
+	public void LastIndexOf_StringComparison () 
+	{
+		" ".LastIndexOf ("", 0, 1, (StringComparison)Int32.MinValue);
+	}
+#endif
+
+	[Test]
 	[ExpectedException (typeof (ArgumentOutOfRangeException))]
 	public void LastIndexOf_Char_StartIndexStringLength () 
 	{
@@ -1532,7 +1556,15 @@
 		AssertEquals ("#02", "123", st [0]);
 	}
 
+#if NET_2_0
 	[Test]
+	[ExpectedException (typeof (ArgumentException))]
+	public void TestStartsWithWrongParameter () {
+		"ABC".StartsWith ("A", (StringComparison)80);
+	}
+#endif
+
+	[Test]
 	public void StartsWith() {
 		string s1 = "original";
 		
@@ -1916,6 +1948,15 @@
 		AssertEquals ("#03-01", 1, res.Length);
 		AssertEquals ("#03-02", "..A..B..", res [0]);
 		
+		// Strange Case A+B A
+		res = "...".Split (new Char[] { '.' }, 1, StringSplitOptions.RemoveEmptyEntries);
+		AssertEquals ("#ABA-01", 1, res.Length);
+		AssertEquals ("#ABA-02", "...", res [0]);
+
+		// Strange Case A+B B
+		res = "...".Split (new Char[] { '.' }, 2, StringSplitOptions.RemoveEmptyEntries);
+		AssertEquals ("#ABB-01", 0, res.Length);
+
 		// Keeping Empties and multipe split chars
 		res = "..A;.B.;".Split (new Char[] { '.', ';' }, StringSplitOptions.None);
 		AssertEquals ("#04-01", 7, res.Length);
