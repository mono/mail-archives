Index: Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncReceiveTest.cs
===================================================================
--- Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncReceiveTest.cs	(revision 122085)
+++ Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncReceiveTest.cs	(working copy)
@@ -126,5 +126,15 @@
 			Assert.AreEqual ("foo", result.AsyncState, "State not passed properly");
 			Assert.IsTrue (success, "Callback not run");
 		}
+		
+		[Test]
+		[ExpectedException (typeof (MessageQueueException))]
+		public void BeginReceiveWithException()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-peek-5");
+			IAsyncResult result = q.BeginReceive (new TimeSpan (0, 0, 2));
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndReceive (result);
+		}		
 	}
 }
Index: Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncPeekTest.cs
===================================================================
--- Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncPeekTest.cs	(revision 122085)
+++ Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/AsyncPeekTest.cs	(working copy)
@@ -62,7 +62,8 @@
 			Message rMsg = q.EndPeek (result);
 			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
 			Assert.IsTrue (eventCalled, "Handle Message not called");
-			q.Purge ();
+			
+			Assert.IsNotNull (q.Receive (), "Message not peeked");
 		}
 		
 		[Test]
@@ -79,7 +80,7 @@
 			Message rMsg = q.EndPeek (result);
 			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
 			
-			q.Purge ();
+			Assert.IsNotNull (q.Receive (), "Message not peeked");
 		}
 		
 		[Test]
@@ -97,7 +98,7 @@
 			Assert.AreEqual (body, rMsg.Body, "Async Send Failed, bodies not equal");
 			Assert.AreEqual ("foo", result.AsyncState, "State not passed properly");
 			
-			q.Purge ();
+			Assert.IsNotNull (q.Receive (), "Message not peeked");
 		}
 		
 		private bool success = false;
@@ -123,7 +124,17 @@
 			Assert.AreEqual ("foo", result.AsyncState, "State not passed properly");
 			Assert.IsTrue (success, "Callback not run");
 			
-			q.Purge ();			
+			Assert.IsNotNull (q.Receive (), "Message not peeked");
 		}
+		
+		[Test]
+		[ExpectedException (typeof (MessageQueueException))]
+		public void BeginPeekWithException()
+		{
+			MessageQueue q = MQUtil.GetQueue (@".\private$\async-peek-5");
+			IAsyncResult result = q.BeginPeek (new TimeSpan (0, 0, 2));
+			result.AsyncWaitHandle.WaitOne ();
+			Message rMsg = q.EndPeek (result);
+		}		
 	}
 }
Index: Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/ChangeLog
===================================================================
--- Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/ChangeLog	(revision 122085)
+++ Mono.Messaging.RabbitMQ/Test/Mono.Messaging.RabbitMQ/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2009-01-03  Michael Barker  <mike@middlesoft.co.uk>
+
+	* AsyncPeekTest.cs:  Added test for handling exceptions aysnchronously.
+	* AsyncReceiveTest.cs:  Added test for handling exceptions aysnchronously.
+
 2008-12-20  Michael Barker  <mike@middlesoft.co.uk>
 
 	* AsyncReceiveTest.cs:  New, tests for Asynchronous Receive methods.
Index: Mono.Messaging/Mono.Messaging/ChangeLog
===================================================================
--- Mono.Messaging/Mono.Messaging/ChangeLog	(revision 122085)
+++ Mono.Messaging/Mono.Messaging/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2009-01-03  Michael Barker  <mike@middlesoft.co.uk>
+
+	* MessageQueueBase.cs:  Added support for handling exception asynchronously.
+
 2008-12-21  Michael Barker  <mike@middlesoft.co.uk>
 
 	* MessageQueueBase.cs:  Added optional base class that provide async
Index: Mono.Messaging/Mono.Messaging/MessageQueueBase.cs
===================================================================
--- Mono.Messaging/Mono.Messaging/MessageQueueBase.cs	(revision 122085)
+++ Mono.Messaging/Mono.Messaging/MessageQueueBase.cs	(working copy)
@@ -162,6 +162,7 @@
 			protected IMessage message;
 			protected readonly TimeSpan timeout;
 			protected readonly AsyncCallback callback;
+			protected MonoMessagingException ex = null;
 			
 			public AsyncResultBase (object asyncState,
 			                        IMessageQueue q,
@@ -195,7 +196,12 @@
 			}
 			
 			internal IMessage Message {
-				get { return message; }
+				get { 
+					if (ex != null)
+						throw new MonoMessagingException ("Asynchronous Wrapped Exception", ex);
+				
+					return message;
+				}
 			}
 			
 			protected abstract IMessage GetMessage ();
@@ -204,10 +210,14 @@
 			
 			private void run ()
 			{
-				message = GetMessage ();					
-				isCompleted = true;
-				callback (this);
-				SendCompletedEvent (this);
+				try {
+					message = GetMessage ();					
+					isCompleted = true;
+					callback (this);
+					SendCompletedEvent (this);
+				} catch (MonoMessagingException ex) {
+					this.ex = ex;
+				}
 			}
 		}
 		