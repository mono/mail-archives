Index: loader.c
===================================================================
--- loader.c	(revision 39776)
+++ loader.c	(working copy)
@@ -186,7 +186,6 @@
 static MonoMethod *
 find_method (MonoClass *klass, MonoClass *ic, const char* name, MonoMethodSignature *sig)
 {
-	int i;
 	char *qname, *fqname;
 
 	if (ic) {
@@ -199,9 +198,10 @@
 		qname = fqname = NULL;
 
 	while (klass) {
-		for (i = 0; i < klass->method.count; ++i) {
-			MonoMethod *m = klass->methods [i];
-
+		gpointer iter = NULL;
+		MonoMethod* m;
+		
+		while ((m = mono_class_get_methods (klass, &iter))) {
 			if (!((fqname && !strcmp (m->name, fqname)) ||
 			      (qname && !strcmp (m->name, qname)) || !strcmp (m->name, name)))
 				continue;
@@ -999,7 +999,11 @@
 	MonoClass *klass = method->klass;
 	MonoTableInfo *methodt;
 	MonoTableInfo *paramt;
-
+	guint32 idx;
+	guint32 cols [MONO_PARAM_SIZE];
+	guint param_index;
+	
+	
 	if (!mono_method_signature (method)->param_count)
 		return;
 	for (i = 0; i < mono_method_signature (method)->param_count; ++i)
@@ -1024,33 +1028,30 @@
 
 	methodt = &klass->image->tables [MONO_TABLE_METHOD];
 	paramt = &klass->image->tables [MONO_TABLE_PARAM];
-	for (i = 0; i < klass->method.count; ++i) {
-		if (method == klass->methods [i]) {
-			guint32 idx = klass->method.first + i;
-			guint32 cols [MONO_PARAM_SIZE];
-			guint param_index = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);
 
-			if (idx + 1 < methodt->rows)
-				lastp = mono_metadata_decode_row_col (methodt, idx + 1, MONO_METHOD_PARAMLIST);
-			else
-				lastp = paramt->rows + 1;
-			for (i = param_index; i < lastp; ++i) {
-				mono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);
-				if (cols [MONO_PARAM_SEQUENCE]) /* skip return param spec */
-					names [cols [MONO_PARAM_SEQUENCE] - 1] = mono_metadata_string_heap (klass->image, cols [MONO_PARAM_NAME]);
-			}
-			return;
-		}
+	
+	idx = mono_metadata_token_index (method->token) - 1;
+	param_index = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);
+
+	if (idx + 1 < methodt->rows)
+		lastp = mono_metadata_decode_row_col (methodt, idx + 1, MONO_METHOD_PARAMLIST);
+	else
+		lastp = paramt->rows + 1;
+	for (i = param_index; i < lastp; ++i) {
+		mono_metadata_decode_row (paramt, i -1, cols, MONO_PARAM_SIZE);
+		if (cols [MONO_PARAM_SEQUENCE]) /* skip return param spec */
+			names [cols [MONO_PARAM_SEQUENCE] - 1] = mono_metadata_string_heap (klass->image, cols [MONO_PARAM_NAME]);
 	}
 }
 
 guint32
 mono_method_get_param_token (MonoMethod *method, int index)
 {
-	int i;
 	MonoClass *klass = method->klass;
 	MonoTableInfo *methodt;
-
+	gpointer iter = NULL;
+	MonoMethod* m;
+	
 	if (klass->generic_class)
 		g_assert_not_reached ();
 
@@ -1061,9 +1062,10 @@
 	}
 
 	methodt = &klass->image->tables [MONO_TABLE_METHOD];
-	for (i = 0; i < klass->method.count; ++i) {
-		if (method == klass->methods [i]) {
-			guint32 idx = klass->method.first + i;
+		
+	while ((m = mono_class_get_methods (klass, &iter))) {
+		if (m == method) {
+			guint32 idx = mono_metadata_token_index (method->token) - 1;
 			guint param_index = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);
 
 			return mono_metadata_make_token (MONO_TABLE_PARAM, param_index + index);
@@ -1080,6 +1082,8 @@
 	MonoClass *klass = method->klass;
 	MonoTableInfo *methodt;
 	MonoTableInfo *paramt;
+	gpointer iter = NULL;
+	MonoMethod* m;
 
 	for (i = 0; i < mono_method_signature (method)->param_count + 1; ++i)
 		mspecs [i] = NULL;
@@ -1104,9 +1108,9 @@
 	methodt = &klass->image->tables [MONO_TABLE_METHOD];
 	paramt = &klass->image->tables [MONO_TABLE_PARAM];
 
-	for (i = 0; i < klass->method.count; ++i) {
-		if (method == klass->methods [i]) {
-			guint32 idx = klass->method.first + i;
+	while ((m = mono_class_get_methods (klass, &iter))) {
+		if (method == m) {
+			guint32 idx = mono_metadata_token_index (method->token) - 1;
 			guint32 cols [MONO_PARAM_SIZE];
 			guint param_index = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);
 
@@ -1138,7 +1142,9 @@
 	MonoClass *klass = method->klass;
 	MonoTableInfo *methodt;
 	MonoTableInfo *paramt;
-
+	gpointer iter = NULL;
+	MonoMethod* m;
+	
 	if (method->klass->image->dynamic) {
 		MonoReflectionMethodAux *method_aux = 
 			g_hash_table_lookup (
@@ -1157,9 +1163,9 @@
 	methodt = &klass->image->tables [MONO_TABLE_METHOD];
 	paramt = &klass->image->tables [MONO_TABLE_PARAM];
 
-	for (i = 0; i < klass->method.count; ++i) {
-		if (method == klass->methods [i]) {
-			guint32 idx = klass->method.first + i;
+	while ((m = mono_class_get_methods (klass, &iter))) {
+		if (method == m) {
+			guint32 idx = mono_metadata_token_index (method->token) - 1;
 			guint32 cols [MONO_PARAM_SIZE];
 			guint param_index = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);
 
Index: appdomain.c
===================================================================
--- appdomain.c	(revision 39775)
+++ appdomain.c	(working copy)
@@ -213,12 +213,7 @@
 	MonoObject *o;
 
 	if (field == NULL) {
-		MonoClass *klass = mono_defaults.appdomain_class;
-		int i;
-
-		for (i = 0; i < klass->field.count; ++i)
-			if (strcmp (klass->fields [i].name, "TypeResolve") == 0)
-				field = &klass->fields [i];
+		field = mono_class_get_field_from_name (mono_defaults.appdomain_class, "TypeResolve");
 		g_assert (field);
 	}
 
Index: string-icalls.c
===================================================================
--- string-icalls.c	(revision 39775)
+++ string-icalls.c	(working copy)
@@ -202,7 +202,7 @@
 	arr = mono_array_new (domain, mono_defaults.byte_class, length);
 	memcpy (mono_array_addr (arr, guint8*, 0), value + sindex, length);
 
-	get_string = mono_find_method_by_name (enc->vtable->klass, "GetString", 1);
+	get_string = mono_class_get_method_from_name (mono_object_class (enc), "GetString", 1);
 	args [0] = arr;
 	s = (MonoString*)mono_runtime_invoke (get_string, enc, args, &exc);
 	if (!s || exc)
Index: monodiet.c
===================================================================
--- monodiet.c	(revision 39776)
+++ monodiet.c	(working copy)
@@ -223,6 +223,10 @@
 	guint32 missing;
 	MonoCustomAttrInfo* cattrs;
 	gpointer val = NULL, oldkey = NULL;
+	MonoClassField* field;
+	MonoProperty* property;
+	MonoEvent* event;
+	gpointer iter;
 	
 	if (g_hash_table_lookup_extended (type_table, klass, &oldkey, &val)) {
 		missing = flags & ~(GPOINTER_TO_UINT (val));
@@ -239,26 +243,31 @@
 		add_type (klass->parent);
 	if (klass->nested_in)
 		add_type (klass->nested_in);
-	for (i = 0; i < klass->method.count; ++i) {
-		if ((missing & TYPE_METHODS) || strcmp (klass->methods [i]->name, ".cctor") == 0)
-			add_types_from_method (klass->methods [i]);
-	}
-	if (klass->enumtype) {
+	
+	if (mono_class_get_method_from_name (klass, ".cctor", 0))
+		add_types_from_method (mono_class_get_method_from_name (klass, ".cctor", 0));
+	
+	if (klass->enumtype)
 		add_field (mono_class_get_field_from_name (klass, "value__"));
-	}
+	
 	if (force_enums || (missing & TYPE_FIELDS)) {
-		for (i = 0; i < klass->field.count; ++i) {
-			add_field (&klass->fields [i]);
-		}
+		iter = NULL;
+		while ((field = mono_class_get_fields (klass, &iter)))
+			add_field (field);
 	}
-	for (i = 0; i < klass->property.count; ++i) {
-		cattrs = mono_custom_attrs_from_property (klass, &klass->properties [i]);
+	
+	iter = NULL;
+	while ((property = mono_class_get_properties (klass, &iter))) {
+		cattrs = mono_custom_attrs_from_property (klass, property);
 		handle_cattrs (cattrs);
 	}
-	for (i = 0; i < klass->event.count; ++i) {
-		cattrs = mono_custom_attrs_from_event (klass, &klass->events [i]);
+	
+	iter = NULL;
+	while ((event = mono_class_get_events (klass, &iter))) {
+		cattrs = mono_custom_attrs_from_event (klass, event);
 		handle_cattrs (cattrs);
 	}
+	
 	for (i = 0; i < klass->interface_count; ++i)
 		add_type (klass->interfaces [i]);
 	cattrs = mono_custom_attrs_from_class (klass);
Index: debug-helpers.c
===================================================================
--- debug-helpers.c	(revision 39776)
+++ debug-helpers.c	(working copy)
@@ -285,13 +285,13 @@
 MonoMethod*
 mono_method_desc_search_in_class (MonoMethodDesc *desc, MonoClass *klass)
 {
-	int i;
-
-	mono_class_init (klass);
-	for (i = 0; i < klass->method.count; ++i) {
-		if (mono_method_desc_match (desc, klass->methods [i]))
-			return klass->methods [i];
-	}
+	MonoMethod* m;
+	gpointer iter = NULL;
+	
+	while ((m = mono_class_get_methods (klass, &iter)))
+		if (mono_method_desc_match (desc, m))
+			return m;
+	
 	return NULL;
 }
 
@@ -528,23 +528,3 @@
 
 	return res;
 }
-
-MonoMethod *
-mono_find_method_by_name (MonoClass *klass, const char *name, int param_count)
-{
-	MonoMethod *res = NULL;
-	int i;
-
-	mono_class_init (klass);
-
-	for (i = 0; i < klass->method.count; ++i) {
-		if (klass->methods [i]->name[0] == name [0] && 
-		    !strcmp (name, klass->methods [i]->name) &&
-		    mono_method_signature (klass->methods [i])->param_count == param_count) {
-			res = klass->methods [i];
-			break;
-		}
-	}
-	return res;
-}
-
Index: debug-helpers.h
===================================================================
--- debug-helpers.h	(revision 39775)
+++ debug-helpers.h	(working copy)
@@ -38,7 +38,5 @@
 
 char*           mono_method_full_name (MonoMethod *method, gboolean signature);
 
-MonoMethod *    mono_find_method_by_name (MonoClass *klass, const char *name, int param_count);
-
 #endif /* __MONO_DEBUG_HELPERS_H__ */
 
Index: object.c
===================================================================
--- object.c	(revision 39776)
+++ object.c	(working copy)
@@ -50,18 +50,9 @@
 void
 mono_runtime_object_init (MonoObject *this)
 {
-	int i;
-	MonoMethod *method = NULL;
 	MonoClass *klass = this->vtable->klass;
+	MonoMethod *method = mono_class_get_method_from_name (klass, ".ctor", 0);
 
-	for (i = 0; i < klass->method.count; ++i) {
-		if (!strcmp (".ctor", klass->methods [i]->name) &&
-		    mono_method_signature (klass->methods [i])->param_count == 0) {
-			method = klass->methods [i];
-			break;
-		}
-	}
-
 	g_assert (method);
 
 	if (method->klass->valuetype)
@@ -150,7 +141,6 @@
 void
 mono_runtime_class_init (MonoVTable *vtable)
 {
-	int i;
 	MonoException *exc;
 	MonoException *exc_to_throw;
 	MonoMethod *method = NULL;
@@ -166,16 +156,11 @@
 	exc = NULL;
 	found = FALSE;
 	klass = vtable->klass;
+	
+	method = mono_class_get_method_from_name (klass, ".cctor", 0);
+	if (method && method->flags & METHOD_ATTRIBUTE_SPECIAL_NAME)
+		found = TRUE;
 
-	for (i = 0; i < klass->method.count; ++i) {
-		method = klass->methods [i];
-		if ((method->flags & METHOD_ATTRIBUTE_SPECIAL_NAME) && 
-		    (strcmp (".cctor", method->name) == 0)) {
-			found = TRUE;
-			break;
-		}
-	}
-
 	if (found) {
 		MonoDomain *domain = vtable->domain;
 		TypeInitializationLock *lock;
@@ -435,7 +420,6 @@
 	MonoClassField *field;
 	guint64 bitmap;
 	guint32 bm [2];
-	int i;
 	static gboolean gcj_inited = FALSE;
 
 	if (!gcj_inited) {
@@ -497,8 +481,8 @@
 /*		printf("KLASS: %s.\n", class->name); */
 
 		for (p = class; p != NULL; p = p->parent) {
-		for (i = 0; i < p->field.count; ++i) {
-			field = &p->fields [i];
+		gpointer iter = NULL;
+		while ((field = mono_class_get_fields (p, &iter))) {
 			if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
 				continue;
 			if (field->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)
@@ -611,6 +595,7 @@
 	guint32 vtable_size;
 	guint32 cindex;
 	guint32 constant_cols [MONO_CONSTANT_SIZE];
+	gpointer iter = NULL;
 
 	g_assert (class);
 
@@ -672,8 +657,7 @@
 	}
 
 	cindex = -1;
-	for (i = class->field.first; i < class->field.last; ++i) {
-		field = &class->fields [i - class->field.first];
+	while ((field = mono_class_get_fields (class, &iter))) {
 		if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
 			continue;
 		if (mono_field_is_deleted (field))
@@ -708,7 +692,7 @@
 
 		
 		if (!field->data) {
-			cindex = mono_metadata_get_constant_index (class->image, MONO_TOKEN_FIELD_DEF | (i + 1), cindex + 1);
+			cindex = mono_metadata_get_constant_index (class->image, mono_class_get_field_token (field), cindex + 1);
 			g_assert (cindex);
 			g_assert (!(field->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA));
 
@@ -792,13 +776,13 @@
 	/* Calculate vtable space for extra interfaces */
 	for (j = 0; j < remote_class->interface_count; j++) {
 		MonoClass* iclass = remote_class->interfaces[j];
-		int method_count = iclass->method.count;
+		int method_count = mono_class_num_methods (iclass);
 	
 		if (iclass->interface_id <= class->max_interface_id && class->interface_offsets[iclass->interface_id] != 0) 
 			continue;	/* interface implemented by the class */
 
 		for (i = 0; i < iclass->interface_count; i++)
-			method_count += iclass->interfaces[i]->method.count;
+			method_count += mono_class_num_methods (iclass->interfaces[i]);
 
 		extra_interface_vtsize += method_count * sizeof (gpointer);
 		if (iclass->max_interface_id > max_interface_id) max_interface_id = iclass->max_interface_id;
@@ -825,11 +809,12 @@
 	{
 		/* create trampolines for abstract methods */
 		for (k = class; k; k = k->parent) {
-			for (i = 0; i < k->method.count; i++) {
-				int slot = k->methods [i]->slot;
-				if (!pvt->vtable [slot]) 
-					pvt->vtable [slot] = arch_create_remoting_trampoline (k->methods[i], target_type);
-			}
+			MonoMethod* m;
+			gpointer iter = NULL;
+			
+			while ((m = mono_class_get_methods (k, &iter)))
+				if (!pvt->vtable [m->slot])
+					pvt->vtable [m->slot] = arch_create_remoting_trampoline (m, target_type);
 		}
 	}
 
@@ -861,13 +846,15 @@
 			i = -1;
 			interf = iclass;
 			do {
+				MonoMethod* cm;
+				gpointer iter = NULL;
+				
 				pvt->interface_offsets [interf->interface_id] = &pvt->vtable [slot];
 	
-				for (j = 0; j < interf->method.count; ++j) {
-					MonoMethod *cm = interf->methods [j];
+				while ((cm = mono_class_get_methods (interf, &iter)))
 					pvt->vtable [slot + j] = arch_create_remoting_trampoline (cm, target_type);
-				}
-				slot += interf->method.count;
+				
+				slot += mono_class_num_methods (interf);
 				if (++i < iclass->interface_count) interf = iclass->interfaces[i];
 				else interf = NULL;
 				
@@ -1468,19 +1455,8 @@
 mono_get_delegate_invoke (MonoClass *klass)
 {
 	MonoMethod *im;
-	int i;
-
-	im = NULL;
-
-	for (i = 0; i < klass->method.count; ++i) {
-		if (klass->methods [i]->name[0] == 'I' && 
-		    !strcmp ("Invoke", klass->methods [i]->name)) {
-			im = klass->methods [i];
-		}
-	}
-
+	im = mono_class_get_method_from_name (klass, "Invoke", -1);
 	g_assert (im);
-
 	return im;
 }
 
@@ -1663,7 +1639,7 @@
 	MonoMethod *method = NULL;
 	MonoBoolean is_terminating = TRUE;
 	MonoObject *obj;
-	gint i;
+	gpointer iter = NULL;
 
 	klass = mono_class_from_name (mono_defaults.corlib, "System", "UnhandledExceptionEventArgs");
 	g_assert (klass);
@@ -1671,8 +1647,7 @@
 	mono_class_init (klass);
 
 	/* UnhandledExceptionEventArgs only has 1 public ctor with 2 args */
-	for (i = 0; i < klass->method.count; ++i) {
-		method = klass->methods [i];
+	while ((method = mono_class_get_methods (klass, &iter))) {
 		if (!strcmp (".ctor", method->name) &&
 		    mono_method_signature (method)->param_count == 2 &&
 		    method->flags & METHOD_ATTRIBUTE_PUBLIC)
@@ -2021,18 +1996,7 @@
 
 		if (im == NULL) {
 			MonoClass *klass = mono_class_from_name (mono_defaults.corlib, "System.Runtime.Remoting.Activation", "ActivationServices");
-			int i;
-
-			if (!klass->inited)
-				mono_class_init (klass);
-
-			for (i = 0; i < klass->method.count; ++i) {
-				if (!strcmp ("CreateProxyForType", klass->methods [i]->name) &&
-					mono_method_signature (klass->methods [i])->param_count == 1) {
-					im = klass->methods [i];
-					break;
-				}
-			}
+			im = mono_class_get_method_from_name (klass, "CreateProxyForType", 1);
 			g_assert (im);
 			vtable->domain->create_proxy_for_type_method = im;
 		}
@@ -2696,15 +2660,8 @@
 		MonoClass *rpklass = mono_defaults.iremotingtypeinfo_class;
 		MonoMethod *im = NULL;
 		gpointer pa [2];
-		int i;
-	
-		for (i = 0; i < rpklass->method.count; ++i) {
-			if (!strcmp ("CanCastTo", rpklass->methods [i]->name)) {
-				im = rpklass->methods [i];
-				break;
-			}
-		}
-	
+		
+		im = mono_class_get_method_from_name (rpklass, "CanCastTo", -1);
 		im = mono_object_get_virtual_method (rp, im);
 		g_assert (im);
 	
@@ -3129,18 +3086,10 @@
 
 	if (!im) {
 		MonoClass *klass;
-		int i;
 
 		klass = mono_defaults.real_proxy_class; 
-		       
-		for (i = 0; i < klass->method.count; ++i) {
-			if (!strcmp ("PrivateInvoke", klass->methods [i]->name) &&
-			    mono_method_signature (klass->methods [i])->param_count == 4) {
-				im = klass->methods [i];
-				break;
-			}
-		}
-	
+		
+		im = mono_class_get_method_from_name (klass, "PrivateInvoke", 4);
 		g_assert (im);
 		real_proxy->vtable->domain->private_invoke_method = im;
 	}
@@ -3213,14 +3162,13 @@
 	MonoMethod *method;
 	MonoClass *klass;
 	gboolean free_message = FALSE;
-	gint i;
-
+	
 	if (mono_object_isinst (exc, mono_defaults.exception_class)) {
 		klass = exc->vtable->klass;
 		method = NULL;
 		while (klass && method == NULL) {
-			for (i = 0; i < klass->method.count; ++i) {
-				method = klass->methods [i];
+			gpointer iter = NULL;
+			while ((method = mono_class_get_methods (klass, &iter))) {
 				if (!strcmp ("ToString", method->name) &&
 				    mono_method_signature (method)->param_count == 0 &&
 				    method->flags & METHOD_ATTRIBUTE_VIRTUAL &&
@@ -3446,16 +3394,7 @@
 	}
 	
 	if (!getter) {
-		int i;
-
-		for (i = 0; i < mono_defaults.object_class->method.count; ++i) {
-			MonoMethod *cm = mono_defaults.object_class->methods [i];
-	       
-			if (!strcmp (cm->name, "FieldGetter")) {
-				getter = cm;
-				break;
-			}
-		}
+		getter = mono_class_get_method_from_name (mono_get_object_class (), "FieldGetter", -1);
 		g_assert (getter);
 	}
 	
@@ -3516,16 +3455,7 @@
 	}
 
 	if (!getter) {
-		int i;
-
-		for (i = 0; i < mono_defaults.object_class->method.count; ++i) {
-			MonoMethod *cm = mono_defaults.object_class->methods [i];
-	       
-			if (!strcmp (cm->name, "FieldGetter")) {
-				getter = cm;
-				break;
-			}
-		}
+		getter = mono_class_get_method_from_name (mono_get_object_class (), "FieldGetter", -1);
 		g_assert (getter);
 	}
 	
@@ -3579,16 +3509,7 @@
 	}
 
 	if (!setter) {
-		int i;
-
-		for (i = 0; i < mono_defaults.object_class->method.count; ++i) {
-			MonoMethod *cm = mono_defaults.object_class->methods [i];
-	       
-			if (!strcmp (cm->name, "FieldSetter")) {
-				setter = cm;
-				break;
-			}
-		}
+		setter = mono_class_get_method_from_name (mono_get_object_class (), "FieldSetter", -1);
 		g_assert (setter);
 	}
 
@@ -3641,16 +3562,7 @@
 	}
 
 	if (!setter) {
-		int i;
-
-		for (i = 0; i < mono_defaults.object_class->method.count; ++i) {
-			MonoMethod *cm = mono_defaults.object_class->methods [i];
-	       
-			if (!strcmp (cm->name, "FieldSetter")) {
-				setter = cm;
-				break;
-			}
-		}
+		setter = mono_class_get_method_from_name (mono_get_object_class (), "FieldSetter", -1);
 		g_assert (setter);
 	}
 
Index: mono-debug-debugger.c
===================================================================
--- mono-debug-debugger.c	(revision 39776)
+++ mono-debug-debugger.c	(working copy)
@@ -820,6 +820,11 @@
 	int ctor_info_size = 0, cctor_info_size = 0, iface_info_size = 0;
 	guint32 size, data_size, offset, data_offset;
 	GHashTable *method_slots = NULL;
+	MonoMethod *method;
+	MonoClassField* field;
+	MonoProperty* property;
+	MonoEvent* event;
+	gpointer iter = NULL;
 	int i;
 
 	if (klass->init_pending)
@@ -844,20 +849,23 @@
 		return offset;
 	}
 
-	for (i = 0; i < klass->field.count; i++)
-		if (!(klass->fields [i].type->attrs & FIELD_ATTRIBUTE_STATIC))
+	iter = NULL;
+	while ((field = mono_class_get_fields (klass, &iter)))
+		if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
 			++num_fields;
 		else
 			++num_static_fields;
 
-	for (i = 0; i < klass->property.count; i++)
-		if (!property_is_static (&klass->properties [i]))
+	iter = NULL;
+	while ((property = mono_class_get_properties (klass, &iter)))
+		if (!property_is_static (property))
 			++num_properties;
 		else
 			++num_static_properties;
 
-	for (i = 0; i < klass->event.count; i++)
-		if (!event_is_static (&klass->events [i]))
+	iter = NULL;
+	while ((event = mono_class_get_events (klass, &iter)))
+		if (!event_is_static (event))
 			++num_events;
 		else
 			++num_static_events;
@@ -868,9 +876,8 @@
 	ctors = g_ptr_array_new ();
 	cctors = g_ptr_array_new ();
 
-	for (i = 0; i < klass->method.count; i++) {
-		MonoMethod *method = klass->methods [i];
-
+	iter = NULL;
+	while ((method = mono_class_get_methods (klass, &iter))) {
 		if (!strcmp (method->name, ".cctor")) {
 			++num_cctors;
 			g_ptr_array_add (cctors, method);
@@ -982,39 +989,41 @@
 	else
 		WRITE_UINT32 (ptr, 0);
 
-	for (i = 0; i < klass->field.count; i++) {
-		if (klass->fields [i].type->attrs & FIELD_ATTRIBUTE_STATIC)
+	iter = NULL;
+	while ((field = mono_class_get_fields (klass, &iter))) {
+		if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
 			continue;
 
-		WRITE_UINT32 (ptr, klass->fields [i].offset + base_offset);
-		WRITE_UINT32 (ptr, write_type (table, klass->fields [i].type));
+		WRITE_UINT32 (ptr, field->offset + base_offset);
+		WRITE_UINT32 (ptr, write_type (table, field->type));
 	}
 
-	for (i = 0; i < klass->property.count; i++) {
-		if (property_is_static (&klass->properties [i]))
+	iter = NULL;
+	while ((property = mono_class_get_properties (klass, &iter))) {
+		if (property_is_static (property))
 			continue;
 
-		if (klass->properties [i].get)
-			WRITE_UINT32 (ptr, write_type (table, mono_method_signature (klass->properties [i].get)->ret));
+		if (property->get)
+			WRITE_UINT32 (ptr, write_type (table, mono_method_signature (property->get)->ret));
 		else
 			WRITE_UINT32 (ptr, 0);
-		WRITE_POINTER (ptr, klass->properties [i].get);
-		WRITE_POINTER (ptr, klass->properties [i].set);
+		WRITE_POINTER (ptr, property->get);
+		WRITE_POINTER (ptr, property->set);
 	}
 
-	for (i = 0; i < klass->event.count; i++) {
-		if (event_is_static (&klass->events[i]))
+	iter = NULL;
+	while ((event = mono_class_get_events (klass, &iter))) {
+		if (event_is_static (event))
 			continue;
 
-		if (klass->events [i].add) {
-			WRITE_UINT32 (ptr, write_type (table, mono_method_signature (klass->events [i].add)->params[0]));
-		}
-		else {
+		if (event->add) {
+			WRITE_UINT32 (ptr, write_type (table, mono_method_signature (event->add)->params[0]));
+		} else {
 			g_warning ("event add method not defined");
 			WRITE_UINT32 (ptr, 0);
 		}
-		WRITE_POINTER (ptr, klass->events [i].add);
-		WRITE_POINTER (ptr, klass->events [i].remove);
+		WRITE_POINTER (ptr, event->add);
+		WRITE_POINTER (ptr, event->remove);
 		/* raise?  other? */
 	}
 
@@ -1034,39 +1043,41 @@
 
 	g_ptr_array_free (methods, FALSE);
 
-	for (i = 0; i < klass->field.count; i++) {
-		if (!(klass->fields [i].type->attrs & FIELD_ATTRIBUTE_STATIC))
+	iter = NULL;
+	while ((field = mono_class_get_fields (klass, &iter))) {
+		if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
 			continue;
 
-		WRITE_UINT32 (ptr, klass->fields [i].offset);
-		WRITE_UINT32 (ptr, write_type (table, klass->fields [i].type));
+		WRITE_UINT32 (ptr, field->offset);
+		WRITE_UINT32 (ptr, write_type (table, field->type));
 	}
 
-	for (i = 0; i < klass->property.count; i++) {
-		if (!property_is_static (&klass->properties [i]))
+	iter = NULL;
+	while ((property = mono_class_get_properties (klass, &iter))) {
+		if (!property_is_static (property))
 			continue;
 
-		if (klass->properties [i].get)
-			WRITE_UINT32 (ptr, write_type (table, mono_method_signature (klass->properties [i].get)->ret));
+		if (property->get)
+			WRITE_UINT32 (ptr, write_type (table, mono_method_signature (property->get)->ret));
 		else
 			WRITE_UINT32 (ptr, 0);
-		WRITE_POINTER (ptr, klass->properties [i].get);
-		WRITE_POINTER (ptr, klass->properties [i].set);
+		WRITE_POINTER (ptr, property->get);
+		WRITE_POINTER (ptr, property->set);
 	}
 
-	for (i = 0; i < klass->event.count; i++) {
-		if (!event_is_static (&klass->events[i]))
+	iter = NULL;
+	while ((event = mono_class_get_events (klass, &iter))) {
+		if (!event_is_static (event))
 			continue;
 
-		if (klass->events [i].add) {
-			WRITE_UINT32 (ptr, write_type (table, mono_method_signature (klass->events [i].add)->params[0]));
-		}
-		else {
+		if (event->add) {
+			WRITE_UINT32 (ptr, write_type (table, mono_method_signature (event->add)->params[0]));
+		} else {
 			g_warning ("event add method not defined");
 			WRITE_UINT32 (ptr, 0);
 		}
-		WRITE_POINTER (ptr, klass->events [i].add);
-		WRITE_POINTER (ptr, klass->events [i].remove);
+		WRITE_POINTER (ptr, event->add);
+		WRITE_POINTER (ptr, event->remove);
 		/* raise?  other? */
 	}
 
@@ -1467,14 +1478,14 @@
 	MonoString *str; 
 	MonoMethod *method;
 	MonoClass *klass;
-	gint i;
 
 	if (mono_object_isinst (exc, mono_defaults.exception_class)) {
 		klass = exc->vtable->klass;
 		method = NULL;
 		while (klass && method == NULL) {
-			for (i = 0; i < klass->method.count; ++i) {
-				method = klass->methods [i];
+			MonoMethod* method;
+			gpointer iter = NULL;
+			while ((method = mono_class_get_methods (klass, &iter))) {
 				if (!strcmp ("ToString", method->name) &&
 				    mono_method_signature (method)->param_count == 0 &&
 				    method->flags & METHOD_ATTRIBUTE_VIRTUAL &&
Index: marshal.c
===================================================================
--- marshal.c	(revision 39776)
+++ marshal.c	(working copy)
@@ -868,14 +868,7 @@
 	MonoMethod *ctor = NULL;
 
 	MonoClass *mme = mono_class_from_name (mono_defaults.corlib, "System", exc_name);
-	int i;
-	mono_class_init (mme);
-	for (i = 0; i < mme->method.count; ++i) {
-		if (strcmp (mme->methods [i]->name, ".ctor") == 0 && mono_method_signature (mme->methods [i])->param_count == 0) {
-			ctor = mme->methods [i];
-			break;
-		}
-	}
+	ctor = mono_class_get_method_from_name (mme, ".ctor", 0);
 	g_assert (ctor);
 	mono_mb_emit_byte (mb, CEE_NEWOBJ);
 	mono_mb_emit_i4 (mb, mono_mb_add_data (mb, ctor));
@@ -1444,7 +1437,6 @@
 	MonoMethod *im;
 	MonoClass *klass;
 	MonoMethod *method = NULL;
-	int i;
 
 	g_assert (delegate);
 
@@ -1477,15 +1469,10 @@
 
 	klass = delegate->object.vtable->klass;
 
-	method = mono_get_delegate_invoke (klass);
-	for (i = 0; i < klass->method.count; ++i) {
-		if (klass->methods [i]->name[0] == 'B' && 
-		    !strcmp ("BeginInvoke", klass->methods [i]->name)) {
-			method = klass->methods [i];
-			break;
-		}
-	}
-
+	method = mono_class_get_method_from_name (klass, "BeginInvoke", -1);
+	if (! method)
+		method = mono_get_delegate_invoke (klass);
+	
 	g_assert (method != NULL);
 
 	im = mono_get_delegate_invoke (method->klass);
@@ -1851,8 +1838,6 @@
 	MonoObject *res, *exc;
 	MonoArray *out_args;
 	MonoClass *klass;
-	int i;
-
 	g_assert (delegate);
 
 	if (!delegate->method_info || !delegate->method_info->method)
@@ -1860,14 +1845,7 @@
 
 	klass = delegate->object.vtable->klass;
 
-	for (i = 0; i < klass->method.count; ++i) {
-		if (klass->methods [i]->name[0] == 'E' && 
-		    !strcmp ("EndInvoke", klass->methods [i]->name)) {
-			method = klass->methods [i];
-			break;
-		}
-	}
-
+	method = mono_class_get_method_from_name (klass, "EndInvoke", -1);
 	g_assert (method != NULL);
 
 	sig = signature_no_pinvoke (mono_method_signature (method));
@@ -7087,11 +7065,15 @@
 	klass = mono_class_from_mono_type (type->type);
 
 	while (klass && match_index == -1) {
-		for (i = 0; i < klass->field.count; ++i) {
-			if (*fname == *klass->fields [i].name && strcmp (fname, klass->fields [i].name) == 0) {
+		gpointer iter = NULL;
+		MonoClassField* field;
+		i = 0;
+		while ((field = mono_class_get_fields (klass, &iter))) {
+			if (!strcmp (fname, field->name)) {
 				match_index = i;
 				break;
 			}
+			i ++;
 		}
 
 		if (match_index == -1)
@@ -7264,8 +7246,10 @@
 MonoMarshalType *
 mono_marshal_load_type_info (MonoClass* klass)
 {
-	int i, j, count = 0, native_size = 0, min_align = 1;
+	int j = 0, count = 0, native_size = 0, min_align = 1;
 	MonoMarshalType *info;
+	MonoClassField* field;
+	gpointer iter;
 	guint32 layout;
 
 	g_assert (klass != NULL);
@@ -7276,10 +7260,11 @@
 	if (!klass->inited)
 		mono_class_init (klass);
 	
-	for (i = 0; i < klass->field.count; ++i) {
-		if (klass->fields [i].type->attrs & FIELD_ATTRIBUTE_STATIC)
+	iter = NULL;
+	while ((field = mono_class_get_fields (klass, &iter))) {
+		if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
 			continue;
-		if (mono_field_is_deleted (&klass->fields [i]))
+		if (mono_field_is_deleted (field))
 			continue;
 		count++;
 	}
@@ -7299,23 +7284,24 @@
 		native_size += parent_size;
 		info->native_size = parent_size;
 	}
- 
-	for (j = i = 0; i < klass->field.count; ++i) {
+	
+	iter = NULL;
+	while ((field = mono_class_get_fields (klass, &iter))) {
 		int size, align;
 		
-		if (klass->fields [i].type->attrs & FIELD_ATTRIBUTE_STATIC)
+		if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
 			continue;
 
-		if (mono_field_is_deleted (&klass->fields [i]))
+		if (mono_field_is_deleted (field))
 			continue;
-		if (klass->fields [i].type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_MARSHAL)
-			mono_metadata_field_info (klass->image, klass->field.first + i, 
+		if (field->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_MARSHAL)
+			mono_metadata_field_info (klass->image, mono_metadata_token_index (mono_class_get_field_token (field)) - 1, 
 						  NULL, NULL, &info->fields [j].mspec);
 
-		info->fields [j].field = &klass->fields [i];
+		info->fields [j].field = field;
 
-		if ((klass->field.count == 1) && (klass->instance_size == sizeof (MonoObject)) &&
-			(strcmp (klass->fields [i].name, "$PRIVATE$") == 0)) {
+		if ((mono_class_num_fields (klass) == 1) && (klass->instance_size == sizeof (MonoObject)) &&
+			(strcmp (field->name, "$PRIVATE$") == 0)) {
 			/* This field is a hack inserted by MCS to empty structures */
 			continue;
 		}
@@ -7323,7 +7309,7 @@
 		switch (layout) {
 		case TYPE_ATTRIBUTE_AUTO_LAYOUT:
 		case TYPE_ATTRIBUTE_SEQUENTIAL_LAYOUT:
-			size = mono_marshal_type_size (klass->fields [i].type, info->fields [j].mspec, 
+			size = mono_marshal_type_size (field->type, info->fields [j].mspec, 
 						       &align, TRUE, klass->unicode);
 			align = klass->packing_size ? MIN (klass->packing_size, align): align;
 			min_align = MAX (align, min_align);
@@ -7333,11 +7319,11 @@
 			info->native_size = info->fields [j].offset + size;
 			break;
 		case TYPE_ATTRIBUTE_EXPLICIT_LAYOUT:
-			size = mono_marshal_type_size (klass->fields [i].type, info->fields [j].mspec, 
+			size = mono_marshal_type_size (field->type, info->fields [j].mspec, 
 						       &align, TRUE, klass->unicode);
 			align = klass->packing_size ? MIN (klass->packing_size, align): align;
 			min_align = MAX (align, min_align);
-			info->fields [j].offset = klass->fields [i].offset - sizeof (MonoObject);
+			info->fields [j].offset = field->offset - sizeof (MonoObject);
 			info->native_size = MAX (info->native_size, info->fields [j].offset + size);
 			break;
 		}	
Index: icall.c
===================================================================
--- icall.c	(revision 39776)
+++ icall.c	(working copy)
@@ -742,18 +742,19 @@
 static gint32
 ves_icall_System_ValueType_InternalGetHashCode (MonoObject *this, MonoArray **fields)
 {
-	int i;
 	MonoClass *klass;
 	MonoObject **values = NULL;
 	MonoObject *o;
 	int count = 0;
 	gint32 result = 0;
+	MonoClassField* field;
+	gpointer iter = NULL;
 
 	MONO_ARCH_SAVE_REGS;
 
-	klass = this->vtable->klass;
+	klass = mono_object_class (this);
 
-	if (klass->field.count == 0)
+	if (mono_class_num_fields (klass) == 0)
 		return ves_icall_System_Object_GetHashCode (this);
 
 	/*
@@ -761,8 +762,7 @@
 	 * types, and return the remaining fields in an array to the managed side.
 	 * This way, we can avoid costly reflection operations in managed code.
 	 */
-	for (i = 0; i < klass->field.count; ++i) {
-		MonoClassField *field = &klass->fields [i];
+	while ((field = mono_class_get_fields (klass, &iter))) {
 		if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
 			continue;
 		if (mono_field_is_deleted (field))
@@ -781,7 +781,7 @@
 		}
 		default:
 			if (!values)
-				values = alloca (klass->field.count * sizeof (MonoObject*));
+				values = g_newa (MonoObject*, mono_class_num_fields (klass));
 			o = mono_field_get_value_object (mono_object_domain (this), field, this);
 			values [count++] = o;
 		}
@@ -799,10 +799,11 @@
 static MonoBoolean
 ves_icall_System_ValueType_Equals (MonoObject *this, MonoObject *that, MonoArray **fields)
 {
-	int i;
 	MonoClass *klass;
 	MonoObject **values = NULL;
 	MonoObject *o;
+	MonoClassField* field;
+	gpointer iter = NULL;
 	int count = 0;
 
 	MONO_ARCH_SAVE_REGS;
@@ -812,7 +813,7 @@
 	if (this->vtable != that->vtable)
 		return FALSE;
 
-	klass = this->vtable->klass;
+	klass = mono_object_class (this);
 
 	/*
 	 * Do the comparison for fields of primitive type and return a result if
@@ -821,8 +822,7 @@
 	 * managed code.
 	 */
 	*fields = NULL;
-	for (i = 0; i < klass->field.count; ++i) {
-		MonoClassField *field = &klass->fields [i];
+	while ((field = mono_class_get_fields (klass, &iter))) {
 		if (field->type->attrs & FIELD_ATTRIBUTE_STATIC)
 			continue;
 		if (mono_field_is_deleted (field))
@@ -853,7 +853,7 @@
 		}
 		default:
 			if (!values)
-				values = alloca (klass->field.count * 2 * sizeof (MonoObject*));
+				values = g_newa (MonoObject*, mono_class_num_fields (klass) * 2);
 			o = mono_field_get_value_object (mono_object_domain (this), field, this);
 			values [count++] = o;
 			o = mono_field_get_value_object (mono_object_domain (this), field, that);
@@ -1563,7 +1563,9 @@
 	MonoClass *class = mono_class_from_mono_type (type->type);
 	MonoClass *iclass = mono_class_from_mono_type (iface->type);
 	MonoReflectionMethod *member;
-	int i, len, ioffset;
+	MonoMethod* method;
+	gpointer iter = NULL;
+	int i = 0, len, ioffset;
 	MonoDomain *domain;
 
 	MONO_ARCH_SAVE_REGS;
@@ -1572,16 +1574,18 @@
 	if ((iclass->interface_id > class->max_interface_id) || !class->interface_offsets [iclass->interface_id])
 			return;
 
-	len = iclass->method.count;
+	len = mono_class_num_methods (iclass);
 	ioffset = class->interface_offsets [iclass->interface_id];
 	domain = mono_object_domain (type);
 	*targets = mono_array_new (domain, mono_defaults.method_info_class, len);
 	*methods = mono_array_new (domain, mono_defaults.method_info_class, len);
-	for (i = 0; i < len; ++i) {
-		member = mono_method_get_object (domain, iclass->methods [i], iclass);
+	while ((method = mono_class_get_methods (iclass, &iter))) {
+		member = mono_method_get_object (domain, method, iclass);
 		mono_array_set (*methods, gpointer, i, member);
 		member = mono_method_get_object (domain, class->vtable [i + ioffset], class);
 		mono_array_set (*targets, gpointer, i, member);
+		
+		i ++;
 	}
 }
 
@@ -2398,26 +2402,23 @@
 			str = mono_string_to_utf8 (name);
 		
 			do {
-				for (i = 0; i < k->field.count; i++) {
-					if (!strcmp (k->fields [i].name, str)) {
-						MonoClass *field_klass =  mono_class_from_mono_type (k->fields [i].type);
-						if (field_klass->valuetype)
-							result = mono_value_box (domain, field_klass,
-										 (char *)this + k->fields [i].offset);
-						else 
-							result = *((gpointer *)((char *)this + k->fields [i].offset));
-					
-						g_assert (result);
-						out_args = mono_array_new (domain, mono_defaults.object_class, 1);
-						*outArgs = out_args;
-						mono_array_set (out_args, gpointer, 0, result);
-						g_free (str);
-						return NULL;
-					}
+				MonoClassField* field = mono_class_get_field_from_name (k, str);
+				if (field) {
+					MonoClass *field_klass =  mono_class_from_mono_type (field->type);
+					if (field_klass->valuetype)
+						result = mono_value_box (domain, field_klass, (char *)this + field->offset);
+					else 
+						result = *((gpointer *)((char *)this + field->offset));
+				
+					g_assert (result);
+					out_args = mono_array_new (domain, mono_defaults.object_class, 1);
+					*outArgs = out_args;
+					mono_array_set (out_args, gpointer, 0, result);
+					g_free (str);
+					return NULL;
 				}
 				k = k->parent;
-			} 
-			while (k != NULL);
+			} while (k);
 
 			g_free (str);
 			g_assert_not_reached ();
@@ -2440,28 +2441,27 @@
 			str = mono_string_to_utf8 (name);
 		
 			do {
-				for (i = 0; i < k->field.count; i++) {
-					if (!strcmp (k->fields [i].name, str)) {
-						MonoClass *field_klass =  mono_class_from_mono_type (k->fields [i].type);
-						MonoObject *val = mono_array_get (params, gpointer, 2);
-	
-						if (field_klass->valuetype) {
-							size = mono_type_size (k->fields [i].type, &align);
-							memcpy ((char *)this + k->fields [i].offset, 
-								((char *)val) + sizeof (MonoObject), size);
-						} else 
-							*(MonoObject**)((char *)this + k->fields [i].offset) = val;
-					
-						out_args = mono_array_new (domain, mono_defaults.object_class, 0);
-						*outArgs = out_args;
-	
-						g_free (str);
-						return NULL;
-					}
+				MonoClassField* field = mono_class_get_field_from_name (k, str);
+				if (field) {
+					MonoClass *field_klass =  mono_class_from_mono_type (field->type);
+					MonoObject *val = mono_array_get (params, gpointer, 2);
+
+					if (field_klass->valuetype) {
+						size = mono_type_size (field->type, &align);
+						memcpy ((char *)this + field->offset, 
+							((char *)val) + sizeof (MonoObject), size);
+					} else 
+						*(MonoObject**)((char *)this + field->offset) = val;
+				
+					out_args = mono_array_new (domain, mono_defaults.object_class, 0);
+					*outArgs = out_args;
+
+					g_free (str);
+					return NULL;
 				}
+				
 				k = k->parent;
-			} 
-			while (k != NULL);
+			} while (k);
 
 			g_free (str);
 			g_assert_not_reached ();
@@ -2566,22 +2566,22 @@
 {
 	MonoDomain *domain = mono_object_domain (type); 
 	MonoClass *enumc = mono_class_from_mono_type (type->type);
-	guint i, j, nvalues, crow;
+	guint j = 0, nvalues, crow;
+	gpointer iter = NULL;
 	MonoClassField *field;
 
 	MONO_ARCH_SAVE_REGS;
 
 	info->utype = mono_type_get_object (domain, enumc->enum_basetype);
-	nvalues = enumc->field.count ? enumc->field.count - 1 : 0;
+	nvalues = mono_class_num_fields (enumc) ? mono_class_num_fields (enumc) - 1 : 0;
 	info->names = mono_array_new (domain, mono_defaults.string_class, nvalues);
 	info->values = mono_array_new (domain, enumc, nvalues);
 	
 	crow = -1;
-	for (i = 0, j = 0; i < enumc->field.count; ++i) {
+	while ((field = mono_class_get_fields (enumc, &iter))) {
 		const char *p;
 		int len;
-
-		field = &enumc->fields [i];
+		
 		if (strcmp ("value__", field->name) == 0)
 			continue;
 		if (mono_field_is_deleted (field))
@@ -2589,7 +2589,7 @@
 		mono_array_set (info->names, gpointer, j, mono_string_new (domain, field->name));
 
 		if (!field->data) {
-			crow = mono_metadata_get_constant_index (enumc->image, MONO_TOKEN_FIELD_DEF | (i+enumc->field.first+1), crow + 1);
+			crow = mono_metadata_get_constant_index (enumc->image, mono_class_get_field_token (field), crow + 1);
 			field->def_type = mono_metadata_decode_row_col (&enumc->image->tables [MONO_TABLE_CONSTANT], crow-1, MONO_CONSTANT_TYPE);
 			crow = mono_metadata_decode_row_col (&enumc->image->tables [MONO_TABLE_CONSTANT], crow-1, MONO_CONSTANT_VALUE);
 			field->data = (gpointer)mono_metadata_blob_heap (enumc->image, crow);
@@ -2646,8 +2646,9 @@
 {
 	MonoDomain *domain; 
 	MonoClass *startklass, *klass;
-	int i, match;
+	int match;
 	MonoClassField *field;
+	gpointer iter;
 	char *utf8_name;
 	int (*compare_func) (const char *s1, const char *s2) = NULL;
 	domain = ((MonoObject *)type)->vtable->domain;
@@ -2660,10 +2661,10 @@
 
 	compare_func = (bflags & BFLAGS_IgnoreCase) ? g_strcasecmp : strcmp;
 
-handle_parent:	
-	for (i = 0; i < klass->field.count; ++i) {
+handle_parent:
+	iter = NULL;
+	while ((field = mono_class_get_fields (klass, &iter))) {
 		match = 0;
-		field = &klass->fields [i];
 		if (mono_field_is_deleted (field))
 			continue;
 		if ((field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) == FIELD_ATTRIBUTE_PUBLIC) {
@@ -2713,6 +2714,7 @@
 	MonoArray *res;
 	MonoObject *member;
 	int i, len, match;
+	gpointer iter;
 	MonoClassField *field;
 
 	MONO_ARCH_SAVE_REGS;
@@ -2722,9 +2724,9 @@
 	refklass = mono_class_from_mono_type (reftype->type);
 
 handle_parent:	
-	for (i = 0; i < klass->field.count; ++i) {
+	iter = NULL;
+	while ((field = mono_class_get_fields (klass, &iter))) {
 		match = 0;
-		field = &klass->fields [i];
 		if (mono_field_is_deleted (field))
 			continue;
 		if ((field->type->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) == FIELD_ATTRIBUTE_PUBLIC) {
@@ -2771,6 +2773,7 @@
 	MonoClass *startklass, *klass, *refklass;
 	MonoArray *res;
 	MonoMethod *method;
+	gpointer iter;
 	MonoObject *member;
 	int i, len, match;
 	GHashTable *method_slots = g_hash_table_new (mono_aligned_addr_hash, NULL);
@@ -2789,9 +2792,10 @@
 	}
 
 handle_parent:
-	for (i = 0; i < klass->method.count; ++i) {
+	iter = NULL;
+	
+	while ((method = mono_class_get_methods (klass, &iter))) {
 		match = 0;
-		method = klass->methods [i];
 		if (strcmp (method->name, ".ctor") == 0 || strcmp (method->name, ".cctor") == 0)
 			continue;
 		if ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {
@@ -2860,16 +2864,16 @@
 	MonoMethod *method;
 	MonoObject *member;
 	int i, len, match;
-
+	gpointer iter = NULL;
+	
 	MONO_ARCH_SAVE_REGS;
 
 	domain = ((MonoObject *)type)->vtable->domain;
 	klass = startklass = mono_class_from_mono_type (type->type);
 	refklass = mono_class_from_mono_type (reftype->type);
 
-	for (i = 0; i < klass->method.count; ++i) {
+	while ((method = mono_class_get_methods (klass, &iter))) {
 		match = 0;
-		method = klass->methods [i];
 		if (strcmp (method->name, ".ctor") && strcmp (method->name, ".cctor"))
 			continue;
 		if ((method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC) {
@@ -2922,6 +2926,7 @@
 	MonoProperty *prop;
 	int i, match;
 	int len = 0;
+	gpointer iter;
 	guint32 flags;
 	GHashTable *method_slots = g_hash_table_new (mono_aligned_addr_hash, NULL);
 	gchar *propname = NULL;
@@ -2937,8 +2942,8 @@
 	}
 
 handle_parent:
-	for (i = 0; i < klass->property.count; ++i) {
-		prop = &klass->properties [i];
+	iter = NULL;
+	while ((prop = mono_class_get_properties (klass, &iter))) {
 		match = 0;
 		method = prop->get;
 		if (!method)
@@ -3014,10 +3019,10 @@
 {
 	MonoDomain *domain;
 	MonoClass *klass, *startklass;
-	gint i;
 	MonoEvent *event;
 	MonoMethod *method;
 	gchar *event_name;
+	gpointer iter;
 
 	MONO_ARCH_SAVE_REGS;
 
@@ -3025,9 +3030,9 @@
 	klass = startklass = mono_class_from_mono_type (type->type);
 	domain = mono_object_domain (type);
 
-handle_parent:	
-	for (i = 0; i < klass->event.count; i++) {
-		event = &klass->events [i];
+handle_parent:
+	iter = NULL;
+	while ((event = mono_class_get_events (klass, &iter))) {
 		if (strcmp (event->name, event_name))
 			continue;
 
@@ -3071,15 +3076,16 @@
 	MonoMethod *method;
 	MonoEvent *event;
 	int i, len, match;
+	gpointer iter;
 
 	MONO_ARCH_SAVE_REGS;
 
 	domain = ((MonoObject *)type)->vtable->domain;
 	klass = startklass = mono_class_from_mono_type (type->type);
 
-handle_parent:	
-	for (i = 0; i < klass->event.count; ++i) {
-		event = &klass->events [i];
+handle_parent:
+	iter = NULL;
+	while ((event = mono_class_get_events (klass, &iter))) {
 		match = 0;
 		method = event->add;
 		if (!method)
@@ -5441,11 +5447,12 @@
 	{
 		result = klass->vtable [method->slot];
 		if (result == NULL) {
+			MonoMethod* m;
+			gpointer iter = NULL;
 			/* It is an abstract method */
-			int i;
-			for (i=0; i<klass->method.count; i++) {
-				if (klass->methods [i]->slot == method->slot) {
-					result = klass->methods [i];
+			while ((m = mono_class_get_methods (klass, &iter))) {
+				if (m->slot == method->slot) {
+					result = m;
 					break;
 				}
 			}
@@ -5608,12 +5615,13 @@
 ves_icall_System_Runtime_InteropServices_Marshal_PrelinkAll (MonoReflectionType *type)
 {
 	MonoClass *klass = mono_class_from_mono_type (type->type);
-	int i;
+	MonoMethod* m;
+	gpointer iter = NULL;
 	MONO_ARCH_SAVE_REGS;
 
-	mono_class_init (klass);
-	for (i = 0; i < klass->method.count; ++i)
-		prelink_method (klass->methods [i]);
+	
+	while ((m = mono_class_get_methods (klass, &iter)))
+		prelink_method (m);
 }
 
 /* These parameters are "readonly" in corlib/System/Char.cs */
Index: reflection.c
===================================================================
--- reflection.c	(revision 39776)
+++ reflection.c	(working copy)
@@ -1949,18 +1949,7 @@
 	g_assert (NewConstraintAttr);
 
 	if (!NewConstraintAttr_ctor) {
-		int i;
-
-		for (i = 0; i < NewConstraintAttr->method.count; i++) {
-			MonoMethod *m = NewConstraintAttr->methods [i];
-
-			if (strcmp (m->name, ".ctor"))
-				continue;
-
-			NewConstraintAttr_ctor = m;
-			break;
-		}
-
+		NewConstraintAttr_ctor = mono_class_get_method_from_name (NewConstraintAttr, ".ctor", -1);
 		g_assert (NewConstraintAttr_ctor);
 	}
 
