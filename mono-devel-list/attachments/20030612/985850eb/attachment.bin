Index: Test/System.Collections/SortedListTest.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/Test/System.Collections/SortedListTest.cs,v
retrieving revision 1.7
diff -u -p -r1.7 SortedListTest.cs
--- Test/System.Collections/SortedListTest.cs	21 Dec 2002 14:11:00 -0000	1.7
+++ Test/System.Collections/SortedListTest.cs	13 Jun 2003 00:33:59 -0000
@@ -1,6 +1,8 @@
 // SortedListTest.cs - NUnit Test Cases for the System.Collections.SortedList class
 //
-// Jaak Simm
+// Authors:
+//      Jaak Simm
+//      Duncan Mak (duncan@ximian.com)
 //
 // Thanks go to David Brandt (bucky@keystreams.com),
 // because this file is based on his ArrayListTest.cs
@@ -21,17 +23,20 @@ namespace MonoTests.System.Collections {
 
 
 /// <summary>SortedList test.</summary>
-public class SortedListTest : TestCase {
+[TestFixture]
+public class SortedListTest : Assertion {
 	protected SortedList sl1;
 	protected SortedList sl2;
 	protected SortedList emptysl;
 	protected const int icap=16;
-		
-	protected override void SetUp() 
+
+        [SetUp]
+	public  void SetUp() 
 	{
 	}
 
-	protected override void TearDown() 
+        [TearDown]
+	public void TearDown() 
 	{
 	}
 
@@ -40,7 +45,8 @@ public class SortedListTest : TestCase {
 		AssertNotNull("sl.constructor-1: returns null", temp1);
 		AssertEquals("sl.constructor-1: incorrect initial capacity", icap, temp1.Capacity);
 	}
-	
+
+        [Test]
 	public void TestConstructor2() {
 		Comparer c = Comparer.Default;
 		SortedList temp1 = new SortedList(c);
@@ -48,6 +54,7 @@ public class SortedListTest : TestCase {
 		AssertEquals("sl.constructor-2: incorrect initial capacity", icap, temp1.Capacity);
 	}
 
+        [Test]
 	public void TestConstructor3() {
 		Hashtable d = new Hashtable();
 		d.Add("one", "Mircosoft");
@@ -79,7 +86,8 @@ public class SortedListTest : TestCase {
 			Fail ("Unexpected Exception throw: e=" + e);
 		}
 	}
-	
+
+        [Test]	
 	public void TestConstructor4() {
 		SortedList temp1 = new SortedList(17);
 		AssertNotNull("sl.constructor-4: returns null", temp1);
@@ -95,6 +103,7 @@ public class SortedListTest : TestCase {
 		}
 	}
 
+        [Test]	
 	public void TestConstructor5() {
 		Comparer c = Comparer.Default;
 		SortedList temp1 = new SortedList(c,27);
@@ -106,6 +115,7 @@ public class SortedListTest : TestCase {
 		} catch (ArgumentOutOfRangeException) {}
 	}
 
+        [Test]	
 	public void TestIsSynchronized() {
 		SortedList sl1 = new SortedList();
 		Assert("sl: should not be synchronized by default", 
@@ -114,6 +124,7 @@ public class SortedListTest : TestCase {
 		Assert("sl: synchronized wrapper not working", sl2.IsSynchronized);
 	}
 
+        [Test]	
 	public void TestCapacity() {
 		for (int i = 0; i < 100; i++) {
 			SortedList sl1 = new SortedList(i);
@@ -122,6 +133,33 @@ public class SortedListTest : TestCase {
 		}
 	}
 
+        [Test]
+        public void TestCapacity2 ()
+        {
+                SortedList list = new SortedList ();
+                list.Capacity = 5;
+
+                AssertEquals (list.Capacity, 5);
+        }
+
+        [Test]
+        public void TestCapacity3 ()
+        {
+                SortedList list = new SortedList (1000);
+                list.Capacity = 5;
+
+                AssertEquals (list.Capacity, 16);
+        }
+
+        [Test]
+        [ExpectedException (typeof (OutOfMemoryException))]
+        public void TestCapacity4 ()
+        {
+                SortedList list = new SortedList ();
+                list.Capacity = Int32.MaxValue;
+        }
+
+        [Test]	
 	public void TestCount() {
 		{
 			SortedList sl1 = new SortedList();
@@ -135,17 +173,21 @@ public class SortedListTest : TestCase {
 		}
 	}
 
+        [Test]	
 	public void TestIsFixed() {
 		SortedList sl1 = new SortedList();
 		Assert("should not be fixed by default", !sl1.IsFixedSize);
 	}
 
+
+        [Test]	
 	public void TestIsReadOnly() {
 		SortedList sl
@@ -446,6 +502,7 @@ public class SortedListTest : TestCase {
 		AssertEquals("sl.GetKeyList: incorrect key(2)",keys[8],33.9);
 	}
 
+        [Test]
 	public void TestGetValueList() {
 		SortedList sl1 = DefaultSL();
 		IList originalvals = DefaultValues();
@@ -473,6 +530,7 @@ public class SortedListTest : TestCase {
 	}
 	*/
 
+        [Test]
 	public void TestIndexOfKey() {
 		SortedList sl1 = new SortedList(24);
 		string s=null;
@@ -499,6 +557,7 @@ public class SortedListTest : TestCase {
 		}
 	}
 
+        [Test]
 	public void TestIndexOfValue() {
 		SortedList sl1 = new SortedList(24);
 		string s=null;
@@ -516,8 +575,30 @@ public class SortedListTest : TestCase {
 			AssertEquals("sl.IndexOfValue: incorrect index key", i, sl1.IndexOfValue(100+i*i));
 		}
 	}
-	
 
+        [Test]
+        public void TestIndexOfValue2 ()
+        {
+                SortedList list = new SortedList ();
+                list.Add ("key0", "la la");
+                list.Add ("key1", "value");
+                list.Add ("key2", "value");
+
+                int i = list.IndexOfValue ("value");
+
+                AssertEquals (i, 1);
+        }
+
+        [Test]
+        public void TestIndexOfValue3 ()
+        {
+                SortedList list = new SortedList ();
+                int i = list.IndexOfValue ((string) null);
+
+                AssertEquals (i, -1);
+        }
+
+        [Test]
 	public void TestRemove() {
 		SortedList sl1 = new SortedList(24);
 		string s=null;
@@ -544,6 +625,7 @@ public class SortedListTest : TestCase {
 			AssertEquals("sl.Remove: removing failed(2)",sl1["kala "+i],null);
 	}
 
+        [Test]
 	public void TestRemoveAt() {
 		SortedList sl1 = new SortedList(24);
 		int k;
@@ -574,6 +656,7 @@ public class SortedListTest : TestCase {
 			AssertEquals("sl.RemoveAt: removing failed(4)",sl1["kala "+string.Format("{0:D2}", i)],i);
 	}
 
+        [Test]
 	public void TestSetByIndex() {
 		SortedList sl1 = new SortedList(24);
 		for (int i = 49; i>=0; i--) sl1.Add(100+i,i);
@@ -597,6 +680,7 @@ public class SortedListTest : TestCase {
 
 	}
 
+        [Test]
 	public void TestTrimToSize() {
 		SortedList sl1 = new SortedList(24);
 		
Index: Test/System.Collections/HashtableTest.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/Test/System.Collections/HashtableTest.cs,v
retrieving revision 1.9
diff -u -p -r1.9 HashtableTest.cs
--- Test/System.Collections/HashtableTest.cs	10 Jun 2003 22:42:04 -0000	1.9
+++ Test/System.Collections/HashtableTest.cs	13 Jun 2003 00:33:59 -0000
@@ -22,11 +22,15 @@ namespace MonoTests.System.Collections {
 
 /// <summary>Hashtable test.</summary>
 [TestFixture]
-public class HashtableTest : TestCase {
+public class HashtableTest : Assertion {
+
+        [Test]
 	public void TestCtor1() {
 		Hashtable h = new Hashtable();
 		AssertNotNull("No hash table", h);
 	}
+
+        [Test]
 	public void TestCtor2() {
 		{
 			bool errorThrown = false;
@@ -52,9 +56,26 @@ public class HashtableTest : TestCase {
 			}
 		}
 	}
+
+        [Test]
+        [ExpectedException (typeof (ArgumentOutOfRangeException))]
+        public void TestCtor3 ()
+        {
+                Hashtable h = new Hashtable ();
+                Hashtable hh = new Hashtable (h, Single.NaN);
+        }
+
+        [Test]
+        [ExpectedException (typeof (ArgumentException))]
+        public void TestCtor4 ()
+        {
+                Hashtable ht = new Hashtable (Int32.MaxValue, 0.1f, null, null);
+        }
+        
 	// TODO - Ctors for capacity and load (how to test? any access?)
         // TODO - Ctors with IComparer, IHashCodeProvider, Serialization
-	
+
+        [Test]	
 	public void TestCount() {
 		Hashtable h = new Hashtable();
 		AssertEquals("new table - count zero", 0, h.Count);
@@ -71,6 +92,7 @@ public class HashtableTest : TestCase {
 		}
 	}
 
+        [Test]        
 	public void TestIsFixedSize() {
 		Hashtable h = new
@@ -615,6 +651,7 @@ public class HashtableTest : TestCase {
 	///  Test hashtable with CaseInsensitiveHashCodeProvider
 	///  and CaseInsensitive comparer.
 	/// </summary>
+        [Test]        
 	public void TestCaseInsensitive ()
 	{
 		// Not very meaningfull test, just to make
@@ -630,7 +667,7 @@ public class HashtableTest : TestCase {
 
 	}
 
-
+        [Test]
 	public void TestCopyConstructor ()
 	{
 		SetDefaultData ();
@@ -640,7 +677,7 @@ public class HashtableTest : TestCase {
 		Assert(ht.Count == htCopy.Count);
 	}
 
-
+        [Test]
 	public void TestEnumerator ()
 	{
 		SetDefaultData ();
Index: Test/System.Collections/ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/Test/System.Collections/ChangeLog,v
retrieving revision 1.34
diff -u -p -r1.34 ChangeLog
--- Test/System.Collections/ChangeLog	10 Jun 2003 22:42:04 -0000	1.34
+++ Test/System.Collections/ChangeLog	13 Jun 2003 00:33:59 -0000
@@ -1,4 +1,21 @@
+2003-06-12  Duncan Mak  <duncan@ximian.com>
 
+	* HashtableTest.cs: Converted it to the new style of NUnit tests.
+
+	(TestCtor3): 
+	(TestCtor4): new tests for the constructor.
+
+2003-06-11  Duncan Mak  <duncan@ximian.com>
+
+	* SortedListTest.cs: Convert it to the new style of NUnit tests.
+
+	(TestCapacity2):
+	(TestCapacity3):
+	(TestCapacity4): new tests for the Capacity property.
+
+	(TestIndexOfValue2):
+	(TestIndexOfValue3): new tests for the IndexOfValue method.
+	
 2003-06-11  Gonzalo Paniagua Javier <gonzalo@ximian.com>
 
 	* HashtableTest.cs: removed duplicate tests and unneeded inner class.
Index: System.Collections/SortedList.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Collections/SortedList.cs,v
retrieving revision 1.11
diff -u -p -r1.11 SortedList.cs
--- System.Collections/SortedList.cs	9 Jun 2003 00:41:38 -0000	1.11
+++ System.Collections/SortedList.cs	13 Jun 2003 00:33:59 -0000
@@ -162,17 +162,32 @@ namespace System.Collections {
 			get {
 				return table.Length;
 			}
+
 			set {
-				Slot [] table = this.table;
-				int current = table.Length;
+				int current = this.table.Length;
 
 				if (inUse > value)
 					throw new ArgumentOutOfRangeException("capacity too small");
 
-				if (value > current) {
+                                else if (value > inUse) {
+                                        Slot [] newTable = new Slot [value];
+                                        Array.Copy (table, newTable, inUse);
+                                        this.table = newTable;
+                                        return;
+
+                                } else if (current > INITIAL_SIZE && value < current) {
+                                        Slot [] newTable = new Slot [INITIAL_SIZE];
+                                        Array.Copy (table, newTable, inUse);
+                                        this.table = newTable;
+                                        return;
+                                
+                                }
+
+                                if (value > current) {
 					Slot [] newTable = new Slot [value];
 					Array.Copy (table, newTable, current);
 					this.table = newTable;
+                                        return;
 				}
 			}
 		}
@@ -320,18 +335,15 @@ namespace System.Collections {
 
 		public virtual int IndexOfValue (object value)
 		{
-			if (null == value)
-				return -1;
+                        if (inUse == 0)
+                                return -1;
+                        
+                        for (int i = 0; i < this.table.Length; i ++) {
+                                Slot current = this.table [i];
 
-			Slot [] table = this.table;
-			int len = table.Length;
-
-			for (int i=0; i < len; i++) {
-				object trialValue = table[i].value;
-				if ((null != trialValue) && (trialValue.Equals (value))) {
+                                if (Equals (current.value, value))
 					return i;
-				}
-			}
+                        }
 
 			return -1;
 		}
@@ -514,14 +526,12 @@ namespace System.Collections {
 
 		private void  CopyToArray (Array arr, int i, 
 					   EnumeratorMode mode)
-		{
-			if (arr == null)
-				throw new ArgumentNullException ("arr");
-
-			if (i < 0 || i + this.Count > arr.Length)
-				throw new ArgumentOutOfRangeException ("i");
-			
-
+		{
+			if (arr == null)
+				throw new ArgumentNullException ("arr");
+
+			if (i < 0 || i + this.Count > arr.Length)
+				throw new ArgumentOutOfRangeException ("i");
 			
 			IEnumerator it = new Enumerator (this, mode);
 
@@ -575,8 +585,8 @@ namespace System.Collections {
 			private EnumeratorMode mode;
 
 			private object currentKey;
-			private object currentValue;
-				
+			private object currentValue;
+				
 			bool invalid = false;
 
 			private readonly static string xstr = "SortedList.Enumerator: snapshot out of sync.";
@@ -597,7 +607,7 @@ namespace System.Collections {
 
 			public void Reset ()
 			{
-				if (host.modificationCount != stamp || invalid)
+				if (host.modificationCount != stamp || invalid)
 					throw new InvalidOperationException (xstr);
 
 				pos = -1;
@@ -607,7 +617,7 @@ namespace System.Collections {
 
 			public bool MoveNext ()
 			{
-				if (host.modificationCount != stamp || invalid)
+				if (host.modificationCount != stamp || invalid)
 					throw new InvalidOperationException (xstr);
 
 				Slot [] table = host.table;
@@ -628,8 +638,8 @@ namespace System.Collections {
 			public DictionaryEntry Entry
 			{
 				get {
-					if (invalid || pos >= size || pos == -1)
-						throw new InvalidOperationException (xstr);
+					if (invalid || pos >= size || pos == -1)
+						throw new InvalidOperationException (xstr);
 					
 					return new DictionaryEntry (currentKey,
 					                            currentValue);
@@ -638,7 +648,7 @@ namespace System.Collections {
 
 			public Object Key {
 				get {
-					if (invalid || pos >= size || pos == -1)
+					if (invalid || pos >= size || pos == -1)
 						throw new InvalidOperationException (xstr);
 					return currentKey;
 				}
@@ -646,7 +656,7 @@ namespace System.Collections {
 
 			public Object Value {
 				get {
-					if (invalid || pos >= size || pos == -1)
+					if (invalid || pos >= size || pos == -1)
 						throw new InvalidOperationException (xstr);
 					return currentValue;
 				}
@@ -654,8 +664,8 @@ namespace System.Collections {
 
 			public Object Current {
 				get {
-					if (invalid || pos >= size || pos == -1)
-						throw new InvalidOperationException (xstr);
+					if (invalid || pos >= size || pos == -1)
+						throw new InvalidOperationException (xstr);
 					
 					return (mode == EnumeratorMode.KEY_MODE)
 					        ? currentKey
Index: System.Collections/Hashtable.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Collections/Hashtable.cs,v
retrieving revision 1.17
diff -u -p -r1.17 Hashtable.cs
--- System.Collections/Hashtable.cs	9 Jun 2003 00:41:38 -0000	1.17
+++ System.Collections/Hashtable.cs	13 Jun 2003 00:33:59 -0000
@@ -110,12 +110,17 @@ namespace System.Collections {
 			if (capacity<0)
 				throw new ArgumentOutOfRangeException ("negative capacity");
 
-			if (loadFactor<0.1 || loadFactor>1)
+			if (loadFactor < 0.1f || loadFactor > 1.0f || Single.IsNaN (loadFactor))
 				throw new ArgumentOutOfRangeException ("load factor");
 
 			if (capacity == 0) ++capacity;
 			this.loadFactor = 0.75f*loadFactor;
-			int size = (int) (capacity/this.loadFactor);
+			double tableSize = capacity / this.loadFactor;
+
+                        if (tableSize > Int32.MaxValue)
+                                throw new ArgumentException ("Size is too big");
+
+                        int size = (int) tableSize;
 			size = ToPrime (size);
 			this.SetTable (new Slot [size]);
 
Index: System.Collections/ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Collections/ChangeLog,v
retrieving revision 1.78
diff -u -p -r1.78 ChangeLog
--- System.Collections/ChangeLog	9 Jun 2003 00:43:28 -0000	1.78
+++ System.Collections/ChangeLog	13 Jun 2003 00:33:59 -0000
@@ -1,3 +1,26 @@
+2003-06-12  Duncan Mak  <duncan@ximian.com>
+
+	* Hashtable.cs (constructor):
+	if loadFactor equals Single.NaN, then throw an
+	ArgumentOutOfRangeException.
+
+	if we set capacity to be too big (ie. capacity / loadFactor is
+	greater than Int32.MaxValue), then we throw an ArgumentException.
+
+2003-06-11  Duncan Mak  <duncan@ximian.com>
+
+	* SortedList.cs: Oi! What a mess.
+
+	If the list was constructed using the null-param constructor, and
+	it tries to set it to a size lower than the default, let it do so.
+
+	If the list was constructed with a specific size, and it tries to
+	set it to a size lower than the specified size, set it to the
+	default size.
+
+	(IndexOfValue): Clean up the code somewhat, make it allow for
+	values to be null.
+
 2003-06-08  Ben Maurer <bmaurer@users.sourceforge.net>
 	* ArrayList.cs, Hashtable.cs, SortedList.cs: Enumerator fixes, error
 	checking
