Index: assembly.c
===================================================================
--- assembly.c	(revisión: 48811)
+++ assembly.c	(copia de trabajo)
@@ -1171,10 +1171,92 @@
 	g_free ((void *) aname->hash_value);
 }
 
+static gint 
+to_int32_le (gchar bytes [], gint offset)
+{
+	return (bytes [offset+3] << 24) | (bytes [offset+2] << 16) | (bytes [offset+1] << 8) | bytes [offset];
+}
+
 static gboolean
-build_assembly_name (const char *name, const char *version, const char *culture, const char *token, MonoAssemblyName *aname)
+parse_public_key (const gchar *key, const gchar** pubkey)
 {
+	const gchar *pkey;
+	gchar header [16], val, *arr;
+	gint i, j, offset, bitlen, keylen, pkeylen;
+	
+	keylen = strlen (key) >> 1;
+	if (keylen < 1)
+		return FALSE;
+	
+	val = g_ascii_xdigit_value (key [0]) << 4;
+	val |= g_ascii_xdigit_value (key [1]);
+	switch (val) {
+		case 0x00:
+			if (keylen < 13)
+				return FALSE;
+			val = g_ascii_xdigit_value (key [24]);
+			val |= g_ascii_xdigit_value (key [25]);
+			if (val != 0x06)
+				return FALSE;
+			pkey = key + 24;
+			break;
+		case 0x06:
+			pkey = key;
+			break;
+		default:
+			return FALSE;
+	}
+		
+	/* We need the first 16 bytes
+	* to check whether this key is valid or not */
+	pkeylen = strlen (pkey) >> 1;
+	if (pkeylen < 16)
+		return FALSE;
+		
+	for (i = 0, j = 0; i < 16; i++) {
+		header [i] = g_ascii_xdigit_value (pkey [j++]) << 4;
+		header [i] |= g_ascii_xdigit_value (pkey [j++]);
+	}
+
+	if (header [0] != 0x06 || /* PUBLICKEYBLOB (0x06) */
+			header [1] != 0x02 || /* Version (0x02) */
+			header [2] != 0x00 || /* Reserved (word) */
+			header [3] != 0x00 ||
+			(guint)(to_int32_le (header, 8)) != 0x31415352) /* DWORD magic = RSA1 */
+		return FALSE;
+
+	/* Based on this length, we _should_ be able to know if the length is right */
+	bitlen = to_int32_le (header, 12) >> 3;
+	if ((bitlen + 16 + 4) != pkeylen)
+		return FALSE;
+		
+	/* Encode the size of the blob */
+	offset = 0;
+	if (keylen <= 127) {
+		arr = g_malloc (keylen + 1);
+		arr [offset++] = keylen;
+	} else {
+		arr = g_malloc (keylen + 2);
+		arr [offset++] = 0x80; /* 10bs */
+		arr [offset++] = keylen;
+	}
+		
+	for (i = offset, j = 0; i < keylen + offset; i++) {
+		arr [i] = g_ascii_xdigit_value (key [j++]) << 4;
+		arr [i] |= g_ascii_xdigit_value (key [j++]);
+	}
+	if (pubkey)
+		*pubkey = arr;
+
+	return TRUE;
+}
+
+static gboolean
+build_assembly_name (const char *name, const char *version, const char *culture, const char *token, const char *key, MonoAssemblyName *aname, gboolean save_public_key)
+{
 	gint major, minor, build, revision;
+	gint len;
+	gchar *pkey, *pkeyptr, *encoded, tok [8];
 
 	memset (aname, 0, sizeof (MonoAssemblyName));
 
@@ -1199,6 +1281,25 @@
 	
 	if (token && strncmp (token, "null", 4) != 0)
 		g_strlcpy ((char*)aname->public_key_token, token, MONO_PUBLIC_KEY_TOKEN_LENGTH);
+
+	if (key && strncmp (key, "null", 4) != 0) {
+		if (!parse_public_key (key, (const gchar**) &pkey)) {
+			mono_assembly_name_free (aname);
+			return FALSE;
+		}
+		
+		len = mono_metadata_decode_blob_size ((const gchar *) pkey, (const gchar **) &pkeyptr);
+		// We also need to generate the key token
+		mono_digest_get_public_token ((guchar*) tok, (guint8*) pkeyptr, len);
+		encoded = encode_public_tok ((guchar*) tok, 8);
+		g_strlcpy ((gchar*)aname->public_key_token, encoded, MONO_PUBLIC_KEY_TOKEN_LENGTH);
+		g_free (encoded);
+
+		if (save_public_key)
+			aname->public_key = (guint8*) pkey;
+		else
+			g_free (pkey);
+	}
 	
 	return TRUE;
 }
@@ -1215,27 +1316,19 @@
 		return FALSE;
 	}
 	
-	res = build_assembly_name (name, parts[0], parts[1], parts[2], aname);
+	res = build_assembly_name (name, parts[0], parts[1], parts[2], NULL, aname, FALSE);
 	g_strfreev (parts);
 	return res;
 }
 
-/**
-* mono_assembly_name_parse:
-* @name: name to parse
-* @aname: the destination assembly name
-* Returns: true if the name could be parsed.
-* 
-* Parses an assembly qualified type name and assigns the name,
-* version, culture and token to the provided assembly name object.
-*/
 gboolean
-mono_assembly_name_parse (const char *name, MonoAssemblyName *aname)
+mono_assembly_name_parse_full (const char *name, MonoAssemblyName *aname, gboolean save_public_key)
 {
 	gchar *dllname;
 	gchar *version = NULL;
 	gchar *culture = NULL;
 	gchar *token = NULL;
+	gchar *key = NULL;
 	gboolean res;
 	gchar *value;
 	gchar **parts;
@@ -1270,16 +1363,37 @@
 			tmp++;
 			continue;
 		}
+
+		if (!g_ascii_strncasecmp (value, "PublicKey=", 10)) {
+			key = g_strstrip (value + 10);
+			tmp++;
+			continue;
+		}
 		
 		g_strfreev (parts);
 		return FALSE;
 	}
 
-	res = build_assembly_name (dllname, version, culture, token, aname);
+	res = build_assembly_name (dllname, version, culture, token, key, aname, save_public_key);
 	g_strfreev (parts);
 	return res;
 }
 
+/**
+* mono_assembly_name_parse:
+* @name: name to parse
+* @aname: the destination assembly name
+* Returns: true if the name could be parsed.
+* 
+* Parses an assembly qualified type name and assigns the name,
+* version, culture and token to the provided assembly name object.
+*/
+gboolean
+mono_assembly_name_parse (const char *name, MonoAssemblyName *aname)
+{
+	return mono_assembly_name_parse_full (name, aname, FALSE);
+}
+
 static MonoAssembly*
 probe_for_partial_name (const char *basepath, const char *fullname, MonoAssemblyName *aname, MonoImageOpenStatus *status)
 {
Index: metadata-internals.h
===================================================================
--- metadata-internals.h	(revisión: 48811)
+++ metadata-internals.h	(copia de trabajo)
@@ -330,5 +330,10 @@
 
 void mono_config_parse_publisher_policy (const char *filename, MonoAssemblyBindingInfo *binding_info);
 
+gboolean
+mono_assembly_name_parse_full 		     (const char	   *name,
+					      MonoAssemblyName	   *aname,
+					      gboolean save_public_key);
+
 #endif /* __MONO_METADATA_INTERNALS_H__ */
 
Index: icall.c
===================================================================
--- icall.c	(revisión: 48811)
+++ icall.c	(copia de trabajo)
@@ -4152,9 +4152,11 @@
 		mono_method_desc_free (desc);
 	}
 
-	args [0] = mono_string_new (domain, name->culture);
-	aname->cultureInfo = 
-		mono_runtime_invoke (create_culture, NULL, args, NULL);
+	if (name->culture) {
+		args [0] = mono_string_new (domain, name->culture);
+		aname->cultureInfo = 
+			mono_runtime_invoke (create_culture, NULL, args, NULL);
+	}
 
 	if (name->public_key) {
 		pkey_ptr = (char*)name->public_key;
@@ -4445,6 +4447,26 @@
 	return res;
 }
 
+static gboolean
+ves_icall_System_Reflection_AssemblyName_ParseName (MonoReflectionAssemblyName *name, MonoString *assname)
+{
+	MonoAssemblyName aname;
+	MonoDomain *domain = mono_object_domain (name);
+	char *val;
+
+	val = mono_string_to_utf8 (assname);
+	if (!mono_assembly_name_parse_full (val, &aname, TRUE))
+		return FALSE;
+	
+	fill_reflection_assembly_name (domain, name, &aname, "");
+
+	mono_assembly_name_free (&aname);
+	g_free ((guint8*) aname.public_key);
+	g_free (val);
+
+	return TRUE;
+}
+
 static MonoReflectionType*
 ves_icall_System_Reflection_Module_GetGlobalType (MonoReflectionModule *module)
 {
@@ -6539,6 +6561,10 @@
 	{"load_with_partial_name", ves_icall_System_Reflection_Assembly_load_with_partial_name}
 };
 
+static const IcallEntry assembly_name_icalls [] = {
+	{"ParseName", ves_icall_System_Reflection_AssemblyName_ParseName}
+};
+
 static const IcallEntry methodbase_icalls [] = {
 	{"GetCurrentMethod", ves_icall_GetCurrentMethod},
 	{"GetMethodBodyInternal", ves_icall_System_Reflection_MethodBase_GetMethodBodyInternal},
@@ -7077,6 +7103,7 @@
 	{"System.Net.Sockets.SocketException", socketex_icalls, G_N_ELEMENTS (socketex_icalls)},
 	{"System.Object", object_icalls, G_N_ELEMENTS (object_icalls)},
 	{"System.Reflection.Assembly", assembly_icalls, G_N_ELEMENTS (assembly_icalls)},
+	{"System.Reflection.AssemblyName", assembly_name_icalls, G_N_ELEMENTS (assembly_name_icalls)},
 	{"System.Reflection.Emit.AssemblyBuilder", assemblybuilder_icalls, G_N_ELEMENTS (assemblybuilder_icalls)},
 	{"System.Reflection.Emit.CustomAttributeBuilder", customattrbuilder_icalls, G_N_ELEMENTS (customattrbuilder_icalls)},
 	{"System.Reflection.Emit.DynamicMethod", dynamicmethod_icalls, G_N_ELEMENTS (dynamicmethod_icalls)},
