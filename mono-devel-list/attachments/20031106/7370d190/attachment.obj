Index: mono/metadata/reflection.h
===================================================================
RCS file: /mono/mono/mono/metadata/reflection.h,v
retrieving revision 1.94
diff -u -b -r1.94 reflection.h
--- mono/metadata/reflection.h	3 Nov 2003 20:55:02 -0000	1.94
+++ mono/metadata/reflection.h	7 Nov 2003 02:22:44 -0000
@@ -482,7 +482,7 @@
 	StrongNameKeyPair keypair;
 	AssemblyVersionCompatibility versioncompat;*/
 	MonoObject  *cultureInfo;
-	MonoObject  *flags;
+	guint32     flags;
 	guint32     hashalg;
 	MonoObject  *keypair;
 	MonoArray   *publicKey;
Index: mono/mini/cpu-pentium.md
===================================================================
RCS file: /mono/mono/mono/mini/cpu-pentium.md,v
retrieving revision 1.16
diff -u -b -r1.16 cpu-pentium.md
--- mono/mini/cpu-pentium.md	28 Aug 2003 11:25:08 -0000	1.16
+++ mono/mini/cpu-pentium.md	7 Nov 2003 02:22:45 -0000
@@ -303,6 +303,9 @@
 voidcall: len:11 clob:c
 voidcall_reg: src1:i len:11 clob:c
 voidcall_membase: src1:b len:16 clob:c
+pcall: dest:i len:11 clob:c
+pcall_reg: dest:i src1:i len:11 clob:c
+pcall_membase: dest:i src1:b len:16 clob:c
 fcall: dest:f len:11 clob:c
 fcall_reg: dest:f src1:i len:11 clob:c
 fcall_membase: dest:f src1:b len:16 clob:c
Index: mono/mini/graph.c
===================================================================
RCS file: /mono/mono/mono/mini/graph.c,v
retrieving revision 1.3
diff -u -b -r1.3 graph.c
--- mono/mini/graph.c	1 Sep 2003 14:56:19 -0000	1.3
+++ mono/mini/graph.c	7 Nov 2003 02:22:45 -0000
@@ -191,6 +191,8 @@
 		break;
 	case CEE_CALL:
 	case CEE_CALLVIRT:
+	case OP_PCALL:
+	case OP_PCALLVIRT:
 	case OP_FCALL:
 	case OP_FCALLVIRT:
 	case OP_LCALL:
@@ -233,6 +235,7 @@
 	case CEE_CASTCLASS:
 	case OP_OUTARG:
 	case OP_CALL_REG:
+	case OP_PCALL_REG:
 	case OP_FCALL_REG:
 	case OP_LCALL_REG:
 	case OP_VCALL_REG:
Index: mono/mini/inssel-long.brg
===================================================================
RCS file: /mono/mono/mono/mini/inssel-long.brg,v
retrieving revision 1.1
diff -u -b -r1.1 inssel-long.brg
--- mono/mini/inssel-long.brg	5 Apr 2003 19:21:32 -0000	1.1
+++ mono/mini/inssel-long.brg	7 Nov 2003 02:22:45 -0000
@@ -1,47 +1,443 @@
+/*
+ * inssel-long.brg: burg file for 64bit architectures
+ *
+ * Author:
+ *   Dietmar Maurer (dietmar@ximian.com)
+ *
+ * (C) 2002 Ximian, Inc.
+ *
+ */
+
+#define	MONO_EMIT_NEW_LCOMPARE_IMM(cfg,sr1,imm)				\
+G_STMT_START {								\
+	MonoInst *inst;							\
+	inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst)); \
+	inst->opcode = OP_LCOMPARE_IMM;					\
+	inst->sreg1 = sr1;						\
+	inst->inst_p1 = (gpointer)(imm);				\
+	mono_bblock_add_inst ((cfg)->cbb, inst);			\
+} G_STMT_END
+
+#define	MONO_EMIT_NEW_LCOMPARE(cfg,sr1,sr2)				\
+G_STMT_START {								\
+	MonoInst *inst;							\
+	inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst)); \
+	inst->opcode = OP_LCOMPARE;					\
+	inst->sreg1 = sr1;						\
+	inst->sreg2 = sr2;						\
+	mono_bblock_add_inst ((cfg)->cbb, inst);			\
+} G_STMT_END
+
 %%
 
 #
-# inssel-long.brg: burg file for 64bit architectures
+# LP64 stuff
+#
+
+regp: reg {
+	MonoInst *inst;
+	int dst = mono_regstate_next_int (s->rs);
+
+	/* create a new instruction for chained rules */
+	inst = mono_mempool_alloc0 (s->mempool, sizeof (MonoInst));
+	inst->opcode = CEE_CONV_I;
+	inst->sreg1 = state->reg1;
+	inst->dreg = dst;
+	mono_bblock_add_inst (s->cbb, inst);
+
+	state->reg1 = dst;
+	state->tree = inst;
+}
+
+regp: lreg "0"
+lreg: regp "0"
+
+base: OP_LADD (base, OP_ICONST) "0" {
+	tree->inst_offset = state->left->tree->inst_offset 
+		+ state->right->tree->inst_c0;
+	tree->inst_basereg = state->left->tree->inst_basereg;
+}
+
+base: OP_LADD (CEE_LDIND_REF (OP_REGPTR), OP_ICONST) "0" {
+	tree->inst_offset = state->right->tree->inst_c0;
+	tree->inst_basereg = state->left->left->tree->dreg;
+}
+
+base: OP_LADD (CEE_LDIND_I (OP_REGPTR), OP_ICONST) "0" {
+	tree->inst_offset = state->right->tree->inst_c0;
+	tree->inst_basereg = state->left->left->tree->dreg;
+}
+
+#
+# helpers
 #
-# Author:
-#   Dietmar Maurer (dietmar@ximian.com)
+
+stmt: CEE_POP (lreg) {
+	/* do nothing */
+}
+
+i8con: OP_I8CONST "0"
+
+i8con: OP_ICONST "0" {
+	/* implicit conv.i{8} */
+	tree->opcode = OP_I8CONST;
+	tree->inst_l = (gint64) tree->inst_c0;
+}
+
+i8con: CEE_CONV_I8 (OP_ICONST) "0" {
+	tree->opcode = OP_I8CONST;
+	tree->inst_l = (gint32) state->left->tree->inst_c0;
+}
+
+i8con: CEE_CONV_U8 (OP_ICONST) "0" {
+	tree->opcode = OP_I8CONST;
+	tree->inst_l = (guint32) state->left->tree->inst_c0;
+}
+
+lreg: OP_I8CONST {
+	MONO_EMIT_NEW_I8CONST (s, state->reg1, state->tree->inst_l);
+}
+
 #
-# (C) 2002 Ximian, Inc.
+# load/store operations
 #
 
-reg: CEE_LDIND_I8 (base) {
+
+lreg: CEE_LDIND_I8 (base) {
 	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI8_MEMBASE, state->reg1, 
-				   state->left->tree->inst_basereg, state->left->tree->inst_offset);
+				   state->left->tree->inst_basereg,
+				   state->left->tree->inst_offset);
+}
+
+lreg: CEE_LDIND_I8 (OP_REGVAR) {
+	tree->opcode = OP_MOVE;
+	tree->sreg1 = state->left->tree->dreg;
+	tree->dreg = state->reg1;
+	mono_bblock_add_inst (s->cbb, tree);
+}
+
+stmt: CEE_STIND_I8 (base, lreg) {
+	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI8_MEMBASE_REG,
+				 state->left->tree->inst_basereg,
+				 state->left->tree->inst_offset,
+				 state->right->reg1);
+}
+
+stmt: CEE_STIND_I8 (OP_REGVAR, lreg) {
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg,
+			 state->right->reg1);
+}
+
+stmt: CEE_STIND_I8 (OP_REGVAR, i8con) {
+	tree->opcode = OP_I8CONST;
+	tree->dreg = state->left->tree->dreg;
+	tree->inst_l = state->right->tree->inst_l;
+	mono_bblock_add_inst (s->cbb, tree);
+}
+
+#
+# int32 to int64 conversions
+#
+
+lreg: CEE_CONV_I8 (reg) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
+}
+
+lreg: CEE_CONV_OVF_I8 (reg) {
+	/* cannot overflow */
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_I8, state->reg1, state->left->reg1);
+}
+
+lreg: CEE_CONV_U8 (reg) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
+}
+
+lreg: CEE_CONV_OVF_U8 (reg) {
+	/* make sure it is positive */
+	MONO_EMIT_NEW_COMPARE_IMM (s, state->left->reg1, 0);
+	MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_U8, state->reg1, state->left->reg1);
+}
+
+#
+# int64 to int32 conversions
+#
+
+reg: OP_LCONV_TO_I1 (lreg) {
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state->reg1, state->left->reg1);
+}
+
+reg: OP_LCONV_TO_U1 (lreg) {
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_U1, state->reg1, state->left->reg1);
+}
+
+reg: OP_LCONV_TO_I2 (lreg) {
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state->reg1, state->left->reg1);
+}
+
+reg: OP_LCONV_TO_U2 (lreg) {
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_U2, state->reg1, state->left->reg1);
+}
+
+reg: OP_LCONV_TO_I4 (lreg) {
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+reg: OP_LCONV_TO_U4 (lreg) {
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+lreg: OP_LCONV_TO_I8 (lreg) {
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+lreg: OP_LCONV_TO_U8 (lreg) {
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+regp: OP_LCONV_TO_U (lreg) {
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+regp: OP_LCONV_TO_I (lreg) {
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
 }
 
-stmt: CEE_STIND_I8 (base, reg) {
-	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STOREI8_MEMBASE_REG, state->left->tree->inst_basereg,
-				 state->left->tree->inst_offset, state->right->reg1);
+reg: OP_LCONV_TO_OVF_I1 (lreg) {
+	/* Probe value to be within -128 and 127 */
+	MONO_EMIT_NEW_LCOMPARE_IMM (s, state->left->reg1, 127);
+	MONO_EMIT_NEW_COND_EXC (s, GT, "OverflowException");
+	MONO_EMIT_NEW_LCOMPARE_IMM (s, state->left->reg1, -128);
+	MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_I1, state->reg1, state->left->reg1);
 }
 
-stmt: CEE_STIND_I8 (base, OP_ICONST) {
-	MONO_EMIT_STORE_MEMBASE_IMM (s, tree, OP_STOREI8_MEMBASE_IMM, state->left->tree->inst_basereg,
-				     state->left->tree->inst_offset, state->right->tree->inst_c0);
+reg: OP_LCONV_TO_OVF_U1 (lreg) {
+	/* probe value to be within 0 to 255 */
+	MONO_EMIT_NEW_LCOMPARE_IMM (s, state->left->reg1, 0xff);
+	MONO_EMIT_NEW_COND_EXC (s, GT_UN, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_U1, state->reg1, state->left->reg1);
 }
 
-reg: OP_FCONV_TO_I8 (freg) {
-	g_assert_not_reached ();
+reg: OP_LCONV_TO_OVF_I2 (lreg) {
+	/* Probe value to be within -32768 and 32767 */
+	MONO_EMIT_NEW_LCOMPARE_IMM (s, state->left->reg1, 32767);
+	MONO_EMIT_NEW_COND_EXC (s, GT, "OverflowException");
+	MONO_EMIT_NEW_LCOMPARE_IMM (s, state->left->reg1, -32768);
+	MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_I2, state->reg1, state->left->reg1);
 }
 
-reg: OP_FCONV_TO_U8 (freg) {
-	g_assert_not_reached ();
+reg: OP_LCONV_TO_OVF_U2 (lreg) {
+	/* Probe value to be within 0 and 65535 */
+	MONO_EMIT_NEW_LCOMPARE_IMM (s, state->left->reg1, 0xffff);
+	MONO_EMIT_NEW_COND_EXC (s, GT_UN, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, CEE_CONV_U2, state->reg1, state->left->reg1);
+}
+
+reg: OP_LCONV_TO_OVF_I4 (lreg) {
+	/*FIXME: check ovf*/
+	//int tmp1 = mono_regstate_next_int (s->rs);
+	//int tmp2 = mono_regstate_next_int (s->rs);
+	//MONO_EMIT_NEW_BIALU_IMM (s, OP_LSHL_IMM, tmp1, state->left->reg1, 32);
+	//MONO_EMIT_NEW_BIALU_IMM (s, OP_LSHR_IMM, tmp2, tmp1, 32);
+	//MONO_EMIT_NEW_LCOMPARE (s, tmp2, state->left->reg1);
+	//MONO_EMIT_NEW_COND_EXC (s, NE_UN, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+reg: OP_LCONV_TO_OVF_U4 (lreg) {
+	/*FIXME: check ovf*/
+	//int r = mono_regstate_next_int (s->rs);
+	//MONO_EMIT_NEW_BIALU_IMM (s, OP_LSHR_UN_IMM, r, state->left->reg1, 32);
+	//MONO_EMIT_NEW_COMPARE_IMM (s, r, 0);
+	//MONO_EMIT_NEW_COND_EXC (s, NE_UN, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+reg: OP_LCONV_TO_OVF_U4_UN (lreg) {
+	/*FIXME: check ovf*/
+	//int r = mono_regstate_next_int (s->rs);
+	//MONO_EMIT_NEW_BIALU_IMM (s, OP_LSHR_UN_IMM, r, state->left->reg1, 32);
+	//MONO_EMIT_NEW_COMPARE_IMM (s, r, 0);
+	//MONO_EMIT_NEW_COND_EXC (s, NE_UN, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+regp: OP_LCONV_TO_OVF_I (lreg) {
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+regp: OP_LCONV_TO_OVF_I_UN (lreg) {
+	/* make sure it is positive */
+	MONO_EMIT_NEW_LCOMPARE_IMM (s, state->left->reg1, 0);
+	MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+lreg: OP_LCONV_TO_OVF_I8 (lreg) {
+	/* cannot overflow */
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+lreg: OP_LCONV_TO_OVF_I8_UN (lreg) {
+	/* make sure it is positive */
+	MONO_EMIT_NEW_LCOMPARE_IMM (s, state->left->reg1, 0);
+	MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+lreg: OP_LCONV_TO_OVF_U8 (lreg) {
+	/* make sure it is positive */
+	MONO_EMIT_NEW_LCOMPARE_IMM (s, state->left->reg1, 0);
+	MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+lreg: OP_LCONV_TO_OVF_U8_UN (lreg) {
+	/* cannot overflow */
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
+}
+
+#
+# floating-point to int64 conversions
+#
+
+lreg: OP_FCONV_TO_I8 (freg) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
+}
+
+lreg: OP_FCONV_TO_U8 (freg) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
+}
+
+#
+# arithmetic/logical int64 operations
+#
+
+lreg: OP_LADD (lreg, lreg) {
+	MONO_EMIT_BIALU (s, tree, CEE_ADD, state->reg1, state->left->reg1,
+			 state->right->reg1);
+}
+
+lreg: OP_LADD (lreg, i8con) {
+	MONO_EMIT_BIALU_IMM (s, tree, OP_ADD_IMM, state->reg1,
+			     state->left->reg1, state->right->tree->inst_l);
+}
+
+lreg: OP_LADD_OVF (lreg, lreg) {
+	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1,
+			 state->right->reg1);
+}
+
+lreg: OP_LADD_OVF_UN (lreg, lreg) {
+	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1,
+			 state->right->reg1);
+}
+
+lreg: OP_LSUB (lreg, lreg) {
+	MONO_EMIT_BIALU (s, tree, CEE_SUB, state->reg1, state->left->reg1,
+			 state->right->reg1);
+}
+
+lreg: OP_LSUB (lreg, i8con) {
+	MONO_EMIT_BIALU_IMM (s, tree, OP_SUB_IMM, state->reg1,
+			     state->left->reg1, state->right->tree->inst_l);
+}
+
+lreg: OP_LSUB_OVF (lreg, lreg) {
+	MONO_EMIT_NEW_BIALU (s, tree->opcode, state->reg1, state->left->reg1,
+			     state->right->reg1);
+}
+
+lreg: OP_LSUB_OVF_UN (lreg, lreg) {
+	MONO_EMIT_NEW_BIALU (s, tree->opcode, state->reg1, state->left->reg1,
+			     state->right->reg1);
+}
+
+lreg: OP_LMUL (lreg, lreg) {
+	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1,
+			 state->left->reg1, state->right->reg1);
+}
+
+lreg: OP_LAND (lreg, lreg) {	
+	MONO_EMIT_BIALU (s, tree, CEE_AND, state->reg1,
+			 state->left->reg1, state->right->reg1);
+}
+
+lreg: OP_LAND (lreg, i8con) {
+	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1,
+			     state->left->reg1, state->right->tree->inst_l);
+}
+
+lreg: OP_LOR (lreg, lreg) {
+	MONO_EMIT_BIALU (s, tree, CEE_OR, state->reg1,
+			 state->left->reg1, state->right->reg1);
+}
+
+lreg: OP_LOR (lreg, i8con) {
+	MONO_EMIT_BIALU_IMM (s, tree, OP_OR_IMM, state->reg1,
+			     state->left->reg1, state->right->tree->inst_l);
+}
+
+lreg: OP_LXOR (lreg, lreg) {
+	MONO_EMIT_BIALU (s, tree, CEE_XOR, state->reg1,
+			 state->left->reg1, state->right->reg1);
+}
+
+lreg: OP_LXOR (lreg, i8con) {
+	MONO_EMIT_BIALU_IMM (s, tree, OP_XOR_IMM, state->reg1,
+			     state->left->reg1, state->right->tree->inst_l);
+}
+
+lreg: OP_LNOT (lreg) {
+	MONO_EMIT_UNALU (s, tree, CEE_NOT, state->reg1, state->left->reg1);
+}
+
+lreg: OP_LNEG (lreg) {
+	MONO_EMIT_UNALU (s, tree, CEE_NEG, state->reg1, state->left->reg1);
+}
+
+lreg: OP_BIGMUL (reg, reg) {
+	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1,
+			 state->right->reg1); 
+}
+
+lreg: OP_BIGMUL_UN (reg, reg) {
+	MONO_EMIT_BIALU (s, tree, tree->opcode, state->reg1, state->left->reg1,
+			 state->right->reg1); 
+}
+
+#
+# int64 comparisons
+#
+
+cflags: OP_COMPARE (lreg, lreg) {
+	tree->opcode = OP_LCOMPARE;
+	tree->sreg1 = state->left->reg1;
+	tree->sreg2 = state->right->reg1;
+	mono_bblock_add_inst (s->cbb, tree);
 }
 
-freg: CEE_CONV_R_UN (reg) {
-	g_assert_not_reached ();
+cflags: OP_COMPARE (lreg, i8con) {
+	tree->opcode = OP_LCOMPARE_IMM;
+	tree->sreg1 = state->left->reg1;
+	tree->inst_imm = state->right->tree->inst_l;
+	mono_bblock_add_inst (s->cbb, tree);
 }
 
-freg: CEE_CONV_R4 (reg) {
-	g_assert_not_reached ();
+cflags: OP_COMPARE (CEE_LDIND_I8 (OP_REGVAR), lreg) {
+	tree->opcode = OP_LCOMPARE;
+	tree->sreg1 = state->left->left->tree->dreg;
+	tree->sreg2 = state->right->reg1;
+	mono_bblock_add_inst (s->cbb, tree);
 }
 
-freg: CEE_CONV_R8 (reg) {
-	g_assert_not_reached ();
+cflags: OP_COMPARE (CEE_LDIND_I8 (OP_REGVAR), i8con) {
+	tree->opcode = OP_LCOMPARE_IMM;
+	tree->sreg1 = state->left->left->tree->dreg;
+	tree->inst_imm = state->right->tree->inst_l;
+	mono_bblock_add_inst (s->cbb, tree);
 }
 
 %%
Index: mono/mini/inssel-long32.brg
===================================================================
RCS file: /mono/mono/mono/mini/inssel-long32.brg,v
retrieving revision 1.11
diff -u -b -r1.11 inssel-long32.brg
--- mono/mini/inssel-long32.brg	4 Aug 2003 10:22:15 -0000	1.11
+++ mono/mini/inssel-long32.brg	7 Nov 2003 02:22:46 -0000
@@ -10,6 +10,28 @@
 #
 
 #
+# ILP32 stuff
+#
+
+regp: reg "0"
+reg: regp "0"
+
+base: CEE_ADD (base, OP_ICONST) "0" {
+	tree->inst_offset = state->left->tree->inst_offset + state->right->tree->inst_c0;
+	tree->inst_basereg = state->left->tree->inst_basereg;
+}
+
+base: CEE_ADD (CEE_LDIND_REF (OP_REGPTR), OP_ICONST) "0" {
+	tree->inst_offset = state->right->tree->inst_c0;
+	tree->inst_basereg = state->left->left->tree->dreg;
+}
+
+base: CEE_ADD (CEE_LDIND_I (OP_REGPTR), OP_ICONST) "0" {
+	tree->inst_offset = state->right->tree->inst_c0;
+	tree->inst_basereg = state->left->left->tree->dreg;
+}
+
+#
 # We use a new non-terminal called "lreg" for 64bit registers, and
 # emulate lreg with 2 32bit registers.
 #
@@ -133,6 +155,10 @@
 lreg: OP_LAND (lreg, lreg) {	
 	MONO_EMIT_NEW_BIALU (s, CEE_AND, state->reg1, state->left->reg1, state->right->reg1);
 	MONO_EMIT_BIALU (s, tree, CEE_AND, state->reg2, state->left->reg2, state->right->reg2);
+}
+
+lreg: OP_LMUL (lreg, lreg) {
+	g_assert_not_reached ();
 }
 
 lreg: OP_LAND (lreg, i8con) {	
Index: mono/mini/inssel-x86.brg
===================================================================
RCS file: /mono/mono/mono/mini/inssel-x86.brg,v
retrieving revision 1.13
diff -u -b -r1.13 inssel-x86.brg
--- mono/mini/inssel-x86.brg	6 Oct 2003 15:48:33 -0000	1.13
+++ mono/mini/inssel-x86.brg	7 Nov 2003 02:22:48 -0000
@@ -22,7 +22,7 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-stmt: OP_ENDFILTER (reg) {
+stmt: OP_ENDFILTER (regp) {
 	MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
 	MONO_EMIT_NEW_UNALU (s, OP_MOVE, X86_EAX, state->left->reg1);
 	MONO_EMIT_NEW_LOAD_MEMBASE (s, X86_ESP, spvar->inst_basereg, spvar->inst_offset); 
@@ -107,7 +107,7 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-reg: OP_LOCALLOC (OP_ICONST) {
+regp: OP_LOCALLOC (OP_ICONST) {
 	if (tree->flags & MONO_INST_INIT) {
 		/* microcoded in mini-x86.c */
 		tree->sreg1 = mono_regstate_next_int (s->rs);
@@ -119,11 +119,110 @@
 	}
 }
 
-reg: OP_LOCALLOC (reg) {
-	tree->sreg1 = state->left->tree->dreg;
+regp: OP_LOCALLOC (regp) {
+	tree->sreg1 = state->left->reg1;
+	mono_bblock_add_inst (s->cbb, tree);
+}
+
+stmt: OP_VCALL (regp) {
+	MonoInst *vtarg;
+
+	MONO_INST_NEW (s, vtarg, OP_OUTARG);
+	vtarg->inst_left = state->left->tree;
+	vtarg->type = STACK_MP;
+	vtarg->sreg1 = state->left->reg1;
+	mono_bblock_add_inst (s->cbb, vtarg);
+
+	mono_bblock_add_inst (s->cbb, tree);
+}
+
+stmt: OP_VCALL_REG (regp, regp) {
+	MonoInst *vtarg;
+
+	MONO_INST_NEW (s, vtarg, OP_OUTARG);
+	vtarg->inst_left = state->right->tree;
+	vtarg->type = STACK_MP;
+	vtarg->sreg1 = state->right->reg1;
+	mono_bblock_add_inst (s->cbb, vtarg);
+	
+	tree->sreg1 = state->left->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
+reg: CEE_CALLVIRT (regp) {
+	MonoInst *this;
+	/* add the this argument */
+	MONO_INST_NEW (s, this, OP_OUTARG);
+	this->inst_left = state->left->tree;
+	this->type = this->inst_left->type;
+	this->sreg1 = state->left->reg1;
+	mono_bblock_add_inst (s->cbb, this);
+	mini_emit_virtual_call (s, state, tree, CEE_CALL, OP_CALL_MEMBASE);
+}
+
+regp: OP_PCALLVIRT (regp) {
+	MonoInst *this;
+	/* add the this argument */
+	MONO_INST_NEW (s, this, OP_OUTARG);
+	this->inst_left = state->left->tree;
+	this->type = this->inst_left->type;
+	this->sreg1 = state->left->reg1;
+	mono_bblock_add_inst (s->cbb, this);
+	mini_emit_virtual_call (s, state, tree, OP_PCALL, OP_PCALL_MEMBASE);
+}
+
+stmt: OP_VOIDCALLVIRT (regp) {
+	MonoInst *this;
+	/* add the this argument */
+	MONO_INST_NEW (s, this, OP_OUTARG);
+	this->inst_left = state->left->tree;
+	this->type = this->inst_left->type;
+	this->sreg1 = state->left->reg1;
+	mono_bblock_add_inst (s->cbb, this);
+	mini_emit_virtual_call (s, state, tree, OP_VOIDCALL, OP_VOIDCALL_MEMBASE);
+}
+
+lreg: OP_LCALLVIRT (regp) {
+	MonoInst *this;
+	/* add the this argument */
+	MONO_INST_NEW (s, this, OP_OUTARG);
+	this->inst_left = state->left->tree;
+	this->type = this->inst_left->type;
+	this->sreg1 = state->left->reg1;
+	mono_bblock_add_inst (s->cbb, this);
+	mini_emit_virtual_call (s, state, tree, OP_LCALL, OP_LCALL_MEMBASE);
+}
+
+freg: OP_FCALLVIRT (regp) {
+	MonoInst *this;
+	/* add the this argument */
+	MONO_INST_NEW (s, this, OP_OUTARG);
+	this->inst_left = state->left->tree;
+	this->type = this->inst_left->type;
+	this->sreg1 = state->left->reg1;
+	mono_bblock_add_inst (s->cbb, this);
+	mini_emit_virtual_call (s, state, tree, OP_FCALL, OP_FCALL_MEMBASE);
+}
+
+stmt: OP_VCALLVIRT (regp, regp) {
+	MonoInst *vtarg, *this;
+
+	/* add the this argument */
+	MONO_INST_NEW (s, this, OP_OUTARG);
+	this->inst_left = state->left->tree;
+	this->type = this->inst_left->type;
+	this->sreg1 = state->left->reg1;
+	mono_bblock_add_inst (s->cbb, this);
+
+	MONO_INST_NEW (s, vtarg, OP_OUTARG);
+	vtarg->inst_left = state->right->tree;
+	vtarg->type = STACK_MP;
+	vtarg->sreg1 = state->right->reg1;
+	mono_bblock_add_inst (s->cbb, vtarg);
+
+	mini_emit_virtual_call (s, state, tree, OP_VCALL, OP_VCALL_MEMBASE);
+}
+
 stmt: OP_SETRET (reg) {
 	tree->opcode = OP_MOVE;
 	tree->sreg1 = state->left->reg1;
@@ -131,6 +230,13 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
+stmt: OP_SETRET (regp) {
+	tree->opcode = OP_MOVE;
+	tree->sreg1 = state->left->reg1;
+	tree->dreg = X86_EAX;
+	mono_bblock_add_inst (s->cbb, tree);
+}
+
 stmt: OP_SETRET (lreg) {
 	MONO_EMIT_NEW_UNALU (s, OP_MOVE, X86_EDX, state->left->reg2);
 	tree->opcode = OP_MOVE;
@@ -163,6 +269,12 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
+stmt: OP_OUTARG (regp) {
+	tree->opcode = OP_X86_PUSH;
+	tree->sreg1 = state->left->reg1;
+	mono_bblock_add_inst (s->cbb, tree);
+}
+
 # we need to reduce this code duplication with some burg syntax extension
 stmt: OP_OUTARG (CEE_LDIND_REF (OP_REGVAR)) {
 	tree->opcode = OP_X86_PUSH;
@@ -249,9 +361,9 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-stmt: OP_OUTARG (CEE_LDOBJ (reg)) {
+stmt: OP_OUTARG (CEE_LDOBJ (regp)) {
 	tree->opcode = OP_X86_PUSH;
-	tree->sreg1 = state->left->reg1;
+	tree->sreg1 = state->left->left->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
@@ -314,9 +426,9 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-stmt: OP_OUTARG_VT (reg) {
+stmt: OP_OUTARG_VT (regp) {
 	tree->opcode = OP_X86_PUSH;
-	tree->sreg1 = state->left->tree->dreg;
+	tree->sreg1 = state->left->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
@@ -348,7 +460,7 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-reg: CEE_LDELEMA (reg, reg) "15" {
+regp: CEE_LDELEMA (regp, regp) "15" {
 	int length_reg = mono_regstate_next_int (s->rs);
 	guint32 size = mono_class_array_element_size (tree->klass);
 	
Index: mono/mini/inssel.brg
===================================================================
RCS file: /mono/mono/mono/mini/inssel.brg,v
retrieving revision 1.25
diff -u -b -r1.25 inssel.brg
--- mono/mini/inssel.brg	29 Oct 2003 14:56:08 -0000	1.25
+++ mono/mini/inssel.brg	7 Nov 2003 02:22:53 -0000
@@ -267,7 +267,7 @@
 # base addressing mode 
 #
 
-base: reg "0" {
+base: regp "0" {
 	/* we create a new MonoInst in chain rules and set state->tree to it
 	 * since a MBState (and hence state->tree) is reused in chain rules and
 	 * normal rules.
@@ -283,7 +283,7 @@
 	//tree->inst_basereg = state->reg1;
 }
 
-base: CEE_LDIND_I (OP_REGVAR) "0" {
+base: CEE_LDIND_I (OP_REGPTR) "0" {
 	tree->inst_offset = 0;
 	tree->inst_basereg = state->left->tree->dreg;
 }
@@ -302,21 +302,6 @@
 	tree->inst_basereg = state->left->tree->inst_basereg;
 }
 
-base: CEE_ADD (base, OP_ICONST) "0" {
-	tree->inst_offset = state->left->tree->inst_offset + state->right->tree->inst_c0;
-	tree->inst_basereg = state->left->tree->inst_basereg;
-}
-
-base: CEE_ADD (CEE_LDIND_REF (OP_REGVAR), OP_ICONST) "0" {
-	tree->inst_offset = state->right->tree->inst_c0;
-	tree->inst_basereg = state->left->left->tree->dreg;
-}
-
-base: CEE_ADD (CEE_LDIND_I (OP_REGVAR), OP_ICONST) "0" {
-	tree->inst_offset = state->right->tree->inst_c0;
-	tree->inst_basereg = state->left->left->tree->dreg;
-}
-
 #
 # helpers
 #
@@ -325,7 +310,16 @@
      	MONO_EMIT_NEW_ICONST (s, state->reg1, tree->inst_c0);
 }
 
-reg: OP_AOTCONST {
+regp: OP_ICONST {
+
+     	MONO_EMIT_NEW_PCONST (s, state->reg1, tree->inst_p0);
+}
+
+regp: CEE_CONV_I (OP_ICONST) {
+     	MONO_EMIT_NEW_PCONST (s, state->reg1, state->left->tree->inst_p0);
+}
+
+regp: OP_AOTCONST {
      	MONO_EMIT_NEW_AOTCONST (s, state->reg1, tree->inst_p0, tree->inst_c1);
 }
 
@@ -333,12 +327,12 @@
 # load/store operations
 #
 
-reg: CEE_LDIND_I (base) {
+regp: CEE_LDIND_I (base) {
 	MONO_EMIT_LOAD_MEMBASE (s, tree, state->reg1, state->left->tree->inst_basereg, 
 				state->left->tree->inst_offset);
 }
 
-reg: CEE_LDIND_REF (base) {
+regp: CEE_LDIND_REF (base) {
 	MONO_EMIT_LOAD_MEMBASE (s, tree, state->reg1, state->left->tree->inst_basereg, 
 				state->left->tree->inst_offset);
 }
@@ -363,7 +357,7 @@
 				   state->left->tree->inst_basereg, state->left->tree->inst_offset);
 }
 
-reg: OP_LDADDR (OP_REGOFFSET) "2" {
+regp: OP_LDADDR (OP_REGOFFSET) "2" {
 	/* use LEA */
 	tree->opcode = OP_MOVE;
 	tree->sreg1 = state->left->tree->inst_basereg;
@@ -374,7 +368,7 @@
 	}
 }
 
-reg: CEE_LDOBJ (OP_REGOFFSET) "2" {
+regp: CEE_LDOBJ (OP_REGOFFSET) "2" {
 	/* use LEA */
 	/* FIXME: this is just an hack */
 	tree->opcode = OP_MOVE;
@@ -386,28 +380,28 @@
 	}
 }
 
-reg: CEE_LDOBJ (reg) {
+regp: CEE_LDOBJ (regp) {
 	tree->opcode = OP_MOVE;
 	tree->sreg1 = state->left->reg1;
 	tree->dreg = state->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-reg: OP_OBJADDR (reg) {
+regp: OP_OBJADDR (regp) {
 	tree->opcode = OP_MOVE;
 	tree->sreg1 = state->left->reg1;
 	tree->dreg = state->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-reg: OP_VTADDR (reg) {
+regp: OP_VTADDR (regp) {
 	tree->opcode = OP_MOVE;
 	tree->sreg1 = state->left->reg1;
 	tree->dreg = state->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-reg: CEE_LDIND_REF (OP_REGVAR) {
+regp: CEE_LDIND_REF (OP_REGPTR) {
 	tree->opcode = OP_MOVE;
 	tree->sreg1 = state->left->tree->dreg;
 	tree->dreg = state->reg1;
@@ -436,12 +430,12 @@
 	MONO_EMIT_BIALU_IMM (s, tree, OP_AND_IMM, state->reg1, state->left->tree->dreg, 0xffff);
 }
 
-stmt: CEE_STIND_REF (base, reg) {
+stmt: CEE_STIND_REF (base, regp) {
 	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STORE_MEMBASE_REG, state->left->tree->inst_basereg,
 				 state->left->tree->inst_offset, state->right->reg1);
 }
 
-stmt: CEE_STIND_REF (base, CEE_LDIND_REF (OP_REGVAR)) {
+stmt: CEE_STIND_REF (base, CEE_LDIND_REF (OP_REGPTR)) {
 	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STORE_MEMBASE_REG, state->left->tree->inst_basereg,
 				 state->left->tree->inst_offset, state->right->left->tree->dreg);
 }
@@ -451,12 +445,12 @@
 				     state->left->tree->inst_offset, state->right->tree->inst_c0);
 }
 
-stmt: CEE_STIND_REF (OP_REGVAR, CEE_LDIND_REF (OP_REGVAR)) {
+stmt: CEE_STIND_REF (OP_REGPTR, CEE_LDIND_REF (OP_REGPTR)) {
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->left->tree->dreg);
 }
 
 
-stmt: CEE_STIND_I (base, reg) {
+stmt: CEE_STIND_I (base, regp) {
 	MONO_EMIT_STORE_MEMBASE (s, tree, OP_STORE_MEMBASE_REG, state->left->tree->inst_basereg,
 				 state->left->tree->inst_offset, state->right->reg1);
 }
@@ -484,7 +478,7 @@
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->tree->dreg);
 }
 
-reg: CEE_LDIND_I (OP_REGVAR) {
+regp: CEE_LDIND_I (OP_REGPTR) {
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->tree->dreg);
 }
 
@@ -568,22 +562,22 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-stmt: CEE_STIND_REF (OP_REGVAR, reg) {
+stmt: CEE_STIND_REF (OP_REGPTR, regp) {
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->reg1);
 }
 
-stmt: CEE_STIND_REF (OP_REGVAR, OP_ICONST) {
+stmt: CEE_STIND_REF (OP_REGPTR, OP_ICONST) {
 	tree->opcode = OP_ICONST;
 	tree->dreg = state->left->tree->dreg;
 	tree->inst_c0 = state->right->tree->inst_c0;
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-stmt: CEE_STIND_I (OP_REGVAR, reg) {
+stmt: CEE_STIND_I (OP_REGPTR, regp) {
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->left->tree->dreg, state->right->reg1);
 }
 
-stmt: CEE_STELEM_REF (OP_GROUP (reg, reg), reg) {
+stmt: CEE_STELEM_REF (OP_GROUP (reg, reg), regp) {
 
 	g_assert_not_reached ();
 }
@@ -592,17 +586,17 @@
 	g_assert_not_reached ();
 }
 
-stmt: OP_MEMCPY (reg, reg) {
+stmt: OP_MEMCPY (regp, regp) {
 	int size = tree->unused;
 	mini_emit_memcpy (s, state->left->reg1, 0, state->right->reg1, 0, size, 0);
 }
 
-stmt: OP_MEMSET (reg) {
+stmt: OP_MEMSET (regp) {
 	int size = tree->unused;
 	mini_emit_memset (s, state->left->reg1, 0, size, tree->inst_imm, 0);
 }
 
-reg: OP_LDELEMA2D (reg, OP_GROUP (reg, reg)) "20" {
+regp: OP_LDELEMA2D (regp, OP_GROUP (regp, regp)) "20" {
 	int bounds_reg = mono_regstate_next_int (s->rs);
 	int add_reg = mono_regstate_next_int (s->rs);
 	int mult_reg = mono_regstate_next_int (s->rs);
@@ -621,7 +615,7 @@
 	index2 = state->right->right->reg1;
 
 	/* range checking */
-	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, bounds_reg, 
+	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, bounds_reg, 
 				       state->left->reg1, G_STRUCT_OFFSET (MonoArray, bounds));
 
 	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOADI4_MEMBASE, low1_reg, 
@@ -660,7 +654,7 @@
 }
 
 reg: CEE_CONV_I4 (reg) {
-	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
+	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
 }
 
 reg: CEE_CONV_U1 (reg) {
@@ -672,14 +666,10 @@
 }
 
 reg: CEE_CONV_U4 (reg) {
-	if (sizeof (void *) == 8) {
-		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
-	} else {
 		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
-	}
 }
 
-reg: CEE_CONV_U (reg) {
+regp: CEE_CONV_U (reg) {
 	if (sizeof (void *) == 8) {
 		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
 	} else {
@@ -687,7 +677,7 @@
 	}
 }
 
-reg: CEE_CONV_I (reg) {
+regp: CEE_CONV_I (reg) {
 	if (sizeof (void *) == 8) {
 		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
 	} else {
@@ -696,33 +686,21 @@
 }
 
 reg: CEE_CONV_OVF_I4 (reg) {
-	if (sizeof (void *) == 8) {
-		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
-	} else {
 		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
-	}
 }
 
 reg: CEE_CONV_OVF_U4 (reg) {
-	if (sizeof (void *) == 8) {
-		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
-	} else {
-		/* Keep in sync with CONV_OVF_I4_UN below, they are the same on 32-bit machines */		
+	/* Keep in sync with CONV_OVF_I4_UN below */		
 		MONO_EMIT_NEW_COMPARE_IMM (s, state->left->reg1, 0);
 		MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
 		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
-	}
 }
 
 reg: CEE_CONV_OVF_I4_UN (reg) {
-	if (sizeof (void *) == 8) {
-		MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
-	} else {
-		/* Keep in sync with CONV_OVF_U4 above, they are the same on 32-bit machines */
+	/* Keep in sync with CONV_OVF_U4 above */
 		MONO_EMIT_NEW_COMPARE_IMM (s, state->left->reg1, 0);
 		MONO_EMIT_NEW_COND_EXC (s, LT, "OverflowException");
 		MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
-	}
 }
 
 reg: CEE_CONV_OVF_I1 (reg) {     
@@ -1013,27 +991,18 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-reg: CEE_CALLVIRT (reg) {
-	mini_emit_virtual_call (s, state, tree, CEE_CALL, OP_CALL_MEMBASE);
-}
-
-stmt: OP_VOIDCALLVIRT (reg) {
-	mini_emit_virtual_call (s, state, tree, OP_VOIDCALL, OP_VOIDCALL_MEMBASE);
-}
-
-lreg: OP_LCALLVIRT (reg) {
-	mini_emit_virtual_call (s, state, tree, OP_LCALL, OP_LCALL_MEMBASE);
-}
-
-freg: OP_FCALLVIRT (reg) {
-	mini_emit_virtual_call (s, state, tree, OP_FCALL, OP_FCALL_MEMBASE);
+reg: OP_CALL_REG (regp) {
+	tree->sreg1 = state->left->reg1;
+	tree->dreg = state->reg1;
+	mono_bblock_add_inst (s->cbb, tree);
 }
 
-stmt: OP_VCALLVIRT (reg, reg) {
-	mini_emit_virtual_call (s, state, tree, OP_VCALL, OP_VCALL_MEMBASE);
+regp: OP_PCALL {
+	tree->dreg = state->reg1;
+	mono_bblock_add_inst (s->cbb, tree);
 }
 
-reg: OP_CALL_REG (reg) {
+regp: OP_PCALL_REG (regp) {
 	tree->sreg1 = state->left->reg1;
 	tree->dreg = state->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
@@ -1043,7 +1012,7 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-stmt: OP_VOIDCALL_REG (reg) {
+stmt: OP_VOIDCALL_REG (regp) {
 	tree->sreg1 = state->left->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
@@ -1053,7 +1022,7 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-freg: OP_FCALL_REG (reg) {
+freg: OP_FCALL_REG (regp) {
 	tree->sreg1 = state->left->reg1;
 	tree->dreg = state->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
@@ -1064,37 +1033,12 @@
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-lreg: OP_LCALL_REG (reg) {
+lreg: OP_LCALL_REG (regp) {
 	tree->sreg1 = state->left->reg1;
 	tree->dreg = state->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
-stmt: OP_VCALL (reg) {
-	MonoInst *vtarg;
-	/* FIXME: this is actually arch-specific... */
-	MONO_INST_NEW (s, vtarg, OP_OUTARG);
-	vtarg->inst_left = state->left->tree;
-	vtarg->type = STACK_MP;
-	vtarg->sreg1 = state->left->reg1;
-	mono_bblock_add_inst (s->cbb, vtarg);
-
-	mono_bblock_add_inst (s->cbb, tree);
-}
-
-stmt: OP_VCALL_REG (reg, reg) {
-	MonoInst *vtarg;
-	/* FIXME: this is actually arch-specific... */
-	MONO_INST_NEW (s, vtarg, OP_OUTARG);
-	vtarg->inst_left = state->right->tree;
-	vtarg->type = STACK_MP;
-	vtarg->sreg1 = state->right->reg1;
-	mono_bblock_add_inst (s->cbb, vtarg);
-	
-	tree->sreg1 = state->left->reg1;
-	mono_bblock_add_inst (s->cbb, tree);
-}
-
 stmt: CEE_RET "0" {
 	mono_bblock_add_inst (s->cbb, tree);
 }
@@ -1167,6 +1111,8 @@
 
 stmt: CEE_POP (reg)
 
+stmt: CEE_POP (regp)
+
 # remove some common pops without side effects
 stmt: CEE_POP (OP_ICONST)
 stmt: CEE_POP (CEE_LDIND_REF (base))
@@ -1179,11 +1125,11 @@
 
 # exception handling
 
-stmt: CEE_THROW (reg) {
+stmt: CEE_THROW (regp) {
 	MONO_EMIT_UNALU (s, tree, CEE_THROW, -1, state->left->reg1);
 }
 
-stmt: OP_THROW_OR_NULL (reg) {
+stmt: OP_THROW_OR_NULL (regp) {
 	     	MonoClass *klass = tree->inst_newa_class;
 	MonoInst *object_is_null, *end_label, *false_label;
 	int obj_reg = state->left->reg1;
@@ -1197,7 +1143,7 @@
 	mono_bblock_add_inst (s->cbb, object_is_null);
 }
 
-stmt: CEE_THROW (CEE_LDIND_REF (OP_REGVAR)) {
+stmt: CEE_THROW (CEE_LDIND_REF (OP_REGPTR)) {
 	MONO_EMIT_UNALU (s, tree, CEE_THROW, -1, state->left->left->tree->dreg);
 }
 
@@ -1217,13 +1163,14 @@
 	MONO_EMIT_UNALU (s, tree, OP_ENDFILTER, -1, state->left->reg1);
 }
 
-stmt: OP_CHECK_THIS (reg) {
+stmt: OP_CHECK_THIS (regp) {
+	tree->sreg1 = state->left->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
 # object related opcodes 
 
-reg: CEE_ISINST (reg) {
+regp: CEE_ISINST (regp) {
      	MonoClass *klass = tree->inst_newa_class;
 	MonoInst *object_is_null, *end_label, *false_label;
 	int obj_reg = state->left->reg1;
@@ -1341,7 +1288,7 @@
 	mono_bblock_add_inst (s->cbb, end_label);
 }
 
-reg: OP_UNBOXCAST (reg) {
+regp: OP_UNBOXCAST (regp) {
      	MonoClass *klass = tree->inst_newa_class;
 	int obj_reg = state->left->reg1;
 	int vtable_reg = mono_regstate_next_int (s->rs);
@@ -1374,7 +1321,7 @@
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, obj_reg);
 }
 
-reg: CEE_CASTCLASS (reg) {
+regp: CEE_CASTCLASS (regp) {
      	MonoClass *klass = tree->inst_newa_class;
 	MonoInst *object_is_null;
 	int obj_reg = state->left->reg1;
@@ -1478,11 +1425,7 @@
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, obj_reg);
 }
 
-reg: CEE_NEWARR (reg) {
-	g_assert_not_reached ();
-}
-
-lreg: OP_LMUL (lreg, lreg) {
+regp: CEE_NEWARR (regp) {
 	g_assert_not_reached ();
 }
 
@@ -1525,7 +1468,7 @@
 #
 # string support
 #
-reg: OP_GETCHR (reg, reg) {
+reg: OP_GETCHR (regp, regp) {
 	int length_reg = mono_regstate_next_int (s->rs);
 	int mult_reg = mono_regstate_next_int (s->rs);
 	int add_reg = mono_regstate_next_int (s->rs);
@@ -1541,7 +1484,7 @@
 				   add_reg, G_STRUCT_OFFSET (MonoString, chars));
 }
 
-reg: OP_GETCHR (reg, OP_ICONST) {
+reg: OP_GETCHR (regp, OP_ICONST) {
 	int length_reg = mono_regstate_next_int (s->rs);
 	int ind;
 
@@ -1556,12 +1499,17 @@
 #
 # array support
 #
-reg: CEE_LDLEN (reg) {	
+regp: CEE_LDLEN (regp) {	
 	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, 
 				   state->left->reg1, G_STRUCT_OFFSET (MonoArray, max_length));
 }
 
-reg: OP_ARRAY_RANK (reg) {	
+reg: OP_ARRAY_LENGTH (regp) {	
+	MONO_EMIT_LOAD_MEMBASE_OP (s, tree, OP_LOADI4_MEMBASE, state->reg1, 
+				   state->left->reg1, G_STRUCT_OFFSET (MonoArray, max_length));
+}
+
+reg: OP_ARRAY_RANK (regp) {	
 	int vtable_reg = mono_regstate_next_int (s->rs);
 	int class_reg = mono_regstate_next_int (s->rs);
 	MONO_EMIT_NEW_LOAD_MEMBASE_OP (s, OP_LOAD_MEMBASE, vtable_reg, 
@@ -1572,7 +1520,7 @@
 				       class_reg, G_STRUCT_OFFSET (MonoClass, rank));
 }
 
-reg: OP_CHECK_ARRAY_TYPE (reg) {
+regp: OP_CHECK_ARRAY_TYPE (regp) {
 	int vtable_reg = mono_regstate_next_int (s->rs);
 	int class_reg = mono_regstate_next_int (s->rs);
 	int elclass_reg = mono_regstate_next_int (s->rs);
@@ -1588,7 +1536,7 @@
 	MONO_EMIT_UNALU (s, tree, OP_MOVE, state->reg1, state->left->reg1);
 }
 
-reg: CEE_LDELEMA (reg, OP_ICONST) "15" {
+regp: CEE_LDELEMA (regp, OP_ICONST) "15" {
 	int length_reg = mono_regstate_next_int (s->rs);
 	guint32 size = mono_class_array_element_size (tree->klass);
 	int ind;
@@ -1633,7 +1581,7 @@
 	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->reg1, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, value));
 }	
 
-reg: CEE_REFANYTYPE (reg) {
+regp: CEE_REFANYTYPE (regp) {
 	MONO_EMIT_NEW_LOAD_MEMBASE (s, state->reg1, state->left->reg1, G_STRUCT_OFFSET (MonoTypedRef, type));
 }	
 
@@ -1741,27 +1689,10 @@
 void 
 mini_emit_virtual_call (MonoCompile *cfg, void *st, MonoInst *tree, int novirtop, int virtop)
 {
-	MonoInst *this, *vtarg;
 	MonoMethod *method = ((MonoCallInst*)tree)->method;
 	int vtable_reg, slot_reg;
 	MBState *state = st;
 
-	/* add the this argument */
-	MONO_INST_NEW (cfg, this, OP_OUTARG);
-	this->inst_left = state->left->tree;
-	this->type = this->inst_left->type;
-	this->sreg1 = state->left->reg1;
-	mono_bblock_add_inst (cfg->cbb, this);
-
-	if (novirtop == OP_VCALL) {
-		/* FIXME: this is actually arch-specific... */
-		MONO_INST_NEW (cfg, vtarg, OP_OUTARG);
-		vtarg->inst_left = state->right->tree;
-		vtarg->type = STACK_MP;
-		vtarg->sreg1 = state->right->reg1;
-		mono_bblock_add_inst (cfg->cbb, vtarg);
-	}
-
 	if (!(method->flags & METHOD_ATTRIBUTE_VIRTUAL) || 
 	    ((method->flags & METHOD_ATTRIBUTE_FINAL) && 
 	     method->wrapper_type != MONO_WRAPPER_REMOTING_INVOKE_WITH_CHECK)) {
@@ -1774,8 +1705,9 @@
 		}
 
 		if (!method->string_ctor)
-			MONO_EMIT_NEW_UNALU (cfg, OP_CHECK_THIS, -1, this->sreg1);
+			MONO_EMIT_NEW_UNALU (cfg, OP_CHECK_THIS, -1, state->left->reg1);
 
+		if (novirtop != OP_VCALL)
 		tree->dreg = state->reg1;
 		tree->opcode = novirtop;
 		mono_bblock_add_inst (cfg->cbb, tree);
@@ -1783,7 +1715,7 @@
 	}
 
 	vtable_reg = mono_regstate_next_int (cfg->rs);
-	MONO_EMIT_NEW_LOAD_MEMBASE (cfg, vtable_reg, this->sreg1, G_STRUCT_OFFSET (MonoObject, vtable));
+	MONO_EMIT_NEW_LOAD_MEMBASE (cfg, vtable_reg, state->left->reg1, G_STRUCT_OFFSET (MonoObject, vtable));
 	if (method->klass->flags & TYPE_ATTRIBUTE_INTERFACE) {
 		slot_reg = mono_regstate_next_int (cfg->rs);
 		mini_emit_load_intf_reg_vtable (cfg, slot_reg, vtable_reg, method->klass);
@@ -1793,6 +1725,7 @@
 		tree->inst_offset = G_STRUCT_OFFSET (MonoVTable, vtable) + (method->slot * SIZEOF_VOID_P);
 	}
 	
+	if (novirtop != OP_VCALL)
 	tree->dreg = state->reg1;
 	tree->opcode = virtop;
 	tree->sreg1 = slot_reg;
Index: mono/mini/jit-icalls.c
===================================================================
RCS file: /mono/mono/mono/mini/jit-icalls.c,v
retrieving revision 1.11
diff -u -b -r1.11 jit-icalls.c
--- mono/mini/jit-icalls.c	8 Sep 2003 20:09:44 -0000	1.11
+++ mono/mini/jit-icalls.c	7 Nov 2003 02:22:53 -0000
@@ -80,8 +80,12 @@
 }
 
 static guint64  
-mono_llmult_ovf_un (guint32 al, guint32 ah, guint32 bl, guint32 bh)
+mono_llmult_ovf_un (guint64 a, guint64 b)
 {
+	guint32 al = (guint32) a;
+	guint32 ah = a >> 32;
+	guint32 bl = (guint32) b;
+	guint32 bh = b >> 32;
 	guint64 res, t1;
 
 	MONO_ARCH_SAVE_REGS;
@@ -109,8 +113,12 @@
 
 
 static guint64  
-mono_llmult_ovf (guint32 al, gint32 ah, guint32 bl, gint32 bh) 
+mono_llmult_ovf (gint64 a, gint64 b)
 {
+	guint32 al = (guint32) a;
+	gint32  ah = a >> 32;
+	guint32 bl = (guint32) b;
+	gint32  bh = b >> 32;
 	/*
 	Use Karatsuba algorithm where:
 		a*b is: AhBh(R^2+R)+(Ah-Al)(Bl-Bh)R+AlBl(R+1)
@@ -427,3 +435,4 @@
 	}
 	return res;
 }
+
Index: mono/mini/linear-scan.c
===================================================================
RCS file: /mono/mono/mono/mini/linear-scan.c,v
retrieving revision 1.2
diff -u -b -r1.2 linear-scan.c
--- mono/mini/linear-scan.c	21 Aug 2003 17:26:35 -0000	1.2
+++ mono/mini/linear-scan.c	7 Nov 2003 02:22:53 -0000
@@ -169,10 +169,11 @@
 		
 		if (vmv->reg >= 0)  {
 			if (gains [vmv->reg] > 3) {
-				cfg->varinfo [vmv->idx]->opcode = OP_REGVAR;
-				cfg->varinfo [vmv->idx]->dreg = vmv->reg;
+				MonoInst *var = cfg->varinfo [vmv->idx];
+				var->opcode = mono_type_to_regopcode (var->inst_vtype);
+				var->dreg = vmv->reg;
 				if (cfg->verbose_level > 2)
-					printf ("REGVAR %d C%d R%d\n", vmv->idx, vmv->spill_costs, vmv->reg);
+					printf ("%s %d C%d R%d\n", mono_inst_name (var->opcode), vmv->idx, vmv->spill_costs, vmv->reg);
 			} else {
 				used_regs &= ~(1LL << vmv->reg); 
 				vmv->reg = -1;
Index: mono/mini/mini-ops.h
===================================================================
RCS file: /mono/mono/mono/mini/mini-ops.h,v
retrieving revision 1.16
diff -u -b -r1.16 mini-ops.h
--- mono/mini/mini-ops.h	29 Oct 2003 14:56:08 -0000	1.16
+++ mono/mini/mini-ops.h	7 Nov 2003 02:22:53 -0000
@@ -10,6 +10,7 @@
 MINI_OP(OP_COMPARE_IMM,	"compare_imm")
 MINI_OP(OP_FCOMPARE,	"fcompare")
 MINI_OP(OP_LCOMPARE,	"lcompare")
+MINI_OP(OP_LCOMPARE_IMM,	"lcompare_imm")
 MINI_OP(OP_LOCAL,	"local")
 MINI_OP(OP_ARG,	"arg")
 MINI_OP(OP_ARGLIST,	"oparglist")
@@ -21,6 +22,7 @@
 MINI_OP(OP_RETARG,	"retarg")
 MINI_OP(OP_SETRET,	"setret")
 MINI_OP(OP_SETLRET,	"setlret")
+MINI_OP(OP_SETRET_VT,	"setret_vt")
 MINI_OP(OP_SETREG,	"setreg")
 MINI_OP(OP_SETREGIMM,	"setregimm")
 MINI_OP(OP_SETFREG,	"setfreg")
@@ -29,6 +31,10 @@
 MINI_OP(OP_VOIDCALLVIRT,	"voidcallvirt")
 MINI_OP(OP_VOIDCALL_REG,	"voidcall_reg")
 MINI_OP(OP_VOIDCALL_MEMBASE,	"voidcall_membase")
+MINI_OP(OP_PCALL,	"pcall")
+MINI_OP(OP_PCALLVIRT,	"pcallvirt")
+MINI_OP(OP_PCALL_REG,	"pcall_reg")
+MINI_OP(OP_PCALL_MEMBASE,	"pcall_membase")
 MINI_OP(OP_FCALL,	"fcall")
 MINI_OP(OP_FCALLVIRT,	"fcallvirt")
 MINI_OP(OP_FCALL_REG,	"fcall_reg")
@@ -49,11 +55,15 @@
 MINI_OP(OP_R4CONST,	"r4const")
 MINI_OP(OP_R8CONST,	"r8const")
 MINI_OP(OP_REGVAR,	"regvar")
+MINI_OP(OP_REGPTR,	"regptr")
+MINI_OP(OP_FREGVAR,	"fregvar")
+MINI_OP(OP_DREGVAR,	"dregvar")
 MINI_OP(OP_REG,		"reg")
 MINI_OP(OP_REGOFFSET,	"regoffset")
 MINI_OP(OP_LABEL,	"label")
 MINI_OP(OP_CHECK_ARRAY_TYPE,	"check_array_type")
 MINI_OP(OP_ARRAY_RANK,	"array_rank")
+MINI_OP(OP_ARRAY_LENGTH,	"array_length")
 MINI_OP(OP_THROW_OR_NULL,	"throw_or_null")
 
 MINI_OP(OP_STORE_MEMBASE_IMM,"store_membase_imm")
Index: mono/mini/mini-x86.c
===================================================================
RCS file: /mono/mono/mono/mini/mini-x86.c,v
retrieving revision 1.45
diff -u -b -r1.45 mini-x86.c
--- mono/mini/mini-x86.c	16 Oct 2003 19:14:31 -0000	1.45
+++ mono/mini/mini-x86.c	7 Nov 2003 02:22:56 -0000
@@ -552,14 +552,14 @@
 		case MONO_TYPE_VOID:
 			break;
 		default:
-			m->ret->opcode = OP_REGVAR;
+			m->ret->opcode = mono_type_to_regopcode (sig->ret);
 			m->ret->inst_c0 = X86_EAX;
 			break;
 		}
 	}
 	if (sig->hasthis) {
 		inst = m->varinfo [curinst];
-		if (inst->opcode != OP_REGVAR) {
+		if (!MONO_IS_REG (inst->opcode)) {
 			inst->opcode = OP_REGOFFSET;
 			inst->inst_basereg = X86_EBP;
 		}
@@ -575,7 +575,7 @@
 
 	for (i = 0; i < sig->param_count; ++i) {
 		inst = m->varinfo [curinst];
-		if (inst->opcode != OP_REGVAR) {
+		if (!MONO_IS_REG (inst->opcode)) {
 			inst->opcode = OP_REGOFFSET;
 			inst->inst_basereg = X86_EBP;
 		}
@@ -610,7 +610,7 @@
 	for (i = curinst; i < m->num_varinfo; ++i) {
 		inst = m->varinfo [i];
 
-		if ((inst->flags & MONO_INST_IS_DEAD) || inst->opcode == OP_REGVAR)
+		if ((inst->flags & MONO_INST_IS_DEAD) || MONO_IS_REG (inst->opcode))
 			continue;
 
 		/* inst->unused indicates native sized value types, this is used by the
@@ -2328,6 +2328,7 @@
 		case OP_LCALL:
 		case OP_VCALL:
 		case OP_VOIDCALL:
+		case OP_PCALL:
 		case CEE_CALL:
 			call = (MonoCallInst*)ins;
 			if (ins->flags & MONO_INST_HAS_METHOD)
@@ -2343,6 +2344,7 @@
 		case OP_LCALL_REG:
 		case OP_VCALL_REG:
 		case OP_VOIDCALL_REG:
+		case OP_PCALL_REG:
 		case OP_CALL_REG:
 			call = (MonoCallInst*)ins;
 			x86_call_reg (code, ins->sreg1);
@@ -2353,6 +2355,7 @@
 		case OP_LCALL_MEMBASE:
 		case OP_VCALL_MEMBASE:
 		case OP_VOIDCALL_MEMBASE:
+		case OP_PCALL_MEMBASE:
 		case OP_CALL_MEMBASE:
 			call = (MonoCallInst*)ins;
 			x86_call_membase (code, ins->sreg1, ins->inst_offset);
@@ -3246,7 +3249,7 @@
 
 	for (i = 0; i < sig->param_count + sig->hasthis; ++i) {
 		inst = cfg->varinfo [pos];
-		if (inst->opcode == OP_REGVAR) {
+		if (MONO_IS_REG (inst->opcode)) {
 			x86_mov_reg_membase (code, inst->dreg, X86_EBP, inst->inst_offset, 4);
 			if (cfg->verbose_level > 2)
 				g_print ("Argument %d assigned to register %s\n", pos, mono_arch_regname (inst->dreg));
Index: mono/mini/mini.c
===================================================================
RCS file: /mono/mono/mono/mini/mini.c,v
retrieving revision 1.133
diff -u -b -r1.133 mini.c
--- mono/mini/mini.c	2 Nov 2003 12:38:22 -0000	1.133
+++ mono/mini/mini.c	7 Nov 2003 02:23:10 -0000
@@ -958,6 +958,48 @@
 	return -1;
 }
 
+guint16
+mono_type_to_regopcode (MonoType *t)
+{
+	if (t->byref)
+		return OP_REGPTR;
+
+	switch (t->type) {
+	case MONO_TYPE_VALUETYPE:
+		if (t->data.klass->enumtype)
+			return mono_type_to_regopcode (
+				t->data.klass->enum_basetype);
+	case MONO_TYPE_BOOLEAN:
+	case MONO_TYPE_CHAR:
+	case MONO_TYPE_I1:
+	case MONO_TYPE_U1:
+	case MONO_TYPE_I2:
+	case MONO_TYPE_U2:
+	case MONO_TYPE_I4:
+	case MONO_TYPE_U4:
+	case MONO_TYPE_I8:
+	case MONO_TYPE_U8:
+		return OP_REGVAR;
+	case MONO_TYPE_R4:
+		return OP_REGVAR; // should be OP_FREGVAR
+	case MONO_TYPE_R8:
+		return OP_REGVAR; // should be OP_DREGVAR
+	case MONO_TYPE_I:
+	case MONO_TYPE_U:
+	case MONO_TYPE_PTR:
+	case MONO_TYPE_OBJECT:
+	case MONO_TYPE_STRING:
+	case MONO_TYPE_CLASS:
+	case MONO_TYPE_SZARRAY:
+	case MONO_TYPE_ARRAY:
+	case MONO_TYPE_TYPEDBYREF:
+	case MONO_TYPE_GENERICINST:
+		return OP_REGPTR;
+	}
+	g_assert_not_reached ();
+	return -1;
+}
+
 /*
  * Returns the type used in the eval stack when @type is loaded.
  * FIXME: return a MonoType/MonoClass for the byref and VALUETYPE cases.
@@ -1095,7 +1137,7 @@
 /* handles from CEE_ADD to CEE_SHR_UN (CEE_REM_UN for floats) */
 static const guint16
 binops_op_map [STACK_MAX] = {
-	0, 0, OP_LADD-CEE_ADD, OP_PADD-CEE_ADD, OP_FADD-CEE_ADD, 0
+	0, 0, OP_LADD-CEE_ADD, OP_PADD-CEE_ADD, OP_FADD-CEE_ADD, OP_PADD-CEE_ADD
 };
 
 /* handles from CEE_NEG to CEE_CONV_U8 */
@@ -1659,7 +1701,7 @@
 	int t = type->type;
 
 	if (type->byref)
-		return calli? OP_CALL_REG: virt? CEE_CALLVIRT: CEE_CALL;
+		return calli? OP_PCALL_REG: virt? OP_PCALLVIRT: OP_PCALL;
 
 handle_enum:
 	switch (t) {
@@ -1677,13 +1719,13 @@
 	case MONO_TYPE_I:
 	case MONO_TYPE_U:
 	case MONO_TYPE_PTR:
-		return calli? OP_CALL_REG: virt? CEE_CALLVIRT: CEE_CALL;
+		return calli? OP_PCALL_REG: virt? OP_PCALLVIRT: OP_PCALL;
 	case MONO_TYPE_CLASS:
 	case MONO_TYPE_STRING:
 	case MONO_TYPE_OBJECT:
 	case MONO_TYPE_SZARRAY:
 	case MONO_TYPE_ARRAY:    
-		return calli? OP_CALL_REG: virt? CEE_CALLVIRT: CEE_CALL;
+		return calli? OP_PCALL_REG: virt? OP_PCALLVIRT: OP_PCALL;
 	case MONO_TYPE_I8:
 	case MONO_TYPE_U8:
 		return calli? OP_LCALL_REG: virt? OP_LCALLVIRT: OP_LCALL;
@@ -1866,7 +1908,7 @@
 	if (!MONO_TYPE_IS_VOID (ret) || ret_object) {
 		if (ret_object) {
 			call->inst.type = STACK_OBJ;
-			call->inst.opcode = CEE_CALL;
+			call->inst.opcode = OP_PCALL;
 			temp = mono_compile_create_var (cfg, &mono_defaults.string_class->byval_arg, OP_LOCAL);
 		} else {
 			type_to_eval_stack_type (ret, ins);
@@ -2296,7 +2338,7 @@
 		if (strcmp (cmethod->name, "get_Rank") == 0)
 			op = OP_ARRAY_RANK;
 		else if (strcmp (cmethod->name, "get_Length") == 0)
-			op = CEE_LDLEN;
+			op = OP_ARRAY_LENGTH;
 		else
 			return NULL;
 	} else {
@@ -3861,7 +3903,7 @@
 			ins->inst_newa_class = klass;
 			ins->cil_code = ip;
 
-			MONO_INST_NEW (cfg, add, CEE_ADD);
+			MONO_INST_NEW (cfg, add, OP_PADD);
 			NEW_ICONST (cfg, vtoffset, sizeof (MonoObject));
 			add->inst_left = ins;
 			add->inst_right = vtoffset;
@@ -3916,7 +3958,7 @@
 			ins->inst_newa_class = klass;
 			ins->cil_code = ip;
 
-			MONO_INST_NEW (cfg, add, CEE_ADD);
+			MONO_INST_NEW (cfg, add, OP_PADD);
 			NEW_ICONST (cfg, vtoffset, sizeof (MonoObject));
 			add->inst_left = ins;
 			add->inst_right = vtoffset;
@@ -4019,7 +4061,7 @@
 				} else {
 					MonoInst *store;
 					NEW_ICONST (cfg, offset_ins, foffset);
-					MONO_INST_NEW (cfg, ins, CEE_ADD);
+					MONO_INST_NEW (cfg, ins, OP_PADD);
 					ins->cil_code = ip;
 					ins->inst_left = *sp;
 					ins->inst_right = offset_ins;
@@ -4089,7 +4131,7 @@
 					}
 				} else {
 					NEW_ICONST (cfg, offset_ins, foffset);
-					MONO_INST_NEW (cfg, ins, CEE_ADD);
+					MONO_INST_NEW (cfg, ins, OP_PADD);
 					ins->cil_code = ip;
 					ins->inst_left = *sp;
 					ins->inst_right = offset_ins;
@@ -4344,7 +4386,7 @@
 			}
 			NEW_TEMPLOAD (cfg, load, temp);
 			NEW_ICONST (cfg, vtoffset, sizeof (MonoObject));
-			MONO_INST_NEW (cfg, add, CEE_ADD);
+			MONO_INST_NEW (cfg, add, OP_PADD);
 			add->inst_left = load;
 			add->inst_right = vtoffset;
 			add->cil_code = ip;
@@ -5340,7 +5382,7 @@
 		MonoCallInst *call;
 		MonoInst *store;
 
-		MONO_INST_NEW_CALL (cfg, call, CEE_CALL);
+		MONO_INST_NEW_CALL (cfg, call, OP_PCALL);
 		call->signature = helper_sig_domain_get;
 		call->inst.type = STACK_PTR;
 		call->fptr = mono_domain_get;
@@ -5466,6 +5508,7 @@
 		printf ("[0x%x(%s)]", tree->inst_offset, mono_arch_regname (tree->inst_basereg));
 		break;
 	case OP_REGVAR:
+	case OP_REGPTR:
 		printf ("[%s]", mono_arch_regname (tree->dreg));
 		break;
 	case CEE_NEWARR:
@@ -5474,6 +5517,8 @@
 		break;
 	case CEE_CALL:
 	case CEE_CALLVIRT:
+	case OP_PCALL:
+	case OP_PCALLVIRT:
 	case OP_FCALL:
 	case OP_FCALLVIRT:
 	case OP_LCALL:
@@ -5512,6 +5557,7 @@
 	case CEE_CASTCLASS:
 	case OP_OUTARG:
 	case OP_CALL_REG:
+	case OP_PCALL_REG:
 	case OP_FCALL_REG:
 	case OP_LCALL_REG:
 	case OP_VCALL_REG:
@@ -6599,7 +6645,7 @@
 	MBEmitFunc emit;
 
 	//g_print ("rule: %s\n", mono_burg_rule_string [ern]);
-	switch (goal) {
+	if (!state->reg1) switch (goal) {
 	case MB_NTERM_reg:
 		//if (state->reg2)
 		//	state->reg1 = state->reg2; /* chain rule */
@@ -6607,9 +6653,14 @@
 		state->reg1 = mono_regstate_next_int (cfg->rs);
 		//g_print ("alloc symbolic R%d (reg2: R%d) in block %d\n", state->reg1, state->reg2, cfg->cbb->block_num);
 		break;
+	case MB_NTERM_regp:
+		state->reg1 = mono_regstate_next_int (cfg->rs);
+		break;
 	case MB_NTERM_lreg:
 		state->reg1 = mono_regstate_next_int (cfg->rs);
+#if SIZEOF_VOID_P == 4
 		state->reg2 = mono_regstate_next_int (cfg->rs);
+#endif /* SIZEOF_VOID_P == 4 */
 		break;
 	case MB_NTERM_freg:
 		state->reg1 = mono_regstate_next_float (cfg->rs);
@@ -6908,6 +6959,9 @@
 	case CEE_CALL:
 	case OP_CALL_REG:
 	case CEE_CALLVIRT:
+	case OP_PCALL:
+	case OP_PCALL_REG:
+	case OP_PCALLVIRT:
 	case OP_LCALL_REG:
 	case OP_LCALLVIRT:
 	case OP_LCALL:
Index: mono/mini/mini.h
===================================================================
RCS file: /mono/mono/mono/mini/mini.h,v
retrieving revision 1.40
diff -u -b -r1.40 mini.h
--- mono/mini/mini.h	31 Oct 2003 15:59:47 -0000	1.40
+++ mono/mini/mini.h	7 Nov 2003 02:23:11 -0000
@@ -546,13 +546,30 @@
 };
 #undef MINI_OP
 
+#define MONO_IS_REG(opcode) ((opcode) >= OP_REGVAR && (opcode) <= OP_DREGVAR)
+
 /* make this depend on 32bit platform (use OP_LADD otherwise) */
+#if SIZEOF_VOID_P == 4
 #define OP_PADD CEE_ADD
+#define OP_PADD_IMM OP_ADD_IMM
 #define OP_PNEG CEE_NEG
 #define OP_PCONV_TO_U2 CEE_CONV_U2
 #define OP_PCONV_TO_OVF_I1_UN CEE_CONV_OVF_I1_UN
 #define OP_PCONV_TO_OVF_I1 CEE_CONV_OVF_I1
 #define OP_PCEQ CEE_CEQ
+#define OP_PCOMPARE OP_COMPARE
+#define OP_PCOMPARE_IMM OP_COMPARE_IMM
+#else /* SIZEOF_VOID_P == 8 */
+#define OP_PADD OP_LADD
+#define OP_PADD_IMM OP_LADD_IMM
+#define OP_PNEG OP_LNEG
+#define OP_PCONV_TO_U2 OP_LCONV_TO_U2
+#define OP_PCONV_TO_OVF_I1_UN OP_LCONV_TO_OVF_I1_UN
+#define OP_PCONV_TO_OVF_I1 OP_LCONV_TO_OVF_I1
+#define OP_PCEQ OP_LCEQ
+#define OP_PCOMPARE OP_LCOMPARE
+#define OP_PCOMPARE_IMM OP_LCOMPARE_IMM
+#endif /* SIZEOF_VOID_P == 8 */
 
 typedef enum {
 	STACK_INV,
@@ -633,6 +650,7 @@
 void      mono_disassemble_code             (guint8 *code, int size, char *id);
 guint     mono_type_to_ldind                (MonoType *t);
 guint     mono_type_to_stind                (MonoType *t);
+guint16   mono_type_to_regopcode            (MonoType *t);
 void      mono_add_patch_info               (MonoCompile *cfg, int ip, MonoJumpInfoType type, gconstpointer target);
 void      mono_remove_patch_info            (MonoCompile *cfg, int ip);
 gpointer  mono_get_lmf_addr                 (void);
Index: mono/mini/ssa.c
===================================================================
RCS file: /mono/mono/mono/mini/ssa.c,v
retrieving revision 1.5
diff -u -b -r1.5 ssa.c
--- mono/mini/ssa.c	5 Oct 2003 02:52:02 -0000	1.5
+++ mono/mini/ssa.c	7 Nov 2003 02:23:12 -0000
@@ -800,12 +800,18 @@
 	if (inst->ssa_op == MONO_SSA_LOAD && 
 	    (inst->inst_i0->opcode == OP_LOCAL || inst->inst_i0->opcode == OP_ARG) &&
 	    (c0 = carray [inst->inst_i0->inst_c0])) {
+#if SIZEOF_VOID_P == 8 // FIXME_64BIT_MINI
+		if (((gssize)(int)inst->inst_c0) != inst->inst_c0) return 2;
+#endif
 		*res = c0->inst_c0;
 		return 1;
 	}
 
 	switch (inst->opcode) {
 	case OP_ICONST:
+#if SIZEOF_VOID_P == 8 // FIXME_64BIT_MINI
+		if (((gssize)(int)inst->inst_c0) != inst->inst_c0) return 2;
+#endif
 		*res = inst->inst_c0;
 		return 1;
 
