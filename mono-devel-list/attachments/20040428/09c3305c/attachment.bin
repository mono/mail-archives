Index: ChangeLog
from  Raja R Harinath  <rharinath@novell.com>
	Refactor Attribute.ApplyAttributes.
	* attribute.cs (Attributable): New base class for objects that can
	have Attributes applied on them.
	(Attribute): Make AttributeUsage fields public.
	(Attribute.UsageAttr): Convert to a public read-only property.
	(Attribute.CheckAttributeType): Use a DeclSpace, not an	EmitContext.
	(Attribute.ResolveType, Attribute.Resolve)
	(Attribute.ScanForIndexerName): Update to reflect changes.
	(Attribute.CheckAttributeTarget): Re-format.
	(Attribute.ApplyAttributes): Refactor, to various
	Attributable.ApplyAttributeBuilder methods.
	* decl.cs (MemberCore): Make Attributable.
	* class.cs (Accessor): Make Attributable.
	(TypeContainer.LabelParameters): Pass Parameter to
	ApplyAttributes.
	(TypeContainer.ApplyAttributeBuilder)
	(Method.ApplyAttributeBuilder, Constructor.ApplyAttributeBuilder)
	(Field.ApplyAttributeBuilder, Accessor.ApplyAttributeBuilder)	
	(PropertyBase.ApplyAttributeBuilder, Event.ApplyAttributeBuilder)
	(Operator.ApplyAttributeBuilder): New factored-out methods.
	(MethodData.ApplyAttributes): Use proper attribute types, not
	attribute names.
	* const.cs (Const.ApplyAttributeBuilder): New factored-out method.
	* delegate.cs (Delegate.ApplyAttributeBuilder): Likewise.
	* enum.cs (Enum.ApplyAttributeBuilder): Likewise.
	* parameter.cs (ParameterBase): New Attributable base class
	that can also represent Return types.
	(Parameter): Update to the changes.

2004-04-28  Raja R Harinath  <rharinath@novell.com>

Index: attribute.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/attribute.cs,v
retrieving revision 1.117
diff -u -u -r1.117 attribute.cs
--- attribute.cs 27 Apr 2004 19:06:37 -0000 1.117
+++ attribute.cs 28 Apr 2004 11:04:25 -0000
@@ -20,6 +20,36 @@
 
 namespace Mono.CSharp {
 
+	/// <summary>
+	///   Base class for objects that can have Attributes applied to them.
+	/// </summary>
+	public abstract class Attributable {
+		/// <summary>
+		///   Attributes for this type
+		/// </summary>
+ 		Attributes attributes;
+
+		public Attributable(Attributes attrs)
+		{
+			attributes = attrs;
+		}
+
+		public Attributes OptAttributes 
+		{
+			get {
+				return attributes;
+			}
+			set {
+				attributes = value;
+			}
+		}
+
+		/// <summary>
+		/// Use member-specific procedure to apply attribute @a in @cb to the entity being built in @builder
+		/// </summary>
+		public abstract void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb);
+	};
+
 	public class Attribute {
 		public readonly string    Name;
 		public readonly ArrayList Arguments;
@@ -32,11 +62,15 @@
 		// The following are only meaningful when the attribute
 		// being emitted is an AttributeUsage attribute
 		//
-		AttributeTargets Targets;
-		bool AllowMultiple;
-		bool Inherited;
+		public AttributeTargets Targets;
+		public bool AllowMultiple;
+		public bool Inherited;
+
+		bool usage_attr = false;
 
-		bool UsageAttr = false;
+		public bool UsageAttr {
+			get { return usage_attr; }
+		}
 		
 		MethodImplOptions ImplOptions;
 		UnmanagedType     UnmanagedType;
@@ -80,11 +114,11 @@
 		/// <summary>
                 ///   Tries to resolve the type of the attribute. Flags an error if it can't.
                 /// </summary>
-		private Type CheckAttributeType (EmitContext ec) {
-			Type t1 = RootContext.LookupType (ec.DeclSpace, Name, true, Location);
+		private Type CheckAttributeType (DeclSpace ds) {
+			Type t1 = RootContext.LookupType (ds, Name, true, Location);
 
 			// FIXME: Shouldn't do this for quoted attributes: [@A]
-			Type t2 = RootContext.LookupType (ec.DeclSpace, Name + "Attribute", true, Location);
+			Type t2 = RootContext.LookupType (ds, Name + "Attribute", true, Location);
 
 			String err0616 = null;
 
@@ -120,9 +154,10 @@
 			return null;
 		}
 
-		public Type ResolveType (EmitContext ec)
+		public Type ResolveType (DeclSpace ds)
 		{
-			Type = CheckAttributeType (ec);
+			if (Type == null)
+				Type = CheckAttributeType (ds);
 			return Type;
 		}
 
@@ -171,15 +206,14 @@
 		
 		public CustomAttributeBuilder Resolve (EmitContext ec)
 		{
-			if (Type == null)
-				Type = CheckAttributeType (ec);
+			ResolveType (ec.DeclSpace);
 			if (Type == null)
 				return null;
 
 			bool MethodImplAttr = false;
 			bool MarshalAsAttr = false;
 			bool GuidAttr = false;
-			UsageAttr = false;
+			usage_attr = false;
 
 			bool DoCompares = true;
 
@@ -189,7 +223,7 @@
                         //
                         
 			if (Type == TypeManager.attribute_usage_type)
-				UsageAttr = true;
+				usage_attr = true;
 			else if (Type == TypeManager.methodimpl_attr_type)
 				MethodImplAttr = true;
 			else if (Type == TypeManager.marshal_as_attr_type)
@@ -602,77 +636,25 @@
 				targets = attr.Targets;
 
 
-			if (element is Class) {
-				if ((targets & AttributeTargets.Class) != 0)
-					return true;
-				else
-					return false;
-				
-			} else if (element is Struct) {
-				if ((targets & AttributeTargets.Struct) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is Constructor) {
-				if ((targets & AttributeTargets.Constructor) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is Delegate) {
-				if ((targets & AttributeTargets.Delegate) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is Enum) {
-				if ((targets & AttributeTargets.Enum) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is Event) {
-				if ((targets & AttributeTargets.Event) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is Field || element is FieldBuilder) {
-				if ((targets & AttributeTargets.Field) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is Interface) {
-				if ((targets & AttributeTargets.Interface) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is Method || element is Operator ||
-                                   element is Accessor) {
-				if ((targets & AttributeTargets.Method) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is ParameterBuilder) {
-				if ((targets & AttributeTargets.Parameter) != 0 ||
-                                    (targets & AttributeTargets.ReturnValue) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is Property || element is Indexer ||
-				   element is Accessor) {
-				if ((targets & AttributeTargets.Property) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is AssemblyClass){
-				if ((targets & AttributeTargets.Assembly) != 0)
-					return true;
-				else
-					return false;
-			} else if (element is ModuleClass){
-				if ((targets & AttributeTargets.Module) != 0)
-					return true;
-				else
-					return false;
-			}
-
+			if (element is Class)		return ((targets & AttributeTargets.Class) != 0);
+			if (element is Struct)		return ((targets & AttributeTargets.Struct) != 0);
+			if (element is Constructor)	return ((targets & AttributeTargets.Constructor) != 0);
+			if (element is Delegate)	return ((targets & AttributeTargets.Delegate) != 0);
+			if (element is Enum)		return ((targets & AttributeTargets.Enum) != 0);
+			if (element is Event)		return ((targets & AttributeTargets.Event) != 0);
+			if (element is Field 
+			    || element is FieldBuilder)	return ((targets & AttributeTargets.Field) != 0);
+			if (element is Interface)	return ((targets & AttributeTargets.Interface) != 0);
+			if (element is Method
+			    || element is Operator
+			    || element is Accessor)	return ((targets & AttributeTargets.Method) != 0);
+			if (element is ParameterBase)	return ((targets & (AttributeTargets.Parameter 
+									    | AttributeTargets.ReturnValue)) != 0);
+			if (element is Property
+			    || element is Indexer
+			    || element is Accessor)	return ((targets & AttributeTargets.Property) != 0);
+			if (element is AssemblyClass)	return ((targets & AttributeTargets.Assembly) != 0);
+			if (element is ModuleClass)	return ((targets & AttributeTargets.Module) != 0);
 			return false;
 		}
 
@@ -692,7 +674,7 @@
 					continue;
 
 				foreach (Attribute a in asec.Attributes){
-					if (a.ResolveType (ec) == null)
+					if (a.ResolveType (ec.DeclSpace) == null)
 						return null;
 					
 					if (a.Type != TypeManager.indexer_name_type)
@@ -820,26 +802,26 @@
 			return (bool)pos_values [0];
 		}
 
-		static object GetFieldValue (Attribute a, string name)
+		object GetFieldValue (string name)
                 {
 			int i;
-			if (a.field_info_arr == null)
+			if (field_info_arr == null)
 				return null;
 			i = 0;
-			foreach (FieldInfo fi in a.field_info_arr) {
+			foreach (FieldInfo fi in field_info_arr) {
 				if (fi.Name == name)
-					return a.field_values_arr [i];
+					return field_values_arr [i];
 				i++;
 			}
 			return null;
 		}
 
-		static UnmanagedMarshal GetMarshal (Attribute a)
+		public UnmanagedMarshal GetMarshal ()
 		{
-			object o = GetFieldValue (a, "ArraySubType");
+			object o = GetFieldValue ("ArraySubType");
 			UnmanagedType array_sub_type = o == null ? UnmanagedType.I4 : (UnmanagedType) o;
 			
-			switch (a.UnmanagedType) {
+			switch (UnmanagedType) {
 			case UnmanagedType.CustomMarshaler:
 				MethodInfo define_custom = typeof (UnmanagedMarshal).GetMethod ("DefineCustom",
                                                                        BindingFlags.Static | BindingFlags.Public);
@@ -847,9 +829,9 @@
 					return null;
 				
 				object [] args = new object [4];
-				args [0] = GetFieldValue (a, "MarshalTypeRef");
-				args [1] = GetFieldValue (a, "MarshalCookie");
-				args [2] = GetFieldValue (a, "MarshalType");
+				args [0] = GetFieldValue ("MarshalTypeRef");
+				args [1] = GetFieldValue ("MarshalCookie");
+				args [2] = GetFieldValue ("MarshalType");
 				args [3] = Guid.Empty;
 				return (UnmanagedMarshal) define_custom.Invoke (null, args);
 				
@@ -860,16 +842,21 @@
 				return UnmanagedMarshal.DefineSafeArray (array_sub_type);
 			
 			case UnmanagedType.ByValArray:
-				return UnmanagedMarshal.DefineByValArray ((int) GetFieldValue (a, "SizeConst"));
+				return UnmanagedMarshal.DefineByValArray ((int) GetFieldValue ("SizeConst"));
 			
 			case UnmanagedType.ByValTStr:
-				return UnmanagedMarshal.DefineByValTStr ((int) GetFieldValue (a, "SizeConst"));
+				return UnmanagedMarshal.DefineByValTStr ((int) GetFieldValue ("SizeConst"));
 			
 			default:
-				return UnmanagedMarshal.DefineUnmanagedMarshal (a.UnmanagedType);
+				return UnmanagedMarshal.DefineUnmanagedMarshal (UnmanagedType);
 			}
 		}
 
+		public bool IsInternalCall
+		{
+			get { return ImplOptions == MethodImplOptions.InternalCall; }
+		}
+
 		/// <summary>
 		///   Applies the attributes specified on target 'kind' to the `builder'.
 		/// </summary>
@@ -902,12 +889,6 @@
 
 					if (cb == null) 
 						continue;
-					
-					if (!(kind is TypeContainer))
-						if (!CheckAttributeTarget (a, kind)) {
-							Error_AttributeNotValidForElement (a, loc);
-							return;
-						}
 
 					//
 					// Perform the check for duplicate attributes
@@ -919,170 +900,40 @@
 						return;
 					}
 
-					if (kind is IAttributeSupport) {
-						if (attr_type == TypeManager.methodimpl_attr_type && a.ImplOptions == MethodImplOptions.InternalCall) {
-							((MethodBuilder) builder).SetImplementationFlags (MethodImplAttributes.InternalCall | MethodImplAttributes.Runtime);
-						} 
-						else {
-							IAttributeSupport attributeSupport = kind as IAttributeSupport;
-							attributeSupport.SetCustomAttribute (cb);
-						}
+					if (!CheckAttributeTarget (a, kind)) {
+						Error_AttributeNotValidForElement (a, loc);
+						return;
 					}
-					else if (kind is Method || kind is Operator || kind is Accessor) {
-						if (attr_type == TypeManager.methodimpl_attr_type) {
-							if (a.ImplOptions == MethodImplOptions.InternalCall)
-								((MethodBuilder) builder).
-								SetImplementationFlags (
-									MethodImplAttributes.InternalCall |
-									MethodImplAttributes.Runtime);
-							else
-								((MethodBuilder) builder).SetCustomAttribute (cb);
-						} else if (attr_type != TypeManager.dllimport_type){
-							((MethodBuilder) builder).SetCustomAttribute (cb);
-						}
-					} else if (kind is Constructor) {
-						((ConstructorBuilder) builder).SetCustomAttribute (cb);
-					} else if (kind is Field) {
-						if (attr_type == TypeManager.marshal_as_attr_type) {
-							UnmanagedMarshal marshal = GetMarshal (a);
-							if (marshal == null) {
-								Report.Warning (-24, loc,
-									"The Microsoft Runtime cannot set this marshal info. " +
-									"Please use the Mono runtime instead.");
-							} else {
-								((FieldBuilder) builder).SetMarshal (marshal);
-							}
-						} else { 
-							((FieldBuilder) builder).SetCustomAttribute (cb);
-						}
-					} else if (kind is Property || kind is Indexer) {
-
-                                                if (builder is PropertyBuilder) 
-                                                        ((PropertyBuilder) builder).SetCustomAttribute (cb);
-                                                //
-                                                // This is for the case we are setting attributes on
-                                                // the get and set accessors
-                                                //
-                                                else if (builder is MethodBuilder)
-                                                        ((MethodBuilder) builder).SetCustomAttribute (cb);
-					} else if (kind is Event) {
-						((MyEventBuilder) builder).SetCustomAttribute (cb);
-					} else if (kind is ParameterBuilder) {
-
-						if (attr_type == TypeManager.marshal_as_attr_type) {
-							UnmanagedMarshal marshal = GetMarshal (a);
-							if (marshal == null) {
-								Report.Warning (-24, loc,
-									"The Microsoft Runtime cannot set this marshal info. " +
-									"Please use the Mono runtime instead.");
-							} else {
-								((ParameterBuilder) builder).SetMarshal (marshal);
-							}
-						} else { 
-
-							try {
-								((ParameterBuilder) builder).SetCustomAttribute (cb);
-							} catch (System.ArgumentException) {
-								Report.Warning (-24, loc,
-										"The Microsoft Runtime cannot set attributes \n" +
-										"on the return type of a method. Please use the \n" +
-										"Mono runtime instead.");
-							}
-
-						}
-					} else if (kind is Enum) {
-						((TypeBuilder) builder).SetCustomAttribute (cb); 
-
-					} else if (kind is TypeContainer) {
-						TypeContainer tc = (TypeContainer) kind;
-						
-						if (a.UsageAttr) {
-							tc.Targets = a.Targets;
-							tc.AllowMultiple = a.AllowMultiple;
-							tc.Inherited = a.Inherited;
-
-							TypeManager.RegisterAttributeAllowMultiple (tc.TypeBuilder,
-												    tc.AllowMultiple);
-							
-						} else if (attr_type == TypeManager.default_member_type) {
-							if (tc.Indexers != null) {
-								Report.Error (646, loc,
-								      "Cannot specify the DefaultMember attribute on" +
-								      " a type containing an indexer");
-								return;
-							}
 
-						} else {
-							if (!CheckAttributeTarget (a, kind)) {
-								Error_AttributeNotValidForElement (a, loc);
-								return;
-							}
-						}
-
-						try {
-							((TypeBuilder) builder).SetCustomAttribute (cb);
-						} catch (System.ArgumentException) {
-							Report.Warning (
-								-21, loc,
-						"The CharSet named property on StructLayout\n"+
-						"\tdoes not work correctly on Microsoft.NET\n"+
-						"\tYou might want to remove the CharSet declaration\n"+
-						"\tor compile using the Mono runtime instead of the\n"+
-						"\tMicrosoft .NET runtime");
-						}
-					} else if (kind is Delegate){
-						if (!CheckAttributeTarget (a, kind)) {
-							Error_AttributeNotValidForElement (a, loc);
-							return;
-						}
-						try {
-							((TypeBuilder) builder).SetCustomAttribute (cb);
-						} catch (System.ArgumentException) {
-							Report.Warning (
-								-21, loc,
-						"The CharSet named property on StructLayout\n"+
-						"\tdoes not work correctly on Microsoft.NET\n"+
-						"\tYou might want to remove the CharSet declaration\n"+
-						"\tor compile using the Mono runtime instead of the\n"+
-						"\tMicrosoft .NET runtime");
-						}
-					} else if (kind is Interface) {
-						Interface iface = (Interface) kind;
+					if (kind is Attributable) {
+						Attributable able = kind as Attributable;
+						able.ApplyAttributeBuilder (builder, a, cb);
+					} 
+					else if (kind is IAttributeSupport) {
+						IAttributeSupport attributeSupport = kind as IAttributeSupport;
+						attributeSupport.SetCustomAttribute (cb);
+					} 
+					else if (kind is FieldBuilder) {
+						// This is used only for enumerated constants
 
-						if ((attr_type == TypeManager.default_member_type) &&
-						    (iface.Indexers != null)) {
-							Report.Error (
-								646, loc,
-								"Cannot specify the DefaultMember attribute on" +
-								" a type containing an indexer");
-							return;
-						}
-
-						if (!CheckAttributeTarget (a, kind)) {
-							Error_AttributeNotValidForElement (a, loc);
-							return;
-						}
-
-						((TypeBuilder) builder).SetCustomAttribute (cb);
-					} else if (kind is AssemblyBuilder){
-						((AssemblyBuilder) builder).SetCustomAttribute (cb);
-					} else if (kind is ModuleBuilder) {
-						((ModuleBuilder) builder).SetCustomAttribute (cb);
-					} else if (kind is FieldBuilder) {
 						if (attr_type == TypeManager.marshal_as_attr_type) {
-							UnmanagedMarshal marshal = GetMarshal (a);
+							UnmanagedMarshal marshal = a.GetMarshal ();
 							if (marshal == null) {
 								Report.Warning (-24, loc,
 									"The Microsoft Runtime cannot set this marshal info. " +
 									"Please use the Mono runtime instead.");
 							} else {
-								((ParameterBuilder) builder).SetMarshal (marshal);
+								((FieldBuilder) builder).SetMarshal (marshal);
 							}
 						} else { 
 							((FieldBuilder) builder).SetCustomAttribute (cb);
 						}
-					} else
-						throw new Exception ("Unknown kind: " + kind);
+					} 
+					else {
+						throw new Exception ("" + loc + ": Error applying Attribute " + a.Type 
+								     + " to unknown kind " + kind);
+
+					}
 
 					//
 					// Once an attribute type has been emitted once we
@@ -1169,7 +1020,7 @@
 				return null;
 			}
 
-			Type = CheckAttributeType (ec);
+			ResolveType (ec.DeclSpace);
 			if (Type == null)
 				return null;
 			
Index: class.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/class.cs,v
retrieving revision 1.424
diff -u -u -r1.424 class.cs
--- class.cs 22 Apr 2004 15:22:32 -0000 1.424
+++ class.cs 28 Apr 2004 11:04:27 -0000
@@ -420,6 +420,41 @@
 			return AdditionResult.Success;
 		}
 
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			TypeBuilder tb = builder as TypeBuilder;
+					
+			if (a.UsageAttr) {
+				Targets = a.Targets;
+				AllowMultiple = a.AllowMultiple;
+				Inherited = a.Inherited;
+				
+				TypeManager.RegisterAttributeAllowMultiple (tb, AllowMultiple);
+			}
+
+			if (a.Type == TypeManager.default_member_type) {
+				if (Indexers != null) {
+					Report.Error (646, a.Location,
+						      "Cannot specify the DefaultMember attribute on" +
+						      " a type containing an indexer");
+					return;
+				}
+			}
+			
+			try {
+				tb.SetCustomAttribute (cb);
+			} 
+			catch (System.ArgumentException e) {
+				Report.Warning (-21, a.Location,
+						"The CharSet named property on StructLayout\n"+
+						"\tdoes not work correctly on Microsoft.NET\n"+
+						"\tYou might want to remove the CharSet declaration\n"+
+						"\tor compile using the Mono runtime instead of the\n"+
+						"\tMicrosoft .NET runtime.\n"+
+						"\tThe runtime reported the error: " + e);
+			}
+		}
+
 		public void RegisterOrder (Interface iface)
 		{
 			if (interface_order == null)
@@ -2603,7 +2638,7 @@
 					
 					Attributes attr = p [i].OptAttributes;
 					if (attr != null){
-						Attribute.ApplyAttributes (ec, pb, pb, attr);
+						Attribute.ApplyAttributes (ec, pb, p[i], attr);
 
 						if (par_attr == ParameterAttributes.Out){
 							if (attr.Contains (TypeManager.in_attribute_type))
@@ -2654,9 +2689,11 @@
 			}
 
 			if (ret_attrs != null) {
+				ParameterBase ret = new ParameterBase (ret_attrs);
+
 				try {
-				 	ret_pb = mb.DefineParameter (0, ParameterAttributes.None, "");
-					Attribute.ApplyAttributes (ec, ret_pb, ret_pb, ret_attrs);
+					ret_pb = mb.DefineParameter (0, ParameterAttributes.None, "");				
+					Attribute.ApplyAttributes (ec, ret_pb, ret, ret_attrs);
 
                                 } catch (ArgumentOutOfRangeException) {
 					Report.Warning (
@@ -2758,6 +2795,16 @@
                                 return false;
                 }
 
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			MethodBuilder mb = builder as MethodBuilder;
+
+			if (a.Type == TypeManager.methodimpl_attr_type && a.IsInternalCall)
+				mb.SetImplementationFlags (MethodImplAttributes.InternalCall | MethodImplAttributes.Runtime);
+			else if (a.Type != TypeManager.dllimport_type)
+				mb.SetCustomAttribute (cb);
+		}
+
 		//
 		// Checks our base implementation if any
 		//
@@ -3118,6 +3165,11 @@
 					(Initializer is ConstructorBaseInitializer) &&
 					(Initializer.Arguments == null);
 		}
+
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			((ConstructorBuilder) builder).SetCustomAttribute (cb);
+		}
 		
 		protected override bool CheckBase (TypeContainer container)
 		{
@@ -3436,7 +3488,7 @@
 		string obsolete = null;
 		bool obsolete_error = false;
 
-		public virtual bool ApplyAttributes (Attributes opt_attrs, bool is_method)
+		public virtual bool ApplyAttributes (Attributes opt_attrs, bool is_method, DeclSpace ds)
 		{
 			if ((opt_attrs == null) || (opt_attrs.AttributeSections == null))
 				return true;
@@ -3446,15 +3498,15 @@
 					continue;
 					
 				foreach (Attribute a in asec.Attributes) {
-					if (a.Name == "Conditional") {
+					Type attr_type = a.ResolveType (ds);
+					if (attr_type == TypeManager.conditional_attribute_type) {
 						if (!ApplyConditionalAttribute (a))
 							return false;
-					} else if (a.Name == "Obsolete") {
+					} else if (attr_type == TypeManager.obsolete_attribute_type) {
 						if (!ApplyObsoleteAttribute (a))
 							return false;
-					} else if (a.Name.IndexOf ("DllImport") != -1) {
+					} else if (attr_type == TypeManager.dllimport_type) {
 						if (!is_method) {
-							a.Type = TypeManager.dllimport_type;
 							Attribute.Error_AttributeNotValidForElement (a, method.Location);
 							return false;
 						}
@@ -3619,7 +3671,7 @@
 			string prefix;
 
 			if (method.OptAttributes != null)
-				if (!ApplyAttributes (method.OptAttributes, is_method))
+				if (!ApplyAttributes (method.OptAttributes, is_method, container))
 					return false;
 
 			if (member.IsExplicitImpl)
@@ -4410,6 +4462,23 @@
 		{
 		}
 
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			FieldBuilder fb = builder as FieldBuilder;
+
+			if (a.Type == TypeManager.marshal_as_attr_type) {
+				UnmanagedMarshal marshal = a.GetMarshal ();
+				if (marshal == null)
+					Report.Warning (-24, a.Location,
+							"The Microsoft Runtime cannot set this marshal info. " +
+							"Please use the Mono runtime instead.");
+				else
+					fb.SetMarshal (marshal);
+			}
+			else
+				fb.SetCustomAttribute (cb);
+		}
+
 		public override bool Define (TypeContainer container)
 		{
 			Type t = container.ResolveType (Type, false, Location);
@@ -4514,17 +4583,26 @@
 	//
 	// `set' and `get' accessors are represented with an Accessor.
 	// 
-	public class Accessor {
+	public class Accessor : Attributable {
 		//
 		// Null if the accessor is empty, or a Block if not
 		//
 		public Block Block;
-		public Attributes OptAttributes;
 		
 		public Accessor (Block b, Attributes attrs)
+			: base (attrs)
 		{
 			Block = b;
-			OptAttributes = attrs;
+		}
+
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			MethodBuilder mb = builder as MethodBuilder;
+
+			if (a.Type == TypeManager.methodimpl_attr_type && a.IsInternalCall)
+				mb.SetImplementationFlags (MethodImplAttributes.InternalCall | MethodImplAttributes.Runtime);
+			else if (a.Type != TypeManager.dllimport_type)
+				mb.SetCustomAttribute (cb);
 		}
 	}
 
@@ -4693,6 +4771,18 @@
 		{
 		}
 
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			if (builder is PropertyBuilder) 
+				((PropertyBuilder) builder).SetCustomAttribute (cb);
+			//
+			// This is for the case we are setting attributes on
+			// the get and set accessors
+			//
+			else if (builder is MethodBuilder)
+				((MethodBuilder) builder).SetCustomAttribute (cb);
+		}
+
 		protected override bool DoDefine (TypeContainer container)
 		{
 			if (!base.DoDefine (container))
@@ -5312,6 +5402,11 @@
 			this.ds = ds;
 		}
 
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			((MyEventBuilder) builder).SetCustomAttribute (cb);
+		}
+
 		public override bool Define (TypeContainer container)
 		{
 			EventAttributes e_attr = EventAttributes.RTSpecialName | EventAttributes.SpecialName;
@@ -5751,6 +5846,11 @@
 		{
 			return container.Name + ".operator " + OperatorType + " (" + FirstArgType + "," +
 				SecondArgType + ")";
+		}
+
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb) 
+		{
+			OperatorMethod.ApplyAttributeBuilder (builder, a, cb);
 		}
 		
 		public override bool Define (TypeContainer container)
Index: const.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/const.cs,v
retrieving revision 1.29
diff -u -u -r1.29 const.cs
--- const.cs 1 Apr 2004 18:32:01 -0000 1.29
+++ const.cs 28 Apr 2004 11:04:27 -0000
@@ -66,6 +66,11 @@
 		}
 #endif
 
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			throw new NotImplementedException ("Can't apply attributes to constants ???");
+		}
+
 		/// <summary>
 		///   Defines the constant in the @parent
 		/// </summary>
Index: decl.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/decl.cs,v
retrieving revision 1.102
diff -u -u -r1.102 decl.cs
--- decl.cs 22 Apr 2004 15:22:32 -0000 1.102
+++ decl.cs 28 Apr 2004 11:04:27 -0000
@@ -18,10 +18,10 @@
 namespace Mono.CSharp {
 
 	/// <summary>
-	///   Base representation for members.  This is only used to keep track
-	///   of Name, Location and Modifier flags.
+	///   Base representation for members.  This is used to keep track
+	///   of Name, Location and Modifier flags, and handling Attributes.
 	/// </summary>
-	public abstract class MemberCore {
+	public abstract class MemberCore : Attributable {
 		/// <summary>
 		///   Public name
 		/// </summary>
@@ -37,11 +37,6 @@
 		/// </summary>
 		public readonly Location Location;
 
-		/// <summary>
-		///   Attributes for this type
-		/// </summary>
- 		Attributes attributes;
-
 		[Flags]
 		public enum Flags {
 			Obsolete_Undetected = 1,		// Obsolete attribute has not beed detected yet
@@ -57,10 +52,10 @@
 		protected Flags caching_flags;
 
 		public MemberCore (string name, Attributes attrs, Location loc)
+			: base (attrs)
 		{
 			Name = name;
 			Location = loc;
-			attributes = attrs;
 			caching_flags = Flags.Obsolete_Undetected | Flags.ClsCompliance_Undetected;
 		}
 
@@ -72,16 +67,6 @@
 		public virtual string GetSignatureForError ()
 		{
 			return Name;
-		}
-
-		public Attributes OptAttributes 
-		{
-			get {
-				return attributes;
-			}
-			set {
-				attributes = value;
-			}
 		}
 
 		/// <summary>
Index: delegate.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/delegate.cs,v
retrieving revision 1.98
diff -u -u -r1.98 delegate.cs
--- delegate.cs 21 Apr 2004 07:37:12 -0000 1.98
+++ delegate.cs 28 Apr 2004 11:04:27 -0000
@@ -55,7 +55,23 @@
 			ModFlags        = Modifiers.Check (AllowedModifiers, mod_flags,
 							   IsTopLevel ? Modifiers.INTERNAL :
 							   Modifiers.PRIVATE, l);
-			Parameters      = param_list;		}
+			Parameters      = param_list;
+		}
+
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			try {
+				((TypeBuilder) builder).SetCustomAttribute (cb);
+			} catch (System.ArgumentException e) {
+				Report.Warning (-21, a.Location,
+						"The CharSet named property on StructLayout\n"+
+						"\tdoes not work correctly on Microsoft.NET\n"+
+						"\tYou might want to remove the CharSet declaration\n"+
+						"\tor compile using the Mono runtime instead of the\n"+
+						"\tMicrosoft .NET runtime\n"+
+						"\tThe runtime gave the error: " + e);
+			}
+		}
 
 		public override TypeBuilder DefineType ()
 		{
@@ -211,7 +227,7 @@
 					pb = InvokeBuilder.DefineParameter (i+1, p.Attributes, p.Name);
 					cattr = p.OptAttributes;
 					if (cattr != null)
-						Attribute.ApplyAttributes (ec, pb, pb, cattr);
+						Attribute.ApplyAttributes (ec, pb, p, cattr);
 
 					if ((p.ModFlags & Parameter.Modifier.ISBYREF) != 0)
 						out_params++;
@@ -224,7 +240,7 @@
 					i+1, p.Attributes, p.Name);
 				cattr = p.OptAttributes;
 				if (cattr != null)
-					Attribute.ApplyAttributes (ec, pb, pb, cattr);
+					Attribute.ApplyAttributes (ec, pb, p, cattr);
 			}
 			
 			InvokeBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
@@ -264,7 +280,7 @@
 					pb = BeginInvokeBuilder.DefineParameter (i+1, p.Attributes, p.Name);
 					cattr = p.OptAttributes;
 					if (cattr != null)
-						Attribute.ApplyAttributes (ec, pb, pb, cattr);
+						Attribute.ApplyAttributes (ec, pb, p, cattr);
 				}
 			}
 			if (Parameters.ArrayParameter != null){
@@ -273,7 +289,7 @@
 				pb = BeginInvokeBuilder.DefineParameter (i+1, p.Attributes, p.Name);
 				cattr = p.OptAttributes;
 				if (cattr != null)
-					Attribute.ApplyAttributes (ec, pb, pb, cattr);
+					Attribute.ApplyAttributes (ec, pb, p, cattr);
 				i++;
 			}
 
Index: enum.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/enum.cs,v
retrieving revision 1.80
diff -u -u -r1.80 enum.cs
--- enum.cs 15 Apr 2004 14:07:59 -0000 1.80
+++ enum.cs 28 Apr 2004 11:04:27 -0000
@@ -91,6 +91,11 @@
 			return AdditionResult.Success;
 		}
 
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			((TypeBuilder) builder).SetCustomAttribute (cb);
+		}
+
 		//
 		// This is used by corlib compilation: we map from our
 		// type to a type that is consumable by the DefineField
Index: parameter.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/parameter.cs,v
retrieving revision 1.49
diff -u -u -r1.49 parameter.cs
--- parameter.cs 7 Apr 2004 05:36:16 -0000 1.49
+++ parameter.cs 28 Apr 2004 11:04:27 -0000
@@ -16,11 +16,46 @@
 
 namespace Mono.CSharp {
 
+	/// <summary>
+	///   Base class for parameters of a method.  Can also be
+	///   used to directly represent the return type of a method
+	/// </summary>
+	public class ParameterBase : Attributable {
+		public ParameterBase (Attributes attrs)
+			: base (attrs)
+		{
+		}
+
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			ParameterBuilder pb = builder as ParameterBuilder;
+
+			if (a.Type == TypeManager.marshal_as_attr_type) {
+				UnmanagedMarshal marshal = a.GetMarshal ();
+				if (marshal == null)
+					Report.Warning (-24, a.Location,
+							"The Microsoft Runtime cannot set this marshal info. " +
+							"Please use the Mono runtime instead.");
+				else 
+					pb.SetMarshal (marshal);
+			}
+			else { 
+				try {
+					pb.SetCustomAttribute (cb);
+				} catch (System.ArgumentException) {
+					Report.Warning (-24, a.Location,
+							"The Microsoft Runtime cannot set attributes \n" +
+							"on the return type of a method. Please use the \n" +
+							"Mono runtime instead.");
+				}
+			}
+		}
+	}
 
 	/// <summary>
 	///   Represents a single method parameter
 	/// </summary>
-	public class Parameter {
+	public class Parameter : ParameterBase {
 		[Flags]
 		public enum Modifier : byte {
 			NONE    = 0,
@@ -33,16 +68,15 @@
 
 		public readonly Expression TypeName;
 		public readonly Modifier ModFlags;
-		public Attributes OptAttributes;
 		public readonly string Name;
 		Type parameter_type;
 		
 		public Parameter (Expression type, string name, Modifier mod, Attributes attrs)
+			: base (attrs)
 		{
 			Name = name;
 			ModFlags = mod;
 			TypeName = type;
-			OptAttributes = attrs;
 		}
 
 		// <summary>
