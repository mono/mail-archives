Index: Test/System.Diagnostics/EventLogTest.cs
===================================================================
--- Test/System.Diagnostics/EventLogTest.cs	(revision 0)
+++ Test/System.Diagnostics/EventLogTest.cs	(revision 0)
@@ -0,0 +1,732 @@
+//
+// EventLogTest.cs -
+// NUnit Test Cases for System.Diagnostics.EventLog
+//
+// Author:
+//	Gert Driesen <driesen@users.sourceforge.net>
+//
+// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
+//
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Diagnostics;
+
+using Microsoft.Win32;
+
+using NUnit.Framework;
+
+namespace MonoTests.System.Diagnostics
+{
+	[TestFixture]
+	public class EventLogTest
+	{
+		[Test]
+		public void Constructor1 ()
+		{
+			EventLog eventLog = new EventLog ();
+			Assert.IsFalse (eventLog.EnableRaisingEvents, "#1");
+			Assert.IsNotNull (eventLog.Entries, "#2");
+			try {
+				eventLog.Entries.GetEnumerator ().MoveNext ();
+				Assert.Fail ("#3a");
+			} catch (ArgumentException ex) {
+				// Log property is not set (zero-length string)
+				Assert.AreEqual (typeof (ArgumentException), ex.GetType (), "#3b");
+				Assert.IsNotNull (ex.Message, "#3c");
+				Assert.IsNull (ex.InnerException, "#3d");
+			}
+			Assert.IsNotNull (eventLog.Log, "#4");
+			Assert.AreEqual (string.Empty, eventLog.Log, "#5");
+#if NET_2_0
+			try {
+				string displayName = eventLog.LogDisplayName;
+				Assert.Fail ("#6a: " + displayName);
+			} catch (InvalidOperationException ex) {
+				// Event log names must consist of printable characters and
+				// cannot contain \, *, ?, or spaces
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#6b");
+				Assert.IsNotNull (ex.Message, "#6c");
+				Assert.IsNull (ex.InnerException, "#6d");
+			}
+#else
+			Assert.IsNotNull (eventLog.LogDisplayName, "#6a");
+			Assert.AreEqual (string.Empty, eventLog.LogDisplayName, "#6b");
+#endif
+			Assert.IsNotNull (eventLog.MachineName, "#7");
+			Assert.AreEqual (".", eventLog.MachineName, "#8");
+			Assert.IsNotNull (eventLog.Source, "#9");
+			Assert.AreEqual (string.Empty, eventLog.Source, "#10");
+			eventLog.Close ();
+		}
+
+		[Test]
+		public void Constructor2 ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			EventLog.CreateEventSource ("monotempsource", "monotemplog", ".");
+			try {
+				EventLog eventLog = new EventLog ("monotemplog");
+				Assert.IsFalse (eventLog.EnableRaisingEvents, "#B1");
+				Assert.IsNotNull (eventLog.Entries, "#B2");
+				// MSBUG: Assert.AreEqual (0, eventLog.Entries.Count, "#B3");
+				Assert.IsNotNull (eventLog.Log, "#B4");
+				Assert.AreEqual ("monotemplog", eventLog.Log, "#B5");
+				Assert.AreEqual ("monotemplog", eventLog.LogDisplayName, "#B6");
+				Assert.IsNotNull (eventLog.MachineName, "#B7");
+				Assert.AreEqual (".", eventLog.MachineName, "#B8");
+				Assert.IsNotNull (eventLog.Source, "#B9");
+				Assert.AreEqual (string.Empty, eventLog.Source, "#B10");
+				eventLog.Close ();
+			} finally {
+				EventLog.Delete ("monotemplog");
+			}
+		}
+
+		[Test]
+		public void Constructor2_Log_Empty ()
+		{
+			EventLog eventLog = new EventLog (string.Empty);
+			Assert.IsFalse (eventLog.EnableRaisingEvents, "#A1");
+			Assert.IsNotNull (eventLog.Entries, "#A2");
+			try {
+				eventLog.Entries.GetEnumerator ().MoveNext ();
+				Assert.Fail ("#A3a");
+			} catch (ArgumentException ex) {
+				// Log property is not set (zero-length string)
+				Assert.AreEqual (typeof (ArgumentException), ex.GetType (), "#A3b");
+				Assert.IsNotNull (ex.Message, "#A3c");
+				Assert.IsNull (ex.InnerException, "#A3d");
+			}
+			Assert.IsNotNull (eventLog.Log, "#A4");
+			Assert.AreEqual (string.Empty, eventLog.Log, "#A5");
+#if NET_2_0
+			try {
+				string displayName = eventLog.LogDisplayName;
+				Assert.Fail ("#A6a: " + displayName);
+			} catch (InvalidOperationException ex) {
+				// Event log names must consist of printable characters and
+				// cannot contain \, *, ?, or spaces
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#A6b");
+				Assert.IsNotNull (ex.Message, "#A6c");
+				Assert.IsNull (ex.InnerException, "#A6d");
+			}
+#else
+			Assert.IsNotNull (eventLog.LogDisplayName, "#A6a");
+			Assert.AreEqual (string.Empty, eventLog.LogDisplayName, "#A6b");
+#endif
+			Assert.IsNotNull (eventLog.MachineName, "#A7");
+			Assert.AreEqual (".", eventLog.MachineName, "#A8");
+			Assert.IsNotNull (eventLog.Source, "#A9");
+			Assert.AreEqual (string.Empty, eventLog.Source, "#A10");
+			eventLog.Close ();
+		}
+
+		[Test]
+		public void Constructor2_Log_DoesNotExist ()
+		{
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			EventLog eventLog = new EventLog ("monotemplog");
+			Assert.IsFalse (eventLog.EnableRaisingEvents, "#B1");
+			Assert.IsNotNull (eventLog.Entries, "#B2");
+			try {
+				eventLog.Entries.GetEnumerator ().MoveNext ();
+				Assert.Fail ("#B3a");
+			} catch (InvalidOperationException ex) {
+				// The event log 'monotemplog' on computer '.' does not exist
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#B3b");
+				Assert.IsNotNull (ex.Message, "#B3c");
+				Assert.IsTrue (ex.Message.IndexOf ("'monotemplog'") != -1, "#B3d");
+				Assert.IsTrue (ex.Message.IndexOf ("'.'") != -1, "#B3e");
+				Assert.IsNull (ex.InnerException, "#B3f");
+			}
+			Assert.IsNotNull (eventLog.Log, "#B4");
+			Assert.AreEqual ("monotemplog", eventLog.Log, "#B5");
+			try {
+				string displayName = eventLog.LogDisplayName;
+				Assert.Fail ("#B6a: " + displayName);
+			} catch (InvalidOperationException ex) {
+				// Cannot find Log monotemplog on computer .
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#B6b");
+				Assert.IsNotNull (ex.Message, "#B6c");
+				Assert.IsTrue (ex.Message.IndexOf ("monotemplog") != -1, "#B6d");
+				Assert.IsTrue (ex.Message.IndexOf (".") != -1, "#B6e");
+				Assert.IsNull (ex.InnerException, "#B6f");
+			}
+			Assert.IsNotNull (eventLog.MachineName, "#B7");
+			Assert.AreEqual (".", eventLog.MachineName, "#B8");
+			Assert.IsNotNull (eventLog.Source, "#B9");
+			Assert.AreEqual (string.Empty, eventLog.Source, "#B10");
+			eventLog.Close ();
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void Constructor2_Log_Null ()
+		{
+			new EventLog (null);
+		}
+
+		[Test]
+		public void Constructor3 ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			EventLog.CreateEventSource ("monotempsource", "monotemplog", ".");
+			try {
+				EventLog eventLog = new EventLog ("monotemplog", ".");
+				Assert.IsFalse (eventLog.EnableRaisingEvents, "#B1");
+				Assert.IsNotNull (eventLog.Entries, "#B2");
+				// MSBUG: Assert.AreEqual (0, eventLog.Entries.Count, "#B3");
+				Assert.IsNotNull (eventLog.Log, "#B4");
+				Assert.AreEqual ("monotemplog", eventLog.Log, "#B5");
+				Assert.AreEqual ("monotemplog", eventLog.LogDisplayName, "#B6");
+				Assert.IsNotNull (eventLog.MachineName, "#B7");
+				Assert.AreEqual (".", eventLog.MachineName, "#B8");
+				Assert.IsNotNull (eventLog.Source, "#B9");
+				Assert.AreEqual (string.Empty, eventLog.Source, "#B10");
+				eventLog.Close ();
+			} finally {
+				EventLog.Delete ("monotemplog");
+			}
+		}
+
+		[Test]
+		public void Constructor3_Log_Empty ()
+		{
+			EventLog eventLog = new EventLog (string.Empty, ".");
+			Assert.IsFalse (eventLog.EnableRaisingEvents, "#A1");
+			Assert.IsNotNull (eventLog.Entries, "#A2");
+			try {
+				eventLog.Entries.GetEnumerator ().MoveNext ();
+				Assert.Fail ("#A3a");
+			} catch (ArgumentException ex) {
+				// Log property is not set (zero-length string)
+				Assert.AreEqual (typeof (ArgumentException), ex.GetType (), "#A3b");
+				Assert.IsNotNull (ex.Message, "#A3c");
+				Assert.IsNull (ex.InnerException, "#A3d");
+			}
+			Assert.IsNotNull (eventLog.Log, "#A4");
+			Assert.AreEqual (string.Empty, eventLog.Log, "#A5");
+#if NET_2_0
+			try {
+				string displayName = eventLog.LogDisplayName;
+				Assert.Fail ("#A6a: " + displayName);
+			} catch (InvalidOperationException ex) {
+				// Event log names must consist of printable characters and
+				// cannot contain \, *, ?, or spaces
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#A6b");
+				Assert.IsNotNull (ex.Message, "#A6c");
+				Assert.IsNull (ex.InnerException, "#A6d");
+			}
+#else
+			Assert.IsNotNull (eventLog.LogDisplayName, "#A6a");
+			Assert.AreEqual (string.Empty, eventLog.LogDisplayName, "#A6b");
+#endif
+			Assert.IsNotNull (eventLog.MachineName, "#A7");
+			Assert.AreEqual (".", eventLog.MachineName, "#A8");
+			Assert.IsNotNull (eventLog.Source, "#A9");
+			Assert.AreEqual (string.Empty, eventLog.Source, "#A10");
+			eventLog.Close ();
+		}
+
+		[Test]
+		public void Constructor3_Log_DoesNotExist ()
+		{
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			EventLog eventLog = new EventLog ("monotemplog", ".");
+			Assert.IsFalse (eventLog.EnableRaisingEvents, "#B1");
+			Assert.IsNotNull (eventLog.Entries, "#B2");
+			try {
+				eventLog.Entries.GetEnumerator ().MoveNext ();
+				Assert.Fail ("#B3a");
+			} catch (InvalidOperationException ex) {
+				// The event log 'monotemplog' on computer '.' does not exist
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#B3b");
+				Assert.IsNotNull (ex.Message, "#B3c");
+				Assert.IsTrue (ex.Message.IndexOf ("'monotemplog'") != -1, "#B3d");
+				Assert.IsTrue (ex.Message.IndexOf ("'.'") != -1, "#B3e");
+				Assert.IsNull (ex.InnerException, "#B3f");
+			}
+			Assert.IsNotNull (eventLog.Log, "#B4");
+			Assert.AreEqual ("monotemplog", eventLog.Log, "#B5");
+			try {
+				string displayName = eventLog.LogDisplayName;
+				Assert.Fail ("#B6a: " + displayName);
+			} catch (InvalidOperationException ex) {
+				// Cannot find Log monotemplog on computer .
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#B6b");
+				Assert.IsNotNull (ex.Message, "#B6c");
+				Assert.IsTrue (ex.Message.IndexOf ("monotemplog") != -1, "#B6d");
+				Assert.IsTrue (ex.Message.IndexOf (".") != -1, "#B6e");
+				Assert.IsNull (ex.InnerException, "#B6f");
+			}
+			Assert.IsNotNull (eventLog.MachineName, "#B7");
+			Assert.AreEqual (".", eventLog.MachineName, "#B8");
+			Assert.IsNotNull (eventLog.Source, "#B9");
+			Assert.AreEqual (string.Empty, eventLog.Source, "#B10");
+			eventLog.Close ();
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void Constructor3_Log_Null ()
+		{
+			new EventLog (null, ".");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Invalid value '' for parameter 'machineName'
+		public void Constructor3_MachineName_Empty ()
+		{
+			new EventLog ("monotemplog", string.Empty);
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Invalid value '' for parameter 'machineName'
+		public void Constructor3_MachineName_Null ()
+		{
+			new EventLog ("monotemplog", null);
+		}
+
+		// TODO: ctor4 : (logName, machineName, source)
+
+		[Test]
+		public void CreateEventSource1 ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			try {
+				EventLog.CreateEventSource ("monotempsource", "monotemplog");
+				Assert.IsTrue (EventLog.Exists ("monotemplog", "."), "#A1");
+				Assert.IsTrue (EventLog.SourceExists ("monotempsource", "."), "#A2");
+
+				using (EventLog eventLog = new EventLog ("monotemplog", ".", "monotempsource")) {
+					Assert.IsFalse (eventLog.EnableRaisingEvents, "#B1");
+					Assert.IsNotNull (eventLog.Entries, "#B2");
+					// MSBUG: Assert.AreEqual (0, eventLog.Entries.Count, "#B3");
+					Assert.IsNotNull (eventLog.Log, "#B4");
+					Assert.AreEqual ("monotemplog", eventLog.Log, "#B5");
+					Assert.IsNotNull (eventLog.LogDisplayName, "#B6");
+					Assert.AreEqual ("monotemplog", eventLog.LogDisplayName, "#B7");
+					Assert.IsNotNull (eventLog.MachineName, "#B8");
+					Assert.AreEqual (".", eventLog.MachineName, "#B9");
+					Assert.IsNotNull (eventLog.Source, "#B10");
+					Assert.AreEqual ("monotempsource", eventLog.Source, "#B11");
+				}
+			} finally {
+				if (EventLog.Exists ("monotemplog", "."))
+					EventLog.Delete ("monotemplog", ".");
+			}
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Must specify value for source
+		public void CreateEventSource1_Source_Null ()
+		{
+			EventLog.CreateEventSource (null, "monotemplog");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Must specify value for source
+		public void CreateEventSource1_Source_Empty ()
+		{
+			EventLog.CreateEventSource (string.Empty, "monotemplog");
+		}
+
+		[Test]
+		public void CreateEventSource1_Log_Null ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			bool logExists = EventLog.Exists ("Application", ".");
+			try {
+				EventLog.CreateEventSource ("monotempsource", null);
+				string logName = EventLog.LogNameFromSourceName ("monotempsource", ".");
+				Assert.IsNotNull (logName, "#1");
+				Assert.AreEqual ("application", logName.ToLower (), "#2");
+			} finally {
+				if (!logExists) {
+					if (EventLog.Exists ("Application"))
+						EventLog.Delete ("Application");
+				} else {
+					if (EventLog.SourceExists ("monotempsource", "."))
+						EventLog.DeleteEventSource ("monotempsource", ".");
+				}
+			}
+		}
+
+		[Test]
+		public void CreateEventSource1_Log_Empty ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			bool logExists = EventLog.Exists ("Application", ".");
+			try {
+				EventLog.CreateEventSource ("monotempsource", string.Empty);
+				string logName = EventLog.LogNameFromSourceName ("monotempsource", ".");
+				Assert.IsNotNull (logName, "#1");
+				Assert.AreEqual ("application", logName.ToLower (), "#2");
+			} finally {
+				if (!logExists) {
+					if (EventLog.Exists ("Application", "."))
+						EventLog.Delete ("Application", ".");
+				} else {
+					if (EventLog.SourceExists ("monotempsource", "."))
+						EventLog.DeleteEventSource ("monotempsource", ".");
+				}
+			}
+		}
+
+		[Test]
+		public void Delete1 ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			EventLog.CreateEventSource ("monotempsource", "monotemplog", ".");
+			Assert.IsTrue (EventLog.Exists ("monotemplog", "."), "#1");
+			EventLog.Delete ("monotemplog");
+			Assert.IsFalse (EventLog.Exists ("monotemplog", "."), "#2");
+			Assert.IsFalse (EventLog.Exists ("monotempsource", "."), "#3");
+		}
+
+		[Test]
+		public void Delete1_Log_DoesNotExist ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			try {
+				EventLog.Delete ("monotemplog");
+				Assert.Fail ("#1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.Message, "#3");
+				Assert.IsTrue (ex.Message.IndexOf ("monotemplog") != -1, "#4");
+				Assert.IsTrue (ex.Message.IndexOf (".") != -1, "#5");
+				Assert.IsNull (ex.InnerException, "#6");
+			}
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Log to delete was not specified
+		public void Delete1_Log_Empty ()
+		{
+			EventLog.Delete (string.Empty);
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Log to delete was not specified
+		public void Delete1_Log_Null ()
+		{
+			EventLog.Delete (null);
+		}
+
+		[Test]
+		public void Delete2 ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			EventLog.CreateEventSource ("monotempsource", "monotemplog", ".");
+			Assert.IsTrue (EventLog.Exists ("monotemplog", "."), "#1");
+			EventLog.Delete ("monotemplog", ".");
+			Assert.IsFalse (EventLog.Exists ("monotemplog", "."), "#2");
+			Assert.IsFalse (EventLog.Exists ("monotempsource", "."), "#3");
+		}
+
+		[Test]
+		public void Delete2_Log_DoesNotExist ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			try {
+				EventLog.Delete ("monotemplog", ".");
+				Assert.Fail ("#1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.Message, "#3");
+				Assert.IsTrue (ex.Message.IndexOf ("monotemplog") != -1, "#4");
+				Assert.IsTrue (ex.Message.IndexOf (".") != -1, "#5");
+				Assert.IsNull (ex.InnerException, "#6");
+			}
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Log to delete was not specified
+		public void Delete2_Log_Empty ()
+		{
+			EventLog.Delete (string.Empty, ".");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Log to delete was not specified
+		public void Delete2_Log_Null ()
+		{
+			EventLog.Delete (null, ".");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Invalid format for argument machineName
+		public void Delete2_MachineName_Empty ()
+		{
+			EventLog.Delete ("monotemplog", string.Empty);
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Invalid format for argument machineName
+		public void Delete2_MachineName_Null ()
+		{
+			EventLog.Delete ("monotemplog", null);
+		}
+
+		[Test]
+		public void DeleteEventSource1 ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			bool monotemplogExists = EventLog.Exists ("monotemplog", ".");
+			try {
+				EventLog.CreateEventSource ("monotempsource", "monotemplog", ".");
+				Assert.IsTrue (EventLog.SourceExists ("monotempsource", "."), "#1");
+				EventLog.DeleteEventSource ("monotempsource");
+				Assert.IsFalse (EventLog.SourceExists ("monotempsource", "."), "#2");
+			} finally {
+				if (!monotemplogExists) {
+					EventLog.Delete ("monotemplog");
+				}
+			}
+		}
+
+		[Test]
+		public void DeleteEventSource1_Source_DoesNotExist ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			try {
+				EventLog.DeleteEventSource ("monotempsource");
+				Assert.Fail ("#1");
+			} catch (ArgumentException ex) {
+				Assert.AreEqual (typeof (ArgumentException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.Message, "#3");
+				Assert.IsTrue (ex.Message.IndexOf ("'monotempsource'") != -1, "#4");
+				Assert.IsTrue (ex.Message.IndexOf ("'.'") != -1, "#5");
+				Assert.IsNull (ex.InnerException, "#6");
+			}
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // The source '' is not registered on machine '.', ...
+		public void DeleteEventSource1_Source_Empty ()
+		{
+			EventLog.DeleteEventSource (string.Empty);
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // The source '' is not registered on machine '.', ...
+		public void DeleteEventSource1_Source_Null ()
+		{
+			EventLog.DeleteEventSource (null);
+		}
+
+		[Test]
+		public void DeleteEventSource2 ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			bool monotemplogExists = EventLog.Exists ("monotemplog", ".");
+			try {
+				EventLog.CreateEventSource ("monotempsource", "monotemplog");
+				Assert.IsTrue (EventLog.SourceExists ("monotempsource"), "#1");
+				EventLog.DeleteEventSource ("monotempsource", ".");
+				Assert.IsFalse (EventLog.SourceExists ("monotempsource"), "#2");
+			} finally {
+				if (!monotemplogExists) {
+					EventLog.Delete ("monotemplog");
+				}
+			}
+		}
+
+		[Test]
+		public void DeleteEventSource2_Source_DoesNotExist ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			try {
+				EventLog.DeleteEventSource ("monotempsource", ".");
+				Assert.Fail ("#1");
+			} catch (ArgumentException ex) {
+				Assert.AreEqual (typeof (ArgumentException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.Message, "#3");
+				Assert.IsTrue (ex.Message.IndexOf ("'monotempsource'") != -1, "#4");
+				Assert.IsTrue (ex.Message.IndexOf ("'.'") != -1, "#5");
+				Assert.IsNull (ex.InnerException, "#6");
+			}
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // The source '' is not registered on machine '.', ...
+		public void DeleteEventSource2_Source_Empty ()
+		{
+			EventLog.DeleteEventSource (string.Empty, ".");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // The source '' is not registered on machine '.', ...
+		public void DeleteEventSource2_Source_Null ()
+		{
+			EventLog.DeleteEventSource (null, ".");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Invalid value '' for parameter 'machineName'
+		public void DeleteEventSource2_MachineName_Empty ()
+		{
+			EventLog.DeleteEventSource ("monotempsource", string.Empty);
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Invalid value '' for parameter 'machineName'
+		public void DeleteEventSource2_MachineName_Null ()
+		{
+			EventLog.DeleteEventSource ("monotempsource", null);
+		}
+
+		[Test]
+		public void Log ()
+		{
+			EventLog eventLog = new EventLog ();
+			eventLog.Log = string.Empty;
+			Assert.AreEqual (string.Empty, eventLog.Log, "#1");
+			Assert.AreEqual (string.Empty, eventLog.Source, "#2");
+			eventLog.Log = "monotemplog";
+			Assert.AreEqual ("monotemplog", eventLog.Log, "#3");
+			Assert.AreEqual (string.Empty, eventLog.Source, "#4");
+			eventLog.Log = string.Empty;
+			Assert.AreEqual (string.Empty, eventLog.Log, "#5");
+			Assert.AreEqual (string.Empty, eventLog.Source, "#6");
+			eventLog.Close ();
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void Log_Null ()
+		{
+			EventLog eventLog = new EventLog ();
+			eventLog.Log = null;
+		}
+
+		[Test]
+		public void Source ()
+		{
+			EventLog eventLog = new EventLog ();
+			eventLog.Source = null;
+			Assert.AreEqual (string.Empty, eventLog.Source, "#1");
+			Assert.AreEqual (string.Empty, eventLog.Log, "#2");
+			eventLog.Source = "monotempsource";
+			Assert.AreEqual ("monotempsource", eventLog.Source, "#3");
+			Assert.AreEqual (string.Empty, eventLog.Log, "#4");
+			eventLog.Source = null;
+			Assert.AreEqual (string.Empty, eventLog.Source, "#5");
+			Assert.AreEqual (string.Empty, eventLog.Log, "#6");
+			eventLog.Close ();
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException))] // Source property was not set before writing to the event log
+		public void WriteEntry1_Source_Empty ()
+		{
+			EventLog eventLog = new EventLog ("monotemplog");
+			eventLog.WriteEntry ("test");
+		}
+
+		[Test]
+		public void WriteEntry1_Log_Empty ()
+		{
+			if (EventLog.SourceExists ("monotempsource", "."))
+				Assert.Ignore ("Event log source 'monotempsource' should not exist.");
+
+			if (EventLog.Exists ("monotemplog", "."))
+				Assert.Ignore ("Event log 'monotemplog' should not exist.");
+
+			bool applicationLogExists = EventLog.Exists ("Application");
+
+			// specified source does not exist, so use Application log
+			try {
+				using (EventLog eventLog = new EventLog (string.Empty, ".", "monotempsource")) {
+					eventLog.WriteEntry ("test");
+					// MSBUG: Assert.AreEqual (1, eventLog.Entries.Count, "#1");
+					Assert.AreEqual ("application", eventLog.Log.ToLower (), "#2"); // unix registry API performs ToLower of keys
+					Assert.AreEqual ("monotempsource", eventLog.Source, "#3");
+					Assert.IsTrue (EventLog.Exists ("Application"), "#4");
+					Assert.IsTrue (EventLog.SourceExists ("monotempsource"), "#5");
+					Assert.AreEqual ("application", EventLog.LogNameFromSourceName ("monotempsource", ".").ToLower (), "#6"); // unix registry API performs ToLower of keys
+				}
+			} finally {
+				if (!applicationLogExists) {
+					if (EventLog.Exists ("Application"))
+						EventLog.Delete ("Application");
+				} else {
+					if (EventLog.SourceExists ("monotempsource", "."))
+						EventLog.DeleteEventSource ("monotempsource", ".");
+				}
+			}
+		}
+	}
+}

Property changes on: Test/System.Diagnostics/EventLogTest.cs
___________________________________________________________________
Name: svn:executable
   + *

Index: System.dll.sources
===================================================================
--- System.dll.sources	(revision 63523)
+++ System.dll.sources	(working copy)
@@ -482,6 +482,7 @@
 System.Diagnostics/TraceListenerCollection.cs
 System.Diagnostics/TraceListener.cs
 System.Diagnostics/TraceSwitch.cs
+System.Diagnostics/Win32EventLog.cs
 System/FileStyleUriParser.cs
 System/FtpStyleUriParser.cs
 System/GenericUriParser.cs
Index: System.Diagnostics/EventSourceCreationData.cs
===================================================================
--- System.Diagnostics/EventSourceCreationData.cs	(revision 63530)
+++ System.Diagnostics/EventSourceCreationData.cs	(working copy)
@@ -1,12 +1,11 @@
 //
 // System.Diagnostics.EventSourceCreationData
 //
-// Authors:
-//	Gert Driesen (drieseng@users.sourceforge.net)
+// Author:
+//	Gert Driesen <driesen@users.sourceforge.net>
 //
-// (C) 2006 Novell
+// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
 //
-//
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
 // "Software"), to deal in the Software without restriction, including
@@ -52,7 +51,11 @@
 		internal EventSourceCreationData (string source, string logName, string machineName)
 		{
 			_source = source;
-			_logName = logName;
+			if (logName == null || logName.Length == 0) {
+				_logName = "Application";
+			} else {
+				_logName = logName;
+			}
 			_machineName = machineName;
 		}
 
Index: System.Diagnostics/EventLogImpl.cs
===================================================================
--- System.Diagnostics/EventLogImpl.cs	(revision 63521)
+++ System.Diagnostics/EventLogImpl.cs	(working copy)
@@ -6,7 +6,6 @@
 //
 // (C) 2003 Andreas Nahr
 //
-
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -29,92 +28,170 @@
 //
 
 using System;
-using System.Diagnostics;
 using System.ComponentModel;
 using System.ComponentModel.Design;
+using System.Diagnostics;
+using System.Globalization;
 
 namespace System.Diagnostics
 {
+	internal abstract class EventLogImpl
+	{
+		readonly EventLog _coreEventLog;
 
-// FIXME set a symbol for every implementation and include the implementation
-#if (EVENTLOG_WIN32)
+		protected EventLogImpl (EventLog coreEventLog)
+		{
+			_coreEventLog = coreEventLog;
+		}
 
-	// TODO implement the EventLog for Win32 platforms
+		public event EntryWrittenEventHandler EntryWritten;
 
-#elif (EVENTLOG_GENERIC)
+		protected EventLog CoreEventLog {
+			get { return _coreEventLog; }
+		}
 
-	// TODO implement a generic (XML - based?) Eventlog for non - Win32 platforms
+		public int EntryCount {
+			get {
+				if (_coreEventLog.Log == null || _coreEventLog.Log.Length == 0) {
+					throw new ArgumentException ("Log property is not set.");
+				}
 
-#else
-	// Empty implementation that does not need any specific platform
-	// but should be enough to get applications to run that WRITE to eventlog
-	internal class EventLogImpl
-	{
-		public EventLogImpl (EventLog coreEventLog)
-		{
+				if (!EventLog.Exists (_coreEventLog.Log, _coreEventLog.MachineName)) {
+					throw new InvalidOperationException (string.Format (
+						CultureInfo.InvariantCulture, "The event log '{0}' on "
+						+ " computer '{1}' does not exist.", _coreEventLog.Log,
+						_coreEventLog.MachineName));
+				}
+
+				return GetEntryCount ();
+			}
 		}
 
-		public static event EntryWrittenEventHandler EntryWritten;
+		public EventLogEntry this[int index] {
+			get {
+				if (_coreEventLog.Log == null || _coreEventLog.Log.Length == 0) {
+					throw new ArgumentException ("Log property is not set.");
+				}
 
-		public EventLogEntryCollection Entries {
-			get {return new EventLogEntryCollection ();}
+				if (!EventLog.Exists (_coreEventLog.Log, _coreEventLog.MachineName)) {
+					throw new InvalidOperationException (string.Format (
+						CultureInfo.InvariantCulture, "The event log '{0}' on "
+						+ " computer '{1}' does not exist.", _coreEventLog.Log,
+						_coreEventLog.MachineName));
+				}
+
+				if (index < 0 || index > EntryCount)
+					throw new ArgumentException ("Index out of range");
+
+				return GetEntry (index);
+			}
 		}
 
 		public string LogDisplayName {
-			get {return "";}
+			get {
+#if NET_2_0
+				// to-do perform valid character checks
+				if (_coreEventLog.Log != null && _coreEventLog.Log.Length == 0) {
+					throw new InvalidOperationException ("Event log names must"
+						+ " consist of printable characters and cannot contain"
+						+ " \\, *, ?, or spaces.");
+				}
+#endif
+				if (_coreEventLog.Log != null) {
+					if (!EventLog.Exists (_coreEventLog.Log, _coreEventLog.MachineName)) {
+						throw new InvalidOperationException (string.Format (
+							CultureInfo.InvariantCulture, "Cannot find Log {0}"
+							+ " on computer {1}.", _coreEventLog.Log,
+							_coreEventLog.MachineName));
+					}
+				}
+
+				return GetLogDisplayName ();
+			}
 		}
 
-		public void BeginInit () {}
+		public abstract void BeginInit ();
 
-		public void Clear () {}
+		public abstract void Clear ();
 
-		public void Close () {}
+		public abstract void Close ();
 
-		public static void CreateEventSource (string source, string logName, string machineName) {}
+		public abstract void Dispose (bool disposing);
 
-		public static void Delete (string logName, string machineName) {}
+		public abstract void EndInit ();
 
-		public static void DeleteEventSource (string source, string machineName) {}
+		public abstract EventLogEntry[] GetEntries ();
 
-		public void Dispose (bool disposing) {}
+		protected abstract int GetEntryCount ();
 
-		public void EndInit () {}
+		protected abstract EventLogEntry GetEntry (int index);
 
-		public static bool Exists (string logName, string machineName)
+		protected abstract string GetLogDisplayName ();
+
+		protected abstract void WriteEventLogEntry (EventLogEntry entry);
+
+		public void WriteEntry (string message, EventLogEntryType type, int eventID, short category, byte[] rawData)
 		{
-			return false;
+			EventLogEntry entry = new EventLogEntry (string.Empty, category, 0, eventID,
+				message, _coreEventLog.Source, string.Empty, _coreEventLog.MachineName,
+				type, DateTime.Now, DateTime.Now, rawData, null);
+			WriteEventLogEntry (entry);
+			if (EntryWritten != null)
+				EntryWritten (null, new EntryWrittenEventArgs (entry));
 		}
+	}
 
-		public static EventLog[] GetEventLogs (string machineName)
+	// Empty implementation that does not need any specific platform
+	// but should be enough to get applications to run that WRITE to eventlog
+	internal class NullEventLog : EventLogImpl
+	{
+		public NullEventLog (EventLog coreEventLog)
+			: base (coreEventLog)
 		{
-			return new EventLog[0];
 		}
 
-		public static string LogNameFromSourceName (string source, string machineName)
+		public override void BeginInit ()
 		{
-			return String.Empty;
 		}
 
-		public static bool SourceExists (string source, string machineName)
+		public override void Clear ()
 		{
-			return false;
 		}
 
-		public void WriteEntry (string message, EventLogEntryType type, int eventID, short category, byte[] rawData)
+		public override void Close ()
 		{
-			WriteEntry ("", message, type, eventID, category, rawData);
 		}
 
-		public static void WriteEntry (string source, string message, EventLogEntryType type, int eventID, short category, byte[] rawData)
+		public override void Dispose (bool disposing)
 		{
-			EventLogEntry Entry;
-			Entry = new EventLogEntry ("", category, 0, eventID, message, source, 
-				"", "", type, DateTime.Now, DateTime.Now, rawData, null);
-			if (EntryWritten != null)
-				EntryWritten (null, new EntryWrittenEventArgs (Entry));
 		}
-	}
 
-#endif
+		public override void EndInit ()
+		{
+		}
 
+		public override EventLogEntry[] GetEntries ()
+		{
+			return new EventLogEntry[0];
+		}
+
+		protected override int GetEntryCount ()
+		{
+			return 0;
+		}
+
+		protected override EventLogEntry GetEntry (int index)
+		{
+			return null;
+		}
+
+		protected override string GetLogDisplayName ()
+		{
+			return CoreEventLog.Log;
+		}
+
+		protected override void WriteEventLogEntry (EventLogEntry entry)
+		{
+		}
+	}
 }
Index: System.Diagnostics/EventLogEntryCollection.cs
===================================================================
--- System.Diagnostics/EventLogEntryCollection.cs	(revision 63521)
+++ System.Diagnostics/EventLogEntryCollection.cs	(working copy)
@@ -37,42 +37,79 @@
 
 	public class EventLogEntryCollection : ICollection, IEnumerable {
 
-		private ArrayList eventLogs = new ArrayList ();
+		readonly EventLogImpl _impl;
 
-		internal EventLogEntryCollection()
+		internal EventLogEntryCollection(EventLogImpl impl)
 		{
+			_impl = impl;
 		}
 
 		public int Count {
-			get {return eventLogs.Count;}
+			get { return _impl.EntryCount; }
 		}
 
 		public virtual EventLogEntry this [int index] {
-			get {return (EventLogEntry) eventLogs[index];}
+			get { return _impl[index]; }
 		}
 
 		bool ICollection.IsSynchronized {
-			get {return eventLogs.IsSynchronized;}
+			get { return false; }
 		}
 
 		object ICollection.SyncRoot {
-			get {return eventLogs.SyncRoot;}
+			get { return this; }
 		}
 
-		public void CopyTo (EventLogEntry[] eventLogs, int index)
+		public void CopyTo (EventLogEntry[] eventLogEntries, int index)
 		{
-			eventLogs.CopyTo (eventLogs, index);
+			EventLogEntry[] entries = _impl.GetEntries ();
+			Array.Copy (entries, 0, eventLogEntries, index, entries.Length);
 		}
 
 		public IEnumerator GetEnumerator ()
 		{
-			return eventLogs.GetEnumerator ();
+			return new EventLogEntryEnumerator (_impl);
 		}
 
 		void ICollection.CopyTo (Array array, int index)
 		{
-			eventLogs.CopyTo (array, index);
+			EventLogEntry[] entries = _impl.GetEntries ();
+			Array.Copy (entries, 0, array, index, entries.Length);
 		}
-	}
+
+		private class EventLogEntryEnumerator : IEnumerator
+		{
+			internal EventLogEntryEnumerator (EventLogImpl impl)
+			{
+				_impl = impl;
+			}
+
+			object IEnumerator.Current {
+				get { return Current; }
+			}
+
+			public EventLogEntry Current
+			{
+				get { return _currentEntry; }
+			}
+
+			public bool MoveNext ()
+			{
+				_currentIndex++;
+				_currentEntry = _impl[_currentIndex];
+				return _currentEntry != null;
+			}
+
+			public void Reset ()
+			{
+				_currentIndex = - 1;
+				_currentEntry = null;
+			}
+
+			readonly EventLogImpl _impl;
+			int _currentIndex = -1;
+			EventLogEntry _currentEntry;
+		}
 }
+}
 
Index: System.Diagnostics/EventLog.cs
===================================================================
--- System.Diagnostics/EventLog.cs	(revision 63521)
+++ System.Diagnostics/EventLog.cs	(working copy)
@@ -32,9 +32,14 @@
 
 using System;
 using System.Diagnostics;
+using System.Collections;
 using System.ComponentModel;
 using System.ComponentModel.Design;
+using System.Globalization;
+using System.IO;
 
+using Microsoft.Win32;
+
 namespace System.Diagnostics 
 {
 	[DefaultEvent ("EntryWritten")]
@@ -42,7 +47,6 @@
 	[Designer ("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, " + Consts.AssemblyMicrosoft_VisualStudio)]
 	public class EventLog : Component, ISupportInitialize 
 	{
-
 		private string source;
 		private string logName;
 		private string machineName;
@@ -52,7 +56,7 @@
 		private EventLogImpl Impl;
 
 		public EventLog()
-			: this ("")
+			: this (string.Empty)
 		{
 		}
 
@@ -61,19 +65,31 @@
 		{
 		}
 
-		public EventLog(string logName, string machineName) 
-			: this (logName, machineName, "")
+		public EventLog(string logName, string machineName)
+			: this (logName, machineName, string.Empty)
 		{
 		}
 
 		public EventLog(string logName, string machineName, string source)
 		{
+			if (logName == null) {
+				throw new ArgumentNullException ("logName");
+			}
+			if (machineName == null || machineName.Length == 0)
+				throw new ArgumentException (string.Format (
+					CultureInfo.InvariantCulture, "Invalid value '{0}' for"
+					+ " parameter 'machineName'.", machineName));
+
 			this.source = source;
 			this.machineName = machineName;
 			this.logName = logName;
 
-			this.Impl = new EventLogImpl (this);
-			EventLogImpl.EntryWritten += new EntryWrittenEventHandler (EntryWrittenHandler);
+			if (Environment.OSVersion.Platform == PlatformID.Win32NT) {
+				Impl = new Win32EventLog (this);
+			} else {
+				Impl = new NullEventLog (this);
+			}
+			Impl.EntryWritten += new EntryWrittenEventHandler (EntryWrittenHandler);
 		}
 
 		private void EntryWrittenHandler (object sender, EntryWrittenEventArgs e)
@@ -92,7 +108,7 @@
 		[Browsable (false), DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
 		[MonitoringDescription ("The entries in the log.")]
 		public EventLogEntryCollection Entries {
-			get {return Impl.Entries;}
+			get {return new EventLogEntryCollection(Impl);}
 		}
 
 		[ReadOnly (true), DefaultValue (""), RecommendedAsConfigurable (true)]
@@ -100,7 +116,11 @@
 		[MonitoringDescription ("Name of the log that is read and written.")]
 		public string Log {
 			get {return logName;}
-			set {logName = value;}
+			set {
+				if (value == null)
+					throw new ArgumentNullException ("value");
+				logName = value;
+			}
 		}
 
 		[Browsable (false)]
@@ -119,8 +139,8 @@
 		[TypeConverter ("System.Diagnostics.Design.StringValueConverter, " + Consts.AssemblySystem_Design)]
 		[MonitoringDescription ("The application name that writes the log.")]
 		public string Source {
-			get {return source;}
-			set {source = value;}
+			get { return source; }
+			set { source = (value == null) ? string.Empty : value; }
 		}
 
 		[Browsable (false), DefaultValue (null)]
@@ -154,17 +174,128 @@
 			string logName, 
 			string machineName)
 		{
-			EventLogImpl.CreateEventSource (source, logName, machineName);
+			CreateEventSource (new EventSourceCreationData (source, logName,
+				machineName));
 		}
 
+#if NET_2_0
+		[MonoTODO ("Support remote machine")]
+		public
+#else
+		private
+#endif
+		static void CreateEventSource (EventSourceCreationData sourceData)
+		{
+			if (sourceData.Source == null || sourceData.Source.Length == 0) {
+				throw new ArgumentException ("Source is not set");
+			}
+			if (sourceData.LogName == null || sourceData.LogName.Length == 0) {
+				throw new ArgumentException ("LogName is not set");
+			}
+
+			if (SourceExists (sourceData.Source, sourceData.MachineName)) {
+				throw new ArgumentException (string.Format (CultureInfo.InvariantCulture,
+					"Source '{0}' already exists on '{1}'.", sourceData.Source,
+					sourceData.MachineName));
+			}
+
+			using (RegistryKey eventLogKey = GetEventLogKey (sourceData.MachineName, true)) {
+				if (eventLogKey == null)
+					throw new InvalidOperationException ("EventLog registry key is missing.");
+
+				bool logKeyCreated = false;
+				RegistryKey logKey = null;
+				try {
+					logKey = eventLogKey.OpenSubKey (sourceData.LogName, true);
+					if (logKey == null) {
+						logKey = eventLogKey.CreateSubKey (sourceData.LogName);
+						logKey.SetValue ("Sources", new string[] { sourceData.LogName,
+							sourceData.Source });
+						UpdateLogRegistry (logKey);
+
+						using (RegistryKey sourceKey = logKey.CreateSubKey (sourceData.LogName)) {
+							UpdateSourceRegistry (sourceKey, sourceData);
+						}
+
+						logKeyCreated = true;
+					}
+
+					if (sourceData.LogName != sourceData.Source) {
+						if (!logKeyCreated) {
+							string[] sources = (string[]) logKey.GetValue ("Sources");
+							if (sources == null) {
+								logKey.SetValue ("Sources", new string[] { sourceData.LogName,
+								sourceData.Source });
+							} else {
+								bool found = false;
+								for (int i = 0; i < sources.Length; i++) {
+									if (sources[i] == sourceData.Source) {
+										found = true;
+										break;
+									}
+								}
+								if (!found) {
+									string[] newSources = new string[sources.Length + 1];
+									Array.Copy (sources, 0, newSources, 0, sources.Length);
+									newSources[sources.Length] = sourceData.Source;
+								}
+							}
+						}
+						using (RegistryKey sourceKey = logKey.CreateSubKey (sourceData.Source)) {
+							UpdateSourceRegistry (sourceKey, sourceData);
+						}
+					}
+				} finally {
+					if (logKey != null)
+						logKey.Close ();
+				}
+			}
+		}
+
 		public static void Delete(string logName)
 		{
 			Delete (logName, ".");
 		}
 
-		public static void Delete(string logName, string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static void Delete (string logName, string machineName)
 		{
-			EventLogImpl.Delete (logName, machineName);
+			if (machineName == null || machineName.Length == 0)
+				throw new ArgumentException ("Invalid format for argument"
+					+ " machineName.");
+
+			if (logName == null || logName.Length == 0)
+				throw new ArgumentException ("Log to delete was not specified.");
+
+			using (RegistryKey eventLogKey = GetEventLogKey (machineName, true)) {
+				if (eventLogKey == null)
+					throw new InvalidOperationException ("The event log key does not exist.");
+
+				using (RegistryKey logKey = eventLogKey.OpenSubKey (logName, false)) {
+					if (logKey == null)
+						throw new InvalidOperationException (string.Format (
+							CultureInfo.InvariantCulture, "Event Log '{0}'"
+							+ " does not exist on computer '{1}'.", logName,
+							machineName));
+
+					// remove all eventlog entries for specified log
+					using (EventLog eventLog = new EventLog (logName, machineName)) {
+						eventLog.Clear ();
+					}
+
+					// remove file holding event log entries
+					string file = (string) logKey.GetValue ("File");
+					if (file != null) {
+						try {
+							File.Delete (file);
+						} catch (Exception) {
+							// .NET seems to ignore failures here
+						}
+					}
+				}
+
+				eventLogKey.DeleteSubKeyTree (logName);
+			}
 		}
 
 		public static void DeleteEventSource(string source)
@@ -172,13 +303,37 @@
 			DeleteEventSource (source, ".");
 		}
 
-		public static void DeleteEventSource(string source, 
-			string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static void DeleteEventSource (string source, string machineName)
 		{
-			EventLogImpl.DeleteEventSource (source, machineName);
+			if (machineName == null || machineName.Length == 0)
+				throw new ArgumentException (string.Format (
+					CultureInfo.InvariantCulture, "Invalid value '{0}' for"
+					+ " parameter 'machineName'.", machineName));
+
+			using (RegistryKey logKey = FindLogKeyBySource (source, machineName, true)) {
+				if (logKey == null) {
+					throw new ArgumentException (string.Format (
+						CultureInfo.InvariantCulture, "The source '{0}' is not"
+						+ " registered on computer '{1}'.", source, machineName));
+				}
+
+				logKey.DeleteSubKeyTree (source);
+
+				string[] sources = (string[]) logKey.GetValue ("Sources");
+				if (sources != null) {
+					ArrayList temp = new ArrayList ();
+					for (int i = 0; i < sources.Length; i++)
+						if (sources[i] != source)
+							temp.Add (sources[i]);
+					string[] newSources = new string[temp.Count];
+					temp.CopyTo (newSources, 0);
+					logKey.SetValue ("Sources", newSources);
+				}
+			}
 		}
 
-		protected override void Dispose(bool disposing)
+		protected override void Dispose (bool disposing)
 		{
 			Impl.Dispose (disposing);
 		}
@@ -193,25 +348,45 @@
 			return Exists (logName, ".");
 		}
 
-		public static bool Exists(string logName, string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static bool Exists (string logName, string machineName)
 		{
-			return EventLogImpl.Exists (logName, machineName);
+			using (RegistryKey logKey = FindLogKeyByName (logName, machineName, false)) {
+				return (logKey != null);
+			}
 		}
 
-		public static EventLog[] GetEventLogs()
+		public static EventLog[] GetEventLogs ()
 		{
 			return GetEventLogs (".");
 		}
 
-		public static EventLog[] GetEventLogs(string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static EventLog[] GetEventLogs (string machineName)
 		{
-			return EventLogImpl.GetEventLogs (machineName);
+			using (RegistryKey eventLogKey = GetEventLogKey (machineName, false)) {
+				if (eventLogKey == null) {
+					throw new InvalidOperationException ("TODO");
+				}
+				string[] logNames = eventLogKey.GetSubKeyNames ();
+				EventLog[] eventLogs = new EventLog[logNames.Length];
+				for (int i = 0; i < logNames.Length; i++) {
+					EventLog eventLog = new EventLog (logNames[i], machineName);
+					eventLogs[i] = eventLog;
+				}
+				return eventLogs;
+			}
 		}
 
-		public static string LogNameFromSourceName(string source, 
-			string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static string LogNameFromSourceName (string source, string machineName)
 		{
-			return EventLogImpl.LogNameFromSourceName (source, machineName);
+			using (RegistryKey logKey = FindLogKeyBySource (source, machineName, false)) {
+				if (logKey == null)
+					return null;
+
+				return GetLogName (logKey);
+			}
 		}
 
 		public static bool SourceExists(string source)
@@ -219,9 +394,15 @@
 			return SourceExists (source, ".");
 		}
 
-		public static bool SourceExists(string source, string machineName)
+		[MonoTODO ("Support remote machines")]
+		public static bool SourceExists (string source, string machineName)
 		{
-			return EventLogImpl.SourceExists (source, machineName);
+			RegistryKey logKey = FindLogKeyBySource (source, machineName, false);
+			if (logKey != null) {
+				logKey.Close ();
+				return true;
+			}
+			return false;
 		}
 
 		public void WriteEntry(string message)
@@ -244,6 +425,18 @@
 			int eventID,
 			short category)
 		{
+			if (Source.Length == 0) {
+				throw new ArgumentException ("Source property was not set"
+					+ "before writing to the event log.");
+			}
+
+			if (!SourceExists (Source, MachineName)) {
+				if (Log == null || Log.Length == 0) {
+					Log = "Application";
+				}
+				CreateEventSource (Source, Log, MachineName);
+			}
+
 			WriteEntry (message, type, eventID, category, null);
 		}
 
@@ -281,7 +474,10 @@
 			EventLogEntryType type, int eventID, short category, 
 			byte[] rawData)
 		{
-			EventLogImpl.WriteEntry (source, message, type, eventID, category, rawData);
+			using (EventLog eventLog = new EventLog ()) {
+				eventLog.Source = source;
+				eventLog.WriteEntry (message, type, eventID, category, rawData);
+			}
 		}
 
 		internal void OnEntryWritten (EventLogEntry newEntry)
@@ -292,6 +488,106 @@
 
 		[MonitoringDescription ("Raised for each EventLog entry written.")]
 		public event EntryWrittenEventHandler EntryWritten;
+
+		internal string GetLogName ()
+		{
+			if (logName != null && logName.Length > 0)
+				return logName;
+
+			// if no log name has been set, then use source to determine name of log
+			logName = LogNameFromSourceName (source, machineName);
+			return logName;
+		}
+
+		private static void UpdateLogRegistry (RegistryKey logKey)
+		{
+			if (logKey.GetValue ("File") == null) {
+				string logName = GetLogName (logKey);
+				string file;
+				if (logName.Length > 8) {
+					file = logName.Substring (0, 8) + ".evt";
+				} else {
+					file = logName + ".evt";
+				}
+				string configPath = Path.Combine (Environment.GetFolderPath (
+					Environment.SpecialFolder.System), "config");
+				logKey.SetValue ("File", Path.Combine (configPath, file));
+			}
+
+			// TODO: write other Log values:
+			// - MaxSize
+			// - Retention
+			// - AutoBackupLogFiles
+		}
+
+		private static void UpdateSourceRegistry (RegistryKey sourceKey, EventSourceCreationData data)
+		{
+			if (data.CategoryCount > 0)
+				sourceKey.SetValue ("CategoryCount", data.CategoryCount);
+
+			if (data.CategoryResourceFile != null && data.CategoryResourceFile.Length > 0)
+				sourceKey.SetValue ("CategoryMessageFile", data.CategoryResourceFile);
+
+			if (data.MessageResourceFile != null && data.MessageResourceFile.Length > 0)
+				sourceKey.SetValue ("EventMessageFile", data.MessageResourceFile);
+
+			if (data.ParameterResourceFile != null && data.ParameterResourceFile.Length > 0)
+				sourceKey.SetValue ("ParameterMessageFile", data.ParameterResourceFile);
+		}
+
+		private static string GetLogName (RegistryKey logKey) {
+			string logName = logKey.Name;
+			return logName.Substring (logName.LastIndexOf ("\\") + 1);
+		}
+
+		[MonoTODO ("Support remote machines")]
+		private static RegistryKey GetEventLogKey (string machineName, bool writable)
+		{
+			return Registry.LocalMachine.OpenSubKey (@"SYSTEM\CurrentControlSet\Services\EventLog", writable);
+		}
+
+		private static RegistryKey FindLogKeyByName (string logName, string machineName, bool writable)
+		{
+			using (RegistryKey eventLogKey = GetEventLogKey (machineName, writable)) {
+				if (eventLogKey == null) {
+					return null;
+				}
+
+				return eventLogKey.OpenSubKey (logName, writable);
+			}
+		}
+
+		private static RegistryKey FindLogKeyBySource (string source, string machineName, bool writable)
+		{
+			if (source == null || source.Length == 0)
+				return null;
+
+			RegistryKey eventLogKey = null;
+			try {
+				eventLogKey = GetEventLogKey (machineName, writable);
+				if (eventLogKey == null)
+					return null;
+
+				string[] subKeys = eventLogKey.GetSubKeyNames ();
+				for (int i = 0; i < subKeys.Length; i++) {
+					RegistryKey sourceKey = null;
+					try {
+						RegistryKey logKey = eventLogKey.OpenSubKey (subKeys[i], writable);
+						if (logKey != null) {
+							sourceKey = logKey.OpenSubKey (source, writable);
+							if (sourceKey != null)
+								return logKey;
+						}
+					} finally {
+						if (sourceKey != null)
+							sourceKey.Close ();
+					}
+				}
+				return null;
+			} finally {
+				if (eventLogKey != null)
+					eventLogKey.Close ();
+			}
+		}
 	}
 }
-
Index: System.Diagnostics/OverflowAction.cs
===================================================================
--- System.Diagnostics/OverflowAction.cs	(revision 63523)
+++ System.Diagnostics/OverflowAction.cs	(working copy)
@@ -1,10 +1,10 @@
 //
 // System.Diagnostics.OverFlowAction
 //
-// Authors:
-//	Gert Driesen (drieseng@users.sourceforge.net)
+// Author:
+//	Gert Driesen <driesen@users.sourceforge.net>
 //
-// (C) 2006 Novell
+// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
 //
 //
 // Permission is hereby granted, free of charge, to any person obtaining
Index: System.Diagnostics/EventInstance.cs
===================================================================
--- System.Diagnostics/EventInstance.cs	(revision 63523)
+++ System.Diagnostics/EventInstance.cs	(working copy)
@@ -1,10 +1,10 @@
 //
 // System.Diagnostics.EventInstance
 //
-// Authors:
-//	Gert Driesen (drieseng@users.sourceforge.net)
+// Author:
+//	Gert Driesen <driesen@users.sourceforge.net>
 //
-// (C) 2006 Novell
+// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
 //
 //
 // Permission is hereby granted, free of charge, to any person obtaining
Index: System_test.dll.sources
===================================================================
--- System_test.dll.sources	(revision 63530)
+++ System_test.dll.sources	(working copy)
@@ -132,6 +132,7 @@
 System.Configuration/SettingsPropertyTest.cs
 System.Configuration/SettingsPropertyValueCollectionTest.cs
 System.Configuration/SettingsPropertyValueTest.cs
+System.Diagnostics/EventLogTest.cs
 System.Diagnostics/StopwatchTest.cs
 System.Diagnostics/TraceTest.cs
 System.Diagnostics/SwitchesTest.cs
