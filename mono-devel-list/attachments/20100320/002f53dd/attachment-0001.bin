//
// System.Random Test Cases
//
// Authors:
//  Adrian Willenb√ºcher <AWillenbuecher@gmx.de>
//
// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using NUnit.Framework;
using NUnit.Framework.SyntaxHelpers;
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Resources;

namespace MonoTests.System
{

	[TestFixture]
	public class RandomTest
	{
		#region Random()
		[Test]
		public void Constructor1 ()
		{
			var ticks = Environment.TickCount;
			var rng = new Random ();
			for (var i = 0; i < 100; ++i)
				Assert.That (rng.Next (), Is.GreaterThanOrEqualTo (0), "#F01 probable TickCount: " + ticks);
		}
		#endregion

		#region Next ()
		[Test]
		public void SeededSequence1 ()
		{
			int [] expected = { 256171686, 924759460, 1326063082, 1748505655, 770391478, 893875434, 1927233845,
				1915141213, 1304416967, 1040106214, 1413028753, 517287625, 164449503, 484347407, 134543290,
				1497001777, 1437568641, 1805630818, 442001507, 276608167 };

			var rng = new Random (-1234);
			
			foreach (var x in expected)
				Assert.That (x, Is.EqualTo (rng.Next ()), "#A01");
		}

		[Test]
		public void SeededSequence2 ()
		{
			int [] expected = { 545630734, 1871987772, 32100770, 2055383023, 588683182, 770534463, 129782961, 1446710564,
				1212431109, 342542925, 1688944563, 631123534, 1233995261, 1977968768, 1785858814, 375605933,
				1274134403, 2089187981, 919781722, 1124065708 };
			
			var rng = new Random (0);
			
			foreach (var x in expected)
				Assert.That (x, Is.EqualTo (rng.Next ()), "#A02");
		}

		[Test]
		public void SeededSequence3 ()
		{
			int [] expected = { 428190222, 177488956, 1323946402, 2139269103, 1846974382, 2037083199, 817648817,
				341642532, 1854421765, 726977101, 2110569395, 1682606670, 414270973, 582707328, 2058012414,
				664397541, 735971203, 1192835725, 373417658, 1356677716 };
			
			var rng = new Random (int.MaxValue);
			
			foreach (var e in expected)
				Assert.That (rng.Next (), Is.EqualTo (e), "#A03");
		}
		#endregion

		#region Next (int)
		[Test]
		public void NextMax1 ()
		{
			var rng = new Random (0);
			Assert.That (rng.Next (0), Is.EqualTo (0), "#B01");
		}

		[Test]
		public void NextMax2 ()
		{
			var rng = new Random (0);
			int [] maxValues = { 1, 2, 3, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
			foreach (var maxValue in maxValues) {
				for (var i = 0; i < 100; ++i) {
					var x = rng.Next (maxValue);
					Assert.That (x, Is.GreaterThanOrEqualTo (0), "#B02a");
					Assert.That (x, Is.LessThan (maxValue), "#B02b");
				}
			}
		}

		[Test]
		[ExpectedException("System.ArgumentOutOfRangeException", UserMessage = "#B03")]
		public void NextMax3 ()
		{
			var rng = new Random (0);
			rng.Next (-1);
		}
		#endregion

		#region Next (int, int)
		[Test]
		public void NextMinMax1 ()
		{
			var rng = new Random (0);
			Assert.That (rng.Next (-50, -50), Is.EqualTo (-50), "#C01");
		}

		[Test]
		public void NextMinMax2 ()
		{
			var rng = new Random (0);
			int [] minValues = { -4, -3, -2, 0, 4, 5, 6, 7, 8, 0, int.MinValue, int.MinValue };
			int [] maxValues = { -3, 0, 10, 1, 5, 7, 7, 15, 16, int.MaxValue, 0, int.MaxValue };
			for (var i = 0; i < minValues.Length; ++i) {
				var minValue = minValues [i];
				var maxValue = maxValues [i];
				for (var j = 0; j < 100; ++j) {
					var x = rng.Next (minValue, maxValue);
					Assert.That (x, Is.GreaterThanOrEqualTo (minValue), "#C02a");
					Assert.That (x, Is.LessThan (maxValue), "#C02b");
				}
			}
		}

		[Test]
		[ExpectedException("System.ArgumentOutOfRangeException", UserMessage = "#C03")]
		public void NextMinMax3 ()
		{
			var rng = new Random (0);
			rng.Next (11, 10);
		}
		#endregion

		#region NextBytes(byte[])
		[Test]
		public void NextBytes1 ()
		{
			var rng = new Random (-1);
			
			byte [] expected = { 14, 60, 162, 239, 174, 63, 177, 36, 5, 77, 179, 78, 253, 128, 254, 157, 131, 141, 26 };
			byte [] values = new byte [expected.Length];
			
			rng.NextBytes (values);
			Assert.That (values, Is.EqualTo (expected), "#D01");
		}

		[Test]
		[ExpectedException("System.ArgumentNullException", UserMessage = "#D02")]
		public void NextBytes2 ()
		{
			var rng = new Random (-1);
			rng.NextBytes (null);
		}
		#endregion

		#region NextDouble ()
		[Test]
		public void NextDouble1 ()
		{
			double [] expected = {
				0.62703955499455332756042480468750, 0.43585611786693334579467773437500,
				0.00747404294088482856750488281250, 0.97855615220032632350921630859375,
				0.13706348417326807975769042968750, 0.17940403497777879238128662109375,
				0.03021745034493505954742431640625, 0.33683855179697275161743164062500,
				0.78229111549444496631622314453125, 0.57975448970682919025421142578125,
				0.39323804969899356365203857421875, 0.64694489864632487297058105468750,
				0.28731191088445484638214111328125, 0.96053174138069152832031250000000,
				0.41580265713855624198913574218750, 0.58745257114060223102569580078125,
				0.29665753315202891826629638671875, 0.98642698233015835285186767578125,
				0.71415337035432457923889160156250, 0.76171694230288267135620117187500 };
			var rng = new Random (0);
			foreach (var e in expected)
				Assert.That (rng.NextDouble (), Is.EqualTo (e).Within (1E-28), "#E01");
		}
		#endregion

		#region Serialization
		[Test]
		public void Deserialize1 ()
		{
			// Load serialized old version of System.Random
			var path = Path.Combine (Path.Combine ("Test", "resources"), "Random.old");
			var stream = File.Open (path, FileMode.Open);
			var formatter = new BinaryFormatter ();
			var rng = (Random) formatter.Deserialize (stream);

			// Just make sure that it has been successfully deserialized
			for (var i = 0; i < 20; ++i)
				Assert.That (rng.Next (), Is.GreaterThanOrEqualTo (0), "#G01");
		}

		[Test]
		public void Deserialize2 ()
		{
			// Serialize...
			var stream = new MemoryStream ();
			var formatter = new BinaryFormatter ();
			var rng = new Random (0);
			formatter.Serialize (stream, rng);
			var expected_values = new byte [100];
			rng.NextBytes (expected_values);

			// ... deserialize...
			stream.Position = 0;
			rng = (Random) formatter.Deserialize (stream);

			// ... and check that the generated values are the same.
			var new_values = new byte [expected_values.Length];
			rng.NextBytes (new_values);
			Assert.That (new_values, Is.EqualTo (expected_values), "#G02");
		}
		#endregion
	}
}
