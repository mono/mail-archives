//
// System.Random.cs
//
// Authors:
//   Bob Smith (bob@thestuff.net)
//   Ben Maurer (bmaurer@users.sourceforge.net)
//   Adrian Willenb√ºcher (AWillenbuecher@gmx.de)
//
// (C) 2001 Bob Smith.  http://www.thestuff.net
// (C) 2003 Ben Maurer
//
// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace System
{
	/* Uses an xorshift algorithm by George Marsaglia. References:
	 * http://groups.google.com/group/comp.lang.c/browse_thread/thread/a9915080a4424068/
	 * http://www.jstatsoft.org/v08/i14/paper
	 */
	[Serializable]
	[ComVisible(true)]
	public class Random
	{
		// State from the old version of this class; not used after deserialization.
		#pragma warning disable 169
		private int inext;
		private int inextp;
		#pragma warning restore 169
		private int [] SeedArray;

		// Actual state of the algorithm.
		private uint [] state;
		private const uint STATE_SIZE = 5;

		public Random () : this(Environment.TickCount)
		{
		}

		public Random (int Seed)
		{
			SeedState (Seed);
		}

		private void SeedState (int seed)
		{
			state = new uint [STATE_SIZE];
			state[0] = 123456789 ^ (uint) seed;
			state[1] = 362436069;
			state[2] = 521288629;
			state[3] = 88675123;
			state[4] = 886756453;
		}

		[OnDeserialized]
		private void PostDeserialization (StreamingContext context)
		{
			// Did we deserialize from an old object?
			if (state == null || state.Length < STATE_SIZE)
				SeedState (0);
			
			if (SeedArray != null) {
				// Incorporate state from old object
				try {
					for (var i = 0; i < STATE_SIZE; ++i)
						state [i] ^= (uint) SeedArray [i + 1];
					
				} finally {
					// We don't need SeedArray anymore
					SeedArray = null;
				}
			}
		}

		// Returns a full 32-bit random number.
		private uint NextUInt32 ()
		{
			var temp = state [0] ^ (state [0] >> 7);
			temp = temp ^ (temp << 13);
			
			for (var i = 0; i < 4; ++i)
				state [i] = state [i + 1];
			
			state [4] = (state [4] ^ (state [4] << 6)) ^ temp;
			
			return (2 * state [1] + 1) * state [4];
		}

		// Returns a random number n with 0 <= n < maxValue.
		private uint NextUInt32 (uint maxValue)
		{
			if (maxValue == 0)
				return 0;
			
			// Mask for all bits beneath and including most significant bit
			var mask = maxValue;
			mask = mask | (mask >> 1);
			mask = mask | (mask >> 2);
			mask = mask | (mask >> 4);
			mask = mask | (mask >> 8);
			mask = mask | (mask >> 16);
			
			uint x;
			do {
				x = NextUInt32 () & mask;
			} while (x >= maxValue);
			
			return x;
		}

		protected virtual double Sample ()
		{
			return NextUInt32 () * (1.0 / 4294967296.0);
		}

		public virtual double NextDouble ()
		{
			return Sample ();
		}

		public virtual int Next ()
		{
			const uint cutoff = 2147483648u;
			var x = NextUInt32 ();
			return x >= cutoff ? (int) (x - cutoff) : (int) x;
		}

		public virtual int Next (int maxValue)
		{
			if (maxValue < 0)
				throw new ArgumentOutOfRangeException ("maxValue", Locale.GetText ("maxValue is less than 0"));
			
			return (int) NextUInt32 ((uint) maxValue);
		}

		public virtual int Next (int minValue, int maxValue)
		{
			if (minValue > maxValue)
				throw new ArgumentOutOfRangeException ("maxValue", Locale.GetText ("maxValue is less than minValue"));
			
			return (int) NextUInt32 ((uint) (maxValue - minValue)) + minValue;
		}

		public virtual void NextBytes (byte [] buffer)
		{
			if (buffer == null)
				throw new ArgumentNullException ("buffer");
			
			for (var i = 0; i < buffer.Length; ++i)
				buffer [i] = (byte) NextUInt32 ();
		}
	}
}
