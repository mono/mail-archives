Index: XSPApplicationHost.cs
===================================================================
--- XSPApplicationHost.cs	(revision 42593)
+++ XSPApplicationHost.cs	(working copy)
@@ -33,6 +33,10 @@
 using System.Net.Sockets;
 using System.Text;
 using System.Web;
+using System.Security.Cryptography;
+using System.Security.Cryptography.X509Certificates;
+using Mono.Security.Authenticode;
+using Mono.Security.Protocol.Tls;
 
 namespace Mono.ASPNET
 {
@@ -43,7 +47,26 @@
 	public class XSPWebSource: IWebSource
 	{
 		IPEndPoint bindAddress;
-		
+		bool SecureConnection;
+		Mono.Security.Protocol.Tls.SecurityProtocolType SecurityProtocol;
+		System.Security.Cryptography.X509Certificates.X509Certificate cert;
+		Mono.Security.Authenticode.PrivateKey key;
+		bool RequireClientCert;
+
+		public XSPWebSource(IPAddress address, int port, 
+			Mono.Security.Protocol.Tls.SecurityProtocolType securityProtocol,
+			System.Security.Cryptography.X509Certificates.X509Certificate cert,
+			Mono.Security.Authenticode.PrivateKey key,
+			bool RequireClientCert)
+		{			
+			SecureConnection=true;
+			this.bindAddress = new IPEndPoint (address, port);
+			this.SecurityProtocol=securityProtocol;
+			this.cert=cert;
+			this.key=key;
+			this.RequireClientCert=RequireClientCert;
+		}
+
 		public XSPWebSource (IPAddress address, int port)
 		{
 			SetListenAddress (address, port);
@@ -76,7 +99,8 @@
  
 		public IWorker CreateWorker (Socket client, ApplicationServer server)
 		{
-			return new XSPWorker (client, client.LocalEndPoint, server);
+			return new XSPWorker (client, client.LocalEndPoint, server,
+				SecureConnection, SecurityProtocol, cert, key, RequireClientCert);
 		}
 		
 		public Type GetApplicationHostType ()
@@ -200,23 +224,50 @@
 	internal class XSPWorker: IWorker
 	{
 		ApplicationServer server;
-		LingeringNetworkStream stream;
+		LingeringNetworkStream netStream;
+		Stream stream;
 		IPEndPoint remoteEP;
 		IPEndPoint localEP;
 		Socket sock;
 
-		public XSPWorker (Socket client, EndPoint localEP, ApplicationServer server)
+		PrivateKey key; 
+
+		public XSPWorker (Socket client, EndPoint localEP, Mono.ASPNET.ApplicationServer server,
+			bool SecureConnection,
+			Mono.Security.Protocol.Tls.SecurityProtocolType SecurityProtocol,
+			X509Certificate Cert,
+			PrivateKey key,
+			bool RequireClientCert) 
 		{
-			stream = new LingeringNetworkStream (client, false);
+			// For a secure connection, replace the stream with a SslStreamStream
+			if (SecureConnection)
+			{
+				netStream = new LingeringNetworkStream (client, true);
+				this.key=key;
+				Mono.Security.Protocol.Tls.SslServerStream s=new Mono.Security.Protocol.Tls.SslServerStream(netStream,
+					Cert, RequireClientCert, false);
+				s.PrivateKeyCertSelectionDelegate += new PrivateKeySelectionCallback (GetPrivateKey); 
+				stream = s;
+			}
+			else
+			{
+				netStream = new LingeringNetworkStream (client, false);
+				stream = netStream;
+			}
+
 			sock = client;
 			this.server = server;
-
 			try {
 				remoteEP = (IPEndPoint) client.RemoteEndPoint;
 			} catch { }
 			this.localEP = (IPEndPoint) localEP;
 		}
 
+		private AsymmetricAlgorithm GetPrivateKey (X509Certificate certificate, string targetHost) 
+		{ 
+			return key.RSA; 
+		} 
+
 		public int GetReuseCount ()
 		{
 			return server.GetAvailableReuses (sock);
@@ -307,23 +358,28 @@
 		{
 			if (!keepAlive || !IsConnected ()) {
 				stream.Close ();
+				if (stream!=netStream)
+					netStream.Close();
 				server.CloseSocket (sock);
 				return;
 			}
 
-			stream.EnableLingering = false;
+			netStream.EnableLingering = false;
 			stream.Close ();
+			if (stream!=netStream)
+				netStream.Close();
 			server.ReuseSocket (sock);
 		}
 
 		public bool IsConnected ()
 		{
-			return stream.Connected;
+			return netStream.Connected;
 		}
 
 		public void Flush ()
 		{
 			stream.Flush ();
+			netStream.Flush ();
 		}
 	}
 }