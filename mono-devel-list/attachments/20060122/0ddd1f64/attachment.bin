Index: Test/System.Xml.Serialization/XmlReflectionImporterTests.cs
===================================================================
--- Test/System.Xml.Serialization/XmlReflectionImporterTests.cs	(revision 55191)
+++ Test/System.Xml.Serialization/XmlReflectionImporterTests.cs	(working copy)
@@ -52,6 +52,7 @@
 	{
 		private const string SomeNamespace = "some:urn";
 		private const string AnotherNamespace = "another:urn";
+		private const string XmlSchemaNamespace = "http://www.w3.org/2001/XMLSchema";
 
 		// these Map methods re-create the XmlReflectionImporter at every call.
 
@@ -118,7 +119,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestIntTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map(typeof(int[]));
@@ -163,7 +163,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestStringTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (string[]));
@@ -208,7 +207,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestObjectTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (object[]));
@@ -253,7 +251,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestByteTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map(typeof(byte[]));
@@ -374,7 +371,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestDateTimeTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (DateTime[]));
@@ -419,7 +415,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestGuidTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (Guid[]));
@@ -495,7 +490,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestCharTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (char[]));
@@ -530,7 +524,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestXmlNodeTypeMapping ()
 		{
 			Type type = typeof (XmlNode);
@@ -576,7 +569,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestXmlElementTypeMapping ()
 		{
 			Type type = typeof (XmlElement);
@@ -622,7 +614,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestXmlNotationTypeMapping ()
 		{
 			Type type = typeof (XmlNotation);
@@ -668,7 +659,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestXmlSerializableTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (Employee));
@@ -679,7 +669,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestXmlSerializableTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (Employee[]));
@@ -714,7 +703,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestClassTypeMapping_NestedStruct ()
 		{
 			XmlTypeMapping tm = Map (typeof (NestedStruct));
@@ -742,7 +730,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestStructTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (TimeSpan));
@@ -753,7 +740,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestStructTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (TimeSpan[]));
@@ -788,7 +774,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestEnumTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (AttributeTargets));
@@ -799,7 +784,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestEnumTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (AttributeTargets[]));
@@ -844,7 +828,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestClassTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClass[]));
@@ -879,7 +862,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_IEnumerable_SimpleClass ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClassEnumerable));
@@ -920,7 +902,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_IEnumerable_Object ()
 		{
 			XmlTypeMapping tm = Map (typeof (ObjectEnumerable));
@@ -961,7 +942,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_IEnumarable_Object_NoMatchingAddMethod ()
 		{
@@ -969,7 +949,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_IEnumarable_Object_NoMatchingAddMethod_Array ()
 		{
@@ -977,7 +956,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_IEnumerable_SimpleClass_PrivateCurrent ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClassEnumerablePrivateCurrent));
@@ -1021,7 +999,6 @@
 #if ONLY_1_1
 		[Category ("NotDotNet")] // results in NullReferenceException in .NET 1.1 (SP1)
 #endif
-		[Category ("NotWorking")]
 		public void TypeMapping_IEnumerable_SimpleClass_PrivateGetEnumerator ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClassEnumerablePrivateGetEnumerator));
@@ -1062,7 +1039,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_Object_NoMatchingAddMethod ()
 		{
@@ -1070,7 +1046,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_Object_NoMatchingAddMethod_Array ()
 		{
@@ -1078,7 +1053,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_SimpleClass_NoMatchingAddMethod ()
 		{
@@ -1086,7 +1060,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_SimpleClass_NoMatchingAddMethod_Array ()
 		{
@@ -1094,7 +1067,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_ICollection_SimpleClass ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClassCollection));
@@ -1135,7 +1107,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_ICollection_Object ()
 		{
 			XmlTypeMapping tm = Map (typeof (ObjectCollection));
@@ -1176,7 +1147,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_Object_NoIntIndexer ()
 		{
@@ -1184,7 +1154,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_Object_NoIntIndexer_Array ()
 		{
@@ -1192,7 +1161,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_SimpleClass_NoIntIndexer ()
 		{
@@ -1200,7 +1168,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_SimpleClass_NoIntIndexer_Array ()
 		{
@@ -1208,6 +1175,16 @@
 		}
 
 		[Test]
+		[ExpectedException (typeof (InvalidOperationException))] 
+		public void TypeMapping_WrongChoices ()
+		{
+			// Type MonoTests.System.Xml.TestClasses.ItemChoiceType is missing 
+			// enumeration value 'StrangeOne' for element 'StrangeOne' from
+			// namespace ''.
+			Map (typeof (WrongChoices));
+		}
+
+		[Test]
 		[Category ("NotWorking")]
 		public void TestImportMembersMapping()
 		{
@@ -1245,9 +1222,12 @@
 			Assert.IsNull (smm.Namespace, "#4");
 			Assert.AreEqual ("System.String", smm.TypeFullName, "#5");
 			Assert.AreEqual ("string", smm.TypeName, "#6");
+#if NET_2_0
+			Assert.AreEqual (XmlSchemaNamespace, smm.TypeNamespace, "#7");
+#else
 			Assert.IsNull (smm.TypeNamespace, "#7");
+#endif
 
-			
 			rm = new XmlReflectionMember();
 			rm.IsReturnValue = false;
 			rm.MemberName = "nothing";
Index: Test/System.Xml.Serialization/SoapReflectionImporterTests.cs
===================================================================
--- Test/System.Xml.Serialization/SoapReflectionImporterTests.cs	(revision 55191)
+++ Test/System.Xml.Serialization/SoapReflectionImporterTests.cs	(working copy)
@@ -24,26 +24,28 @@
 	{
 		private const string SomeNamespace = "some:urn";
 		private const string AnotherNamespace = "another:urn";
+		private const string XmlSchemaNamespace = "http://www.w3.org/2001/XMLSchema";
+		private const string WsdlTypesNamespace = "http://microsoft.com/wsdl/types/";
 
 		// these Map methods re-create the SoapReflectionImporter at every call.
 
-		private XmlTypeMapping Map(Type t)
+		private XmlTypeMapping Map (Type t)
 		{
-			SoapReflectionImporter ri = new SoapReflectionImporter();
-			XmlTypeMapping tm = ri.ImportTypeMapping(t);
+			SoapReflectionImporter ri = new SoapReflectionImporter ();
+			XmlTypeMapping tm = ri.ImportTypeMapping (t);
 
 			return tm;
 		}
 
-		private XmlTypeMapping Map(Type t, string ns)
+		private XmlTypeMapping Map (Type t, string ns)
 		{
-			SoapReflectionImporter ri = new SoapReflectionImporter(ns);
-			XmlTypeMapping tm = ri.ImportTypeMapping(t);
+			SoapReflectionImporter ri = new SoapReflectionImporter (ns);
+			XmlTypeMapping tm = ri.ImportTypeMapping (t);
 
 			return tm;
 		}
 
-		private XmlTypeMapping Map(Type t, SoapAttributeOverrides overrides)
+		private XmlTypeMapping Map (Type t, SoapAttributeOverrides overrides)
 		{
 			SoapReflectionImporter ri = new SoapReflectionImporter(overrides);
 			XmlTypeMapping tm = ri.ImportTypeMapping(t);
@@ -54,26 +56,37 @@
 		private XmlMembersMapping MembersMap (Type t, SoapAttributeOverrides overrides, 
 			XmlReflectionMember [] members, bool inContainer, bool writeAccessors)
 		{
-			SoapReflectionImporter ri = new SoapReflectionImporter(overrides);
-			XmlMembersMapping mm = ri.ImportMembersMapping(null, null, members, 
+			SoapReflectionImporter ri = new SoapReflectionImporter (overrides);
+			XmlMembersMapping mm = ri.ImportMembersMapping (null, null, members, 
 				inContainer, writeAccessors);
 			
 			return mm;
 		}
 		
 		[Test]
-		[Category ("NotWorking")]
-		public void TestIntTypeMapping()
+		public void TestIntTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (int));
 			Assert.AreEqual ("int", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Int32", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Int32", tm.TypeFullName, "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestIntTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (int), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (int[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (int[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestIntTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (int[]));
@@ -95,31 +108,32 @@
 			Assert.AreEqual ("Int32[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("System.Int32[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (int[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfInt", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfInt32", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("Int32[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("System.Int32[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
-		public void TestStringTypeMapping()
+		public void TestStringTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (string));
 			Assert.AreEqual ("string", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("String", tm.TypeName, "#3");
 			Assert.AreEqual ("System.String", tm.TypeFullName, "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestStringTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (string), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (string[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (string[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestStringTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (string[]));
@@ -141,31 +155,32 @@
 			Assert.AreEqual ("String[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("System.String[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (string[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfString", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfString", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("String[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("System.String[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
-		public void TestObjectTypeMapping()
+		public void TestObjectTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (object));
 			Assert.AreEqual ("anyType", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Object", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Object", tm.TypeFullName, "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestObjectTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (object), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (object[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (object[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestObjectTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (object[]));
@@ -187,36 +202,37 @@
 			Assert.AreEqual ("Object[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("System.Object[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (object[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfAnyType", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfObject", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("Object[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("System.Object[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestByteTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (byte));
 			Assert.AreEqual ("unsignedByte", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Byte", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Byte", tm.TypeFullName, "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestByteTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (byte), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (byte[]), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (byte[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestByteTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (byte[]));
 			Assert.AreEqual ("base64Binary", tm.ElementName, "#A1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#A2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#A2");
 			Assert.AreEqual ("Byte[]", tm.TypeName, "#A3");
 			Assert.AreEqual ("System.Byte[]", tm.TypeFullName, "#A4");
 
@@ -229,119 +245,216 @@
 			Assert.AreEqual ("Byte[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("System.Byte[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (byte[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfBase64Binary", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfByte", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("Byte[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("System.Byte[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestBoolTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (bool));
 			Assert.AreEqual ("boolean", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Boolean", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Boolean", tm.TypeFullName, "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestBoolTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (bool), "http://somenamespace");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (bool[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (bool[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestShortTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (short));
 			Assert.AreEqual ("short", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Int16", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Int16", tm.TypeFullName, "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestShortTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (short), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (short[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (short[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestUnsignedShortTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (ushort));
 			Assert.AreEqual ("unsignedShort", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("UInt16", tm.TypeName, "#3");
 			Assert.AreEqual ("System.UInt16", tm.TypeFullName, "#4");
 		}
-		
+
 		[Test]
-		[Category ("NotWorking")]
+		public void TestUnsignedShortTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (ushort), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (ushort[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (ushort[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestUIntTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (uint));
 			Assert.AreEqual ("unsignedInt", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("UInt32", tm.TypeName, "#3");
 			Assert.AreEqual ("System.UInt32", tm.TypeFullName, "#4");
 		}
-		
+
 		[Test]
-		[Category ("NotWorking")]
+		public void TestUIntTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (uint), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (uint[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (uint[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestLongTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (long));
 			Assert.AreEqual ("long", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Int64", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Int64", tm.TypeFullName, "#4");
 		}
-		
+
 		[Test]
-		[Category ("NotWorking")]
+		public void TestLongTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (long), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (long[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (long[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestULongTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (ulong));
 			Assert.AreEqual ("unsignedLong", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("UInt64", tm.TypeName, "#3");
 			Assert.AreEqual ("System.UInt64", tm.TypeFullName, "#4");
 		}
-		
+
 		[Test]
-		[Category ("NotWorking")]
+		public void TestULongTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (ulong), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (ulong[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (ulong[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestFloatTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (float));
 			Assert.AreEqual ("float", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Single", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Single", tm.TypeFullName, "#4");
 		}
-		
+
 		[Test]
-		[Category ("NotWorking")]
+		public void TestFloatTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (float), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (float[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (float[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestDoubleTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (double));
 			Assert.AreEqual ("double", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Double", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Double", tm.TypeFullName, "#4");
 		}
-		
+
 		[Test]
-		[Category ("NotWorking")]
+		public void TestDoubleTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (double), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (double[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (double[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestDateTimeTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (DateTime));
 			Assert.AreEqual ("dateTime", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("DateTime", tm.TypeName, "#3");
 			Assert.AreEqual ("System.DateTime", tm.TypeFullName, "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestDateTimeTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (DateTime), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (DateTime[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (DateTime[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestDateTimeTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (DateTime[]));
@@ -363,31 +476,32 @@
 			Assert.AreEqual ("DateTime[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("System.DateTime[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (DateTime[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfDateTime", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfDateTime", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("DateTime[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("System.DateTime[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestGuidTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (Guid));
 			Assert.AreEqual ("guid", tm.ElementName, "#1");
-			Assert.AreEqual ("http://microsoft.com/wsdl/types/", tm.Namespace, "#2");
+			Assert.AreEqual (WsdlTypesNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Guid", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Guid", tm.TypeFullName, "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestGuidTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (Guid), SomeNamespace);
+			Assert.AreEqual (WsdlTypesNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (Guid[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (Guid[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestGuidTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (Guid[]));
@@ -409,65 +523,149 @@
 			Assert.AreEqual ("Guid[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("System.Guid[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (Guid[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfGuid", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfGuid", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("Guid[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("System.Guid[][][]", tm.TypeFullName, "#C4");
 		}
 		
 		[Test]
-		[Category ("NotWorking")]
-		public void TestDecimalTypeMapping()
+		public void TestDecimalTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (decimal));
 			Assert.AreEqual ("decimal", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Decimal", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Decimal", tm.TypeFullName, "#4");
 		}
-		
+
 		[Test]
-		[Category ("NotWorking")]
-		public void TestXmlQualifiedNameTypeMapping()
+		public void TestDecimalTypeMapping_DefaultNamespace ()
 		{
+			XmlTypeMapping tm = Map (typeof (decimal), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (decimal[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (decimal[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
+		public void TestXmlQualifiedNameTypeMapping ()
+		{
 			XmlTypeMapping tm = Map (typeof (XmlQualifiedName));
 			Assert.AreEqual ("QName", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("XmlQualifiedName", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Xml.XmlQualifiedName", tm.TypeFullName, "#4");
 		}
+
+		[Test]
+		public void TestXmlQualifiedNameTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (XmlQualifiedName), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (XmlQualifiedName[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (XmlQualifiedName[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
+		public void TestXmlQualifiedNameTypeMapping_Array ()
+		{
+			XmlTypeMapping tm = Map (typeof (XmlQualifiedName[]));
+			Assert.AreEqual ("ArrayOfQName", tm.ElementName, "#A1");
+			Assert.AreEqual (string.Empty, tm.Namespace, "#A2");
+#if NET_2_0
+			Assert.AreEqual ("ArrayOfXmlQualifiedName", tm.TypeName, "#A3");
+#else
+			Assert.AreEqual ("XmlQualifiedName[]", tm.TypeName, "#A3");
+#endif
+			Assert.AreEqual ("System.Xml.XmlQualifiedName[]", tm.TypeFullName, "#A4");
+
+			tm  = Map (typeof (XmlQualifiedName[][]));
+			Assert.AreEqual ("ArrayOfArrayOfQName", tm.ElementName, "#B1");
+			Assert.AreEqual (string.Empty, tm.Namespace, "#B2");
+#if NET_2_0
+			Assert.AreEqual ("ArrayOfArrayOfXmlQualifiedName", tm.TypeName, "#B3");
+#else
+			Assert.AreEqual ("XmlQualifiedName[][]", tm.TypeName, "#B3");
+#endif
+			Assert.AreEqual ("System.Xml.XmlQualifiedName[][]", tm.TypeFullName, "#B4");
+		}
 		
 		[Test]
-		[Category ("NotWorking")]
-		public void TestSByteTypeMapping()
+		public void TestSByteTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (sbyte));
 			Assert.AreEqual ("byte", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("SByte", tm.TypeName, "#3");
 			Assert.AreEqual ("System.SByte", tm.TypeFullName, "#4");
 		}
-		
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestSByteTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (sbyte), SomeNamespace);
+			Assert.AreEqual (XmlSchemaNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (sbyte[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (sbyte[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
+		public void TestSByteTypeMapping_Array ()
+		{
+			XmlTypeMapping tm = Map (typeof (sbyte[]));
+			Assert.AreEqual ("ArrayOfByte", tm.ElementName, "#A1");
+			Assert.AreEqual (string.Empty, tm.Namespace, "#A2");
+#if NET_2_0
+			Assert.AreEqual ("ArrayOfSByte", tm.TypeName, "#A3");
+#else
+			Assert.AreEqual ("SByte[]", tm.TypeName, "#A3");
+#endif
+			Assert.AreEqual ("System.SByte[]", tm.TypeFullName, "#A4");
+
+			tm = Map (typeof (sbyte[][]));
+			Assert.AreEqual ("ArrayOfArrayOfByte", tm.ElementName, "#B1");
+			Assert.AreEqual (string.Empty, tm.Namespace, "#B2");
+#if NET_2_0
+			Assert.AreEqual ("ArrayOfArrayOfSByte", tm.TypeName, "#B3");
+#else
+			Assert.AreEqual ("SByte[][]", tm.TypeName, "#B3");
+#endif
+			Assert.AreEqual ("System.SByte[][]", tm.TypeFullName, "#B4");
+		}
+
+		[Test]
 		public void TestCharTypeMapping()
 		{
 			XmlTypeMapping tm = Map (typeof (char));
 			Assert.AreEqual ("char", tm.ElementName, "#1");
-			Assert.AreEqual ("http://microsoft.com/wsdl/types/", tm.Namespace, "#2");
+			Assert.AreEqual (WsdlTypesNamespace, tm.Namespace, "#2");
 			Assert.AreEqual ("Char", tm.TypeName, "#3");
 			Assert.AreEqual ("System.Char", tm.TypeFullName, "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestCharTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (char), SomeNamespace);
+			Assert.AreEqual (WsdlTypesNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (char[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (char[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestCharTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (char[]));
@@ -489,44 +687,159 @@
 			Assert.AreEqual ("Char[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("System.Char[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (char[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfChar", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfChar", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("Char[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("System.Char[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
-		[ExpectedException (typeof (NotSupportedException))] // The type System.Xml.XmlNode may not be serialized with SOAP-encoded messages.
 		public void TestXmlNodeTypeMapping ()
 		{
-			Map (typeof (XmlNode));
+			try {
+				Map (typeof (XmlNode));
+				Assert.Fail ("#1");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNode may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlNode[]));
+				Assert.Fail ("#2");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNode may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlNode[][]));
+				Assert.Fail ("#3");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNode may not be serialized with SOAP-encoded messages.
+			}
 		}
 
 		[Test]
-		[Category ("NotWorking")]
-		[ExpectedException (typeof (NotSupportedException))] // The type System.Xml.XmlElement may not be serialized with SOAP-encoded messages.
+		public void TestXmlNodeTypeMapping_DefaultNamespace ()
+		{
+			try {
+				Map (typeof (XmlNode), SomeNamespace);
+				Assert.Fail ("#1");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNode may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlNode[]), SomeNamespace);
+				Assert.Fail ("#2");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNode may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlNode[][]), SomeNamespace);
+				Assert.Fail ("#3");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNode may not be serialized with SOAP-encoded messages.
+			}
+		}
+
+		[Test]
 		public void TestXmlElementTypeMapping ()
 		{
-			Map (typeof (XmlElement));
+			try {
+				Map (typeof (XmlElement));
+				Assert.Fail ("#1");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlElement may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlElement[]));
+				Assert.Fail ("#2");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlElement may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlElement[][]));
+				Assert.Fail ("#3");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlElement may not be serialized with SOAP-encoded messages.
+			}
 		}
 
 		[Test]
-		[Category ("NotWorking")]
-		[ExpectedException (typeof (NotSupportedException))] // The type System.Xml.XmlNotation may not be serialized with SOAP-encoded messages.
+		public void TestXmlElementTypeMapping_DefaultNamespace ()
+		{
+			try {
+				Map (typeof (XmlElement), SomeNamespace);
+				Assert.Fail ("#1");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlElement may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlElement[]), SomeNamespace);
+				Assert.Fail ("#2");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlElement may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlElement[][]), SomeNamespace);
+				Assert.Fail ("#3");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlElement may not be serialized with SOAP-encoded messages.
+			}
+		}
+
+		[Test]
 		public void TestXmlNotationTypeMapping ()
 		{
-			Map (typeof (XmlNotation));
+			try {
+				Map (typeof (XmlNotation));
+				Assert.Fail ("#1");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNotation may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlNotation[]));
+				Assert.Fail ("#2");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNotation may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlNotation[][]));
+				Assert.Fail ("#3");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNotation may not be serialized with SOAP-encoded messages.
+			}
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestXmlNotationTypeMapping_DefaultNamespace ()
+		{
+			try {
+				Map (typeof (XmlNotation), SomeNamespace);
+				Assert.Fail ("#1");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNotation may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlNotation[]), SomeNamespace);
+				Assert.Fail ("#2");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNotation may not be serialized with SOAP-encoded messages.
+			}
+
+			try {
+				Map (typeof (XmlNotation[][]), SomeNamespace);
+				Assert.Fail ("#3");
+			} catch (NotSupportedException) {
+				// The type System.Xml.XmlNotation may not be serialized with SOAP-encoded messages.
+			}
+		}
+
+		[Test]
 		[ExpectedException (typeof (NotSupportedException))]
 		public void TestXmlSerializableTypeMapping ()
 		{
@@ -542,7 +855,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (ArgumentNullException))]
 		public void TestNullTypeMapping()
 		{
@@ -550,18 +862,13 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
-		public void TestIntTypeMappingWithDefaultNamespaces()
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void TestNullTypeMapping_DefaultNamespace ()
 		{
-			XmlTypeMapping tm = Map (typeof (int), SomeNamespace);
-			Assert.AreEqual ("int", tm.ElementName, "#1");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", tm.Namespace, "#2");
-			Assert.AreEqual ("Int32", tm.TypeName, "#3");
-			Assert.AreEqual ("System.Int32", tm.TypeFullName, "#4");
+			Map (null, SomeNamespace);
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestStructTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (TimeSpan));
@@ -572,7 +879,25 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestStructTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (TimeSpan), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#1");
+
+			try {
+				tm = Map (typeof (TimeSpan[]), SomeNamespace);
+				Assert.Fail ("#2");
+			} catch (NotSupportedException) {
+			}
+
+			try {
+				tm = Map (typeof (TimeSpan[][]), SomeNamespace);
+				Assert.Fail ("#3");
+			} catch (NotSupportedException) {
+			}
+		}
+
+		[Test]
 		[ExpectedException (typeof (NotSupportedException))] // Arrays of structs are not supported with encoded SOAP.
 		public void TestStructTypeMapping_Array ()
 		{
@@ -580,7 +905,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestEnumTypeMapping ()
 		{
 			XmlTypeMapping tm = Map (typeof (AttributeTargets));
@@ -591,7 +915,19 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestEnumTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (AttributeTargets), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (AttributeTargets[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (AttributeTargets[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestEnumTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (AttributeTargets[]));
@@ -613,20 +949,9 @@
 			Assert.AreEqual ("AttributeTargets[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("System.AttributeTargets[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (AttributeTargets[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfAttributeTargets", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfAttributeTargets", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("AttributeTargets[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("System.AttributeTargets[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TestClassTypeMapping()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClass));
@@ -637,7 +962,19 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void TestClassTypeMapping_DefaultNamespace ()
+		{
+			XmlTypeMapping tm = Map (typeof (SimpleClass), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#1");
+
+			tm = Map (typeof (SimpleClass[]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#2");
+
+			tm = Map (typeof (SimpleClass[][]), SomeNamespace);
+			Assert.AreEqual (SomeNamespace, tm.Namespace, "#3");
+		}
+
+		[Test]
 		public void TestClassTypeMapping_Array ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClass[]));
@@ -659,20 +996,9 @@
 			Assert.AreEqual ("SimpleClass[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("MonoTests.System.Xml.TestClasses.SimpleClass[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (SimpleClass[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfSimpleClass", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfSimpleClass", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("SimpleClass[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("MonoTests.System.Xml.TestClasses.SimpleClass[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_IEnumerable_SimpleClass ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClassEnumerable));
@@ -700,20 +1026,9 @@
 			Assert.AreEqual ("SimpleClassEnumerable[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.SimpleClassEnumerable[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (SimpleClassEnumerable[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfArrayOfSimpleClass", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfSimpleClassEnumerable", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("SimpleClassEnumerable[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.SimpleClassEnumerable[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_IEnumerable_Object ()
 		{
 			XmlTypeMapping tm = Map (typeof (ObjectEnumerable));
@@ -741,20 +1056,9 @@
 			Assert.AreEqual ("ObjectEnumerable[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.ObjectEnumerable[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (ObjectEnumerable[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfArrayOfAnyType", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfObjectEnumerable", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("ObjectEnumerable[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.ObjectEnumerable[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_IEnumarable_Object_NoMatchingAddMethod ()
 		{
@@ -762,7 +1066,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_IEnumarable_Object_NoMatchingAddMethod_Array ()
 		{
@@ -770,7 +1073,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_IEnumerable_SimpleClass_PrivateCurrent ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClassEnumerablePrivateCurrent));
@@ -798,23 +1100,12 @@
 			Assert.AreEqual ("SimpleClassEnumerablePrivateCurrent[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.SimpleClassEnumerablePrivateCurrent[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (SimpleClassEnumerablePrivateCurrent[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfArrayOfAnyType", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfSimpleClassEnumerablePrivateCurrent", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("SimpleClassEnumerablePrivateCurrent[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.SimpleClassEnumerablePrivateCurrent[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
 #if ONLY_1_1
 		[Category ("NotDotNet")] // results in NullReferenceException in .NET 1.1 (SP1)
 #endif
-		[Category ("NotWorking")]
 		public void TypeMapping_IEnumerable_SimpleClass_PrivateGetEnumerator ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClassEnumerablePrivateGetEnumerator));
@@ -842,20 +1133,9 @@
 			Assert.AreEqual ("SimpleClassEnumerablePrivateGetEnumerator[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.SimpleClassEnumerablePrivateGetEnumerator[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (SimpleClassEnumerablePrivateGetEnumerator[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfArrayOfAnyType", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfSimpleClassEnumerablePrivateGetEnumerator", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("SimpleClassEnumerablePrivateGetEnumerator[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.SimpleClassEnumerablePrivateGetEnumerator[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_Object_NoMatchingAddMethod ()
 		{
@@ -863,7 +1143,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_Object_NoMatchingAddMethod_Array ()
 		{
@@ -871,7 +1150,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_SimpleClass_NoMatchingAddMethod ()
 		{
@@ -879,7 +1157,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_SimpleClass_NoMatchingAddMethod_Array ()
 		{
@@ -887,7 +1164,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_ICollection_SimpleClass ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClassCollection));
@@ -915,20 +1191,9 @@
 			Assert.AreEqual ("SimpleClassCollection[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.SimpleClassCollection[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (SimpleClassCollection[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfArrayOfSimpleClass", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfSimpleClassCollection", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("SimpleClassCollection[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.SimpleClassCollection[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void TypeMapping_ICollection_Object ()
 		{
 			XmlTypeMapping tm = Map (typeof (ObjectCollection));
@@ -956,20 +1221,9 @@
 			Assert.AreEqual ("ObjectCollection[][]", tm.TypeName, "#B3");
 #endif
 			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.ObjectCollection[][]", tm.TypeFullName, "#B4");
-
-			tm = Map (typeof (ObjectCollection[][][]));
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfArrayOfAnyType", tm.ElementName, "#C1");
-			Assert.AreEqual (string.Empty, tm.Namespace, "#C2");
-#if NET_2_0
-			Assert.AreEqual ("ArrayOfArrayOfArrayOfObjectCollection", tm.TypeName, "#C3");
-#else
-			Assert.AreEqual ("ObjectCollection[][][]", tm.TypeName, "#C3");
-#endif
-			Assert.AreEqual ("MonoTests.System.XmlSerialization.SoapReflectionImporterTests.ObjectCollection[][][]", tm.TypeFullName, "#C4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_Object_NoIntIndexer ()
 		{
@@ -977,7 +1231,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_Object_NoIntIndexer_Array ()
 		{
@@ -985,7 +1238,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_SimpleClass_NoIntIndexer ()
 		{
@@ -993,7 +1245,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		[ExpectedException (typeof (InvalidOperationException))]
 		public void TypeMapping_ICollection_SimpleClass_NoIntIndexer_Array ()
 		{
@@ -1038,7 +1289,7 @@
 			Assert.IsNull (smm.Namespace, "#4");
 			Assert.AreEqual ("System.String", smm.TypeFullName, "#5");
 			Assert.AreEqual ("string", smm.TypeName, "#6");
-			Assert.AreEqual ("http://www.w3.org/2001/XMLSchema", smm.TypeNamespace, "#7");
+			Assert.AreEqual (XmlSchemaNamespace, smm.TypeNamespace, "#7");
 
 			
 			rm = new XmlReflectionMember();
Index: Test/System.Xml.Serialization/ChangeLog
===================================================================
--- Test/System.Xml.Serialization/ChangeLog	(revision 55191)
+++ Test/System.Xml.Serialization/ChangeLog	(working copy)
@@ -1,4 +1,4 @@
-2006-01-07  Gert Driesen  <drieseng@users.sourceforge.net>
+2006-01-22  Gert Driesen  <drieseng@users.sourceforge.net>
 
 	* XmlReflectionImporterTests.cs: Added numerous tests. No longer
 	derive from Assertion.
@@ -6,6 +6,8 @@
 	* XmlSchemaImporterTests.cs: Added numerous tests.
 	* XmlSchemaExporterTests.cs: Added numerous tests.
 	* SoapSchemaExporterTests.cs: Added numerous tests.
+ 	* XmlSerializerTestClasses.cs: Added test classes for 
+	XmlSchemaExporter. Fixed line endings (to CRLF).
 
 2005-12-29  Gert Driesen  <drieseng@users.sourceforge.net>
 
Index: Test/System.Xml.Serialization/XmlSchemaImporterTests.cs
===================================================================
--- Test/System.Xml.Serialization/XmlSchemaImporterTests.cs	(revision 55191)
+++ Test/System.Xml.Serialization/XmlSchemaImporterTests.cs	(working copy)
@@ -24,6 +24,8 @@
 	[TestFixture]
 	public class XmlSchemaImporterTests
 	{
+		private const string WsdlTypesNamespace = "http://microsoft.com/wsdl/types/";
+
 		[Test]
 		[Category ("NotWorking")]
 		public void ImportTypeMapping_Struct ()
@@ -43,7 +45,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void ImportTypeMapping_XsdPrimitive_AnyType ()
 		{
 			XmlSchemas schemas = ExportType (typeof (object));
@@ -283,20 +284,11 @@
 
 		[Test]
 		[Category ("NotWorking")]
+		[ExpectedException (typeof (XmlSchemaException))] // Type 'http://microsoft.com/wsdl/types/:guid' is not declared
 		public void ImportTypeMapping_XsdPrimitive_Guid ()
 		{
 			XmlSchemas schemas = ExportType (typeof (Guid));
-			ArrayList qnames = GetXmlQualifiedNames (schemas);
-			Assert.AreEqual (1, qnames.Count, "#1");
-
-			XmlSchemaImporter importer = new XmlSchemaImporter (schemas);
-			XmlTypeMapping map = importer.ImportTypeMapping ((XmlQualifiedName) qnames[0]);
-
-			Assert.IsNotNull (map, "#2");
-			Assert.AreEqual ("int", map.ElementName, "#3");
-			Assert.AreEqual ("NSInt32", map.Namespace, "#4");
-			Assert.AreEqual ("System.Int32", map.TypeFullName, "#5");
-			Assert.AreEqual ("Int32", map.TypeName, "#6");
+			GetXmlQualifiedNames (schemas);
 		}
 
 		[Test]
@@ -335,20 +327,11 @@
 
 		[Test]
 		[Category ("NotWorking")]
+		[ExpectedException (typeof (XmlSchemaException))] // Type 'http://microsoft.com/wsdl/types/:char' is not declared
 		public void ImportTypeMapping_XsdPrimitive_Char ()
 		{
 			XmlSchemas schemas = ExportType (typeof (char));
-			ArrayList qnames = GetXmlQualifiedNames (schemas);
-			Assert.AreEqual (1, qnames.Count, "#1");
-
-			XmlSchemaImporter importer = new XmlSchemaImporter (schemas);
-			XmlTypeMapping map = importer.ImportTypeMapping ((XmlQualifiedName) qnames[0]);
-
-			Assert.IsNotNull (map, "#2");
-			Assert.AreEqual ("int", map.ElementName, "#3");
-			Assert.AreEqual ("NSChar", map.Namespace, "#4");
-			Assert.AreEqual ("System.Int32", map.TypeFullName, "#5");
-			Assert.AreEqual ("Int32", map.TypeName, "#6");
+			GetXmlQualifiedNames (schemas);
 		}
 
 		[Test]
Index: Test/System.Xml.Serialization/XmlSchemaExporterTests.cs
===================================================================
--- Test/System.Xml.Serialization/XmlSchemaExporterTests.cs	(revision 55191)
+++ Test/System.Xml.Serialization/XmlSchemaExporterTests.cs	(working copy)
@@ -24,16 +24,40 @@
 	[TestFixture]
 	public class XmlSchemaExporterTests
 	{
-		[Test]
-		[Category ("NotWorking")] // on Mono, element is output before type
-		public void ExportStruct ()
+		private XmlSchemas Export (Type type)
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NSTimeSpan");
+			return Export (type, string.Empty);
+		}
+
+		private XmlSchemas Export (Type type, string defaultNamespace)
+		{
+			XmlReflectionImporter ri = new XmlReflectionImporter (defaultNamespace);
 			XmlSchemas schemas = new XmlSchemas ();
 			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (TimeSpan));
+			XmlTypeMapping tm = ri.ImportTypeMapping (type);
 			sx.ExportTypeMapping (tm);
+			return schemas;
+		}
 
+		private XmlSchemas Export (Type type, XmlAttributeOverrides overrides)
+		{
+			return Export (type, overrides, string.Empty);
+		}
+
+		private XmlSchemas Export (Type type, XmlAttributeOverrides overrides, string defaultNamespace)
+		{
+			XmlReflectionImporter ri = new XmlReflectionImporter (overrides, defaultNamespace);
+			XmlSchemas schemas = new XmlSchemas ();
+			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
+			XmlTypeMapping tm = ri.ImportTypeMapping (type);
+			sx.ExportTypeMapping (tm);
+			return schemas;
+		}
+
+		[Test]
+		public void ExportStruct ()
+		{
+			XmlSchemas schemas = Export (typeof (TimeSpan), "NSTimeSpan");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -45,18 +69,25 @@
 				"  <xs:element name=\"TimeSpan\" type=\"tns:TimeSpan\" />{0}" +
 				"  <xs:complexType name=\"TimeSpan\" />{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (TimeSpan));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:element name=\"TimeSpan\" type=\"TimeSpan\" />{0}" +
+				"  <xs:complexType name=\"TimeSpan\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // on Mono, element is output before type
 		public void ExportStruct_Array ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NSTimeSpanArray");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (TimeSpan[]));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (TimeSpan[]), "NSTimeSpanArray");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -65,19 +96,52 @@
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
 				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
 				"<xs:schema xmlns:tns=\"NSTimeSpanArray\" elementFormDefault=\"qualified\" targetNamespace=\"NSTimeSpanArray\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
 				"  <xs:element name=\"ArrayOfTimeSpan\" nillable=\"true\" type=\"tns:ArrayOfTimeSpan\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfTimeSpan\" type=\"tns:ArrayOfTimeSpan\" />{0}" +
+#endif
 				"  <xs:complexType name=\"ArrayOfTimeSpan\">{0}" +
 				"    <xs:sequence>{0}" +
+#if MS // bug #77117
 				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TimeSpan\" type=\"tns:TimeSpan\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TimeSpan\" nillable=\"true\" type=\"tns:TimeSpan\" />{0}" +
+#endif
 				"    </xs:sequence>{0}" +
 				"  </xs:complexType>{0}" +
 				"  <xs:complexType name=\"TimeSpan\" />{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (TimeSpan[]));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayOfTimeSpan\" nillable=\"true\" type=\"ArrayOfTimeSpan\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfTimeSpan\" type=\"ArrayOfTimeSpan\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayOfTimeSpan\">{0}" +
+				"    <xs:sequence>{0}" +
+#if MS // bug #77117
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TimeSpan\" type=\"TimeSpan\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TimeSpan\" nillable=\"true\" type=\"TimeSpan\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"TimeSpan\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // on Mono, element is output before type
-		public void ExportClass ()
+		public void ExportClass_SimpleClass ()
 		{
 			XmlAttributeOverrides overrides = new XmlAttributeOverrides ();
 			XmlAttributes attr = new XmlAttributes ();
@@ -87,12 +151,7 @@
 			attr.XmlElements.Add (element);
 			overrides.Add (typeof (SimpleClass), "something", attr);
 
-			XmlReflectionImporter ri = new XmlReflectionImporter (overrides, "NS1");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (SimpleClass));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (SimpleClass), overrides, "NSSimpleClass");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -100,30 +159,1111 @@
 
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
 				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
-				"<xs:schema xmlns:tns=\"NS1\" elementFormDefault=\"qualified\" targetNamespace=\"NS1\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"<xs:schema xmlns:tns=\"NSSimpleClass\" elementFormDefault=\"qualified\" targetNamespace=\"NSSimpleClass\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
 				"  <xs:element name=\"SimpleClass\" nillable=\"true\" type=\"tns:SimpleClass\" />{0}" +
+#else
+				"  <xs:element name=\"SimpleClass\" type=\"tns:SimpleClass\" />{0}" +
+#endif
 				"  <xs:complexType name=\"SimpleClass\">{0}" +
 				"    <xs:sequence>{0}" +
 				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"saying\" nillable=\"true\" type=\"xs:string\" />{0}" +
 				"    </xs:sequence>{0}" +
 				"  </xs:complexType>{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (SimpleClass), overrides);
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"SimpleClass\" nillable=\"true\" type=\"SimpleClass\" />{0}" +
+#else
+				"  <xs:element name=\"SimpleClass\" type=\"SimpleClass\" />{0}" +
+#endif
+				"  <xs:complexType name=\"SimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"saying\" nillable=\"true\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
+		public void ExportClass_StringCollection ()
+		{
+			XmlSchemas schemas = Export (typeof (StringCollection), "NSStringCollection");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSStringCollection\" elementFormDefault=\"qualified\" targetNamespace=\"NSStringCollection\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayOfString\" nillable=\"true\" type=\"tns:ArrayOfString\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfString\" type=\"tns:ArrayOfString\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"string\" nillable=\"true\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (StringCollection));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayOfString\" nillable=\"true\" type=\"ArrayOfString\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfString\" type=\"ArrayOfString\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"string\" nillable=\"true\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_StringCollectionContainer ()
+		{
+			XmlSchemas schemas = Export (typeof (StringCollectionContainer), "NSStringCollectionContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSStringCollectionContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSStringCollectionContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"StringCollectionContainer\" nillable=\"true\" type=\"tns:StringCollectionContainer\" />{0}" +
+#else
+				"  <xs:element name=\"StringCollectionContainer\" type=\"tns:StringCollectionContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"StringCollectionContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Messages\" type=\"tns:ArrayOfString\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"string\" nillable=\"true\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (StringCollectionContainer));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"StringCollectionContainer\" nillable=\"true\" type=\"StringCollectionContainer\" />{0}" +
+#else
+				"  <xs:element name=\"StringCollectionContainer\" type=\"StringCollectionContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"StringCollectionContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Messages\" type=\"ArrayOfString\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"string\" nillable=\"true\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_ArrayContainer ()
+		{
+			XmlSchemas schemas = Export (typeof (ArrayContainer), "NSArrayContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSArrayContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSArrayContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayContainer\" nillable=\"true\" type=\"tns:ArrayContainer\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayContainer\" type=\"tns:ArrayContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"items\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (ArrayContainer));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayContainer\" nillable=\"true\" type=\"ArrayContainer\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayContainer\" type=\"ArrayContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"items\" type=\"ArrayOfAnyType\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_ClassArrayContainer ()
+		{
+			XmlSchemas schemas = Export (typeof (ClassArrayContainer), "NSClassArrayContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSClassArrayContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSClassArrayContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ClassArrayContainer\" nillable=\"true\" type=\"tns:ClassArrayContainer\" />{0}" +
+#else
+				"  <xs:element name=\"ClassArrayContainer\" type=\"tns:ClassArrayContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ClassArrayContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"items\" type=\"tns:ArrayOfSimpleClass\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfSimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"SimpleClass\" nillable=\"true\" type=\"tns:SimpleClass\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"SimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"something\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (ClassArrayContainer));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ClassArrayContainer\" nillable=\"true\" type=\"ClassArrayContainer\" />{0}" +
+#else
+				"  <xs:element name=\"ClassArrayContainer\" type=\"ClassArrayContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ClassArrayContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"items\" type=\"ArrayOfSimpleClass\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfSimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"SimpleClass\" nillable=\"true\" type=\"SimpleClass\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"SimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"something\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_SimpleClassWithXmlAttributes ()
+		{
+			XmlSchemas schemas = Export (typeof (SimpleClassWithXmlAttributes), "NSSimpleClassWithXmlAttributes");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSSimpleClassWithXmlAttributes\" elementFormDefault=\"qualified\" targetNamespace=\"NSSimpleClassWithXmlAttributes\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"simple\" nillable=\"true\" type=\"tns:SimpleClassWithXmlAttributes\" />{0}" +
+#else
+				"  <xs:element name=\"simple\" type=\"tns:SimpleClassWithXmlAttributes\" />{0}" +
+#endif
+				"  <xs:complexType name=\"SimpleClassWithXmlAttributes\">{0}" +
+				"    <xs:attribute name=\"member\" type=\"xs:string\" />{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (SimpleClassWithXmlAttributes));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"simple\" nillable=\"true\" type=\"SimpleClassWithXmlAttributes\" />{0}" +
+#else
+				"  <xs:element name=\"simple\" type=\"SimpleClassWithXmlAttributes\" />{0}" +
+#endif
+				"  <xs:complexType name=\"SimpleClassWithXmlAttributes\">{0}" +
+				"    <xs:attribute name=\"member\" type=\"xs:string\" />{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_Field ()
+		{
+			XmlSchemas schemas = Export (typeof (Field), "NSField");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSField\" elementFormDefault=\"qualified\" targetNamespace=\"NSField\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"field\" nillable=\"true\" type=\"tns:Field\" />{0}" +
+#else
+				"  <xs:element name=\"field\" type=\"tns:Field\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Field\">{0}" +
+				"    <xs:attribute name=\"modifiers\" type=\"tns:MapModifiers\" use=\"required\" />{0}" +
+				"    <xs:attribute form=\"unqualified\" name=\"modifiers2\" type=\"tns:MapModifiers\" use=\"required\" />{0}" +
+#if MS // Mono does not yet translate default values to corresponding enum fields
+				"    <xs:attribute default=\"public\" name=\"modifiers3\" type=\"tns:MapModifiers\" />{0}" +
+				"    <xs:attribute default=\"public\" form=\"unqualified\" name=\"modifiers4\" type=\"tns:MapModifiers\" />{0}" +
+#else
+				"    <xs:attribute default=\"0\" name=\"modifiers3\" type=\"tns:MapModifiers\" />{0}" +
+				"    <xs:attribute default=\"0\" form=\"unqualified\" name=\"modifiers4\" type=\"tns:MapModifiers\" />{0}" +
+#endif
+				"    <xs:attribute name=\"names\">{0}" +
+				"      <xs:simpleType>{0}" +
+				"        <xs:list itemType=\"xs:string\" />{0}" +
+				"      </xs:simpleType>{0}" +
+				"    </xs:attribute>{0}" +
+				"    <xs:attribute name=\"street\" type=\"xs:string\" />{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:simpleType name=\"MapModifiers\">{0}" +
+				"    <xs:list>{0}" +
+				"      <xs:simpleType>{0}" +
+				"        <xs:restriction base=\"xs:string\">{0}" +
+				"          <xs:enumeration value=\"public\" />{0}" +
+				"          <xs:enumeration value=\"protected\" />{0}" +
+				"        </xs:restriction>{0}" +
+				"      </xs:simpleType>{0}" +
+				"    </xs:list>{0}" +
+				"  </xs:simpleType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (Field));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"field\" nillable=\"true\" type=\"Field\" />{0}" +
+#else
+				"  <xs:element name=\"field\" type=\"Field\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Field\">{0}" +
+				"    <xs:attribute name=\"modifiers\" type=\"MapModifiers\" use=\"required\" />{0}" +
+				"    <xs:attribute form=\"unqualified\" name=\"modifiers2\" type=\"MapModifiers\" use=\"required\" />{0}" +
+#if MS // Mono does not yet translate default values to corresponding enum fields
+				"    <xs:attribute default=\"public\" name=\"modifiers3\" type=\"MapModifiers\" />{0}" +
+				"    <xs:attribute default=\"public\" form=\"unqualified\" name=\"modifiers4\" type=\"MapModifiers\" />{0}" +
+#else
+				"    <xs:attribute default=\"0\" name=\"modifiers3\" type=\"MapModifiers\" />{0}" +
+				"    <xs:attribute default=\"0\" form=\"unqualified\" name=\"modifiers4\" type=\"MapModifiers\" />{0}" +
+#endif
+				"    <xs:attribute name=\"names\">{0}" +
+				"      <xs:simpleType>{0}" +
+				"        <xs:list itemType=\"xs:string\" />{0}" +
+				"      </xs:simpleType>{0}" +
+				"    </xs:attribute>{0}" +
+				"    <xs:attribute name=\"street\" type=\"xs:string\" />{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:simpleType name=\"MapModifiers\">{0}" +
+				"    <xs:list>{0}" +
+				"      <xs:simpleType>{0}" +
+				"        <xs:restriction base=\"xs:string\">{0}" +
+				"          <xs:enumeration value=\"public\" />{0}" +
+				"          <xs:enumeration value=\"protected\" />{0}" +
+				"        </xs:restriction>{0}" +
+				"      </xs:simpleType>{0}" +
+				"    </xs:list>{0}" +
+				"  </xs:simpleType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_MyList ()
+		{
+			XmlSchemas schemas = Export (typeof (MyList), "NSMyList");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSMyList\" elementFormDefault=\"qualified\" targetNamespace=\"NSMyList\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayOfAnyType\" nillable=\"true\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfAnyType\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (MyList));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayOfAnyType\" nillable=\"true\" type=\"ArrayOfAnyType\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfAnyType\" type=\"ArrayOfAnyType\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_Container ()
+		{
+			XmlSchemas schemas = Export (typeof (Container), "NSContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"Container\" nillable=\"true\" type=\"tns:Container\" />{0}" +
+#else
+				"  <xs:element name=\"Container\" type=\"tns:Container\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Container\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Items\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (Container));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"Container\" nillable=\"true\" type=\"Container\" />{0}" +
+#else
+				"  <xs:element name=\"Container\" type=\"Container\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Container\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Items\" type=\"ArrayOfAnyType\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_Container2 ()
+		{
+			XmlSchemas schemas = Export (typeof (Container2), "NSContainer2");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSContainer2\" elementFormDefault=\"qualified\" targetNamespace=\"NSContainer2\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"Container2\" nillable=\"true\" type=\"tns:Container2\" />{0}" +
+#else
+				"  <xs:element name=\"Container2\" type=\"tns:Container2\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Container2\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Items\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (Container2));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"Container2\" nillable=\"true\" type=\"Container2\" />{0}" +
+#else
+				"  <xs:element name=\"Container2\" type=\"Container2\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Container2\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Items\" type=\"ArrayOfAnyType\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
 		[ExpectedException (typeof (InvalidOperationException))] // Cannot use wildcards at the top level of a schema.
+		public void ExportClass_MyElem ()
+		{
+			Export (typeof (MyElem), "NSMyElem");
+		}
+
+		[Test]
+		public void ExportClass_CDataContainer ()
+		{
+			XmlSchemas schemas = Export (typeof (CDataContainer), "NSCDataContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSCDataContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSCDataContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"CDataContainer\" nillable=\"true\" type=\"tns:CDataContainer\" />{0}" +
+#else
+				"  <xs:element name=\"CDataContainer\" type=\"tns:CDataContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"CDataContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"cdata\">{0}" +
+				"        <xs:complexType mixed=\"true\">{0}" +
+				"          <xs:sequence>{0}" +
+				"            <xs:any />{0}" +
+				"          </xs:sequence>{0}" +
+				"        </xs:complexType>{0}" +
+				"      </xs:element>{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (CDataContainer));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"CDataContainer\" nillable=\"true\" type=\"CDataContainer\" />{0}" +
+#else
+				"  <xs:element name=\"CDataContainer\" type=\"CDataContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"CDataContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"cdata\">{0}" +
+				"        <xs:complexType mixed=\"true\">{0}" +
+				"          <xs:sequence>{0}" +
+				"            <xs:any />{0}" +
+				"          </xs:sequence>{0}" +
+				"        </xs:complexType>{0}" +
+				"      </xs:element>{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_NodeContainer ()
+		{
+			XmlSchemas schemas = Export (typeof (NodeContainer), "NSNodeContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSNodeContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSNodeContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"NodeContainer\" nillable=\"true\" type=\"tns:NodeContainer\" />{0}" +
+#else
+				"  <xs:element name=\"NodeContainer\" type=\"tns:NodeContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"NodeContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"node\">{0}" +
+				"        <xs:complexType mixed=\"true\">{0}" +
+				"          <xs:sequence>{0}" +
+				"            <xs:any />{0}" +
+				"          </xs:sequence>{0}" +
+				"        </xs:complexType>{0}" +
+				"      </xs:element>{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (NodeContainer));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"NodeContainer\" nillable=\"true\" type=\"NodeContainer\" />{0}" +
+#else
+				"  <xs:element name=\"NodeContainer\" type=\"NodeContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"NodeContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"node\">{0}" +
+				"        <xs:complexType mixed=\"true\">{0}" +
+				"          <xs:sequence>{0}" +
+				"            <xs:any />{0}" +
+				"          </xs:sequence>{0}" +
+				"        </xs:complexType>{0}" +
+				"      </xs:element>{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		[Category ("NotWorking")] // Mono does not generate the <xs:choice> node
+#if NET_2_0
+		[Category ("NotDotNet")] // MS.NET 2.0 randomly modifies the order of the elements!
+#endif
+		public void ExportClass_Choices ()
+		{
+			XmlSchemas schemas = Export (typeof (Choices), "NSChoices");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSChoices\" elementFormDefault=\"qualified\" targetNamespace=\"NSChoices\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"Choices\" nillable=\"true\" type=\"tns:Choices\" />{0}" +
+#else
+				"  <xs:element name=\"Choices\" type=\"tns:Choices\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Choices\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:choice minOccurs=\"1\" maxOccurs=\"1\">{0}" +
+				"        <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ChoiceOne\" type=\"xs:string\" />{0}" +
+				"        <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ChoiceTwo\" type=\"xs:string\" />{0}" +
+				"        <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ChoiceZero\" type=\"xs:string\" />{0}" +
+				"      </xs:choice>{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (Choices));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"Choices\" nillable=\"true\" type=\"Choices\" />{0}" +
+#else
+				"  <xs:element name=\"Choices\" type=\"Choices\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Choices\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:choice minOccurs=\"1\" maxOccurs=\"1\">{0}" +
+				"        <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ChoiceOne\" type=\"xs:string\" />{0}" +
+				"        <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ChoiceTwo\" type=\"xs:string\" />{0}" +
+				"        <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ChoiceZero\" type=\"xs:string\" />{0}" +
+				"      </xs:choice>{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+#if ONLY_1_1
+		[Category ("NotDotNet")] // MS.NET 1.x does not escape spaces in a type name, bug is fixed in .NET 2.0
+#endif
+		public void ExportClass_TestSpace ()
+		{
+			XmlSchemas schemas = Export (typeof (TestSpace), "NSTestSpace");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSTestSpace\" elementFormDefault=\"qualified\" targetNamespace=\"NSTestSpace\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"Type_x0020_with_x0020_space\" nillable=\"true\" type=\"tns:Type_x0020_with_x0020_space\" />{0}" +
+#else
+				"  <xs:element name=\"Type_x0020_with_x0020_space\" type=\"tns:Type_x0020_with_x0020_space\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Type_x0020_with_x0020_space\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Element_x0020_with_x0020_space\" type=\"xs:int\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"    <xs:attribute name=\"Attribute_x0020_with_x0020_space\" type=\"xs:int\" use=\"required\" />{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (TestSpace));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"Type_x0020_with_x0020_space\" nillable=\"true\" type=\"Type_x0020_with_x0020_space\" />{0}" +
+#else
+				"  <xs:element name=\"Type_x0020_with_x0020_space\" type=\"Type_x0020_with_x0020_space\" />{0}" +
+#endif
+				"  <xs:complexType name=\"Type_x0020_with_x0020_space\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Element_x0020_with_x0020_space\" type=\"xs:int\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"    <xs:attribute name=\"Attribute_x0020_with_x0020_space\" type=\"xs:int\" use=\"required\" />{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_ReadOnlyProperties ()
+		{
+			XmlSchemas schemas = Export (typeof (ReadOnlyProperties), "NSReadOnlyProperties");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSReadOnlyProperties\" elementFormDefault=\"qualified\" targetNamespace=\"NSReadOnlyProperties\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ReadOnlyProperties\" nillable=\"true\" type=\"tns:ReadOnlyProperties\" />{0}" +
+#else
+				"  <xs:element name=\"ReadOnlyProperties\" type=\"tns:ReadOnlyProperties\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ReadOnlyProperties\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (ReadOnlyProperties));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ReadOnlyProperties\" nillable=\"true\" type=\"ReadOnlyProperties\" />{0}" +
+#else
+				"  <xs:element name=\"ReadOnlyProperties\" type=\"ReadOnlyProperties\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ReadOnlyProperties\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_ListDefaults ()
+		{
+			XmlSchemas schemas = Export (typeof (ListDefaults), "NSListDefaults");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSListDefaults\" elementFormDefault=\"qualified\" targetNamespace=\"NSListDefaults\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"root\" nillable=\"true\" type=\"tns:ListDefaults\" />{0}" +
+#else
+				"  <xs:element name=\"root\" type=\"tns:ListDefaults\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ListDefaults\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"list2\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"list3\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"list4\" type=\"tns:ArrayOfString\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"e\" type=\"tns:SimpleClass\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ed\" type=\"tns:SimpleClass\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"str\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"string\" nillable=\"true\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"SimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"something\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (ListDefaults));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"root\" nillable=\"true\" type=\"ListDefaults\" />{0}" +
+#else
+				"  <xs:element name=\"root\" type=\"ListDefaults\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ListDefaults\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"list2\" type=\"ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"list3\" type=\"ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"list4\" type=\"ArrayOfString\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"e\" type=\"SimpleClass\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"ed\" type=\"SimpleClass\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"str\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"string\" nillable=\"true\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"SimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"something\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_ClsPerson ()
+		{
+			XmlSchemas schemas = Export (typeof (clsPerson), "NSClsPerson");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSClsPerson\" elementFormDefault=\"qualified\" targetNamespace=\"NSClsPerson\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"clsPerson\" nillable=\"true\" type=\"tns:clsPerson\" />{0}" +
+#else
+				"  <xs:element name=\"clsPerson\" type=\"tns:clsPerson\" />{0}" +
+#endif
+				"  <xs:complexType name=\"clsPerson\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"EmailAccounts\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (clsPerson));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"clsPerson\" nillable=\"true\" type=\"clsPerson\" />{0}" +
+#else
+				"  <xs:element name=\"clsPerson\" type=\"clsPerson\" />{0}" +
+#endif
+				"  <xs:complexType name=\"clsPerson\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"EmailAccounts\" type=\"ArrayOfAnyType\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_ArrayClass ()
+		{
+			XmlSchemas schemas = Export (typeof (ArrayClass), "NSArrayClass");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSArrayClass\" elementFormDefault=\"qualified\" targetNamespace=\"NSArrayClass\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayClass\" nillable=\"true\" type=\"tns:ArrayClass\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayClass\" type=\"tns:ArrayClass\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"names\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+
+			schemas = Export (typeof (ArrayClass));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayClass\" nillable=\"true\" type=\"ArrayClass\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayClass\" type=\"ArrayClass\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"names\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_StructContainer ()
+		{
+			XmlSchemas schemas = Export (typeof (StructContainer), "NSStructContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSStructContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSStructContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"StructContainer\" nillable=\"true\" type=\"tns:StructContainer\" />{0}" +
+#else
+				"  <xs:element name=\"StructContainer\" type=\"tns:StructContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"StructContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Value\" type=\"tns:EnumDefaultValue\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Times\" type=\"tns:ArrayOfTimeSpan\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:simpleType name=\"EnumDefaultValue\">{0}" +
+				"    <xs:list>{0}" +
+				"      <xs:simpleType>{0}" +
+				"        <xs:restriction base=\"xs:string\">{0}" +
+				"          <xs:enumeration value=\"e1\" />{0}" +
+				"          <xs:enumeration value=\"e2\" />{0}" +
+				"          <xs:enumeration value=\"e3\" />{0}" +
+				"        </xs:restriction>{0}" +
+				"      </xs:simpleType>{0}" +
+				"    </xs:list>{0}" +
+				"  </xs:simpleType>{0}" +
+				"  <xs:complexType name=\"ArrayOfTimeSpan\">{0}" +
+				"    <xs:sequence>{0}" +
+#if MS // bug #77117
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TimeSpan\" type=\"tns:TimeSpan\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TimeSpan\" nillable=\"true\" type=\"tns:TimeSpan\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"TimeSpan\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (StructContainer));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"StructContainer\" nillable=\"true\" type=\"StructContainer\" />{0}" +
+#else
+				"  <xs:element name=\"StructContainer\" type=\"StructContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"StructContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Value\" type=\"EnumDefaultValue\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Times\" type=\"ArrayOfTimeSpan\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:simpleType name=\"EnumDefaultValue\">{0}" +
+				"    <xs:list>{0}" +
+				"      <xs:simpleType>{0}" +
+				"        <xs:restriction base=\"xs:string\">{0}" +
+				"          <xs:enumeration value=\"e1\" />{0}" +
+				"          <xs:enumeration value=\"e2\" />{0}" +
+				"          <xs:enumeration value=\"e3\" />{0}" +
+				"        </xs:restriction>{0}" +
+				"      </xs:simpleType>{0}" +
+				"    </xs:list>{0}" +
+				"  </xs:simpleType>{0}" +
+				"  <xs:complexType name=\"ArrayOfTimeSpan\">{0}" +
+				"    <xs:sequence>{0}" +
+#if MS // bug #77117
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TimeSpan\" type=\"TimeSpan\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"TimeSpan\" nillable=\"true\" type=\"TimeSpan\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"TimeSpan\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))] // Cannot use wildcards at the top level of a schema.
 		public void ExportClass_XmlElement ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NS1");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (XmlElement));
-			sx.ExportTypeMapping (tm);
+			XmlSchemas schemas = Export (typeof (XmlElement), "NS1");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // on Mono, element is output before type
 		public void ExportClass_Array ()
 		{
 			XmlAttributeOverrides overrides = new XmlAttributeOverrides ();
@@ -134,12 +1274,7 @@
 			attr.XmlElements.Add (element);
 			overrides.Add (typeof (SimpleClass), "something", attr);
 
-			XmlReflectionImporter ri = new XmlReflectionImporter (overrides, "NSSimpleClassArray");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (SimpleClass[]));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (SimpleClass[]), overrides, "NSSimpleClassArray");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -148,7 +1283,11 @@
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
 				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
 				"<xs:schema xmlns:tns=\"NSSimpleClassArray\" elementFormDefault=\"qualified\" targetNamespace=\"NSSimpleClassArray\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
 				"  <xs:element name=\"ArrayOfSimpleClass\" nillable=\"true\" type=\"tns:ArrayOfSimpleClass\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfSimpleClass\" type=\"tns:ArrayOfSimpleClass\" />{0}" +
+#endif
 				"  <xs:complexType name=\"ArrayOfSimpleClass\">{0}" +
 				"    <xs:sequence>{0}" +
 				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"SimpleClass\" nillable=\"true\" type=\"tns:SimpleClass\" />{0}" +
@@ -160,18 +1299,38 @@
 				"    </xs:sequence>{0}" +
 				"  </xs:complexType>{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (SimpleClass[]), overrides);
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayOfSimpleClass\" nillable=\"true\" type=\"ArrayOfSimpleClass\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfSimpleClass\" type=\"ArrayOfSimpleClass\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayOfSimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"SimpleClass\" nillable=\"true\" type=\"SimpleClass\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"SimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"saying\" nillable=\"true\" type=\"xs:string\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // on Mono, element is output before type
 		public void ExportEnum ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NSEnumDefaultValue");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (EnumDefaultValue));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (EnumDefaultValue), "NSEnumDefaultValue");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -194,15 +1353,10 @@
 				"  </xs:simpleType>{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
 
-			ri = new XmlReflectionImporter ("NSEnumDefaultValueNF");
-			schemas = new XmlSchemas ();
-			sx = new XmlSchemaExporter (schemas);
-			tm = ri.ImportTypeMapping (typeof (EnumDefaultValueNF));
-			sx.ExportTypeMapping (tm);
-
+			schemas = Export (typeof (EnumDefaultValueNF), "NSEnumDefaultValueNF");
 			Assert.AreEqual (1, schemas.Count, "#3");
 
-			sw = new StringWriter ();
+			sw.GetStringBuilder ().Length = 0; 
 			schemas[0].Write (sw);
 
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
@@ -217,18 +1371,54 @@
 				"    </xs:restriction>{0}" +
 				"  </xs:simpleType>{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+
+			schemas = Export (typeof (EnumDefaultValue));
+			Assert.AreEqual (1, schemas.Count, "#5");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:element name=\"EnumDefaultValue\" type=\"EnumDefaultValue\" />{0}" +
+				"  <xs:simpleType name=\"EnumDefaultValue\">{0}" +
+				"    <xs:list>{0}" +
+				"      <xs:simpleType>{0}" +
+				"        <xs:restriction base=\"xs:string\">{0}" +
+				"          <xs:enumeration value=\"e1\" />{0}" +
+				"          <xs:enumeration value=\"e2\" />{0}" +
+				"          <xs:enumeration value=\"e3\" />{0}" +
+				"        </xs:restriction>{0}" +
+				"      </xs:simpleType>{0}" +
+				"    </xs:list>{0}" +
+				"  </xs:simpleType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#6");
+
+			schemas = Export (typeof (EnumDefaultValueNF));
+			Assert.AreEqual (1, schemas.Count, "#7");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:element name=\"EnumDefaultValueNF\" type=\"EnumDefaultValueNF\" />{0}" +
+				"  <xs:simpleType name=\"EnumDefaultValueNF\">{0}" +
+				"    <xs:restriction base=\"xs:string\">{0}" +
+				"      <xs:enumeration value=\"e1\" />{0}" +
+				"      <xs:enumeration value=\"e2\" />{0}" +
+				"      <xs:enumeration value=\"e3\" />{0}" +
+				"    </xs:restriction>{0}" +
+				"  </xs:simpleType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#8");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // on Mono, element is output before type
 		public void ExportXmlSerializable ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NS3");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (Employee));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (Employee), "NSEmployee");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -236,9 +1426,13 @@
 
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
 				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
-				"<xs:schema xmlns:tns=\"NS3\" elementFormDefault=\"qualified\" targetNamespace=\"NS3\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"<xs:schema xmlns:tns=\"NSEmployee\" elementFormDefault=\"qualified\" targetNamespace=\"NSEmployee\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
 				"  <xs:import namespace=\"http://www.w3.org/2001/XMLSchema\" />{0}" +
+#if MS // bug #77117
 				"  <xs:element name=\"Employee\" nillable=\"true\">{0}" +
+#else
+				"  <xs:element name=\"Employee\">{0}" +
+#endif
 				"    <xs:complexType>{0}" +
 				"      <xs:sequence>{0}" +
 				"        <xs:element ref=\"xs:schema\" />{0}" +
@@ -248,27 +1442,223 @@
 				"  </xs:element>{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
 
-			ri = new XmlReflectionImporter ("NS4");
+			schemas = Export (typeof (Employee));
+			Assert.AreEqual (1, schemas.Count, "#3");
 
-			schemas = new XmlSchemas ();
-			sx = new XmlSchemaExporter (schemas);
-			tm = ri.ImportTypeMapping (typeof (EmployeeSchema));
-			sx.ExportTypeMapping (tm);
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
 
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:import namespace=\"http://www.w3.org/2001/XMLSchema\" />{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"Employee\" nillable=\"true\">{0}" +
+#else
+				"  <xs:element name=\"Employee\">{0}" +
+#endif
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportXmlSerializable_Schema ()
+		{
+			XmlSchemas schemas = Export (typeof (EmployeeSchema), "NSEmployeeSchema");
+			Assert.AreEqual (2, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSEmployeeSchema\" elementFormDefault=\"qualified\" targetNamespace=\"NSEmployeeSchema\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if ONLY_1_1
+				"  <xs:import namespace=\"urn:types-devx-com\" />{0}" +
+#endif
+#if MS // bug #77117
+				"  <xs:element name=\"EmployeeSchema\" nillable=\"true\">{0}" +
+#else
+				"  <xs:element name=\"EmployeeSchema\">{0}" +
+#endif
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:any namespace=\"urn:types-devx-com\" />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[1].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"urn:types-devx-com\" targetNamespace=\"urn:types-devx-com\" id=\"EmployeeSchema\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:complexType name=\"employeeRoot\">{0}" +
+				"    <xs:attribute name=\"firstName\" />{0}" +
+				"    <xs:attribute name=\"lastName\" />{0}" +
+				"    <xs:attribute name=\"address\" />{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:element name=\"employee\" type=\"tns:employeeRoot\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#3");
+
+			schemas = Export (typeof (EmployeeSchema));
+			Assert.AreEqual (2, schemas.Count, "#4");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if ONLY_1_1
+				"  <xs:import namespace=\"urn:types-devx-com\" />{0}" +
+#endif
+#if MS // bug #77117
+				 "  <xs:element name=\"EmployeeSchema\" nillable=\"true\">{0}" +
+#else
+				"  <xs:element name=\"EmployeeSchema\">{0}" +
+#endif
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:any namespace=\"urn:types-devx-com\" />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#5");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[1].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"urn:types-devx-com\" targetNamespace=\"urn:types-devx-com\" id=\"EmployeeSchema\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:complexType name=\"employeeRoot\">{0}" +
+				"    <xs:attribute name=\"firstName\" />{0}" +
+				"    <xs:attribute name=\"lastName\" />{0}" +
+				"    <xs:attribute name=\"address\" />{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:element name=\"employee\" type=\"tns:employeeRoot\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#6");
+
+			schemas = Export (typeof (PrimitiveSchema), "NSPrimitiveSchema");
+			Assert.AreEqual (2, schemas.Count, "#7");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSPrimitiveSchema\" elementFormDefault=\"qualified\" targetNamespace=\"NSPrimitiveSchema\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"PrimitiveSchema\" nillable=\"true\">{0}" +
+#else
+				"  <xs:element name=\"PrimitiveSchema\">{0}" +
+#endif
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:any namespace=\"\" />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#8");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[1].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema id=\"LuckyNumberSchema\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:element name=\"LuckyNumber\" type=\"xs:int\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#9");
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))] // Schema Id is missing
+		public void ExportXmlSerializable_MissingID ()
+		{
+			Export (typeof (MissingIDSchema));
+		}
+
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void ExportXmlSerializable_DuplicateNamespace ()
+		{
+			try {
+				Export (typeof (PrimitiveSchema));
+				Assert.Fail ("#1");
+			} catch (InvalidOperationException) {
+				// The namespace, , is a duplicate.
+			}
+
+			try {
+				Export (typeof (XmlSerializableContainer));
+				Assert.Fail ("#2");
+			} catch (InvalidOperationException) {
+				// The namespace, , is a duplicate.
+			}
+		}
+
+		[Test]
+#if NET_2_0
+		[Category ("NotWorking")] // support for XmlSchemaProvider is not implemented
+#endif
+		public void ExportXmlSerializable_SchemaProvider ()
+		{
+			XmlSchemas schemas = Export (typeof (EmployeeSchemaProvider), "NSEmployeeSchemaProvider");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSEmployeeSchemaProvider\" elementFormDefault=\"qualified\" targetNamespace=\"NSEmployeeSchemaProvider\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if NET_2_0
+				"  <xs:import namespace=\"urn:types-devx-com\" />{0}" +
+				"  <xs:element name=\"employeeRoot\" nillable=\"true\" xmlns:q1=\"urn:types-devx-com\" type=\"q1:employeeRoot\" />{0}" +
+#else
+				"  <xs:import namespace=\"http://www.w3.org/2001/XMLSchema\" />{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"EmployeeSchemaProvider\" nillable=\"true\">{0}" +
+#else
+				"  <xs:element name=\"EmployeeSchemaProvider\">{0}" +
+#endif
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#endif
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (EmployeeSchemaProvider));
 			Assert.AreEqual (1, schemas.Count, "#3");
 
-			sw = new StringWriter ();
+			sw.GetStringBuilder ().Length = 0;
 			schemas[0].Write (sw);
 
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
 				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
-				"<xs:schema xmlns:tns=\"NS4\" elementFormDefault=\"qualified\" targetNamespace=\"NS4\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
 #if NET_2_0
 				"  <xs:import namespace=\"urn:types-devx-com\" />{0}" +
 				"  <xs:element name=\"employeeRoot\" nillable=\"true\" xmlns:q1=\"urn:types-devx-com\" type=\"q1:employeeRoot\" />{0}" +
 #else
 				"  <xs:import namespace=\"http://www.w3.org/2001/XMLSchema\" />{0}" +
-				"  <xs:element name=\"EmployeeSchema\" nillable=\"true\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"EmployeeSchemaProvider\" nillable=\"true\">{0}" +
+#else
+				"  <xs:element name=\"EmployeeSchemaProvider\">{0}" +
+#endif
 				"    <xs:complexType>{0}" +
 				"      <xs:sequence>{0}" +
 				"        <xs:element ref=\"xs:schema\" />{0}" +
@@ -278,10 +1668,283 @@
 				"  </xs:element>{0}" +
 #endif
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+
+			schemas = Export (typeof (PrimitiveSchemaProvider), "NSPrimitiveSchemaProvider");
+			Assert.AreEqual (1, schemas.Count, "#5");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSPrimitiveSchemaProvider\" elementFormDefault=\"qualified\" targetNamespace=\"NSPrimitiveSchemaProvider\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if NET_2_0
+				"  <xs:import />{0}" +
+				"  <xs:element name=\"int\" nillable=\"true\" type=\"xs:int\" />{0}" +
+#else
+				"  <xs:import namespace=\"http://www.w3.org/2001/XMLSchema\" />{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"PrimitiveSchemaProvider\" nillable=\"true\">{0}" +
+#else
+				"  <xs:element name=\"PrimitiveSchemaProvider\">{0}" +
+#endif
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#endif
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#6");
+
+			schemas = Export (typeof (PrimitiveSchemaProvider));
+			Assert.AreEqual (1, schemas.Count, "#7");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if NET_2_0
+				"  <xs:element name=\"int\" nillable=\"true\" type=\"xs:int\" />{0}" +
+#else
+				"  <xs:import namespace=\"http://www.w3.org/2001/XMLSchema\" />{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"PrimitiveSchemaProvider\" nillable=\"true\">{0}" +
+#else
+				"  <xs:element name=\"PrimitiveSchemaProvider\">{0}" +
+#endif
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#endif
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#8");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // bug #77117
+#if NET_2_0
+		[Category ("NotWorking")] // support for XmlSchemaProvider is not implemented
+#endif
+		public void ExportXmlSerializable_Container ()
+		{
+			XmlSchemas schemas = Export (typeof (XmlSerializableContainer), "NSXmlSerializableContainer");
+			Assert.AreEqual (3, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"NSXmlSerializableContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSXmlSerializableContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:import namespace=\"http://www.w3.org/2001/XMLSchema\" />{0}" +
+				"  <xs:import namespace=\"urn:types-devx-com\" />{0}" +
+#if NET_2_0
+				"  <xs:import />{0}" +
+#endif
+#if MS // bug #77117
+				"  <xs:element name=\"XmlSerializableContainer\" nillable=\"true\" type=\"tns:XmlSerializableContainer\" />{0}" +
+#else
+				"  <xs:element name=\"XmlSerializableContainer\" type=\"tns:XmlSerializableContainer\" />{0}" +
+#endif
+				"  <xs:complexType name=\"XmlSerializableContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Slave\">{0}" +
+				"        <xs:complexType>{0}" +
+				"          <xs:sequence>{0}" +
+				"            <xs:element ref=\"xs:schema\" />{0}" +
+				"            <xs:any />{0}" +
+				"          </xs:sequence>{0}" +
+				"        </xs:complexType>{0}" +
+				"      </xs:element>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"SlaveSchema\">{0}" +
+				"        <xs:complexType>{0}" +
+				"          <xs:sequence>{0}" +
+				"            <xs:any namespace=\"urn:types-devx-com\" />{0}" +
+				"          </xs:sequence>{0}" +
+				"        </xs:complexType>{0}" +
+				"      </xs:element>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"SlaveSchemaProvider\" xmlns:q1=\"urn:types-devx-com\" type=\"q1:employeeRoot\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"SlaveSchemaProvider\">{0}" +
+				"        <xs:complexType>{0}" +
+				"          <xs:sequence>{0}" +
+				"            <xs:element ref=\"xs:schema\" />{0}" +
+				"            <xs:any />{0}" +
+				"          </xs:sequence>{0}" +
+				"        </xs:complexType>{0}" +
+				"      </xs:element>{0}" +
+#endif
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"NativeSchema\">{0}" +
+				"        <xs:complexType>{0}" +
+				"          <xs:sequence>{0}" +
+				"            <xs:any namespace=\"\" />{0}" +
+				"          </xs:sequence>{0}" +
+				"        </xs:complexType>{0}" +
+				"      </xs:element>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"NativeSchemaProvider\" type=\"xs:int\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q2=\"urn:types-devx-com\" ref=\"q2:SlaveNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q3=\"urn:types-devx-com\" ref=\"q3:SlaveSchemaNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q4=\"urn:types-devx-com\" ref=\"q4:SlaveSchemaProviderNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q5=\"urn:types-devx-com\" ref=\"q5:NativeSchemaNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q6=\"urn:types-devx-com\" ref=\"q6:NativeSchemaProviderNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q7=\"urn:types-devx-com\" ref=\"q7:SlaveNSOnly\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q8=\"urn:types-devx-com\" ref=\"q8:SlaveSchemaNSOnly\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q9=\"urn:types-devx-com\" ref=\"q9:SlaveSchemaProviderNSOnly\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q10=\"urn:types-devx-com\" ref=\"q10:NativeSchemaNSOnly\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q11=\"urn:types-devx-com\" ref=\"q11:NativeSchemaProviderNSOnly\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"NativeSchemaProvider\">{0}" +
+				"        <xs:complexType>{0}" +
+				"          <xs:sequence>{0}" +
+				"            <xs:element ref=\"xs:schema\" />{0}" +
+				"            <xs:any />{0}" +
+				"          </xs:sequence>{0}" +
+				"        </xs:complexType>{0}" +
+				"      </xs:element>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q1=\"urn:types-devx-com\" ref=\"q1:SlaveNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q2=\"urn:types-devx-com\" ref=\"q2:SlaveSchemaNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q3=\"urn:types-devx-com\" ref=\"q3:SlaveSchemaProviderNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q4=\"urn:types-devx-com\" ref=\"q4:NativeSchemaNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q5=\"urn:types-devx-com\" ref=\"q5:NativeSchemaProviderNamespace\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q6=\"urn:types-devx-com\" ref=\"q6:SlaveNSOnly\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q7=\"urn:types-devx-com\" ref=\"q7:SlaveSchemaNSOnly\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q8=\"urn:types-devx-com\" ref=\"q8:SlaveSchemaProviderNSOnly\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q9=\"urn:types-devx-com\" ref=\"q9:NativeSchemaNSOnly\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" xmlns:q10=\"urn:types-devx-com\" ref=\"q10:NativeSchemaProviderNSOnly\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[1].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"urn:types-devx-com\" targetNamespace=\"urn:types-devx-com\" id=\"EmployeeSchema\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:import namespace=\"http://www.w3.org/2001/XMLSchema\" />{0}" +
+#if NET_2_0
+				"  <xs:import />{0}" +
+#endif
+				"  <xs:complexType name=\"employeeRoot\">{0}" +
+				"    <xs:attribute name=\"firstName\" />{0}" +
+				"    <xs:attribute name=\"lastName\" />{0}" +
+				"    <xs:attribute name=\"address\" />{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:element name=\"employee\" type=\"tns:employeeRoot\" />{0}" +
+				"  <xs:element name=\"SlaveNamespace\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+				"  <xs:element name=\"SlaveSchemaNamespace\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:any namespace=\"urn:types-devx-com\" />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#if NET_2_0
+				"  <xs:element name=\"SlaveSchemaProviderNamespace\" type=\"tns:employeeRoot\" />{0}" +
+#else
+				"  <xs:element name=\"SlaveSchemaProviderNamespace\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#endif
+				"  <xs:element name=\"NativeSchemaNamespace\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:any namespace=\"\" />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#if NET_2_0
+				"  <xs:element name=\"NativeSchemaProviderNamespace\" type=\"xs:int\" />{0}" +
+#else
+				"  <xs:element name=\"NativeSchemaProviderNamespace\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#endif
+				"  <xs:element name=\"SlaveNSOnly\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+				"  <xs:element name=\"SlaveSchemaNSOnly\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:any namespace=\"urn:types-devx-com\" />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#if NET_2_0
+				 "  <xs:element name=\"SlaveSchemaProviderNSOnly\" type=\"tns:employeeRoot\" />{0}" +
+#else
+				"  <xs:element name=\"SlaveSchemaProviderNSOnly\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#endif
+				"  <xs:element name=\"NativeSchemaNSOnly\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:any namespace=\"\" />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#if NET_2_0
+				"  <xs:element name=\"NativeSchemaProviderNSOnly\" type=\"xs:int\" />{0}" +
+#else
+				"  <xs:element name=\"NativeSchemaProviderNSOnly\">{0}" +
+				"    <xs:complexType>{0}" +
+				"      <xs:sequence>{0}" +
+				"        <xs:element ref=\"xs:schema\" />{0}" +
+				"        <xs:any />{0}" +
+				"      </xs:sequence>{0}" +
+				"    </xs:complexType>{0}" +
+				"  </xs:element>{0}" +
+#endif
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[2].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema id=\"LuckyNumberSchema\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:element name=\"LuckyNumber\" type=\"xs:int\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
 		public void ExportXsdPrimitive ()
 		{
 			ArrayList types = new ArrayList ();
@@ -306,12 +1969,7 @@
 			types.Add (new TypeDescription (typeof (string), true, "string", "String", true));
 
 			foreach (TypeDescription typeDesc in types) {
-				XmlReflectionImporter ri = new XmlReflectionImporter (typeDesc.Type.Name);
-				XmlSchemas schemas = new XmlSchemas ();
-				XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-				XmlTypeMapping tm = ri.ImportTypeMapping (typeDesc.Type);
-				sx.ExportTypeMapping (tm);
-
+				XmlSchemas schemas = Export (typeDesc.Type, typeDesc.Type.Name);
 				Assert.AreEqual (1, schemas.Count, typeDesc.Type.FullName + "#1");
 
 				StringWriter sw = new StringWriter ();
@@ -321,21 +1979,36 @@
 					"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
 					"<xs:schema xmlns:tns=\"{1}\" elementFormDefault=\"qualified\" targetNamespace=\"{1}\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
 					"  <xs:element name=\"{2}\" {3}type=\"xs:{2}\" />{0}" +
+#if MS // bug #77117
 					"</xs:schema>", Environment.NewLine, typeDesc.Type.Name, typeDesc.XmlType, typeDesc.IsNillable ? "nillable=\"true\" " : ""),
+#else
+					"</xs:schema>", Environment.NewLine, typeDesc.Type.Name, typeDesc.XmlType, ""),
+#endif
 					sw.ToString (), typeDesc.Type.FullName + "#2");
+
+				schemas = Export (typeDesc.Type);
+				Assert.AreEqual (1, schemas.Count, typeDesc.Type.FullName + "#3");
+
+				sw.GetStringBuilder ().Length = 0;
+				schemas[0].Write (sw);
+
+				Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+					"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+					"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+					"  <xs:element name=\"{1}\" {2}type=\"xs:{1}\" />{0}" +
+#if MS // bug #77117
+					"</xs:schema>", Environment.NewLine, typeDesc.XmlType, typeDesc.IsNillable ? "nillable=\"true\" " : ""),
+#else
+					"</xs:schema>", Environment.NewLine, typeDesc.XmlType, ""),
+#endif
+					sw.ToString (), typeDesc.Type.FullName + "#4");
 			}
 		}
 
 		[Test]
-		[Category ("NotWorking")] // bug #77117
 		public void ExportXsdPrimitive_Object ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NSAnyType");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (object));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (object), "NSAnyType");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -344,20 +2017,34 @@
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
 				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
 				"<xs:schema xmlns:tns=\"NSAnyType\" elementFormDefault=\"qualified\" targetNamespace=\"NSAnyType\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
 				"  <xs:element name=\"anyType\" nillable=\"true\" />{0}" +
+#else
+				"  <xs:element name=\"anyType\" />{0}" +
+#endif
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (object));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"anyType\" nillable=\"true\" />{0}" +
+#else
+				"  <xs:element name=\"anyType\" />{0}" +
+#endif
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // bug #77117
 		public void ExportXsdPrimitive_ByteArray ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("ByteArray");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (byte[]));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (byte[]), "NSByteArray");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -365,13 +2052,32 @@
 
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
 				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
-				"<xs:schema xmlns:tns=\"ByteArray\" elementFormDefault=\"qualified\" targetNamespace=\"ByteArray\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"<xs:schema xmlns:tns=\"NSByteArray\" elementFormDefault=\"qualified\" targetNamespace=\"NSByteArray\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
 				"  <xs:element name=\"base64Binary\" nillable=\"true\" type=\"xs:base64Binary\" />{0}" +
+#else
+				"  <xs:element name=\"base64Binary\" type=\"xs:base64Binary\" />{0}" +
+#endif
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (byte[]));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"base64Binary\" nillable=\"true\" type=\"xs:base64Binary\" />{0}" +
+#else
+				"  <xs:element name=\"base64Binary\" type=\"xs:base64Binary\" />{0}" +
+#endif
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // bug #77117
 		public void ExportXsdPrimitive_Arrays ()
 		{
 			ArrayList types = new ArrayList ();
@@ -395,12 +2101,7 @@
 			types.Add (new TypeDescription (typeof (string[]), true, "string", "String", true));
 
 			foreach (TypeDescription typeDesc in types) {
-				XmlReflectionImporter ri = new XmlReflectionImporter (typeDesc.Type.Name);
-				XmlSchemas schemas = new XmlSchemas ();
-				XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-				XmlTypeMapping tm = ri.ImportTypeMapping (typeDesc.Type);
-				sx.ExportTypeMapping (tm);
-
+				XmlSchemas schemas = Export (typeDesc.Type, typeDesc.Type.Name);
 				Assert.AreEqual (1, schemas.Count, typeDesc.Type.FullName + "#1");
 
 				StringWriter sw = new StringWriter ();
@@ -409,7 +2110,11 @@
 				Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
 					"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
 					"<xs:schema xmlns:tns=\"{1}\" elementFormDefault=\"qualified\" targetNamespace=\"{1}\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
 					"  <xs:element name=\"ArrayOf{2}\" nillable=\"true\" type=\"tns:ArrayOf{2}\" />{0}" +
+#else
+					"  <xs:element name=\"ArrayOf{2}\" type=\"tns:ArrayOf{2}\" />{0}" +
+#endif
 					"  <xs:complexType name=\"ArrayOf{2}\">{0}" +
 					"    <xs:sequence>{0}" +
 					"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"{3}\" {5}type=\"{4}:{3}\" />{0}" +
@@ -418,19 +2123,36 @@
 					"</xs:schema>", Environment.NewLine, typeDesc.Type.Name, typeDesc.ArrayType, typeDesc.XmlType, 
 					typeDesc.XsdType ? "xs" : "tns", typeDesc.IsNillable ? "nillable=\"true\" " : ""),
 					sw.ToString (), typeDesc.Type.FullName + "#2");
+
+				schemas = Export (typeDesc.Type);
+				Assert.AreEqual (1, schemas.Count, typeDesc.Type.FullName + "#3");
+
+				sw.GetStringBuilder ().Length = 0;
+				schemas[0].Write (sw);
+
+				Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+					"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+					"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+					"  <xs:element name=\"ArrayOf{1}\" nillable=\"true\" type=\"ArrayOf{1}\" />{0}" +
+#else
+					"  <xs:element name=\"ArrayOf{1}\" type=\"ArrayOf{1}\" />{0}" +
+#endif
+					"  <xs:complexType name=\"ArrayOf{1}\">{0}" +
+					"    <xs:sequence>{0}" +
+					"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"{2}\" {4}type=\"{3}:{2}\" />{0}" +
+					"    </xs:sequence>{0}" +
+					"  </xs:complexType>{0}" +
+					"</xs:schema>", Environment.NewLine, typeDesc.ArrayType, typeDesc.XmlType,
+					typeDesc.XsdType ? "xs" : "tns", typeDesc.IsNillable ? "nillable=\"true\" " : ""),
+					sw.ToString (), typeDesc.Type.FullName + "#4");
 			}
 		}
 
 		[Test]
-		[Category ("NotWorking")] // bug #77117
 		public void ExportXsdPrimitive_Object_Arrays ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NSArrayOfAnyType");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (object[]));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (object[]), "NSArrayOfAnyType");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -439,25 +2161,44 @@
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
 				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
 				"<xs:schema xmlns:tns=\"NSArrayOfAnyType\" elementFormDefault=\"qualified\" targetNamespace=\"NSArrayOfAnyType\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
 				"  <xs:element name=\"ArrayOfAnyType\" nillable=\"true\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfAnyType\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#endif
 				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
 				"    <xs:sequence>{0}" +
 				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
 				"    </xs:sequence>{0}" +
 				"  </xs:complexType>{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (object[]));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#if MS // bug #77117
+				"  <xs:element name=\"ArrayOfAnyType\" nillable=\"true\" type=\"ArrayOfAnyType\" />{0}" +
+#else
+				"  <xs:element name=\"ArrayOfAnyType\" type=\"ArrayOfAnyType\" />{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:sequence>{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"anyType\" nillable=\"true\" />{0}" +
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // bug #77117
 		public void ExportNonXsdPrimitive_Guid ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NSPrimGuid");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (Guid));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (Guid), "NSPrimGuid");
 			Assert.AreEqual (2, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -470,7 +2211,7 @@
 				"  <xs:element name=\"guid\" xmlns:q1=\"http://microsoft.com/wsdl/types/\" type=\"q1:guid\" />{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
 
-			sw = new StringWriter ();
+			sw.GetStringBuilder ().Length = 0;
 			schemas[1].Write (sw);
 
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
@@ -482,18 +2223,38 @@
 				"    </xs:restriction>{0}" +
 				"  </xs:simpleType>{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#3");
+
+			schemas = Export (typeof (Guid));
+			Assert.AreEqual (2, schemas.Count, "#4");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:import namespace=\"http://microsoft.com/wsdl/types/\" />{0}" +
+				"  <xs:element name=\"guid\" xmlns:q1=\"http://microsoft.com/wsdl/types/\" type=\"q1:guid\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#5");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[1].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"http://microsoft.com/wsdl/types/\" elementFormDefault=\"qualified\" targetNamespace=\"http://microsoft.com/wsdl/types/\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:simpleType name=\"guid\">{0}" +
+				"    <xs:restriction base=\"xs:string\">{0}" +
+				"      <xs:pattern value=\"[0-9a-fA-F]{{8}}-[0-9a-fA-F]{{4}}-[0-9a-fA-F]{{4}}-[0-9a-fA-F]{{4}}-[0-9a-fA-F]{{12}}\" />{0}" +
+				"    </xs:restriction>{0}" +
+				"  </xs:simpleType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#6");
 		}
 
 		[Test]
-		[Category ("NotWorking")] // bug #77117
 		public void ExportNonXsdPrimitive_Char ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NSPrimChar");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (Char));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (char), "NSPrimChar");
 			Assert.AreEqual (2, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -506,7 +2267,7 @@
 				"  <xs:element name=\"char\" xmlns:q1=\"http://microsoft.com/wsdl/types/\" type=\"q1:char\" />{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
 
-			sw = new StringWriter ();
+			sw.GetStringBuilder ().Length = 0;
 			schemas[1].Write (sw);
 
 			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
@@ -516,6 +2277,30 @@
 				"    <xs:restriction base=\"xs:unsignedShort\" />{0}" +
 				"  </xs:simpleType>{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#3");
+
+			schemas = Export (typeof (char));
+			Assert.AreEqual (2, schemas.Count, "#4");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:import namespace=\"http://microsoft.com/wsdl/types/\" />{0}" +
+				"  <xs:element name=\"char\" xmlns:q1=\"http://microsoft.com/wsdl/types/\" type=\"q1:char\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#5");
+
+			sw.GetStringBuilder ().Length = 0;
+			schemas[1].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+				"<xs:schema xmlns:tns=\"http://microsoft.com/wsdl/types/\" elementFormDefault=\"qualified\" targetNamespace=\"http://microsoft.com/wsdl/types/\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+				"  <xs:simpleType name=\"char\">{0}" +
+				"    <xs:restriction base=\"xs:unsignedShort\" />{0}" +
+				"  </xs:simpleType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#6");
 		}
 
 		public class Employee : IXmlSerializable
@@ -524,7 +2309,7 @@
 			private string _lastName;
 			private string _address;
 
-			public XmlSchema GetSchema ()
+			public virtual XmlSchema GetSchema ()
 			{
 				return null;
 			}
@@ -549,45 +2334,198 @@
 			}
 		}
 
-#if NET_2_0
-		[XmlSchemaProvider ("CreateEmployeeSchema")]
-#endif
-		public class EmployeeSchema : Employee
+		public class EmployeeSchema : IXmlSerializable
 		{
-#if NET_2_0
-			public static XmlQualifiedName CreateEmployeeSchema (XmlSchemaSet schemaSet)
+			private string _firstName;
+			private string _lastName;
+			private string _address;
+
+			public virtual XmlSchema GetSchema ()
 			{
-				XmlSchema schema = new XmlSchema();
+				return CreateSchema ();
+			}
+
+			public void WriteXml (XmlWriter writer)
+			{
+				writer.WriteStartElement ("employee", "urn:devx-com");
+				writer.WriteAttributeString ("firstName", _firstName);
+				writer.WriteAttributeString ("lastName", _lastName);
+				writer.WriteAttributeString ("address", _address);
+				writer.WriteEndElement ();
+			}
+
+			public void ReadXml (XmlReader reader)
+			{
+				XmlNodeType type = reader.MoveToContent ();
+				if (type == XmlNodeType.Element && reader.LocalName == "employee") {
+					_firstName = reader["firstName"];
+					_lastName = reader["lastName"];
+					_address = reader["address"];
+				}
+			}
+
+			protected static XmlSchema CreateSchema ()
+			{
+				XmlSchema schema = new XmlSchema ();
 				schema.Id = "EmployeeSchema";
 				schema.TargetNamespace = "urn:types-devx-com";
-			
-				XmlSchemaComplexType type = new XmlSchemaComplexType();
+
+				XmlSchemaComplexType type = new XmlSchemaComplexType ();
 				type.Name = "employeeRoot";
-				XmlSchemaAttribute firstNameAttr = new XmlSchemaAttribute();
+				XmlSchemaAttribute firstNameAttr = new XmlSchemaAttribute ();
 				firstNameAttr.Name = "firstName";
-				type.Attributes.Add(firstNameAttr);
+				type.Attributes.Add (firstNameAttr);
 
-				XmlSchemaAttribute lastNameAttr = new XmlSchemaAttribute();
+				XmlSchemaAttribute lastNameAttr = new XmlSchemaAttribute ();
 				lastNameAttr.Name = "lastName";
-				type.Attributes.Add(lastNameAttr);
+				type.Attributes.Add (lastNameAttr);
 
-				XmlSchemaAttribute addressAttr = new XmlSchemaAttribute();
+				XmlSchemaAttribute addressAttr = new XmlSchemaAttribute ();
 				addressAttr.Name = "address";
-				type.Attributes.Add(addressAttr);
+				type.Attributes.Add (addressAttr);
 
-				XmlSchemaElement employeeElement = new XmlSchemaElement();
+				XmlSchemaElement employeeElement = new XmlSchemaElement ();
 				employeeElement.Name = "employee";
-				XmlQualifiedName name = new XmlQualifiedName("employeeRoot", "urn:types-devx-com");
+				XmlQualifiedName name = new XmlQualifiedName ("employeeRoot", "urn:types-devx-com");
 				employeeElement.SchemaTypeName = name;
 
-				schema.Items.Add(type);
-				schema.Items.Add(employeeElement);
-				schemaSet.Add(schema);
-				return name;
+				schema.Items.Add (type);
+				schema.Items.Add (employeeElement);
+				return schema;
 			}
+		}
+
+		public class PrimitiveSchema : IXmlSerializable
+		{
+			private string _firstName;
+			private string _lastName;
+			private string _address;
+
+			public virtual XmlSchema GetSchema ()
+			{
+				XmlSchema schema = new XmlSchema ();
+				schema.Id = "LuckyNumberSchema";
+				XmlSchemaElement luckyNumberElement = new XmlSchemaElement ();
+				luckyNumberElement.Name = "LuckyNumber";
+				luckyNumberElement.SchemaTypeName = new XmlQualifiedName ("int", "http://www.w3.org/2001/XMLSchema");
+				schema.Items.Add (luckyNumberElement);
+				return schema;
+			}
+
+			public void WriteXml (XmlWriter writer)
+			{
+				writer.WriteStartElement ("employee", "urn:devx-com");
+				writer.WriteAttributeString ("firstName", _firstName);
+				writer.WriteAttributeString ("lastName", _lastName);
+				writer.WriteAttributeString ("address", _address);
+				writer.WriteEndElement ();
+			}
+
+			public void ReadXml (XmlReader reader)
+			{
+				XmlNodeType type = reader.MoveToContent ();
+				if (type == XmlNodeType.Element && reader.LocalName == "employee") {
+					_firstName = reader["firstName"];
+					_lastName = reader["lastName"];
+					_address = reader["address"];
+				}
+			}
+		}
+
+		public class MissingIDSchema : IXmlSerializable
+		{
+			private string _firstName;
+			private string _lastName;
+			private string _address;
+
+			public virtual XmlSchema GetSchema ()
+			{
+				XmlSchema schema = new XmlSchema ();
+				XmlSchemaElement luckyNumberElement = new XmlSchemaElement ();
+				luckyNumberElement.Name = "LuckyNumber";
+				luckyNumberElement.SchemaTypeName = new XmlQualifiedName ("int", "http://www.w3.org/2001/XMLSchema");
+				return schema;
+			}
+
+			public void WriteXml (XmlWriter writer)
+			{
+				writer.WriteStartElement ("employee", "urn:devx-com");
+				writer.WriteAttributeString ("firstName", _firstName);
+				writer.WriteAttributeString ("lastName", _lastName);
+				writer.WriteAttributeString ("address", _address);
+				writer.WriteEndElement ();
+			}
+
+			public void ReadXml (XmlReader reader)
+			{
+				XmlNodeType type = reader.MoveToContent ();
+				if (type == XmlNodeType.Element && reader.LocalName == "employee") {
+					_firstName = reader["firstName"];
+					_lastName = reader["lastName"];
+					_address = reader["address"];
+				}
+			}
+		}
+
+#if NET_2_0
+		[XmlSchemaProvider ("CreateEmployeeSchema")]
 #endif
+		public class EmployeeSchemaProvider : EmployeeSchema
+		{
+#if NET_2_0
+			public static XmlQualifiedName CreateEmployeeSchema (XmlSchemaSet schemaSet)
+			{
+				schemaSet.Add (CreateSchema ());
+				return new XmlQualifiedName ("employeeRoot", "urn:types-devx-com");
+			}
+#else
+			public override XmlSchema GetSchema ()
+			{
+				return null;
+			}
+#endif
 		}
 
+#if NET_2_0
+		[XmlSchemaProvider ("CreateLuckyNumberSchema")]
+#endif
+		public class PrimitiveSchemaProvider : IXmlSerializable
+		{
+#if NET_2_0
+			public static XmlQualifiedName CreateLuckyNumberSchema (XmlSchemaSet schemaSet)
+			{
+				XmlSchema schema = new XmlSchema ();
+
+				XmlSchemaElement luckyNumberElement = new XmlSchemaElement ();
+				luckyNumberElement.Name = "LuckyNumber";
+
+				XmlQualifiedName typeName = new XmlQualifiedName("int", "http://www.w3.org/2001/XMLSchema");
+				luckyNumberElement.SchemaTypeName = typeName;
+				schema.Items.Add (luckyNumberElement);
+
+				schemaSet.Add (schema);
+				return typeName;
+			}
+#endif
+
+			public XmlSchema GetSchema ()
+			{
+				return null;
+			}
+
+			public void WriteXml (XmlWriter writer)
+			{
+				writer.WriteElementString ("LuckyNumber", "7");
+			}
+
+			public void ReadXml (XmlReader reader)
+			{
+				XmlNodeType type = reader.MoveToContent ();
+				if (type == XmlNodeType.Element && reader.LocalName == "LuckyNumber") {
+				}
+			}
+		}
+
 		private class TypeDescription
 		{
 			public TypeDescription (Type type, bool xsdType, string xmlType, string arrayType) : this (type, xsdType, xmlType, arrayType, false)
@@ -629,5 +2567,43 @@
 			private string _arrayType;
 			private bool _isNillable;
 		}
+
+		public class StructContainer
+		{
+			public EnumDefaultValue Value;
+			public TimeSpan[] Times;
+		}
+
+		public class XmlSerializableContainer
+		{
+			public Employee Slave;
+			public EmployeeSchema SlaveSchema;
+			public EmployeeSchemaProvider SlaveSchemaProvider;
+			public PrimitiveSchema NativeSchema;
+			public PrimitiveSchemaProvider NativeSchemaProvider;
+
+			[XmlElement ("SlaveNamespace", Namespace = "urn:types-devx-com")]
+			public Employee SlaveNS;
+			[XmlElement ("SlaveSchemaNamespace", Namespace = "urn:types-devx-com")]
+			public EmployeeSchema SlaveSchemaNS;
+			[XmlElement ("SlaveSchemaProviderNamespace", Namespace = "urn:types-devx-com")]
+			public EmployeeSchemaProvider SlaveSchemaProviderNS;
+			[XmlElement ("NativeSchemaNamespace", Namespace = "urn:types-devx-com")]
+			public PrimitiveSchema NativeSchemaNS;
+			[XmlElement ("NativeSchemaProviderNamespace", Namespace = "urn:types-devx-com")]
+			public PrimitiveSchemaProvider NativeSchemaProviderNS;
+
+
+			[XmlElement (Namespace = "urn:types-devx-com")]
+			public Employee SlaveNSOnly;
+			[XmlElement (Namespace = "urn:types-devx-com")]
+			public EmployeeSchema SlaveSchemaNSOnly;
+			[XmlElement (Namespace = "urn:types-devx-com")]
+			public EmployeeSchemaProvider SlaveSchemaProviderNSOnly;
+			[XmlElement (Namespace = "urn:types-devx-com")]
+			public PrimitiveSchema NativeSchemaNSOnly;
+			[XmlElement (Namespace = "urn:types-devx-com")]
+			public PrimitiveSchemaProvider NativeSchemaProviderNSOnly;
+		}
 	}
 }
Index: Test/System.Xml.Serialization/SoapSchemaExporterTests.cs
===================================================================
--- Test/System.Xml.Serialization/SoapSchemaExporterTests.cs	(revision 55191)
+++ Test/System.Xml.Serialization/SoapSchemaExporterTests.cs	(working copy)
@@ -24,16 +24,40 @@
 	[TestFixture]
 	public class SoapSchemaExporterTests
 	{
-		[Test]
-		[Category ("NotWorking")]
-		public void ExportStruct ()
+		private XmlSchemas Export (Type type)
 		{
-			SoapReflectionImporter ri = new SoapReflectionImporter ("NSTimeSpan");
+			return Export (type, string.Empty);
+		}
+
+		private XmlSchemas Export (Type type, string defaultNamespace)
+		{
+			SoapReflectionImporter ri = new SoapReflectionImporter (defaultNamespace);
 			XmlSchemas schemas = new XmlSchemas ();
 			SoapSchemaExporter sx = new SoapSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (TimeSpan));
+			XmlTypeMapping tm = ri.ImportTypeMapping (type);
 			sx.ExportTypeMapping (tm);
+			return schemas;
+		}
 
+		private XmlSchemas Export (Type type, SoapAttributeOverrides overrides)
+		{
+			return Export (type, overrides, string.Empty);
+		}
+
+		private XmlSchemas Export (Type type, SoapAttributeOverrides overrides, string defaultNamespace)
+		{
+			SoapReflectionImporter ri = new SoapReflectionImporter (overrides, defaultNamespace);
+			XmlSchemas schemas = new XmlSchemas ();
+			SoapSchemaExporter sx = new SoapSchemaExporter (schemas);
+			XmlTypeMapping tm = ri.ImportTypeMapping (type);
+			sx.ExportTypeMapping (tm);
+			return schemas;
+		}
+
+		[Test]
+		public void ExportStruct ()
+		{
+			XmlSchemas schemas = Export (typeof (TimeSpan), "NSTimeSpan");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -48,12 +72,29 @@
 #endif
 				"  <xs:complexType name=\"TimeSpan\" />{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+
+			schemas = Export (typeof (TimeSpan));
+			Assert.AreEqual (1, schemas.Count, "#3");
+
+			sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:complexType name=\"TimeSpan\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
 		}
 
-
 		[Test]
-		[Category ("NotWorking")]
-		public void ExportClass ()
+#if NET_2_0
+		[Category ("NotWorking")] // minOccurs is 1 on Mono
+#endif
+		public void ExportClass_SimpleClass ()
 		{
 			SoapAttributeOverrides overrides = new SoapAttributeOverrides ();
 			SoapAttributes attr = new SoapAttributes ();
@@ -63,12 +104,7 @@
 			attr.SoapElement = element;
 			overrides.Add (typeof (SimpleClass), "something", attr);
 
-			SoapReflectionImporter ri = new SoapReflectionImporter (overrides, "NSSimpleClass");
-			XmlSchemas schemas = new XmlSchemas ();
-			SoapSchemaExporter sx = new SoapSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (SimpleClass));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (SimpleClass), overrides, "NSSimpleClass");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -94,33 +130,661 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
-		[ExpectedException (typeof (InvalidOperationException))] // Cannot use wildcards at the top level of a schema.
-		public void ExportClass_XmlNode ()
+		public void ExportClass_StringCollection ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NS1");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (XmlNode));
-			sx.ExportTypeMapping (tm);
+			XmlSchemas schemas = Export (typeof (StringCollection), "NSStringCollection");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSStringCollection\" elementFormDefault=\"qualified\" targetNamespace=\"NSStringCollection\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSStringCollection\" targetNamespace=\"NSStringCollection\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:string[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
-		[ExpectedException (typeof (InvalidOperationException))] // Cannot use wildcards at the top level of a schema.
-		public void ExportClass_XmlElement ()
+		public void ExportClass_StringCollectionContainer ()
 		{
-			XmlReflectionImporter ri = new XmlReflectionImporter ("NS1");
-			XmlSchemas schemas = new XmlSchemas ();
-			XmlSchemaExporter sx = new XmlSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (XmlElement));
-			sx.ExportTypeMapping (tm);
+			XmlSchemas schemas = Export (typeof (StringCollectionContainer), "NSStringCollectionContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSStringCollectionContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSStringCollectionContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSStringCollectionContainer\" targetNamespace=\"NSStringCollectionContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"StringCollectionContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"Messages\" type=\"tns:ArrayOfString\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Messages\" type=\"tns:ArrayOfString\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:string[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
-		public void ExportClass_Array ()
+		public void ExportClass_ArrayContainer ()
 		{
+			XmlSchemas schemas = Export (typeof (ArrayContainer), "NSArrayContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSArrayContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSArrayContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSArrayContainer\" targetNamespace=\"NSArrayContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"ArrayContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"items\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"items\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:anyType[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_ClassArrayContainer ()
+		{
+			XmlSchemas schemas = Export (typeof (ClassArrayContainer), "NSClassArrayContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSClassArrayContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSClassArrayContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSClassArrayContainer\" targetNamespace=\"NSClassArrayContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"ClassArrayContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"items\" type=\"tns:ArrayOfSimpleClass\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"items\" type=\"tns:ArrayOfSimpleClass\" />{0}" +
+#endif
+ "    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfSimpleClass\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"tns:SimpleClass[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"SimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"something\" type=\"xs:string\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"something\" type=\"xs:string\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_SimpleClassWithXmlAttributes ()
+		{
+			XmlSchemas schemas = Export (typeof (SimpleClassWithXmlAttributes), "NSSimpleClassWithXmlAttributes");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSSimpleClassWithXmlAttributes\" elementFormDefault=\"qualified\" targetNamespace=\"NSSimpleClassWithXmlAttributes\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSSimpleClassWithXmlAttributes\" targetNamespace=\"NSSimpleClassWithXmlAttributes\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:complexType name=\"SimpleClassWithXmlAttributes\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"something\" type=\"xs:string\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"something\" type=\"xs:string\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_Field ()
+		{
+			XmlSchemas schemas = Export (typeof (Field), "NSField");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSField\" elementFormDefault=\"qualified\" targetNamespace=\"NSField\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSField\" targetNamespace=\"NSField\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"Field\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" form=\"unqualified\" name=\"Modifiers\" type=\"tns:MapModifiers\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" form=\"unqualified\" name=\"Modifiers2\" type=\"tns:MapModifiers\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" form=\"unqualified\" name=\"Modifiers3\" type=\"tns:MapModifiers\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" form=\"unqualified\" name=\"Modifiers4\" type=\"tns:MapModifiers\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"Names\" type=\"tns:ArrayOfString\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"Street\" type=\"xs:string\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Modifiers\" type=\"tns:MapModifiers\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Modifiers2\" type=\"tns:MapModifiers\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Modifiers3\" type=\"tns:MapModifiers\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Modifiers4\" type=\"tns:MapModifiers\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Names\" type=\"tns:ArrayOfString\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Street\" type=\"xs:string\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:simpleType name=\"MapModifiers\">{0}" +
+				"    <xs:list>{0}" +
+				"      <xs:simpleType>{0}" +
+				"        <xs:restriction base=\"xs:string\">{0}" +
+				"          <xs:enumeration value=\"Public\" />{0}" +
+				"          <xs:enumeration value=\"Protected\" />{0}" +
+				"        </xs:restriction>{0}" +
+				"      </xs:simpleType>{0}" +
+				"    </xs:list>{0}" +
+				"  </xs:simpleType>{0}" +
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:string[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_MyList ()
+		{
+			XmlSchemas schemas = Export (typeof (MyList), "NSMyList");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSMyList\" elementFormDefault=\"qualified\" targetNamespace=\"NSMyList\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSMyList\" targetNamespace=\"NSMyList\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:anyType[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_Container ()
+		{
+			XmlSchemas schemas = Export (typeof (Container), "NSContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSContainer\" targetNamespace=\"NSContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"Container\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"Items\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Items\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:anyType[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_Container2 ()
+		{
+			XmlSchemas schemas = Export (typeof (Container2), "NSContainer2");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSContainer2\" elementFormDefault=\"qualified\" targetNamespace=\"NSContainer2\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSContainer2\" targetNamespace=\"NSContainer2\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"Container2\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"Items\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Items\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:anyType[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		[ExpectedException (typeof (NotSupportedException))]
+		public void ExportClass_MyElem ()
+		{
+			Export (typeof (MyElem), "NSMyElem");
+		}
+
+		[Test]
+		[ExpectedException (typeof (NotSupportedException))] // The type System.Xml.XmlCDataSection may not be serialized with SOAP-encoded messages.
+		public void ExportClass_CDataContainer ()
+		{
+			Export (typeof (CDataContainer), "NSCDataContainer");
+		}
+
+		[Test]
+		[ExpectedException (typeof (NotSupportedException))] // The type System.Xml.XmlCDataSection may not be serialized with SOAP-encoded messages.
+		public void ExportClass_NodeContainer ()
+		{
+			Export (typeof (NodeContainer), "NSNodeContainer");
+		}
+
+		[Test]
+		public void ExportClass_Choices ()
+		{
+			XmlSchemas schemas = Export (typeof (Choices), "NSChoices");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSChoices\" elementFormDefault=\"qualified\" targetNamespace=\"NSChoices\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSChoices\" targetNamespace=\"NSChoices\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:complexType name=\"Choices\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"MyChoice\" type=\"xs:string\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" form=\"unqualified\" name=\"ItemType\" type=\"tns:ItemChoiceType\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"MyChoice\" type=\"xs:string\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"ItemType\" type=\"tns:ItemChoiceType\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:simpleType name=\"ItemChoiceType\">{0}" +
+				"    <xs:restriction base=\"xs:string\">{0}" +
+				"      <xs:enumeration value=\"ChoiceZero\" />{0}" +
+				"      <xs:enumeration value=\"StrangeOne\" />{0}" +
+				"      <xs:enumeration value=\"ChoiceTwo\" />{0}" +
+				"    </xs:restriction>{0}" +
+				"  </xs:simpleType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_WrongChoices ()
+		{
+			XmlSchemas schemas = Export (typeof (WrongChoices), "NSWrongChoices");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSWrongChoices\" elementFormDefault=\"qualified\" targetNamespace=\"NSWrongChoices\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSWrongChoices\" targetNamespace=\"NSWrongChoices\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:complexType name=\"WrongChoices\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"MyChoice\" type=\"xs:string\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" form=\"unqualified\" name=\"ItemType\" type=\"tns:ItemChoiceType\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"MyChoice\" type=\"xs:string\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"ItemType\" type=\"tns:ItemChoiceType\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:simpleType name=\"ItemChoiceType\">{0}" +
+				"    <xs:restriction base=\"xs:string\">{0}" +
+				"      <xs:enumeration value=\"ChoiceZero\" />{0}" +
+				"      <xs:enumeration value=\"StrangeOne\" />{0}" +
+				"      <xs:enumeration value=\"ChoiceTwo\" />{0}" +
+				"    </xs:restriction>{0}" +
+				"  </xs:simpleType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_TestSpace ()
+		{
+			XmlSchemas schemas = Export (typeof (TestSpace), "NSTestSpace");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSTestSpace\" elementFormDefault=\"qualified\" targetNamespace=\"NSTestSpace\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSTestSpace\" targetNamespace=\"NSTestSpace\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:complexType name=\"TestSpace\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" form=\"unqualified\" name=\"elem\" type=\"xs:int\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"elem\" type=\"xs:int\" />{0}" +
+#endif
+#if NET_2_0
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" form=\"unqualified\" name=\"attr\" type=\"xs:int\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"attr\" type=\"xs:int\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_ReadOnlyProperties ()
+		{
+			XmlSchemas schemas = Export (typeof (ReadOnlyProperties), "NSReadOnlyProperties");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSReadOnlyProperties\" elementFormDefault=\"qualified\" targetNamespace=\"NSReadOnlyProperties\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSReadOnlyProperties\" targetNamespace=\"NSReadOnlyProperties\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:complexType name=\"ReadOnlyProperties\" />{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_ListDefaults ()
+		{
+			XmlSchemas schemas = Export (typeof (ListDefaults), "NSListDefaults");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSListDefaults\" elementFormDefault=\"qualified\" targetNamespace=\"NSListDefaults\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSListDefaults\" targetNamespace=\"NSListDefaults\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"ListDefaults\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"list2\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"list3\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"list4\" type=\"tns:ArrayOfString\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"list5\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"ed\" type=\"tns:SimpleClass\" />{0}" +
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"str\" type=\"xs:string\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"list2\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"list3\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"list4\" type=\"tns:ArrayOfString\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"list5\" type=\"tns:ArrayOfAnyType\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"ed\" type=\"tns:SimpleClass\" />{0}" +
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"str\" type=\"xs:string\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:anyType[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"SimpleClass\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"something\" type=\"xs:string\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"something\" type=\"xs:string\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfString\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q2=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q2:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:string[]\" ref=\"q2:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_ClsPerson ()
+		{
+			XmlSchemas schemas = Export (typeof (clsPerson), "NSClsPerson");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSClsPerson\" elementFormDefault=\"qualified\" targetNamespace=\"NSClsPerson\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+ "<xs:schema xmlns:tns=\"NSClsPerson\" targetNamespace=\"NSClsPerson\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+ "  <xs:import namespace=\"http://schemas.xmlsoap.org/soap/encoding/\" />{0}" +
+				"  <xs:import namespace=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"  <xs:complexType name=\"clsPerson\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"EmailAccounts\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#else
+ "      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"EmailAccounts\" type=\"tns:ArrayOfAnyType\" />{0}" +
+#endif
+ "    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:complexType name=\"ArrayOfAnyType\">{0}" +
+				"    <xs:complexContent mixed=\"false\">{0}" +
+				"      <xs:restriction xmlns:q1=\"http://schemas.xmlsoap.org/soap/encoding/\" base=\"q1:Array\">{0}" +
+				"        <xs:attribute d5p1:arrayType=\"xs:anyType[]\" ref=\"q1:arrayType\" xmlns:d5p1=\"http://schemas.xmlsoap.org/wsdl/\" />{0}" +
+				"      </xs:restriction>{0}" +
+				"    </xs:complexContent>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+		public void ExportClass_ArrayClass ()
+		{
+			XmlSchemas schemas = Export (typeof (ArrayClass), "NSArrayClass");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSArrayClass\" elementFormDefault=\"qualified\" targetNamespace=\"NSArrayClass\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSArrayClass\" targetNamespace=\"NSArrayClass\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:complexType name=\"ArrayClass\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"0\" maxOccurs=\"1\" form=\"unqualified\" name=\"names\" type=\"xs:anyType\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"names\" type=\"xs:anyType\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"</xs:schema>", Environment.NewLine), sw.ToString (), "#4");
+		}
+
+		[Test]
+		public void ExportClass_StructContainer ()
+		{
+			XmlSchemas schemas = Export (typeof (StructContainer), "NSStructContainer");
+			Assert.AreEqual (1, schemas.Count, "#1");
+
+			StringWriter sw = new StringWriter ();
+			schemas[0].Write (sw);
+
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version=\"1.0\" encoding=\"utf-16\"?>{0}" +
+#if NET_2_0
+				"<xs:schema xmlns:tns=\"NSStructContainer\" elementFormDefault=\"qualified\" targetNamespace=\"NSStructContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#else
+				"<xs:schema xmlns:tns=\"NSStructContainer\" targetNamespace=\"NSStructContainer\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">{0}" +
+#endif
+				"  <xs:complexType name=\"StructContainer\">{0}" +
+				"    <xs:sequence>{0}" +
+#if NET_2_0
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" form=\"unqualified\" name=\"Value\" type=\"tns:EnumDefaultValue\" />{0}" +
+#else
+				"      <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"Value\" type=\"tns:EnumDefaultValue\" />{0}" +
+#endif
+				"    </xs:sequence>{0}" +
+				"  </xs:complexType>{0}" +
+				"  <xs:simpleType name=\"EnumDefaultValue\">{0}" +
+				"    <xs:list>{0}" +
+				"      <xs:simpleType>{0}" +
+				"        <xs:restriction base=\"xs:string\">{0}" +
+				"          <xs:enumeration value=\"e1\" />{0}" +
+				"          <xs:enumeration value=\"e2\" />{0}" +
+				"          <xs:enumeration value=\"e3\" />{0}" +
+				"        </xs:restriction>{0}" +
+				"      </xs:simpleType>{0}" +
+				"    </xs:list>{0}" +
+				"  </xs:simpleType>{0}" +
+ 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
+		}
+
+		[Test]
+#if NET_2_0
+		[Category ("NotWorking")] // minOccurs is 1 on Mono
+#endif
+		public void ExportClass_SimpleClass_Array ()
+		{
 			SoapAttributeOverrides overrides = new SoapAttributeOverrides ();
 			SoapAttributes attr = new SoapAttributes ();
 			SoapElementAttribute element = new SoapElementAttribute ();
@@ -169,15 +833,9 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void ExportEnum ()
 		{
-			SoapReflectionImporter ri = new SoapReflectionImporter ("NSEnumDefaultValue");
-			XmlSchemas schemas = new XmlSchemas ();
-			SoapSchemaExporter sx = new SoapSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (EnumDefaultValue));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (EnumDefaultValue), "NSEnumDefaultValue");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -203,12 +861,7 @@
 				"  </xs:simpleType>{0}" +
 				"</xs:schema>", Environment.NewLine), sw.ToString (), "#2");
 
-			ri = new SoapReflectionImporter ("NSEnumDefaultValueNF");
-			schemas = new XmlSchemas ();
-			sx = new SoapSchemaExporter (schemas);
-			tm = ri.ImportTypeMapping (typeof (EnumDefaultValueNF));
-			sx.ExportTypeMapping (tm);
-
+			schemas = Export (typeof (EnumDefaultValueNF), "NSEnumDefaultValueNF");
 			Assert.AreEqual (1, schemas.Count, "#3");
 
 			sw = new StringWriter ();
@@ -232,7 +885,6 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void ExportXsdPrimitive ()
 		{
 			ArrayList types = new ArrayList ();
@@ -258,31 +910,19 @@
 			types.Add (new TypeDescription (typeof (string), true, "string", "String", true));
 
 			foreach (TypeDescription typeDesc in types) {
-				SoapReflectionImporter ri = new SoapReflectionImporter (typeDesc.Type.Name);
-				XmlSchemas schemas = new XmlSchemas ();
-				SoapSchemaExporter sx = new SoapSchemaExporter (schemas);
-				XmlTypeMapping tm = ri.ImportTypeMapping (typeDesc.Type);
-				sx.ExportTypeMapping (tm);
-
+				XmlSchemas schemas = Export (typeDesc.Type, typeDesc.Type.Name);
 				Assert.AreEqual (0, schemas.Count, typeDesc.Type.FullName + "#1");
 			}
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void ExportXsdPrimitive_ByteArray ()
 		{
-			SoapReflectionImporter ri = new SoapReflectionImporter ("ByteArray");
-			XmlSchemas schemas = new XmlSchemas ();
-			SoapSchemaExporter sx = new SoapSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (byte[]));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (byte[]), "ByteArray");
 			Assert.AreEqual (0, schemas.Count, "#1");
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void ExportXsdPrimitive_Arrays ()
 		{
 			ArrayList types = new ArrayList ();
@@ -307,12 +947,7 @@
 			types.Add (new TypeDescription (typeof (string[]), true, "string", "String", true));
 
 			foreach (TypeDescription typeDesc in types) {
-				SoapReflectionImporter ri = new SoapReflectionImporter (typeDesc.Type.Name);
-				XmlSchemas schemas = new XmlSchemas ();
-				SoapSchemaExporter sx = new SoapSchemaExporter (schemas);
-				XmlTypeMapping tm = ri.ImportTypeMapping (typeDesc.Type);
-				sx.ExportTypeMapping (tm);
-
+				XmlSchemas schemas = Export (typeDesc.Type, typeDesc.Type.Name);
 				Assert.AreEqual (1, schemas.Count, typeDesc.Type.FullName + "#1");
 
 				StringWriter sw = new StringWriter ();
@@ -341,15 +976,9 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void ExportNonXsdPrimitive_Guid ()
 		{
-			SoapReflectionImporter ri = new SoapReflectionImporter ("NSPrimGuid");
-			XmlSchemas schemas = new XmlSchemas ();
-			SoapSchemaExporter sx = new SoapSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (Guid));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (Guid), "NSPrimGuid");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -371,15 +1000,9 @@
 		}
 
 		[Test]
-		[Category ("NotWorking")]
 		public void ExportNonXsdPrimitive_Char ()
 		{
-			SoapReflectionImporter ri = new SoapReflectionImporter ("NSPrimChar");
-			XmlSchemas schemas = new XmlSchemas ();
-			SoapSchemaExporter sx = new SoapSchemaExporter (schemas);
-			XmlTypeMapping tm = ri.ImportTypeMapping (typeof (Char));
-			sx.ExportTypeMapping (tm);
-
+			XmlSchemas schemas = Export (typeof (Char), "NSPrimChar");
 			Assert.AreEqual (1, schemas.Count, "#1");
 
 			StringWriter sw = new StringWriter ();
@@ -429,6 +1052,11 @@
 			}
 		}
 
+		public class StructContainer
+		{
+			public EnumDefaultValue Value;
+		}
+
 		private class TypeDescription
 		{
 			public TypeDescription (Type type, bool xsdType, string xmlType, string arrayType)
Index: Test/System.Xml.Serialization/XmlSerializerTestClasses.cs
===================================================================
--- Test/System.Xml.Serialization/XmlSerializerTestClasses.cs	(revision 55191)
+++ Test/System.Xml.Serialization/XmlSerializerTestClasses.cs	(working copy)
@@ -12,8 +12,9 @@
 using System;
 using System.ComponentModel;
 using System.Collections;
+using System.Xml;
+using System.Xml.Schema;
 using System.Xml.Serialization;
-using System.Xml;
 
 namespace MonoTests.System.Xml.TestClasses
 {
@@ -80,6 +81,23 @@
 	{
 		[XmlAttribute("modifiers")]
 		public MapModifiers Modifiers;
+
+		[XmlAttribute ("modifiers2", Form=XmlSchemaForm.Unqualified)]
+		public MapModifiers Modifiers2;
+
+		[XmlAttribute ("modifiers3")]
+		[DefaultValue (0)]
+		public MapModifiers Modifiers3;
+
+		[XmlAttribute ("modifiers4", Form=XmlSchemaForm.Unqualified)]
+		[DefaultValue (0)]
+		public MapModifiers Modifiers4;
+
+		[XmlAttribute ("names")]
+		public string[] Names;
+
+		[XmlAttribute ("street")]
+		public string Street;
 	}
 
 	[Flags]
@@ -90,7 +108,7 @@
 		[XmlEnum("protected")]
 		Protected = 1,
 	}
-	
+
 	public class MyList : ArrayList
 	{
 		object container;
@@ -121,39 +139,39 @@
 		public Container2 (bool b) {
 			Items = new MyList(this);
 		}
-	}
+	}
 
-	public class MyElem: XmlElement
-	{
-		public MyElem (XmlDocument doc): base ("","myelem","", doc)
-		{
-			SetAttribute ("aa","1");
-		}
-
-		[XmlAttribute]
-		public int kk=1;
-	}
+	public class MyElem: XmlElement
+	{
+		public MyElem (XmlDocument doc): base ("","myelem","", doc)
+		{
+			SetAttribute ("aa","1");
+		}
 
-	public class MyDocument: XmlDocument
-	{
-		public MyDocument ()
-		{
-		}
-
-		[XmlAttribute]
-		public int kk=1;
-	}
-	
-	public class CDataContainer
-	{
-		public XmlCDataSection cdata;
-	}
-	
-	public class NodeContainer
-	{
-		public XmlNode node;
+		[XmlAttribute]
+		public int kk=1;
 	}
+
+	public class MyDocument: XmlDocument
+	{
+		public MyDocument ()
+		{
+		}
+
+		[XmlAttribute]
+		public int kk=1;
+	}
 	
+	public class CDataContainer
+	{
+		public XmlCDataSection cdata;
+	}
+	
+	public class NodeContainer
+	{
+		public XmlNode node;
+	}
+	
 	public class Choices
 	{
 		[XmlElementAttribute("ChoiceZero", typeof(string), IsNullable=false)]
@@ -185,73 +203,73 @@
 
 		[XmlIgnore]
 		public ItemChoiceType ItemType;
-	}
-	
-	[XmlType ("Type with space")]
-	public class TestSpace
-	{
-	   [XmlElement (ElementName = "Element with space")]
-	   public int elem;
-	    
-	   [XmlAttribute (AttributeName = "Attribute with space")]
-	   public int attr; 
-	}
+	}
+	
+	[XmlType ("Type with space")]
+	public class TestSpace
+	{
+	   [XmlElement (ElementName = "Element with space")]
+	   public int elem;
+	    
+	   [XmlAttribute (AttributeName = "Attribute with space")]
+	   public int attr; 
+	}
 
-	[Serializable]
-	public class ReadOnlyProperties {
-		string[] strArr = new string[2] { "string1", "string2" };
-
-		public string[] StrArr {
-			get { return strArr; }
-		}
-		
-		public string dat {
-			get { return "fff"; }
-		} 
-	}
-	
-	[XmlRoot("root")]
-	public class ListDefaults
-	{
-		public ListDefaults ()
-		{
-			ed = new SimpleClass ();
-			str = "hola";
-		}
-		
-	    public ArrayList list2;
-	    
-	    public MyList list3;
-	    
-	    public string[] list4;
-	    
-		[XmlElement("e", typeof(SimpleClass))]
-	    public ArrayList list5;
-	    
-		[DefaultValue (null)]
-	    public SimpleClass ed;
-	    
-		[DefaultValue (null)]
-	    public string str; 
-	}
-	
-	public class clsPerson
-	{
-		public IList EmailAccounts;
-	}
-	
-	public class ArrayClass
-	{
-		public object names = new object[] { "un","dos" };
-	}
-	
-	public class CompositeValueType
-	{
-		public void Init ()
-		{
-	   		Items = new object[] { 1, 2 };
-	   		ItemsElementName = new ItemsChoiceType[] { ItemsChoiceType.In, ItemsChoiceType.Es };
+	[Serializable]
+	public class ReadOnlyProperties {
+		string[] strArr = new string[2] { "string1", "string2" };
+
+		public string[] StrArr {
+			get { return strArr; }
 		}
+		
+		public string dat {
+			get { return "fff"; }
+		} 
+	}
+	
+	[XmlRoot("root")]
+	public class ListDefaults
+	{
+		public ListDefaults ()
+		{
+			ed = new SimpleClass ();
+			str = "hola";
+		}
+		
+	    public ArrayList list2;
+	    
+	    public MyList list3;
+	    
+	    public string[] list4;
+	    
+		[XmlElement("e", typeof(SimpleClass))]
+	    public ArrayList list5;
+	    
+		[DefaultValue (null)]
+	    public SimpleClass ed;
+	    
+		[DefaultValue (null)]
+	    public string str; 
+	}
+	
+	public class clsPerson
+	{
+		public IList EmailAccounts;
+	}
+	
+	public class ArrayClass
+	{
+		public object names = new object[] { "un","dos" };
+	}
+	
+	public class CompositeValueType
+	{
+		public void Init ()
+		{
+	   		Items = new object[] { 1, 2 };
+	   		ItemsElementName = new ItemsChoiceType[] { ItemsChoiceType.In, ItemsChoiceType.Es };
+		}
 	   
 		[XmlElementAttribute("Es", typeof(int))]
 		[XmlElementAttribute("In", typeof(int))]
@@ -262,174 +280,174 @@
 		[XmlIgnoreAttribute()]
 		public ItemsChoiceType[] ItemsElementName;
 	}
-
+
 	public enum ItemsChoiceType {
 	   In, Es
-	}
-	
-	public class ArrayAttributeWithType
-	{
-		[XmlAttribute (DataType="anyURI")]
-		public string[] at = new string [] { "a","b" };
-
-		[XmlAttribute (DataType="base64Binary")]
-		public byte[][] bin1 = new byte[][] { new byte[]{1,2},  new byte[]{1,2}};
-		
-		[XmlAttribute (DataType="base64Binary")]
-		public byte[] bin2 = new byte[] { 1,2 };
-	}
-	
-	public class ArrayAttributeWithWrongType
-	{
-		[XmlAttribute (DataType="int")]
-		public string[] at = new string [] { "a","b" };
-	}
-	
-	[XmlType ("Container")]
-	public class EntityContainer
-	{
-		EntityCollection collection1;
-		EntityCollection collection2;
-		EntityCollection collection3 = new EntityCollection ("root");
-		EntityCollection collection4 = new EntityCollection ("root");
-		
-		[XmlArray (IsNullable=true)]
-		public EntityCollection Collection1 {
-			get { return collection1; }
-			set { collection1 = value; collection1.Container = "assigned"; }
-		}
-		
-		[XmlArray (IsNullable=false)]
-		public EntityCollection Collection2 {
-			get { return collection2; }
-			set { collection2 = value; collection2.Container = "assigned"; }
-		}
-		
-		[XmlArray (IsNullable=true)]
-		public EntityCollection Collection3 {
-			get { return collection3; }
-			set { collection3 = value; collection3.Container = "assigned"; }
-		}
-		
-		[XmlArray (IsNullable=false)]
-		public EntityCollection Collection4 {
-			get { return collection4; }
-			set { collection4 = value; collection4.Container = "assigned"; }
-		}
-	}
-	
-	[XmlType ("Container")]
-	public class ArrayEntityContainer
-	{
-		Entity[] collection1;
-		Entity[] collection2;
-		Entity[] collection3 = new Entity [0];
-		Entity[] collection4 = new Entity [0];
-		
-		[XmlArray (IsNullable=true)]
-		public Entity[] Collection1 {
-			get { return collection1; }
-			set { collection1 = value; }
-		}
-		
-		[XmlArray (IsNullable=false)]
-		public Entity[] Collection2 {
-			get { return collection2; }
-			set { collection2 = value; }
-		}
-		
-		[XmlArray (IsNullable=true)]
-		public Entity[] Collection3 {
-			get { return collection3; }
-			set { collection3 = value; }
-		}
-		
-		[XmlArray (IsNullable=false)]
-		public Entity[] Collection4 {
-			get { return collection4; }
-			set { collection4 = value; }
-		}
-	}
-	
-	public class Entity
-	{
-		private string _name = string.Empty;
-		private string _parent = null;
-
-		[XmlAttribute]
-		public string Name {
-			get { return _name; }
-			set { _name = value; }
-		}
-
-		[XmlIgnore] 
-		public string Parent {
-			get { return _parent; }
-			set { _parent = value; }
-		}
-	}
-
-	public class EntityCollection : ArrayList
-	{
-		public string _container;
-
-		public EntityCollection ()
-		{
-		}
-
-		public EntityCollection (string c)
-		{
-			_container = c;
-		}
-
-		public string Container {
-			get { return _container; }
-			set { _container = value; }
-		}
-
-		public int Add (Entity value)
-		{
-			if(_container != null)
-				value.Parent = _container;
-
-			return base.Add(value);
-		}
-
-		public new Entity this[int index]
-		{
-			get { return (Entity) base[index]; }
-			set { base[index] = value; }
-		}
-	}
-	
-	[XmlType ("Container")]
-	public class ObjectWithReadonlyCollection
-	{
-		EntityCollection collection1 = new EntityCollection ("root");
-		
-		public EntityCollection Collection1 {
-			get { return collection1; }
-		}
-	}
-	
-	[XmlType ("Container")]
-	public class ObjectWithReadonlyNulCollection
-	{
-		EntityCollection collection1;
-		
-		public EntityCollection Collection1 {
-			get { return collection1; }
-		}
-	}
-	
-	[XmlType ("Container")]
-	public class ObjectWithReadonlyArray
-	{
-		Entity[] collection1 = new Entity [0];
-		
-		public Entity[] Collection1 {
-			get { return collection1; }
-		}
-	}
+	}
+	
+	public class ArrayAttributeWithType
+	{
+		[XmlAttribute (DataType="anyURI")]
+		public string[] at = new string [] { "a","b" };
+
+		[XmlAttribute (DataType="base64Binary")]
+		public byte[][] bin1 = new byte[][] { new byte[]{1,2},  new byte[]{1,2}};
+		
+		[XmlAttribute (DataType="base64Binary")]
+		public byte[] bin2 = new byte[] { 1,2 };
+	}
+	
+	public class ArrayAttributeWithWrongType
+	{
+		[XmlAttribute (DataType="int")]
+		public string[] at = new string [] { "a","b" };
+	}
+	
+	[XmlType ("Container")]
+	public class EntityContainer
+	{
+		EntityCollection collection1;
+		EntityCollection collection2;
+		EntityCollection collection3 = new EntityCollection ("root");
+		EntityCollection collection4 = new EntityCollection ("root");
+		
+		[XmlArray (IsNullable=true)]
+		public EntityCollection Collection1 {
+			get { return collection1; }
+			set { collection1 = value; collection1.Container = "assigned"; }
+		}
+		
+		[XmlArray (IsNullable=false)]
+		public EntityCollection Collection2 {
+			get { return collection2; }
+			set { collection2 = value; collection2.Container = "assigned"; }
+		}
+		
+		[XmlArray (IsNullable=true)]
+		public EntityCollection Collection3 {
+			get { return collection3; }
+			set { collection3 = value; collection3.Container = "assigned"; }
+		}
+		
+		[XmlArray (IsNullable=false)]
+		public EntityCollection Collection4 {
+			get { return collection4; }
+			set { collection4 = value; collection4.Container = "assigned"; }
+		}
+	}
+	
+	[XmlType ("Container")]
+	public class ArrayEntityContainer
+	{
+		Entity[] collection1;
+		Entity[] collection2;
+		Entity[] collection3 = new Entity [0];
+		Entity[] collection4 = new Entity [0];
+		
+		[XmlArray (IsNullable=true)]
+		public Entity[] Collection1 {
+			get { return collection1; }
+			set { collection1 = value; }
+		}
+		
+		[XmlArray (IsNullable=false)]
+		public Entity[] Collection2 {
+			get { return collection2; }
+			set { collection2 = value; }
+		}
+		
+		[XmlArray (IsNullable=true)]
+		public Entity[] Collection3 {
+			get { return collection3; }
+			set { collection3 = value; }
+		}
+		
+		[XmlArray (IsNullable=false)]
+		public Entity[] Collection4 {
+			get { return collection4; }
+			set { collection4 = value; }
+		}
+	}
+	
+	public class Entity
+	{
+		private string _name = string.Empty;
+		private string _parent = null;
+
+		[XmlAttribute]
+		public string Name {
+			get { return _name; }
+			set { _name = value; }
+		}
+
+		[XmlIgnore] 
+		public string Parent {
+			get { return _parent; }
+			set { _parent = value; }
+		}
+	}
+
+	public class EntityCollection : ArrayList
+	{
+		public string _container;
+
+		public EntityCollection ()
+		{
+		}
+
+		public EntityCollection (string c)
+		{
+			_container = c;
+		}
+
+		public string Container {
+			get { return _container; }
+			set { _container = value; }
+		}
+
+		public int Add (Entity value)
+		{
+			if(_container != null)
+				value.Parent = _container;
+
+			return base.Add(value);
+		}
+
+		public new Entity this[int index]
+		{
+			get { return (Entity) base[index]; }
+			set { base[index] = value; }
+		}
+	}
+	
+	[XmlType ("Container")]
+	public class ObjectWithReadonlyCollection
+	{
+		EntityCollection collection1 = new EntityCollection ("root");
+		
+		public EntityCollection Collection1 {
+			get { return collection1; }
+		}
+	}
+	
+	[XmlType ("Container")]
+	public class ObjectWithReadonlyNulCollection
+	{
+		EntityCollection collection1;
+		
+		public EntityCollection Collection1 {
+			get { return collection1; }
+		}
+	}
+	
+	[XmlType ("Container")]
+	public class ObjectWithReadonlyArray
+	{
+		Entity[] collection1 = new Entity [0];
+		
+		public Entity[] Collection1 {
+			get { return collection1; }
+		}
+	}
 }
-
+
Index: System.Xml.Schema/XmlSchema.cs
===================================================================
--- System.Xml.Schema/XmlSchema.cs	(revision 54859)
+++ System.Xml.Schema/XmlSchema.cs	(working copy)
@@ -905,7 +905,7 @@
 				// Add the xml schema namespace. (It is done 
 				// only when no entry exists in Namespaces).
 				nss.Add ("xs", XmlSchema.Namespace);
-				if (TargetNamespace != null)
+				if (TargetNamespace != null && TargetNamespace.Length != 0)
 					nss.Add ("tns", TargetNamespace);
 			}
 
Index: System.Xml.Serialization/TypeData.cs
===================================================================
--- System.Xml.Serialization/TypeData.cs	(revision 55082)
+++ System.Xml.Serialization/TypeData.cs	(working copy)
@@ -31,6 +31,7 @@
 
 using System;
 using System.Collections;
+using System.Globalization;
 using System.Reflection;
 using System.Xml.Schema;
 
@@ -44,43 +45,64 @@
 		Type listItemType;
 		string typeName;
 		string fullTypeName;
+		string itemTypeName;
 		TypeData listItemTypeData;
 		TypeData listTypeData;
 		TypeData mappedType;
 		XmlSchemaPatternFacet facet;
 		bool hasPublicConstructor = true;
+		bool isFlags;
 
 		public TypeData (Type type, string elementName, bool isPrimitive) :
 			this(type, elementName, isPrimitive, null, null) {}
 
-		public TypeData (Type type, string elementName, bool isPrimitive, TypeData mappedType, XmlSchemaPatternFacet facet)
+
+		public TypeData (Type type, string elementName, bool isPrimitive, string itemTypeName) :
+			this (type, elementName, isPrimitive, null, null, itemTypeName) { }
+
+		public TypeData (Type type, string elementName, bool isPrimitive, TypeData mappedType, XmlSchemaPatternFacet facet) :
+			this (type, elementName, isPrimitive, mappedType, facet, null) { }
+
+		private TypeData (Type type, string elementName, bool isPrimitive, TypeData mappedType, XmlSchemaPatternFacet facet, string itemTypeName)
 		{
+			this.itemTypeName = itemTypeName; // we only need this for byte[]
 			this.mappedType = mappedType;
 			this.facet = facet;
 			this.type = type;
-			this.typeName = type.Name;
 			this.fullTypeName = type.FullName.Replace ('+', '.');
 
 			if (isPrimitive)
 				sType = SchemaTypes.Primitive;
 			else
 			{
-				if (type.IsEnum)
+				if (type.IsEnum) {
 					sType = SchemaTypes.Enum;
-				else if (typeof(IXmlSerializable).IsAssignableFrom (type))
+					isFlags = type.IsDefined (typeof (FlagsAttribute), false);
+				} else if (typeof (IXmlSerializable).IsAssignableFrom (type)) {
 					sType = SchemaTypes.XmlSerializable;
-				else if (typeof (System.Xml.XmlNode).IsAssignableFrom (type))
+				} else if (typeof (System.Xml.XmlNode).IsAssignableFrom (type)) {
 					sType = SchemaTypes.XmlNode;
-				else if (type.IsArray || typeof(IEnumerable).IsAssignableFrom (type))
+				} else if (type.IsArray || typeof (IEnumerable).IsAssignableFrom (type)) {
 					sType = SchemaTypes.Array;
-				else
+				} else {
 					sType = SchemaTypes.Class;
+				}
 			}
-			
-			if (IsListType)
+
+			if (IsListType) {
 				this.elementName = TypeTranslator.GetArrayName (ListItemTypeData.XmlType);
-			else
+#if NET_2_0
+				if (type.IsArray)
+					this.typeName = TypeTranslator.GetArrayName (ListItemTypeData.ItemTypeName);
+				else
+					this.typeName = type.Name;
+#else
+				this.typeName = type.Name;
+#endif
+			} else {
 				this.elementName = elementName;
+				this.typeName = type.Name;
+			}
 
 			if (sType == SchemaTypes.Array || sType == SchemaTypes.Class) {
 				hasPublicConstructor = !type.IsInterface && (type.IsArray || type.GetConstructor (Type.EmptyTypes) != null || type.IsAbstract || type.IsValueType);
@@ -159,6 +181,19 @@
 			}
 		}
 
+		public bool IsFlags {
+			get { return isFlags; }
+		}
+
+		public string ItemTypeName {
+			get {
+				if (itemTypeName == null) {
+					return typeName;
+				}
+				return itemTypeName;
+			}
+		}
+
 		public TypeData ListItemTypeData
 		{
 			get
@@ -187,20 +222,39 @@
 					PropertyInfo prop = GetIndexerProperty (type);
 					if (prop == null) 
 						throw new InvalidOperationException ("You must implement a default accessor on " + type.FullName + " because it inherits from ICollection");
-						
-					return prop.PropertyType;
+
+					listItemType = prop.PropertyType;
+
+					MethodInfo addMethod = type.GetMethod ("Add", new Type[] { listItemType });
+					if (addMethod == null)
+						throw CreateMissingAddMethodException (type, "ICollection",
+							listItemType);
 				}
-				else
+				else // at this point, we must be dealing with IEnumerable implementation
 				{
-					MethodInfo met = type.GetMethod ("Add");
-					if (met == null)
-						throw new InvalidOperationException ("The collection " + type.FullName + " must implement an Add method");
+					MethodInfo met = type.GetMethod ("GetEnumerator", Type.EmptyTypes);
+					if (met == null) { 
+						// get private implemenation
+						met = type.GetMethod ("System.Collections.IEnumerable.GetEnumerator",
+							BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance,
+							null, Type.EmptyTypes, null);
+					}
+					// determine ListItemType using IEnumerable.Current property
+					PropertyInfo prop = met.ReturnType.GetProperty ("Current");
+					if (prop == null)
+						listItemType = typeof (object);
+					else
+						listItemType = prop.PropertyType;
 
-					ParameterInfo[] pars = met.GetParameters();
-					if (pars.Length != 1)
-						throw new InvalidOperationException ("The Add method of the collection " + type.FullName + " must have only one parameter");
-					
-					return pars[0].ParameterType;
+					MethodInfo addMethod = type.GetMethod ("Add", new Type[] { listItemType });
+
+					// if necessary, we try to fall back to Add(System.Object) method
+					if (addMethod == null && listItemType != typeof (object))
+						addMethod = type.GetMethod ("Add", new Type[] { typeof (object) });
+
+					if (addMethod == null)
+						throw CreateMissingAddMethodException (type, "IEnumerable",
+							listItemType);
 				}
 
 				return listItemType;
@@ -255,5 +309,13 @@
 			}
 			return null;
 		}
+
+		private static InvalidOperationException CreateMissingAddMethodException (Type type, string inheritFrom, Type argumentType) {
+			return new InvalidOperationException (string.Format(CultureInfo.InvariantCulture,
+				"To be XML serializable, types which inherit from {0} must have " +
+				"an implementation of Add({1}) at all levels of their inheritance " +
+				"hierarchy. {2} does not implement Add({1}).", inheritFrom, 
+				argumentType.FullName, type.FullName));
+		}
 	}
 }
Index: System.Xml.Serialization/ChangeLog
===================================================================
--- System.Xml.Serialization/ChangeLog	(revision 55210)
+++ System.Xml.Serialization/ChangeLog	(working copy)
@@ -1,6 +1,49 @@
-2006-01-08  Gert Driesen  <drieseng@users.sourceforge.net>
+2006-01-22  Gert Driesen  <drieseng@users.sourceforge.net>
 
-	* XmlSchemaImporter.cs: Fixed line endings (to CRLF).
+	* XmlSerializer.cs: Added constant for WSDL Types namespace.
+	* TypeData.cs: Added ItemTypeName property, necessary for byte[] on
+	2.0 profile. Added IsFlags property for enums. On 2.0 profile, use
+	ListItemTypeData.ItemTypeName for TypeName property if SchemeType
+	is Array, and type is an array. For types implementing ICollection,
+	verify if there's an Add method for the ListItemType. For types
+	implementing IEnumerable, use the property type of the Current 
+	property of the enumerator as ListItemType, and verify if there's
+	a corresponding Add method, or an Add method taking an object as
+	argument.
+	* XmlSchemaExporter.cs: In ImportTypeMapping, report failure for
+	type with SchemeType XmlNode and with zero-length element name. For
+	encoded SOAP schema, also support exporting enum and array types.
+	To match MS.NET, never mark a type member nillable on 1.0 profile for
+	encoded SOAP schema. If exported type is non-xsd primitive type
+	(meaning char or guid), also import its namespace. Export bit field
+	enums as list of simple types. When exporting array schema, also
+	import SOAP encoding namespace if we're generating encoded SOAP
+	schema. Mark attribute required if it has no default value, is not
+	optional value type and is not a value type. Introduced 
+	XmlSchemaObjectContainer class that is used to achieve the same
+	order of elements than MS.NET.
+	* XmlReflectionImporter.cs: Added and used (wherever possible) Import
+	methods that take TypeData (instead of Type), as we need this when
+	a given type can be representing multiple XSD types (eg. DateTime
+	can represent dateTime, date, ...). If SchemaType is XmlNode, set
+	element name to string.Empty, and namespace to null. For non-XSD
+	primitive types, use http://microsoft.com/wsdl/types as namespace.
+	In 2.0 profile, QName is nillable.
+	* SoapReflectionImporter.cs: Added and used (wherever possible) Import
+	methods that take TypeData (instead of Type), as we need this when
+	a given type can be representing multiple XSD types (eg. DateTime
+	can represent dateTime, date, ...). Do not report failure when 
+	importing a value type. Do not register base type for types deriving
+	from ValueType. Report failure when attempting to import value type
+	list, and type is not a primitive type (meaning guid), and is not
+	an enum. Use http://microsoft.com/wsdl/types as namespace non-XSD
+	primitive types (meaning char and guid).
+	* XmlSchemaImporter.cs: Added ReflectType overload that takes TypeData
+	instead, as we need this to differentiate between different DateTime
+	based XSD primitive types (such as dateTime, date, ...).
+	* TypeTranslator.cs: Use ArrayOfByte ListItemTypeName for byte[] on
+	2.0 profile. Do not register TimeSpan as XSD primitive type, to match
+	MS.NET. duration XSD type is string backed, not TimeSpan.
 
 2006-01-07  Gert Driesen  <drieseng@users.sourceforge.net>
 
Index: System.Xml.Serialization/XmlSerializer.cs
===================================================================
--- System.Xml.Serialization/XmlSerializer.cs	(revision 55082)
+++ System.Xml.Serialization/XmlSerializer.cs	(working copy)
@@ -52,6 +52,7 @@
 	{
 		internal const string WsdlNamespace = "http://schemas.xmlsoap.org/wsdl/";
 		internal const string EncodingNamespace = "http://schemas.xmlsoap.org/soap/encoding/";
+		internal const string WsdlTypesNamespace = "http://microsoft.com/wsdl/types/";
 		static int generationThreshold;
 		static bool backgroundGeneration = true;
 		static bool deleteTempFiles = true;
Index: System.Xml.Serialization/XmlSchemaExporter.cs
===================================================================
--- System.Xml.Serialization/XmlSchemaExporter.cs	(revision 55082)
+++ System.Xml.Serialization/XmlSchemaExporter.cs	(working copy)
@@ -149,19 +149,22 @@
 						
 						XmlSchemaElement exe = FindElement (schema.Items, einfo.ElementName);
 						XmlSchemaElement elem;
-						
+
+						XmlSchemaObjectContainer container = null;
+						// In encoded format, the schema elements are not needed
+						if (!encodedFormat)
+							container = new XmlSchemaObjectContainer (schema);
+
 						Type memType = member.GetType();
 						if (member is XmlTypeMapMemberFlatList)
 							throw new InvalidOperationException ("Unwrapped arrays not supported as parameters");
 						else if (memType == typeof(XmlTypeMapMemberElement))
-							elem = (XmlSchemaElement) GetSchemaElement (schema, einfo, member.DefaultValue, false);
+							elem = (XmlSchemaElement) GetSchemaElement (schema, 
+								einfo, member.DefaultValue, false, container);
 						else
-							elem = (XmlSchemaElement) GetSchemaElement (schema, einfo, false);
+							elem = (XmlSchemaElement) GetSchemaElement (schema, 
+								einfo, false, container);
 						
-						// In encoded format, the schema elements are not needed
-						if (!encodedFormat)
-							schema.Items.Add (elem);
-						
 						if (exe != null)
 						{
 							if (exe.SchemaTypeName.Equals (elem.SchemaTypeName))
@@ -191,15 +194,28 @@
 		{
 			if (!xmlTypeMapping.IncludeInSchema) return;
 			if (IsElementExported (xmlTypeMapping)) return;
-			
-			if (encodedFormat)
-			{
-				ExportClassSchema (xmlTypeMapping);
-				XmlSchema schema = GetSchema (xmlTypeMapping.XmlTypeNamespace);
-				ImportNamespace (schema, XmlSerializer.EncodingNamespace);
+
+			if (xmlTypeMapping.TypeData.SchemaType == SchemaTypes.XmlNode && xmlTypeMapping.ElementName.Length == 0) {
+				throw new InvalidOperationException ("Cannot use wildcards at top level of a schema.");
 			}
-			else
-			{
+
+			if (encodedFormat) {
+				switch (xmlTypeMapping.TypeData.SchemaType) {
+				case SchemaTypes.Enum:
+					ExportEnumSchema (xmlTypeMapping);
+					break;
+				case SchemaTypes.Array:
+					ExportArraySchema (xmlTypeMapping, xmlTypeMapping.Namespace);
+					break;
+				case SchemaTypes.Primitive:
+					if (!xmlTypeMapping.TypeData.IsXsdType)
+						ExportDerivedSchema (xmlTypeMapping);
+					break;
+				default:
+					ExportClassSchema (xmlTypeMapping);
+					break;
+				}
+			} else {
 				XmlSchema schema = GetSchema (xmlTypeMapping.Namespace);
 				XmlTypeMapElementInfo einfo = new XmlTypeMapElementInfo (null, xmlTypeMapping.TypeData);
 				einfo.Namespace = xmlTypeMapping.Namespace;
@@ -207,7 +223,7 @@
 				if (xmlTypeMapping.TypeData.IsComplexType)
 					einfo.MappedType = xmlTypeMapping;
 				einfo.IsNullable = false;
-				schema.Items.Add (GetSchemaElement (schema, einfo, false));
+				GetSchemaElement (schema, einfo, false, new XmlSchemaObjectContainer (schema));
 				SetElementExported (xmlTypeMapping);
 			}
 			
@@ -218,31 +234,35 @@
 		{
 	        if (IsMapExported (map)) return;
 	        SetMapExported (map);
-	        
-	        if (map.Schema == null) return;
 
+			if (map.Schema == null)
+				return;
+
 			string targetNs = map.Schema.TargetNamespace;
-	        XmlSchema existingSchema = schemas [targetNs];
-	        if (existingSchema == null)
-	        {
+			XmlSchema existingSchema = schemas [targetNs];
+			if (existingSchema == null)
+			{
 				schemas.Add (map.Schema);
+#if ONLY_1_1
 				ImportNamespace (currentSchema, targetNs);
-	        }
-	        else if (existingSchema != map.Schema)
-	        {
-				throw new InvalidOperationException("The namespace '" + targetNs +"' defined by the class '" + map.TypeFullName + "' is a duplicate.");
-	        }
+#endif
+			}
+			else if (existingSchema != map.Schema)
+			{
+				throw new InvalidOperationException ("The namespace '" + targetNs + "' defined by the class '" + map.TypeFullName + "' is a duplicate.");
+			}
 		}
 
 		void ExportClassSchema (XmlTypeMapping map)
 		{
 			if (IsMapExported (map)) return;
 			SetMapExported (map);
-			
-			if (map.TypeData.Type == typeof(object))
-			{
-				foreach (XmlTypeMapping dmap in map.DerivedTypes)
-					if (dmap.TypeData.SchemaType == SchemaTypes.Class) ExportClassSchema (dmap);
+
+			if (map.TypeData.Type == typeof (object)) {
+				if (encodedFormat) {
+					foreach (XmlTypeMapping dmap in map.DerivedTypes)
+						if (dmap.TypeData.SchemaType == SchemaTypes.Class) ExportClassSchema (dmap);
+				}
 				return;
 			}
 
@@ -340,13 +360,13 @@
 					}
 					else if (memType == typeof(XmlTypeMapMemberElement))
 					{
-						XmlSchemaParticle elem = GetSchemaElement (schema, (XmlTypeMapElementInfo) member.ElementInfo [0], member.DefaultValue, true);
-						if (elem != null)
-							seq.Items.Add (elem);
+						GetSchemaElement (schema, (XmlTypeMapElementInfo) member.ElementInfo [0], 
+							member.DefaultValue, true, new XmlSchemaObjectContainer (seq));
 					}
 					else
 					{
-						seq.Items.Add (GetSchemaElement (schema, (XmlTypeMapElementInfo) member.ElementInfo [0], true));
+						GetSchemaElement (schema, (XmlTypeMapElementInfo) member.ElementInfo[0], 
+							true, new XmlSchemaObjectContainer (seq));
 					}
 				}
 			}
@@ -407,6 +427,9 @@
 
 			if (currentSchema == memberSchema || encodedFormat)
 			{
+				if (attinfo.DefaultValue == System.DBNull.Value && !attinfo.IsOptionalValueType && attinfo.TypeData.IsValueType)
+					sat.Use = XmlSchemaUse.Required;
+
 				sat.Name = attinfo.AttributeName;
 				if (isTypeMember) sat.Form = attinfo.Form;
 				if (attinfo.TypeData.SchemaType == SchemaTypes.Enum)
@@ -436,11 +459,16 @@
 
 		XmlSchemaParticle GetSchemaElement (XmlSchema currentSchema, XmlTypeMapElementInfo einfo, bool isTypeMember)
 		{
-			return GetSchemaElement (currentSchema, einfo, System.DBNull.Value, isTypeMember);
+			return GetSchemaElement (currentSchema, einfo, System.DBNull.Value, isTypeMember, (XmlSchemaObjectContainer) null);
 		}
-		
-		XmlSchemaParticle GetSchemaElement (XmlSchema currentSchema, XmlTypeMapElementInfo einfo, object defaultValue, bool isTypeMember)
+
+		XmlSchemaParticle GetSchemaElement (XmlSchema currentSchema, XmlTypeMapElementInfo einfo, bool isTypeMember, XmlSchemaObjectContainer container)
 		{
+			return GetSchemaElement (currentSchema, einfo, System.DBNull.Value, isTypeMember, container);
+		}
+
+		XmlSchemaParticle GetSchemaElement (XmlSchema currentSchema, XmlTypeMapElementInfo einfo, object defaultValue, bool isTypeMember, XmlSchemaObjectContainer container)
+		{
 			if (einfo.IsTextElement) return null;
 
 			if (einfo.IsUnnamedAnyElement)
@@ -448,18 +476,28 @@
 				XmlSchemaAny any = new XmlSchemaAny ();
 				any.MinOccurs = 0;
 				any.MaxOccurs = 1;
+
+				if (container != null)
+					container.Items.Add (any);
 				return any;
 			}
 			
 			XmlSchemaElement selem = new XmlSchemaElement ();
+			if (container != null)
+				container.Items.Add (selem);
 
 			if (isTypeMember)
 			{
 				selem.MaxOccurs = 1;
-				selem.MinOccurs = einfo.IsNullable ? 1 : 0;
 				
-				if ((einfo.TypeData.IsValueType && einfo.Member != null && !einfo.Member.IsOptionalValueType) || encodedFormat) 
+#if NET_2_0
+				if ((einfo.IsNullable || einfo.TypeData.IsValueType) && (einfo.Member == null || !einfo.Member.IsOptionalValueType))
+#else
+				if (((einfo.IsNullable || einfo.TypeData.IsValueType) && (einfo.Member == null || !einfo.Member.IsOptionalValueType)) || encodedFormat)
+#endif
 					selem.MinOccurs = 1;
+				else
+					selem.MinOccurs = 0;
 			}
 
 			XmlSchema memberSchema = null;
@@ -472,14 +510,26 @@
 			
 			if (currentSchema == memberSchema || encodedFormat || !isTypeMember)
 			{
+#if NET_2_0
 				if (isTypeMember) selem.IsNillable = einfo.IsNullable;
+#else
+				if (isTypeMember && !encodedFormat) selem.IsNillable = einfo.IsNullable;
+#endif
+
 				selem.Name = einfo.ElementName;
 
 				if (defaultValue != System.DBNull.Value)
 					selem.DefaultValue = XmlCustomFormatter.ToXmlString (einfo.TypeData, defaultValue);
 					
+#if NET_2_0
+				if (isTypeMember && encodedFormat)
+					selem.Form = XmlSchemaForm.Unqualified;
+				else if (einfo.Form != XmlSchemaForm.Qualified)
+					selem.Form = einfo.Form;
+#else
 				if (einfo.Form != XmlSchemaForm.Qualified)
 					selem.Form = einfo.Form;
+#endif
 
 				switch (einfo.TypeData.SchemaType)
 				{
@@ -488,7 +538,7 @@
 						break;
 
 					case SchemaTypes.XmlSerializable:
-						selem.SchemaType = GetSchemaXmlSerializableType (einfo.MappedType as XmlSerializableMapping);
+						selem.SchemaType = GetSchemaXmlSerializableType (currentSchema, einfo.MappedType as XmlSerializableMapping);
 						ExportXmlSerializableSchema (currentSchema, einfo.MappedType as XmlSerializableMapping);
 						break;
 
@@ -498,8 +548,8 @@
 						ExportEnumSchema (einfo.MappedType);
 						break;
 
-					case SchemaTypes.Array: 
-						XmlQualifiedName atypeName = ExportArraySchema (einfo.MappedType, currentSchema.TargetNamespace); 
+					case SchemaTypes.Array:
+						XmlQualifiedName atypeName = ExportArraySchema (einfo.MappedType, currentSchema.TargetNamespace);
 						selem.SchemaTypeName = atypeName;
 						ImportNamespace (currentSchema, atypeName.Namespace);
 						break;
@@ -508,17 +558,17 @@
 						if (einfo.MappedType.TypeData.Type != typeof(object)) {
 							selem.SchemaTypeName = new XmlQualifiedName (einfo.MappedType.XmlType, einfo.MappedType.XmlTypeNamespace);
 							ImportNamespace (currentSchema, einfo.MappedType.XmlTypeNamespace);
-						}
-						else if (encodedFormat)
+						} else if (encodedFormat)
 							selem.SchemaTypeName = new XmlQualifiedName (einfo.MappedType.XmlType, einfo.MappedType.XmlTypeNamespace);
-							
 						ExportClassSchema (einfo.MappedType);
 						break;
 
 					case SchemaTypes.Primitive:
 						selem.SchemaTypeName = new XmlQualifiedName (einfo.TypeData.XmlType, einfo.DataTypeNamespace);;
-						if (!einfo.TypeData.IsXsdType)
+						if (!einfo.TypeData.IsXsdType) {
+							ImportNamespace (currentSchema, einfo.MappedType.XmlTypeNamespace);
 							ExportDerivedSchema (einfo.MappedType);
+						}
 						break;
 				}
 			}
@@ -528,16 +578,16 @@
 				foreach (XmlSchemaObject ob in memberSchema.Items)
 					if (ob is XmlSchemaElement && ((XmlSchemaElement)ob).Name == einfo.ElementName)
 						return selem;
-						
-				memberSchema.Items.Add (GetSchemaElement (memberSchema, einfo, defaultValue, false));
+				
+				GetSchemaElement (memberSchema, einfo, defaultValue, false,
+					new XmlSchemaObjectContainer (memberSchema));
 			}
 			return selem;
 		}
 
 		void ImportNamespace (XmlSchema schema, string ns)
 		{
-			if (ns == null || ns.Length == 0 ||
-				ns == schema.TargetNamespace || ns == XmlSchema.Namespace) return;
+			if (ns == null || ns.Length == 0 || ns == schema.TargetNamespace) return;
 
 			foreach (XmlSchemaObject sob in schema.Includes)
 				if ((sob is XmlSchemaImport) && ((XmlSchemaImport)sob).Namespace == ns) return;
@@ -567,18 +617,20 @@
 			return stype;
 		}
 
-		XmlSchemaType GetSchemaXmlSerializableType (XmlSerializableMapping map)
+		XmlSchemaType GetSchemaXmlSerializableType (XmlSchema currentSchema, XmlSerializableMapping map)
 		{
 			XmlSchemaComplexType stype = new XmlSchemaComplexType ();
 			XmlSchemaSequence seq = new XmlSchemaSequence ();
 			if (map.Schema == null) {
+				ImportNamespace (currentSchema, XmlSchema.Namespace);
 				XmlSchemaElement selem = new XmlSchemaElement ();
-				selem.RefName = new XmlQualifiedName ("schema",XmlSchema.Namespace);
+				selem.RefName = new XmlQualifiedName ("schema", XmlSchema.Namespace);
 				seq.Items.Add (selem);
 				seq.Items.Add (new XmlSchemaAny ());
 			} else {
+				string tns = map.Schema.TargetNamespace;
 				XmlSchemaAny any = new XmlSchemaAny ();
-				any.Namespace = map.Schema.TargetNamespace;
+				any.Namespace = (tns == null) ? string.Empty : tns;
 				seq.Items.Add (any);
 			}
 			stype.Particle = seq;
@@ -616,7 +668,7 @@
 				foreach (XmlTypeMapElementInfo einfo in infos)
 				{
 					if (einfo.IsTextElement) continue;
-					schoice.Items.Add (GetSchemaElement (currentSchema, einfo, true));
+					GetSchemaElement (currentSchema, einfo, true, new XmlSchemaObjectContainer (schoice));
 				}
 				return schoice;
 			}
@@ -659,7 +711,16 @@
 				ef.Value = emem.XmlName;
 				rest.Facets.Add (ef);
 			}
-			stype.Content = rest;
+
+			if (map.TypeData.IsFlags) {
+				XmlSchemaSimpleTypeList slist = new XmlSchemaSimpleTypeList ();
+				XmlSchemaSimpleType restrictionType = new XmlSchemaSimpleType ();
+				restrictionType.Content = rest;
+				slist.ItemType = restrictionType;
+				stype.Content = slist;
+			} else {
+				stype.Content = rest;
+			}
 		}
 
 		XmlQualifiedName ExportArraySchema (XmlTypeMapping map, string defaultNamespace)
@@ -669,7 +730,8 @@
 			if (encodedFormat)
 			{
 				string name, ns, schemaNs;
-				lmap.GetArrayType (-1, out name, out ns);				
+				lmap.GetArrayType (-1, out name, out ns);
+
 				if (ns == XmlSchema.Namespace) schemaNs = defaultNamespace;
 				else schemaNs = ns;
 
@@ -691,6 +753,7 @@
 				XmlSchemaAttribute at = new XmlSchemaAttribute ();
 				rest.Attributes.Add (at);
 				at.RefName = new XmlQualifiedName ("arrayType", XmlSerializer.EncodingNamespace);
+				ImportNamespace (schema, XmlSerializer.EncodingNamespace);
 				
 				XmlAttribute arrayType = Document.CreateAttribute ("arrayType", XmlSerializer.WsdlNamespace);
 				arrayType.Value = ns + (ns != "" ? ":" : "") + name;
@@ -763,7 +826,6 @@
 		bool IsElementExported (XmlTypeMapping map)
 		{
 			if (exportedElements.ContainsKey (GetMapKey(map))) return true;
-			if (map.TypeData.Type == typeof(object)) return true;
 			return false;
 		}
 
@@ -777,9 +839,11 @@
 			// Don't use type name for array types, since we can have different
 			// classes that represent the same array type (for example
 			// StringCollection and string[]).
-			
+
 			if (map.TypeData.IsListType)
 				return GetArrayKeyName (map.TypeData) + " " + map.XmlType + " " + map.XmlTypeNamespace;
+			else if (map.TypeData.SchemaType == SchemaTypes.XmlSerializable)
+				return map.TypeData.FullTypeName + " " + map.XmlType;
 			else
 				return map.TypeData.FullTypeName + " " + map.XmlType + " " + map.XmlTypeNamespace;
 		}
@@ -802,8 +866,11 @@
 			if (schema == null)
 			{
 				schema = new XmlSchema ();
-				schema.TargetNamespace = ns;
+				if (ns != null && ns.Length != 0)
+					schema.TargetNamespace = ns;
+#if ONLY_1_1
 				if (!encodedFormat)
+#endif
 					schema.ElementFormDefault = XmlSchemaForm.Qualified;
 				schemas.Add (schema);
 			}
@@ -811,5 +878,30 @@
 		}
 
 		#endregion // Methods
+
+		private class XmlSchemaObjectContainer
+		{
+			private readonly XmlSchemaObject _xmlSchemaObject;
+
+			public XmlSchemaObjectContainer (XmlSchema schema)
+			{
+				_xmlSchemaObject = schema;
+			}
+
+			public XmlSchemaObjectContainer (XmlSchemaGroupBase group)
+			{
+				_xmlSchemaObject = group;
+			}
+
+			public XmlSchemaObjectCollection Items {
+				get {
+					if (_xmlSchemaObject is XmlSchema) {
+						return ((XmlSchema) _xmlSchemaObject).Items;
+					} else {
+						return ((XmlSchemaGroupBase) _xmlSchemaObject).Items;
+					}
+				}
+			}
+		}
 	}
 }
Index: System.Xml.Serialization/XmlReflectionImporter.cs
===================================================================
--- System.Xml.Serialization/XmlReflectionImporter.cs	(revision 55082)
+++ System.Xml.Serialization/XmlReflectionImporter.cs	(working copy)
@@ -170,26 +170,43 @@
 			if (type == typeof (void))
 				throw new InvalidOperationException ("Type " + type.Name + " may not be serialized.");
 
+			return ImportTypeMapping (TypeTranslator.GetTypeData (type), root, 
+				defaultNamespace);
+		}
+
+		internal XmlTypeMapping ImportTypeMapping (TypeData typeData, string defaultNamespace)
+		{
+			return ImportTypeMapping (typeData, (XmlRootAttribute) null, 
+				defaultNamespace);
+		}
+
+		private XmlTypeMapping ImportTypeMapping (TypeData typeData, XmlRootAttribute root, string defaultNamespace)
+		{
+			if (typeData == null)
+				throw new ArgumentNullException ("typeData");
+
+			if (typeData.Type == null)
+				throw new ArgumentException ("Specified TypeData instance does not have Type set.");
+
 			if (defaultNamespace == null) defaultNamespace = initialDefaultNamespace;
 			if (defaultNamespace == null) defaultNamespace = string.Empty;
 
 			XmlTypeMapping map;
 
-			switch (TypeTranslator.GetTypeData(type).SchemaType)
-			{
-				case SchemaTypes.Class: map = ImportClassMapping (type, root, defaultNamespace); break;
-				case SchemaTypes.Array: map = ImportListMapping (type, root, defaultNamespace, null, 0); break;
-				case SchemaTypes.XmlNode: map = ImportXmlNodeMapping (type, root, defaultNamespace); break;
-				case SchemaTypes.Primitive: map = ImportPrimitiveMapping (type, root, defaultNamespace); break;
-				case SchemaTypes.Enum: map = ImportEnumMapping (type, root, defaultNamespace); break;
-				case SchemaTypes.XmlSerializable: map = ImportXmlSerializableMapping (type, root, defaultNamespace); break;
-				default: throw new NotSupportedException ("Type " + type.FullName + " not supported for XML stialization");
+			switch (typeData.SchemaType) {
+				case SchemaTypes.Class: map = ImportClassMapping (typeData, root, defaultNamespace); break;
+				case SchemaTypes.Array: map = ImportListMapping (typeData, root, defaultNamespace, null, 0); break;
+				case SchemaTypes.XmlNode: map = ImportXmlNodeMapping (typeData, root, defaultNamespace); break;
+				case SchemaTypes.Primitive: map = ImportPrimitiveMapping (typeData, root, defaultNamespace); break;
+				case SchemaTypes.Enum: map = ImportEnumMapping (typeData, root, defaultNamespace); break;
+				case SchemaTypes.XmlSerializable: map = ImportXmlSerializableMapping (typeData, root, defaultNamespace); break;
+				default: throw new NotSupportedException ("Type " + typeData.Type.FullName + " not supported for XML serialization");
 			}
 
 			map.RelatedMaps = relatedMaps;
 			map.Format = SerializationFormat.Literal;
-			Type[] extraTypes = includedTypes != null ? (Type[])includedTypes.ToArray(typeof(Type)) : null;
-			map.Source = new XmlTypeSerializationSource (type, root, attributeOverrides, defaultNamespace, extraTypes);
+			Type[] extraTypes = includedTypes != null ? (Type[]) includedTypes.ToArray (typeof (Type)) : null;
+			map.Source = new XmlTypeSerializationSource (typeData.Type, root, attributeOverrides, defaultNamespace, extraTypes);
 			if (allowPrivateTypes) map.Source.CanBeGenerated = false;
 			return map;
 		}
@@ -214,7 +231,7 @@
 					throw new InvalidOperationException ("XmlRoot and XmlType attributes may not be specified for the type " + typeData.FullTypeName);
 			}
 
-			if (atts == null) 
+			if (atts == null)
 				atts = new XmlAttributes (typeData.Type);
 
 			if (atts.XmlRoot != null && root == null)
@@ -227,11 +244,14 @@
 
 				if (atts.XmlType.TypeName != null && atts.XmlType.TypeName != string.Empty)
 					defaultXmlType = XmlConvert.EncodeLocalName (atts.XmlType.TypeName);
-					
+
 				includeInSchema = atts.XmlType.IncludeInSchema;
 			}
 
-			elementName = defaultXmlType;
+			if (typeData.SchemaType == SchemaTypes.XmlNode)
+				elementName = string.Empty;
+			else
+				elementName = defaultXmlType;
 
 			if (root != null)
 			{
@@ -242,15 +262,27 @@
 				nullable = root.IsNullable;
 			}
 
-			if (rootNamespace == null) rootNamespace = "";
+			if (typeData.SchemaType == SchemaTypes.XmlNode)
+				rootNamespace = null;
+			else if (rootNamespace == null) 
+				rootNamespace = "";
+
 			if (typeNamespace == null) typeNamespace = rootNamespace;
-			
+
 			XmlTypeMapping map;
-			if (typeData.SchemaType == SchemaTypes.XmlSerializable)
+
+			switch (typeData.SchemaType) {
+			case SchemaTypes.XmlSerializable:
 				map = new XmlSerializableMapping (elementName, rootNamespace, typeData, defaultXmlType, typeNamespace);
-			else
+				break;
+			case SchemaTypes.Primitive:
+				map = new XmlTypeMapping (elementName, rootNamespace, typeData, defaultXmlType, XmlSerializer.WsdlTypesNamespace);
+				break;
+			default:
 				map = new XmlTypeMapping (elementName, rootNamespace, typeData, defaultXmlType, typeNamespace);
-				
+				break;
+			}
+
 			map.IncludeInSchema = includeInSchema;
 			map.IsNullable = nullable;
 			relatedMaps.Add (map);
@@ -261,6 +293,13 @@
 		XmlTypeMapping ImportClassMapping (Type type, XmlRootAttribute root, string defaultNamespace)
 		{
 			TypeData typeData = TypeTranslator.GetTypeData (type);
+			return ImportClassMapping (typeData, root, defaultNamespace);
+		}
+
+		XmlTypeMapping ImportClassMapping (TypeData typeData, XmlRootAttribute root, string defaultNamespace)
+		{
+			Type type = typeData.Type;
+
 			XmlTypeMapping map = helper.GetRegisteredClrType (type, GetTypeNamespace (typeData, root, defaultNamespace));
 			if (map != null) return map;
 
@@ -287,7 +326,6 @@
 						XmlTypeMapping bmap = ImportClassMapping (rmember.DeclaringType, root, defaultNamespace);
 						ns = bmap.XmlTypeNamespace;
 					}
-					
 					XmlTypeMapMember mem = CreateMapMember (type, rmember, ns);
 					mem.CheckOptionalValueType (type);
 					classMap.AddMember (mem);
@@ -312,7 +350,7 @@
 				XmlTypeMapping bmap = ImportClassMapping (type.BaseType, root, defaultNamespace);
 				ClassMap cbmap = bmap.ObjectMap as ClassMap;
 				
-				if (type.BaseType != typeof (object)) {
+				if (type.BaseType != typeof (object) && type.BaseType != typeof (ValueType)) {
 					map.BaseMap = bmap;
 					if (!cbmap.HasSimpleContent)
 						classMap.SetCanBeSimpleType (false);
@@ -394,6 +432,11 @@
 		XmlTypeMapping ImportListMapping (Type type, XmlRootAttribute root, string defaultNamespace, XmlAttributes atts, int nestingLevel)
 		{
 			TypeData typeData = TypeTranslator.GetTypeData (type);
+			return ImportListMapping (typeData, root, defaultNamespace, atts, nestingLevel);
+		}
+		XmlTypeMapping ImportListMapping (TypeData typeData, XmlRootAttribute root, string defaultNamespace, XmlAttributes atts, int nestingLevel)
+		{
+			Type type = typeData.Type;
 			ListMap obmap = new ListMap ();
 
 			if (!allowPrivateTypes)
@@ -479,7 +522,7 @@
 			do {
 				XmlTypeMapping foundMap = helper.GetRegisteredSchemaType (name, defaultNamespace);
 				if (foundMap == null) nameCount = -1;
-				else if (obmap.Equals (foundMap.ObjectMap) && typeData.Type == foundMap.TypeData.Type) return foundMap;
+				else if (obmap.Equals (foundMap.ObjectMap) && typeData.ListItemType == foundMap.TypeData.ListItemType) return foundMap;
 				else name = baseName + (nameCount++);
 			}
 			while (nameCount != -1);
@@ -505,12 +548,13 @@
 			return map;
 		}
 
-		XmlTypeMapping ImportXmlNodeMapping (Type type, XmlRootAttribute root, string defaultNamespace)
+		XmlTypeMapping ImportXmlNodeMapping (TypeData typeData, XmlRootAttribute root, string defaultNamespace)
 		{
-			XmlTypeMapping map = helper.GetRegisteredClrType (type, GetTypeNamespace (TypeTranslator.GetTypeData (type), root, defaultNamespace));
+			Type type = typeData.Type;
+			XmlTypeMapping map = helper.GetRegisteredClrType (type, GetTypeNamespace (typeData, root, defaultNamespace));
 			if (map != null) return map;
 
-			map = CreateTypeMapping (TypeTranslator.GetTypeData (type), root, null, defaultNamespace);
+			map = CreateTypeMapping (typeData, root, null, defaultNamespace);
 			helper.RegisterClrType (map, type, map.XmlTypeNamespace);
 			
 			if (type.BaseType != null)
@@ -525,9 +569,9 @@
 			return map;
 		}
 
-		XmlTypeMapping ImportPrimitiveMapping (Type type, XmlRootAttribute root, string defaultNamespace)
+		XmlTypeMapping ImportPrimitiveMapping (TypeData typeData, XmlRootAttribute root, string defaultNamespace)
 		{
-			TypeData typeData = TypeTranslator.GetTypeData (type);
+			Type type = typeData.Type;
 			XmlTypeMapping map = helper.GetRegisteredClrType (type, GetTypeNamespace (typeData, root, defaultNamespace));
 			if (map != null) return map;
 			map = CreateTypeMapping (typeData, root, null, defaultNamespace);
@@ -535,9 +579,9 @@
 			return map;
 		}
 
-		XmlTypeMapping ImportEnumMapping (Type type, XmlRootAttribute root, string defaultNamespace)
+		XmlTypeMapping ImportEnumMapping (TypeData typeData, XmlRootAttribute root, string defaultNamespace)
 		{
-			TypeData typeData = TypeTranslator.GetTypeData (type);
+			Type type = typeData.Type;
 			XmlTypeMapping map = helper.GetRegisteredClrType (type, GetTypeNamespace (typeData, root, defaultNamespace));
 			if (map != null) return map;
 			
@@ -567,9 +611,9 @@
 			return map;
 		}
 
-		XmlTypeMapping ImportXmlSerializableMapping (Type type, XmlRootAttribute root, string defaultNamespace)
+		XmlTypeMapping ImportXmlSerializableMapping (TypeData typeData, XmlRootAttribute root, string defaultNamespace)
 		{
-			TypeData typeData = TypeTranslator.GetTypeData (type);
+			Type type = typeData.Type;
 			XmlTypeMapping map = helper.GetRegisteredClrType (type, GetTypeNamespace (typeData, root, defaultNamespace));
 			if (map != null) return map;
 			
@@ -754,9 +798,6 @@
 
 				mapAttribute.AttributeName = XmlConvert.EncodeLocalName (mapAttribute.AttributeName);
 
-				if (typeData.IsComplexType)
-					mapAttribute.MappedType = ImportTypeMapping (typeData.Type, null, mapAttribute.Namespace);
-				
 				if (atts.XmlAttribute.Namespace != null && atts.XmlAttribute.Namespace != defaultNamespace)
 				{
 					if (atts.XmlAttribute.Form == XmlSchemaForm.Unqualified)
@@ -767,11 +808,11 @@
 				else
 				{
 					mapAttribute.Form = atts.XmlAttribute.Form;
-					if (atts.XmlAttribute.Form == XmlSchemaForm.Qualified)
-						mapAttribute.Namespace = defaultNamespace;
-					else
-						mapAttribute.Namespace = "";
+					mapAttribute.Namespace = defaultNamespace;
 				}
+
+				if (typeData.IsComplexType)
+					mapAttribute.MappedType = ImportTypeMapping (typeData.Type, null, mapAttribute.Namespace);
 				
 				typeData = TypeTranslator.GetTypeData(rmember.MemberType, atts.XmlAttribute.DataType);
 				mapMember = mapAttribute;
@@ -973,7 +1014,12 @@
 		
 		bool CanBeNull (TypeData type)
 		{
-			return (type.SchemaType != SchemaTypes.Primitive || type.Type == typeof (string));
+			return (type.SchemaType != SchemaTypes.Primitive || 
+#if NET_2_0
+				type.Type == typeof (string) || type.Type == typeof (XmlQualifiedName));
+#else
+				type.Type == typeof (string));
+#endif
 		}
 		
 		public void IncludeType (Type type)
Index: System.Xml.Serialization/SoapReflectionImporter.cs
===================================================================
--- System.Xml.Serialization/SoapReflectionImporter.cs	(revision 55082)
+++ System.Xml.Serialization/SoapReflectionImporter.cs	(working copy)
@@ -109,27 +109,38 @@
 			if (type == typeof (void))
 				throw new InvalidOperationException ("Type " + type.Name + " may not be serialized.");
 
+			return ImportTypeMapping (TypeTranslator.GetTypeData (type), 
+				defaultNamespace);
+		}
+
+		internal XmlTypeMapping ImportTypeMapping (TypeData typeData, string defaultNamespace)
+		{
+			if (typeData == null)
+				throw new ArgumentNullException ("typeData");
+
+			if (typeData.Type == null)
+				throw new ArgumentException ("Specified TypeData instance does not have Type set.");
+
 			string oldNs = initialDefaultNamespace;
 			if (defaultNamespace == null) defaultNamespace = initialDefaultNamespace;
 			if (defaultNamespace == null) defaultNamespace = string.Empty;
-			initialDefaultNamespace = defaultNamespace; 
+			initialDefaultNamespace = defaultNamespace;
 
 			XmlTypeMapping map;
-			switch (TypeTranslator.GetTypeData(type).SchemaType)
-			{
-				case SchemaTypes.Class: map = ImportClassMapping (type, defaultNamespace); break;
-				case SchemaTypes.Array: map = ImportListMapping (type, defaultNamespace); break;
-				case SchemaTypes.XmlNode: throw CreateTypeException (type);
-				case SchemaTypes.Primitive: map = ImportPrimitiveMapping (type, defaultNamespace); break;
-				case SchemaTypes.Enum: map = ImportEnumMapping (type, defaultNamespace); break;
+			switch (typeData.SchemaType) {
+				case SchemaTypes.Class: map = ImportClassMapping (typeData, defaultNamespace); break;
+				case SchemaTypes.Array: map = ImportListMapping (typeData, defaultNamespace); break;
+				case SchemaTypes.XmlNode: throw CreateTypeException (typeData.Type);
+				case SchemaTypes.Primitive: map = ImportPrimitiveMapping (typeData, defaultNamespace); break;
+				case SchemaTypes.Enum: map = ImportEnumMapping (typeData, defaultNamespace); break;
 				case SchemaTypes.XmlSerializable:
-				default: throw new NotSupportedException ("Type " + type.FullName + " not supported for XML serialization");
+				default: throw new NotSupportedException ("Type " + typeData.Type.FullName + " not supported for XML serialization");
 			}
 			map.RelatedMaps = relatedMaps;
 			map.Format = SerializationFormat.Encoded;
-			Type[] extraTypes = includedTypes != null ? (Type[])includedTypes.ToArray(typeof(Type)) : null;
-			map.Source = new SoapTypeSerializationSource (type, attributeOverrides, defaultNamespace, extraTypes);
-			
+			Type[] extraTypes = includedTypes != null ? (Type[]) includedTypes.ToArray (typeof (Type)) : null;
+			map.Source = new SoapTypeSerializationSource (typeData.Type, attributeOverrides, defaultNamespace, extraTypes);
+
 			initialDefaultNamespace = oldNs;
 			return map;
 		}
@@ -175,12 +186,18 @@
 
 		XmlTypeMapping ImportClassMapping (Type type, string defaultNamespace)
 		{
-			if (type.IsValueType) throw CreateStructException (type);
+			TypeData typeData = TypeTranslator.GetTypeData (type);
+			return ImportClassMapping (typeData, defaultNamespace);
+		}
+
+		XmlTypeMapping ImportClassMapping (TypeData typeData, string defaultNamespace)
+		{
+			Type type = typeData.Type;
+
 			if (type == typeof (object)) defaultNamespace = XmlSchema.Namespace;
 
 			ReflectionHelper.CheckSerializableType (type, false);
-				
-			TypeData typeData = TypeTranslator.GetTypeData (type);
+
 			XmlTypeMapping map = helper.GetRegisteredClrType (type, GetTypeNamespace (typeData, defaultNamespace));
 			if (map != null) return map;
 
@@ -201,6 +218,8 @@
 					if (rmember.SoapAttributes.SoapIgnore) continue;
 					classMap.AddMember (CreateMapMember (rmember, map.Namespace));
 				}
+			} catch (NotSupportedException) {
+				throw;
 			}
 			catch (Exception ex) 
 			{
@@ -228,7 +247,7 @@
 			{
 				XmlTypeMapping bmap = ImportClassMapping (type.BaseType, defaultNamespace);
 				
-				if (type.BaseType != typeof (object))
+				if (type.BaseType != typeof (object) && type.BaseType != typeof (ValueType))
 					map.BaseMap = bmap;
 					
 				// At this point, derived classes of this map must be already registered
@@ -278,16 +297,21 @@
 			else return membersNamespace;
 		}
 		
-		XmlTypeMapping ImportListMapping (Type type, string defaultNamespace)
+		XmlTypeMapping ImportListMapping (TypeData typeData, string defaultNamespace)
 		{
-			TypeData typeData = TypeTranslator.GetTypeData (type);
+			TypeData itemTypeData = typeData.ListItemTypeData;
+
+			if ((itemTypeData.IsValueType && itemTypeData.SchemaType != SchemaTypes.Primitive) && itemTypeData.SchemaType != SchemaTypes.Enum) {
+				throw new NotSupportedException ("Cannot serialize " + typeData.FullTypeName + 
+					". Arrays of structs are not supported with encoded SOAP");
+			}
+
+			Type type = typeData.Type;
 			XmlTypeMapping map = helper.GetRegisteredClrType (type, XmlSerializer.EncodingNamespace);
 			if (map != null) return map;
 
 			ListMap obmap = new ListMap ();
-			TypeData itemTypeData = typeData.ListItemTypeData;
-
-			map = CreateTypeMapping (typeData, "Array", XmlSerializer.EncodingNamespace);
+			map = CreateTypeMapping (typeData, null, defaultNamespace);
 			helper.RegisterClrType (map, type, XmlSerializer.EncodingNamespace);
 			map.MultiReferenceType = true;
 			map.ObjectMap = obmap;
@@ -321,20 +345,21 @@
 			return map;
 		}
 		
-		XmlTypeMapping ImportPrimitiveMapping (Type type, string defaultNamespace)
+		XmlTypeMapping ImportPrimitiveMapping (TypeData typeData, string defaultNamespace)
 		{
-			TypeData typeData = TypeTranslator.GetTypeData (type);
-			XmlTypeMapping map = helper.GetRegisteredClrType (type, GetTypeNamespace (typeData, defaultNamespace));
+			Type type = typeData.Type;
+			string ns = typeData.IsXsdType ? XmlSchema.Namespace : XmlSerializer.WsdlTypesNamespace;
+			XmlTypeMapping map = helper.GetRegisteredClrType (type, ns);
 			if (map != null) return map;
-			map = CreateTypeMapping (typeData, null, defaultNamespace);
+			map = CreateTypeMapping (typeData, null, ns);
 			helper.RegisterClrType (map, type, map.Namespace);
 			return map;
 		}
 
 
-		XmlTypeMapping ImportEnumMapping (Type type, string defaultNamespace)
+		XmlTypeMapping ImportEnumMapping (TypeData typeData, string defaultNamespace)
 		{
-			TypeData typeData = TypeTranslator.GetTypeData (type);
+			Type type = typeData.Type;
 			XmlTypeMapping map = helper.GetRegisteredClrType (type, GetTypeNamespace (typeData, defaultNamespace));
 			if (map != null) return map;
 			
Index: System.Xml.Serialization/XmlSchemaImporter.cs
===================================================================
--- System.Xml.Serialization/XmlSchemaImporter.cs	(revision 55210)
+++ System.Xml.Serialization/XmlSchemaImporter.cs	(working copy)
@@ -247,7 +247,7 @@
 			// Does not have the requested base type.
 			// Then, get/create a map for that base type.
 			
-			XmlTypeMapping baseMap = ReflectType (baseType, null);
+			XmlTypeMapping baseMap = ReflectType (baseType);
 			
 			// Add this map as a derived map of the base map
 
@@ -419,7 +419,7 @@
 			if (stype == null) {
 				// Importing a primitive type
 				TypeData td = TypeTranslator.GetPrimitiveTypeData (qname.Name);
-				return ReflectType (td.Type, name.Namespace);
+				return ReflectType (td, name.Namespace);
 			}
 			
 			XmlTypeMapping map = GetRegisteredTypeMapping (qname);
@@ -442,7 +442,6 @@
 			if (elem == null) return false;
 
 			// The root element must be an element with complex type
-
 			if (elem.SchemaType != null)
 			{
 				stype = elem.SchemaType;
@@ -450,7 +449,13 @@
 			}
 			else
 			{
-				if (elem.SchemaTypeName.IsEmpty) return false;
+				if (elem.SchemaTypeName.IsEmpty) {
+					if (elem.Name == "anyType") {
+						qname = name;
+						return true;
+					}
+					return false;
+				}
 				
 				object type = schemas.Find (elem.SchemaTypeName, typeof (XmlSchemaComplexType));
 				if (type == null) type = schemas.Find (elem.SchemaTypeName, typeof (XmlSchemaSimpleType));
@@ -1784,22 +1789,27 @@
 			}
 			return grp;
 		}
-		
-		XmlTypeMapping ReflectType (Type type, string ns)
+
+		XmlTypeMapping ReflectType (Type type)
 		{
+			TypeData typeData = TypeTranslator.GetTypeData (type);
+			return ReflectType (typeData, (string) null);
+		}
+
+		XmlTypeMapping ReflectType (TypeData typeData, string ns)
+		{
 			if (!encodedFormat)
 			{
 				if (auxXmlRefImporter == null) auxXmlRefImporter = new XmlReflectionImporter ();
-				return auxXmlRefImporter.ImportTypeMapping (type, ns);
+				return auxXmlRefImporter.ImportTypeMapping (typeData, ns);
 			}
 			else
 			{
 				if (auxSoapRefImporter == null) auxSoapRefImporter = new SoapReflectionImporter ();
-				return auxSoapRefImporter.ImportTypeMapping (type, ns);
+				return auxSoapRefImporter.ImportTypeMapping (typeData, ns);
 			}
 		}
 
-
 		string GetDocumentation (XmlSchemaAnnotated elem)
 		{
 			string res = "";
Index: System.Xml.Serialization/TypeTranslator.cs
===================================================================
--- System.Xml.Serialization/TypeTranslator.cs	(revision 55193)
+++ System.Xml.Serialization/TypeTranslator.cs	(working copy)
@@ -92,10 +92,13 @@
 			nameCache.Add (typeof (sbyte), new TypeData (typeof (sbyte), "byte", true));
 			nameCache.Add (typeof (char), new TypeData (typeof (char), "char", true, (TypeData)nameCache[typeof (ushort)], null));
 			nameCache.Add (typeof (object), new TypeData (typeof (object), "anyType", false));
+#if NET_2_0
+			nameCache.Add (typeof (byte[]), new TypeData (typeof (byte[]), "base64Binary", true, "ArrayOfByte"));
+#else
 			nameCache.Add (typeof (byte[]), new TypeData (typeof (byte[]), "base64Binary", true));
+#endif
 			nameCache.Add (typeof (XmlNode), new TypeData (typeof (XmlNode), "XmlNode", false));
 			nameCache.Add (typeof (XmlElement), new TypeData (typeof (XmlElement), "XmlElement", false));
-			nameCache.Add (typeof (TimeSpan), new TypeData (typeof (TimeSpan), "duration", true));
 
 			primitiveTypes = new Hashtable();
 			ICollection types = nameCache.Values;
@@ -107,6 +110,7 @@
 			primitiveTypes.Add ("date", new TypeData (typeof (DateTime), "date", true));	// TODO: timeInstant
 			primitiveTypes.Add ("time", new TypeData (typeof (DateTime), "time", true));
 			primitiveTypes.Add ("timePeriod", new TypeData (typeof (DateTime), "timePeriod", true));
+			primitiveTypes.Add ("duration", new TypeData (typeof (String), "duration", true));
 			primitiveTypes.Add ("gDay", new TypeData (typeof (string), "gDay", true));
 			primitiveTypes.Add ("gMonthDay", new TypeData (typeof (string), "gMonthDay", true));
 			primitiveTypes.Add ("gYear", new TypeData (typeof (string), "gYear", true));
@@ -237,7 +241,7 @@
 		{
 			return "ArrayOf" + Char.ToUpper (elemName [0], CultureInfo.InvariantCulture) + elemName.Substring (1);
 		}
-		
+
 		public static string GetArrayName (string elemName, int dimensions)
 		{
 			string aname = GetArrayName (elemName);
