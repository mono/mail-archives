Index: mono/mini/mini-x86.c
===================================================================
--- mono/mini/mini-x86.c	(revision 70826)
+++ mono/mini/mini-x86.c	(working copy)
@@ -49,12 +49,16 @@
 #ifdef PLATFORM_WIN32
 /* Under windows, the default pinvoke calling convention is stdcall */
 #define CALLCONV_IS_STDCALL(sig) ((((sig)->call_convention) == MONO_CALL_STDCALL) || ((sig)->pinvoke && ((sig)->call_convention) == MONO_CALL_DEFAULT))
+/* Under windows, thiscall works like this: 'this' pointer is stored in ECX during a call and the callee cleans up the stack */
+#define CALLCONV_IS_WIN32_THISCALL(sig) (((sig)->call_convention) == MONO_CALL_THISCALL)
 #else
 #define CALLCONV_IS_STDCALL(sig) (((sig)->call_convention) == MONO_CALL_STDCALL)
+#define CALLCONV_IS_WIN32_THISCALL(sig) FALSE
 #endif
 
+#define CALLEE_CLEANS_STACK(sig) (CALLCONV_IS_STDCALL(sig) || CALLCONV_IS_WIN32_THISCALL(sig))
+
 #define NOT_IMPLEMENTED g_assert_not_reached ()
-
 const char*
 mono_arch_regname (int reg) {
 	switch (reg) {
@@ -2359,11 +2363,15 @@
 		case OP_VOIDCALL:
 		case CEE_CALL:
 			call = (MonoCallInst*)ins;
+
+			if (CALLCONV_IS_WIN32_THISCALL (call->signature))
+				x86_pop_reg (code, X86_ECX);
+
 			if (ins->flags & MONO_INST_HAS_METHOD)
 				code = emit_call (cfg, code, MONO_PATCH_INFO_METHOD, call->method);
 			else
 				code = emit_call (cfg, code, MONO_PATCH_INFO_ABS, call->fptr);
-			if (call->stack_usage && !CALLCONV_IS_STDCALL (call->signature)) {
+			if (call->stack_usage && !CALLEE_CLEANS_STACK (call->signature)) {
 				/* a pop is one byte, while an add reg, imm is 3. So if there are 4 or 8
 				 * bytes to pop, we want to use pops. GCC does this (note it won't happen
 				 * for P4 or i686 because gcc will avoid using pop push at all. But we aren't
@@ -2393,8 +2401,12 @@
 		case OP_VOIDCALL_REG:
 		case OP_CALL_REG:
 			call = (MonoCallInst*)ins;
+
+			if (CALLCONV_IS_WIN32_THISCALL (call->signature))
+				x86_pop_reg (code, X86_ECX);
+
 			x86_call_reg (code, ins->sreg1);
-			if (call->stack_usage && !CALLCONV_IS_STDCALL (call->signature)) {
+			if (call->stack_usage && !CALLEE_CLEANS_STACK (call->signature)) {
 				if (call->stack_usage == 4)
 					x86_pop_reg (code, X86_ECX);
 				else
@@ -2408,8 +2420,12 @@
 		case OP_VOIDCALL_MEMBASE:
 		case OP_CALL_MEMBASE:
 			call = (MonoCallInst*)ins;
+
+			if (CALLCONV_IS_WIN32_THISCALL (call->signature))
+				x86_pop_reg (code, X86_ECX);
+
 			x86_call_membase (code, ins->sreg1, ins->inst_offset);
-			if (call->stack_usage && !CALLCONV_IS_STDCALL (call->signature)) {
+			if (call->stack_usage && !CALLEE_CLEANS_STACK (call->signature)) {
 				if (call->stack_usage == 4)
 					x86_pop_reg (code, X86_ECX);
 				else
@@ -3314,7 +3330,17 @@
 
 	cfg->code_size =  MAX (mono_method_get_header (method)->code_size * 4, 256);
 	code = cfg->native_code = g_malloc (cfg->code_size);
+	sig = mono_method_signature (method);
 
+	if (CALLCONV_IS_WIN32_THISCALL (sig))
+	{
+		/* 'this' pointer is passed through ECX,
+			put it on the stack before the return pointer to simulate a normal calling convention */
+		x86_pop_reg (code, X86_EAX);
+		x86_push_reg (code, X86_ECX);
+		x86_push_reg (code, X86_EAX);
+	}
+
 	x86_push_reg (code, X86_EBP);
 	x86_mov_reg_reg (code, X86_EBP, X86_ESP, 4);
 
@@ -3490,7 +3516,6 @@
 		code = mono_arch_instrument_prolog (cfg, mono_trace_enter_method, code, TRUE);
 
 	/* load arguments allocated to register from the stack */
-	sig = mono_method_signature (method);
 	pos = 0;
 
 	for (i = 0; i < sig->param_count + sig->hasthis; ++i) {
@@ -3639,7 +3664,7 @@
 
 	x86_leave (code);
 
-	if (CALLCONV_IS_STDCALL (sig)) {
+	if (CALLEE_CLEANS_STACK (sig)) {
 		MonoJitArgumentInfo *arg_info = alloca (sizeof (MonoJitArgumentInfo) * (sig->param_count + 1));
 
 		stack_to_pop = mono_arch_get_argument_info (sig, sig->param_count, arg_info);
