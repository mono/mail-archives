#!/usr/bin/perl -w

my %templates = (
	# typical sse instructions
	"XREG XREG XREG -> MEMBASE[2]" => [qw (ADDPD DIVPD MULPD SUBPD MAXPD)],
	# typical integer instruction
	"IREG IREG IREG -> IMM[2:NONE]" => [qw (IADD ISUB IMUL IDIV)],
);

my @data = (
# a more complex case: we generate several instructions
'COMPARE compare NONE IREG IREG -> IMM[2:NONE], MEMBASE_REG[1], MEMBASE_IMM[1 2:NONE], REG_MEMBASE[2]',
);

foreach my $template (keys %templates) {
	foreach my $op (@{$templates{$template}}) {
		push @data, "$op ". lc($op) . " $template";
	}
}

sub output {
	my @spec = @_;
	print "MONO_OP(OP_$spec[0], \"$spec[1]\", $spec[2], $spec[3], $spec[4])\n";
}

sub output_variant {
	my ($variant, @spec) = @_;
	my @orig = @spec;
	return unless $variant =~ /(\S+)\s*\[(.*)\]/;
	my $name = $1;
	my @regs = split (/\s/, $2);
	$spec [0] .= "_$name";
	$spec [1] .= "_" . lc $name;
	my $membase;
	foreach my $reg (@regs) {
		my ($num, $new) = split (/:/, $reg);
		$new = "IREG" unless defined $new;
		$spec [2 + $num] = $new;
		# we use the convention that the first one is the base pointer
		$membase = $num unless defined $membase;
	}
	output (@spec);
	my $orig = $spec[0];
	$orig =~ s/_MEMBASE//;
	# to be used in the switch in functions like op_to_op_* with something like:
	# #define OP_2_OP_REG1_MEMBASE(a,b) case a: return b;
	print "OP_2_OP_REG${membase}_MEMBASE(OP_$orig,OP_$spec[0])\n" if defined $membase && $name =~ /MEMBASE/;
}

sub generate {
	my $template = shift;
	my ($opcode, $variant) = split (/->/, $template);
	my @spec = split (/\s/, $opcode);
	output (@spec);
	return unless (defined $variant) and (length $variant);
	foreach my $var (split (/,/, $variant)) {
		# variants could go to a different output queue to
		# maintain instruction order currently required in the JIT
		output_variant ($var, @spec) 
	}
}

foreach my $op (@data) {
	generate ($op);
}

