Index: System.Collections/Hashtable.cs
===================================================================
--- System.Collections/Hashtable.cs	(revision 103725)
+++ System.Collections/Hashtable.cs	(working copy)
@@ -175,6 +175,31 @@
 		{
 		}
 
+		//
+		// Used as a faster Clone
+		//
+		internal Hashtable (Hashtable source)
+		{
+			inUse = source.inUse;
+			modificationCount = source.modificationCount;
+			loadFactor = source.loadFactor;
+			
+			int slen = source.table.Length;
+			table = new Slot [slen];
+			int hlen = source.hashes.Length;
+			hashes = new int [source.hashes.Length];
+			threshold = source.threshold;
+			hcpRef = source.hcpRef;
+			comparerRef = source.comparerRef;
+			serializationInfo = source.serializationInfo;
+
+			for (int i = 0; i < slen; i++)
+				table [i] = source.table [i];
+
+			for (int i = 0; i < hlen; i++)
+				hashes [i] = source.hashes [i];
+		}
+			
 #if NET_2_0
 		[Obsolete ("Please use Hashtable(int, IEqualityComparer) instead")]
 #endif
@@ -519,25 +544,7 @@
 
 		public virtual object Clone ()
 		{
-#if NET_2_0
-			Hashtable ht = new Hashtable (Count, equalityComparer);
-			ht.hcp = this.hcp;
-			ht.comparer = this.comparer;
-#else
-			Hashtable ht = new Hashtable (Count, hcp, comparer);
-#endif
-			ht.inUse = 0;
-			ht.loadFactor = this.loadFactor;
-
-			// FIXME: maybe it's faster to simply
-			//        copy the back-end array?
-
-			IDictionaryEnumerator it = GetEnumerator ();
-			while (it.MoveNext ()) {
-				ht [it.Key] = it.Value;
-			}
-
-			return ht;
+			return new Hashtable (this);
 		}
 
 		public virtual void GetObjectData (SerializationInfo info, StreamingContext context)
Index: System.Reflection/ParameterInfo.cs
===================================================================
--- System.Reflection/ParameterInfo.cs	(revision 103725)
+++ System.Reflection/ParameterInfo.cs	(working copy)
@@ -74,6 +74,7 @@
 			this.marshalAs = marshalAs;
 		}
 
+#if NET_2_0
 		public override string ToString() {
 			Type elementType = ClassImpl;
 			while (elementType.HasElementType) {
@@ -91,6 +92,7 @@
 			}
 			return result;
 		}
+#endif
 
 		public virtual Type ParameterType {
 			get {return ClassImpl;}
