Index: Test/Microsoft.Win32/RegistryKeyTest.cs
===================================================================
--- Test/Microsoft.Win32/RegistryKeyTest.cs	(revision 64755)
+++ Test/Microsoft.Win32/RegistryKeyTest.cs	(working copy)
@@ -43,9 +43,8 @@
 		[Test]
 		public void TestHandle ()
 		{
-			// this test is for Windows
-			int p = (int) Environment.OSVersion.Platform;
-			if ((p == 4) || (p == 128))
+			// this test is for Windows only
+			if (RunningOnUnix)
 				return;
 
 			// this regpath always exists under windows
@@ -150,6 +149,291 @@
 		}
 
 		[Test]
+		public void Close_Local_Hive ()
+		{
+			RegistryKey hive = Registry.CurrentUser;
+			hive.Close ();
+
+			Assert.IsNotNull (hive.GetSubKeyNames (), "#1");
+			Assert.IsNull (hive.GetValue ("doesnotexist"), "#2");
+			Assert.IsNotNull (hive.GetValueNames (), "#3");
+			Assert.IsNull (hive.OpenSubKey ("doesnotexist"), "#4");
+			Assert.IsNotNull (hive.SubKeyCount, "#5");
+			Assert.IsNotNull (hive.ToString (), "#6");
+
+			// closing key again does not have any effect
+			hive.Close ();
+		}
+
+		[Test]
+		public void Close_Local_Key ()
+		{
+			RegistryKey key = Registry.CurrentUser.OpenSubKey ("SOFTWARE");
+			key.Close ();
+
+			// closing a key twice does not have any effect
+			key.Close ();
+
+			try {
+				key.CreateSubKey ("a");
+				Assert.Fail ("#1");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.DeleteSubKey ("doesnotexist");
+				Assert.Fail ("#2");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.DeleteSubKeyTree ("doesnotexist");
+				Assert.Fail ("#3");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.DeleteValue ("doesnotexist");
+				Assert.Fail ("#4");
+			} catch (ObjectDisposedException) {
+			}
+
+			// flushing a closed key does not have any effect
+			key.Flush ();
+
+			try {
+				key.GetSubKeyNames ();
+				Assert.Fail ("#5");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.GetValue ("doesnotexist");
+				Assert.Fail ("#6");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.GetValueNames ();
+				Assert.Fail ("#7");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.OpenSubKey ("doesnotexist");
+				Assert.Fail ("#8");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.SetValue ("doesnotexist", "something");
+				Assert.Fail ("#9");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				int x = key.SubKeyCount;
+				Assert.Fail ("#10:" + x);
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.ToString ();
+				Assert.Fail ("#11");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				int x = key.ValueCount;
+				Assert.Fail ("#12:" + x);
+			} catch (ObjectDisposedException) {
+			}
+		}
+
+		[Test]
+		public void Close_Remote_Hive ()
+		{
+			// access to registry of remote machines is not implemented on unix
+			if (RunningOnUnix)
+				return;
+
+			RegistryKey hive = RegistryKey.OpenRemoteBaseKey (
+				RegistryHive.CurrentUser, Environment.MachineName);
+			hive.Close ();
+
+			// closing a remote hive twice does not have any effect
+			hive.Close ();
+
+			try {
+				hive.CreateSubKey ("a");
+				Assert.Fail ("#1");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				hive.DeleteSubKey ("doesnotexist");
+				Assert.Fail ("#2");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				hive.DeleteSubKeyTree ("doesnotexist");
+				Assert.Fail ("#3");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				hive.DeleteValue ("doesnotexist");
+				Assert.Fail ("#4");
+			} catch (ObjectDisposedException) {
+			}
+
+			// flushing a closed hive does not have any effect
+			hive.Flush ();
+
+			try {
+				hive.GetSubKeyNames ();
+				Assert.Fail ("#5");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				hive.GetValue ("doesnotexist");
+				Assert.Fail ("#6");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				hive.GetValueNames ();
+				Assert.Fail ("#7");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				hive.OpenSubKey ("doesnotexist");
+				Assert.Fail ("#8");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				hive.SetValue ("doesnotexist", "something");
+				Assert.Fail ("#9");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				int x = hive.SubKeyCount;
+				Assert.Fail ("#10:" + x);
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				hive.ToString ();
+				Assert.Fail ("#11");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				int x = hive.ValueCount;
+				Assert.Fail ("#12:" + x);
+			} catch (ObjectDisposedException) {
+			}
+		}
+
+		[Test]
+		public void Close_Remote_Key ()
+		{
+			// access to registry of remote machines is not implemented on unix
+			if (RunningOnUnix)
+				return;
+
+			RegistryKey hive = RegistryKey.OpenRemoteBaseKey (
+				RegistryHive.CurrentUser, Environment.MachineName);
+			RegistryKey key = hive.OpenSubKey ("SOFTWARE");
+			key.Close ();
+
+			// closing a remote key twice does not have any effect
+			key.Close ();
+
+			try {
+				key.CreateSubKey ("a");
+				Assert.Fail ("#1");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.DeleteSubKey ("doesnotexist");
+				Assert.Fail ("#2");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.DeleteSubKeyTree ("doesnotexist");
+				Assert.Fail ("#3");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.DeleteValue ("doesnotexist");
+				Assert.Fail ("#4");
+			} catch (ObjectDisposedException) {
+			}
+
+			// flushing a closed key does not have any effect
+			key.Flush ();
+
+			try {
+				key.GetSubKeyNames ();
+				Assert.Fail ("#5");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.GetValue ("doesnotexist");
+				Assert.Fail ("#6");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.GetValueNames ();
+				Assert.Fail ("#7");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.OpenSubKey ("doesnotexist");
+				Assert.Fail ("#8");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.SetValue ("doesnotexist", "something");
+				Assert.Fail ("#9");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				int x = key.SubKeyCount;
+				Assert.Fail ("#10:" + x);
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				key.ToString ();
+				Assert.Fail ("#11");
+			} catch (ObjectDisposedException) {
+			}
+
+			try {
+				int x = key.ValueCount;
+				Assert.Fail ("#12:" + x);
+			} catch (ObjectDisposedException) {
+			}
+
+			hive.Close ();
+		}
+
+		[Test]
 		public void CreateSubKey ()
 		{
 			string subKeyName = Guid.NewGuid ().ToString ();
@@ -178,7 +462,7 @@
 						createdKey = softwareKey.CreateSubKey (subKeyName);
 						Assert.Fail ("#1");
 					} catch (UnauthorizedAccessException ex) {
-						// Cannot write to the registry key.
+						// Cannot write to the registry key
 						Assert.AreEqual (typeof (UnauthorizedAccessException), ex.GetType (), "#2");
 						Assert.IsNotNull (ex.Message, "#3");
 						Assert.IsNull (ex.InnerException, "#4");
@@ -291,7 +575,7 @@
 					Assert.Fail ("#2");
 				} catch (InvalidOperationException ex) {
 					// Registry key has subkeys and recursive removes are not
-					// supported by this method.
+					// supported by this method
 					Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#3");
 					Assert.IsNotNull (ex.Message, "#4");
 					Assert.IsNull (ex.InnerException, "#5");
@@ -1384,6 +1668,50 @@
 		}
 
 		[Test]
+		public void OpenRemoteBaseKey ()
+		{
+			// access to registry of remote machines is not implemented on unix
+			if (RunningOnUnix)
+				return;
+
+			RegistryKey hive = RegistryKey.OpenRemoteBaseKey (
+				RegistryHive.CurrentUser, Environment.MachineName);
+			Assert.IsNotNull (hive, "#1");
+
+			RegistryKey key = hive.OpenSubKey ("SOFTWARE");
+			Assert.IsNotNull (key, "#2");
+			key.Close ();
+
+			hive.Close ();
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentNullException))]
+		public void OpenRemoteBaseKey_MachineName_Null ()
+		{
+			RegistryKey.OpenRemoteBaseKey (RegistryHive.CurrentUser, null);
+		}
+
+		[Test]
+		public void OpenRemoteBaseKey_MachineName_DoesNotExist ()
+		{
+			// access to registry of remote machines is not implemented on unix
+			if (RunningOnUnix)
+				return;
+
+			try {
+				RegistryKey.OpenRemoteBaseKey (RegistryHive.CurrentUser,
+					"DOESNOTEXIST");
+				Assert.Fail ("#1");
+			} catch (IOException ex) {
+				// The network path was not found
+				Assert.AreEqual (typeof (IOException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.Message, "#3");
+				Assert.IsNull (ex.InnerException, "#4");
+			}
+		}
+
+		[Test]
 		public void SetValue_Name_Null ()
 		{
 			string subKeyName = Guid.NewGuid ().ToString ();
@@ -1696,7 +2024,7 @@
 							createdKey.SetValue ("name1", "value1");
 							Assert.Fail ("#1");
 						} catch (UnauthorizedAccessException ex) {
-							// Cannot write to the registry key.
+							// Cannot write to the registry key
 							Assert.AreEqual (typeof (UnauthorizedAccessException), ex.GetType (), "#2");
 							Assert.IsNotNull (ex.Message, "#3");
 							Assert.IsNull (ex.InnerException, "#4");
@@ -2147,5 +2475,16 @@
 				}
 			}
 		}
+
+		private bool RunningOnUnix {
+			get {
+#if NET_2_0
+				return Environment.OSVersion.Platform == PlatformID.Unix;
+#else
+				int p = (int) Environment.OSVersion.Platform;
+				return ((p == 4) || (p == 128));
+#endif
+			}
+		}
 	}
 }
Index: Test/Microsoft.Win32/ChangeLog
===================================================================
--- Test/Microsoft.Win32/ChangeLog	(revision 64755)
+++ Test/Microsoft.Win32/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2006-09-03  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* RegistryKeyTest.cs: Added RunningOnUnix property that is used
+	to skip tests that only need to be run on Windows. Added tests Close
+	tests for local/remote registry hives and keys. Added tests for
+	OpenRemoteBaseKey (Windows only).
+
 2006-08-23  Gert Driesen  <drieseng@users.sourceforge.net>
 
 	* RegistryKeyTest.cs: Modified GetValueNamesTest and GetSubKeyNamesTest
Index: Microsoft.Win32/IRegistryApi.cs
===================================================================
--- Microsoft.Win32/IRegistryApi.cs	(revision 64755)
+++ Microsoft.Win32/IRegistryApi.cs	(working copy)
@@ -38,6 +38,7 @@
 
 	internal interface IRegistryApi {
 		RegistryKey CreateSubKey (RegistryKey rkey, string keyname);
+		RegistryKey OpenRemoteBaseKey (RegistryHive hKey, string machineName);
 		RegistryKey OpenSubKey (RegistryKey rkey, string keyname, bool writtable);
 		void Flush (RegistryKey rkey);
 		void Close (RegistryKey rkey);
Index: Microsoft.Win32/Win32ResultCode.cs
===================================================================
--- Microsoft.Win32/Win32ResultCode.cs	(revision 64755)
+++ Microsoft.Win32/Win32ResultCode.cs	(working copy)
@@ -52,8 +52,8 @@
 		public const int AccessDenied = 5;
 		public const int InvalidParameter = 87;
 		public const int MoreData = 234;
+		public const int NetworkPathNotFound = 53;
 		public const int NoMoreEntries = 259;
 		public const int MarkedForDeletion = 1018;
-
 	}
 }
Index: Microsoft.Win32/RegistryKey.cs
===================================================================
--- Microsoft.Win32/RegistryKey.cs	(revision 64755)
+++ Microsoft.Win32/RegistryKey.cs	(working copy)
@@ -48,20 +48,13 @@
 		// This represents the backend data, used when creating the
 		// RegistryKey object
 		//
-		internal object Data;
-		
+		object handle;
+
+		object hive; // the RegistryHive if the key represents a base key
 		readonly string qname;	// the fully qualified registry key name
-		readonly bool isRoot;	// is the an instance of a root key?
+		readonly bool isRemoteRoot;	// is an instance of a remote root key?
 		readonly bool isWritable;	// is the key openen in writable mode
 
-		internal bool IsRoot {
-			get { return isRoot; }
-		}
-
-		internal bool IsWritable {
-			get { return isWritable; }
-		}
-		
 		static readonly IRegistryApi RegistryApi;
 
 		static RegistryKey ()
@@ -75,22 +68,30 @@
 		/// <summary>
 		///	Construct an instance of a root registry key entry.
 		/// </summary>
-		internal RegistryKey (RegistryHive hiveId, string keyName)
+		internal RegistryKey (RegistryHive hiveId) : this (hiveId, 
+			new IntPtr ((int) hiveId), false)
 		{
-			Data = hiveId;
-			qname = keyName;
-			isRoot = true;
+		}
+
+		/// <summary>
+		///	Construct an instance of a root registry key entry.
+		/// </summary>
+		internal RegistryKey (RegistryHive hiveId, IntPtr keyHandle, bool remoteRoot)
+		{
+			hive = hiveId;
+			handle = keyHandle;
+			qname = GetHiveName (hiveId);
+			isRemoteRoot = remoteRoot;
 			isWritable = true; // always consider root writable
 		}
-		
+
 		/// <summary>
 		///	Construct an instance of a registry key entry.
 		/// </summary>
 		internal RegistryKey (object data, string keyName, bool writable)
 		{
-			Data = data;
+			handle = data;
 			qname = keyName;
-			isRoot = false;
 			isWritable = writable;
 		}
 
@@ -142,11 +143,13 @@
 		{
 			Flush ();
 
-			if (isRoot)
+			// a handle to a remote hive must be closed, while one to a local
+			// hive should not be closed
+			if (!isRemoteRoot && IsRoot)
 				return;
 			
 			RegistryApi.Close (this);
-			Data = null;
+			handle = null;
 		}
 		
 		
@@ -382,10 +385,12 @@
 		}
 		
 		
-		[MonoTODO]
+		[MonoTODO ("Not implemented on unix")]
 		public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey,string machineName)
 		{
-			throw new NotImplementedException ();
+			if (machineName == null)
+				throw new ArgumentNullException ("machineName");
+			return RegistryApi.OpenRemoteBaseKey (hKey, machineName);
 		}
 		
 		
@@ -396,18 +401,41 @@
 		/// </summary>
 		public override string ToString()
 		{
+			AssertKeyStillValid ();
+
 			return RegistryApi.ToString (this);
 		}
 
 		#endregion // PublicAPI
 
-		
+		internal bool IsRoot {
+			get { return hive != null; }
+		}
+
+		private bool IsWritable {
+			get { return isWritable; }
+		}
+
+		internal RegistryHive Hive {
+			get {
+				if (!IsRoot)
+					throw new NotSupportedException ();
+				return (RegistryHive) hive;
+			}
+		}
+
+		// returns the key handle for the win32 implementation and the
+		// KeyHandler for the unix implementation
+		internal object Handle {
+			get { return handle; }
+		}
+
 		/// <summary>
 		/// validate that the registry key handle is still usable.
 		/// </summary>
 		private void AssertKeyStillValid ()
 		{
-			if (Data == null)
+			if (handle == null)
 				throw new ObjectDisposedException ("Microsoft.Win32.RegistryKey");
 		}
 
@@ -430,7 +458,7 @@
 		/// </summary>
 		private void DeleteChildKeysAndValues ()
 		{
-			if (isRoot)
+			if (IsRoot)
 				return;
 			
 			string[] subKeys = GetSubKeyNames ();
@@ -466,6 +494,29 @@
 				+ " registry key that has been marked for deletion.");
 		}
 
+		static string GetHiveName (RegistryHive hive)
+		{
+			switch (hive) {
+			case RegistryHive.ClassesRoot:
+				return "HKEY_CLASSES_ROOT";
+			case RegistryHive.CurrentConfig:
+				return "HKEY_CURRENT_CONFIG";
+			case RegistryHive.CurrentUser:
+				return "HKEY_CURRENT_USER";
+			case RegistryHive.DynData:
+				return "HKEY_DYN_DATA";
+			case RegistryHive.LocalMachine:
+				return "HKEY_LOCAL_MACHINE";
+			case RegistryHive.PerformanceData:
+				return "HKEY_PERFORMANCE_DATA";
+			case RegistryHive.Users:
+				return "HKEY_USERS";
+			}
+
+			throw new NotImplementedException (string.Format (
+				"Registry hive '{0}' is not implemented.", hive.ToString ()));
+		}
+
 	}
 }
 
Index: Microsoft.Win32/ChangeLog
===================================================================
--- Microsoft.Win32/ChangeLog	(revision 64755)
+++ Microsoft.Win32/ChangeLog	(working copy)
@@ -1,3 +1,27 @@
+2006-09-03  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* IRegistryApi.cs: Added OpenRemoteBaseKey method.
+	* Win32ResultCode.cs: Added code for win32 error 53.
+	* RegistryKey.cs: Implemented support for OpenRemoteBaseKEy on
+	Windows. To achieve this, the handle of the remote hive must be
+	stored separately from the RegistryHive value. Removed isRoot field, as
+	we now determine whether we're a root key (hive) by checking if hive
+	is not null. Added internal ctor for registry hives that takes a 
+	RegistryHive, a key handle and a bool to indicate whether its a remote
+	hive. Renamed Data field to handle and added internal property to 
+	access it. Throw ObjectDisposedException in ToString if key is
+	closed/disposed. Added Hive property, which is used in UnixRegistryApi.
+	Added GetHiveName method which translates a RegistryHive value to its
+	(key) name.
+	* Win32RegistryApi.cs: Added pinvoke for RegConnectRegistry. GetHandle
+	no longer needs to know whether the key refers to a hive (base key) 
+	or not. Implemented OpenRemoteBaseKey.
+	* UnixRegistryApi.cs: Added OpenRemoteBaseKey implementation which
+	always throws NotImplementedException.
+	* Registry.cs: The key name of the base key no longer needs to be 
+	passed to the ctor, as it's looked up in the ctor itself. This avoids
+	having a different logical for local or remote base keys.
+
 2006-08-23  Gert Driesen  <drieseng@users.sourceforge.net>
 
 	* Win32RegistryApi.cs: Use a StringBuilder instead of byte [] for
Index: Microsoft.Win32/Win32RegistryApi.cs
===================================================================
--- Microsoft.Win32/Win32RegistryApi.cs	(revision 64755)
+++ Microsoft.Win32/Win32RegistryApi.cs	(working copy)
@@ -35,6 +35,7 @@
 
 using System;
 using System.Collections;
+using System.IO;
 using System.Runtime.InteropServices;
 using System.Security;
 using System.Text;
@@ -63,6 +64,10 @@
 		[DllImport ("advapi32.dll", CharSet=CharSet.Unicode, EntryPoint="RegCloseKey")]
 		static extern int RegCloseKey (IntPtr keyHandle);
 
+		[DllImport ("advapi32.dll", CharSet=CharSet.Unicode)]
+		static extern int RegConnectRegistry (string machineName, IntPtr hKey,
+				out IntPtr keyHandle);
+
 		[DllImport ("advapi32.dll", CharSet=CharSet.Unicode, EntryPoint="RegFlushKey")]
 		private static extern int RegFlushKey (IntPtr keyHandle);
 
@@ -124,13 +129,12 @@
 		// Returns our handle from the RegistryKey
 		static IntPtr GetHandle (RegistryKey key)
 		{
-			return key.IsRoot ? new IntPtr ((int) key.Data)
-				: (IntPtr) key.Data;
+			return (IntPtr) key.Handle;
 		}
 
 		static bool IsHandleValid (RegistryKey key)
 		{
-			return key.Data != null;
+			return key.Handle != null;
 		}
 
 		/// <summary>
@@ -358,7 +362,19 @@
 			}
 			return index;
 		}
-		
+
+		public RegistryKey OpenRemoteBaseKey (RegistryHive hKey, string machineName)
+		{
+			IntPtr handle = new IntPtr ((int) hKey);
+
+			IntPtr keyHandle;
+			int result = RegConnectRegistry (machineName, handle, out keyHandle);
+			if (result != Win32ResultCode.Success)
+				GenerateException (result);
+
+			return new RegistryKey (hKey, keyHandle, true);
+		}
+
 		public RegistryKey OpenSubKey (RegistryKey rkey, string keyName, bool writable)
 		{
 			int access = OpenRegKeyRead;
@@ -508,10 +524,10 @@
 				case Win32ResultCode.FileNotFound:
 				case Win32ResultCode.InvalidParameter:
 					throw new ArgumentException ();
-				
 				case Win32ResultCode.AccessDenied:
 					throw new SecurityException ();
-
+				case Win32ResultCode.NetworkPathNotFound:
+					throw new IOException ("The network path was not found.");
 				default:
 					// unidentified system exception
 					throw new SystemException ();
Index: Microsoft.Win32/UnixRegistryApi.cs
===================================================================
--- Microsoft.Win32/UnixRegistryApi.cs	(revision 64755)
+++ Microsoft.Win32/UnixRegistryApi.cs	(working copy)
@@ -240,7 +240,7 @@
 				if (!rkey.IsRoot || !createNonExisting)
 					return null;
 
-				RegistryHive x = (RegistryHive) rkey.Data;
+				RegistryHive x = (RegistryHive) rkey.Hive;
 				switch (x){
 				case RegistryHive.CurrentUser:
 					string userDir = Path.Combine (UserStore, x.ToString ());
@@ -570,6 +570,11 @@
 			return CreateSubKey (rkey, keyname, true);
 		}
 
+		public RegistryKey OpenRemoteBaseKey (RegistryHive hKey, string machineName)
+		{
+			throw new NotImplementedException ();
+		}
+
 		public RegistryKey OpenSubKey (RegistryKey rkey, string keyname, bool writable)
 		{
 			KeyHandler self = KeyHandler.Lookup (rkey, true);
Index: Microsoft.Win32/Registry.cs
===================================================================
--- Microsoft.Win32/Registry.cs	(revision 64755)
+++ Microsoft.Win32/Registry.cs	(working copy)
@@ -45,19 +45,19 @@
 		private Registry () { }
 #endif
 		public static readonly RegistryKey ClassesRoot = new RegistryKey (
-				RegistryHive.ClassesRoot, "HKEY_CLASSES_ROOT");
+				RegistryHive.ClassesRoot);
 		public static readonly RegistryKey CurrentConfig = new RegistryKey (
-				RegistryHive.CurrentConfig, "HKEY_CURRENT_CONFIG");
+				RegistryHive.CurrentConfig);
 		public static readonly RegistryKey CurrentUser = new RegistryKey (
-				RegistryHive.CurrentUser, "HKEY_CURRENT_USER");
+				RegistryHive.CurrentUser);
 		public static readonly RegistryKey DynData = new RegistryKey (
-				RegistryHive.DynData, "HKEY_DYN_DATA");
+				RegistryHive.DynData);
 		public static readonly RegistryKey LocalMachine = new RegistryKey (
-				RegistryHive.LocalMachine, "HKEY_LOCAL_MACHINE");
+				RegistryHive.LocalMachine);
 		public static readonly RegistryKey PerformanceData = new RegistryKey (
-				RegistryHive.PerformanceData, "HKEY_PERFORMANCE_DATA");
+				RegistryHive.PerformanceData);
 		public static readonly RegistryKey Users = new RegistryKey (
-				RegistryHive.Users, "HKEY_USERS");
+				RegistryHive.Users);
 
 #if NET_2_0
 		static RegistryKey ToKey (string keyName, bool setting)
