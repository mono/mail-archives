//#define EXPLICIT

using System;
using System.Threading;
using System.Runtime.InteropServices;
using System.Diagnostics;


using Tao.FFmpeg;


namespace PP
{
	public class FFmpegDecoder
	{

#if EXPLICIT
		[StructLayout(LayoutKind.Explicit)]
		public struct AVRational
		{
			[MarshalAs(UnmanagedType.I4)]
			[FieldOffset(0)]
			public int num;
			[MarshalAs(UnmanagedType.I4)]
			[FieldOffset(4)]
			public int den;
		};
#else
		[StructLayout(LayoutKind.Sequential)]
		public struct AVRational
		{
			[MarshalAs(UnmanagedType.I4)]
			public int num;
			[MarshalAs(UnmanagedType.I4)]
			public int den;
		};
#endif

		[StructLayout(LayoutKind.Sequential)]
		struct ByteIOContext
		{
			IntPtr buffer;
			int buffer_size;
			IntPtr buf_ptr;
			IntPtr buf_end;
			IntPtr opaque;
			IntPtr read_packet;//int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);
			IntPtr write_packet;//int (*write_packet)(void *opaque, uint8_t *buf, int buf_size);
			IntPtr seek;//offset_t (*seek)(void *opaque, offset_t offset, int whence);
			Int64 pos; /**< position in the file of the current buffer */
			int must_flush; /**< true if the next seek should flush */
			int eof_reached; /**< true if eof reached */
			int write_flag;  /**< true if open for writing */
			int is_streamed;
			int max_packet_size;
			ulong checksum;
			IntPtr checksum_ptr;
			IntPtr update_checksum;// unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);
			int error;         ///< contains the error code or 0 if no error happened
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct AVCodecContext
		{
			public IntPtr av_class; // AVClass *av_class;

			[MarshalAs(UnmanagedType.I4)]
			public int bit_rate;

			[MarshalAs(UnmanagedType.I4)]
			public int bit_rate_tolerance;

			[MarshalAs(UnmanagedType.I4)]
			public int flags;
		
			[MarshalAs(UnmanagedType.I4)]
			public int sub_id;
		
			[MarshalAs(UnmanagedType.I4)]
			public int me_method;
		
			public IntPtr extradata; // void* extradata;
		
			[MarshalAs(UnmanagedType.I4)]
			public int extradata_size;
		
			public AVRational time_base;
		
			[MarshalAs(UnmanagedType.I4)]
			public int width;
		
			[MarshalAs(UnmanagedType.I4)]
			public int height;
			
			/* ignore the rest...*/
		};

        [StructLayout(LayoutKind.Sequential)]
		struct  AVFormatContext
		{
			IntPtr av_class; /**< set by av_alloc_format_context */
			/* can only be iformat or oformat, not both at the same time */
			IntPtr iformat;
			IntPtr oformat;
			IntPtr priv_data;
			ByteIOContext pb;
			public uint nb_streams;
			
			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)]
			public IntPtr[] streams;
			
			/* ignore the rest...*/
		}


		private IntPtr m_pctxFormat;
		private AVFormatContext m_ctxFormat;

	
		public FFmpegDecoder()
		{
			FFmpeg.avcodec_init();
			
			FFmpeg.av_register_all();
		}
		
		// return true if sucessful
		public bool Open(string fileName)
		{
			// Open video file
			if(FFmpeg.av_open_input_file(out m_pctxFormat, fileName, IntPtr.Zero, 0, IntPtr.Zero) < 0)
				return false; // Couldn't open file

			// Retrieve stream information	
			if(FFmpeg.av_find_stream_info(m_pctxFormat) < 0)
				return false; // Couldn't find stream information

			// Dump information about file onto standard error
			FFmpeg.dump_format(m_pctxFormat, 0, fileName, 0);
			
			m_ctxFormat = (AVFormatContext)
				Marshal.PtrToStructure(m_pctxFormat, typeof(AVFormatContext));

			Console.WriteLine("Streams:{0}", m_ctxFormat.nb_streams);
			if (m_ctxFormat.nb_streams < 1)
					return false;
			FFmpeg.AVStream stream = (FFmpeg.AVStream)
				Marshal.PtrToStructure(m_ctxFormat.streams[0], typeof(FFmpeg.AVStream));

			AVCodecContext codec = (AVCodecContext)
					Marshal.PtrToStructure(stream.codec, typeof(AVCodecContext));
			Console.WriteLine("width {0}", codec.width);
			
			return true;
		}
		
	}
	
	public class Program
	{
		[STAThread]
		public static void Main()
		{
			FFmpegDecoder decoder = new FFmpegDecoder();
			decoder.Open("cold.avi");
		}
	}
}