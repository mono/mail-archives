Index: ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/ChangeLog,v
retrieving revision 1.88
diff -u -r1.88 ChangeLog
--- ChangeLog	26 Nov 2003 18:37:32 -0000	1.88
+++ ChangeLog	30 Nov 2003 14:00:41 -0000
@@ -1,3 +1,36 @@
+2003-11-30 Eran Domb <erand@mainsoft.com>
+	* DataColumnCollection.cs (this[string name]) : Use IndexOf to find the column.
+	(Add) : Find if the new column name is the same as the one found in IndexOf.
+	(IndexOf) : New method.
+	(Contains) : Use new IndexOf.
+	(IndexOf) : Use new IndexOf.
+	
+	* DataRelationCollection.cs (DataRelationCollection.AddCore) : Add The Relation to the collection.
+	(DataSetRelationCollection.AddCore) : First add the UniqueConstraint.
+	
+	* DataRow.cs (this[int columnIndex, DataRowVersion version]) : Change exceptions.
+	(Delete) : Detach row if the RowState was Added.
+	(GetChildRows) : Get the array form the ChildTable.
+	(GetParentRows) : Get the array from the ParenTable.
+	
+	* DataRowCollection.cs (Remove) : Check if row state is Detached to avoid exception.
+	
+	* DataSet.cs (IXmlSerializable.ReadXml) : Do not call MoveToContent and ReadEndElement - the XmlSerializationReader does it.
+	
+	* DataTable.cs (PrimaryKey) : Fix bugs.
+	(Compute) : First call Select. Then create ExpressionAggregate to aggregate the Select result.
+	
+	* DataTableCollection.cs (Add) : Fix a bug.
+	
+	* ExpressionElement.cs (ValidateExpression) : Turning ValidateExpression to static.
+	(Result) : Added new interface to AggregateExpression that get DataRow[] as a param.
+	
+	* ForeignKeyConstraint.cs (_validateColumns) : Throw correct exception.
+	
+	* MergeManager.cs (AdjustSchema) : Fix a bug.
+	
+	
+
 2003-11-26  Miguel de Icaza  <miguel@ximian.com>
 
 	* DataSet.cs: Add a few more missing methods, code style updated
Index: DataColumnCollection.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataColumnCollection.cs,v
retrieving revision 1.18
diff -u -r1.18 DataColumnCollection.cs
--- DataColumnCollection.cs	4 Apr 2003 19:31:24 -0000	1.18
+++ DataColumnCollection.cs	30 Nov 2003 14:00:41 -0000
@@ -48,14 +48,10 @@
 		{
 			get
 			{
-				foreach (DataColumn column in base.List)
-				{					
-					if (String.Compare (column.ColumnName, name, true) == 0)
-					{
-						return column;
-					}
-				}
-				return null;                
+				int tmp = IndexOf(name, true);
+				if (tmp == -1)
+					return null;
+				return this[tmp]; 
 			}
 		}
 
@@ -125,12 +121,14 @@
 			{
 				column.ColumnName = GetNextDefaultColumnName ();
 			}
-			else if (Contains(column.ColumnName))
+			int tmp = IndexOf(column.ColumnName);
+			// if we found a column with same name we have to check
+			// that it is the same case.
+			// indexof can return a table with different case letters.
+			if (tmp != -1)
 			{
-				if (object.ReferenceEquals(this [column.ColumnName], column))
-					throw new ArgumentException ("Column '" + column.ColumnName + "' already belongs to this DataTable.");
-				else if (CaseSensitiveContains (column.ColumnName))
-					throw new DuplicateNameException("A column named '" + column.ColumnName + "' already belongs to this DataTable.");
+				if(column.ColumnName == this[tmp].ColumnName)
+					throw new DuplicateNameException("A DataColumn named '" + column.ColumnName + "' already belongs to this DataTable.");
 			}
 
 			if (column.Table != null)
@@ -361,7 +359,7 @@
 		/// <returns>true if a column exists with this name; otherwise, false.</returns>
 		public bool Contains(string name)
 		{
-			return (IndexOf(name) != -1);
+			return (IndexOf(name, false) != -1);
 		}
 
 		/// <summary>
@@ -381,17 +379,7 @@
 		/// <returns>The zero-based index of the column with the specified name, or -1 if the column doesn't exist in the collection.</returns>
 		public int IndexOf(string columnName)
 		{
-			
-			DataColumn column = this[columnName];
-			
-			if (column != null)
-			{
-				return IndexOf(column);
-			}
-			else
-			{
-				return -1;
-			}
+			return IndexOf(columnName, false);
 		}
 
 		/// <summary>
@@ -486,6 +474,27 @@
 				return string.Compare (column.ColumnName, columnName, false) == 0; 
 
 			return false;
+		}
+
+		private int IndexOf (string name, bool error)
+		{
+			int count = 0, match = -1;
+			for (int i = 0; i < list.Count; i++)
+			{
+				String name2 = ((DataColumn) list[i]).ColumnName;
+				if (String.Compare (name, name2, true) == 0)
+				{
+					if (String.Compare (name, name2, false) == 0)
+						return i;
+					match = i;
+					count++;
+				}
+			}
+			if (count == 1)
+				return match;
+			if (count > 1 && error)
+				throw new ArgumentException ("There is no match for the name in the same case and there are multiple matches in different case.");
+			return -1;
 		}
 		
 
Index: DataRelationCollection.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataRelationCollection.cs,v
retrieving revision 1.13
diff -u -r1.13 DataRelationCollection.cs
--- DataRelationCollection.cs	3 Nov 2003 12:35:50 -0000	1.13
+++ DataRelationCollection.cs	30 Nov 2003 14:00:41 -0000
@@ -72,57 +72,61 @@
 			/// </summary>
 			/// <param name="relation">The relation to check.</param>
 			protected override void AddCore (DataRelation relation)
-			{
-				base.AddCore (relation);
-				if (relation.ChildTable.DataSet != this.dataSet || relation.ParentTable.DataSet != this.dataSet)
-					throw new DataException ();
-				//List.Add (relation);
-				relation.SetDataSet (dataSet);
-				relation.ParentTable.ChildRelations.Add (relation);
-				relation.ChildTable.ParentRelations.Add (relation);
-				ForeignKeyConstraint foreignKeyConstraint = null;
-				if (relation.createConstraints) 
-				{
-					foreignKeyConstraint = new ForeignKeyConstraint (relation.RelationName, relation.ParentColumns, relation.ChildColumns);
-					relation.ChildTable.Constraints.Add (foreignKeyConstraint);
+			{
+				 base.AddCore (relation);
+				 if (relation.ChildTable.DataSet != this.dataSet || relation.ParentTable.DataSet != this.dataSet)
+					 throw new DataException ();
+				 relation.SetDataSet (dataSet);
+				 relation.ParentTable.ChildRelations.Add (relation);
+				 relation.ChildTable.ParentRelations.Add (relation);
+				 ForeignKeyConstraint foreignKeyConstraint = null;
+			
+				 if (relation.createConstraints) 
+				 {
+					 
+					 UniqueConstraint uniqueConstraint = null;
+					 ConstraintCollection parentConstrains = relation.ParentTable.Constraints;
+					 // find if the unique constraint already exists in the parent table.
+					 foreach (Constraint o in parentConstrains) 
+					 {
+						 if (o is UniqueConstraint) 
+						 {
+							 UniqueConstraint uc = (UniqueConstraint) o;
+							 if (uc.Columns.Length == relation.ParentColumns.Length) 
+							 {
+								 bool allColumnsEqual = true;
+								 for (int columnCnt = 0; columnCnt < uc.Columns.Length; ++columnCnt) 
+								 {
+									 if (uc.Columns[columnCnt] != relation.ParentColumns[columnCnt]) 
+									 {
+										 allColumnsEqual = false;
+										 break;
+									 }
+								 }
+								 if (allColumnsEqual) 
+								 {
+									 uniqueConstraint = uc;
+									 break;
+								 }
+							 }
+						 }
+					 }
+					 // if we did not find the unique constraint in the parent table.
+					 // we generate new uniqueconastraint and add it to the parent table.
+					 if (uniqueConstraint == null)
+					 {
+						 uniqueConstraint = new UniqueConstraint(relation.ParentColumns, false);
+						 relation.ParentTable.Constraints.Add(uniqueConstraint);
+					 }
+					
+					 foreignKeyConstraint = new ForeignKeyConstraint (relation.RelationName, relation.ParentColumns, relation.ChildColumns);
+					 relation.ChildTable.Constraints.Add (foreignKeyConstraint);
+
+					 relation.SetParentKeyConstraint (uniqueConstraint);
+					 relation.SetChildKeyConstraint (foreignKeyConstraint);
+				 }
 				
-					UniqueConstraint uniqueConstraint = null;
-					ConstraintCollection parentConstrains = relation.ParentTable.Constraints;
-					// find if the unique constraint already exists in the parent table.
-					foreach (Constraint o in parentConstrains) 
-					{
-						if (o is UniqueConstraint) 
-						{
-							UniqueConstraint uc = (UniqueConstraint) o;
-							if (uc.Columns.Length == relation.ParentColumns.Length) 
-							{
-								bool allColumnsEqual = true;
-								for (int columnCnt = 0; columnCnt < uc.Columns.Length; ++columnCnt) 
-								{
-									if (uc.Columns[columnCnt] != relation.ParentColumns[columnCnt]) 
-									{
-										allColumnsEqual = false;
-										break;
-									}
-								}
-								if (allColumnsEqual) 
-								{
-									uniqueConstraint = uc;
-									break;
-								}
-							}
-						}
-					}
-					// if we did not find the unique constraint in the parent table.
-					// we generate new uniqueconastraint and add it to the parent table.
-					if (uniqueConstraint == null)
-					{
-						uniqueConstraint = new UniqueConstraint(relation.ParentColumns, false);
-						relation.ParentTable.Constraints.Add(uniqueConstraint);
-					}
-					relation.SetParentKeyConstraint (uniqueConstraint);
-					relation.SetChildKeyConstraint (foreignKeyConstraint);
-				}
+			
 			}
 
 			public override void AddRange (DataRelation[] relations)
@@ -260,7 +264,7 @@
 			if(relation.RelationName == string.Empty)
 				relation.RelationName = GenerateRelationName();
 			CollectionChangeEventArgs e = new CollectionChangeEventArgs(CollectionChangeAction.Add, this);
-			List.Add(relation);
+			//List.Add(relation);
 			OnCollectionChanged(e);
 		}
 
@@ -404,6 +408,7 @@
 				//TODO: Issue a good exception message.
 				throw new DuplicateNameException("A Relation named " + relation.RelationName + " already belongs to this DataSet.");
 			}
+			List.Add(relation);
 		}
 
 		/// <summary>
@@ -415,11 +420,11 @@
 			foreach (DataRelation relation in relations) Add(relation);
 		}
 
-		[MonoTODO]
 		public virtual bool CanRemove(DataRelation relation)
 		{
-			//TODO: Implement.
-			return false;
+			if (relation == null || !GetDataSet().Equals(relation.DataSet))
+				return false;
+			return true;
 		}
 
 		public virtual void Clear()
Index: DataRow.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataRow.cs,v
retrieving revision 1.48
diff -u -r1.48 DataRow.cs
--- DataRow.cs	21 Nov 2003 15:57:35 -0000	1.48
+++ DataRow.cs	30 Nov 2003 14:00:42 -0000
@@ -190,22 +190,30 @@
 				//if (rowState == DataRowState.Detached && version == DataRowVersion.Default)
 				//	throw new RowNotInTableException("This row has been removed from a table and does not have any data.  BeginEdit() will allow creation of new data in this row.");
 				// Non-existent version
-				if (!HasVersion (version))
-					throw new VersionNotFoundException (Locale.GetText ("There is no " + version.ToString () + " data to access."));
-				switch (version) {
-				case DataRowVersion.Default:
-					if (editing || rowState == DataRowState.Detached)
-						return proposed[columnIndex];
-					return current[columnIndex];
-				case DataRowVersion.Proposed:
-					return proposed[columnIndex];
-				case DataRowVersion.Current:
-					return current[columnIndex];
-				case DataRowVersion.Original:
-					return original[columnIndex];
-				default:
-					throw new ArgumentException ();
+				//if (!HasVersion (version))
+				//	throw new VersionNotFoundException (Locale.GetText ("There is no " + version.ToString () + " data to access."));
+				if (HasVersion(version))
+				{
+					switch (version) 
+					{
+						case DataRowVersion.Default:
+							if (editing || rowState == DataRowState.Detached)
+								return proposed[columnIndex];
+							return current[columnIndex];
+						case DataRowVersion.Proposed:
+							return proposed[columnIndex];
+						case DataRowVersion.Current:
+							return current[columnIndex];
+						case DataRowVersion.Original:
+							return original[columnIndex];
+						default:
+							throw new ArgumentException ();
+					}
 				}
+				if (rowState == DataRowState.Detached && proposed == null)
+					throw new RowNotInTableException("This row has been removed from a table and does not have any data.  BeginEdit() will allow creation of new data in this row.");
+				
+				throw new VersionNotFoundException (Locale.GetText ("There is no " + version.ToString () + " data to access."));
 			}
 		}
 
@@ -504,6 +512,8 @@
 			switch (rowState) {
 			case DataRowState.Added:
 				Table.Rows.RemoveInternal (this);
+				// if row was in Added state we move it to Detached.
+				DetachRow();
 				break;
 			case DataRowState.Deleted:
 				break;
@@ -742,7 +752,9 @@
 					if (allColumnsMatch) rows.Add(row);
 				}
 			}
-			return rows.ToArray(typeof(DataRow)) as DataRow[];
+			DataRow[] result = relation.ChildTable.NewRowArray(rows.Count);
+			rows.CopyTo(result, 0);
+			return result;
 		}
 
 		/// <summary>
@@ -895,7 +907,10 @@
 					if (allColumnsMatch) rows.Add(row);
 				}
 			}
-			return rows.ToArray(typeof(DataRow)) as DataRow[];
+
+			DataRow[] result = relation.ParentTable.NewRowArray(rows.Count);
+			rows.CopyTo(result, 0);
+			return result;
 		}
 
 		/// <summary>
Index: DataRowCollection.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataRowCollection.cs,v
retrieving revision 1.27
diff -u -r1.27 DataRowCollection.cs
--- DataRowCollection.cs	9 Nov 2003 18:51:03 -0000	1.27
+++ DataRowCollection.cs	30 Nov 2003 14:00:42 -0000
@@ -266,7 +266,10 @@
 			if (index < 0)
 				throw new IndexOutOfRangeException ("The given datarow is not in the current DataRowCollection.");
 			row.Delete();
-			row.AcceptChanges();
+			// if the row was in added state it will be in Detached state after the
+			// delete operation, so we have to check it.
+			if (row.RowState != DataRowState.Detached)
+				row.AcceptChanges();
 		}
 
 		/// <summary>
Index: DataSet.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataSet.cs,v
retrieving revision 1.52
diff -u -r1.52 DataSet.cs
--- DataSet.cs	26 Nov 2003 18:37:32 -0000	1.52
+++ DataSet.cs	30 Nov 2003 14:00:42 -0000
@@ -889,9 +889,10 @@
 
 			reader.MoveToContent ();
 			ReadXml (reader, XmlReadMode.IgnoreSchema);
-
-			reader.MoveToContent ();
-			reader.ReadEndElement ();	// </DataSet>
+			
+			// the XmlSerializationReader does this lines!!!
+			//reader.MoveToContent ();
+			//reader.ReadEndElement ();	// </DataSet>
 		}
 		
 		void IXmlSerializable.WriteXml (XmlWriter writer)
Index: DataTable.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataTable.cs,v
retrieving revision 1.43
diff -u -r1.43 DataTable.cs
--- DataTable.cs	26 Nov 2003 06:16:56 -0000	1.43
+++ DataTable.cs	30 Nov 2003 14:00:43 -0000
@@ -352,43 +352,47 @@
 				return uc.Columns;
 			}
 			set {
-
-				//YUK: msft removes a previous unique constraint if it is flagged as a pk  
-				//when a new pk is set 
+				UniqueConstraint oldPKConstraint = UniqueConstraint.GetPrimaryKeyConstraint( Constraints);
 				
-				//clear Primary Key if value == null
-				if (null == value) {
-					
-					RemoveUniqueConstraints ();
+				// first check if value is the same as current PK.
+				if (oldPKConstraint != null && DataColumn.AreColumnSetsTheSame(value, oldPKConstraint.Columns))
 					return;
-				}
 
-				//Does constraint exist for these columns
-				UniqueConstraint uc = UniqueConstraint.GetUniqueConstraintForColumnSet(
-					this.Constraints, (DataColumn[]) value);
-
-				//if constraint doesn't exist for columns
-				//create new unique primary key constraint
-				if (null == uc) {
-
-					RemoveUniqueConstraints ();						
-					
-					foreach (DataColumn Col in (DataColumn[]) value) {
+				// remove PK Constraint
+				if(oldPKConstraint != null)
+				{
+					Constraints.Remove(oldPKConstraint);
+				}
+				
+				if (value != null)
+				{
+					//Does constraint exist for these columns
+					UniqueConstraint uc = UniqueConstraint.GetUniqueConstraintForColumnSet(
+						this.Constraints, (DataColumn[]) value);
+				
+					//if constraint doesn't exist for columns
+					//create new unique primary key constraint
+					if (null == uc) 
+					{
+						foreach (DataColumn Col in (DataColumn[]) value) 
+						{
 
-						if (Col.Table == null)
-							break;
+							if (Col.Table == null)
+								break;
 
-						if (Columns.IndexOf (Col) < 0)
-							throw new ArgumentException ("PrimaryKey columns do not belong to this table.");
-					}
+							if (Columns.IndexOf (Col) < 0)
+								throw new ArgumentException ("PrimaryKey columns do not belong to this table.");
+						}
 
 
-					uc = new UniqueConstraint( (DataColumn[]) value, true);
+						uc = new UniqueConstraint( (DataColumn[]) value, true);
 					
-					Constraints.Add (uc);
-				}
-				else { //set existing constraint as the new primary key
-					UniqueConstraint.SetAsPrimaryKey(this.Constraints, uc);
+						Constraints.Add (uc);
+					}
+					else 
+					{ //set existing constraint as the new primary key
+						UniqueConstraint.SetAsPrimaryKey(this.Constraints, uc);
+					}
 				}
 				
 			}
@@ -555,21 +559,11 @@
 
 			object obj = null;
 
-			// filter rows
-			ExpressionElement Expression = new ExpressionMainElement (filter);
+			DataRow[] rows = Select(filter);
 			
-			ArrayList List = new ArrayList ();
-			foreach (DataRow Row in Rows) {
-				
-				if (Expression.Test (Row))
-					List.Add (Row);
-			}
+			ExpressionAggregate Expression = new ExpressionAggregate (expression);
+			obj = Expression.Result(rows);
 			
-			DataRow[] rows = (DataRow [])List.ToArray (typeof (DataRow));
-
-			// TODO: with the filtered rows, execute the aggregate function
-			//       mentioned in expression
-
 			return obj;
 		}
 
Index: DataTableCollection.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataTableCollection.cs,v
retrieving revision 1.17
diff -u -r1.17 DataTableCollection.cs
--- DataTableCollection.cs	26 Nov 2003 06:16:56 -0000	1.17
+++ DataTableCollection.cs	30 Nov 2003 14:00:43 -0000
@@ -88,9 +88,16 @@
 				NameTable (table);
 		    
 			// check if the collection has a table with the same name.
-			if(Contains(table.TableName))
-				throw new DuplicateNameException("A DataTable named '" + table.TableName + "' already belongs to this DataSet.");
-				
+			int tmp = IndexOf(table.TableName);
+			// if we found a table with same name we have to check
+			// that it is the same case.
+			// indexof can return a table with different case letters.
+			if (tmp != -1)
+			{
+				if(table.TableName == this[tmp].TableName)
+					throw new DuplicateNameException("A DataTable named '" + table.TableName + "' already belongs to this DataSet.");
+			}
+	
 			list.Add (table);
 			table.dataSet = dataSet;
 			OnCollectionChanged (new CollectionChangeEventArgs (CollectionChangeAction.Add, table));
Index: ExpressionElement.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/ExpressionElement.cs,v
retrieving revision 1.8
diff -u -r1.8 ExpressionElement.cs
--- ExpressionElement.cs	3 Nov 2003 12:35:50 -0000	1.8
+++ ExpressionElement.cs	30 Nov 2003 14:00:44 -0000
@@ -17,31 +17,27 @@
 
 using System.Collections;
 
-namespace System.Data
+namespace System.Data 
 {
-        /// <summary>
-        /// The main element which includes whole expression
-        /// </summary>
-        internal class ExpressionMainElement : ExpressionElement
+	/// <summary>
+	/// The main element which includes whole expression
+	/// </summary>
+	internal class ExpressionMainElement : ExpressionElement 
 	{
 		
-		#region Fields
-
-		enum OP {OPERATOR, OPERAND};
-		enum OPERATOR_TYPE {SYMBOLIC, LITERAL, UNDEFINED};
-		enum OPERAND_TYPE {NUMERIC, STRING, UNDEFINED};
-
-		#endregion // Fields
+		
 
-		public ExpressionMainElement (string s)
+		public ExpressionMainElement (string s) 
 		{
-			s = ValidateExpression (s);
+			s = ExpressionElement.ValidateExpression (s);
 			ParseExpression (s);
 		}
 		
-		public override bool Test (DataRow Row) {
+		public override bool Test (DataRow Row) 
+		{
 
-			foreach (ExpressionElement El in Elements) {
+			foreach (ExpressionElement El in Elements) 
+			{
 				if (!El.Test (Row))
 					return false;
 			}
@@ -49,288 +45,172 @@
 			return true;
 		}
 
-		/// <summary>
-		///  Checks syntax of expression and throws exception if needed.
-		///  Also removes whitespaces between operator elements for example: age < = 64 --> age <= 64
-		/// </summary>
-		private string ValidateExpression (string s)
-		{			
-			//
-			// TODO: find out nice way to do this. This is NOT nice way :-P
-			//
-			string temp = "";
-			OP op = OP.OPERAND;
-			OPERATOR_TYPE operatorType = OPERATOR_TYPE.UNDEFINED;
-
-			string strOperator = "";
-			string strOperand = "";
-			int quotes = 0;
-			int parentheses = 0;
-			string newExp = "";
-			bool isDigit = false;
-			bool litOperator = false;
-			s = s.Trim();
-			
-			for (int i = 0; i < s.Length; i++) {
-
-				char c = s [i];
-				
-				if (c == '\'')
-					quotes++;
-
-				if ((c == '\n' || c == '\t') && quotes == 0)
-					c = ' ';
-
-				if (op == OP.OPERAND && c == '(')
-					parentheses++;
-				else if (op == OP.OPERAND && c == ')')
-					parentheses--;
-
-				if (c == ' ' && op ==  OP.OPERAND && (quotes % 2) == 0 && parentheses == 0) {
-					
-					op = OP.OPERATOR;
-					newExp += strOperand;
-					strOperand = "";
-					strOperator = " ";
-				}
-
-				if (op == OP.OPERAND) {
-
-					if (!Char.IsDigit (c) && isDigit && (quotes % 2) == 0) {
-
-						newExp += strOperand;
-						strOperand = "";
-						op = OP.OPERATOR;
-						operatorType = OPERATOR_TYPE.UNDEFINED;
-					}
-					else
-						strOperand += c;
-				}
-
-				if (op == OP.OPERATOR) {
-
-					isDigit = false;
-					if (operatorType == OPERATOR_TYPE.UNDEFINED) {
-
-						if (c == '<' || c == '=' || c == '>' || c == '*' || c == '/' || c == '%' 
-							|| c == '-' || c == '+')
-
-							operatorType = OPERATOR_TYPE.SYMBOLIC;
-						else if (c != ' ')
-							operatorType = OPERATOR_TYPE.LITERAL;
-					}
-					else if (operatorType == OPERATOR_TYPE.SYMBOLIC) {
-
-						if (c != '<' && c != '=' && c != '>' && c != ' ') {
-							
-							// this is COPY-PASTE
-							op = OP.OPERAND;
-							if (!newExp.EndsWith (" ") && !strOperator.StartsWith (" ")) 
-								strOperator = " " + strOperator;
-
-							newExp += strOperator;
-
-							if (Char.IsDigit (c))
-								isDigit = true;
-								
-							strOperand = c.ToString ();
-							
-							strOperator = "";
-							continue;
-						}
-					}
-
-					if (operatorType == OPERATOR_TYPE.LITERAL && c == ' ') {
-						op = OP.OPERAND;
-						newExp += strOperator;
-						strOperand += " ";
-						strOperator = "";
-					}
-
-
- 					if (Char.IsDigit (c) && operatorType != OPERATOR_TYPE.LITERAL) {
-
- 						op = OP.OPERAND;
-
- 						if (!newExp.EndsWith (" ") && !strOperator.StartsWith (" "))
- 							strOperator = " " + strOperator;
-						newExp += strOperator;
- 						strOperand = c.ToString ();
- 						isDigit = true;
- 						strOperator = "";
- 					}
-
- 					else if (c != ' ')
-						strOperator += c;					
-				}
-			}
-
-			if (op == OP.OPERATOR)
-				throw new SyntaxErrorException (
-					"Missing operand after '" + strOperator + "' operator");
-			else
-				newExp += strOperand;
-
-			return newExp;
-		}
+		
 	}
 
-        //
-        // O_P_E_R_A_T_O_R_S
-        //
-
-        /// <summary>
-        ///  Class for =
-        /// </summary>
-        internal class ExpressionEquals : ExpressionElement
+	//
+	// O_P_E_R_A_T_O_R_S
+	//
+
+	/// <summary>
+	///  Class for =
+	/// </summary>
+	internal class ExpressionEquals : ExpressionElement 
 	{	
 
-               	public ExpressionEquals (string exp1, string exp2) 
-        	{	
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+		public ExpressionEquals (string exp1, string exp2) 
+		{	
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
 
-		public override bool Test (DataRow Row) {
+		public override bool Test (DataRow Row) 
+		{
 			
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
 
 			return ExpressionElement.Compare (E1, E2, Row) == 0;
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for <
-        /// </summary>
-        internal class ExpressionLessThan : ExpressionElement
+	/// <summary>
+	///  Class for <
+	/// </summary>
+	internal class ExpressionLessThan : ExpressionElement 
 	{	
 
-               	public ExpressionLessThan (string exp1, string exp2) 
-        	{	
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+		public ExpressionLessThan (string exp1, string exp2) 
+		{	
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
 
-		public override bool Test (DataRow Row) {
+		public override bool Test (DataRow Row) 
+		{
 								
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
 					   
 			return ExpressionElement.Compare (E1, E2, Row) < 0;
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for <=
-        /// </summary>
-        internal class ExpressionLessThanOrEqual : ExpressionElement
+	/// <summary>
+	///  Class for <=
+	/// </summary>
+	internal class ExpressionLessThanOrEqual : ExpressionElement 
 	{	
 
-               	public ExpressionLessThanOrEqual (string exp1, string exp2) 
-        	{	
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+		public ExpressionLessThanOrEqual (string exp1, string exp2) 
+		{	
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
 
-		public override bool Test (DataRow Row) {
+		public override bool Test (DataRow Row) 
+		{
 
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
 
 			return ExpressionElement.Compare (E1, E2, Row) <= 0;
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for >
-        /// </summary>
-        internal class ExpressionGreaterThan : ExpressionElement
+	/// <summary>
+	///  Class for >
+	/// </summary>
+	internal class ExpressionGreaterThan : ExpressionElement 
 	{	
 
-               	public ExpressionGreaterThan (string exp1, string exp2) 
-        	{	
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+		public ExpressionGreaterThan (string exp1, string exp2) 
+		{	
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
 
-		public override bool Test (DataRow Row) {
+		public override bool Test (DataRow Row) 
+		{
 			
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
 
 			return ExpressionElement.Compare (E1, E2, Row) > 0;
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for >=
-        /// </summary>
-        internal class ExpressionGreaterThanOrEqual : ExpressionElement
+	/// <summary>
+	///  Class for >=
+	/// </summary>
+	internal class ExpressionGreaterThanOrEqual : ExpressionElement 
 	{	
 
-               	public ExpressionGreaterThanOrEqual (string exp1, string exp2) 
-        	{	
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+		public ExpressionGreaterThanOrEqual (string exp1, string exp2) 
+		{	
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
 
-		public override bool Test (DataRow Row) {
+		public override bool Test (DataRow Row) 
+		{
 
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
 
 			return ExpressionElement.Compare (E1, E2, Row) >= 0;
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for <>
-        /// </summary>
-        internal class ExpressionUnequals : ExpressionElement
-        {	
-
-               	public ExpressionUnequals (string exp1, string exp2) 
-        	{	
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+	/// <summary>
+	///  Class for <>
+	/// </summary>
+	internal class ExpressionUnequals : ExpressionElement 
+	{	
 
-		public override bool Test (DataRow Row) {
+		public ExpressionUnequals (string exp1, string exp2) 
+		{	
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
+
+		public override bool Test (DataRow Row) 
+		{
 			
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
 
 			return ExpressionElement.Compare (E1, E2, Row) != 0;
 		}
-        }
+	}
 
 
-        /// <summary>
-        ///  Class for LIKE-operator
-        /// </summary>
-        internal class ExpressionLike : ExpressionElement
+	/// <summary>
+	///  Class for LIKE-operator
+	/// </summary>
+	internal class ExpressionLike : ExpressionElement 
 	{	
 
-               	public ExpressionLike (string exp1, string exp2) 
-        	{
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+		public ExpressionLike (string exp1, string exp2) 
+		{
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
 
-		public override bool Test (DataRow Row) {
+		public override bool Test (DataRow Row) 
+		{
 
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
@@ -353,12 +233,14 @@
 			int indexOf = -1;
 
 			indexOf = operand2.IndexOf ("*");
-			while (indexOf != -1) {
+			while (indexOf != -1) 
+			{
 
 				oldIndex = indexOf + 1;
 				if (operand2 [indexOf + 1] != ']' || operand2 [indexOf - 1] != '[')
 					throw new EvaluateException ("Error in Like operator: ther string pattern " + operand1 + " is invalid");
-				else {
+				else 
+				{
 					operand2 = operand2.Remove (indexOf + 1, 1);
 					operand2 = operand2.Remove (indexOf -1, 1);
 					oldIndex--;
@@ -369,13 +251,15 @@
 
 			oldIndex = 0;
 			indexOf = operand2.IndexOf ("%");
-			while (indexOf != -1) {
+			while (indexOf != -1) 
+			{
 
 				oldIndex = indexOf + 1;
 				
 				if (operand2 [indexOf + 1] != ']' || operand2 [indexOf - 1] != '[')
 					throw new EvaluateException ("Error in Like operator: ther string pattern " + operand2 + " is invalid");
-				else {
+				else 
+				{
 					operand2 = operand2.Remove (indexOf + 1, 1);
 					operand2 = operand2.Remove (indexOf -1, 1);					
 					oldIndex--;
@@ -386,7 +270,8 @@
 
 			int len2 = operand2.Length;
 			int startIndex = 0;
-			while ((startIndex + len2) <= operand1.Length) {
+			while ((startIndex + len2) <= operand1.Length) 
+			{
 				if (String.Compare (operand1.Substring (startIndex, len2), operand2, !Row.Table.CaseSensitive) == 0)
 					return true;
 				startIndex++;
@@ -394,77 +279,80 @@
 
 			return false;
 		}
-        }
+	}
 
 
-        /// <summary>
-        ///  Class for OR
-        /// </summary>
-        internal class ExpressionOr : ExpressionElement
-        {        	        	
-        	public ExpressionOr (string exp1, string exp2)
-        	{
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+	/// <summary>
+	///  Class for OR
+	/// </summary>
+	internal class ExpressionOr : ExpressionElement 
+	{        	        	
+		public ExpressionOr (string exp1, string exp2) 
+		{
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
 
 		public override bool Test (DataRow Row) 
 		{			
-			foreach (ExpressionElement El in Elements) {
+			foreach (ExpressionElement El in Elements) 
+			{
 				if (El.Test (Row))
 					return true;
 			}
 			
 			return false;
 		}		        	
-        }
+	}
 		
-        /// <summary>
-        ///  Class for AND
-        /// </summary>
-        internal class ExpressionAnd : ExpressionElement
-        {        	        	
-        	public ExpressionAnd (string exp1, string exp2)
-        	{
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+	/// <summary>
+	///  Class for AND
+	/// </summary>
+	internal class ExpressionAnd : ExpressionElement 
+	{        	        	
+		public ExpressionAnd (string exp1, string exp2) 
+		{
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
 	       
-		public override object Result (DataRow Row) {
+		public override object Result (DataRow Row) 
+		{
 			
 			return Test(Row);
 		}
 
 		public override bool Test (DataRow Row) 
 		{
-			foreach (ExpressionElement El in Elements) {
+			foreach (ExpressionElement El in Elements) 
+			{
 				if (!El.Test (Row))
 					return false;
 			}
 			
 			return true;
 		}		        	
-        }
+	}
+
 
+	//
+	// A_R_I_T_H_M_E_T_I_C  O_P_E_R_A_T_O_R_S
+	//
 
-        //
-        // A_R_I_T_H_M_E_T_I_C  O_P_E_R_A_T_O_R_S
-        //
-
-        /// <summary>
-        ///  Class for +
-        /// </summary>
-        internal class ExpressionAddition : ExpressionElement
-        {
-        	public ExpressionAddition (string exp1, string exp2)
-        	{        		
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+	/// <summary>
+	///  Class for +
+	/// </summary>
+	internal class ExpressionAddition : ExpressionElement 
+	{
+		public ExpressionAddition (string exp1, string exp2) 
+		{        		
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
         	
-		public override Type ResultType (DataRow Row)
+		public override Type ResultType (DataRow Row) 
 		{
 			Type ResultType = typeof (string);
 			ExpressionElement exp1Temp = ((ExpressionElement)Elements [0]);
@@ -482,10 +370,10 @@
 			return ResultType;
 		}
 
-        	public override object Result (DataRow Row) 
+		public override object Result (DataRow Row) 
 		{
 			return CalculateResult (Row);
-        	}
+		}
         	
 		protected override object Calculate (object value1, object value2, Type TempType) 
 		{
@@ -500,7 +388,7 @@
 			else if (TempType == typeof (short))
 				Result = (short)value1 + (short)value2;
 			else if (TempType == typeof (ulong))
-					Result = (ulong)value1 + (ulong)value2;
+				Result = (ulong)value1 + (ulong)value2;
 			else if (TempType == typeof (uint))
 				Result = (uint)value1 + (uint)value2;
 			else if (TempType == typeof (ushort))
@@ -509,9 +397,9 @@
 				Result = (byte)value1 + (byte)value2;
 			else if (TempType == typeof (sbyte))
 				Result = (sbyte)value1 + (sbyte)value2;
-			// FIXME:
-			//else if (TempType == typeof (bool))
-			//	Result = (bool)value1 + (bool)value2;
+				// FIXME:
+				//else if (TempType == typeof (bool))
+				//	Result = (bool)value1 + (bool)value2;
 			else if (TempType == typeof (float))
 				Result = (float)value1 + (float)value2;
 			else if (TempType == typeof (double))
@@ -526,36 +414,36 @@
 		}
 
 
-        	// This method is shouldnt never invoked
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
-        }
-
-        /// <summary>
-        ///  Class for -
-        /// </summary>
-        internal class ExpressionSubtraction : ExpressionElement
-        {
-        	public ExpressionSubtraction (string exp1, string exp2)
-        	{        		
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+		// This method is shouldnt never invoked
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
+	}
+
+	/// <summary>
+	///  Class for -
+	/// </summary>
+	internal class ExpressionSubtraction : ExpressionElement 
+	{
+		public ExpressionSubtraction (string exp1, string exp2) 
+		{        		
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
         	
-        	public override object Result (DataRow Row) 
+		public override object Result (DataRow Row) 
 		{        		
 			return CalculateResult (Row);
-        	}
+		}
         	
-        	// This method is shouldnt never invoked
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
+		// This method is shouldnt never invoked
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
 
 		protected override object Calculate (object value1, object value2, Type TempType) 
 		{
@@ -571,7 +459,7 @@
 			else if (TempType == typeof (short))
 				Result = (short)value1 - (short)value2;
 			else if (TempType == typeof (ulong))
-					Result = (ulong)value1 + (ulong)value2;
+				Result = (ulong)value1 + (ulong)value2;
 			else if (TempType == typeof (uint))
 				Result = (uint)value1 - (uint)value2;
 			else if (TempType == typeof (ushort))
@@ -580,9 +468,9 @@
 				Result = (byte)value1 - (byte)value2;
 			else if (TempType == typeof (sbyte))
 				Result = (sbyte)value1 - (sbyte)value2;
-			// FIXME:
-			//else if (TempType == typeof (bool))
-			//	Result = (bool)value1 - (bool)value2;
+				// FIXME:
+				//else if (TempType == typeof (bool))
+				//	Result = (bool)value1 - (bool)value2;
 			else if (TempType == typeof (float))
 				Result = (float)value1 - (float)value2;
 			else if (TempType == typeof (double))
@@ -595,22 +483,22 @@
 			
 			return Result;
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for *
-        /// </summary>
-        internal class ExpressionMultiply : ExpressionElement
-        {
-        	public ExpressionMultiply (string exp1, string exp2)
-        	{        		
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+	/// <summary>
+	///  Class for *
+	/// </summary>
+	internal class ExpressionMultiply : ExpressionElement 
+	{
+		public ExpressionMultiply (string exp1, string exp2) 
+		{        		
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
         	
-		public override Type ResultType (DataRow Row)
+		public override Type ResultType (DataRow Row) 
 		{
 			Type ResultType = null;
 			ExpressionElement E1 = ((ExpressionElement)Elements [0]);
@@ -620,7 +508,7 @@
 				
 			if (t1 == typeof (string) || t2 == typeof (string))
 				throw new EvaluateException ("Cannon perform '*' operation on " + t1.ToString () + 
-							     " and " + t2.ToString ());
+					" and " + t2.ToString ());
 
 			else if (t1 == typeof (long) || t2 == typeof (long))
 				ResultType = typeof (long);
@@ -631,15 +519,15 @@
 			return ResultType;
 		}
 
-        	public override object Result (DataRow Row) 
+		public override object Result (DataRow Row) 
 		{
 			return CalculateResult (Row);
-        	}
+		}
         	
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
 
 		protected override object Calculate (object value1, object value2, Type TempType) 
 		{
@@ -661,9 +549,9 @@
 				Result = (byte)value1 * (byte)value2;
 			else if (TempType == typeof (sbyte))
 				Result = (sbyte)value1 * (sbyte)value2;
-			// FIXME:
-			//else if (TempType == typeof (bool))
-			//	Result = (bool)value1 * (bool)value2;
+				// FIXME:
+				//else if (TempType == typeof (bool))
+				//	Result = (bool)value1 * (bool)value2;
 			else if (TempType == typeof (float))
 				Result = (float)value1 * (float)value2;
 			else if (TempType == typeof (double))
@@ -677,31 +565,31 @@
 			return Result;
 		}
 
-        }
+	}
 
-        /// <summary>
-        ///  Class for *
-        /// </summary>
-        internal class ExpressionDivide : ExpressionElement
-        {
-        	public ExpressionDivide (string exp1, string exp2)
-        	{        		
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+	/// <summary>
+	///  Class for *
+	/// </summary>
+	internal class ExpressionDivide : ExpressionElement 
+	{
+		public ExpressionDivide (string exp1, string exp2) 
+		{        		
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
         	
-        	public override object Result (DataRow Row) 
+		public override object Result (DataRow Row) 
 		{
 			return CalculateResult (Row);
-        	}
+		}
         	
-        	// This method is shouldnt never invoked
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
+		// This method is shouldnt never invoked
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
 
 		protected  override object Calculate (object value1, object value2, Type TempType) 
 		{
@@ -709,9 +597,9 @@
 
 			if (TempType == typeof (long))
 				Result = (long)value1 / (long)value2;
-			// FIXME: 
-			//else if (TempType == typeof (int))
-			//	Result = (string)value1 / (string)value2;
+				// FIXME: 
+				//else if (TempType == typeof (int))
+				//	Result = (string)value1 / (string)value2;
 			else if (TempType == typeof (int))
 				Result = (int)value1 / (int)value2;
 			else if (TempType == typeof (short))
@@ -726,9 +614,9 @@
 				Result = (byte)value1 / (byte)value2;
 			else if (TempType == typeof (sbyte))
 				Result = (sbyte)value1 / (sbyte)value2;
-			// FIXME:
-			//else if (TempType == typeof (bool))
-			//	Result = (bool)value1 // (bool)value2;
+				// FIXME:
+				//else if (TempType == typeof (bool))
+				//	Result = (bool)value1 // (bool)value2;
 			else if (TempType == typeof (float))
 				Result = (float)value1 / (float)value2;
 			else if (TempType == typeof (double))
@@ -741,31 +629,31 @@
 			
 			return Result;
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for *
-        /// </summary>
-        internal class ExpressionModulus : ExpressionElement
-        {
-        	public ExpressionModulus (string exp1, string exp2)
-        	{        		
-        		this.exp1 = exp1;
-        		this.exp2 = exp2;
-        		ParseExpression (exp1);
-        		ParseExpression (exp2);
-        	}
+	/// <summary>
+	///  Class for *
+	/// </summary>
+	internal class ExpressionModulus : ExpressionElement 
+	{
+		public ExpressionModulus (string exp1, string exp2) 
+		{        		
+			this.exp1 = exp1;
+			this.exp2 = exp2;
+			ParseExpression (exp1);
+			ParseExpression (exp2);
+		}
         	
-        	public override object Result (DataRow Row) 
+		public override object Result (DataRow Row) 
 		{
 			return CalculateResult (Row);
-        	}
+		}
         	
-        	// This method is shouldnt never invoked
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
+		// This method is shouldnt never invoked
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
 
 		protected  override object Calculate (object value1, object value2, Type TempType) 
 		{
@@ -773,9 +661,9 @@
 
 			if (TempType == typeof (long))
 				Result = (long)value1 % (long)value2;
-			// FIXME: 
-			//else if (TempType == typeof (int))
-			//	Result = (string)value1 % (string)value2;
+				// FIXME: 
+				//else if (TempType == typeof (int))
+				//	Result = (string)value1 % (string)value2;
 			else if (TempType == typeof (int))
 				Result = (int)value1 % (int)value2;
 			else if (TempType == typeof (short))
@@ -790,9 +678,9 @@
 				Result = (byte)value1 % (byte)value2;
 			else if (TempType == typeof (sbyte))
 				Result = (sbyte)value1 % (sbyte)value2;
-			// FIXME:
-			//else if (TempType == typeof (bool))
-			//	Result = (bool)value1 // (bool)value2;
+				// FIXME:
+				//else if (TempType == typeof (bool))
+				//	Result = (bool)value1 // (bool)value2;
 			else if (TempType == typeof (float))
 				Result = (float)value1 % (float)value2;
 			else if (TempType == typeof (double))
@@ -805,25 +693,45 @@
 			
 			return Result;
 		}
-        }
+	}
 
-        //
-        // _____A_G_G_R_E_G_A_T_E_S_____
-        //
+	//
+	// _____A_G_G_R_E_G_A_T_E_S_____
+	//
 
-        internal class ExpressionAggregate : ExpressionElement
+	internal class ExpressionAggregate : ExpressionElement 
 	{
-        	//public override object Result (DataRow Row) 
-		//{
-		//	return null;
-        	//}
-        	
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
+        	
+		public ExpressionAggregate() 
+		{
+		}
+
+		public ExpressionAggregate(string s) 
+		{
+			s = ExpressionElement.ValidateExpression (s);
+			ParseExpression (s);
+		}
+
+        	
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
+
+		public override object Result(DataRow Row) 
+		{
+			DataRow[] rows = new DataRow[Row.Table.Rows.Count];
+			Row.Table.Rows.CopyTo(rows, 0);
+			return ((ExpressionAggregate)Elements[0]).Result(rows);
+		}
+
+		public virtual object Result(DataRow[] rows) 
+		{
+			return ((ExpressionAggregate)Elements[0]).Result(rows);
+		}
+
 
-		protected virtual void ParseParameters (string s)
+		protected virtual void ParseParameters (string s) 
 		{
 			string stemp = s.ToLower ();
 			bool inString = false;
@@ -837,7 +745,8 @@
 			s = s.Remove (0, 1);
 
 			int parentheses = 0;
-			for (int i = 0; i < s.Length; i++) {
+			for (int i = 0; i < s.Length; i++) 
+			{
 
 				if (s [i] == '\'')
 					inString = !inString;
@@ -846,9 +755,12 @@
 				else if (s [i] == ')')
 					parentheses--;
 
-				if ((s [i] == ',' ||  s [i] == ')') && !inString && parentheses == -1) { // Parameter changed
+				if ((s [i] == ',' ||  s [i] == ')') && !inString && parentheses == -1) 
+				{ 
+					// Parameter changed
 
-					if (p1 == null) {
+					if (p1 == null) 
+					{
 						p1 = s.Substring (0, i);
 						break;
 					}
@@ -863,56 +775,58 @@
 		
 	}
 
-        /// <summary>
-        ///  Class for Sum (column_Name)
-        /// </summary
-        internal class ExpressionSum : ExpressionAggregate
+	/// <summary>
+	///  Class for Sum (column_Name)
+	/// </summary
+	internal class ExpressionSum : ExpressionAggregate 
 	{
-		public ExpressionSum (string exp1)
+		public ExpressionSum (string exp1) 
 		{
 			ParseParameters (exp1);
 		}
 
-        	public override object Result (DataRow Row) 
+		public override object Result(DataRow[] rows) 
 		{
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
-			object value1 = E1.Result (Row);
+			object value1 = E1.Result (rows[0]);
 			Type t1 = value1.GetType ();
-			object result = null;
+			object result = 0;
 			
 			// This could be optimized. If E1 is single element (Not child or parent) the
 			// result of Sum() aggregate is allways same
 
-			if (E1 is ExpressionSingleElement) {
+			if (E1 is ExpressionSingleElement) 
+			{
 				
 				// This should be optimized somehow
-				foreach (DataRow tempRow in Row.Table.Rows) {
+				for (int i = 0; i < rows.Length; i++) 
+				{
 
 					// TODO: other types and exceptions
-					object v = E1.Result (tempRow);
+					object v = E1.Result (rows[i]);
 					t1 = v.GetType ();
 
 					if (v == null || v == DBNull.Value)
 						continue;
 
-					if (t1 == typeof (long)) {
-						result = 0;
+					if (t1 == typeof (long)) 
+					{
 						result = (long)result + (long)v;
 					}
-					else if (t1 == typeof (int)) {
-						result = 0;
+					else if (t1 == typeof (int)) 
+					{
 						result = (int)result + (int)v;
 					}
-					else if (t1 == typeof (short)) {
-						result = 0;
+					else if (t1 == typeof (short)) 
+					{
 						result = (short)result + (short)v;
 					}
-					else if (t1 == typeof (double)) {
-						result = 0;
+					else if (t1 == typeof (double)) 
+					{
 						result = (double)result + (double)v;
 					}
-					else if (t1 == typeof (float)) {
-						result = 0;
+					else if (t1 == typeof (float)) 
+					{
 						result = (float)result + (float)v;
 					}
 					else
@@ -921,46 +835,41 @@
 			}
 			
 			return result;
-        	}
+		}
+
         	
 		//
-		// FIXME: This method is copy-paste in every Aggregate class.
+		// Copy: This method is copy-paste in every Aggregate class.
 		//
 	}
 
-        /// <summary>
-        ///  Class for Avg (column_Name)
-        /// </summary
-        internal class ExpressionAvg : ExpressionAggregate
+	/// <summary>
+	///  Class for Avg (column_Name)
+	/// </summary
+	internal class ExpressionAvg : ExpressionAggregate 
 	{
-		public ExpressionAvg (string exp1)
+		public ExpressionAvg (string exp1) 
 		{
 			ParseParameters (exp1);
 		}
 
-		/// <summary>
-		///  This is used from ExpressionStdDev for evaluating avg.
-		/// </summary>
-		public ExpressionAvg (ExpressionElement E)
-		{
-			Elements.Add (E);
-		}
-
-        	public override object Result (DataRow Row) 
+		public override object Result(DataRow[] rows) 
 		{
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
-			object value1 = E1.Result (Row);
+			object value1 = E1.Result (rows[0]);
 			Type original = value1.GetType ();
 			object result = null;
 			
-			if (E1 is ExpressionSingleElement) {
+			if (E1 is ExpressionSingleElement) 
+			{
 				
 				Type t1 = null;
 				// This should be optimized somehow
-				foreach (DataRow tempRow in Row.Table.Rows) {
+				for (int i = 0; i < rows.Length; i++) 
+				{
 				       
 					// TODO: other types and exceptions
-					object v = E1.Result (tempRow);
+					object v = E1.Result (rows[i]);
 
 					if (v == null || v == DBNull.Value)
 						continue;
@@ -970,19 +879,24 @@
 					if (result == null)
 						result = 0;
 					
-					if (t1 == typeof (long)) {
+					if (t1 == typeof (long)) 
+					{
 						result = (long)result + (long)v;
 					}
-					else if (t1 == typeof (int)) {
+					else if (t1 == typeof (int)) 
+					{
 						result = (int)result + (int)v;
 					}
-					else if (t1 == typeof (short)) {
+					else if (t1 == typeof (short)) 
+					{
 						result = (short)result + (short)v;
 					}
-					else if (t1 == typeof (double)) {
+					else if (t1 == typeof (double)) 
+					{
 						result = (double)result + (double)v;
 					}
-					else if (t1 == typeof (float)) {
+					else if (t1 == typeof (float)) 
+					{
 						result = (float)result + (float)v;
 					}
 					else
@@ -991,45 +905,56 @@
 
 				// TODO: types
 
- 				if (t1 == typeof (long))
- 					result = (long)result / Row.Table.Rows.Count;
- 				else if (t1 == typeof (int))
- 					result = (int)result / Row.Table.Rows.Count;
- 				else if (t1 == typeof (short))
- 					result = (short)result / Row.Table.Rows.Count;
- 				else if (t1 == typeof (double))
- 					result = (double)result / Row.Table.Rows.Count;
+				if (t1 == typeof (long))
+					result = (long)result / rows.Length;
+				else if (t1 == typeof (int))
+					result = (int)result / rows.Length;
+				else if (t1 == typeof (short))
+					result = (short)result / rows.Length;
+				else if (t1 == typeof (double))
+					result = (double)result / rows.Length;
 			}
 			
 			return result;
-        	}        	
+		}
+
+		/// <summary>
+		///  This is used from ExpressionStdDev for evaluating avg.
+		/// </summary>
+		public ExpressionAvg (ExpressionElement E) 
+		{
+			Elements.Add (E);
+		}
+      	
 	}
 
-        /// <summary>
-        ///  Class for Min (column_Name)
-        /// </summary
-        internal class ExpressionMin : ExpressionAggregate
+	/// <summary>
+	///  Class for Min (column_Name)
+	/// </summary
+	internal class ExpressionMin : ExpressionAggregate 
 	{
-		public ExpressionMin (string exp1)
+		public ExpressionMin (string exp1) 
 		{
 			ParseParameters (exp1);
 		}
 
-        	public override object Result (DataRow Row) 
+		public override object Result(DataRow[] rows) 
 		{
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
-			object value1 = E1.Result (Row);
+			object value1 = E1.Result (rows[0]);
 			Type original = value1.GetType ();
 			object result = null;
 			
-			if (E1 is ExpressionSingleElement) {
+			if (E1 is ExpressionSingleElement) 
+			{
 				
 				Type t1 = null;
 				// This should be optimized somehow
-				foreach (DataRow tempRow in Row.Table.Rows) {
+				for (int i = 0; i < rows.Length; i++) 
+				{
 				       
 					// TODO: other types and exceptions
-					object v = E1.Result (tempRow);
+					object v = E1.Result (rows[i]);
 
 					if (v == null || v == DBNull.Value)
 						continue;
@@ -1040,9 +965,9 @@
 						result = 0;
 
 					object CompResult = t1.InvokeMember ("CompareTo", BindingFlags.Default | 
-							       BindingFlags.InvokeMethod, null, 
-							       v, 
-							       new object [] {result});
+						BindingFlags.InvokeMethod, null, 
+						v, 
+						new object [] {result});
 
 					if ((int)CompResult < 0)
 						result = v;
@@ -1051,34 +976,38 @@
 			}
 			
 			return result;
-        	}
+		}
+
+        	
 	}
 
-        /// <summary>
-        ///  Class for Max (column_Name)
-        /// </summary
-        internal class ExpressionMax : ExpressionAggregate
+	/// <summary>
+	///  Class for Max (column_Name)
+	/// </summary
+	internal class ExpressionMax : ExpressionAggregate 
 	{
-		public ExpressionMax (string exp1)
+		public ExpressionMax (string exp1) 
 		{
 			ParseParameters (exp1);
 		}
 
-        	public override object Result (DataRow Row) 
+		public override object Result(DataRow[] rows) 
 		{
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
-			object value1 = E1.Result (Row);
+			object value1 = E1.Result (rows[0]);
 			Type original = value1.GetType ();
 			object result = null;
 			
-			if (E1 is ExpressionSingleElement) {
+			if (E1 is ExpressionSingleElement) 
+			{
 				
 				Type t1 = null;
 				// This should be optimized somehow
-				foreach (DataRow tempRow in Row.Table.Rows) {
+				for (int i = 0; i < rows.Length; i++) 
+				{
 				       
 					// TODO: other types and exceptions
-					object v = E1.Result (tempRow);
+					object v = E1.Result (rows[i]);
 
 					if (v == null || v == DBNull.Value)
 						continue;
@@ -1089,9 +1018,9 @@
 						result = 0;
 
 					object CompResult = t1.InvokeMember ("CompareTo", BindingFlags.Default | 
-							       BindingFlags.InvokeMethod, null, 
-							       v, 
-							       new object [] {result});
+						BindingFlags.InvokeMethod, null, 
+						v, 
+						new object [] {result});
 
 					if ((int)CompResult > 0)
 						result = v;
@@ -1100,55 +1029,65 @@
 			}
 			
 			return result;
-        	}
+		}
+
+        	
 	}
 
 
-        /// <summary>
-        ///  Class for count (column)
-        /// </summary>
-        internal class ExpressionCount : ExpressionAggregate
+	/// <summary>
+	///  Class for count (column)
+	/// </summary>
+	internal class ExpressionCount : ExpressionAggregate 
 	{
-		public ExpressionCount (string exp1)
+		public ExpressionCount (string exp1) 
 		{
 			ParseParameters (exp1);
 		}
+		
+		public override object Result(DataRow[] rows) 
+		{
+			ExpressionElement E1 = (ExpressionElement)Elements [0];
+			int count = 0;
 
-        	public override object Result (DataRow Row) 
+			if (E1 is ExpressionSingleElement) 
+				count = rows.Length;
+			
+			return count;
+		}
+
+		public override object Result (DataRow Row) 
 		{
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			int count = 0;
 
-			if (E1 is ExpressionSingleElement) {
+			if (E1 is ExpressionSingleElement) 
+			{
 				
-				// This should be optimized somehow
-				foreach (DataRow tempRow in Row.Table.Rows) {
-				       
-					count++;
-				}
+				count = Row.Table.Rows.Count;
 			}
 			
 			return count;
-        	}
+		}
 	}
 
 
-        /// <summary>
-        ///  Class for StdDev (column)
-        /// </summary>
-        internal class ExpressionStdev : ExpressionAggregate
+	/// <summary>
+	///  Class for StdDev (column)
+	/// </summary>
+	internal class ExpressionStdev : ExpressionAggregate 
 	{
-		public ExpressionStdev (string exp1)
+		public ExpressionStdev (string exp1) 
 		{		
 			ParseParameters (exp1);
 		}
-		
-        	public override object Result (DataRow Row) 
+
+		public override object Result(DataRow[] rows) 
 		{
-		      	ExpressionElement E1 = (ExpressionElement)Elements [0];
+			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionAvg Avg = new ExpressionAvg (E1);
 
-			object tempAvg = Avg.Result (Row);
+			object tempAvg = Avg.Result (rows[0]);
 			double avg = 0;
 			double sum = 0;
 			double result = 0;
@@ -1156,13 +1095,13 @@
 			if (tempAvg.GetType () == typeof (int))
 				avg = (double)(int)tempAvg;
 			
-			if (E1 is ExpressionSingleElement) {
-
-				foreach (DataRow tempRow in Row.Table.Rows) {
+			if (E1 is ExpressionSingleElement) 
+			{
 
-				       
-					// (value - avg)
-					object v = E1.Result (tempRow);
+				for (int i = 0; i <rows.Length; i++) 
+				{
+					// (value - avg)
+					object v = E1.Result (rows[i]);
 
 					if (v == null || v == DBNull.Value)
 						continue;
@@ -1179,30 +1118,32 @@
 					result += Math.Pow (sum, 2);
 				}
 				
-				result = result / (Row.Table.Rows.Count - 1);
+				result = result / (rows.Length - 1);
 				result = Math.Sqrt (result);
 			}
 
 			return result;
-        	}        	
+		}
+		
+        	
 	}
 
-        /// <summary>
-        ///  Class for Var (column)
-        /// </summary>
-        internal class ExpressionVar : ExpressionAggregate
+	/// <summary>
+	///  Class for Var (column)
+	/// </summary>
+	internal class ExpressionVar : ExpressionAggregate 
 	{
-		public ExpressionVar (string exp1)
+		public ExpressionVar (string exp1) 
 		{
 			ParseParameters (exp1);
 		}
-		
-        	public override object Result (DataRow Row) 
+
+		public override object Result(DataRow[] rows) 
 		{
-		      	ExpressionElement E1 = (ExpressionElement)Elements [0];
+			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionAvg Avg = new ExpressionAvg (E1);
 
-			object tempAvg = Avg.Result (Row);
+			object tempAvg = Avg.Result (rows[0]);
 			double avg = 0;
 			double sum = 0;
 			double result = 0;
@@ -1210,13 +1151,15 @@
 			if (tempAvg.GetType () == typeof (int))
 				avg = (double)(int)tempAvg;
 			
-			if (E1 is ExpressionSingleElement) {
+			if (E1 is ExpressionSingleElement) 
+			{
 
-				foreach (DataRow tempRow in Row.Table.Rows) {
+				for (int i = 0; i < rows.Length; i++) 
+				{
 
 				       
-					// (value - avg)
-					object v = E1.Result (tempRow);
+					// (value - avg)
+					object v = E1.Result (rows[i]);
 
 					if (v == null || v == DBNull.Value)
 						continue;
@@ -1233,42 +1176,44 @@
 					result += Math.Pow (sum, 2);
 				}
 				
-				result = result / (Row.Table.Rows.Count - 1);
+				result = result / (rows.Length - 1);
 			}
 
 			return result;
-        	}        	
+		}
+		
+        	
 	}
 
-        // 
-        // _____F_U_ N_C_T_I_O_N_S_______
-        //
-
-        /// <summary>
-        ///  Class for len (string) function
-        /// </summary>
-        internal class ExpressionLen : ExpressionElement
-        {
-        	public ExpressionLen (string exp1)
-        	{        		
+	// 
+	// _____F_U_ N_C_T_I_O_N_S_______
+	//
+
+	/// <summary>
+	///  Class for len (string) function
+	/// </summary>
+	internal class ExpressionLen : ExpressionElement 
+	{
+		public ExpressionLen (string exp1) 
+		{        		
 			_ResultType = typeof (int);
-        		ParseParameters (exp1);
-        	}
+			ParseParameters (exp1);
+		}
         	
-        	public override object Result (DataRow Row) 
+		public override object Result (DataRow Row) 
 		{
 			ExpressionElement E1 = ((ExpressionElement)Elements [0]);
 			object value1 = E1.Result (Row);
 			
 			return value1.ToString ().Length;
-        	}
+		}
         	
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
 
-		public void ParseParameters (string s)
+		public void ParseParameters (string s) 
 		{
 			string stemp = s.ToLower ();
 			bool inString = false;
@@ -1281,7 +1226,8 @@
 			// remove (
 			s = s.Remove (0, 1);
 			int parentheses = 0;
-			for (int i = 0; i < s.Length; i++) {
+			for (int i = 0; i < s.Length; i++) 
+			{
 
 				if (s [i] == '\'')
 					inString = !inString;
@@ -1290,9 +1236,12 @@
 				else if (s [i] == ')')
 					parentheses--;
 
-				if ((s [i] == ',' ||  s [i] == ')') && !inString && parentheses == -1) { // Parameter changed
+				if ((s [i] == ',' ||  s [i] == ')') && !inString && parentheses == -1) 
+				{ 
+					// Parameter changed
 
-					if (p1 == null) {
+					if (p1 == null) 
+					{
 						p1 = s.Substring (0, i);
 						break;
 					}
@@ -1304,19 +1253,19 @@
 
 			ParseExpression (p1);		
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for iif (exp1, truepart, falsepart) function
-        /// </summary>
-        internal class ExpressionIif : ExpressionElement
-        {
-        	public ExpressionIif (string exp)
-        	{       
+	/// <summary>
+	///  Class for iif (exp1, truepart, falsepart) function
+	/// </summary>
+	internal class ExpressionIif : ExpressionElement 
+	{
+		public ExpressionIif (string exp) 
+		{       
 			ParseParameters (exp);
-        	}
+		}
 
-        	public override object Result (DataRow Row) 
+		public override object Result (DataRow Row) 
 		{
 			ExpressionElement E1 = ((ExpressionElement)Elements [0]);
 			ExpressionElement E2 = ((ExpressionElement)Elements [1]);
@@ -1326,15 +1275,15 @@
 				return E2.Result (Row); // truepart
 			else
 				return E3.Result (Row); // false part			
-        	}
+		}
         	
-        	// This method is shouldnt never invoked
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
+		// This method is shouldnt never invoked
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
 
-		public override Type ResultType (DataRow Row)
+		public override Type ResultType (DataRow Row) 
 		{						
 			ExpressionElement E1 = ((ExpressionElement)Elements [0]);
 			ExpressionElement E2 = ((ExpressionElement)Elements [1]);
@@ -1349,7 +1298,7 @@
 		/// <summary>
 		///  Parses expressions in parameters (exp, truepart, falsepart)
 		/// </summary>
-		private void ParseParameters (string s)
+		private void ParseParameters (string s) 
 		{
 			bool inString = false;
 			string stemp = s.ToLower ();
@@ -1365,7 +1314,8 @@
 			// remove (
 			s = s.Remove (0, 1);
 			int parentheses = 0;
-			for (int i = 0; i < s.Length; i++) {
+			for (int i = 0; i < s.Length; i++) 
+			{
 
 				if (s [i] == '\'')
 					inString = !inString;
@@ -1375,21 +1325,26 @@
 					parentheses--;
 
 				if ((s [i] == ',' && !inString && parentheses == 0) || 
-					(s [i] == ')' && i == (s.Length -1))) { // Parameter changed
+					(s [i] == ')' && i == (s.Length -1))) 
+				{ 
+					// Parameter changed
 
-					if (p1 == null) {
+					if (p1 == null) 
+					{
 						p1 = s.Substring (0, i);
 						s = s.Substring (i + 1);
 						i = 0;
 					}
 
-					else if (p2 == null) {
+					else if (p2 == null) 
+					{
 						p2 = s.Substring (0, i);
 						s = s.Substring (i + 1);
 						i = 0;
 					}
 
-					else if (p3 == null) {
+					else if (p3 == null) 
+					{
 						p3 = s.Substring (0, i);
 						s = s.Substring (i + 1);
 						i = 0;
@@ -1407,19 +1362,19 @@
 			ParseExpression (p2);
 			ParseExpression (p3);
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for isnull (expression, returnvalue) function
-        /// </summary>
-        internal class ExpressionIsNull : ExpressionElement
-        {
-        	public ExpressionIsNull (string exp)
-        	{        		
+	/// <summary>
+	///  Class for isnull (expression, returnvalue) function
+	/// </summary>
+	internal class ExpressionIsNull : ExpressionElement 
+	{
+		public ExpressionIsNull (string exp) 
+		{        		
 			ParseParameters (exp);
-        	}
+		}
         	
-        	public override object Result (DataRow Row) 
+		public override object Result (DataRow Row) 
 		{
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
@@ -1430,9 +1385,9 @@
 				return E2.Result (Row);
 			else
 				return R1;
-        	}
+		}
 
-		public override Type ResultType (DataRow Row)
+		public override Type ResultType (DataRow Row) 
 		{
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
@@ -1448,15 +1403,15 @@
 		/// <summary>
 		///  IsNull function does not return boolean value, so throw exception
 		/// </summary>
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
 
 		/// <summary>
 		///  Parses parameters of function and invoke ParseExpression methods
 		/// </summary>
-		private void ParseParameters (string s)
+		private void ParseParameters (string s) 
 		{
 			bool inString = false;
 			string stemp = s.ToLower ();
@@ -1472,7 +1427,8 @@
 			// remove (
 			s = s.Remove (0, 1);
 			int parentheses = 0;
-			for (int i = 0; i < s.Length; i++) {
+			for (int i = 0; i < s.Length; i++) 
+			{
 
 				if (s [i] == '\'')
 					inString = !inString;
@@ -1482,15 +1438,19 @@
 					parentheses--;
 
 				if ((s [i] == ',' && !inString && parentheses == 0) || 
-					(s [i] == ')' && i == (s.Length -1))) { // Parameter changed
+					(s [i] == ')' && i == (s.Length -1))) 
+				{ 
+					// Parameter changed
 
-					if (p1 == null) {
+					if (p1 == null) 
+					{
 						p1 = s.Substring (0, i);
 						s = s.Substring (i + 1);
 						i = 0;
 					}
 
-					else if (p2 == null) {
+					else if (p2 == null) 
+					{
 						p2 = s.Substring (0, i);
 						s = s.Substring (i + 1);
 						i = 0;
@@ -1507,20 +1467,20 @@
 			ParseExpression (p1);
 			ParseExpression (p2);
 		}
-        }
+	}
 
-        /// <summary>
-        ///  Class for Substring (expression, start, length) function
-        /// </summary>
-        internal class ExpressionSubstring : ExpressionElement
-        {
-        	public ExpressionSubstring (string exp)
-        	{        		
+	/// <summary>
+	///  Class for Substring (expression, start, length) function
+	/// </summary>
+	internal class ExpressionSubstring : ExpressionElement 
+	{
+		public ExpressionSubstring (string exp) 
+		{        		
 			ParseParameters (exp);
 			_ResultType = typeof (string);
-        	}
+		}
         	
-        	public override object Result (DataRow Row) 
+		public override object Result (DataRow Row) 
 		{
 			ExpressionElement E1 = (ExpressionElement)Elements [0];
 			ExpressionElement E2 = (ExpressionElement)Elements [1];
@@ -1534,7 +1494,7 @@
 			Type t3 = value3.GetType ();
 
 			if (value1 == null || value2 == null || value3 == null 
-			    || value1 == DBNull.Value || value2 == DBNull.Value || value3 == DBNull.Value)
+				|| value1 == DBNull.Value || value2 == DBNull.Value || value3 == DBNull.Value)
 				return string.Empty;
 
 			if (t1 != typeof (string))
@@ -1550,7 +1510,8 @@
 
 			if (str.Length < start)
 				str =  string.Empty;
-			else {
+			else 
+			{
 				if ((start + length - 1) > str.Length)
 					str = str.Substring (start - 1);
 				else
@@ -1558,20 +1519,20 @@
 			}
 
 			return str;
-        	}
+		}
 
 		/// <summary>
 		///  IsNull function does not return boolean value, so throw exception
 		/// </summary>
-        	public override bool Test (DataRow Row)
-        	{
-	       		throw new EvaluateException ();
-        	}
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}
 
 		/// <summary>
 		///  Parses parameters of function and invoke ParseExpression methods
 		/// </summary>
-		private void ParseParameters (string s)
+		private void ParseParameters (string s) 
 		{
 			bool inString = false;
 			string stemp = s.ToLower ();
@@ -1588,7 +1549,8 @@
 			// remove (
 			s = s.Remove (0, 1);
 			int parentheses = 0;
-			for (int i = 0; i < s.Length; i++) {
+			for (int i = 0; i < s.Length; i++) 
+			{
 
 				if (s [i] == '\'')
 					inString = !inString;
@@ -1599,21 +1561,26 @@
 
 
 				if ((s [i] == ',' && !inString && parentheses == 0) || 
-					(s [i] == ')' && i == (s.Length -1))) { // Parameter changed
+					(s [i] == ')' && i == (s.Length -1))) 
+				{ 
+					// Parameter changed
 
-					if (p1 == null) {
+					if (p1 == null) 
+					{
 						p1 = s.Substring (0, i);
 						s = s.Substring (i + 1);
 						i = 0;
 					}
 
-					else if (p2 == null) {
+					else if (p2 == null) 
+					{
 						p2 = s.Substring (0, i);
 						s = s.Substring (i + 1);
 						i = 0;
 					}
 
-					else if (p3 == null) {
+					else if (p3 == null) 
+					{
 						p3 = s.Substring (0, i);
 						s = s.Substring (i + 1);
 						i = 0;
@@ -1631,14 +1598,14 @@
 			ParseExpression (p2);
 			ParseExpression (p3);			
 		}
-        }
+	}
 
 	/// <summary>
 	///  Class for In (exp, exp, exp, ...) function
 	/// </summary>
-	internal class ExpressionIn : ExpressionElement
+	internal class ExpressionIn : ExpressionElement 
 	{
-		public ExpressionIn (string exp1, string exp2)
+		public ExpressionIn (string exp1, string exp2) 
 		{       
 			ParseExpression(exp1);
 			ParseParameters (exp2);
@@ -1652,7 +1619,7 @@
 			ExpressionElement E;
 			ExpressionElement columnElement = (ExpressionElement)Elements [0];
 
-			for (int i = 1; i < Elements.Count; i++)
+			for (int i = 1; i < Elements.Count; i++) 
 			{
 				E = (ExpressionElement)Elements [i];
 				if(ExpressionElement.Compare (columnElement, E, Row) == 0)
@@ -1664,7 +1631,7 @@
 		/// <summary>
 		///  Parses parameters of function and invoke ParseExpression methods
 		/// </summary>
-		private void ParseParameters (string s)
+		private void ParseParameters (string s) 
 		{
 			bool inString = false;
 			ArrayList parameters = new ArrayList();
@@ -1701,47 +1668,55 @@
 		}
 	}
 
-        /// <summary>
-        ///  Class for just one element for example string, int, ...
-        /// </summary>
-        internal class ExpressionSingleElement : ExpressionElement
-        {        	
+	/// <summary>
+	///  Class for just one element for example string, int, ...
+	/// </summary>
+	internal class ExpressionSingleElement : ExpressionElement 
+	{        	
 		private object Element = null;
         	
-        	public ExpressionSingleElement (string s)
-        	{
+		public ExpressionSingleElement (string s) 
+		{
 			// TODO: Every type should be checked
-			if (s.StartsWith ("'") && s.EndsWith ("'")) {
+			if (s.StartsWith ("'") && s.EndsWith ("'")) 
+			{
 				Element = s.Substring (1, s.Length - 2);
 				_ResultType = typeof (string);
 			}
-			else if (!Char.IsDigit (s [0]) && s [0] != '-' && s [0] != '+') {
+			else if (!Char.IsDigit (s [0]) && s [0] != '-' && s [0] != '+') 
+			{
 				Element = s;
 				_ResultType = typeof (DataColumn);
 			}
-			else if (s.StartsWith ("#") && s.EndsWith ("#")) {
+			else if (s.StartsWith ("#") && s.EndsWith ("#")) 
+			{
 				Element = DateTime.Parse (s.Substring (1, s.Length - 2));
 				_ResultType = typeof (DateTime);
 			}
-			else {
-				try {
+			else 
+			{
+				try 
+				{
 					Element = int.Parse (s);
 					_ResultType = typeof (int);
-				} catch {
+				} 
+				catch 
+				{
 					Element = Decimal.Parse (s);
 					_ResultType = typeof (Decimal);
 				}
 			}				
-        	}
+		}
 
-        	public override object Result (DataRow Row)
-        	{
+		public override object Result (DataRow Row) 
+		{
 			object Result = null;
-			if (ResultType (Row) == typeof (DataColumn)) {
+			if (ResultType (Row) == typeof (DataColumn)) 
+			{
 				
 				if (!Row.Table.Columns.Contains (Element.ToString ()))
 					throw new EvaluateException ("Column name '" + Element.ToString () + "' not found.");
-				else
+				else 
 				{
 					DataRowVersion rowVersion = DataRowVersion.Default;
 					// if this row is deleted we get the original version, or else we get an exception.
@@ -1753,46 +1728,50 @@
 			else
 				Result = Element;
 				
-        		return Result;
-        	}
+			return Result;
+		}
         	
-        	public override bool Test (DataRow Row)
-        	{
-        		throw new EvaluateException ();
-        	}		
-        }
-
-        /// <summary>
-        ///  Parent class of all the elements of expression
-        /// </summary>
-        internal abstract class ExpressionElement
-        {        	
+		public override bool Test (DataRow Row) 
+		{
+			throw new EvaluateException ();
+		}		
+	}
+
+	/// <summary>
+	///  Parent class of all the elements of expression
+	/// </summary>
+	internal abstract class ExpressionElement 
+	{        
+		enum OP {OPERATOR, OPERAND};
+		enum OPERATOR_TYPE {SYMBOLIC, LITERAL, UNDEFINED};
+		enum OPERAND_TYPE {NUMERIC, STRING, UNDEFINED};
+
 		// 
 		// TODO/FIXME: This class should be inherited more than once. I mean own subclass for operators, functions,...
 		//
 
 		protected string exp1;
-        	protected string exp2;
+		protected string exp2;
 		protected  Type _ResultType;
 
-        	protected ArrayList Elements = new ArrayList ();
+		protected ArrayList Elements = new ArrayList ();
 
 		enum AGGREGATE {SUM, AVG, MIN, MAX, COUNT, STDEV, VAR}
-        	//protected ArrayList Singles = new ArrayList ();
+		//protected ArrayList Singles = new ArrayList ();
         	
 		/// <summary>
 		/// Tells does the current expressions match to current DataRow
 		/// </summary>
-        	abstract public bool Test (DataRow Row);
+		abstract public bool Test (DataRow Row);
 
 		public virtual object Result (DataRow Row) {return null;}
                 
-        	public virtual Type ResultType (DataRow Row)
+		public virtual Type ResultType (DataRow Row) 
 		{
 			return _ResultType;
 		}
 
-		protected object CalculateResult (DataRow Row)
+		protected object CalculateResult (DataRow Row) 
 		{
 			ExpressionElement E1 = ((ExpressionElement)Elements [0]);
 			ExpressionElement E2 = ((ExpressionElement)Elements [1]);
@@ -1802,13 +1781,14 @@
 			Type t1 = value1.GetType ();
 			Type t2 = value2.GetType ();
 			
- 				// Check nulls
+			// Check nulls
 			if (value1 ==  DBNull.Value && value2 == DBNull.Value)
 				return null;
 			
 			// TODO: More types
 			
-			if (t1 == typeof (string) || t2 == typeof (string)) {
+			if (t1 == typeof (string) || t2 == typeof (string)) 
+			{
 				
 				if (t1 != typeof (string))
 					value1 = Convert.ChangeType (value1, Type.GetTypeCode (t2));
@@ -1821,9 +1801,9 @@
 			
 			Result = Calculate (value1, value2, t1);
 			
-        		return Result; 
+			return Result; 
 		}
-		protected virtual object Calculate (object value1, object value2, Type TempType)
+		protected virtual object Calculate (object value1, object value2, Type TempType) 
 		{
 			return null;
 		}
@@ -1832,7 +1812,7 @@
 		///  static method for comparing two ExpressionElement. This is used in =, <, >, <>, <=, >= elements.
 		///  If elements are equal returns 0, if E1 is less that E2, return -1 else if E1 is greater 1 
 		/// </summary>
-		protected static int Compare (ExpressionElement E1, ExpressionElement E2, DataRow Row)
+		protected static int Compare (ExpressionElement E1, ExpressionElement E2, DataRow Row) 
 		{ 
 			int ReturnValue = 0;
 
@@ -1852,7 +1832,8 @@
 			Type RT1 = E1.ResultType (Row);
 			Type RT2 = E2.ResultType (Row);
 
-			if (t1 == typeof (string) || t2 == typeof (string)) {
+			if (t1 == typeof (string) || t2 == typeof (string)) 
+			{
 				// FIXME: If one of elements are string they both should be???
 				//TempType = typeof (string);				
 				if (t1 != typeof (string))
@@ -1861,29 +1842,167 @@
 					value2 = Convert.ChangeType (value2, Type.GetTypeCode (t1));
 
 				
-				if (!Row.Table.CaseSensitive) {
+				if (!Row.Table.CaseSensitive) 
+				{
 					value1 = ((string)value1).ToLower ();
 					value2 = ((string)value2).ToLower ();
 				}
-			}else if (t1 != t2) {
+			}
+			else if (t1 != t2) 
+			{
 				
 				value2 = Convert.ChangeType (value2, Type.GetTypeCode (t1));
 			}
 
 			object Result = t1.InvokeMember ("CompareTo", BindingFlags.Default | 
-							       BindingFlags.InvokeMethod, null, 
-							       value1, 
-							       new object [] {value2});
+				BindingFlags.InvokeMethod, null, 
+				value1, 
+				new object [] {value2});
 			ReturnValue = (int)Result;
 
 			return ReturnValue;
 		}
 
 		/// <summary>
+		///  Checks syntax of expression and throws exception if needed.
+		///  Also removes whitespaces between operator elements for example: age < = 64 --> age <= 64
+		/// </summary>
+		internal static string ValidateExpression (string s) 
+		{			
+			//
+			// TODO: find out nice way to do this. This is NOT nice way :-P
+			//
+			string temp = "";
+			OP op = OP.OPERAND;
+			OPERATOR_TYPE operatorType = OPERATOR_TYPE.UNDEFINED;
+
+			string strOperator = "";
+			string strOperand = "";
+			int quotes = 0;
+			int parentheses = 0;
+			string newExp = "";
+			bool isDigit = false;
+			bool litOperator = false;
+			s = s.Trim();
+			
+			for (int i = 0; i < s.Length; i++) 
+			{
+
+				char c = s [i];
+				
+				if (c == '\'')
+					quotes++;
+
+				if ((c == '\n' || c == '\t') && quotes == 0)
+					c = ' ';
+
+				if (op == OP.OPERAND && c == '(')
+					parentheses++;
+				else if (op == OP.OPERAND && c == ')')
+					parentheses--;
+
+				if (c == ' ' && op ==  OP.OPERAND && (quotes % 2) == 0 && parentheses == 0) 
+				{
+					
+					op = OP.OPERATOR;
+					newExp += strOperand;
+					strOperand = "";
+					strOperator = " ";
+				}
+
+				if (op == OP.OPERAND) 
+				{
+
+					if (!Char.IsDigit (c) && isDigit && (quotes % 2) == 0) 
+					{
+
+						newExp += strOperand;
+						strOperand = "";
+						op = OP.OPERATOR;
+						operatorType = OPERATOR_TYPE.UNDEFINED;
+					}
+					else
+						strOperand += c;
+				}
+
+				if (op == OP.OPERATOR) 
+				{
+
+					isDigit = false;
+					if (operatorType == OPERATOR_TYPE.UNDEFINED) 
+					{
+
+						if (c == '<' || c == '=' || c == '>' || c == '*' || c == '/' || c == '%' 
+							|| c == '-' || c == '+')
+
+							operatorType = OPERATOR_TYPE.SYMBOLIC;
+						else if (c != ' ')
+							operatorType = OPERATOR_TYPE.LITERAL;
+					}
+					else if (operatorType == OPERATOR_TYPE.SYMBOLIC) 
+					{
+
+						if (c != '<' && c != '=' && c != '>' && c != ' ') 
+						{
+							
+							// this is COPY-PASTE
+							op = OP.OPERAND;
+							if (!newExp.EndsWith (" ") && !strOperator.StartsWith (" ")) 
+								strOperator = " " + strOperator;
+
+							newExp += strOperator;
+
+							if (Char.IsDigit (c))
+								isDigit = true;
+								
+							strOperand = c.ToString ();
+							
+							strOperator = "";
+							continue;
+						}
+					}
+
+					if (operatorType == OPERATOR_TYPE.LITERAL && c == ' ') 
+					{
+						op = OP.OPERAND;
+						newExp += strOperator;
+						strOperand += " ";
+						strOperator = "";
+					}
+
+
+					if (Char.IsDigit (c) && operatorType != OPERATOR_TYPE.LITERAL) 
+					{
+
+						op = OP.OPERAND;
+
+						if (!newExp.EndsWith (" ") && !strOperator.StartsWith (" "))
+							strOperator = " " + strOperator;
+						newExp += strOperator;
+						strOperand = c.ToString ();
+						isDigit = true;
+						strOperator = "";
+					}
+
+					else if (c != ' ')
+						strOperator += c;					
+				}
+			}
+
+			if (op == OP.OPERATOR)
+				throw new SyntaxErrorException (
+					"Missing operand after '" + strOperator + "' operator");
+			else
+				newExp += strOperand;
+
+			return newExp;
+		}
+
+		/// <summary>
 		///  Finds and creates Expression elements.
 		///  This presumes that expression is valid.
 		/// </summary>
-		protected void ParseExpression (string s)
+		protected void ParseExpression (string s) 
 		{	
 			//
 			// TODO/FIXME: IMHO, this should be done with different kind of parsing:
@@ -1897,14 +2016,16 @@
 			int temp = -1;
 			
 			// Find parenthesis
-			if ((temp = s.IndexOf ("(")) != -1) {
+			if ((temp = s.IndexOf ("(")) != -1) 
+			{
 				
 				string functionName = "";
 				while (temp != 0 && s [temp - 1] != '=')
 					temp--;
 
 				// Get the previous element of expression
-				while (s [temp] != '(') {
+				while (s [temp] != '(') 
+				{
 					char c = s [temp];
 					functionName = functionName + c;
 					temp++;
@@ -1915,18 +2036,20 @@
 
 				// check if previous element is a function
 				if (!functionName.EndsWith ("convert") && !functionName.EndsWith ("len") &&
-				    !functionName.EndsWith ("isnull") && !functionName.EndsWith ("iif") &&
-				    !functionName.EndsWith ("trim") && !functionName.EndsWith ("substring") &&
-				    !functionName.EndsWith ("sum") && !functionName.EndsWith ("avg") &&
-				    !functionName.EndsWith ("min") && !functionName.EndsWith ("max") &&
-				    !functionName.EndsWith ("count") && !functionName.EndsWith ("stdev") &&
-				    !functionName.EndsWith ("var")&& !functionName.EndsWith ("in")) {
+					!functionName.EndsWith ("isnull") && !functionName.EndsWith ("iif") &&
+					!functionName.EndsWith ("trim") && !functionName.EndsWith ("substring") &&
+					!functionName.EndsWith ("sum") && !functionName.EndsWith ("avg") &&
+					!functionName.EndsWith ("min") && !functionName.EndsWith ("max") &&
+					!functionName.EndsWith ("count") && !functionName.EndsWith ("stdev") &&
+					!functionName.EndsWith ("var")&& !functionName.EndsWith ("in")) 
+				{
 					
 					int startIndex = s.IndexOf ("(");
 					int i = startIndex + 1;
 					int par = 1;
 					char c;				
-					while (par > 0) {
+					while (par > 0) 
+					{
 
 						c = s [i];
 						if (c == '(')
@@ -1952,112 +2075,112 @@
 			else if (FindAndElement (s, ref string1, ref string2))
 				CreateAndElement (string1, string2, inside);
 
-			// find LIKE
+				// find LIKE
 			else if (FindLikeElement (s, ref string1, ref string2))
 				CreateLikeElement (string1, string2, inside);
 			
-			// find IN
+				// find IN
 			else if (FindInElement (s, ref string1, ref string2))
 				CreateInElement (string1, string2, inside);
 
-			// find =
+				// find =
 			else if (FindEqualElement (s, ref string1, ref string2))
 				CreateEqualsElement (string1, string2, inside);
 
-			// find <>
+				// find <>
 			else if (FindUnequalElement (s, ref string1, ref string2))
 				CreateUnequalsElement (string1, string2, inside);
 
-			// find <=
+				// find <=
 			else if (FindLessThanOrEqualElement (s, ref string1, ref string2))
 				CreateLessThanOrEqualElement (string1, string2, inside);
 
-			// find <
+				// find <
 			else if (FindLessThanElement (s, ref string1, ref string2))
 				CreateLessThanElement (string1, string2, inside);
 
-			// find >=
+				// find >=
 			else if (FindGreaterThanOrEqualElement (s, ref string1, ref string2))
 				CreateGreaterThanOrEqualElement (string1, string2, inside);
 
-			// find >
+				// find >
 			else if (FindGreaterThanElement (s, ref string1, ref string2))
 				CreateGreaterThanElement (string1, string2,  inside);
 
-			// if there wasn't any operators like 'and' or 'not' there still could be
-			// arithmetic operators like '+' or '-' or functions like 'iif' or 'substring'
+				// if there wasn't any operators like 'and' or 'not' there still could be
+				// arithmetic operators like '+' or '-' or functions like 'iif' or 'substring'
 
-			// find *
+				// find *
 			else if (FindMultiplyElement (s, ref string1, ref string2))
 				CreateMultiplyElement (string1, string2, inside);
 			
-			// find /
+				// find /
 			else if (FindDivideElement (s, ref string1, ref string2))
 				CreateDivideElement (string1, string2, inside);
 
 
-			// find +
+				// find +
 			else if (FindAdditionElement (s, ref string1, ref string2))
-				 CreateAdditionElement (string1, string2, inside);
+				CreateAdditionElement (string1, string2, inside);
 
-			// find -
+				// find -
 			else if (FindSubtractElement (s, ref string1, ref string2))
 				CreateSubtractionElement (string1, string2, inside);
 
-			// find %
+				// find %
 			else if (FindModulusElement (s, ref string1, ref string2))
 				CreateModulusElement (string1, string2, inside);
 
-			// find sum ()
+				// find sum ()
 			else if (FindAggregateElement (s, AGGREGATE.SUM))
 				Elements.Add (new ExpressionSum (s.Trim ()));
 
-			// find avg ()
+				// find avg ()
 			else if (FindAggregateElement (s, AGGREGATE.AVG))
 				Elements.Add (new ExpressionAvg (s.Trim ()));
 
-			// find min ()
+				// find min ()
 			else if (FindAggregateElement (s, AGGREGATE.MIN))
 				Elements.Add (new ExpressionMin (s.Trim ()));
 
-			// find max ()
+				// find max ()
 			else if (FindAggregateElement (s, AGGREGATE.MAX))
 				Elements.Add (new ExpressionMax (s.Trim ()));
 
-			// find count ()
+				// find count ()
 			else if (FindAggregateElement (s, AGGREGATE.COUNT))
 				Elements.Add (new ExpressionCount (s.Trim ()));				   
 
-			// find stdev ()
+				// find stdev ()
 			else if (FindAggregateElement (s, AGGREGATE.STDEV))
 				Elements.Add (new ExpressionStdev (s.Trim ()));
 
-			// find var ()
+				// find var ()
 			else if (FindAggregateElement (s, AGGREGATE.VAR))
 				Elements.Add (new ExpressionVar (s.Trim ()));
 
-			// find len
+				// find len
 			else if (FindLenElement (s))
 				Elements.Add (new ExpressionLen (s.Trim ()));
 
-			// find iif
+				// find iif
 			else if (FindIifElement (s))
 				Elements.Add (new ExpressionIif (s.Trim ()));
 
-			// find isnull
+				// find isnull
 			else if (FindIsNullElement (s))
 				Elements.Add (new ExpressionIsNull (s.Trim ()));
 
-			// find substring
+				// find substring
 			else if (FindSubstringElement (s))
 				Elements.Add (new ExpressionSubstring (s.Trim ()));
 
-			// if expression is like '(something someoperator something)'
+				// if expression is like '(something someoperator something)'
 			else if (inside.Trim () != string.Empty)
 				ParseExpression (inside);
 
-			// At least, if it wasnt any of the above it is just normat string or int
-			// or....			
+				// At least, if it wasnt any of the above it is just normat string or int
+				// or....			
 			else
 				Elements.Add (new ExpressionSingleElement (s.Trim ()));			
 		}
@@ -2068,7 +2191,7 @@
 		// These methods are temporary for now
 		//
 
-		private bool FindOrElement (string s, ref string s1, ref string s2)
+		private bool FindOrElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf("or");
@@ -2078,7 +2201,8 @@
 
 			// Test if or is between ''
 			int oldIndex = -1;			
-			while ((indexOf = stemp.IndexOf ("or", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("or", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 				
 				oldIndex = indexOf;
 
@@ -2087,13 +2211,15 @@
 					continue;
 				
 				// Check is or part of something else for example column name
-				if (indexOf != 0) {
+				if (indexOf != 0) 
+				{
 					
 					if (stemp [indexOf - 1] != ' ' && stemp [indexOf - 1] != '\'')
 						continue;
 				}
 				
-				if (indexOf < s.Length + 2) {
+				if (indexOf < s.Length + 2) 
+				{
 					
 					if (stemp [indexOf + 2] != ' ' && stemp [indexOf + 2] != '\'')
 						continue;
@@ -2111,7 +2237,7 @@
 			return false;
 		}
 		
-		private bool FindAndElement (string s, ref string s1, ref string s2)
+		private bool FindAndElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf("and");
@@ -2121,7 +2247,8 @@
 
 			// Test if or is between ''
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("and", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("and", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 				
 				oldIndex = indexOf;
 				
@@ -2131,13 +2258,15 @@
 
 
 				// Check is or part of something else for example column name
-				if (indexOf != 0) {
+				if (indexOf != 0) 
+				{
 					
 					if (stemp [indexOf - 1] != ' ' && stemp [indexOf - 1] != '\'')
 						continue;
 				}
 				
-				if (indexOf < stemp.Length + 3) {
+				if (indexOf < stemp.Length + 3) 
+				{
 					
 					if (stemp [indexOf + 3] != ' ' && stemp [indexOf + 3] != '\'')
 						continue;
@@ -2155,7 +2284,7 @@
 			return false;
 		}
 
-		private bool FindLikeElement (string s, ref string s1, ref string s2)
+		private bool FindLikeElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf("like");
@@ -2165,7 +2294,8 @@
 
 			// Test if or is between ''
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("like", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("like", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 				
 				oldIndex = indexOf;
 				
@@ -2175,13 +2305,15 @@
 
 
 				// Check is or part of something else for example column name
-				if (indexOf != 0) {
+				if (indexOf != 0) 
+				{
 					
 					if (stemp [indexOf - 1] != ' ' && stemp [indexOf - 1] != '\'')
 						continue;
 				}
 				
-				if (indexOf < stemp.Length + 4) {
+				if (indexOf < stemp.Length + 4) 
+				{
 					
 					if (stemp [indexOf + 4] != ' ' && stemp [indexOf + 4] != '\'')
 						continue;
@@ -2199,7 +2331,7 @@
 			return false;
 		}
 
-		private bool FindEqualElement (string s, ref string s1, ref string s2)
+		private bool FindEqualElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("=");
@@ -2209,7 +2341,8 @@
 			
 			int oldIndex = -1;
 
-			while ((indexOf = stemp.IndexOf ("=", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("=", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 
@@ -2237,7 +2370,7 @@
 			return false;
 		}
 
-		private bool FindUnequalElement (string s, ref string s1, ref string s2)
+		private bool FindUnequalElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("<>");
@@ -2246,7 +2379,8 @@
 				return false;
 		       
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("<>", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("<>", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 
@@ -2275,7 +2409,7 @@
 		}
 
 
-		private bool FindLessThanElement (string s, ref string s1, ref string s2)
+		private bool FindLessThanElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("<");
@@ -2284,7 +2418,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("<", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("<", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 
@@ -2312,7 +2447,7 @@
 			return false;			
 		}
 
-		private bool FindLessThanOrEqualElement (string s, ref string s1, ref string s2)
+		private bool FindLessThanOrEqualElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("<=");
@@ -2321,7 +2456,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("<=", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("<=", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				// Test is <= element part of string element
@@ -2344,7 +2480,7 @@
 			return false;			
 		}
 
-		private bool FindGreaterThanElement (string s, ref string s1, ref string s2)
+		private bool FindGreaterThanElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf (">");
@@ -2353,7 +2489,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf (">", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf (">", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 
@@ -2380,7 +2517,7 @@
 			return false;			
 		}
 
-		private bool FindGreaterThanOrEqualElement (string s, ref string s1, ref string s2)
+		private bool FindGreaterThanOrEqualElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf (">=");
@@ -2389,7 +2526,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf (">=", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf (">=", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2415,7 +2553,7 @@
 			return false;			
 		}
 
-		private bool FindAdditionElement (string s, ref string s1, ref string s2)
+		private bool FindAdditionElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("+");
@@ -2424,7 +2562,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("+", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("+", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				// FIXME: if '+' represents sign of integer
 
@@ -2451,7 +2590,7 @@
 			return false;			
 		}
 
-		private bool FindSubtractElement (string s, ref string s1, ref string s2)
+		private bool FindSubtractElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("-");
@@ -2460,15 +2599,18 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("-", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("-", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
 
 				// check is this lonely element		
 				failed = true;
-				for (int i = indexOf - 1; i >= 0; i--) {
-					if (stemp [i] != ' ') {
+				for (int i = indexOf - 1; i >= 0; i--) 
+				{
+					if (stemp [i] != ' ') 
+					{
 						failed = false;
 						break;
 					}
@@ -2497,7 +2639,7 @@
 			return false;			
 		}
 
-		private bool FindMultiplyElement (string s, ref string s1, ref string s2)
+		private bool FindMultiplyElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("*");
@@ -2506,7 +2648,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("*", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("*", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 
 				oldIndex = indexOf;
@@ -2534,7 +2677,7 @@
 			return false;			
 		}
 
-		private bool FindDivideElement (string s, ref string s1, ref string s2)
+		private bool FindDivideElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("/");
@@ -2543,7 +2686,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("/", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("/", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 
 				oldIndex = indexOf;
@@ -2571,7 +2715,7 @@
 			return false;			
 		}
 
-		private bool FindModulusElement (string s, ref string s1, ref string s2)
+		private bool FindModulusElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("%");
@@ -2580,7 +2724,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("%", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("%", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 
 				oldIndex = indexOf;
@@ -2605,34 +2750,35 @@
 			return false;			
 		}
 
-		private bool FindAggregateElement (string s, AGGREGATE aggregate)
+		private bool FindAggregateElement (string s, AGGREGATE aggregate) 
 		{
 			string agg = null;
 
-			switch (aggregate) {
+			switch (aggregate) 
+			{
 
-			        case AGGREGATE.SUM:
-				        agg = "sum";
+				case AGGREGATE.SUM:
+					agg = "sum";
+					break;
+				case AGGREGATE.AVG:
+					agg = "avg";
 					break;
-			        case AGGREGATE.AVG:
-				        agg = "avg";
-				        break;
-			        case AGGREGATE.MIN:
-				        agg = "min";
-				        break;
-			        case AGGREGATE.MAX:
-				        agg = "max";
-				        break;
-			        case AGGREGATE.COUNT:
-				        agg = "count";
-				        break;
-			        case AGGREGATE.STDEV:
-				        agg = "stdev";
-				        break;
-		                case AGGREGATE.VAR:
-				        agg = "var";
-				        break;
-			        default:
+				case AGGREGATE.MIN:
+					agg = "min";
+					break;
+				case AGGREGATE.MAX:
+					agg = "max";
+					break;
+				case AGGREGATE.COUNT:
+					agg = "count";
+					break;
+				case AGGREGATE.STDEV:
+					agg = "stdev";
+					break;
+				case AGGREGATE.VAR:
+					agg = "var";
+					break;
+				default:
 					throw new NotImplementedException ();
 			}
 			       
@@ -2644,7 +2790,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf (agg, oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf (agg, oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2665,7 +2812,7 @@
 
 		}
 		
-		private bool FindSumElement (string s)
+		private bool FindSumElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("sum");
@@ -2674,7 +2821,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("sum", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("sum", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2694,7 +2842,7 @@
 			return false;			
 		}
 
-		private bool FindAvgElement (string s)
+		private bool FindAvgElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("avg");
@@ -2703,7 +2851,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("avg", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("avg", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2722,7 +2871,7 @@
 			return false;			
 		}
 
-		private bool FindMinElement (string s)
+		private bool FindMinElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("min");
@@ -2731,7 +2880,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("min", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("min", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2750,7 +2900,7 @@
 			return false;			
 		}
 
-		private bool FindMaxElement (string s)
+		private bool FindMaxElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("max");
@@ -2759,7 +2909,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("max", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("max", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2778,7 +2929,7 @@
 			return false;			
 		}
 
-		private bool FindCountElement (string s)
+		private bool FindCountElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("count");
@@ -2787,7 +2938,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("count", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("count", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2806,7 +2958,7 @@
 			return false;			
 		}
 
-		private bool FindStdevElement (string s)
+		private bool FindStdevElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("stdev");
@@ -2815,7 +2967,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("stdev", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("stdev", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2834,7 +2987,7 @@
 			return false;			
 		}
 
-		private bool FindVarElement (string s)
+		private bool FindVarElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("var");
@@ -2843,7 +2996,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("var", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("var", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2862,7 +3016,7 @@
 			return false;			
 		}
 
-		private bool FindLenElement (string s)
+		private bool FindLenElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("len");
@@ -2871,7 +3025,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("len", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("len", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2891,7 +3046,7 @@
 			return false;			
 		}
 
-		private bool FindIifElement (string s)
+		private bool FindIifElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("iif");
@@ -2900,7 +3055,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("iif", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("iif", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2919,7 +3075,7 @@
 			return false;			
 		}
 
-		private bool FindIsNullElement (string s)
+		private bool FindIsNullElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("isnull");
@@ -2928,7 +3084,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("isnull", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("isnull", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2947,7 +3104,7 @@
 			return false;			
 		}
 
-		private bool FindSubstringElement (string s)
+		private bool FindSubstringElement (string s) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("substring");
@@ -2956,7 +3113,8 @@
 				return false;
 
 			int oldIndex = -1;
-			while ((indexOf = stemp.IndexOf ("substring", oldIndex + 1)) != -1 && indexOf > oldIndex) {
+			while ((indexOf = stemp.IndexOf ("substring", oldIndex + 1)) != -1 && indexOf > oldIndex) 
+			{
 
 				oldIndex = indexOf;
 				bool failed = false;
@@ -2975,7 +3133,7 @@
 			return false;			
 		}
 
-		private bool FindInElement (string s, ref string s1, ref string s2)
+		private bool FindInElement (string s, ref string s1, ref string s2) 
 		{
 			string stemp = s.ToLower ();
 			int indexOf = stemp.IndexOf ("in");
@@ -3032,86 +3190,86 @@
 			Elements.Add (new ExpressionOr (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateAndElement (string s1, string s2, string inside)
+		private void CreateAndElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionAnd (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateLikeElement (string s1, string s2, string inside)
+		private void CreateLikeElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionLike (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateInElement (string s1, string s2, string inside)
+		private void CreateInElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionIn (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateEqualsElement (string s1, string s2, string inside)
+		private void CreateEqualsElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionEquals (s1.Trim (), s2.Trim ()));			
 		}
 
-		private void CreateUnequalsElement (string s1, string s2, string inside)
+		private void CreateUnequalsElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionUnequals (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateLessThanElement (string s1, string s2, string inside)
+		private void CreateLessThanElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionLessThan (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateLessThanOrEqualElement (string s1, string s2, string inside)
+		private void CreateLessThanOrEqualElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionLessThanOrEqual (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateGreaterThanElement (string s1, string s2, string inside)
+		private void CreateGreaterThanElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionGreaterThan (s1.Trim (), s2.Trim ()));
 		}
 
 
-		private void CreateGreaterThanOrEqualElement (string s1, string s2, string inside)
+		private void CreateGreaterThanOrEqualElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionGreaterThanOrEqual (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateAdditionElement (string s1, string s2,  string inside)
+		private void CreateAdditionElement (string s1, string s2,  string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);			
 			Elements.Add (new ExpressionAddition (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateSubtractionElement (string s1, string s2,  string inside)
+		private void CreateSubtractionElement (string s1, string s2,  string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);			
 			Elements.Add (new ExpressionSubtraction (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateMultiplyElement (string s1, string s2, string inside)
+		private void CreateMultiplyElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionMultiply (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateDivideElement (string s1, string s2, string inside)
+		private void CreateDivideElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionDivide (s1.Trim (), s2.Trim ()));
 		}
 
-		private void CreateModulusElement (string s1, string s2, string inside)
+		private void CreateModulusElement (string s1, string s2, string inside) 
 		{
 			CheckParenthesis (inside, ref s1, ref s2);
 			Elements.Add (new ExpressionModulus (s1.Trim (), s2.Trim ()));
@@ -3121,7 +3279,7 @@
 
 		#region Little helppers
 
-		private void CheckParenthesis (string inside, ref string s1, ref string s2)
+		private void CheckParenthesis (string inside, ref string s1, ref string s2) 
 		{
 			if (s1 == string.Empty && inside != string.Empty)
 				s1 = inside;
@@ -3133,11 +3291,12 @@
 		/// <summary>
 		///  Checks is the element part of stringelement
 		/// </summary>
-		private bool IsPartOfStringElement (string s, int indexOf)
+		private bool IsPartOfStringElement (string s, int indexOf) 
 		{
 			// count how many '-charachters are before or. If count is odd it means or IS between quotes
 			int quotes = 0;
-			for (int i = indexOf - 1; i >= 0; i--) {
+			for (int i = indexOf - 1; i >= 0; i--) 
+			{
 				if (s [i] == '\'')
 					quotes++;
 			}
@@ -3151,15 +3310,18 @@
 		/// <summary>
 		///  Checks is the element part of column table
 		/// </summary>
-		private bool IsPartOfColumnName (string s, int indexOf)
+		private bool IsPartOfColumnName (string s, int indexOf) 
 		{
-			for (int i = indexOf; i >= 0; i--) {
+			for (int i = indexOf; i >= 0; i--) 
+			{
 				
 				// If the element is between [] it is part of columnname
-				if (s [i] == '\'' || s [i] == ']') {
+				if (s [i] == '\'' || s [i] == ']') 
+				{
 					break;
 				}
-				else if (s [i] == '[') {
+				else if (s [i] == '[') 
+				{
 					return true;
 				}
 			}
@@ -3171,19 +3333,22 @@
 		/// <summary>
 		///  Checks are element part of function
 		/// </summary>
-		private bool IsPartOfFunction (string s, int indexOf)
+		private bool IsPartOfFunction (string s, int indexOf) 
 		{
 
 			// 
 			// If ',' or '\''  comes before '(' this element is not part of function's parameters
 			//
 			
-			for (int i = indexOf; i >= 0; i--) {
+			for (int i = indexOf; i >= 0; i--) 
+			{
 				
-				if (s [i] == '(' || s [i] == ',') {
+				if (s [i] == '(' || s [i] == ',') 
+				{
 					return true;
 				}
-				else if (s [i] == ')') {
+				else if (s [i] == ')') 
+				{
 					break;
 				}
 			}
@@ -3192,5 +3357,5 @@
 		}
 
 		#endregion // Little helppers
-        }        
+	}        
 }
Index: ForeignKeyConstraint.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/ForeignKeyConstraint.cs,v
retrieving revision 1.13
diff -u -r1.13 ForeignKeyConstraint.cs
--- ForeignKeyConstraint.cs	26 Nov 2003 06:16:56 -0000	1.13
+++ ForeignKeyConstraint.cs	30 Nov 2003 14:00:44 -0000
@@ -148,14 +148,15 @@
 
 					foreach (DataColumn c2 in childColumns) {
 						if (!Object.ReferenceEquals (c2.Table, cc.Table))
-							throw new InvalidConstraintException ("Cannot create a Key from Columns thath belong to different tables.");
+								throw new ArgumentException ("Cannot create a Key from Columns thath belong to different tables.");
+						
 					}
 
 					if (! pc.DataType.Equals(cc.DataType))
 					{
 						//LAMESPEC: spec says throw InvalidConstraintException
 						//		implementation throws InvalidOperationException
-						throw new InvalidConstraintException("Parent column is not type compatible with it's child"
+						throw new ArgumentException("Parent column is not type compatible with it's child"
 								+ " column.");
 					}
 				}	
Index: MergeManager.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/MergeManager.cs,v
retrieving revision 1.4
diff -u -r1.4 MergeManager.cs
--- MergeManager.cs	5 Nov 2003 07:03:03 -0000	1.4
+++ MergeManager.cs	30 Nov 2003 14:00:45 -0000
@@ -110,7 +110,11 @@
 			
 			// if the source table not exists in the target dataset
 			// we act according to the missingschemaaction param.
-			if (!targetSet.Tables.Contains(tableName))
+			int tmp = targetSet.Tables.IndexOf(tableName);
+			// we need to check if it is equals names
+			if (tmp != -1 && !targetSet.Tables[tmp].Equals(tableName))
+				tmp = -1;
+			if (tmp == -1)
 			{
 				if (missingSchemaAction == MissingSchemaAction.Ignore)
 					return true;
