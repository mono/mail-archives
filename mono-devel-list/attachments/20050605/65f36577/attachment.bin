Index: trace.c
===================================================================
--- trace.c	(revision 45414)
+++ trace.c	(working copy)
@@ -96,6 +96,7 @@
 	TOKEN_NAMESPACE,
 	TOKEN_STRING,
 	TOKEN_EXCLUDE,
+	TOKEN_DISABLED,
 	TOKEN_SEPARATOR,
 	TOKEN_END,
 	TOKEN_ERROR
@@ -128,6 +129,8 @@
 			return TOKEN_ALL;
 		if (strcmp (value, "program") == 0)
 			return TOKEN_PROGRAM;
+		if (strcmp (value, "disabled") == 0)
+			return TOKEN_DISABLED;
 		return TOKEN_STRING;
 	}
 	if (*input == '-'){
@@ -198,8 +201,9 @@
 	} else if (token == TOKEN_STRING){
 		trace_spec.ops [*last].op = MONO_TRACEOP_ASSEMBLY;
 		trace_spec.ops [*last].data = g_strdup (value);
-	}
-	else {
+	} else if (token == TOKEN_DISABLED) {
+		trace_spec.enabled = FALSE;
+	} else {
 		fprintf (stderr, "Syntax error in trace option specification\n");
 		return TOKEN_ERROR;
 	}
@@ -214,7 +218,8 @@
 	int size = 1;
 	int last_used;
 	int token;
-	
+
+	trace_spec.enabled = TRUE;
 	if (*p == 0){
 		trace_spec.len = 1;
 		trace_spec.ops = g_new0 (MonoTraceOperation, 1);
@@ -262,8 +267,6 @@
 		indent_level += diff;
 }
 
-static gboolean enable_trace = TRUE;
-
 void
 mono_trace_enter_method (MonoMethod *method, char *ebp)
 {
@@ -274,7 +277,7 @@
 	MonoMethodSignature *sig;
 	char *fname;
 
-	if (!enable_trace)
+	if (!trace_spec.enabled)
 		return;
 
 	fname = mono_method_full_name (method, TRUE);
@@ -413,7 +416,7 @@
 	char *fname;
 	va_list ap;
 
-	if (!enable_trace)
+	if (!trace_spec.enabled)
 		return;
 
 	va_start(ap, method);
@@ -524,3 +527,16 @@
 	//printf (" ip: %p\n", __builtin_return_address (1));
 	printf ("\n");
 }
+
+void
+mono_trace_enable (gboolean enable)
+{
+	trace_spec.enabled = enable;
+}
+
+gboolean
+mono_trace_is_enabled ()
+{
+	return trace_spec.enabled;
+}
+
Index: trace.h
===================================================================
--- trace.h	(revision 45414)
+++ trace.h	(working copy)
@@ -1,5 +1,6 @@
 #ifndef __MONO_TRACE_H__
 #define __MONO_TRACE_H__
+#include <glib.h>
 
 typedef enum {
 	MONO_TRACEOP_ALL,
@@ -18,15 +19,23 @@
 
 struct MonoTraceSpec {
 	int len;
+	gboolean enabled;
 	MonoTraceOperation *ops;
 
 	MonoAssembly *assembly;
 };
 
+G_BEGIN_DECLS
+
 void
 mono_trace_enter_method (MonoMethod *method, char *ebp);
 
 void 
 mono_trace_leave_method (MonoMethod *method, ...);
 
+void mono_trace_enable (gboolean enable);
+gboolean mono_trace_is_enabled (void);
+
+G_END_DECLS
+
 #endif /* __MONO_TRACE_H__ */
Index: mini.c
===================================================================
--- mini.c	(revision 45414)
+++ mini.c	(working copy)
@@ -9685,6 +9685,14 @@
 	mono_arch_handle_exception (ctx, exc, FALSE);
 }
 
+static void
+SIG_HANDLER_SIGNATURE (sigusr2_signal_handler)
+{
+	gboolean enabled = mono_trace_is_enabled ();
+
+	mono_trace_enable (!enabled);
+}
+
 #ifndef PLATFORM_WIN32
 static void
 add_signal_handler (int signo, gpointer handler)
@@ -9718,6 +9726,9 @@
 	win32_seh_set_handler(SIGSEGV, sigsegv_signal_handler);
 	if (debug_options.handle_sigint)
 		win32_seh_set_handler(SIGINT, sigint_signal_handler);
+
+	if (mono_jit_trace_calls != NULL)
+		win32_seh_set_handler(SIGUSR2, sigusr2_signal_handler);
 #else /* !PLATFORM_WIN32 */
 
 	/* libpthreads has its own implementation of sigaction(),
@@ -9732,6 +9743,9 @@
 	add_signal_handler (SIGQUIT, sigquit_signal_handler);
 	add_signal_handler (SIGILL, sigill_signal_handler);
 	add_signal_handler (SIGBUS, sigsegv_signal_handler);
+	if (mono_jit_trace_calls != NULL)
+		add_signal_handler (SIGUSR2, sigusr2_signal_handler);
+
 	add_signal_handler (mono_thread_get_abort_signal (), sigusr1_signal_handler);
 
 	/* catch SIGSEGV */
