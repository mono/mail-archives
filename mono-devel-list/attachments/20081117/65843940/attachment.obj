Index: mono/mono/metadata/ChangeLog
===================================================================
--- mono/mono/metadata/ChangeLog	(revision 119051)
+++ mono/mono/metadata/ChangeLog	(working copy)
@@ -1,3 +1,11 @@
+2008-11-17  Bill Holmes  <billholmes54@gmail.com>
+
+	* marshal.h : cominterop_ccw_getfreethreadedmarshaler added to return the
+	  free threaded marshaler when QueryInterface is called on a COM callable
+	  wrapper requesting the IMarshal interface.
+	  
+	Code is contributed under MIT/X11 license.
+
 2008-11-14  Zoltan Varga  <vargaz@gmail.com>
 
 	* domain-internals.h (MonoDomain): Update MONO_DOMAIN_LAST_GC_TRACKED.
Index: mono/mono/metadata/marshal.c
===================================================================
--- mono/mono/metadata/marshal.c	(revision 119051)
+++ mono/mono/metadata/marshal.c	(working copy)
@@ -219,6 +219,9 @@
 	guint32 ref_count;
 	guint32 gc_handle;
 	GHashTable* vtable_hash;
+#ifdef  PLATFORM_WIN32
+	gpointer free_marshaler;
+#endif
 } MonoCCW;
 
 /* This type is the actual pointer passed to unmanaged code
@@ -11972,6 +11975,9 @@
 
 	if (!ccw) {
 		ccw = g_new0 (MonoCCW, 1);
+#ifdef PLATFORM_WIN32
+		ccw->free_marshaler = 0;
+#endif
 		ccw->vtable_hash = g_hash_table_new (mono_aligned_addr_hash, NULL);
 		ccw->ref_count = 0;
 		/* just alloc a weak handle until we are addref'd*/
@@ -12358,6 +12364,10 @@
 		/* allow gc of object */
 		guint32 oldhandle = ccw->gc_handle;
 		g_assert (oldhandle);
+#ifdef PLATFORM_WIN32
+		if (ccw->free_marshaler)
+			ves_icall_System_Runtime_InteropServices_Marshal_ReleaseInternal (ccw->free_marshaler);
+#endif
 		ccw->gc_handle = mono_gchandle_new_weakref (mono_gchandle_get_target (oldhandle), FALSE);
 		mono_gchandle_free (oldhandle);
 	}
@@ -12368,6 +12378,30 @@
 #define MONO_E_NOINTERFACE 0x80004002L
 #define MONO_E_NOTIMPL 0x80004001L
 
+/* All ccw objects are free threaded */
+static int
+cominterop_ccw_getfreethreadedmarshaler (MonoCCW* ccw, MonoObject* object, gpointer* ppv)
+{
+#ifdef PLATFORM_WIN32
+	if (!ccw->free_marshaler) {
+		int ret = 0;
+		gpointer tunk;
+		tunk = cominterop_get_ccw (object, mono_defaults.iunknown_class);
+		/* remember to addref on QI */
+		cominterop_ccw_addref (tunk);
+		ret = CoCreateFreeThreadedMarshaler (tunk, (LPUNKNOWN*)&ccw->free_marshaler);
+		cominterop_ccw_release(tunk);
+	}
+		
+	if (!ccw->free_marshaler)
+		return MONO_E_NOINTERFACE;
+
+	return ves_icall_System_Runtime_InteropServices_Marshal_QueryInterfaceInternal (ccw->free_marshaler, (IID*)&IID_IMarshal, ppv);
+#else
+	return MONO_E_NOINTERFACE;
+#endif
+}
+
 static int STDCALL 
 cominterop_ccw_queryinterface (MonoCCWInterface* ccwe, guint8* riid, gpointer* ppv)
 {
@@ -12384,6 +12418,9 @@
 	if (ppv)
 		*ppv = NULL;
 
+	if (!mono_domain_get ())
+		mono_thread_attach (mono_get_root_domain ());
+
 	/* handle IUnknown special */
 	if (cominterop_class_guid_equal (riid, mono_defaults.iunknown_class)) {
 		*ppv = cominterop_get_ccw (object, mono_defaults.iunknown_class);
@@ -12400,6 +12437,13 @@
 		return MONO_S_OK;
 	}
 
+#ifdef PLATFORM_WIN32
+	/* handle IMarshal special */
+	if (0 == memcmp (riid, &IID_IMarshal, sizeof (IID))) {
+		return cominterop_ccw_getfreethreadedmarshaler (ccw, object, ppv);	
+	}
+#endif
+
 	ifaces = mono_class_get_implemented_interfaces (klass);
 	if (ifaces) {
 		for (i = 0; i < ifaces->len; ++i) {