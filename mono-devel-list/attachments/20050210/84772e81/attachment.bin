Index: metadata/reflection.h
===================================================================
--- metadata/reflection.h	(revision 40396)
+++ metadata/reflection.h	(working copy)
@@ -122,6 +122,10 @@
 } MonoDeclSecurityActions;
 
 MonoBoolean mono_declsec_get_demands (MonoMethod *callee, MonoDeclSecurityActions* demands);
+MonoBoolean mono_declsec_get_linkdemands (MonoMethod *callee, MonoDeclSecurityActions* klass, MonoDeclSecurityActions* method);
+MonoBoolean mono_declsec_get_inheritdemands_class (MonoMethod *callee, MonoDeclSecurityActions* klass);
+MonoBoolean mono_declsec_get_inheritdemands_method (MonoMethod *callee, MonoDeclSecurityActions* cmethod);
+
 MonoBoolean mono_declsec_get_method_action (MonoMethod *method, guint32 action, MonoDeclSecurityEntry *entry);
 MonoBoolean mono_declsec_get_class_action (MonoClass *klass, guint32 action, MonoDeclSecurityEntry *entry);
 MonoBoolean mono_declsec_get_assembly_action (MonoAssembly *assembly, guint32 action, MonoDeclSecurityEntry *entry);
Index: metadata/security-manager.c
===================================================================
--- metadata/security-manager.c	(revision 40396)
+++ metadata/security-manager.c	(working copy)
@@ -36,11 +36,28 @@
 		
 	secman.demand = mono_class_get_method_from_name (secman.securitymanager,
 		"InternalDemand", 2);	
+	g_assert (secman.demand);
+
 	secman.inheritancedemand = mono_class_get_method_from_name (secman.securitymanager,
-		"InheritanceDemand", 2);	
+		"InheritanceDemand", 3);	
+	g_assert (secman.inheritancedemand);
+
 	secman.linkdemand = mono_class_get_method_from_name (secman.securitymanager,
-		"LinkDemand", 9);
+		"LinkDemand", 3);
+	g_assert (secman.linkdemand);
 
+	secman.linkdemandunmanaged = mono_class_get_method_from_name (secman.securitymanager,
+		"LinkDemandUnmanaged", 1);
+	g_assert (secman.linkdemandunmanaged);
+
+	secman.linkdemandfulltrust = mono_class_get_method_from_name (secman.securitymanager,
+		"LinkDemandFullTrust", 1);
+	g_assert (secman.linkdemandfulltrust);
+
+	secman.linkdemandsecurityexception = mono_class_get_method_from_name (secman.securitymanager,
+		"LinkDemandSecurityException", 3);
+	g_assert (secman.linkdemandsecurityexception);
+
 	return &secman;
 }
 
Index: metadata/security-manager.h
===================================================================
--- metadata/security-manager.h	(revision 40396)
+++ metadata/security-manager.h	(working copy)
@@ -28,8 +28,11 @@
 	MonoMethod *assert;			/* SecurityManager.InternalAssert */
 	MonoMethod *deny;			/* SecurityManager.InternalDeny */
 	MonoMethod *permitonly;			/* SecurityManager.InternalPermitOnly */
+	MonoMethod *inheritancedemand;		/* SecurityManager.InheritanceDemand */
 	MonoMethod *linkdemand;			/* SecurityManager.LinkDemand */
-	MonoMethod *inheritancedemand;		/* SecurityManager.InheritanceDemand */
+	MonoMethod *linkdemandfulltrust;	/* SecurityManager.LinkDemandFullTrust */
+	MonoMethod *linkdemandunmanaged;	/* SecurityManager.LinkDemandUnmanaged */
+	MonoMethod *linkdemandsecurityexception;/* SecurityManager.LinkDemandSecurityException */
 } MonoSecurityManager;
 
 
Index: metadata/ChangeLog
===================================================================
--- metadata/ChangeLog	(revision 40396)
+++ metadata/ChangeLog	(working copy)
@@ -1,4 +1,15 @@
+2005-02-10  Sebastien Pouliot  <sebastien@ximian.com>
 
+	* metadata-internals.h: Added flags to MonoAssembly to cache the most
+	common security informations. This allows us to stay in unmanaged code
+	when doing LinkDemand and it's special cases (except for the first 
+	time for initialization). The flags a very much used with --security.
+	* reflection.c|h: Added code to get declarative security attributes 
+	for LinkDemand and InheritanceDemand. This required to refactor the
+	existing code for Demand.
+	* security-manager.c|h: Added new method fields for the special cases
+	of LinkDemand.
+
 Thu Feb 10 15:03:46 CET 2005 Paolo Molaro <lupus@ximian.com>
 
 	* icall.c, gc.c, gc-internal.h: make sure gchandles can't be used
Index: metadata/metadata-internals.h
===================================================================
--- metadata/metadata-internals.h	(revision 40396)
+++ metadata/metadata-internals.h	(working copy)
@@ -15,6 +15,11 @@
 	guint8 in_gac;
 	guint8 dynamic;
 	guint8 corlib_internal;
+	/* security manager flags (one bit is for lazy initialization) */
+	guint32 ecma:2;		/* Has the ECMA key */
+	guint32 aptc:2;		/* Has the [AllowPartiallyTrustedCallers] attributes */
+	guint32 fulltrust:2;	/* Has FullTrust permission */
+	guint32 unmanaged:2;	/* Has SecurityPermissionFlag.UnmanagedCode permission */
 };
 
 typedef struct {
Index: metadata/reflection.c
===================================================================
--- metadata/reflection.c	(revision 40396)
+++ metadata/reflection.c	(working copy)
@@ -9044,7 +9044,8 @@
  * Returns TRUE if some actions requiring code generation are present, FALSE otherwise.
  */
 static MonoBoolean
-fill_actions_from_index (MonoImage *image, guint32 token, MonoDeclSecurityActions* actions)
+fill_actions_from_index (MonoImage *image, guint32 token, MonoDeclSecurityActions* actions,
+	guint32 id_std, guint32 id_noncas, guint32 id_choice)
 {
 	MonoBoolean result = FALSE;
 	MonoTableInfo *t;
@@ -9061,8 +9062,7 @@
 
 		/* if present only replace (class) permissions with method permissions */
 		/* if empty accept either class or method permissions */
-		switch (cols [MONO_DECL_SECURITY_ACTION]) {
-		case SECURITY_ACTION_DEMAND:
+		if (cols [MONO_DECL_SECURITY_ACTION] == id_std) {
 			if (!actions->demand.blob) {
 				const char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);
 				actions->demand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];
@@ -9070,8 +9070,7 @@
 				actions->demand.size = mono_metadata_decode_blob_size (blob, &blob);
 				result = TRUE;
 			}
-			break;
-		case SECURITY_ACTION_NONCASDEMAND:
+		} else if (cols [MONO_DECL_SECURITY_ACTION] == id_noncas) {
 			if (!actions->noncasdemand.blob) {
 				const char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);
 				actions->noncasdemand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];
@@ -9079,8 +9078,7 @@
 				actions->noncasdemand.size = mono_metadata_decode_blob_size (blob, &blob);
 				result = TRUE;
 			}
-			break;
-		case SECURITY_ACTION_DEMANDCHOICE:
+		} else if (cols [MONO_DECL_SECURITY_ACTION] == id_choice) {
 			if (!actions->demandchoice.blob) {
 				const char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);
 				actions->demandchoice.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];
@@ -9088,13 +9086,32 @@
 				actions->demandchoice.size = mono_metadata_decode_blob_size (blob, &blob);
 				result = TRUE;
 			}
-			break;
 		}
 	}
 
 	return result;
 }
 
+static MonoBoolean
+mono_declsec_get_class_demands_params (MonoMethod *method, MonoDeclSecurityActions* demands, 
+	guint32 id_std, guint32 id_noncas, guint32 id_choice)
+{
+	guint32 idx = mono_metadata_token_index (method->klass->type_token);
+	idx <<= MONO_HAS_DECL_SECURITY_BITS;
+	idx |= MONO_HAS_DECL_SECURITY_TYPEDEF;
+	return fill_actions_from_index (method->klass->image, idx, demands, id_std, id_noncas, id_choice);
+}
+
+static MonoBoolean
+mono_declsec_get_method_demands_params (MonoMethod *method, MonoDeclSecurityActions* demands, 
+	guint32 id_std, guint32 id_noncas, guint32 id_choice)
+{
+	guint32 idx = mono_method_get_index (method);
+	idx <<= MONO_HAS_DECL_SECURITY_BITS;
+	idx |= MONO_HAS_DECL_SECURITY_METHODDEF;
+	return fill_actions_from_index (method->klass->image, idx, demands, id_std, id_noncas, id_choice);
+}
+
 /*
  * Collect all actions (that requires to generate code in mini) assigned for
  * the specified method.
@@ -9103,12 +9120,13 @@
 MonoBoolean
 mono_declsec_get_demands (MonoMethod *method, MonoDeclSecurityActions* demands)
 {
-	MonoImage *image = method->klass->image;
+	guint32 mask = MONO_DECLSEC_FLAG_DEMAND | MONO_DECLSEC_FLAG_NONCAS_DEMAND | 
+		MONO_DECLSEC_FLAG_DEMAND_CHOICE;
 	MonoBoolean result = FALSE;
 	guint32 flags;
 
 	/* quick exit if no declarative security is present in the metadata */
-	if (!image->tables [MONO_TABLE_DECLSECURITY].rows)
+	if (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)
 		return FALSE;
 
 	/* we want the original as the wrapper is "free" of the security informations */
@@ -9120,30 +9138,22 @@
 
 	/* First we look for method-level attributes */
 	if (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {
-		guint32 idx;
-
 		mono_class_init (method->klass);
 		memset (demands, 0, sizeof (MonoDeclSecurityActions));
 
-		idx = mono_method_get_index (method);
-		idx <<= MONO_HAS_DECL_SECURITY_BITS;
-		idx |= MONO_HAS_DECL_SECURITY_METHODDEF;
-		result = fill_actions_from_index (image, idx, demands);
+		result = mono_declsec_get_method_demands_params (method, demands, 
+			SECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);
 	}
 
-	/* Next we fill holes with class-level attributes */
 	/* Here we use (or create) the class declarative cache to look for demands */
 	flags = mono_declsec_flags_from_class (method->klass);
-	if (flags & (MONO_DECLSEC_FLAG_DEMAND | MONO_DECLSEC_FLAG_NONCAS_DEMAND | MONO_DECLSEC_FLAG_DEMAND_CHOICE)) {
-		guint32 idx;
+	if (flags & mask) {
 		if (!result) {
 			mono_class_init (method->klass);
 			memset (demands, 0, sizeof (MonoDeclSecurityActions));
 		}
-		idx = mono_metadata_token_index (method->klass->type_token);
-		idx <<= MONO_HAS_DECL_SECURITY_BITS;
-		idx |= MONO_HAS_DECL_SECURITY_TYPEDEF;
-		result |= fill_actions_from_index (image, idx, demands);
+		result |= mono_declsec_get_class_demands_params (method, demands, 
+			SECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);
 	}
 
 	/* The boolean return value is used as a shortcut in case nothing needs to
@@ -9151,6 +9161,118 @@
 	return result;
 }
 
+
+/*
+ * Collect all Link actions: LinkDemand, NonCasLinkDemand and LinkDemandChoice (2.0).
+ *
+ * Note: Don't use the content of actions if the function return FALSE.
+ */
+MonoBoolean
+mono_declsec_get_linkdemands (MonoMethod *method, MonoDeclSecurityActions* klass, MonoDeclSecurityActions *cmethod)
+{
+	MonoBoolean result = FALSE;
+	guint32 flags;
+
+	/* quick exit if no declarative security is present in the metadata */
+	if (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)
+		return FALSE;
+
+	/* we want the original as the wrapper is "free" of the security informations */
+	if (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) {
+		method = mono_marshal_method_from_wrapper (method);
+		if (!method)
+			return FALSE;
+	}
+
+	/* results are independant - zeroize both */
+	memset (cmethod, 0, sizeof (MonoDeclSecurityActions));
+	memset (klass, 0, sizeof (MonoDeclSecurityActions));
+
+	/* First we look for method-level attributes */
+	if (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {
+		mono_class_init (method->klass);
+
+		result = mono_declsec_get_method_demands_params (method, cmethod, 
+			SECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);
+	}
+
+	/* Here we use (or create) the class declarative cache to look for demands */
+	flags = mono_declsec_flags_from_class (method->klass);
+	if (flags & (MONO_DECLSEC_FLAG_LINKDEMAND | MONO_DECLSEC_FLAG_NONCAS_LINKDEMAND | MONO_DECLSEC_FLAG_LINKDEMAND_CHOICE)) {
+		mono_class_init (method->klass);
+
+		result |= mono_declsec_get_class_demands_params (method, klass, 
+			SECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);
+	}
+
+	return result;
+}
+
+/*
+ * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).
+ *
+ * Note: Don't use the content of actions if the function return FALSE.
+ */
+MonoBoolean
+mono_declsec_get_inheritdemands_class (MonoMethod *method, MonoDeclSecurityActions* klass)
+{
+	MonoBoolean result = FALSE;
+	guint32 flags;
+
+	/* quick exit if no declarative security is present in the metadata */
+	if (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)
+		return FALSE;
+
+	/* we want the original as the wrapper is "free" of the security informations */
+	if (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) {
+		method = mono_marshal_method_from_wrapper (method);
+		if (!method)
+			return FALSE;
+	}
+
+	/* Here we use (or create) the class declarative cache to look for demands */
+	flags = mono_declsec_flags_from_class (method->klass);
+	if (flags & (MONO_DECLSEC_FLAG_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE)) {
+		mono_class_init (method->klass);
+		memset (klass, 0, sizeof (MonoDeclSecurityActions));
+
+		result |= mono_declsec_get_class_demands_params (method, klass, 
+			SECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_INHERITDEMANDCHOICE);
+	}
+
+	return result;
+}
+
+/*
+ * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).
+ *
+ * Note: Don't use the content of actions if the function return FALSE.
+ */
+MonoBoolean
+mono_declsec_get_inheritdemands_method (MonoMethod *method, MonoDeclSecurityActions* cmethod)
+{
+	/* quick exit if no declarative security is present in the metadata */
+	if (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)
+		return FALSE;
+
+	/* we want the original as the wrapper is "free" of the security informations */
+	if (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) {
+		method = mono_marshal_method_from_wrapper (method);
+		if (!method)
+			return FALSE;
+	}
+
+	if (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {
+		mono_class_init (method->klass);
+		memset (cmethod, 0, sizeof (MonoDeclSecurityActions));
+
+		return mono_declsec_get_method_demands_params (method, cmethod, 
+			SECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_INHERITDEMANDCHOICE);
+	}
+	return FALSE;
+}
+
+
 static MonoBoolean
 get_declsec_action (MonoImage *image, guint32 token, guint32 action, MonoDeclSecurityEntry *entry)
 {
Index: mini/mini.c
===================================================================
--- mini/mini.c	(revision 40396)
+++ mini/mini.c	(working copy)
@@ -3681,6 +3681,24 @@
 
 				n = fsig->param_count + fsig->hasthis;
 
+				if (mono_use_security_manager) {
+					/* LinkDemand, NonCasLinkDemand, LinkDemandChoice and other special cases */
+					guint32 result = mono_declsec_linkdemand (cfg->domain, method, cmethod);
+					if (result == MONO_JIT_LINKDEMAND_ECMA) {
+						/* Generate code to throw a SecurityException before the actual call/link */
+						MonoAssembly *assembly = mono_image_get_assembly (method->klass->image);
+						MonoReflectionAssembly *refass = (MonoReflectionAssembly*) mono_assembly_get_object (cfg->domain, assembly);
+						MonoSecurityManager* secman = mono_security_manager_get_methods ();
+						MonoInst *args [3];
+
+						NEW_ICONST (cfg, args [0], 4);
+						NEW_PCONST (cfg, args [1], refass);
+						NEW_PCONST (cfg, args [2], method);
+						mono_emit_method_call_spilled (cfg, bblock, secman->linkdemandsecurityexception, mono_method_signature (secman->linkdemandsecurityexception), args, ip, NULL);
+					} else if ((result != MONO_JIT_SECURITY_OK) && (cfg->security_exception == MONO_JIT_SECURITY_OK))
+						cfg->security_exception = result; /* don't hide previous results */
+				}
+
 				if (cmethod->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL &&
 				    cmethod->klass->parent == mono_defaults.array_class) {
 					array_rank = cmethod->klass->rank;
@@ -5718,6 +5736,7 @@
 				token = read32 (ip + 2);
 				func = mono_method_get_wrapper_data (method, token);
 				info = mono_find_jit_icall_by_addr (func);
+
 				g_assert (info);
 
 				CHECK_STACK (info->sig->param_count);
@@ -9003,6 +9022,23 @@
 	if (cfg->prof_options & MONO_PROFILE_JIT_COMPILATION)
 		mono_profiler_method_end_jit (method, MONO_PROFILE_OK);
 
+	/* this can only be set if the security manager is active */
+	if (cfg->security_exception != MONO_JIT_SECURITY_OK) {
+		MonoSecurityManager* secman = mono_security_manager_get_methods ();
+		MonoObject *exc = NULL;
+		gpointer args [3];
+
+		args [0] = (gpointer*) &cfg->security_exception;
+		args [1] = (gpointer*) mono_assembly_get_object (domain, mono_image_get_assembly (method->klass->image));
+		args [2] = (gpointer*) method;
+		mono_runtime_invoke (secman->linkdemandsecurityexception, NULL, args, &exc);
+
+		mono_destroy_compile (cfg);
+		cfg = NULL;
+
+		mono_raise_exception ((MonoException*)exc);
+	}
+
 	return cfg;
 }
 
Index: mini/mini.h
===================================================================
--- mini/mini.h	(revision 40396)
+++ mini/mini.h	(working copy)
@@ -573,6 +573,7 @@
 	guint16          *intvars;
 	MonoProfileCoverageInfo *coverage_info;
 	MonoCompileArch  arch;
+	guint32          security_exception;
 #ifdef __ia64
 	guint8           ins, locals, outs; /* reg stack region sizes */
 #endif /* __ia64 */
Index: mini/ChangeLog
===================================================================
--- mini/ChangeLog	(revision 40396)
+++ mini/ChangeLog	(working copy)
@@ -1,3 +1,16 @@
+2005-02-10  Sebastien Pouliot  <sebastien@ximian.com>
+
+	* declsec.c: Added LinkDemand support and it's special cases for ECMA,
+	APTC and P/Invoke.
+	* declsec.h: Added macros to get/set lazyly initialized security 
+	informations about assemblies. Added new enum for different type of
+	possible LinkDemand violation. Added function to check LinkDemands.
+	* mini.h: Added a field to MonoCompile to hold any security violation
+	detected when JITting a method (so it can be thrown later).
+	* mini.c: Added LinkDemand checks in mono_method_to_ir for CEE_CALL 
+	and CEE_CALLVIRT. Added code to throw exception at the end of
+	mini_method_compile (note: the exception is unhandled right now).
+
 2005-02-09    <vargaz@freemail.hu>
 
 	* inssel-x86.brg (reg): Align the allocation size in the localloc(imm) case too.
Index: mini/declsec.c
===================================================================
--- mini/declsec.c	(revision 40396)
+++ mini/declsec.c	(working copy)
@@ -94,3 +94,293 @@
 
 	return frame;
 }
+
+
+/*
+ * Execute any LinkDemand, NonCasLinkDemand, LinkDemandChoice declarative
+ * security attribute present on the called method or it's class.
+ *
+ * @domain	The current application domain
+ * @caller	The method calling
+ * @callee	The called method.
+ * return value: TRUE if a security violation is detection, FALSE otherwise.
+ *
+ * Note: The execution is done in managed code in SecurityManager.LinkDemand
+ */
+static gboolean
+mono_declsec_linkdemand_standard (MonoDomain *domain, MonoMethod *caller, MonoMethod *callee)
+{
+	MonoDeclSecurityActions linkclass, linkmethod;
+
+	if (mono_declsec_get_linkdemands (callee, &linkclass, &linkmethod)) {
+		MonoAssembly *assembly = mono_image_get_assembly (caller->klass->image);
+		MonoReflectionAssembly *refass = (MonoReflectionAssembly*) mono_assembly_get_object (domain, assembly);
+		MonoSecurityManager *secman = mono_security_manager_get_methods ();
+		MonoObject *res;
+		gpointer args [3];
+
+		args [0] = (gpointer*) refass;
+		args [1] = (gpointer*) &linkclass;
+		args [2] = (gpointer*) &linkmethod;
+
+		res = mono_runtime_invoke (secman->linkdemand, NULL, args, NULL);
+		return !(*(MonoBoolean *) mono_object_unbox(res));
+	}
+	return FALSE;
+}
+
+/*
+ * Ensure that the restrictions for partially trusted code are satisfied.
+ *
+ * @domain	The current application domain
+ * @caller	The method calling
+ * @callee	The called method
+ * return value: TRUE if a security violation is detection, FALSE otherwise.
+ *
+ * If callee's assembly is strongnamed and doesn't have an 
+ * [AllowPartiallyTrustedCallers] attribute then we must enforce a LinkDemand
+ * for FullTrust on all public/protected methods on public class.
+ *
+ * Note: APTC is only effective on stongnamed assemblies.
+ */
+static gboolean
+mono_declsec_linkdemand_aptc (MonoDomain *domain, MonoMethod *caller, MonoMethod *callee)
+{
+	MonoAssembly *assembly;
+	guint32 size = 0;
+
+	/* A - Applicable only if we're calling into *another* assembly */
+	if (caller->klass->image == callee->klass->image)
+		return FALSE;
+
+	/* B - Applicable if we're calling a public/protected method from a public class */
+	if (!(callee->klass->flags & TYPE_ATTRIBUTE_PUBLIC) || !(callee->flags & FIELD_ATTRIBUTE_PUBLIC))
+		return FALSE;
+
+	/* C - Applicable if the callee's assembly is strongnamed */
+	if ((mono_image_get_public_key (callee->klass->image, &size) == NULL) || (size < MONO_ECMA_KEY_LENGTH))
+		return FALSE;
+
+	/* D - the callee's assembly must have [AllowPartiallyTrustedCallers] */
+	assembly = mono_image_get_assembly (callee->klass->image);
+	if (!MONO_SECMAN_FLAG_INIT (assembly->aptc)) {
+		MonoCustomAttrInfo* cinfo = mono_custom_attrs_from_assembly (assembly);
+		if (cinfo != NULL) {
+			int i;
+			/* look for AllowPartiallyTrustedCallersAttribute _inside_ mscorlib */
+			for (i = 0; i < cinfo->num_attrs; ++i) {
+				if (mono_defaults.corlib == cinfo->attrs [i].ctor->klass->image) {
+					if (strncmp (cinfo->attrs [i].ctor->klass->name, 
+					    "AllowPartiallyTrustedCallersAttribute", 38) == 0) {
+						/* keep this value cached as it will be used very often */
+						MONO_SECMAN_FLAG_SET_VALUE (assembly->aptc, TRUE);
+						return FALSE;
+					}
+				}
+			}
+		}
+		MONO_SECMAN_FLAG_SET_VALUE (assembly->aptc, FALSE);
+	}
+
+	if (MONO_SECMAN_FLAG_GET_VALUE (assembly->aptc))
+		return FALSE;
+
+	/* E - the caller's assembly must have full trust permissions */
+	if (!MONO_SECMAN_FLAG_INIT (assembly->fulltrust)) {
+		MonoReflectionAssembly *refass = (MonoReflectionAssembly*) mono_assembly_get_object (domain, assembly);
+		MonoSecurityManager* secman = mono_security_manager_get_methods ();
+		if (secman && refass) {
+			MonoObject *res;
+			gpointer args [1];
+			args [0] = (gpointer*) refass;
+
+			res = mono_runtime_invoke (secman->linkdemandfulltrust, NULL, args, NULL);
+			if (*(MonoBoolean *) mono_object_unbox(res)) {
+				/* keep this value cached as it will be used very often */
+				MONO_SECMAN_FLAG_SET_VALUE (assembly->fulltrust, TRUE);
+				return FALSE;
+			}
+		}
+
+		MONO_SECMAN_FLAG_SET_VALUE (assembly->fulltrust, FALSE);
+	}
+
+	if (MONO_SECMAN_FLAG_GET_VALUE (assembly->fulltrust))
+		return FALSE;
+
+	/* g_warning ("FAILURE *** JIT LinkDemand APTC check *** %s.%s calls into %s.%s",
+		caller->klass->name, caller->name, callee->klass->name, callee->name); */
+
+	return TRUE;	/* i.e. throw new SecurityException(); */
+}
+
+/*
+ * Ensure that the restrictions for calling internal calls are satisfied.
+ *
+ * @caller	The method calling
+ * @icall	The internal call method
+ * return value: TRUE if a security violation is detection, FALSE otherwise.
+ *
+ * Executing internal calls (icalls) is a restricted operation. Only 
+ * assemblies with an ECMA public key are allowed to call them (unless they
+ * are publicly available).
+ *
+ * This LinkDemand case is special because it can be done without calling 
+ * managed code.
+ *
+ * Note: See SecurityManager.ReflectedInternalCallCheckForEcmaKey for how this
+ * check is performed when reflection is used to execute an internal call.
+ */
+static gboolean
+mono_declsec_linkdemand_ecma (MonoMethod *caller, MonoMethod *icall)
+{
+	MonoAssembly *assembly;
+
+	/* some icall are public (i.e. they CAN be called by any code) */
+	if (((icall->klass->flags & TYPE_ATTRIBUTE_PUBLIC) == TYPE_ATTRIBUTE_PUBLIC) &&
+		((icall->flags & FIELD_ATTRIBUTE_PUBLIC) == FIELD_ATTRIBUTE_PUBLIC)) {
+		return FALSE;
+	}
+
+	assembly = mono_image_get_assembly (icall->klass->image);
+	if (!MONO_SECMAN_FLAG_INIT (assembly->ecma)) {
+		guint32 size = 0;
+		/* ECMA key isn't a real public key - this affect it's length (16) */
+		/* ... and it's value 00000000000000000400000000000000 */
+		const char *pk = mono_image_get_public_key (caller->klass->image, &size);
+		if ((pk != NULL) && (size == MONO_ECMA_KEY_LENGTH) && (pk [8] == 0x04)) {
+			int i, n = 0;
+			for (i=0; i < size; i++)
+				n += pk [i];
+
+			if (n == 4) {
+				/* keep this value cached as it will be used very often */
+				MONO_SECMAN_FLAG_SET_VALUE (assembly->ecma, TRUE);
+				return FALSE;
+			}
+		}
+		MONO_SECMAN_FLAG_SET_VALUE (assembly->ecma, FALSE);
+	}
+
+	if (MONO_SECMAN_FLAG_GET_VALUE (assembly->ecma))
+		return FALSE;
+
+	/* g_warning ("FAILURE *** JIT LinkDemand for ECMA check *** %s.%s calls into %s.%s", 
+		caller->klass->name, caller->name, icall->klass->name, icall->name); */
+
+	return TRUE;	/* i.e. throw new SecurityException(); */
+}
+
+/*
+ * Ensure that the restrictions for calling native code are satisfied.
+ *
+ * @domain	The current application domain
+ * @caller	The method calling
+ * @native	The native method called
+ * return value: TRUE if a security violation is detection, FALSE otherwise.
+ *
+ * Executing Platform Invokes (P/Invoke) is a is a restricted operation.
+ * The security policy must allow (SecurityPermissionFlag.UnmanagedCode)
+ * an assembly to do this.
+ *
+ * This LinkDemand case is special because it only needs to call managed
+ * code once per assembly. Further calls on this assembly will use a cached
+ * flag for better performance. This is not done before the first call (e.g.
+ * when loading the assembly) because that would break the lazy policy
+ * evaluation that Mono use (another time saving optimization).
+ *
+ * Note: P/Invoke checks are ALWAYS (1) done at JIT time (as a LinkDemand). 
+ * They are also checked at runtime, using a Demand (stack walk), unless the 
+ * method or it's class has a [SuppressUnmanagedCodeSecurity] attribute.
+ *
+ * (1) well as long as the security manager is active (i.e. --security)
+ */
+static gboolean
+mono_declsec_linkdemand_pinvoke (MonoDomain *domain, MonoMethod *caller, MonoMethod *native)
+{
+	MonoAssembly *assembly = mono_image_get_assembly (caller->klass->image);
+
+	/* Check for P/Invoke flag for the assembly */
+	if (!MONO_SECMAN_FLAG_INIT (assembly->unmanaged)) {
+		/* Check if we know (and have) or FullTrust status */
+		if (MONO_SECMAN_FLAG_INIT (assembly->fulltrust) && MONO_SECMAN_FLAG_GET_VALUE (assembly->fulltrust)) {
+			/* FullTrust includes UnmanagedCode permission */
+			MONO_SECMAN_FLAG_SET_VALUE (assembly->unmanaged, TRUE);
+		} else {
+			MonoReflectionAssembly *refass = (MonoReflectionAssembly*) mono_assembly_get_object (domain, assembly);
+			MonoSecurityManager* secman = mono_security_manager_get_methods ();
+			if (secman && refass) {
+				MonoObject *res;
+				gpointer args [1];
+				args [0] = (gpointer*) refass;
+
+				res = mono_runtime_invoke (secman->linkdemandunmanaged, NULL, args, NULL);
+				if (*(MonoBoolean *) mono_object_unbox(res)) {
+					MONO_SECMAN_FLAG_SET_VALUE (assembly->unmanaged, TRUE);
+					return FALSE;
+				}
+			}
+		}
+
+		MONO_SECMAN_FLAG_SET_VALUE (assembly->unmanaged, FALSE);
+	}
+
+	if (MONO_SECMAN_FLAG_GET_VALUE (assembly->unmanaged))
+		return FALSE;
+
+	/* g_warning ("FAILURE *** JIT LinkDemand P/Invoke check *** %s.%s calls into %s.%s",
+		caller->klass->name, caller->name, native->klass->name, native->name); */
+
+	return TRUE;	/* i.e. throw new SecurityException(); */
+}
+
+
+/*
+ * Before the JIT can link (call) into a method the following security checks
+ * must be done:
+ *
+ * We check that the code has the permission to link when:
+ * 1. the code try to call an internal call;
+ * 2. the code try to p/invoke to unmanaged code;
+ * 3. the code try to call trusted code without being trusted itself -
+ *    or without the trusted code permission (APTC);
+ * 4. the code try to call managed code protected by a LinkDemand security 
+ *    attribute
+ *
+ * Failures result in a SecurityException being thrown (later in mini code).
+ *
+ * Note: Some checks are duplicated in managed code to deal when reflection is
+ * used to call the methods.
+ */
+guint32
+mono_declsec_linkdemand (MonoDomain *domain, MonoMethod *caller, MonoMethod *callee)
+{
+	guint32 violation = MONO_JIT_SECURITY_OK;
+	/* first, the special (implied) linkdemand */
+
+	if (callee->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {
+		/* restrict calls into the runtime to ECMA signed assemblies */
+		if (mono_declsec_linkdemand_ecma (caller, callee))
+			violation = MONO_JIT_LINKDEMAND_ECMA;
+	} else if (callee->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) {
+		/* CAS can restrict p/invoke calls with the assembly granted permissions */
+		if (mono_declsec_linkdemand_pinvoke (domain, caller, callee))
+			violation = MONO_JIT_LINKDEMAND_PINVOKE;
+	}
+
+	if (!violation) {
+		/* check if we allow partially trusted callers in trusted (signed) assemblies */
+		if (mono_declsec_linkdemand_aptc (domain, caller, callee))
+			violation = MONO_JIT_LINKDEMAND_APTC;
+	}
+
+	/* then the "normal" LinkDemand (only when called method has declarative security) */
+	if (!violation && mono_method_has_declsec (callee)) {
+		/* LinkDemand are ignored for static constructors (ensured by calling mono_method_has_declsec) */
+		if (mono_declsec_linkdemand_standard (domain, caller, callee))
+			violation = MONO_JIT_LINKDEMAND_PERMISSION;
+	}
+
+	/* if (violation) g_warning ("mono_declsec_linkdemand violation reported %d", violation); */
+	return violation;
+}
Index: mini/declsec.h
===================================================================
--- mini/declsec.h	(revision 40396)
+++ mini/declsec.h	(working copy)
@@ -4,7 +4,7 @@
  * Author:
  *	Sebastien Pouliot  <sebastien@ximian.com>
  *
- * (C) 2004 Novell (http://www.novell.com)
+ * (C) 2004-2005 Novell (http://www.novell.com)
  */
 
 #ifndef _MONO_MINI_DECLSEC_H_
@@ -17,10 +17,20 @@
 #include "mono/metadata/object.h"
 #include "mono/metadata/tabledefs.h"
 #include "mono/metadata/marshal.h"
+#include "mono/metadata/security-manager.h"
+#include "mono/metadata/exception.h"
 
 
 /* Definitions */
 
+#define MONO_ECMA_KEY_LENGTH			16
+
+#define MONO_SECMAN_FLAG_INIT(x)		(x & 0x2)
+#define MONO_SECMAN_FLAG_GET_VALUE(x)		(x & 0x1)
+#define MONO_SECMAN_FLAG_SET_VALUE(x,y)		do { x = ((y) ? 0x3 : 0x2); } while (0)
+
+
+/* keep in synch with RuntimeSecurityFrame in /mcs/class/corlib/System.Security/SecurityFrame.cs */
 typedef struct {
 	MonoObject obj;
 	MonoReflectionMethod *method;
@@ -37,9 +47,19 @@
 	MONO_JITINFO_STACKMOD_PERMITONLY	= 0x04
 };
 
+enum {
+	MONO_JIT_SECURITY_OK			= 0x00,
+	MONO_JIT_LINKDEMAND_PERMISSION		= 0x01,
+	MONO_JIT_LINKDEMAND_APTC		= 0x02,
+	MONO_JIT_LINKDEMAND_ECMA		= 0x04,
+	MONO_JIT_LINKDEMAND_PINVOKE		= 0x08
+};
+
 /* Prototypes */
 MonoBoolean mono_method_has_declsec (MonoMethod *method);
 void mono_declsec_cache_stack_modifiers (MonoJitInfo *jinfo);
 MonoSecurityFrame* mono_declsec_create_frame (MonoDomain *domain, MonoJitInfo *jinfo);
 
+guint32 mono_declsec_linkdemand (MonoDomain *domain, MonoMethod *caller, MonoMethod *callee);
+
 #endif /* _MONO_MINI_DECLSEC_H_ */
Index: tests/cas/linkdemand/Makefile
===================================================================
--- tests/cas/linkdemand/Makefile	(revision 40396)
+++ tests/cas/linkdemand/Makefile	(working copy)
@@ -98,9 +98,6 @@
 aptclib.dll: aptclib.cs aptc.snk
 	$(CSCOMPILE) aptclib.cs /out:$@ /target:library /keyfile:aptc.snk
 
-linkdemand_%.exe: linkdemand_%.cs
-	$(CSCOMPILE) $^ /out:$@ /r:Mono.Permissions.dll
-
 %.exe: %.cs
 	$(CSCOMPILE) $^ /out:$@
 
