//
// Authors:
//   Miguel de Icaza (miguel@novell.com)
//
// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Text;

namespace Mono {

	unsafe public abstract class DataConverter {
		static DataConverter SwapConv = new SwapConverter ();
		static DataConverter CopyConv = new CopyConverter ();
		
		public static readonly bool IsLittleEndian = BitConverter.IsLittleEndian;
			
		public abstract double GetDouble (byte [] data, int index);
		public abstract float  GetFloat  (byte [] data, int index);
		public abstract long   GetInt64  (byte [] data, int index);
		public abstract ulong  GetUInt64 (byte [] data, int index);
		public abstract int    GetInt32  (byte [] data, int index);
		public abstract uint   GetUInt32 (byte [] data, int index);
		public abstract short  GetInt16  (byte [] data, int index);
		public abstract ushort GetUInt16 (byte [] data, int index);
		
		public abstract byte[] GetBytes (double value);
		public abstract byte[] GetBytes (float value);
		public abstract byte[] GetBytes (int value);
		public abstract byte[] GetBytes (uint value);
		public abstract byte[] GetBytes (long value);
		public abstract byte[] GetBytes (ulong value);
		public abstract byte[] GetBytes (short value);
		public abstract byte[] GetBytes (ushort value);
		
		static public DataConverter LittleEndian {
			get {
				return IsLittleEndian ? CopyConv : SwapConv;
			}
		}

		static public DataConverter BigEndian {
			get {
				return IsLittleEndian ? SwapConv : CopyConv;
			}
		}

		static public DataConverter Host {
			get {
				return CopyConv;
			}
		}

		struct Buffer {
			public byte [] buffer;
			int next;

			public void Add (byte [] group)
			{
				if (buffer == null){
					buffer = group;
					next = group.Length;
					return;
				}
				if (next + group.Length > buffer.Length){
					byte [] nb = new byte [System.Math.Max (buffer.Length, 16) * 2 + group.Length];
					Array.Copy (buffer, nb, buffer.Length);
					Array.Copy (group, 0, nb, buffer.Length, group.Length);
					next = buffer.Length + group.Length;
					buffer = nb;
				}
			}

			public byte [] Get ()
			{
				if (buffer.Length != next){
					byte [] b = new byte [next];
					Array.Copy (buffer, b, next);
					return b;
				}
				return buffer;
			}
		}

		//
		// Format includes:
		// Control:
		//   ^    Switch to big endian encoding
		//   _    Switch to little endian encoding
		//   %    Switch to host (native) encoding
		//
		// Types:
		//   s    Int16
		//   S    UInt16
		//   i    Int32
		//   I    UInt32
		//   l    Int64
		//   L    UInt64
		//   f    float
		//   d    double
		//   b    byte
		//   $8   string encoded as UTF8
		//   $6   string encoded as UTF16
		//   $7   string encoded as UTF7
		//   $b   string encoded as BigEndianUnicode
		//   x    null byte
		//
		static public byte [] Pack (string description, params object [] args)
		{
			int argn = 0;
			DataConverter conv = CopyConv;
			Buffer b = new Buffer ();
			
			for (int i = 0; i < description.Length; i++){
				object oarg = args [argn];
				
				switch (description [i]){
				case '^':
					conv = BigEndian;
					break;
				case '_':
					conv = LittleEndian;
					break;
				case '%':
					conv = Host;
					break;

				// Type Conversions
				case 'i':
					b.Add (conv.GetBytes (Convert.ToInt32 (oarg)));
					argn++;
					break;
					
				case 'I':
					b.Add (conv.GetBytes (Convert.ToUInt32 (oarg)));
					argn++;
					break;
					
				case 's':
					b.Add (conv.GetBytes (Convert.ToInt16 (oarg)));
					argn++;
					break;
					
				case 'S':
					b.Add (conv.GetBytes (Convert.ToUInt16 (oarg)));
					argn++;
					break;
					
				case 'l':
					b.Add (conv.GetBytes (Convert.ToInt64 (oarg)));
					argn++;
					break;
					
				case 'L':
					b.Add (conv.GetBytes (Convert.ToUInt64 (oarg)));
					argn++;
					break;

				case 'f':
					b.Add (conv.GetBytes (Convert.ToSingle (oarg)));
					argn++;
					break;

				case 'd':
					b.Add (conv.GetBytes (Convert.ToDouble (oarg)));
					argn++;
					break;

				case 'b':
					b.Add (new byte [] { Convert.ToByte (oarg) });
					argn++;
					break;

				case '$':
					i++;
					if (i >= description.Length)
						throw new ArgumentException ("$ description needs a type specified", "description");
					char d = description [i];
					Encoding e;

					switch (d){
					case '8':
						e = Encoding.UTF8;
						break;
					case '6':
						e = Encoding.Unicode;
						break;
					case '7':
						e = Encoding.UTF7;
						break;
					case 'b':
						e = Encoding.BigEndianUnicode;
						break;
					default:
						throw new ArgumentException ("Invalid format for $ specifier", "description");
					}
					b.Add (e.GetBytes (Convert.ToString (oarg)));
					argn++;
					break;
					
				case 'x':
					b.Add (new byte [] { 0 });
					break;
				}
			}
			return b.Get ();
		}
		
		class CopyConverter : DataConverter {
			public override double GetDouble (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("data");

				double ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [i] = data [index+i];

				return ret;
			}

			public override ulong GetUInt64 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("data");

				ulong ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [i] = data [index+i];

				return ret;
			}

			public override long GetInt64 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("data");

				long ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override float GetFloat  (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("data");

				float ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override int GetInt32  (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("data");

				int ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override uint GetUInt32 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("data");

				uint ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override short GetInt16 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 2)
					throw new ArgumentException ("data");

				short ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 2; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override ushort GetUInt16 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 2)
					throw new ArgumentException ("data");

				ushort ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 2; i++)
					b [i] = data [index+i];

				return ret;
			}
			
			public override byte[] GetBytes (double value)
			{
				byte [] ret = new byte [8];
				fixed (byte *target = (&ret [0])){
					long *source = (long *) &value;

					*((long *)target) = *source;
				}

				return ret;
			}
			
			public override byte[] GetBytes (float value)
			{
				byte [] ret = new byte [4];
				fixed (byte *target = &ret [0]){
					uint *source = (uint *) &value;

					*((uint *)target) = *source;
				}

				return ret;
			}
			
			public override byte[] GetBytes (int value)
			{
				byte [] ret = new byte [4];
				fixed (byte *target = &ret [0]){
					uint *source = (uint *) &value;

					*((uint *)target) = *source;
				}

				return ret;
			}
			
			public override byte[] GetBytes (uint value)
			{
				byte [] ret = new byte [4];
				fixed (byte *target = &ret [0]){
					uint *source = (uint *) &value;

					*((uint *)target) = *source;
				}

				return ret;
			}
			
			public override byte[] GetBytes (long value)
			{
				byte [] ret = new byte [8];
				fixed (byte *target = &ret [0]){
					long *source = (long *) &value;

					*((long*)target) = *source;
				}

				return ret;
			}
			
			public override byte[] GetBytes (ulong value)
			{
				byte [] ret = new byte [8];
				fixed (byte *target = &ret [0]){
					ulong *source = (ulong *) &value;

					*((ulong *) target) = *source;
				}

				return ret;
			}
			
			public override byte[] GetBytes (short value)
			{
				byte [] ret = new byte [2];
				fixed (byte *target = &ret [0]){
					ushort *source = (ushort *) &value;

					*((ushort *)target) = *source;
				}

				return ret;
			}
			
			public override byte[] GetBytes (ushort value)
			{
				byte [] ret = new byte [2];
				fixed (byte *target = &ret [0]){
					ushort *source = (ushort *) &value;

					*((ushort *)target) = *source;
				}

				return ret;
			}
		}

		class SwapConverter : DataConverter {
			public override double GetDouble (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("data");

				double ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [7-i] = data [index+i];

				return ret;
			}

			public override ulong GetUInt64 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("data");

				ulong ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [7-i] = data [index+i];

				return ret;
			}

			public override long GetInt64 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 8)
					throw new ArgumentException ("data");

				long ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 8; i++)
					b [7-i] = data [index+i];

				return ret;
			}
			
			public override float GetFloat  (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("data");

				float ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [3-i] = data [index+i];

				return ret;
			}
			
			public override int GetInt32  (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("data");

				int ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [3-i] = data [index+i];

				return ret;
			}
			
			public override uint GetUInt32 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 4)
					throw new ArgumentException ("data");

				uint ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 4; i++)
					b [3-i] = data [index+i];

				return ret;
			}
			
			public override short GetInt16 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 2)
					throw new ArgumentException ("data");

				short ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 2; i++)
					b [1-i] = data [index+i];

				return ret;
			}
			
			public override ushort GetUInt16 (byte [] data, int index)
			{
				if (data == null)
					throw new ArgumentNullException ("data");
				if (data.Length - index < 2)
					throw new ArgumentException ("data");

				ushort ret;
				byte *b = (byte *)&ret;

				for (int i = 0; i < 2; i++)
					b [1-i] = data [index+i];

				return ret;
			}

			public override byte[] GetBytes (double value)
			{
				byte [] ret = new byte [8];

				fixed (byte *target = &ret [0]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 8; i++)
						target [i] = source [7-i];
				}

				return ret;
			}
			
			public override byte[] GetBytes (float value)
			{
				byte [] ret = new byte [4];

				fixed (byte *target = &ret [0]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 4; i++)
						target [i] = source [3-i];
				}

				return ret;
			}
			
			public override byte[] GetBytes (int value)
			{
				byte [] ret = new byte [4];

				fixed (byte *target = &ret [0]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 4; i++)
						target [i] = source [3-i];
				}

				return ret;
			}
			
			public override byte[] GetBytes (uint value)
			{
				byte [] ret = new byte [4];

				fixed (byte *target = &ret [0]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 4; i++)
						target [i] = source [3-i];
				}

				return ret;
			}
			
			public override byte[] GetBytes (long value)
			{
				byte [] ret = new byte [8];

				fixed (byte *target = &ret [0]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 8; i++)
						target [i] = source [7-i];
				}

				return ret;
			}
			
			public override byte[] GetBytes (ulong value)
			{
				byte [] ret = new byte [8];

				fixed (byte *target = &ret [0]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 4; i++)
						target [i] = source [7-i];
				}

				return ret;
			}
			
			public override byte[] GetBytes (short value)
			{
				byte [] ret = new byte [2];

				fixed (byte *target = &ret [0]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 2; i++)
						target [i] = source [1-i];
				}

				return ret;
			}
			
			public override byte[] GetBytes (ushort value)
			{
				byte [] ret = new byte [2];

				fixed (byte *target = &ret [0]){
					byte *source = (byte *) &value;

					for (int i = 0; i < 2; i++)
						target [i] = source [1-i];
				}

				return ret;
			}
		}
		
#region Static converters.
		unsafe void PutBytesLE (byte *dest, byte *src, int count)
		{
			int i = 0;
			
			if (BitConverter.IsLittleEndian){
				for (; i < count; i++)
					*dest++ = *src++;
			} else {
				for (; i < count; i++)
					dest [i-count] = *src++;
			}
		}

		unsafe void PutBytesBE (byte *dest, byte *src, int count)
		{
			int i = 0;
			
			if (BitConverter.IsLittleEndian){
				for (; i < count; i++)
					dest [i-count] = *src++;
			} else {
				for (; i < count; i++)
					*dest++ = *src++;
			}
		}

		unsafe void PutBytesMemory (byte *dest, byte *src, int count)
		{
			int i = 0;
			
			for (; i < count; i++)
				dest [i-count] = *src++;
		}
		
		public unsafe double DoubleFromLE (byte[] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("data");
			
			double ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 8);
			}
			return ret;
		}

		public unsafe float FloatFromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("data");
			
			float ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 4);
			}
			return ret;
		}

		public unsafe long Int64FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("data");
			
			long ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 8);
			}
			return ret;
		}
		
		public unsafe ulong UInt64FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("data");
			
			ulong ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 8);
			}
			return ret;
		}

		public unsafe int Int32FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("data");
			
			int ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 4);
			}
			return ret;
		}
		
		public unsafe uint UInt32FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("data");
			
			uint ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 4);
			}
			return ret;
		}

		public unsafe short Int16FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("data");

			short ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 2);
			}
			return ret;
		}
		
		public unsafe ushort UInt16FromLE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("data");
			
			ushort ret;
			fixed (byte *src = &data[index]){
				PutBytesLE ((byte *) &ret, src, 2);
			}
			return ret;
		}

		public unsafe double DoubleFromBE (byte[] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("data");
			
			double ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 8);
			}
			return ret;
		}

		public unsafe float FloatFromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("data");
			
			float ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 4);
			}
			return ret;
		}

		public unsafe long Int64FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("data");
			
			long ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 8);
			}
			return ret;
		}
		
		public unsafe ulong UInt64FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("data");
			
			ulong ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 8);
			}
			return ret;
		}

		public unsafe int Int32FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("data");
			
			int ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 4);
			}
			return ret;
		}
		
		public unsafe uint UInt32FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("data");
			
			uint ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 4);
			}
			return ret;
		}

		public unsafe short Int16FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("data");

			short ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 2);
			}
			return ret;
		}
		
		public unsafe ushort UInt16FromBE (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("data");
			
			ushort ret;
			fixed (byte *src = &data[index]){
				PutBytesBE ((byte *) &ret, src, 2);
			}
			return ret;
		}

		public unsafe double DoubleFromMemory (byte[] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("data");
			
			double ret;
			fixed (byte *src = &data[index]){
				PutBytesMemory ((byte *) &ret, src, 8);
			}
			return ret;
		}

		public unsafe float FloatFromMemory (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("data");
			
			float ret;
			fixed (byte *src = &data[index]){
				PutBytesMemory ((byte *) &ret, src, 4);
			}
			return ret;
		}

		public unsafe long Int64FromMemory (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("data");
			
			long ret;
			fixed (byte *src = &data[index]){
				PutBytesMemory ((byte *) &ret, src, 8);
			}
			return ret;
		}
		
		public unsafe ulong UInt64FromMemory (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 8)
				throw new ArgumentException ("data");
			
			ulong ret;
			fixed (byte *src = &data[index]){
				PutBytesMemory ((byte *) &ret, src, 8);
			}
			return ret;
		}

		public unsafe int Int32FromMemory (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("data");
			
			int ret;
			fixed (byte *src = &data[index]){
				PutBytesMemory ((byte *) &ret, src, 4);
			}
			return ret;
		}
		
		public unsafe uint UInt32FromMemory (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 4)
				throw new ArgumentException ("data");
			
			uint ret;
			fixed (byte *src = &data[index]){
				PutBytesMemory ((byte *) &ret, src, 4);
			}
			return ret;
		}

		public unsafe short Int16FromMemory (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("data");

			short ret;
			fixed (byte *src = &data[index]){
				PutBytesMemory ((byte *) &ret, src, 2);
			}
			return ret;
		}
		
		public unsafe ushort UInt16FromMemory (byte [] data, int index)
		{
			if (data == null)
				throw new ArgumentNullException ("data");
			if (data.Length - index < 2)
				throw new ArgumentException ("data");
			
			ushort ret;
			fixed (byte *src = &data[index]){
				PutBytesMemory ((byte *) &ret, src, 2);
			}
			return ret;
		}
#endregion
		
	}
}
