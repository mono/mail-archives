
#define GC_PRECISE_STACK

#include <gc.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct {
	int val;
	void *ptr;
} Object;

void finalized (void *o, void *data)
{
	Object *obj = (Object *)o;
	printf("obj%d at %p finalized\n", obj->val, o);
}

Object *create_objects ()
{
	Object *obj1;
	Object *obj2;
	Object *obj3;
	Object *obj4;
	GC_STACK_REFERENCE(x, &obj1, &obj2, &obj3, &obj4);

	obj1 = GC_malloc (sizeof (Object));
	printf("obj1 at %p\n", obj1);
	GC_register_finalizer (obj1, finalized, NULL, NULL, NULL);
	obj1->val = 1;
	obj1->ptr = NULL;

	obj2 = GC_malloc (sizeof (Object));
	printf("obj2 at %p\n", obj2);
	GC_register_finalizer (obj2, finalized, NULL, NULL, NULL);
	obj2->val = 2;
	obj2->ptr = obj1;

	obj3 = GC_malloc (sizeof (Object));
	printf("obj3 at %p\n", obj3);
	GC_register_finalizer (obj3, finalized, NULL, NULL, NULL);
	obj3->val = 3;
	obj3->ptr = obj2;

	obj4 = GC_malloc (sizeof (Object));
	printf("obj4 at %p\n", obj4);
	GC_register_finalizer (obj4, finalized, NULL, NULL, NULL);
	obj4->val = 4;
	obj4->ptr = obj2;

	/* obj1-3 are reachable from the stack, and following
	 * pointers from obj3.  obj4 is only reachable from the
	 * stack
	 */
	printf ("create_objects collecting\n");
	GC_gcollect ();
	GC_invoke_finalizers ();

	printf ("create_objects collecting again\n");
	GC_gcollect ();
	GC_invoke_finalizers ();

	printf ("Returning from create_objects\n");
	return obj3;
}

int main(int argc, char **argv)
{
	Object *obj = create_objects ();
	GC_STACK_REFERENCE(x, &obj);
	//GC_STACK_REFERENCE(x);

	printf ("Got reference to obj%d\n", obj->val);

	/* The obj4 created in create_objects is now unreachable,
	 * but all others are reachable by following the pointer in
	 * obj.
	 */
	GC_gcollect ();
	GC_invoke_finalizers ();
	GC_gcollect ();
	GC_invoke_finalizers ();
	GC_gcollect ();
	GC_invoke_finalizers ();
	GC_gcollect ();
	GC_invoke_finalizers ();

	/* Make sure the optimiser doesn't blow this away before we
	 * run the collector
	 */
	printf ("Still got reference to obj%d\n", obj->val);

	exit (0);
}

