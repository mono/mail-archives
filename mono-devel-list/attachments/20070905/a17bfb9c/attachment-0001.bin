Index: mono/metadata/appdomain.c
===================================================================
--- mono/metadata/appdomain.c	(revision 85261)
+++ mono/metadata/appdomain.c	(working copy)
@@ -111,8 +111,6 @@
 	mono_install_assembly_refonly_preload_hook (mono_domain_assembly_preload, GUINT_TO_POINTER (TRUE));
 	mono_install_assembly_search_hook (mono_domain_assembly_search, GUINT_TO_POINTER (FALSE));
 	mono_install_assembly_refonly_search_hook (mono_domain_assembly_search, GUINT_TO_POINTER (TRUE));
-	mono_install_assembly_postload_search_hook (mono_domain_assembly_postload_search, GUINT_TO_POINTER (FALSE));
-	mono_install_assembly_postload_refonly_search_hook (mono_domain_assembly_postload_search, GUINT_TO_POINTER (TRUE));
 	mono_install_assembly_load_hook (mono_domain_fire_assembly_load, NULL);
 	mono_install_lookup_dynamic_token (mono_reflection_lookup_dynamic_token);
 
@@ -675,8 +673,8 @@
 	return res;
 }
 
-static MonoReflectionAssembly *
-try_assembly_resolve (MonoDomain *domain, MonoString *fname, gboolean refonly)
+MonoReflectionAssembly *
+mono_try_assembly_resolve (MonoDomain *domain, MonoString *fname, gboolean refonly)
 {
 	MonoClass *klass;
 	MonoMethod *method;
@@ -712,7 +710,7 @@
 	aname_str = mono_stringify_assembly_name (aname);
 
 	/* FIXME: We invoke managed code here, so there is a potential for deadlocks */
-	assembly = try_assembly_resolve (domain, mono_string_new (domain, aname_str), refonly);
+	assembly = mono_try_assembly_resolve (domain, mono_string_new (domain, aname_str), refonly);
 
 	g_free (aname_str);
 
@@ -1383,7 +1381,7 @@
 	ass = mono_assembly_load_full (&aname, NULL, &status, refOnly);
 	mono_assembly_name_free (&aname);
 
-	if (!ass && (refass = try_assembly_resolve (domain, assRef, refOnly)) == NULL){
+	if (!ass && (refass = mono_try_assembly_resolve (domain, assRef, refOnly)) == NULL){
 		/* FIXME: it doesn't make much sense since we really don't have a filename ... */
 		MonoException *exc = mono_get_exception_file_not_found2 (NULL, assRef);
 		mono_raise_exception (exc);
Index: mono/metadata/appdomain.h
===================================================================
--- mono/metadata/appdomain.h	(revision 85261)
+++ mono/metadata/appdomain.h	(working copy)
@@ -88,6 +88,9 @@
 MonoAssembly *
 mono_domain_assembly_open  (MonoDomain *domain, const char *name);
 
+MonoReflectionAssembly *
+mono_try_assembly_resolve (MonoDomain *domain, MonoString *fname, gboolean refonly);
+
 gboolean
 mono_domain_finalize       (MonoDomain *domain, guint32 timeout);
 
Index: mono/metadata/assembly.c
===================================================================
--- mono/metadata/assembly.c	(revision 85261)
+++ mono/metadata/assembly.c	(working copy)
@@ -1920,7 +1920,11 @@
 
 	if (res)
 		res->in_gac = TRUE;
-
+	else {
+		MonoDomain *domain = mono_domain_get ();
+		res = mono_try_assembly_resolve (domain, mono_string_new (domain, name), FALSE);		
+	}
+	
 	g_free (fullname);
 	mono_assembly_name_free (aname);
 
Index: mono/metadata/ChangeLog
===================================================================
--- mono/metadata/ChangeLog	(revision 85261)
+++ mono/metadata/ChangeLog	(working copy)
@@ -1,3 +1,17 @@
+2007-09-05  Marek Habersack  <mhabersack@novell.com>
+
+	* assembly.c (mono_assembly_load_with_partial_name): if other
+	attempts fail, trigger the AppDomain.AssemblyResolve event handler
+	to resolve the assembly.
+
+	* appdomain.h: added declaration for mono_try_assembly_resolve.
+
+	* appdomain.c (mono_runtime_init): do not install postload hooks -
+	tests show that MS.NET doesn't use anything of that sort to
+	trigger the AppDomain.AssemblyResolve event.
+	(mono_try_assembly_resolve): renamed from try_assembly_resolve and
+	made public.
+
 2007-09-03  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* process.h, process.c:  added support for user profile/info in
