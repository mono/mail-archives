Index: metadata/reflection.c
===================================================================
--- metadata/reflection.c	(revision 86639)
+++ metadata/reflection.c	(working copy)
@@ -134,6 +134,8 @@
 static void reflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb);
 static void reflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb);
 static guint32 mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type);
+static guint32 mono_image_typedef_or_ref_generic_type_definition (MonoDynamicImage *assembly, MonoClass *klass);
+static guint32 mono_image_typedef_or_ref_or_spec (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec);
 static guint32 mono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method);
 static guint32 mono_image_get_methodbuilder_token (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb);
 static guint32 mono_image_get_ctorbuilder_token (MonoDynamicImage *assembly, MonoReflectionCtorBuilder *cb);
@@ -580,13 +582,17 @@
 {
 	int i;
 	MonoGenericInst *class_inst;
+	MonoClass *klass;
 
 	g_assert (gclass);
 
 	class_inst = gclass->context.class_inst;
 
 	sigbuffer_add_value (buf, MONO_TYPE_GENERICINST);
-	encode_type (assembly, &gclass->container_class->byval_arg, buf);
+	klass = gclass->container_class;
+	sigbuffer_add_value (buf, klass->byval_arg.type);
+	sigbuffer_add_value (buf, mono_image_typedef_or_ref_generic_type_definition (assembly, klass));
+
 	sigbuffer_add_value (buf, class_inst->type_argc);
 	for (i = 0; i < class_inst->type_argc; ++i)
 		encode_type (assembly, class_inst->type_argv [i], buf);
@@ -636,16 +642,22 @@
 	case MONO_TYPE_VALUETYPE:
 	case MONO_TYPE_CLASS: {
 		MonoClass *k = mono_class_from_mono_type (type);
-		/*
-		 * Make sure we use the correct type.
-		 */
-		sigbuffer_add_value (buf, k->byval_arg.type);
-		/*
-		 * ensure only non-byref gets passed to mono_image_typedef_or_ref(),
-		 * otherwise two typerefs could point to the same type, leading to
-		 * verification errors.
-		 */
-		sigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, &k->byval_arg));
+
+		if (k->generic_container) {
+			MonoGenericClass *gclass = mono_metadata_lookup_generic_class (k, k->generic_container->context.class_inst, TRUE);
+			encode_generic_class (assembly, gclass, buf);
+		} else {
+			/*
+			 * Make sure we use the correct type.
+			 */
+			sigbuffer_add_value (buf, k->byval_arg.type);
+			/*
+			 * ensure only non-byref gets passed to mono_image_typedef_or_ref(),
+			 * otherwise two typerefs could point to the same type, leading to
+			 * verification errors.
+			 */
+			sigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, &k->byval_arg));
+		}
 		break;
 	}
 	case MONO_TYPE_ARRAY:
@@ -2150,6 +2162,9 @@
 	guint32 token;
 	SigBuffer buf;
 
+	if ((token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typespec, type))))
+		return token;
+
 	sigbuffer_init (&buf, 32);
 	switch (type->type) {
 	case MONO_TYPE_FNPTR:
@@ -2164,11 +2179,15 @@
 	case MONO_TYPE_CLASS:
 	case MONO_TYPE_VALUETYPE: {
 		MonoClass *k = mono_class_from_mono_type (type);
-		if (!k || !k->generic_class) {
+		if (!k || !(k->generic_class || k->generic_container)) {
 			sigbuffer_free (&buf);
 			return 0;
 		}
-		encode_generic_class (assembly, k->generic_class, &buf);
+
+		if (k->generic_container)
+			encode_type (assembly, &k->byval_arg, &buf);
+		else
+			encode_generic_class (assembly, k->generic_class, &buf);
 		break;
 	}
 	default:
@@ -2186,32 +2205,31 @@
 	sigbuffer_free (&buf);
 
 	token = MONO_TYPEDEFORREF_TYPESPEC | (table->next_idx << MONO_TYPEDEFORREF_BITS);
-	g_hash_table_insert (assembly->typeref, type, GUINT_TO_POINTER(token));
+	g_hash_table_insert (assembly->typespec, type, GUINT_TO_POINTER(token));
 	table->next_idx ++;
 	return token;
 }
 
-/*
- * Despite the name, we handle also TypeSpec (with the above helper).
- */
 static guint32
-mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)
+mono_image_typedef_or_ref_or_spec (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec)
 {
 	MonoDynamicTable *table;
 	guint32 *values;
 	guint32 token, scope, enclosing;
 	MonoClass *klass;
 
-	token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typeref, type));
-	if (token)
-		return token;
-	token = create_typespec (assembly, type);
-	if (token)
-		return token;
 	klass = my_mono_class_from_mono_type (type);
 	if (!klass)
 		klass = mono_class_from_mono_type (type);
 
+	/* if the type requires a typespec, we must try that first*/
+	if (try_typespec && (token = create_typespec (assembly, type)))
+		return token;
+
+	token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typeref, type));
+	if (token)
+		return token;
+
 	/*
 	 * If it's in the same module and not a generic type parameter:
 	 */
@@ -2224,7 +2242,7 @@
 	}
 
 	if (klass->nested_in) {
-		enclosing = mono_image_typedef_or_ref (assembly, &klass->nested_in->byval_arg);
+		enclosing = mono_image_typedef_or_ref_or_spec (assembly, &klass->nested_in->byval_arg, try_typespec);
 		/* get the typeref idx of the enclosing type */
 		enclosing >>= MONO_TYPEDEFORREF_BITS;
 		scope = (enclosing << MONO_RESOLTION_SCOPE_BITS) | MONO_RESOLTION_SCOPE_TYPEREF;
@@ -2247,6 +2265,21 @@
 }
 
 /*
+ * Despite the name, we handle also TypeSpec (with the above helper).
+ */
+static guint32
+mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)
+{
+	return mono_image_typedef_or_ref_or_spec (assembly, type, TRUE);
+}
+
+static guint32
+mono_image_typedef_or_ref_generic_type_definition (MonoDynamicImage *assembly, MonoClass *klass)
+{
+	return mono_image_typedef_or_ref_or_spec (assembly, &klass->byval_arg, FALSE);
+}
+
+/*
  * Insert a memberef row into the metadata: the token that point to the memberref
  * is returned. Caching is done in the caller (mono_image_get_methodref_token() or
  * mono_image_get_fieldref_token()).