Index: mono/mono/mini/mini.c
===================================================================
--- mono/mono/mini/mini.c	(revision 55928)
+++ mono/mono/mini/mini.c	(working copy)
@@ -2889,6 +2889,128 @@
 	return ex;
 }
 
+#define QUICKINLINE 0
+#if QUICKINLINE
+/* QUICKINLINE */
+static MonoClassField* read_field (MonoCompile* cfg, MonoMethod* method, guint32 token, MonoClass** klass)
+{
+       MonoGenericContext *generic_context = NULL;
+       MonoGenericContainer *generic_container = ((MonoMethodNormal *) method)->generic_container;
+       
+       if (method->signature->is_inflated)
+	       generic_context = ((MonoMethodInflated *) method)->context;
+       else if (generic_container)
+	       generic_context = &generic_container->context;
+       
+       return mono_field_from_token (method->klass->image, token, klass, generic_context);
+}
+
+static MonoInst* try_inline_ldfld (MonoCompile *cfg, MonoMethodHeader* h, MonoMethod *method, MonoMethodSignature *sig, MonoInst **args)
+{
+       /* IL_0000:  ldarg.0
+	* IL_0001:  ldfld  int32 X::x
+	* IL_0006:  ret
+	*/
+       
+       MonoInst *offset_ins;
+       MonoInst *ins;
+       MonoInst *load;
+       MonoClassField *field;
+       MonoClass* klass;
+       guint foffset;
+
+       if (h->code_size != 7)
+	       return NULL;
+
+       if (sig->param_count != 0 || !sig->hasthis)
+	       return NULL;
+
+       if (!(h->code [0] == CEE_LDARG_0 && h->code [1] == CEE_LDFLD && h->code [6] == CEE_RET))
+	       return NULL;
+
+       field = read_field (cfg, method, read32 (h->code + 2), &klass);
+       mono_class_init (klass);
+
+       foffset = klass->valuetype ? field->offset - sizeof (MonoObject) : field->offset;
+       
+       NEW_ICONST (cfg, offset_ins, foffset);
+       MONO_INST_NEW (cfg, ins, OP_PADD);
+       ins->inst_left = *args;
+       ins->inst_right = offset_ins;
+       ins->type = STACK_MP;
+       
+       MONO_INST_NEW (cfg, load, mono_type_to_ldind (field->type));
+       type_to_eval_stack_type (field->type, load);
+       load->inst_left = ins;
+       
+       return load;
+}
+/* 
+ *
+ * This method does a quick-and-dirty inlining of a method. It tries to find
+ * common patterns and inlines specific code sequences. This is *NOT* a
+ * general inliner.
+ * 
+ * The goal here is to inline patterns with the following properties: 
+ *	- The pattern is very commonly used 
+ *	- Inlining the pattern will NEVER increase code size
+ * 
+ * Basically, we want to get calls that we don't even have to think about the
+ * cost/benefit tradeoffs.  The methods that this routine inlines are always
+ * good choices to inline, regardless of the call site.
+ *
+ */
+
+static MonoInst*
+quick_inline_method (MonoCompile *cfg, MonoMethod *method, MonoMethodSignature *sig, MonoInst **args)
+{
+       MonoMethodHeader *header = mono_method_get_header (method);
+       MonoInst* ins;
+       
+       if ((method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) ||
+	   (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||
+	   (method->iflags & METHOD_IMPL_ATTRIBUTE_NOINLINING) ||
+	   (method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED) ||
+	   (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||
+	   (method->klass->marshalbyref) ||
+	   !header || header->num_clauses ||
+	   /* fixme: why cant we inline valuetype returns? */
+	   MONO_TYPE_ISSTRUCT (sig->ret))
+	       return NULL;
+       
+       if (header->code_size > 10 || header->num_locals)
+	       return NULL;
+       
+       if (mono_method_has_declsec (method))
+	       return NULL;
+       
+       if (!(cfg->opt & MONO_OPT_SHARED)) {
+	       MonoVTable *vtable = mono_class_vtable (cfg->domain, method->klass);
+	       if (method->klass->flags & TYPE_ATTRIBUTE_BEFORE_FIELD_INIT) {
+		       if (cfg->run_cctors)
+			       mono_runtime_class_init (vtable);
+	       }
+	       else if (!vtable->initialized && mono_class_needs_cctor_run (method->klass, NULL))
+		       return NULL;
+       } else {
+	       /* 
+		* If we're compiling for shared code
+		* the cctor will need to be run at aot method load time, for example,
+		* or at the end of the compilation of the inlining method.
+		*/
+	       if (mono_class_needs_cctor_run (method->klass, NULL) && !((method->klass->flags & TYPE_ATTRIBUTE_BEFORE_FIELD_INIT)))
+		       return NULL;
+       }
+       
+       ins = try_inline_ldfld (cfg, header, method, sig, args);
+       if (ins)
+	       return ins;
+       
+       return NULL;
+       
+}
+#endif
+
 static MonoInst*
 mini_get_inst_for_method (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **args)
 {
@@ -2957,7 +3079,21 @@
 			return ins;
 	}
 
+#if QUICKINLINE
+/* QUICKINLINE */
+	ins = mono_arch_get_inst_for_method (cfg, cmethod, fsig, args);
+	if (ins) {
+		return ins;
+	} else {
+		if (cfg->opt & MONO_OPT_INLINE) {
+			return quick_inline_method (cfg, cmethod, fsig, args);	
+		} else {
+			return NULL;
+		}
+	}
+#else
 	return mono_arch_get_inst_for_method (cfg, cmethod, fsig, args);
+#endif
 }
 
 static void
@@ -3287,6 +3423,7 @@
 	}
 }
 
+#define BRANCH_COST 100
 
 /*
  * mono_method_to_ir: translates IL into basic blocks containing trees
@@ -4363,7 +4500,7 @@
 				sp = stack_start;
 			}
 			start_new_bblock = 1;
-			inline_costs += 10;
+			inline_costs += BRANCH_COST;
 			break;
 		case CEE_BRFALSE_S:
 		case CEE_BRTRUE_S:
@@ -4378,7 +4515,7 @@
 				handle_stack_args (cfg, bblock, stack_start, sp - stack_start);
 				sp = stack_start;
 			}
-			inline_costs += 10;
+			inline_costs += BRANCH_COST;
 			break;
 		case CEE_BEQ_S:
 		case CEE_BGE_S:
@@ -4401,7 +4538,7 @@
 				handle_stack_args (cfg, bblock, stack_start, sp - stack_start);
 				sp = stack_start;
 			}
-			inline_costs += 10;
+			inline_costs += BRANCH_COST;
 			break;
 		case CEE_BR:
 			CHECK_OPSIZE (5);
@@ -4419,7 +4556,7 @@
 				sp = stack_start;
 			}
 			start_new_bblock = 1;
-			inline_costs += 10;
+			inline_costs += BRANCH_COST;
 			break;
 		case CEE_BRFALSE:
 		case CEE_BRTRUE:
@@ -4434,7 +4571,7 @@
 				handle_stack_args (cfg, bblock, stack_start, sp - stack_start);
 				sp = stack_start;
 			}
-			inline_costs += 10;
+			inline_costs += BRANCH_COST;
 			break;
 		case CEE_BEQ:
 		case CEE_BGE:
@@ -4457,7 +4594,7 @@
 				handle_stack_args (cfg, bblock, stack_start, sp - stack_start);
 				sp = stack_start;
 			}
-			inline_costs += 10;
+			inline_costs += BRANCH_COST;
 			break;
 		case CEE_SWITCH:
 			CHECK_OPSIZE (5);
@@ -4491,7 +4628,7 @@
 			}
 			/* Needed by the code generated in inssel.brg */
 			mono_get_got_var (cfg);
-			inline_costs += 20;
+			inline_costs += (BRANCH_COST * 2);
 			break;
 		case CEE_LDIND_I1:
 		case CEE_LDIND_U1:
@@ -6788,6 +6925,7 @@
 	g_slist_free (class_inits);
 	dont_inline = g_list_remove (dont_inline, method);
 	return inline_costs;
+	//return inline_costs + cfg->num_calls * 10;
 
  inline_failure:
 	if (cfg->method != method) 
@@ -8912,11 +9050,361 @@
 	mono_debug_close_method (cfg);
 }
 
-static void
-mono_cprop_copy_values (MonoCompile *cfg, MonoInst *tree, MonoInst **acp)
+
+#define MONO_DEBUG_LOCAL_PROP 0
+#define MONO_DEBUG_TREE_MOVER 0
+#define MONO_DUMP_TREE_MOVER 0
+#define MONO_APPLY_TREE_MOVER_TO_SINGLE_METHOD 0
+#define MONO_APPLY_TREE_MOVER_TO_COUNTED_METHODS 0
+
+struct MonoTreeMoverActSlot;
+typedef struct MonoTreeMoverDependencyNode {
+	struct MonoTreeMoverActSlot *used_slot;
+	struct MonoTreeMoverActSlot *affected_slot;
+	struct MonoTreeMoverDependencyNode *next_used_local;
+	struct MonoTreeMoverDependencyNode *next_affected_local;
+	struct MonoTreeMoverDependencyNode *previous_affected_local;
+	gboolean use_is_direct;
+} MonoTreeMoverDependencyNode;
+
+struct MonoTreeMoverTreeMove;
+typedef struct MonoTreeMoverAffectedMove {
+	struct MonoTreeMoverTreeMove *affected_move;
+	struct MonoTreeMoverAffectedMove *next_affected_move;
+} MonoTreeMoverAffectedMove;
+
+typedef struct MonoTreeMoverDependencyFromDeadDefinition {
+	struct MonoTreeMoverActSlot *defined_slot;
+	MonoInst *dead_definition;
+	struct MonoTreeMoverDependencyFromDeadDefinition *next;
+} MonoTreeMoverDependencyFromDeadDefinition;
+
+typedef struct MonoTreeMoverTreeMove {
+	struct MonoTreeMoverActSlot *defined_slot;
+	MonoInst *definition;
+	MonoInst **use;
+	MonoTreeMoverAffectedMove *affected_moves;
+	struct MonoTreeMoverDependencyFromDeadDefinition *slots_that_must_be_safe;
+	struct MonoTreeMoverTreeMove *next;
+	gboolean move_is_safe;
+	gboolean skip_this_move;
+} MonoTreeMoverTreeMove;
+
+typedef struct MonoTreeMoverActSlot {
+	MonoTreeMoverDependencyNode *used_locals;
+	MonoTreeMoverDependencyNode *last_used_local;
+	MonoTreeMoverDependencyNode *affected_locals;
+	MonoTreeMoverTreeMove *pending_move;
+	gboolean pending_move_is_ready;
+	gboolean waiting_flag;
+	gboolean unsafe_flag;
+	gboolean pending_move_is_forwarded;
+} MonoTreeMoverActSlot;
+
+typedef struct MonoTreeMover {
+	MonoMemPool *pool;
+	MonoCompile *cfg;
+	
+	MonoTreeMoverDependencyNode *free_nodes;
+	MonoTreeMoverTreeMove *free_moves;
+
+	MonoTreeMoverActSlot *ACT;
+	MonoTreeMoverTreeMove *scheduled_moves;
+
+
+	MonoTreeMoverDependencyNode *used_nodes;
+	MonoTreeMoverDependencyNode *last_used_node;
+	gboolean tree_has_side_effects;
+} MonoTreeMover;
+
+
+#define TREE_MOVER_NEW_NODE(__node) do {\
+	if (tree_mover->free_nodes != NULL) {\
+		(__node) = tree_mover->free_nodes;\
+		tree_mover->free_nodes = tree_mover->free_nodes->next_used_local;\
+		(__node)->next_used_local = NULL;\
+		(__node)->next_affected_local = NULL;\
+		(__node)->previous_affected_local = NULL;\
+	} else {\
+		(__node) = (MonoTreeMoverDependencyNode*) mono_mempool_alloc0 (tree_mover->pool, sizeof (MonoTreeMoverDependencyNode));\
+	}\
+} while (0)
+
+#define TREE_MOVER_NEW_MOVE(__move) do {\
+	MonoTreeMoverTreeMove *__m;\
+	if (tree_mover->free_moves != NULL) {\
+		__m = tree_mover->free_moves;\
+		tree_mover->free_moves = tree_mover->free_moves->next;\
+		memset (__m, 0, sizeof (MonoTreeMoverTreeMove));\
+	} else {\
+		__m = (MonoTreeMoverTreeMove*) mono_mempool_alloc0 (tree_mover->pool, sizeof (MonoTreeMoverTreeMove));\
+	}\
+	(__move) = __m;\
+} while (0)
+
+#define TREE_MOVER_DISPOSE_NODES(__node,__last_node) do {\
+	(__last_node)->next_used_local = tree_mover->free_nodes;\
+	tree_mover->free_nodes = (__node);\
+	(__node) = NULL;\
+	(__last_node) = NULL;\
+} while (0)
+
+#define TREE_MOVER_DISPOSE_MOVE(__move) do {\
+	(__move)->next = tree_mover->free_moves;\
+	tree_mover->free_moves = (__move);\
+	(__move) = NULL;\
+} while (0)
+
+#define TREE_MOVER_SLOT_FROM_INDEX(__index) (&(tree_mover->ACT [(__index)]))
+#define TREE_MOVER_SLOT_TO_INDEX(__slot) ((__slot)-(tree_mover->ACT))
+
+#define TREE_MOVER_ADD_USED_NODE(__slot,__use_is_direct) do {\
+	MonoTreeMoverDependencyNode *__node;\
+	TREE_MOVER_NEW_NODE (__node);\
+	__node->used_slot = (__slot);\
+	__node->affected_slot = NULL;\
+	__node->use_is_direct = __use_is_direct;\
+	if (tree_mover->last_used_node != NULL) {\
+		tree_mover->last_used_node->next_used_local = __node;\
+	} else {\
+		tree_mover->used_nodes = __node;\
+	}\
+	tree_mover->last_used_node = __node;\
+} while (0)
+
+#define TREE_MOVER_DISPOSE_USED_NODES do {\
+	if (tree_mover->last_used_node != NULL) {\
+			TREE_MOVER_DISPOSE_NODES (tree_mover->used_nodes, tree_mover->last_used_node);\
+	}\
+} while (0)
+
+#define TREE_MOVER_LINK_AFFECTING_NODE(__node,__affected_slot) do {\
+	MonoTreeMoverActSlot *__affecting_slot = (__node)->used_slot; \
+	(__node)->affected_slot = (__affected_slot);\
+	(__node)->next_affected_local = __affecting_slot->affected_locals;\
+	__affecting_slot->affected_locals = (__node);\
+	if ((__node)->next_affected_local != NULL) {\
+		(__node)->next_affected_local->previous_affected_local = (__node);\
+	}\
+	(__node)->previous_affected_local = NULL;\
+} while (0)
+
+#define TREE_MOVER_UNLINK_AFFECTING_NODE(__node) do {\
+	if ((__node)->next_affected_local != NULL) {\
+		(__node)->next_affected_local->previous_affected_local = (__node)->previous_affected_local;\
+	}\
+	if ((__node)->previous_affected_local != NULL) {\
+		(__node)->previous_affected_local->next_affected_local = (__node)->next_affected_local;\
+	} else {\
+		MonoTreeMoverActSlot *__slot = (__node)->used_slot;\
+		__slot->affected_locals = (__node)->next_affected_local;\
+	}\
+	(__node)->next_affected_local = NULL;\
+	(__node)->previous_affected_local = NULL;\
+	(__node)->affected_slot = NULL;\
+} while (0)
+
+#define TREE_MOVER_LINK_AFFECTED_MOVES(__source_slot,__destination_slot) do {\
+	MonoTreeMoverAffectedMove *__node = (MonoTreeMoverAffectedMove*) mono_mempool_alloc0 (tree_mover->pool, sizeof (MonoTreeMoverAffectedMove));\
+	__node->affected_move = (__destination_slot)->pending_move; \
+	__node->next_affected_move = (__source_slot)->pending_move->affected_moves;\
+	(__source_slot)->pending_move->affected_moves = __node;\
+} while (0)
+
+
+#define TREE_MOVER_RECORD_PENDING_MOVE(__slot,__safe) do {\
+	if ((__slot)->pending_move_is_ready) {\
+		(__slot)->pending_move->move_is_safe = (__safe);\
+		(__slot)->pending_move->next = tree_mover->scheduled_moves;\
+		tree_mover->scheduled_moves = (__slot)->pending_move;\
+		(__slot)->pending_move = NULL;\
+		(__slot)->pending_move_is_ready = FALSE;\
+	}\
+} while (0)
+
+#define TREE_MOVER_CLEAR_FORWARDING_DEPENDENCY(__slot) do {\
+	if ((__slot)->pending_move_is_forwarded) {\
+		MonoTreeMoverDependencyFromDeadDefinition *dependency = (__slot)->pending_move->slots_that_must_be_safe; \
+		while (dependency != NULL) {\
+			if (dependency->defined_slot == (__slot)) {\
+				dependency->defined_slot = NULL;\
+			}\
+			dependency = dependency->next;\
+		}\
+		(__slot)->pending_move = NULL;\
+	}\
+} while (0)
+
+#define TREE_MOVER_ENFORCE_FORWARDING_DEPENDENCY(__slot) do {\
+	if ((__slot)->pending_move_is_forwarded) {\
+		(__slot)->pending_move->skip_this_move = TRUE;\
+		(__slot)->pending_move_is_forwarded = FALSE;\
+		(__slot)->pending_move = NULL;\
+	}\
+} while (0)
+
+#define TREE_MOVER_CLEAN_ACT_SLOT_DEPENDENCY_NODES(__slot) do {\
+	MonoTreeMoverDependencyNode *__current_node = ((__slot)->used_locals); \
+	while (__current_node != NULL) {					\
+		TREE_MOVER_UNLINK_AFFECTING_NODE (__current_node);		\
+		__current_node = __current_node->next_used_local;			\
+	}								\
+	if ((__slot)->used_locals != NULL) {			\
+		TREE_MOVER_DISPOSE_NODES ((__slot)->used_locals, (__slot)->last_used_local); \
+	}								\
+} while (0)
+
+#define TREE_MOVER_CLEAN_ACT_SLOT_PENDING_MOVE(__slot) do {\
+	if ((__slot)->pending_move != NULL) {\
+		if (! (__slot)->pending_move_is_forwarded) {\
+			TREE_MOVER_DISPOSE_MOVE ((__slot)->pending_move); \
+		} else {\
+			(__slot)->pending_move = NULL;\
+		}\
+	}\
+	(__slot)->pending_move_is_ready = FALSE;\
+	(__slot)->pending_move_is_forwarded = FALSE;\
+} while (0)
+
+#define TREE_MOVER_CLEAN_ACT_SLOT(__slot) do {\
+	TREE_MOVER_CLEAN_ACT_SLOT_DEPENDENCY_NODES (__slot);\
+	TREE_MOVER_CLEAN_ACT_SLOT_PENDING_MOVE (__slot);\
+} while (0)
+
+#define TREE_MOVER_KILL_ACT_SLOT_FOR_DEFINITION(__slot) do {\
+	TREE_MOVER_RECORD_PENDING_MOVE ((__slot), TRUE);\
+	TREE_MOVER_CLEAR_FORWARDING_DEPENDENCY (__slot);\
+	TREE_MOVER_CLEAN_ACT_SLOT (__slot);\
+} while (0)
+
+#define TREE_MOVER_KILL_ACT_SLOT_BECAUSE_IT_IS_AFFECTED(__slot) do {\
+	if ((! (__slot)->pending_move_is_ready) && (! (__slot)->pending_move_is_forwarded)) {\
+		TREE_MOVER_CLEAN_ACT_SLOT (__slot);\
+	}\
+} while (0)
+
+#define TREE_MOVER_KILL_ACT_SLOT_FOR_USE(__slot) do {\
+	TREE_MOVER_ENFORCE_FORWARDING_DEPENDENCY (__slot);\
+	TREE_MOVER_CLEAN_ACT_SLOT (__slot);\
+} while (0)
+
+#define TREE_MOVER_KILL_ACT(__size) do {\
+	int __i;\
+	for (__i = 0; __i < __size; __i++) {\
+		MonoTreeMoverActSlot *__slot = &(tree_mover->ACT [__i]);\
+		TREE_MOVER_KILL_ACT_SLOT_FOR_USE (__slot);\
+	}\
+} while (0)
+
+#define TREE_MOVER_CLEAR_ACT_RECORDING_MOVES(__size) do {\
+	int __i;\
+	for (__i = 0; __i < __size; __i++) {\
+		MonoTreeMoverActSlot *__slot = &(tree_mover->ACT [__i]);\
+		TREE_MOVER_RECORD_PENDING_MOVE (__slot, FALSE);\
+		TREE_MOVER_CLEAN_ACT_SLOT (__slot);\
+	}\
+} while (0)
+
+#define TREE_MOVER_SET_WAITING_FLAGS(__size) do {\
+	int __i;\
+	for (__i = 0; __i < __size; __i++) {\
+		MonoTreeMoverActSlot *__slot = &(tree_mover->ACT [__i]);\
+		__slot->waiting_flag = TRUE;\
+	}\
+} while (0)
+
+#define TREE_MOVER_VERIFY_DEPENDENCY_NODES_ARE_CLEAR(__size) do {\
+	int __i;\
+	for (__i = 0; __i < __size; __i++) {\
+		MonoTreeMoverActSlot *__slot = &(tree_mover->ACT [__i]);\
+		if (__slot->affected_locals != NULL) {\
+			printf ("Slot %d has still affected variables\n", __i); \
+			g_assert_not_reached ();\
+		}\
+		if (__slot->used_locals != NULL) {\
+			printf ("Slot %d has still used variables\n", __i); \
+			g_assert_not_reached ();\
+		}\
+		if (__slot->last_used_local != NULL) {\
+			printf ("Slot %d has still a last used variable\n", __i); \
+			g_assert_not_reached ();\
+		}\
+	}\
+} while (0)
+
+#if 0
+static guint16 ldind_to_conv[] = {
+	CEE_CONV_I1,
+	CEE_CONV_U1,
+	CEE_CONV_I2,
+	CEE_CONV_U2,
+	CEE_CONV_I4,
+	CEE_CONV_U4,
+	CEE_CONV_I8,
+	CEE_CONV_I,
+	CEE_CONV_R4,
+	CEE_CONV_R8,
+	0
+};
+#endif
+
+static gboolean stind_needs_conversion[(CEE_STIND_R8-CEE_STIND_REF)+1][STACK_MAX] = {
+	/* INV I4    I8    PTR   R8    MP    OBJ   VTYPE */
+	{TRUE ,TRUE, TRUE, FALSE,TRUE, FALSE,FALSE,TRUE}, /* CEE_STIND_REF */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_I1  */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_I2  */
+	{TRUE ,FALSE,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_I4  */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_I8  */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_R4  */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}  /* CEE_STIND_R8  */
+};
+static gboolean stind_i_needs_conversion[STACK_MAX] = {TRUE ,TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE};
+static gboolean ldind_needs_conversion[(CEE_LDIND_REF-CEE_LDIND_I1)+1][STACK_MAX] = {
+	/* INV I4    I8    PTR   R8    MP    OBJ   VTYPE */
+	{TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_I1  */
+	{TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_U1  */
+	{TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_I2  */
+	{TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_U2  */
+	{TRUE, FALSE,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_I4  */
+	{TRUE, FALSE,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_U4  */
+	{TRUE, TRUE, FALSE,TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_I8  */
+	{TRUE, TRUE, TRUE, FALSE,TRUE, FALSE,FALSE,TRUE}, /* CEE_LDIND_I   */
+	{TRUE, TRUE, TRUE, FALSE,TRUE, FALSE,FALSE,TRUE}, /* CEE_LDIND_R4  */
+	{TRUE, TRUE, TRUE, FALSE,TRUE, FALSE,FALSE,TRUE}, /* CEE_LDIND_R8  */
+	{TRUE, FALSE,FALSE,FALSE,FALSE,FALSE,TRUE, TRUE}  /* CEE_LDIND_REF */
+};
+
+#define TREE_MOVER_LDIND_TO_CONV(__opcode) (ldind_to_conv [(__opcode)-CEE_LDIND_I1])
+#define TREE_MOVER_STIND_NEEDS_CONVERSION(__opcode,__type) (((__opcode)!=CEE_STIND_I)?(stind_needs_conversion [(__opcode)-CEE_STIND_REF][(__type)]):(stind_i_needs_conversion [(__type)]))
+#define TREE_MOVER_LDIND_NEEDS_CONVERSION(__opcode,__type) (ldind_needs_conversion [(__opcode)-CEE_LDIND_I1][(__type)])
+
+#if MONO_DUMP_TREE_MOVER
+static void
+tree_mover_print_act_slot (const char* message, MonoTreeMover *tree_mover, MonoTreeMoverActSlot *slot) {
+	MonoTreeMoverDependencyNode *node;
+	printf ("  [%s] Slot %d uses {", message, TREE_MOVER_SLOT_TO_INDEX (slot));
+	for (node = slot->used_locals; node != NULL; node = node->next_used_local) {
+		printf (" %d", TREE_MOVER_SLOT_TO_INDEX (node->used_slot));
+	}
+	printf (" } affects {");
+	for (node = slot->affected_locals; node != NULL; node = node->next_affected_local) {
+		printf (" %d", TREE_MOVER_SLOT_TO_INDEX (node->affected_slot));
+	}
+	printf (" } R%d F%d W%d U%d", slot->pending_move_is_ready, slot->pending_move_is_forwarded, slot->waiting_flag, slot->unsafe_flag);
+	if (slot->pending_move != NULL) {
+		printf (" DEFINITION:");
+		mono_print_tree (slot->pending_move->definition);
+	}
+	printf ("\n");
+}
+#endif
+
+static MonoTreeMoverTreeMove*
+mono_cprop_copy_values (MonoCompile *cfg, MonoTreeMover *tree_mover, MonoInst *tree, MonoInst **acp)
 {
 	MonoInst *cp;
 	int arity;
+	MonoTreeMoverTreeMove *pending_move = NULL;
 
 	if (tree->ssa_op == MONO_SSA_LOAD && (tree->inst_i0->opcode == OP_LOCAL || tree->inst_i0->opcode == OP_ARG) && 
 	    (cp = acp [tree->inst_i0->inst_c0]) && !tree->inst_i0->flags) {
@@ -8924,36 +9412,149 @@
 		if (cp->opcode == OP_ICONST) {
 			if (cfg->opt & MONO_OPT_CONSPROP) {
 				//{ static int c = 0; printf ("CCOPY %d %d %s\n", c++, cp->inst_c0, mono_method_full_name (cfg->method, TRUE)); }
+#if MONO_DEBUG_LOCAL_PROP
+				printf ("Propagating constant, tree ");
+				mono_print_tree (tree);
+				printf (" becomes ");
+				mono_print_tree (cp);
+				printf ("\n");
+#endif
 				*tree = *cp;
 			}
 		} else {
-			if (tree->inst_i0->inst_vtype->type == cp->inst_vtype->type) {
+			if ((tree->inst_i0->inst_vtype->type == cp->inst_vtype->type) ||
+					(tree->type == STACK_OBJ)) {
 				if (cfg->opt & MONO_OPT_COPYPROP) {
 					//{ static int c = 0; printf ("VCOPY %d\n", ++c); }
+#if MONO_DEBUG_LOCAL_PROP
+					printf ("Propagating value, tree->inst_i0 ");
+					mono_print_tree (tree->inst_i0);
+					printf (" becomes ");
+					mono_print_tree (cp);
+					printf ("\n");
+#endif
 					tree->inst_i0 = cp;
 				} 
 			}
+#if MONO_DEBUG_LOCAL_PROP
+			else {
+				printf ("Values of tree->inst_i0 ");
+				mono_print_tree (tree->inst_i0);
+				printf (" and cp ");
+				mono_print_tree (cp);
+				printf (" have incompatible types in tree ");
+				mono_print_tree (tree);
+				printf ("\n");
+			}
+#endif
 		} 
 	} else {
+#if MONO_DEBUG_LOCAL_PROP
+		printf ("Propagation SKIPPED for inst ");
+		mono_print_tree (tree);
+		printf ("\n");
+#endif
 		arity = mono_burg_arity [tree->opcode];
 
 		if (arity) {
-			mono_cprop_copy_values (cfg, tree->inst_i0, acp);
+			MonoTreeMoverTreeMove *result = mono_cprop_copy_values (cfg, tree_mover, tree->inst_i0, acp);
+			if (result != NULL)
+				result->use = &(tree->inst_i0);
 			if (cfg->opt & MONO_OPT_CFOLD)
 				mono_constant_fold_inst (tree, NULL); 
 			/* The opcode may have changed */
 			if (mono_burg_arity [tree->opcode] > 1) {
-				mono_cprop_copy_values (cfg, tree->inst_i1, acp);
+				result = mono_cprop_copy_values (cfg, tree_mover, tree->inst_i1, acp);
+				if (result != NULL)
+					result->use = &(tree->inst_i1);
 				if (cfg->opt & MONO_OPT_CFOLD)
 					mono_constant_fold_inst (tree, NULL); 
 			}
 			mono_constant_fold_inst (tree, NULL); 
 		}
 	}
+	
+	/* Apply the tree mover after after propagation has been done */
+	if ((tree_mover != NULL) && (tree->ssa_op == MONO_SSA_LOAD) &&
+			(tree->inst_i0->opcode == OP_LOCAL || tree->inst_i0->opcode == OP_ARG)) {
+		guint used_index = tree->inst_i0->inst_c0;
+		MonoTreeMoverActSlot *used_slot = &(tree_mover->ACT [used_index]);
+		
+		/* First, handle waiting flag */
+		if (used_slot->waiting_flag) {
+			used_slot->unsafe_flag = TRUE;
+			used_slot->waiting_flag = FALSE;
+		}
+
+		if (!tree->inst_i0->flags) {
+			/* Record local use (the tree that contains this use might be movable) */
+			TREE_MOVER_ADD_USED_NODE (used_slot, TRUE);
+
+			/* Start working on the pending move... */
+			pending_move = used_slot->pending_move;
+
+			/* If there *is* a pending move... (otherwise, do nothing) */
+			if (pending_move != NULL) {
+				/* Check slot state */
+				if (used_slot->pending_move_is_forwarded) {
+					/* If the slot was a "hopefully dead" definition because of a forwarding... */
+# if MONO_DEBUG_TREE_MOVER
+					printf ("Use should have been dead, killing slot %d: ", used_index);
+					mono_print_tree_nl (tree);
+					printf ("Also disabling forwarded definition at slot %d: ", TREE_MOVER_SLOT_TO_INDEX (pending_move->defined_slot));
+					mono_print_tree_nl (pending_move->definition);
+#endif
+					/* ...clear the slot (which also disables the forwarded definition), and... */
+					TREE_MOVER_KILL_ACT_SLOT_FOR_USE (used_slot);
+					/* ...clear the pending_move */
+					pending_move = NULL;
+				} else if (used_slot->pending_move_is_ready ||
+				    TREE_MOVER_STIND_NEEDS_CONVERSION (pending_move->definition->opcode, pending_move->definition->inst_i1->type) ||
+				    TREE_MOVER_LDIND_NEEDS_CONVERSION (tree->opcode, pending_move->definition->inst_i1->type)) {
+					/* If the move was already in state [U], or if there are type problems... */
+# if MONO_DEBUG_TREE_MOVER
+					printf ("Definition has too many, wrong or misplaced uses, killing slot %d: ", used_index);
+					mono_print_tree_nl (tree);
+#endif
+					/* ...kill it, and clear the pending_move */
+					TREE_MOVER_KILL_ACT_SLOT_FOR_USE (used_slot);
+					pending_move = NULL;
+				} else {
+					/* All goes well: set slot state to [U] */
+					MonoTreeMoverDependencyNode *node = used_slot->used_locals;
+# if MONO_DEBUG_TREE_MOVER
+					printf ("Setting tree move for slot %d as ready: ", used_index);
+					mono_print_tree_nl (tree);
+#endif
+					/* Record indirect uses generated by this move */
+					while (node != NULL) {
+						TREE_MOVER_ADD_USED_NODE (node->used_slot, FALSE);
+						node = node->next_used_local;
+					}
+
+					/* Setup tree as movable */
+					used_slot->pending_move_is_ready = TRUE;
+				}
+			}
+		} else {
+# if MONO_DEBUG_TREE_MOVER
+			printf ("Tree has side effects, killing slot %d: ", used_index);
+			mono_print_tree_nl (tree);
+#endif
+			/* The whole tree is unmovable (it uses a flagged local) */
+			tree_mover->tree_has_side_effects = TRUE;
+			/* Moreover, the use of a flagged local kills the definition */
+			TREE_MOVER_KILL_ACT_SLOT_FOR_USE (used_slot);
+		}
+#if MONO_DUMP_TREE_MOVER
+		tree_mover_print_act_slot ("USE", tree_mover, used_slot);
+#endif
+	}	
+	return pending_move;
 }
 
 static void
-mono_cprop_invalidate_values (MonoInst *tree, MonoInst **acp, int acp_size)
+mono_cprop_invalidate_values (MonoInst *tree, MonoTreeMover *tree_mover, MonoInst **acp, int acp_size)
 {
 	int arity;
 
@@ -8968,7 +9569,21 @@
 	case CEE_STIND_R8:
 	case CEE_STOBJ:
 		if ((tree->ssa_op == MONO_SSA_NOP) || (tree->ssa_op & MONO_SSA_ADDRESS_TAKEN)) {
+#if MONO_DEBUG_LOCAL_PROP
+			printf ("Indirect store clears ACP at tree ");
+			mono_print_tree (tree);
+			printf ("\n");
+#endif
 			memset (acp, 0, sizeof (MonoInst *) * acp_size);
+			if (tree_mover != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+				printf ("Killing all active slots (and recording side effect) because of inst ");
+				mono_print_tree_nl (tree);
+#endif
+				/* Well, actually we should *not* dispose ready moves (state [U]) */
+				TREE_MOVER_KILL_ACT (acp_size);
+				tree_mover->tree_has_side_effects = TRUE;
+			}
 			return;
 		}
 
@@ -8992,6 +9607,14 @@
 		MonoMethodSignature *sig = call->signature;
 		int i, byref = FALSE;
 
+		if (tree_mover != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+			printf ("Recording side effect because of inst ");
+			mono_print_tree_nl (tree);
+#endif
+			tree_mover->tree_has_side_effects = TRUE;
+		}
+
 		for (i = 0; i < sig->param_count; i++) {
 			if (sig->params [i]->byref) {
 				byref = TRUE;
@@ -8999,9 +9622,21 @@
 			}
 		}
 
-		if (byref)
+		if (byref) {
+#if MONO_DEBUG_LOCAL_PROP
+			printf ("Call with byref parameter clears ACP at tree ");
+			mono_print_tree (tree);
+			printf ("\n");
+#endif
 			memset (acp, 0, sizeof (MonoInst *) * acp_size);
-
+			if (tree_mover != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+				printf ("Killing all active slots because of inst ");
+				mono_print_tree_nl (tree);
+#endif
+				TREE_MOVER_KILL_ACT (acp_size);
+			}
+		}
 		return;
 	}
 	default:
@@ -9014,11 +9649,11 @@
 	case 0:
 		break;
 	case 1:
-		mono_cprop_invalidate_values (tree->inst_i0, acp, acp_size);
+		mono_cprop_invalidate_values (tree->inst_i0, tree_mover, acp, acp_size);
 		break;
 	case 2:
-		mono_cprop_invalidate_values (tree->inst_i0, acp, acp_size);
-		mono_cprop_invalidate_values (tree->inst_i1, acp, acp_size);
+		mono_cprop_invalidate_values (tree->inst_i0, tree_mover, acp, acp_size);
+		mono_cprop_invalidate_values (tree->inst_i1, tree_mover, acp, acp_size);
 		break;
 	default:
 		g_assert_not_reached ();
@@ -9026,7 +9661,7 @@
 }
 
 static void
-mono_local_cprop_bb (MonoCompile *cfg, MonoBasicBlock *bb, MonoInst **acp, int acp_size)
+mono_local_cprop_bb (MonoCompile *cfg, MonoTreeMover *tree_mover, MonoBasicBlock *bb, MonoInst **acp, int acp_size)
 {
 	MonoInst *tree = bb->code;	
 	int i;
@@ -9034,35 +9669,199 @@
 	if (!tree)
 		return;
 
+	if (tree_mover != NULL) {
+		TREE_MOVER_SET_WAITING_FLAGS (acp_size);
+# if MONO_DEBUG_TREE_MOVER
+		printf ("Running tree mover on BB%d\n", bb->block_num);
+#endif
+	}
 	for (; tree; tree = tree->next) {
+		if (tree_mover != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+			printf ("Running tree mover on tree ");
+			mono_print_tree_nl (tree);
+#endif
+			tree_mover->tree_has_side_effects = FALSE;
+		}
 
-		mono_cprop_copy_values (cfg, tree, acp);
+		mono_cprop_copy_values (cfg, tree_mover, tree, acp);
+		mono_cprop_invalidate_values (tree, tree_mover, acp, acp_size);
+# if MONO_DEBUG_TREE_MOVER
+		if (tree_mover != NULL) {
+			printf ("After the tree walk, tree_mover->tree_has_side_effects is %d\n", tree_mover->tree_has_side_effects);
+		}
+#endif
 
-		mono_cprop_invalidate_values (tree, acp, acp_size);
 
 		if (tree->ssa_op == MONO_SSA_STORE  && 
 		    (tree->inst_i0->opcode == OP_LOCAL || tree->inst_i0->opcode == OP_ARG)) {
 			MonoInst *i1 = tree->inst_i1;
+			MonoTreeMoverActSlot *forwarding_source = NULL;
+			gboolean tree_can_be_moved = TRUE;
 
 			acp [tree->inst_i0->inst_c0] = NULL;
+#if MONO_DEBUG_LOCAL_PROP
+			printf ("Assignment clears ACP[%d] at tree ", tree->inst_i0->inst_c0);
+			mono_print_tree (tree);
+			printf ("\n");
+#endif
 
 			for (i = 0; i < acp_size; i++) {
 				if (acp [i] && acp [i]->opcode != OP_ICONST && 
 				    acp [i]->inst_c0 == tree->inst_i0->inst_c0) {
 					acp [i] = NULL;
+#if MONO_DEBUG_LOCAL_PROP
+					printf ("  Consequently, ACP[%d] is cleared\n", i);
+#endif
 				}
 			}
 
 			if (i1->opcode == OP_ICONST) {
 				acp [tree->inst_i0->inst_c0] = i1;
+				tree_can_be_moved = FALSE;
+#if MONO_DEBUG_LOCAL_PROP
+				printf ("  Consequently, ACP[%d] becomes constant ", tree->inst_i0->inst_c0);
+				mono_print_tree (i1);
+				printf ("\n");
+#endif
 				//printf ("DEF1 BB%d %d\n", bb->block_num,tree->inst_i0->inst_c0);
 			}
 			if (i1->ssa_op == MONO_SSA_LOAD && 
 			    (i1->inst_i0->opcode == OP_LOCAL || i1->inst_i0->opcode == OP_ARG) &&
 			    (i1->inst_i0->inst_c0 != tree->inst_i0->inst_c0)) {
 				acp [tree->inst_i0->inst_c0] = i1->inst_i0;
+				tree_can_be_moved = FALSE;
+#if MONO_DEBUG_LOCAL_PROP
+				printf ("  Consequently, ACP[%d] becomes local ", tree->inst_i0->inst_c0);
+				mono_print_tree (i1->inst_i0);
+				printf ("\n");
+#endif
+				if (tree_mover != NULL) {
+					/* Examine the variable *used* in this definition (the "source") */
+					forwarding_source = TREE_MOVER_SLOT_FROM_INDEX (i1->inst_i0->inst_c0);
+					/* Check if source slot is ready to be forwarded */
+					if (! forwarding_source->pending_move_is_ready) {
+						/* no forwarding is possible, do nothing */
+						forwarding_source = NULL;
+					}
+				}
 				//printf ("DEF2 BB%d %d %d\n", bb->block_num,tree->inst_i0->inst_c0,i1->inst_i0->inst_c0);
 			}
+			
+			/* Apply tree mover */
+			if (tree_mover != NULL) {
+				guint defined_index = tree->inst_i0->inst_c0;
+				MonoTreeMoverActSlot *defined_slot = TREE_MOVER_SLOT_FROM_INDEX (defined_index);
+				MonoTreeMoverDependencyNode *affected_node;
+				
+				/* First clear the waiting flag... */
+				defined_slot->waiting_flag = FALSE;
+				/* ...and kill this slot (but recording any pending move)*/
+				TREE_MOVER_KILL_ACT_SLOT_FOR_DEFINITION (defined_slot);
+# if MONO_DEBUG_TREE_MOVER
+				printf ("Definition is clearing slot %d\n", defined_index);
+#endif
+
+				/* Handle "used" nodes... */
+				/* Check if this is a forwarding */
+				if (forwarding_source == NULL) {
+					/* Normal case, no forwarding: */
+					/* Check that consprop or copyprop did not already do the job, */
+					/* and that the tree has no side effects */
+					if (tree_can_be_moved && ! tree_mover->tree_has_side_effects) {
+						MonoTreeMoverDependencyNode *affecting_node;
+# if MONO_DEBUG_TREE_MOVER
+						printf ("Recording definition of slot %d by tree: ", defined_index);
+						mono_print_tree_nl (tree);
+#endif
+
+						/* Then apply the definition */
+						TREE_MOVER_NEW_MOVE (defined_slot->pending_move);
+						defined_slot->pending_move->definition = tree;
+						defined_slot->pending_move->defined_slot = defined_slot;
+
+						/* Setup "used nodes" list */
+						defined_slot->used_locals = tree_mover->used_nodes;
+						defined_slot->last_used_local = tree_mover->last_used_node;
+						tree_mover->used_nodes = NULL;
+						tree_mover->last_used_node = NULL;
+						/* Link used nodes to "affecting" slots (so affected variables are linked) */
+						/* This is needed *now* so that circular definitions are detected */
+						for (affecting_node = defined_slot->used_locals; affecting_node != NULL; affecting_node = affecting_node->next_used_local) {
+							TREE_MOVER_LINK_AFFECTING_NODE (affecting_node, defined_slot);
+						}
+					}
+					/* otherwise, do nothing */
+# if MONO_DEBUG_TREE_MOVER
+					else {
+						printf ("Skipping definition of slot %d by tree: ", defined_index);
+						mono_print_tree_nl (tree);
+					}
+#endif
+				} else {
+					MonoTreeMoverDependencyFromDeadDefinition *dependency;
+					/* forwarding previous definition: */
+# if MONO_DEBUG_TREE_MOVER
+					printf ("Handling forwarding in slot %d for tree: ", defined_index);
+					mono_print_tree_nl (tree);
+#endif
+					/* Setup slot for forwarding */
+					defined_slot->pending_move = forwarding_source->pending_move;
+					defined_slot->pending_move_is_forwarded = TRUE;
+					/* Setup forwarding dependency node */
+					dependency = mono_mempool_alloc0 (tree_mover->pool, sizeof (MonoTreeMoverDependencyFromDeadDefinition));
+					dependency->defined_slot = defined_slot;
+					dependency->dead_definition = defined_slot->pending_move->definition;
+					dependency->next = defined_slot->pending_move->slots_that_must_be_safe;
+					defined_slot->pending_move->slots_that_must_be_safe = dependency;
+					/* Clear use (put slot back to state [D]) */
+					defined_slot->pending_move->use = NULL;
+					defined_slot->pending_move->defined_slot->pending_move_is_ready = FALSE;
+				}
+
+				/* Then kill all affected definitions waiting for a use */
+				affected_node = defined_slot->affected_locals;
+				while (affected_node != NULL) {
+					MonoTreeMoverDependencyNode *next_affected_node = affected_node->next_affected_local;
+					MonoTreeMoverActSlot *affected_slot = affected_node->affected_slot;
+					
+					if (affected_node->use_is_direct) {
+						/* Direct use: kill affected slot */
+# if MONO_DEBUG_TREE_MOVER
+						printf ("  Direct use, killing slot %d with definition:", TREE_MOVER_SLOT_TO_INDEX (affected_node->affected_slot));
+						mono_print_tree_nl (affected_slot->pending_move->definition);
+						
+# endif
+						TREE_MOVER_KILL_ACT_SLOT_BECAUSE_IT_IS_AFFECTED (affected_slot);
+					} else if ((defined_slot->pending_move!= NULL) &&
+						   (! defined_slot->pending_move_is_ready) &&
+						   (! defined_slot->pending_move_is_forwarded) &&
+						   (affected_slot->pending_move!= NULL) &&
+						   (! affected_slot->pending_move_is_ready) &&
+						   (! affected_slot->pending_move_is_forwarded)) {
+# if MONO_DEBUG_TREE_MOVER
+						printf ("  Indirect use, linking slots %d and %d\n", TREE_MOVER_SLOT_TO_INDEX (affected_node->used_slot), TREE_MOVER_SLOT_TO_INDEX (affected_node->affected_slot));
+#endif
+						TREE_MOVER_LINK_AFFECTED_MOVES (defined_slot, affected_slot);
+						TREE_MOVER_LINK_AFFECTED_MOVES (affected_slot, defined_slot);
+					}
+					TREE_MOVER_UNLINK_AFFECTING_NODE (affected_node);
+					
+					if ((next_affected_node != NULL) && (next_affected_node->affected_slot != NULL)) {
+						affected_node = next_affected_node;
+					} else {
+						affected_node = defined_slot->affected_locals;
+					}
+				}
+#if MONO_DUMP_TREE_MOVER
+				tree_mover_print_act_slot ("DEFINITION", tree_mover, defined_slot);
+#endif
+			}
+		}
+
+		/* After we are done with this tree, clear the tree mover area */
+		if ((tree_mover != NULL) && (tree_mover->used_nodes != NULL)) {
+			TREE_MOVER_DISPOSE_NODES (tree_mover->used_nodes, tree_mover->last_used_node);
 		}
 
 		/*
@@ -9081,19 +9880,191 @@
 		  }
 		*/
 	}
+	
+	if (tree_mover != NULL) {
+		/* At BB end, kill all definitions still waiting for a use */
+		TREE_MOVER_CLEAR_ACT_RECORDING_MOVES (acp_size);
+#if MONO_DEBUG_TREE_MOVER
+		TREE_MOVER_VERIFY_DEPENDENCY_NODES_ARE_CLEAR (acp_size);
+#endif
+	}
+}
+
+
+#if (MONO_APPLY_TREE_MOVER_TO_SINGLE_METHOD)
+static char*
+mono_tree_mover_method_name = NULL;
+static gboolean check_tree_mover_method_name (MonoCompile *cfg) {
+	if (mono_tree_mover_method_name == NULL) {
+		mono_tree_mover_method_name = getenv ("MONO_TREE_MOVER_METHOD_NAME");
+	}
+	if (mono_tree_mover_method_name != NULL) {
+		char *method_name = mono_method_full_name (cfg->method, TRUE);
+		if (strstr (method_name, mono_tree_mover_method_name) != NULL) {
+			g_free (method_name);
+			return TRUE;
+		} else {
+			g_free (method_name);
+			return FALSE;
+		}
+	} else {
+		return TRUE;
+	}
+}
+#endif
+
+#if (MONO_APPLY_TREE_MOVER_TO_COUNTED_METHODS)
+static int
+mono_tree_mover_method_limit = -1;
+static int
+mono_tree_mover_method_count = 0;
+static gboolean check_tree_mover_method_count (MonoCompile *cfg) {
+	if (mono_tree_mover_method_limit == -1) {
+		char *limit_string = getenv ("MONO_TREE_MOVER_METHOD_LIMIT");
+		if (limit_string != NULL) {
+			mono_tree_mover_method_limit = atoi (limit_string);
+		} else {
+			mono_tree_mover_method_limit = -2;
+		}
+	}
+	if (mono_tree_mover_method_limit > -1) {
+		mono_tree_mover_method_count ++;
+		if (mono_tree_mover_method_count == mono_tree_mover_method_limit) {
+			char *method_name = mono_method_full_name (cfg->method, TRUE);
+			printf ("Last method compiled with treeprop: %s\n", method_name);
+			g_free (method_name);
+			
+		}
+		return (mono_tree_mover_method_count <= mono_tree_mover_method_limit);
+	} else {
+		return TRUE;
+	}
+}
+#endif
+
+static void
+apply_tree_mover (MonoTreeMover *tree_mover, MonoTreeMoverTreeMove *move) {
+	MonoTreeMoverDependencyFromDeadDefinition *dependency;
+	MonoTreeMoverAffectedMove *affected_move;
+
+	/* Test if this move has been explicitly disabled */
+	if (move->skip_this_move) {
+# if MONO_DEBUG_TREE_MOVER
+		printf ("Move of slot %d must be skipped: ", TREE_MOVER_SLOT_TO_INDEX (move->defined_slot));
+		mono_print_tree_nl (move->definition);
+#endif
+		return;
+	}
+	/* Test if this move is safe */
+	if ((! move->move_is_safe) && move->defined_slot->unsafe_flag) {
+# if MONO_DEBUG_TREE_MOVER
+		printf ("Move of slot %d is unsafe: ", TREE_MOVER_SLOT_TO_INDEX (move->defined_slot));
+		mono_print_tree_nl (move->definition);
+#endif
+		return;
+	}
+	/* Test if this move depends from a definition that should have been dead */
+	for (dependency = move->slots_that_must_be_safe; dependency != NULL; dependency = dependency->next) {
+		if ((dependency->defined_slot != NULL) && dependency->defined_slot->unsafe_flag) {
+# if MONO_DEBUG_TREE_MOVER
+			printf ("Move of slot %d depended from unsafe slot %d: ", TREE_MOVER_SLOT_TO_INDEX (move->defined_slot), TREE_MOVER_SLOT_TO_INDEX (dependency->defined_slot));
+			mono_print_tree_nl (move->definition);
+#endif
+			return;
+		}
+	}
+
+# if MONO_DEBUG_TREE_MOVER
+	printf ("Performing move of slot %d: ", TREE_MOVER_SLOT_TO_INDEX (move->defined_slot));
+	mono_print_tree_nl (move->definition);
+#endif
+	/* All tests passed, apply move */
+	*(move->use) = move->definition->inst_i1;
+	move->definition->opcode = CEE_NOP;
+	move->definition->ssa_op = MONO_SSA_NOP;
+
+	/* Then disable moves affected by this move */
+	affected_move = move->affected_moves;
+	while (affected_move != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+		printf ("  Consequently, disabling slot %d\n", TREE_MOVER_SLOT_TO_INDEX (affected_move->affected_move->defined_slot));
+#endif
+		affected_move->affected_move->skip_this_move = TRUE;
+		affected_move = affected_move->next_affected_move;
+	}
+
+	/* Also kill dead dependency definitions */
+	for (dependency = move->slots_that_must_be_safe; dependency != NULL; dependency = dependency->next) {
+		if (dependency->defined_slot != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+			printf ("  Consequently, kill dependent definition %d: ", TREE_MOVER_SLOT_TO_INDEX (dependency->defined_slot));
+			mono_print_tree_nl (dependency->dead_definition);
+#endif
+			dependency->dead_definition->opcode = CEE_NOP;
+			dependency->dead_definition->ssa_op = MONO_SSA_NOP;
+		}
+	}
 }
 
 static void
-mono_local_cprop (MonoCompile *cfg)
-{
+mono_local_cprop (MonoCompile *cfg) {
 	MonoBasicBlock *bb;
 	MonoInst **acp;
+	MonoTreeMover *tree_mover;
 
 	acp = alloca (sizeof (MonoInst *) * cfg->num_varinfo);
 
+	if (cfg->opt & MONO_OPT_TREEPROP) {
+		MonoMemPool *pool = mono_mempool_new();
+		tree_mover = mono_mempool_alloc0(pool, sizeof (MonoTreeMover));
+		
+		tree_mover->cfg = cfg;
+		tree_mover->pool = pool;
+		tree_mover->ACT = mono_mempool_alloc0 (pool, sizeof (MonoTreeMoverActSlot) * (cfg->num_varinfo));		
+#if (MONO_APPLY_TREE_MOVER_TO_SINGLE_METHOD)
+		if (! check_tree_mover_method_name (cfg)) {
+			mono_mempool_destroy(tree_mover->pool);
+			tree_mover = NULL;
+		}
+#endif
+#if (MONO_APPLY_TREE_MOVER_TO_COUNTED_METHODS)
+		if (! check_tree_mover_method_count (cfg)) {
+			mono_mempool_destroy(tree_mover->pool);
+			tree_mover = NULL;
+		}
+#endif
+	} else {
+		tree_mover = NULL;
+	}
+
 	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
+#if MONO_DEBUG_LOCAL_PROP
+		printf ("Applying mono_local_cprop to BB%d\n", bb->block_num);
+#endif
 		memset (acp, 0, sizeof (MonoInst *) * cfg->num_varinfo);
-		mono_local_cprop_bb (cfg, bb, acp, cfg->num_varinfo);
+		mono_local_cprop_bb (cfg, tree_mover, bb, acp, cfg->num_varinfo);
+	}
+	
+	if (tree_mover != NULL) {
+		MonoTreeMoverTreeMove *move;
+		/* Move the movable trees */
+# if MONO_DEBUG_TREE_MOVER
+		printf ("BEFORE TREE MOVER START\n");
+		mono_print_code (cfg);
+		printf ("BEFORE TREE MOVER END\n");
+		printf ("Applying tree mover...\n");
+#endif
+		for (move = tree_mover->scheduled_moves; move != NULL; move = move->next) {
+			apply_tree_mover (tree_mover, move);
+		}
+# if MONO_DEBUG_TREE_MOVER
+		printf ("AFTER TREE MOVER START\n");
+		mono_print_code (cfg);
+		printf ("AFTER TREE MOVER END\n");
+#endif
+		
+		/* Global cleanup of tree mover memory */
+		mono_mempool_destroy(tree_mover->pool);
 	}
 }
 
@@ -9358,6 +10329,13 @@
 	if (parts == 2)
 		return cfg;
 
+
+	if (cfg->verbose_level > 6) {
+		printf ("Before (CONS|COPY|TREE)PROP start:\n");
+		mono_print_code (cfg);
+		printf ("Before (CONS|COPY|TREE)PROP end.\n");
+	}
+
 	if ((cfg->opt & MONO_OPT_CONSPROP) || (cfg->opt & MONO_OPT_COPYPROP)) {
 		if (cfg->comp_done & MONO_COMP_SSA) {
 			mono_ssa_cprop (cfg);
@@ -9366,6 +10344,12 @@
 		}
 	}
 
+	if (cfg->verbose_level > 6) {
+		printf ("After (CONS|COPY|TREE)PROP start:\n");
+		mono_print_code (cfg);
+		printf ("After (CONS|COPY|TREE)PROP end.\n");
+	}
+
 	if (cfg->comp_done & MONO_COMP_SSA) {			
 		//mono_ssa_deadce (cfg);
 
Index: mono/mono/mini/mini.h
===================================================================
--- mono/mono/mini/mini.h	(revision 55928)
+++ mono/mono/mini/mini.h	(working copy)
@@ -506,7 +506,8 @@
 	MONO_OPT_ABCREM   = 1 << 18,
 	MONO_OPT_SSAPRE   = 1 << 19,
 	MONO_OPT_EXCEPTION= 1 << 20,
-	MONO_OPT_SSA      = 1 << 21
+	MONO_OPT_SSA      = 1 << 21,
+	MONO_OPT_TREEPROP = 1 << 22
 };
 
 /* Bit-fields in the MonoBasicBlock.region */
@@ -600,6 +601,7 @@
 #ifdef __ia64
 	guint8           ins, locals, outs; /* reg stack region sizes */
 #endif /* __ia64 */
+	int		num_calls;
 } MonoCompile;
 
 typedef enum {
Index: mono/mono/mini/driver.c
===================================================================
--- mono/mono/mini/driver.c	(revision 55928)
+++ mono/mono/mini/driver.c	(working copy)
@@ -87,12 +87,18 @@
 	{"abcrem",     "Array bound checks removal"},	
 	{"ssapre",     "SSA based Partial Redundancy Elimination"},
 	{"exception",  "Optimize exception catch blocks"},
-	{"ssa",        "Build and use SSA form"}
+	{"ssa",        "Use plain SSA form"},
+	{"treeprop",   "Tree propagation"}
 };
 
 #define DEFAULT_OPTIMIZATIONS (	\
 	MONO_OPT_PEEPHOLE |	\
 	MONO_OPT_CFOLD |	\
+	MONO_OPT_INLINE |	\
+	MONO_OPT_CONSPROP |	\
+	MONO_OPT_COPYPROP |	\
+	MONO_OPT_TREEPROP |	\
+	MONO_OPT_DEADCE |	\
 	MONO_OPT_BRANCH |	\
 	MONO_OPT_LINEARS |	\
 	MONO_OPT_INTRINS |  \
@@ -241,6 +247,7 @@
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_ABCREM,
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_ABCREM | MONO_OPT_SSAPRE,
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_ABCREM,
+       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_TREEPROP,
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_SSAPRE,
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_ABCREM | MONO_OPT_SHARED
 };
