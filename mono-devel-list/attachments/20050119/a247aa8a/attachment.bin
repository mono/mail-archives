Index: domain.c
===================================================================
--- domain.c	(revisión: 39129)
+++ domain.c	(copia de trabajo)
@@ -284,7 +284,9 @@
 	domain->code_mp = mono_code_manager_new ();
 	domain->env = mono_g_hash_table_new ((GHashFunc)mono_string_hash, (GCompareFunc)mono_string_equal);
 	domain->assemblies_by_name = g_hash_table_new (g_str_hash, g_str_equal);
+	domain->assemblies_refonly_by_name = g_hash_table_new (g_str_hash, g_str_equal);
 	domain->assemblies = NULL;
+	domain->assemblies_refonly = NULL;
 	domain->class_vtable_hash = g_hash_table_new (NULL, NULL);
 	domain->proxy_vtable_hash = mono_g_hash_table_new ((GHashFunc)mono_string_hash, (GCompareFunc)mono_string_equal);
 	domain->static_data_hash = mono_g_hash_table_new (NULL, NULL);
@@ -781,10 +783,13 @@
 	
 	g_free (domain->friendly_name);
 	g_hash_table_foreach (domain->assemblies_by_name, remove_assembly, NULL);
+	g_hash_table_foreach (domain->assemblies_refonly_by_name, remove_assembly, NULL);
 
 	mono_g_hash_table_destroy (domain->env);
 	g_hash_table_destroy (domain->assemblies_by_name);
+	g_hash_table_destroy (domain->assemblies_refonly_by_name);
 	g_list_free (domain->assemblies);
+	g_list_free (domain->assemblies_refonly);
 	g_hash_table_destroy (domain->class_vtable_hash);
 	mono_g_hash_table_destroy (domain->proxy_vtable_hash);
 	mono_g_hash_table_destroy (domain->static_data_hash);
Index: appdomain.c
===================================================================
--- appdomain.c	(revisión: 39129)
+++ appdomain.c	(copia de trabajo)
@@ -46,6 +46,10 @@
 mono_domain_assembly_search (MonoAssemblyName *aname,
 							 gpointer user_data);
 
+static MonoAssembly *
+mono_domain_assembly_refonly_search (MonoAssemblyName *aname,
+							 gpointer user_data);
+
 static void
 mono_domain_fire_assembly_load (MonoAssembly *assembly, gpointer user_data);
 
@@ -80,8 +84,10 @@
 	mono_thread_pool_init ();
 	mono_marshal_init ();
 
-	mono_install_assembly_preload_hook (mono_domain_assembly_preload, NULL);
-	mono_install_assembly_search_hook (mono_domain_assembly_search, NULL);
+	mono_install_assembly_preload_hook (mono_domain_assembly_preload, (gpointer) FALSE);
+	mono_install_assembly_refonly_preload_hook (mono_domain_assembly_preload, (gpointer) TRUE);
+	mono_install_assembly_search_hook (mono_domain_assembly_search, (gpointer) FALSE);
+	mono_install_assembly_refonly_search_hook (mono_domain_assembly_search, (gpointer) TRUE);
 	mono_install_assembly_load_hook (mono_domain_fire_assembly_load, NULL);
 	mono_install_lookup_dynamic_token (mono_reflection_lookup_dynamic_token);
 
@@ -472,7 +478,7 @@
 }
 
 MonoArray *
-ves_icall_System_AppDomain_GetAssemblies (MonoAppDomain *ad)
+ves_icall_System_AppDomain_GetAssemblies (MonoAppDomain *ad, MonoBoolean refonly)
 {
 	MonoDomain *domain = ad->data; 
 	static MonoClass *System_Reflection_Assembly;
@@ -491,21 +497,25 @@
 
 	/* Need to skip internal assembly builders created by remoting */
 	mono_domain_lock (domain);
-	g_hash_table_foreach (domain->assemblies_by_name, filter_assembly, &ah);
+	if (!refonly)
+		g_hash_table_foreach (domain->assemblies_by_name, filter_assembly, &ah);
+	g_hash_table_foreach (domain->assemblies_refonly_by_name, filter_assembly, &ah);
 	mono_domain_unlock (domain);
 
 	res = mono_array_new (domain, System_Reflection_Assembly, ah.len);
 	ah.res = res;
 
 	mono_domain_lock (domain);
-	g_hash_table_foreach (domain->assemblies_by_name, add_assembly, &ah);
+	if (!refonly)
+		g_hash_table_foreach (domain->assemblies_by_name, add_assembly, &ah);
+	g_hash_table_foreach (domain->assemblies_refonly_by_name, add_assembly, &ah);
 	mono_domain_unlock (domain);
 
 	return res;
 }
 
 static MonoReflectionAssembly *
-try_assembly_resolve (MonoDomain *domain, MonoString *fname)
+try_assembly_resolve (MonoDomain *domain, MonoString *fname, MonoBoolean refonly)
 {
 	MonoClass *klass;
 	MonoMethod *method;
@@ -516,9 +526,13 @@
 	klass = domain->domain->mbr.obj.vtable->klass;
 	g_assert (klass);
 	
-	method = mono_class_get_method_from_name (klass, "DoAssemblyResolve", -1);
+	method = mono_class_get_method_from_name (klass, refonly? "DoPreBindAssemblyResolve" : "DoAssemblyResolve", -1);
 	if (method == NULL) {
-		g_warning ("Method AppDomain.DoAssemblyResolve not found.\n");
+		if (refonly)
+			g_warning ("Method AppDomain.DoPreBindAssemblyResolve not found.\n");
+		else
+			g_warning ("Method AppDomain.DoAssemblyResolve not found.\n");
+		
 		return NULL;
 	}
 
@@ -529,6 +543,8 @@
 static void
 add_assemblies_to_domain (MonoDomain *domain, MonoAssembly *ass)
 {
+	GHashTable *assemblies_by_name;
+	GList *assemblies;
 	gint i;
 
 	if (!ass->aname.name)
@@ -536,13 +552,25 @@
 
 	mono_domain_lock (domain);
 
-	if (g_hash_table_lookup (domain->assemblies_by_name, ass->aname.name)) {
+	if (ass->ref_only) {
+		assemblies_by_name = domain->assemblies_refonly_by_name;
+		assemblies = domain->assemblies_refonly;
+	} else {
+		assemblies_by_name = domain->assemblies_by_name;
+		assemblies = domain->assemblies;
+	}
+	
+	if (g_hash_table_lookup (assemblies_by_name, ass->aname.name)) {
 		mono_domain_unlock (domain);
 		return; /* This is ok while no lazy loading of assemblies */
 	}
 
-	g_hash_table_insert (domain->assemblies_by_name, (gpointer) ass->aname.name, ass);
-	domain->assemblies = g_list_prepend (domain->assemblies, ass);
+	g_hash_table_insert (assemblies_by_name, (gpointer) ass->aname.name, ass);
+	if (ass->ref_only)
+		domain->assemblies_refonly = g_list_prepend (assemblies, ass);
+	else
+		domain->assemblies = g_list_prepend (assemblies, ass);
+	
 	mono_domain_unlock (domain);
 
 	if (ass->image->references)
@@ -740,21 +768,21 @@
 
 static gboolean
 try_load_from (MonoAssembly **assembly, const gchar *path1, const gchar *path2,
-					const gchar *path3, const gchar *path4)
+					const gchar *path3, const gchar *path4, gboolean refonly)
 {
 	gchar *fullpath;
 
 	*assembly = NULL;
 	fullpath = g_build_filename (path1, path2, path3, path4, NULL);
 	if (g_file_test (fullpath, G_FILE_TEST_IS_REGULAR))
-		*assembly = mono_assembly_open (fullpath, NULL);
+		*assembly = mono_assembly_open_refonly (fullpath, NULL, refonly);
 
 	g_free (fullpath);
 	return (*assembly != NULL);
 }
 
 static MonoAssembly *
-real_load (gchar **search_path, const gchar *culture, const gchar *name)
+real_load (gchar **search_path, const gchar *culture, const gchar *name, gboolean refonly)
 {
 	MonoAssembly *result = NULL;
 	gchar **path;
@@ -778,22 +806,22 @@
 		/* See test cases in bug #58992 and bug #57710 */
 		/* 1st try: [culture]/[name].dll (culture may be empty) */
 		strcpy (filename + len - 4, ".dll");
-		if (try_load_from (&result, *path, local_culture, "", filename))
+		if (try_load_from (&result, *path, local_culture, "", filename, refonly))
 			break;
 
 		/* 2nd try: [culture]/[name].exe (culture may be empty) */
 		strcpy (filename + len - 4, ".exe");
-		if (try_load_from (&result, *path, local_culture, "", filename))
+		if (try_load_from (&result, *path, local_culture, "", filename, refonly))
 			break;
 
 		/* 3rd try: [culture]/[name]/[name].dll (culture may be empty) */
 		strcpy (filename + len - 4, ".dll");
-		if (try_load_from (&result, *path, local_culture, name, filename))
+		if (try_load_from (&result, *path, local_culture, name, filename, refonly))
 			break;
 
 		/* 4th try: [culture]/[name]/[name].exe (culture may be empty) */
 		strcpy (filename + len - 4, ".exe");
-		if (try_load_from (&result, *path, local_culture, name, filename))
+		if (try_load_from (&result, *path, local_culture, name, filename, refonly))
 			break;
 	}
 
@@ -812,15 +840,16 @@
 {
 	MonoDomain *domain = mono_domain_get ();
 	MonoAssembly *result = NULL;
+	gboolean refonly = (gboolean) user_data;
 
 	set_domain_search_path (domain);
 
 	if (domain->search_path && domain->search_path [0] != NULL) {
-		result = real_load (domain->search_path, aname->culture, aname->name);
+		result = real_load (domain->search_path, aname->culture, aname->name, refonly);
 	}
 
 	if (result == NULL && assemblies_path && assemblies_path [0] != NULL) {
-		result = real_load (assemblies_path, aname->culture, aname->name);
+		result = real_load (assemblies_path, aname->culture, aname->name, refonly);
 	}
 
 	return result;
@@ -836,9 +865,11 @@
 	MonoDomain *domain = mono_domain_get ();
 	GList *tmp;
 	MonoAssembly *ass;
+	gboolean refonly = (gboolean) user_data;
 
 	mono_domain_lock (domain);
-	for (tmp = domain->assemblies; tmp; tmp = tmp->next) {
+	tmp = refonly ? domain->assemblies_refonly : domain->assemblies;
+	for (; tmp; tmp = tmp->next) {
 		ass = tmp->data;
 		/* Dynamic assemblies can't match here in MS.NET */
 		if (ass->dynamic || !mono_assembly_names_equal (aname, &ass->aname))
@@ -853,7 +884,7 @@
 }
 
 MonoReflectionAssembly *
-ves_icall_System_Reflection_Assembly_LoadFrom (MonoString *fname)
+ves_icall_System_Reflection_Assembly_LoadFrom (MonoString *fname, MonoBoolean refOnly)
 {
 	MonoDomain *domain = mono_domain_get ();
 	char *name, *filename;
@@ -869,7 +900,7 @@
 		
 	name = filename = mono_string_to_utf8 (fname);
 
-	ass = mono_assembly_open (filename, &status);
+	ass = mono_assembly_open_refonly (filename, &status, refOnly);
 	
 	g_free (name);
 
@@ -1004,7 +1035,7 @@
 }
 
 MonoReflectionAssembly *
-ves_icall_System_AppDomain_LoadAssembly (MonoAppDomain *ad,  MonoString *assRef, MonoObject *evidence)
+ves_icall_System_AppDomain_LoadAssembly (MonoAppDomain *ad,  MonoString *assRef, MonoObject *evidence, MonoBoolean refOnly)
 {
 	MonoDomain *domain = ad->data; 
 	MonoImageOpenStatus status = MONO_IMAGE_OK;
@@ -1025,10 +1056,10 @@
 		mono_raise_exception (exc);
 	}
 
-	ass = mono_assembly_load (&aname, NULL, &status);
+	ass = mono_assembly_load_refonly (&aname, NULL, &status, refOnly);
 	free_assembly_name (&aname);
 
-	if (!ass && (refass = try_assembly_resolve (domain, assRef)) == NULL){
+	if (!ass && (refass = try_assembly_resolve (domain, assRef, refOnly)) == NULL){
 		/* FIXME: it doesn't make much sense since we really don't have a filename ... */
 		MonoException *exc = mono_get_exception_file_not_found (assRef);
 		mono_raise_exception (exc);
Index: assembly.c
===================================================================
--- assembly.c	(revisión: 39129)
+++ assembly.c	(copia de trabajo)
@@ -55,6 +55,9 @@
 /* A hastable of thread->assembly list mappings */
 static GHashTable *assemblies_loading;
 
+/* A hashtable of reflection only load thread->assemblies mappings */
+static GHashTable *assemblies_refonly_loading;
+
 /* If defined, points to the bundled assembly information */
 const MonoBundledAssembly **bundles;
 
@@ -150,13 +153,13 @@
 }
 
 static MonoAssembly*
-search_loaded (MonoAssemblyName* aname)
+search_loaded (MonoAssemblyName* aname, gboolean refonly)
 {
 	GList *tmp;
 	MonoAssembly *ass;
 	GList *loading;
 
-	ass = mono_assembly_invoke_search_hook (aname);
+	ass = refonly? mono_assembly_refonly_invoke_search_hook (aname) : mono_assembly_invoke_search_hook (aname);
 	if (ass)
 		return ass;
 	
@@ -164,7 +167,7 @@
 	 * The assembly might be under load by this thread. In this case, it is
 	 * safe to return an incomplete instance to prevent loops.
 	 */
-	loading = g_hash_table_lookup (assemblies_loading, GetCurrentThread ());
+	loading = g_hash_table_lookup (refonly ? assemblies_refonly_loading : assemblies_loading, GetCurrentThread ());
 	for (tmp = loading; tmp; tmp = tmp->next) {
 		ass = tmp->data;
 		if (!mono_assembly_names_equal (aname, &ass->aname))
@@ -177,7 +180,7 @@
 }
 
 static MonoAssembly *
-load_in_path (const char *basename, const char** search_path, MonoImageOpenStatus *status)
+load_in_path (const char *basename, const char** search_path, MonoImageOpenStatus *status, MonoBoolean refonly)
 {
 	int i;
 	char *fullpath;
@@ -185,7 +188,7 @@
 
 	for (i = 0; search_path [i]; ++i) {
 		fullpath = g_build_filename (search_path [i], basename, NULL);
-		result = mono_assembly_open (fullpath, status);
+		result = mono_assembly_open_refonly (fullpath, status, refonly);
 		g_free (fullpath);
 		if (result)
 			return result;
@@ -236,6 +239,7 @@
 	InitializeCriticalSection (&assemblies_mutex);
 
 	assemblies_loading = g_hash_table_new (NULL, NULL);
+	assemblies_refonly_loading = g_hash_table_new (NULL, NULL);
 }
 
 gboolean
@@ -349,7 +353,20 @@
 		memset (aname.public_key_token, 0, MONO_PUBLIC_KEY_TOKEN_LENGTH);
 	} 
 
-	reference = mono_assembly_load (&aname, image->assembly->basedir, &status);
+	if (image->assembly->ref_only) {
+		/* We use the loaded corlib */
+		if (!strcmp (aname.name, "mscorlib"))
+			reference = mono_assembly_load_refonly (&aname, image->assembly->basedir, &status, FALSE);
+		else
+			reference = mono_assembly_loaded (&aname, TRUE);
+		/*
+		 * Here we must advice that the error was due to
+		 * a non loaded reference using the ReflectionOnly api
+		*/
+		if (!reference)
+			reference = (gpointer)-1;
+	} else
+		reference = mono_assembly_load (&aname, image->assembly->basedir, &status);
 
 	if (reference == NULL){
 		/*
@@ -467,6 +484,7 @@
 };
 
 AssemblySearchHook *assembly_search_hook = NULL;
+AssemblySearchHook *assembly_refonly_search_hook = NULL;
 
 MonoAssembly*
 mono_assembly_invoke_search_hook (MonoAssemblyName *aname)
@@ -482,6 +500,20 @@
 	return NULL;
 }
 
+MonoAssembly*
+mono_assembly_refonly_invoke_search_hook (MonoAssemblyName *aname)
+{
+	AssemblySearchHook *hook;
+
+	for (hook = assembly_refonly_search_hook; hook; hook = hook->next) {
+		MonoAssembly *ass = hook->func (aname, hook->user_data);
+		if (ass)
+			return ass;
+	}
+
+	return NULL;
+}
+
 void          
 mono_install_assembly_search_hook (MonoAssemblySearchFunc func, gpointer user_data)
 {
@@ -496,6 +528,20 @@
 	assembly_search_hook = hook;
 }	
 
+void
+mono_install_assembly_refonly_search_hook (MonoAssemblySearchFunc func, gpointer user_data)
+{
+	AssemblySearchHook *hook;
+
+	g_return_if_fail (func != NULL);
+
+	hook = g_new0 (AssemblySearchHook, 1);
+	hook->func = func;
+	hook->user_data = user_data;
+	hook->next = assembly_refonly_search_hook;
+	assembly_refonly_search_hook = hook;
+}
+
 typedef struct AssemblyPreLoadHook AssemblyPreLoadHook;
 struct AssemblyPreLoadHook {
 	AssemblyPreLoadHook *next;
@@ -504,6 +550,7 @@
 };
 
 AssemblyPreLoadHook *assembly_preload_hook = NULL;
+AssemblyPreLoadHook *assembly_refonly_preload_hook = NULL;
 
 static MonoAssembly *
 invoke_assembly_preload_hook (MonoAssemblyName *aname, gchar **assemblies_path)
@@ -520,6 +567,21 @@
 	return NULL;
 }
 
+static MonoAssembly *
+invoke_assembly_refonly_preload_hook (MonoAssemblyName *aname, gchar **assemblies_path)
+{
+	AssemblyPreLoadHook *hook;
+	MonoAssembly *assembly;
+
+	for (hook = assembly_refonly_preload_hook; hook; hook = hook->next) {
+		assembly = hook->func (aname, assemblies_path, hook->user_data);
+		if (assembly != NULL)
+			return assembly;
+	}
+
+	return NULL;
+}
+
 void
 mono_install_assembly_preload_hook (MonoAssemblyPreLoadFunc func, gpointer user_data)
 {
@@ -534,6 +596,20 @@
 	assembly_preload_hook = hook;
 }
 
+void
+mono_install_assembly_refonly_preload_hook (MonoAssemblyPreLoadFunc func, gpointer user_data)
+{
+	AssemblyPreLoadHook *hook;
+	
+	g_return_if_fail (func != NULL);
+
+	hook = g_new0 (AssemblyPreLoadHook, 1);
+	hook->func = func;
+	hook->user_data = user_data;
+	hook->next = assembly_refonly_preload_hook;
+	assembly_refonly_preload_hook = hook;
+}
+
 static gchar *
 absolute_dir (const gchar *filename)
 {
@@ -643,19 +719,8 @@
 	return image;
 }
 
-/**
- * mono_assembly_open:
- * @filename: Opens the assembly pointed out by this name
- * @status: where a status code can be returned
- *
- * mono_assembly_open opens the PE-image pointed by @filename, and
- * loads any external assemblies referenced by it.
- *
- * NOTE: we could do lazy loading of the assemblies.  Or maybe not worth
- * it. 
- */
 MonoAssembly *
-mono_assembly_open (const char *filename, MonoImageOpenStatus *status)
+mono_assembly_open_refonly (const char *filename, MonoImageOpenStatus *status, gboolean refonly)
 {
 	MonoImage *image;
 	MonoAssembly *ass;
@@ -707,12 +772,13 @@
 		return NULL;
 	}
 
-	ass = mono_assembly_load_from (image, fname, status);
+	ass = mono_assembly_load_from_refonly (image, fname, status, refonly);
 
 	if (ass) {
 		mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_ASSEMBLY,
 				"Assembly Loader loaded assembly from location: '%s'.", filename);
-		mono_config_for_assembly (ass->image);
+		if (!refonly)
+			mono_config_for_assembly (ass->image);
 	}
 
 	g_free (fname);
@@ -720,13 +786,31 @@
 	return ass;
 }
 
+/**
+ * mono_assembly_open:
+ * @filename: Opens the assembly pointed out by this name
+ * @status: where a status code can be returned
+ *
+ * mono_assembly_open opens the PE-image pointed by @filename, and
+ * loads any external assemblies referenced by it.
+ *
+ * NOTE: we could do lazy loading of the assemblies.  Or maybe not worth
+ * it. 
+ */
 MonoAssembly *
-mono_assembly_load_from (MonoImage *image, const char*fname, 
-			 MonoImageOpenStatus *status)
+mono_assembly_open (const char *filename, MonoImageOpenStatus *status)
 {
+	return mono_assembly_open_refonly (filename, status, FALSE);
+}
+
+MonoAssembly *
+mono_assembly_load_from_refonly (MonoImage *image, const char*fname, 
+			 MonoImageOpenStatus *status, gboolean refonly)
+{
 	MonoAssembly *ass, *ass2;
 	char *base_dir;
 	GList *loading;
+	GHashTable *ass_loading;
 
 #if defined (PLATFORM_WIN32)
 	{
@@ -759,6 +843,7 @@
 	 */
 	ass = g_new0 (MonoAssembly, 1);
 	ass->basedir = base_dir;
+	ass->ref_only = refonly;
 	ass->image = image;
 
 	mono_assembly_fill_assembly_name (image, &ass->aname);
@@ -767,9 +852,10 @@
 	 * Atomically search the loaded list and add ourselves to it if necessary.
 	 */
 	EnterCriticalSection (&assemblies_mutex);
-	if (ass->aname.name)
+	if (ass->aname.name) {
 		/* avoid loading the same assembly twice for now... */
-		if ((ass2 = search_loaded (&ass->aname))) {
+		ass2 = search_loaded (&ass->aname, refonly);
+		if (ass2) {
 			g_free (ass);
 			g_free (base_dir);
 			mono_image_close (image);
@@ -777,9 +863,11 @@
 			LeaveCriticalSection (&assemblies_mutex);
 			return ass2;
 		}
-	loading = g_hash_table_lookup (assemblies_loading, GetCurrentThread ());
+	}
+	ass_loading = refonly ? assemblies_refonly_loading : assemblies_loading;
+	loading = g_hash_table_lookup (ass_loading, GetCurrentThread ());
 	loading = g_list_prepend (loading, ass);
-	g_hash_table_insert (assemblies_loading, GetCurrentThread (), loading);
+	g_hash_table_insert (ass_loading, GetCurrentThread (), loading);
 	LeaveCriticalSection (&assemblies_mutex);
 
 	image->assembly = ass;
@@ -788,13 +876,13 @@
 
 	EnterCriticalSection (&assemblies_mutex);
 
-	loading = g_hash_table_lookup (assemblies_loading, GetCurrentThread ());
+	loading = g_hash_table_lookup (ass_loading, GetCurrentThread ());
 	loading = g_list_remove (loading, ass);
 	if (loading == NULL)
 		/* Prevent memory leaks */
-		g_hash_table_remove (assemblies_loading, GetCurrentThread ());
+		g_hash_table_remove (ass_loading, GetCurrentThread ());
 	else
-		g_hash_table_insert (assemblies_loading, GetCurrentThread (), loading);
+		g_hash_table_insert (ass_loading, GetCurrentThread (), loading);
 	if (*status != MONO_IMAGE_OK) {
 		LeaveCriticalSection (&assemblies_mutex);
 		mono_assembly_close (ass);
@@ -802,7 +890,7 @@
 	}
 
 	if (ass->aname.name) {
-		ass2 = search_loaded (&ass->aname);
+		ass2 = search_loaded (&ass->aname, refonly);
 		if (ass2) {
 			/* Somebody else has loaded the assembly before us */
 			LeaveCriticalSection (&assemblies_mutex);
@@ -819,6 +907,13 @@
 	return ass;
 }
 
+MonoAssembly *
+mono_assembly_load_from (MonoImage *image, const char *fname,
+			 MonoImageOpenStatus *status)
+{
+	return mono_assembly_load_from_refonly (image, fname, status, FALSE);
+}
+
 static MonoAssembly*
 probe_for_partial_name (const char *basepath, const char *fullname, MonoImageOpenStatus *status)
 {
@@ -854,7 +949,7 @@
 	memset (&aname, 0, sizeof (MonoAssemblyName));
 	aname.name = name;
 
-	res = mono_assembly_loaded (&aname);
+	res = mono_assembly_loaded (&aname, FALSE);
 	if (res)
 		return res;
 
@@ -901,7 +996,7 @@
  * @aname: The assembly name object
  */
 static MonoAssembly*
-mono_assembly_load_from_gac (MonoAssemblyName *aname,  gchar *filename, MonoImageOpenStatus *status)
+mono_assembly_load_from_gac (MonoAssemblyName *aname,  gchar *filename, MonoImageOpenStatus *status, MonoBoolean refonly)
 {
 	MonoAssembly *result = NULL;
 	gchar *name, *version, *culture, *fullpath, *subpath;
@@ -940,7 +1035,7 @@
 		paths = extra_gac_paths;
 		while (!result && *paths) {
 			fullpath = g_build_path (G_DIR_SEPARATOR_S, *paths, "lib", "mono", "gac", subpath, NULL);
-			result = mono_assembly_open (fullpath, status);
+			result = mono_assembly_open_refonly (fullpath, status, refonly);
 			g_free (fullpath);
 			paths++;
 		}
@@ -954,7 +1049,7 @@
 
 	fullpath = g_build_path (G_DIR_SEPARATOR_S, mono_assembly_getrootdir (),
 			"mono", "gac", subpath, NULL);
-	result = mono_assembly_open (fullpath, status);
+	result = mono_assembly_open_refonly (fullpath, status, refonly);
 	g_free (fullpath);
 
 	if (result)
@@ -965,18 +1060,17 @@
 	return result;
 }
 
-	
 MonoAssembly*
-mono_assembly_load (MonoAssemblyName *aname, const char *basedir, MonoImageOpenStatus *status)
+mono_assembly_load_refonly (MonoAssemblyName *aname, const char *basedir, MonoImageOpenStatus *status, gboolean refonly)
 {
 	MonoAssembly *result;
 	char *fullpath, *filename;
 
-	result = mono_assembly_loaded (aname);
+	result = mono_assembly_loaded (aname, refonly);
 	if (result)
 		return result;
 
-	result = invoke_assembly_preload_hook (aname, assemblies_path);
+	result = refonly ? invoke_assembly_refonly_preload_hook (aname, assemblies_path) : invoke_assembly_preload_hook (aname, assemblies_path);
 	if (result) {
 		result->in_gac = FALSE;
 		return result;
@@ -992,11 +1086,11 @@
 		}
 		/* g_print ("corlib load\n"); */
 		if (assemblies_path) {
-			corlib = load_in_path ("mscorlib.dll", (const char**)assemblies_path, status);
+			corlib = load_in_path ("mscorlib.dll", (const char**)assemblies_path, status, FALSE);
 			if (corlib)
 				return corlib;
 		}
-		corlib = load_in_path ("mscorlib.dll", default_path, status);
+		corlib = load_in_path ("mscorlib.dll", default_path, status, FALSE);
 
 		if (corlib)
 			return corlib;
@@ -1005,13 +1099,13 @@
 		
 		corlib_file = g_build_filename ("mono", mono_get_framework_version (), "mscorlib.dll", NULL);
 		if (assemblies_path) {
-			corlib = load_in_path (corlib_file, (const char**)assemblies_path, status);
+			corlib = load_in_path (corlib_file, (const char**)assemblies_path, status, FALSE);
 			if (corlib) {
 				g_free (corlib_file);
 				return corlib;
 			}
 		}
-		corlib = load_in_path (corlib_file, default_path, status);
+		corlib = load_in_path (corlib_file, default_path, status, FALSE);
 		g_free (corlib_file);
 	
 		return corlib;
@@ -1022,7 +1116,7 @@
 	else
 		filename = g_strconcat (aname->name, ".dll", NULL);
 
-	result = mono_assembly_load_from_gac (aname, filename, status);
+	result = mono_assembly_load_from_gac (aname, filename, status, refonly);
 	if (result) {
 		g_free (filename);
 		return result;
@@ -1030,7 +1124,7 @@
 
 	if (basedir) {
 		fullpath = g_build_filename (basedir, filename, NULL);
-		result = mono_assembly_open (fullpath, status);
+		result = mono_assembly_open_refonly (fullpath, status, refonly);
 		g_free (fullpath);
 		if (result) {
 			result->in_gac = FALSE;
@@ -1039,7 +1133,7 @@
 		}
 	}
 
-	result = load_in_path (filename, default_path, status);
+	result = load_in_path (filename, default_path, status, refonly);
 	if (result)
 		result->in_gac = FALSE;
 	g_free (filename);
@@ -1047,12 +1141,18 @@
 }
 
 MonoAssembly*
-mono_assembly_loaded (MonoAssemblyName *aname)
+mono_assembly_load (MonoAssemblyName *aname, const char *basedir, MonoImageOpenStatus *status)
 {
+	return mono_assembly_load_refonly (aname, basedir, status, FALSE);
+}
+	
+MonoAssembly*
+mono_assembly_loaded (MonoAssemblyName *aname, gboolean ref_only)
+{
 	MonoAssembly *res;
 
 	EnterCriticalSection (&assemblies_mutex);
-	res = search_loaded (aname);
+	res = search_loaded (aname, ref_only);
 	LeaveCriticalSection (&assemblies_mutex);
 
 	return res;
Index: assembly.h
===================================================================
--- assembly.h	(revisión: 39129)
+++ assembly.h	(copia de trabajo)
@@ -8,15 +8,25 @@
 void          mono_assemblies_init     (void);
 MonoAssembly *mono_assembly_open       (const char *filename,
 				       	MonoImageOpenStatus *status);
+MonoAssembly *mono_assembly_open_refonly (const char *filename,
+				       	MonoImageOpenStatus *status,
+					gboolean refonly);
 MonoAssembly* mono_assembly_load       (MonoAssemblyName *aname, 
                                        	const char       *basedir, 
 				     	MonoImageOpenStatus *status);
+MonoAssembly* mono_assembly_load_refonly (MonoAssemblyName *aname, 
+                                       	const char       *basedir, 
+				     	MonoImageOpenStatus *status,
+					gboolean refonly);
 MonoAssembly* mono_assembly_load_from  (MonoImage *image, const char *fname,
 					MonoImageOpenStatus *status);
+MonoAssembly* mono_assembly_load_from_refonly  (MonoImage *image, const char *fname,
+					MonoImageOpenStatus *status,
+					gboolean refonly);
 
 MonoAssembly* mono_assembly_load_with_partial_name (const char *name, MonoImageOpenStatus *status);
 
-MonoAssembly* mono_assembly_loaded     (MonoAssemblyName *aname);
+MonoAssembly* mono_assembly_loaded     (MonoAssemblyName *aname, gboolean refonly);
 void          mono_assembly_load_reference (MonoImage *image, int index);
 void          mono_assembly_load_references (MonoImage *image, MonoImageOpenStatus *status);
 MonoImage*    mono_assembly_load_module (MonoAssembly *assembly, guint32 idx);
@@ -40,8 +50,10 @@
  */
 typedef MonoAssembly *(*MonoAssemblySearchFunc)         (MonoAssemblyName *aname, gpointer user_data);
 void          mono_install_assembly_search_hook (MonoAssemblySearchFunc func, gpointer user_data);
+void          mono_install_assembly_refonly_search_hook (MonoAssemblySearchFunc func, gpointer user_data);
 
 MonoAssembly* mono_assembly_invoke_search_hook (MonoAssemblyName *aname);
+MonoAssembly* mono_assembly_refonly_invoke_search_hook (MonoAssemblyName *aname);
 
 /* Installs a function which is called before a new assembly is loaded
  * The hook are invoked from last hooked to first. If any of them returns
@@ -53,6 +65,9 @@
 void          mono_install_assembly_preload_hook (MonoAssemblyPreLoadFunc func,
 						  gpointer user_data);
 
+void          mono_install_assembly_refonly_preload_hook (MonoAssemblyPreLoadFunc func,
+						  gpointer user_data);
+
 void          mono_assembly_invoke_load_hook (MonoAssembly *ass);
 
 typedef struct {
Index: metadata-internals.h
===================================================================
--- metadata-internals.h	(revisión: 39129)
+++ metadata-internals.h	(copia de trabajo)
@@ -15,6 +15,7 @@
 	guint8 in_gac;
 	guint8 dynamic;
 	guint8 corlib_internal;
+	gboolean ref_only;
 };
 
 typedef struct {
Index: domain-internals.h
===================================================================
--- domain-internals.h	(revisión: 39129)
+++ domain-internals.h	(copia de trabajo)
@@ -88,7 +88,9 @@
 	MonoCodeManager    *code_mp;
 	MonoGHashTable     *env;
 	GHashTable         *assemblies_by_name;
+	GHashTable         *assemblies_refonly_by_name;
 	GList              *assemblies;
+	GList              *assemblies_refonly;
 	MonoAssembly       *entry_assembly;
 	MonoAppDomainSetup *setup;
 	char               *friendly_name;
@@ -171,15 +173,18 @@
 ves_icall_System_AppDomain_getFriendlyName         (MonoAppDomain *ad);
 
 MonoArray *
-ves_icall_System_AppDomain_GetAssemblies           (MonoAppDomain *ad);
+ves_icall_System_AppDomain_GetAssemblies           (MonoAppDomain *ad,
+						    MonoBoolean refonly);
 
 MonoReflectionAssembly *
-ves_icall_System_Reflection_Assembly_LoadFrom      (MonoString *fname);
+ves_icall_System_Reflection_Assembly_LoadFrom      (MonoString *fname,
+						    MonoBoolean refonly);
 
 MonoReflectionAssembly *
 ves_icall_System_AppDomain_LoadAssembly            (MonoAppDomain *ad, 
 						    MonoString *assRef,
-						    MonoObject    *evidence);
+						    MonoObject    *evidence,
+						    MonoBoolean refonly);
 
 gboolean
 ves_icall_System_AppDomain_InternalIsFinalizingForUnload (gint32 domain_id);
Index: exception.c
===================================================================
--- exception.c	(revisión: 39129)
+++ exception.c	(copia de trabajo)
@@ -219,6 +219,13 @@
 }
 
 MonoException *
+mono_get_exception_invalid_operation (const guchar *msg)
+{
+	return mono_exception_from_name_msg (mono_get_corlib (), "System",
+					"InvalidOperationException", msg);
+}
+
+MonoException *
 mono_get_exception_index_out_of_range ()
 {
 	return mono_exception_from_name (mono_get_corlib (), "System",
Index: exception.h
===================================================================
--- exception.h	(revisión: 39129)
+++ exception.h	(copia de trabajo)
@@ -59,6 +59,9 @@
 mono_get_exception_invalid_cast        (void);
 
 MonoException *
+mono_get_exception_invalid_operation (const guchar *msg);
+
+MonoException *
 mono_get_exception_index_out_of_range  (void);
 
 MonoException *
Index: icall.c
===================================================================
--- icall.c	(revisión: 39129)
+++ icall.c	(copia de trabajo)
@@ -1302,6 +1302,10 @@
 
 	MONO_ARCH_SAVE_REGS;
 
+	if (field->klass->image->assembly->ref_only)
+		mono_raise_exception (mono_get_exception_invalid_operation (
+					"It is illegal to get the value on a field on a type loaded using the ReflectionOnly methods."));
+	
 	mono_class_init (field->klass);
 
 	switch (cf->type->type) {
@@ -1373,6 +1377,10 @@
 
 	MONO_ARCH_SAVE_REGS;
 
+	if (field->klass->image->assembly->ref_only)
+		mono_raise_exception (mono_get_exception_invalid_operation (
+					"It is illegal to set the value on a field on a type loaded using the ReflectionOnly methods."));
+
 	v = (gchar *) value;
 	if (!cf->type->byref) {
 		switch (cf->type->type) {
@@ -2344,6 +2352,9 @@
 	if ((m->klass->flags & TYPE_ATTRIBUTE_ABSTRACT) && !strcmp (m->name, ".ctor"))
 		mono_raise_exception (mono_exception_from_name_msg (mono_defaults.corlib, "System", "MethodAccessException", "Cannot invoke constructor of an abstract class."));
 
+	if (m->klass->image->assembly->ref_only)
+		mono_raise_exception (mono_get_exception_invalid_operation ("It is illegal to invoke a method on a type loaded using the ReflectionOnly api."));
+	
 	if (m->klass->rank && !strcmp (m->name, ".ctor")) {
 		int i;
 		guint32 *lengths;
@@ -3348,6 +3359,14 @@
 	return res;
 }
 
+static MonoBoolean
+ves_icall_System_Reflection_Assembly_get_ReflectionOnly (MonoReflectionAssembly *assembly)
+{
+	MONO_ARCH_SAVE_REGS;
+
+	return assembly->assembly->ref_only;
+}
+
 static MonoString *
 ves_icall_System_Reflection_Assembly_InternalImageRuntimeVersion (MonoReflectionAssembly *assembly)
 {
@@ -6021,6 +6040,7 @@
 	{"get_EntryPoint", ves_icall_System_Reflection_Assembly_get_EntryPoint},
 	{"get_ManifestModule", ves_icall_System_Reflection_Assembly_get_ManifestModule},
 	{"get_MetadataToken", mono_reflection_get_token},
+	{"get_ReflectionOnly", ves_icall_System_Reflection_Assembly_get_ReflectionOnly},
 	{"get_code_base", ves_icall_System_Reflection_Assembly_get_code_base},
 	{"get_global_assembly_cache", ves_icall_System_Reflection_Assembly_get_global_assembly_cache},
 	{"get_location", ves_icall_System_Reflection_Assembly_get_location},
Index: reflection.c
===================================================================
--- reflection.c	(revisión: 39129)
+++ reflection.c	(copia de trabajo)
@@ -5327,7 +5327,8 @@
 			return klass->reflection_info;
 		}
 	}
-	mono_class_init (klass);
+	if (!klass->image->assembly->ref_only)
+		mono_class_init (klass);
 	res = (MonoReflectionType *)mono_object_new (domain, mono_defaults.monotype_class);
 	res->type = type;
 	mono_g_hash_table_insert (domain->type_hash, type, res);
@@ -6095,7 +6096,7 @@
 	}
 
 	if (info.assembly.name) {
-		assembly = mono_assembly_loaded (&info.assembly);
+		assembly = mono_assembly_loaded (&info.assembly, image->assembly->ref_only);
 		if (!assembly) {
 			/* then we must load the assembly ourselve - see #60439 */
 			assembly = mono_assembly_load (&info.assembly, NULL, NULL);
