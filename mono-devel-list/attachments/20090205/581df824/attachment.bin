Index: mono/metadata/class.c
===================================================================
--- mono/metadata/class.c	(revision 125681)
+++ mono/metadata/class.c	(working copy)
@@ -2037,6 +2037,55 @@
 	return (key->interface_id - element->interface_id);
 }
 
+static gboolean
+mono_class_has_variant_generic_params (MonoClass *klass)
+{
+	int i;
+	MonoGenericContainer *container;
+
+	if (!klass->generic_class)
+		return FALSE;
+
+	container = klass->generic_class->container_class->generic_container;
+
+	for (i = 0; i < container->type_argc; ++i) {
+		if (container->type_params [i].flags & GENERIC_PARAMETER_ATTRIBUTE_VARIANCE_MASK)
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+static gboolean
+mono_class_is_variant_of (MonoClass *klass, MonoClass *vklass) {
+	int i;
+	MonoClass *generic = klass->generic_class->container_class;
+	MonoClass *vgeneric = vklass->generic_class->container_class;
+	MonoGenericContainer *container = vgeneric->generic_container;
+
+	if (generic != vgeneric)
+		return FALSE;
+
+	for (i = 0; i < container->type_argc; i++) {
+		MonoClass *param_class = mono_class_from_mono_type (klass->generic_class->context.class_inst->type_argv [i]);
+		MonoClass *vparam_class = mono_class_from_mono_type (vklass->generic_class->context.class_inst->type_argv [i]);
+
+		// FIXME this is incorrect
+		if (param_class->valuetype || vparam_class->valuetype)
+			return FALSE;
+
+		if (container->type_params [i].flags & GENERIC_PARAMETER_ATTRIBUTE_VARIANCE_MASK) {
+			if ((container->type_params [i].flags & GENERIC_PARAMETER_ATTRIBUTE_CONTRAVARIANT) && !mono_class_is_assignable_from (param_class, vparam_class))
+				return FALSE;
+			if ((container->type_params [i].flags & GENERIC_PARAMETER_ATTRIBUTE_COVARIANT) && !mono_class_is_assignable_from (vparam_class, param_class))
+				return FALSE;
+		} else if (param_class != vparam_class)
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
 int
 mono_class_interface_offset (MonoClass *klass, MonoClass *itf) {
 	MonoClass **result = bsearch (
@@ -2052,6 +2101,27 @@
 	}
 }
 
+int
+mono_class_interface_offset_with_variance (MonoClass *klass, MonoClass *itf) {
+	int i;
+	MonoClass **result = bsearch (
+			itf,
+			klass->interfaces_packed,
+			klass->interface_offsets_count,
+			sizeof (MonoClass *),
+			compare_interface_ids);
+	if (result) {
+		return klass->interface_offsets_packed [result - (klass->interfaces_packed)];
+	} else if (mono_class_has_variant_generic_params (itf)) {
+		for (i = 0; i < klass->interface_offsets_count; i++) {
+			if (mono_class_is_variant_of (klass->interfaces_packed[i], itf)) {
+				return klass->interface_offsets_packed [i];
+			}
+		}
+	}
+	return -1;
+}
+
 static void
 print_implemented_interfaces (MonoClass *klass) {
 	GPtrArray *ifaces = NULL;
@@ -5800,24 +5870,6 @@
 	return FALSE;
 }
 
-static gboolean
-mono_class_has_variant_generic_params (MonoClass *klass)
-{
-	int i;
-	MonoGenericContainer *container;
-
-	if (!klass->generic_class)
-		return FALSE;
-
-	container = klass->generic_class->container_class->generic_container;
-
-	for (i = 0; i < container->type_argc; ++i)
-		if (container->type_params [i].flags & (MONO_GEN_PARAM_VARIANT|MONO_GEN_PARAM_COVARIANT))
-			return TRUE;
-
-	return FALSE;
-}
-
 /**
  * mono_class_is_assignable_from:
  * @klass: the class to be assigned to
@@ -5855,55 +5907,23 @@
 		if (MONO_CLASS_IMPLEMENTS_INTERFACE (oklass, klass->interface_id))
 			return TRUE;
 
-		if (mono_class_has_variant_generic_params (klass)) {
-			if (oklass->generic_class) {
-				int i;
-				gboolean match = FALSE;
-				MonoClass *container_class1 = klass->generic_class->container_class;
-				MonoClass *container_class2 = oklass->generic_class->container_class;
+		if (mono_class_has_variant_generic_params (klass) && oklass->generic_class) {
+			int i;
+			gboolean match = FALSE;
+			MonoClass *container_class1 = klass->generic_class->container_class;
+			MonoClass *container_class2 = oklass->generic_class->container_class;
 
-				/* 
-				 * Check whenever the generic definition of oklass implements the 
-				 * generic definition of klass. The IMPLEMENTS_INTERFACE stuff is not usable
-				 * here since the relevant tables are not set up.
-				 */
-				for (i = 0; i < container_class2->interface_offsets_count; ++i)
-					if ((container_class2->interfaces_packed [i] == container_class1) || (container_class2->interfaces_packed [i]->generic_class && (container_class2->interfaces_packed [i]->generic_class->container_class == container_class1)))
-						match = TRUE;
-
-				if (match) {
-					MonoGenericContainer *container;
-
-					container = klass->generic_class->container_class->generic_container;
-
+			/* 
+			 * Check whenever the generic definition of oklass implements the 
+			 * generic definition of klass. The IMPLEMENTS_INTERFACE stuff is not usable
+			 * here since the relevant tables are not set up.
+			 */
+			for (i = 0; i < container_class2->interface_offsets_count; ++i)
+				if ((container_class2->interfaces_packed [i] == container_class1) || (container_class2->interfaces_packed [i]->generic_class && (container_class2->interfaces_packed [i]->generic_class->container_class == container_class1)))
 					match = TRUE;
-					for (i = 0; i < container->type_argc; ++i) {
-						MonoClass *param1_class = mono_class_from_mono_type (klass->generic_class->context.class_inst->type_argv [i]);
-						MonoClass *param2_class = mono_class_from_mono_type (oklass->generic_class->context.class_inst->type_argv [i]);
 
-						if (param1_class->valuetype != param2_class->valuetype) {
-							match = FALSE;
-							break;
-						}
-						/*
-						 * The _VARIANT and _COVARIANT constants should read _COVARIANT and
-						 * _CONTRAVARIANT, but they are in a public header so we can't fix it.
-						 */
-						if (param1_class != param2_class) {
-							if ((container->type_params [i].flags & MONO_GEN_PARAM_VARIANT) && mono_class_is_assignable_from (param1_class, param2_class))
-								;
-							else if (((container->type_params [i].flags & MONO_GEN_PARAM_COVARIANT) && mono_class_is_assignable_from (param2_class, param1_class)))
-								;
-							else {
-								match = FALSE;
-								break;
-							}
-						}
-					}
-
-					if (match)
-						return TRUE;
-				}
+			if (match && mono_class_is_variant_of (oklass, klass)) {
+				return TRUE;
 			}
 		}
 	} else if (klass->rank) {
Index: mono/metadata/ChangeLog
===================================================================
--- mono/metadata/ChangeLog	(revision 125344)
+++ mono/metadata/ChangeLog	(working copy)
@@ -1,3 +1,15 @@
+2009-02-05  Scott Peterson  <lunchtimemama@gmail.com>
+
+	This adds runtime generic variance support for reference types.
+	This patch is contributed under the MIT/X11 license.
+
+	* class.c: Added mono_class_has_variant_generic_params which determins
+	if a generic class has a variant type parameter. Added
+	mono_class_is_variant_of which determins if the first class is a legal
+	variant of the second. Added mono_class_interface_offset_with_variance
+	to look for interfaces in a variance-aware fashion. Modified
+	mono_class_is_assignable_from to use the two new methods.
+
 2009-02-01  Zoltan Varga  <vargaz@gmail.com>
 
 	* debug-mono-symfile.c (check_line): Return NULL instead of returning
Index: mono/mini/ChangeLog
===================================================================
--- mono/mini/ChangeLog	(revision 125681)
+++ mono/mini/ChangeLog	(working copy)
@@ -1,3 +1,11 @@
+2009-02-05  Scott Peterson  <lunchtimemama@gmail.com>
+
+	Contrubuted under the MIT/X11 license.
+
+	* mini-trampolines.cs: Use the
+	new mono_class_interface_offset_with_variance method to find interface
+	offsets.
+
 2009-02-04  Mark Probst  <mark.probst@gmail.com>
 
 	Contributed under the terms of the MIT/X11 license by Steven
Index: mono/mini/mini-trampolines.c
===================================================================
--- mono/mini/mini-trampolines.c	(revision 125681)
+++ mono/mini/mini-trampolines.c	(working copy)
@@ -60,7 +60,7 @@
 		int interface_offset;
 		int imt_slot = MONO_IMT_SIZE + displacement;
 
-		interface_offset = mono_class_interface_offset (vt->klass, imt_method->klass);
+		interface_offset = mono_class_interface_offset_with_variance (vt->klass, imt_method->klass);
 
 		if (interface_offset < 0) {
 			g_print ("%s doesn't implement interface %s\n", mono_type_get_name_full (&vt->klass->byval_arg, 0), mono_type_get_name_full (&imt_method->klass->byval_arg, 0));
Index: mono/tests/generic-variance2.cs
===================================================================
--- mono/tests/generic-variance2.cs	(revision 0)
+++ mono/tests/generic-variance2.cs	(revision 0)
@@ -0,0 +1,28 @@
+// Compiler options: -langversion:future
+
+interface IFoo<in T> {
+	string Bar (T t);
+}
+
+class Foo : IFoo<object> {
+	public string Bar (object t) {
+		return t.GetType ().FullName;
+	}
+}
+
+public class Test {
+	static int Main () {
+		IFoo<object> foo = new Foo ();
+		IFoo<string> foo2 = foo;
+
+		if (foo2.Bar ("blah") != typeof (string).FullName)
+			return 1;
+
+		foo2 = new Foo();
+		if (foo2.Bar ("blah") != typeof (string).FullName)
+			return 2;
+		
+
+		return 0;
+	}
+}
Index: mono/tests/generic-variance3.cs
===================================================================
--- mono/tests/generic-variance3.cs	(revision 0)
+++ mono/tests/generic-variance3.cs	(revision 0)
@@ -0,0 +1,14 @@
+// Compiler options: -langversion:future
+
+delegate T Foo<out T> ();
+
+public class Test {
+	static int Main () {
+		string message = "Who is John Galt?";
+		Foo<string> foo = delegate () { return message; } }
+		Foo<object> foo2 = foo;
+		if (foo2 ().GetHashCode () != message.GetHashCode ())
+			return 1;
+		return 0;
+	}
+}
Index: mono/tests/generic-variance.cs
===================================================================
--- mono/tests/generic-variance.cs	(revision 0)
+++ mono/tests/generic-variance.cs	(revision 0)
@@ -0,0 +1,29 @@
+// Compiler options: -langversion:future
+
+interface IFoo<out T> {
+	T Bar { get; }
+}
+
+class Foo : IFoo<string> {
+	readonly string bar;
+	public Foo (string bar) {
+		this.bar = bar;
+	}
+	public string Bar { get { return bar; } }
+}
+
+public class Test {
+	static int Main () {
+		string bar = "Who is John Galt?";
+		IFoo<string> foo = new Foo(bar);
+		IFoo<object> foo2 = foo;
+		if (!foo2.Bar.Equals (bar))
+			return 1;
+
+		foo2 = new Foo(bar);
+		if (foo2.Bar != bar)
+			return 2;
+
+		return 0;
+	}
+}
Index: mono/tests/generic-variance4.cs
===================================================================
--- mono/tests/generic-variance4.cs	(revision 0)
+++ mono/tests/generic-variance4.cs	(revision 0)
@@ -0,0 +1,14 @@
+// Compiler options: -langversion:future
+
+delegate int Foo<in T> (T t);
+
+public class Test {
+	static int Main () {
+		string message = "Who is John Galt?";
+		Foo<object> foo = delegate (object o) { return o.GetHashCode (); } }
+		Foo<string> foo2 = foo;
+		if (foo2 (message) != message.GetHashCode ())
+			return 1;
+		return 0;
+	}
+}
Index: mono/tests/ChangeLog
===================================================================
--- mono/tests/ChangeLog	(revision 125681)
+++ mono/tests/ChangeLog	(working copy)
@@ -1,3 +1,12 @@
+2009-02-05  Scott Peterson  <lunchtimemama@gmail.com>
+
+	Contrubuted under the MIT/X11 license.
+
+	* generics-variance.cs:
+	* generics-variance2.cs:
+	* generics-variance3.cs:
+	* generics-variance4.cs: Added variance tests.
+
 2009-02-02  Zoltan Varga  <vargaz@gmail.com>
 
 	* generics-invoke-byref.2.cs: Add a test for #471259.