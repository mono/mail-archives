Index: Collection.cs
===================================================================
--- Collection.cs	(revision 46228)
+++ Collection.cs	(working copy)
@@ -3,13 +3,16 @@
 // System.Collections.ObjectModel.Collection
 //
 // Author:
 //    Zoltan Varga (vargaz@gmail.com)
+//    David Waite (mass@akuma.org)
 //
 // (C) 2005 Novell, Inc.
+// (C) 2005 David Waite
 //
 
 //
 // Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2005 David Waite
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -43,147 +46,190 @@
 	[Serializable]
 	public class Collection<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable
 	{
+		IList<T> list;
+		object syncRoot;
+		
 		public Collection ()
 		{
-			throw new NotImplementedException ();
+			List<T> l = new List<T>();
+			IList l2 = l as IList;
+			syncRoot = l2.SyncRoot;
+			list = l;
 		}
 
 		public Collection (IList<T> list)
 		{
-			throw new NotImplementedException ();
+			if (list == null)
+				throw new ArgumentNullException("list");
+			this.list = list;
+			ICollection l = list as ICollection;
+			syncRoot = (l != null) ? l.SyncRoot : new object();
 		}
 
 		public void Add (T item)
 		{
-			throw new NotImplementedException ();
+			list.Add(item);			
 		}
 
 		public void Clear ()
 		{
-			throw new NotImplementedException ();
+			list.Clear();
 		}
 
 		public bool Contains (T item)
 		{
-			throw new NotImplementedException ();
+			return list.Contains(item);
 		}
 
 		public void CopyTo (T[] array, int index)
 		{
-			throw new NotImplementedException ();
+			list.CopyTo(array, index);
 		}
 
 		public IEnumerator<T> GetEnumerator ()
 		{
-			throw new NotImplementedException ();
+			return list.GetEnumerator();
 		}
 
 		public int IndexOf (T item)
 		{
-			throw new NotImplementedException ();
+			return list.IndexOf(item);
 		}
 
 		public void Insert (int index, T item)
 		{
-			throw new NotImplementedException ();
+			list.Insert (index, item);
 		}
 
 		public bool Remove (T item)
 		{
-			throw new NotImplementedException ();
+			return list.Remove(item);
 		}
 
 		public void RemoveAt (int index)
 		{
-			throw new NotImplementedException ();
+			list.RemoveAt (index);
 		}
 
 		public virtual int Count {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return list.Count; }
 		}
 
 		public virtual T this [int index] {
 			get {
-				throw new NotImplementedException ();
+				return list[index];
 			}
 			set {
-				throw new NotImplementedException ();
+				list[index] = value;
 			}
 		}
 
 		public bool IsReadOnly {
-			get {
-				throw new NotImplementedException ();
+			get { return list.IsReadOnly; }
+		}
+#region Helper methods for non-generic interfaces
+		internal static bool IsValidItem(object item)
+		{
+			return (item is T || 
+				(item == null && ! typeof(T).IsValueType));
+		}
+		
+		internal static T ConvertItem(object item)
+		{
+			if (IsValidItem(item))
+			{
+				return (T)item;
 			}
+			throw new ArgumentException("item");
 		}
+		
+		internal static void CheckWritable(IList<T> list)
+		{
+			if (list.IsReadOnly)
+				throw new NotSupportedException();
+		}
+		
+		internal static bool IsSynchronized(IList<T> list)
+		{
+			ICollection c = list as ICollection;
+			return (c != null) ? c.IsSynchronized : false;
+		}
+		
+		internal static bool IsFixedSize(IList<T> list)
+		{
+			IList l	 = list as IList;
+			return (l != null) ? l.IsFixedSize : false;
+		}
+#endregion
 
 #region Not generic interface implementations
 		void ICollection.CopyTo (Array array, int arrayIndex)
 		{
-			throw new NotImplementedException ();
+			T[] target = array as T[];
+			if (target == null)
+				throw new ArgumentException("array");
+			list.CopyTo (target, arrayIndex);
 		}
 		
 		IEnumerator IEnumerable.GetEnumerator()
 		{
-			throw new NotImplementedException ();
+			return (IEnumerator) list.GetEnumerator();
 		}
-		
+				
 		int IList.Add (object item)
 		{
-			throw new NotImplementedException ();
+			list.Add(ConvertItem(item));
+			return list.Count - 1;
 		}
 		
 		bool IList.Contains (object item)
 		{
-			throw new NotImplementedException ();
+			if (IsValidItem(item))
+			{
+				return list.Contains((T)item);
+			}
+			return false;
 		}
 		
 		int IList.IndexOf (object item)
 		{
-			throw new NotImplementedException ();
+			if (IsValidItem(item))
+			{
+				return list.IndexOf((T)item);
+			}
+			return -1;
 		}
 		
 		void IList.Insert (int index, object item)
 		{
-			throw new NotImplementedException ();
+			list.Insert(index, ConvertItem(item));
 		}
 		
 		void IList.Remove (object item)
 		{
-			throw new NotImplementedException ();
+			CheckWritable(list);
+			list.Remove(ConvertItem(item));
 		}
 		
 		bool ICollection.IsSynchronized {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return IsSynchronized (list); }
 		}
 		
 		object ICollection.SyncRoot {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return syncRoot; }
 		}
 		bool IList.IsFixedSize {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return IsFixedSize (list); }
 		}
 		
 		bool IList.IsReadOnly {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return list.IsReadOnly; }
 		}
 		
 		object IList.this [int index] {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return list[index]; }
 			set {
-				throw new NotImplementedException ();
+				list[index] = ConvertItem(value);
 			}
 		}
 #endregion
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 46228)
+++ ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2005-06-19  David Waite  <mass@akuma.org>
+
+        * Collection.cs ReadonlyCollection.cs: Implement all methods
+
 2005-06-19  Zoltan Varga  <vargaz@freemail.hu>
 
 	* Collection.cs KeyedCollection.cs ReadOnlyCollection.cs: New files.
Index: ReadOnlyCollection.cs
===================================================================
--- ReadOnlyCollection.cs	(revision 46228)
+++ ReadOnlyCollection.cs	(working copy)
@@ -3,13 +3,16 @@
 // System.Collections.ObjectModel.ReadOnlyCollection
 //
 // Author:
 //    Zoltan Varga (vargaz@gmail.com)
+//    David Waite (mass@akuma.org)
 //
 // (C) 2005 Novell, Inc.
+// (C) 2005 David Waite
 //
 
 //
 // Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2005 David Waite
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -42,143 +45,146 @@
 	[Serializable]
 	public class ReadOnlyCollection<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable
 	{
+		IList<T> list;
+		object syncRoot;
+		
 		public ReadOnlyCollection (IList<T> list)
 		{
-			throw new NotImplementedException ();
+			if (list == null)
+				throw new ArgumentNullException("list");
+			this.list = list;
+			ICollection c = list as ICollection;
+			syncRoot = (c != null) ? c.SyncRoot : new object();
 		}
 
 		public void Add (T item)
 		{
-			throw new NotImplementedException ();
+			throw new NotSupportedException ();
 		}
-
+		
 		public void Clear ()
 		{
-			throw new NotImplementedException ();
+			throw new NotSupportedException ();
 		}
 
 		public bool Contains (T item)
 		{
-			throw new NotImplementedException ();
+			return list.Contains (item);
 		}
 
-		public void CopyTo (T[] array, int index)
+		public void CopyTo (T [] array, int index)
 		{
-			throw new NotImplementedException ();
+			list.CopyTo (array, index);
 		}
 
 		public IEnumerator<T> GetEnumerator ()
 		{
-			throw new NotImplementedException ();
+			return list.GetEnumerator ();
 		}
 
 		public int IndexOf (T item)
 		{
-			throw new NotImplementedException ();
+			return list.IndexOf (item);
 		}
 
 		public void Insert (int index, T item)
 		{
-			throw new NotImplementedException ();
+			throw new NotSupportedException ();
 		}
 
 		public bool Remove (T item)
 		{
-			throw new NotImplementedException ();
+			throw new NotSupportedException ();
 		}
 
 		public void RemoveAt (int index)
 		{
-			throw new NotImplementedException ();
+			throw new NotSupportedException ();
 		}
 
-		public virtual int Count {
-			get {
-				throw new NotImplementedException ();
-			}
+		public int Count {
+			get { return list.Count; }
 		}
 
-		public virtual T this [int index] {
+		public T this [int index] {
 			get {
-				throw new NotImplementedException ();
+				return list [index];
 			}
 			set {
-				throw new NotImplementedException ();
+				throw new NotSupportedException ();
 			}
 		}
 
 		public bool IsReadOnly {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return true; }
 		}
 
 #region Not generic interface implementations
 		void ICollection.CopyTo (Array array, int arrayIndex)
 		{
-			throw new NotImplementedException ();
+			T[] target = array as T[];
+			if (target == null)
+				throw new ArgumentException("array");
+			list.CopyTo (target, arrayIndex);
 		}
-		
+				
 		IEnumerator IEnumerable.GetEnumerator()
 		{
-			throw new NotImplementedException ();
+			return ((IEnumerable)list).GetEnumerator();
 		}
 		
 		int IList.Add (object item)
 		{
-			throw new NotImplementedException ();
+			throw new NotSupportedException ();
 		}
 		
 		bool IList.Contains (object item)
 		{
-			throw new NotImplementedException ();
+			if (Collection<T>.IsValidItem(item))
+			{
+				return list.Contains((T)item);
+			}
+			return false;
 		}
 		
 		int IList.IndexOf (object item)
 		{
-			throw new NotImplementedException ();
+			if (Collection<T>.IsValidItem(item))
+			{
+				return list.IndexOf((T)item);
+			}
+			return -1;
 		}
 		
 		void IList.Insert (int index, object item)
 		{
-			throw new NotImplementedException ();
+			throw new NotSupportedException ();
 		}
 		
 		void IList.Remove (object item)
 		{
-			throw new NotImplementedException ();
+			throw new NotSupportedException ();
 		}
 		
 		bool ICollection.IsSynchronized {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return Collection<T>.IsSynchronized(list); }
 		}
 		
 		object ICollection.SyncRoot {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return syncRoot; }
 		}
+
 		bool IList.IsFixedSize {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return Collection<T>.IsFixedSize(list); }
 		}
 		
 		bool IList.IsReadOnly {
-			get {
-				throw new NotImplementedException ();
-			}
+			get { return true; }
 		}
 		
 		object IList.this [int index] {
-			get {
-				throw new NotImplementedException ();
-			}
-			set {
-				throw new NotImplementedException ();
-			}
+			get { return list[index]; }
+			set { throw new NotSupportedException (); }
 		}
 #endregion
 	}