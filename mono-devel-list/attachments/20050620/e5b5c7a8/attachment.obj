Index: corlib/System.Collections.Generic/List.cs
===================================================================
--- corlib/System.Collections.Generic/List.cs	(revision 46228)
+++ corlib/System.Collections.Generic/List.cs	(working copy)
@@ -5,12 +5,15 @@
 //    Ben Maurer (bmaurer@ximian.com)
 //    Martin Baulig (martin@ximian.com)
 //    Carlos Alberto Cortez (calberto.cortez@gmail.com)
+//    David Waite (mass@akuma.org)
 //
 // (C) 2004 Novell, Inc.
+// (C) 2005 David Waite
 //
 
 //
 // Copyright (C) 2004 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2005 David Waite
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -35,69 +38,134 @@
 #if NET_2_0
 using System;
 using System.Collections;
+using System.Collections.ObjectModel;
 using System.Runtime.InteropServices;
 
 namespace System.Collections.Generic {
 	[Serializable]
-	public class List<T> : IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable {
+	public class List<T> : IList<T>, IList, ICollection {
 		T [] data;
 		int size;
 		int version;
-			
+		
+		static T[] EmptyArray = new T[0]; 
 		const int DefaultCapacity = 4;
 		
 		public List ()
 		{
-			data = new T [DefaultCapacity];
+			data = EmptyArray;
 		}
 		
 		public List (IEnumerable <T> collection)
 		{
-			AddRange (collection);
+			CheckCollection(collection);
+
+			// initialize to needed size (if determinable)
+			ICollection <T> c = collection as ICollection<T>
+			if (c != null)
+			{
+				data = new T[c.Count];
+				AddCollection(c);
+			}
+			else
+			{
+				data = EmptyArray;
+				AddEnumerable(enumerable);
+			}
 		}
 		
 		public List (int capacity)
 		{
+			if (capacity < 0)
+				throw new ArgumentOutOfRangeException("capacity");
 			data = new T [capacity];
 		}
 		
+		internal List(T[] data, int size)
+		{
+			this.data = data;
+			this.size = size;
+		}
 		public void Add (T item)
 		{
 			if (size == data.Length)
-				Capacity = Math.Max (Capacity * 2, DefaultCapacity);
-			
+				Capacity = GrowSize();
 			data [size ++] = item;
 		}
 		
+		int GrowSize()
+		{
+			return Math.Max (Capacity *2, DefaultCapacity);
+		}
+
+		void GrowByCount(int newCount)
+		{
+			int minimumSize = size + newCount;
+
+			// resize internal array
+			int newSize = data.Length;
+			while (newSize < minimumSize)
+			{
+				newSize = GrowSize();
+			}
+			Capacity = newSize;			  
+		}
+		
 		void CheckRange (int idx, int count)
 		{
 			if (idx < 0)
-				throw new ArgumentOutOfRangeException ("index must be equal or larger than zero");
+				throw new ArgumentOutOfRangeException ("index");
 			
-			if (count < 0 || idx > size - count)
-				throw new ArgumentOutOfRangeException ("Count must refer to an element in the list");
+			if (count < 0)
+				throw new ArgumentOutOfRangeException ("count");
+
+			if (idx + count > size)
+				throw new ArgumentException("index and count exceed length of list");
 		}
 		
-		[MonoTODO ("PERFORMANCE: fix if it is an IList <T>")]
-		public void AddRange(IEnumerable<T> collection)
+		void AddCollection(ICollection<T> collection)
 		{
-			foreach (T t in collection)
+			int collectionCount = collection.Count;
+			GrowByCount(collectionCount);			 
+			collection.CopyTo(data, size);
+			size += collectionCount;
+		}
+		void AddEnumerable(IEnumerable<T> enumerable)
+		{
+			foreach (T t in enumerable)
+			{
 				Add (t);
+			}
 		}
+
+		public void AddRange(IEnumerable<T> collection)
+		{
+			CheckCollection(collection);
+			
+			ICollection<T> c = enumerable as ICollection<T>;
+			if (c != null)
+			{ 
+				AddCollection(c);
+			}
+			else
+			{
+				AddEnumerable(collection);
+			}
+		}
 		
-		public IList<T> AsReadOnly ()
+		public ReadOnlyCollection<T> AsReadOnly ()
 		{
-			return new ReadOnlyList<T>(this);
+			return new ReadOnlyCollection<T>(this);
 		}
 		
 		public int BinarySearch(T item)
 		{
-			return BinarySearch (item, Comparer <T>.Default);
+			return Array.BinarySearch (data, item);
 		}
 		
 		public int BinarySearch(T item, IComparer<T> comparer)
 		{
-			return BinarySearch (0, size, item, comparer);
+			return Array.BinarySearch (data, item, comparer);
 		}
 		
 		public int BinarySearch(int index, int count, T item, IComparer<T> comparer)
@@ -109,6 +177,7 @@
 		public void Clear ()
 		{
 			Array.Clear (data, 0, data.Length);
+			size = 0;
 		}
 		
 		public bool Contains (T item)
@@ -118,22 +187,22 @@
 		
 		public List <TOutput> ConvertAll <TOutput> (Converter<T, TOutput> converter)
 		{
+			if (converter == null)
+				throw new ArgumentNullException("converter");
 			List <TOutput> u = new List <TOutput> (size);
-			int i = 0;
 			foreach (T t in this)
-				u [i ++] = converter (t);
-			
+				u.Add(converter(t));			
 			return u;
 		}
 		
 		public void CopyTo (T [] array)
 		{
-			CopyTo (array, 0);
+			Array.Copy (data, 0, array, 0, size);
 		}
 		
 		public void CopyTo (T [] array, int arrayIndex)
 		{
-			CopyTo (0, array, arrayIndex, size);
+			Array.Copy (data, 0, array, arrayIndex, size);
 		}
 		
 		public void CopyTo (int index, T[] array, int arrayIndex, int count)
@@ -144,27 +213,26 @@
 
 		public bool Exists (Predicate<T> match)
 		{
-			foreach (T t in this)
-				if (match (t))
-					return true;
-			
-			return false;
+			return FindIndex(match) != -1;
 		}
 		
 		public T Find (Predicate<T> match)
 		{
-			foreach (T t in this)
-				if (match (t))
-					return t;
-			
-			return default (T);
+			int i = FindIndex(match);
+			return (i != -1) ? data[i] : default (T);
 		}
+		void CheckMatch(Predicate<T> match)
+		{
+			if (match == null)
+				throw new ArgumentNullException("match");
+		}
 		
 		// Maybe we could make this faster. For example, you could
 		// make a bit set with stackalloc for which elements to copy
 		// then you could size the array correctly.
 		public List<T> FindAll (Predicate<T> match)
 		{
+			CheckMatch(match);
 			List <T> f = new List <T> ();
 			
 			foreach (T t in this)
@@ -176,18 +244,24 @@
 		
 		public int FindIndex (Predicate <T> match)
 		{
-			return FindIndex (0, match);
+			CheckMatch (match);
+			return GetIndex (0, size, match);
 		}
 		
 		public int FindIndex (int startIndex, Predicate <T> match)
 		{
-			return FindIndex (startIndex, size - startIndex, match);
+			CheckMatch (match);
+			CheckIndex (startIndex);
+			return GetIndex (startIndex, size - startIndex, match);
 		}
-		
 		public int FindIndex (int startIndex, int count, Predicate <T> match)
 		{
+			CheckMatch (match);
 			CheckRange (startIndex, count);
-			
+			return GetIndex(startIndex, count, match);
+		}
+		int GetIndex (int startIndex, int count, Predicate <T> match)
+		{
 			for (int i = startIndex; i < startIndex + count; i ++)
 				if (match (data [i]))
 					return i;
@@ -197,32 +271,45 @@
 		
 		public T FindLast (Predicate <T> match)
 		{
-			int i = FindLastIndex (match);
+			CheckMatch (match);
+			int i = GetLastIndex (0, size, match);
 			return i == -1 ? default (T) : this [i];
 		}
 		
 		public int FindLastIndex (Predicate <T> match)
 		{
-			return FindLastIndex (0, match);
+			CheckMatch (match);
+			return GetLastIndex (0, size, match);
 		}
 		
 		public int FindLastIndex (int startIndex, Predicate <T> match)
 		{
-			return FindLastIndex (startIndex, size - startIndex, match);
+			CheckMatch (match);
+			CheckIndex (startIndex);
+			return GetLastIndex (0, startIndex + 1, match);
 		}
 		
 		public int FindLastIndex (int startIndex, int count, Predicate <T> match)
 		{
-			CheckRange (startIndex, count);
+			CheckMatch (match);
+			int start = startIndex - count + 1;
+			CheckRange (start, count);
+			return GetLastIndex(start, count, match);
+		}
+
+		int GetLastIndex(int startIndex, int count, Predicate<T> match)
+		{
+			// unlike FindLastIndex, takes regular params for search range
 			for (int i = startIndex + count; i != startIndex;)
 				if (match (data [--i]))
 					return i;
-				
 			return -1;	
 		}
 		
 		public void ForEach (Action <T> action)
 		{
+			if (action == null)
+				throw new ArgumentNullException("action");
 			foreach (T t in this)
 				action (t);
 		}
@@ -235,23 +322,20 @@
 		public List <T> GetRange (int index, int count)
 		{
 			CheckRange (index, count);
-			List<T> result = new List<T> (count);
-
-			result.size = count;
-			for (int i = 0; i < count; i++)
-				result.data [i] = data [i+index];
-
-			return result;
+			T[] tmpArray = new T[count];
+			Array.Copy(data, index, tmpArray, 0, count);
+			return new List<T> (tmpArray, count);
 		}
 		
 		public int IndexOf (T item)
 		{
-			return IndexOf (item, 0);
+			return Array.IndexOf(data, item, 0, size);
 		}
 		
 		public int IndexOf (T item, int index)
 		{
-			return IndexOf (item, index, size - index);
+			CheckIndex (index);
+			return Array.IndexOf (data, item, index, size - index);
 		}
 		
 		public int IndexOf (T item, int index, int count)
@@ -269,6 +353,12 @@
 			
 			size += delta;
 		}
+
+		void CheckIndex (int index)
+		{
+			if ((uint) index >= (uint) size)
+				throw new ArgumentOutOfRangeException ("index");
+		}
 		
 		public void Insert (int index, T item)
 		{
@@ -276,31 +366,60 @@
 				throw new ArgumentOutOfRangeException ("index");
 			
 			if (size == data.Length)
-				 Capacity = Math.Max (Capacity * 2, DefaultCapacity);
+				Capacity = GrowSize();
 			Shift (index, 1);
 			this [index] = item;
 				
 		}
-		[MonoTODO ("Performance for collection")]
-		public void InsertRange (int index, IEnumerable<T> collection)
+
+		void CheckCollection(IEnumerable<T> collection)
 		{
-			foreach (T t in collection)
-				Insert (index ++, t);
+			if (collection == null)
+				throw new ArgumentNullException("collection");
 		}
 		
+		public void InsertRange (int index, IEnumerable<T> enumerable)
+		{
+			CheckEnumerable(enumerable);				
+			CheckIndex(index);			  
+			if (enumerable is ICollection<T>)
+			{
+				InsertCollection(index, enumerable as ICollection<T>);
+			}
+			else
+			{
+				InsertEnumeration(index, enumerable);
+			}
+		}
+
+		void InsertCollection(int index, ICollection<T> collection)
+		{
+			int collectionCount = collection.Count;
+			GrowByCount(collectionCount);
+			
+			Shift (index, collectionCount);
+			collection.CopyTo(data, index);
+		}
+		void InsertEnumeration(int index, IEnumerable<T> enumerable)
+		{
+			foreach (T t in enumerable)
+				Insert (index++, t);		
+		}
+
 		public int LastIndexOf (T item)
 		{
-			return LastIndexOf  (item, 0);
+			return Array.LastIndexOf (data, item, 0, size);
 		}
 		
 		public int LastIndexOf  (T item, int index)
 		{
-			return LastIndexOf  (item, index, size - index);
+			CheckIndex(index);
+			return Array.LastIndexOf (data, item, index, size - index);
 		}
 		
 		public int LastIndexOf (T item, int index, int count)
 		{
-			CheckRange (index, count);
+			CheckRange(index, count);			 
 			return Array.LastIndexOf (data, item, index, count);
 		}
 		
@@ -316,30 +435,36 @@
 		[MonoTODO ("I can make it faster than this...")]
 		public int RemoveAll (Predicate<T> match)
 		{
+			CheckMatch(match);
+
 			int index = 0;
 			int c = 0;
-			while ((index = FindIndex (index, match)) != -1) {
+			while ((index = GetIndex (index, size - index, match)) != -1) {
 				RemoveAt (index);
 				c ++;
 			}
 			
+			Array.Clear(data, size, c);
 			return c;
 		}
 		
 		public void RemoveAt (int index)
 		{
-			RemoveRange (index, 1);
+			CheckIndex (index);
+			Shift (index, -1);
+			Array.Clear(data, size, 0);
 		}
 		
 		public void RemoveRange (int index, int count)
 		{
 			CheckRange (index, count);
 			Shift (index, -count);
+			Array.Clear(data, size, count);
 		}
 		
 		public void Reverse ()
 		{
-			Reverse (0, size);
+			Array.Reverse (data, 0, size);
 		}
 		public void Reverse (int index, int count)
 		{
@@ -349,11 +474,11 @@
 		
 		public void Sort ()
 		{
-			Sort (Comparer <T>.Default);
+			Array.Sort (data, 0, size, (IComparer) Comparer<T>.Default);
 		}
 		public void Sort (IComparer<T> comparer)
 		{
-			Sort (0, size, comparer);
+			Array.Sort (data, 0, size, (IComparer) comparer);
 		}
 		
 		// Waiting on Array
@@ -363,29 +488,29 @@
 			throw new NotImplementedException ();
 		}
 		
-		[MonoTODO]
 		public void Sort (int index, int count, IComparer<T> comparer)
 		{
 			CheckRange (index, count);
-			throw new NotImplementedException ();
+			Array.Sort(data, index, count, (IComparer) comparer);
 		}
 
 		public T [] ToArray ()
 		{
 			T [] t = new T [size];
-			if (data != null)
-				Array.Copy (data, t, size);
+			Array.Copy (data, t, size);
 			
 			return t;
 		}
 		
-		public void TrimToSize ()
+		public void TrimExcess ()
 		{
 			Capacity = size;
 		}
 		
 		public bool TrueForAll (Predicate <T> match)
 		{
+			CheckMatch(match);
+
 			foreach (T t in this)
 				if (!match (t))
 					return false;
@@ -411,13 +536,11 @@
 		
 		public T this [int index] {
 			get {
-				if ((uint) index >= (uint) size)
-					throw new IndexOutOfRangeException ();
+				CheckIndex(index);
 				return data [index];
 			}
 			set {
-				if ((uint) index >= (uint) size)
-					throw new IndexOutOfRangeException ();
+				CheckIndex(index);
 				data [index] = value;
 			}
 		}
@@ -430,7 +553,7 @@
 		
 		void ICollection.CopyTo (Array array, int arrayIndex)
 		{
-			Array.Copy (data, 0, data, arrayIndex, size);
+			Array.Copy (data, 0, array, arrayIndex, size);
 		}
 		
 		IEnumerator IEnumerable.GetEnumerator()
@@ -487,89 +610,7 @@
 			set { this [index] = (T) value; }
 		}
 #endregion
-		
-		[ComVisible (false)]
-		internal class ReadOnlyList<I> : IList<I>, ICollection<I>, IEnumerable<I>
-		{
-			IList<I> list;
-		
-			internal ReadOnlyList (IList<I> list)
-			{
-				this.list = list;
-			}
-
-			public void Add (I item)
-			{
-				throw new NotSupportedException ();
-			}
-			
-			public void Clear ()
-			{
-				throw new NotSupportedException ();
-			}
-
-			public bool Contains (I item)
-			{
-				return list.Contains (item);
-			}
-
-			public void CopyTo (I [] array, int index)
-			{
-				list.CopyTo (array, index);
-			}
-
-			public IEnumerator<I> GetEnumerator ()
-			{
-				return list.GetEnumerator ();
-			}
-
-			IEnumerator IEnumerable.GetEnumerator ()
-			{
-				return ((IEnumerable) list).GetEnumerator ();
-			}
-			
-			public int IndexOf (I item)
-			{
-				return list.IndexOf (item);
-			}
-
-			public void Insert (int index, I item)
-			{
-				throw new NotSupportedException ();
-			}
-
-			public bool Remove (I item)
-			{
-				throw new NotSupportedException ();
-			}
-
-			public void RemoveAt (int index)
-			{
-				throw new NotSupportedException ();
-			}
-
-			public int Count {
-				get {
-					return list.Count;
-				}
-			}
-
-			public bool IsReadOnly {
-				get {
-					return true;
-				}
-			}
-
-			public I this [int index] {
-				get {
-					return list [index];
-				}
-				set {
-					throw new NotSupportedException ();
-				}
-			}
-		}
-		
+				
 		public struct Enumerator : IEnumerator <T>, IDisposable {
 			const int NOT_STARTED = -2;
 			
Index: corlib/System.Collections.Generic/ChangeLog
===================================================================
--- corlib/System.Collections.Generic/ChangeLog	(revision 46228)
+++ corlib/System.Collections.Generic/ChangeLog	(working copy)
@@ -1,3 +1,22 @@
+2005-06-20  David waite  <mass@akuma.org>
+
+    * List.cs : substantial changes and optimizations
+    (AddCollection, AddEnumerable): new internal specializations of AddRange
+    (AsReadOnly): returns specific IList<T> to match ms.net 2.0b2 api.
+    (Clear): reset size to zero on clear
+    (ConvertAll): catch null converter, use Add to prevent OutOfBounds
+    exception
+    (FindAll, FindIndex, FindLast, FindLastIndex, RemoveAll, TrueForAll): 
+    check for null match
+    (FindLastIndex): correct index parameters based on ms.net 2005b2 behavior
+    (ForEach): catch null action
+    (CheckIndex): new internal function similar to CheckRange for functions
+    which only provide a starting index
+    (InsertCollection, InsertEnumerable): new internal specializations of
+    InsertRange
+    (ReadOnlyList): removed, ReadOnlyCollection in 
+    System.Collections.ObjectModel is used instead now 
+    
 2005-06-16  David Waite  <mass@akuma.org>
 
 	* Dictionary.cs (EnumerationMode): Remove.
Index: corlib/Test/System.Collections.Generic/ListTest.cs
===================================================================
--- corlib/Test/System.Collections.Generic/ListTest.cs	(revision 46228)
+++ corlib/Test/System.Collections.Generic/ListTest.cs	(working copy)
@@ -9,74 +9,520 @@
 namespace MonoTests.System.Collections.Generic {
 
 	[TestFixture]
-	public class ListTest : Assertion {
+	public class ListTest
+	{
 
+		int[] _list1_contents;
+        List<int> _list1;
+
 		[SetUp]
-		public void SetUp ()
+		public void SetUp()
 		{
+            // FIXME arrays currently do not support generic collection
+            // interfaces
+            _list1_contents = new int[] { 55, 50, 22, 80, 56, 52, 40, 63 };
+			// _list1 = new List<int>(_list1_contents);
+			
+			_list1 = new List<int>(8);
+			foreach (int i in _list1_contents)
+			{
+    			_list1.Add(i);
+			}
 		}
 
 		[Test]  // This was for bug #74980
-		public void TestInsertion ()
+		public void InsertTest()
 		{
 			List<string> test = new List<string>();
 			test.Insert(0, "a");
 			test.Insert(0, "b");
+			test.Insert(1, "c");
+
+			Assert.AreEqual(3, test.Count);
+			Assert.AreEqual("b", test[0]);
+			Assert.AreEqual("c", test[1]);
+			Assert.AreEqual("a", test[2]);
 		}
 
 		[Test]
-		public void TestOutOfRange ()
+		public void InsertRangeTest()
 		{
-			List<int> l = new List<int> (4);
+			int count = _list1.Count;
+			// FIXME arrays currently do not support generic collection 
+			// interfaces
+			int[] items = {1, 2, 3};
+			// List<int> newRange = new List<int>(items);
+			List<int> newRange = new List<int>(3);
+			foreach (int i in items)
+			{
+                newRange.Add(i);
+            }
+			_list1.InsertRange(1, newRange);
+			Assert.AreEqual(count + 3, _list1.Count);
+			Assert.AreEqual(55, _list1[0]);
+			Assert.AreEqual(1, _list1[1]);
+			Assert.AreEqual(2, _list1[2]);
+			Assert.AreEqual(3, _list1[3]);
+			Assert.AreEqual(50, _list1[4]);
+		}
 
-			bool errorThrown = false;
-			try {
-				l.IndexOf (0, 0, 4);
-			} catch (ArgumentOutOfRangeException){
-				errorThrown = true;
-			}
-			Assert ("Out of range count exception not thrown", errorThrown);
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void InsertRangeNullTest()
+		{
+			IEnumerable<int> n = null;
+			_list1.InsertRange(0, n);
 		}
 
 		[Test]
-		public void TestIndexOf ()
+		public void IndexOfTest()
 		{
 			List<int> l = new List<int>();
 
-			l.Add (100);
-			l.Add (200);
+			l.Add(100);
+			l.Add(200);
 
-			Assert ("Could not find value", l.IndexOf (200) == 1);
+			Assert.AreEqual(1, l.IndexOf(200), "Could not find value");
 		}
 
-		static List<int> MakeList()
+		[Test, ExpectedException(typeof(ArgumentException))]
+		public void IndexOfOutOfRangeTest()
 		{
-			List<int> l = new List<int> ();
+			List<int> l = new List<int>(4);
+			l.IndexOf(0, 0, 4);
+		}
 
-			l.Add (55);
-			l.Add (50);
-			l.Add (22);
-			l.Add (80);
-			l.Add (56);
-			l.Add (52);
-			l.Add (40);
-			l.Add (63);
+		[Test]
+		public void GetRangeTest()
+		{
+			List<int> r = _list1.GetRange(2, 4);
+			Assert.AreEqual(4, r.Count);
+			Assert.AreEqual(22, r[0]);
+			Assert.AreEqual(80, r[1]);
+			Assert.AreEqual(56, r[2]);
+			Assert.AreEqual(52, r[3]);
+		}
 
-			return l;
+		[Test]
+		public void EnumeratorTest()
+		{
+			List<int>.Enumerator e = _list1.GetEnumerator();
+			for (int i = 0; i < _list1_contents.Length; i++)
+			{
+				Assert.IsTrue(e.MoveNext());
+				Assert.AreEqual(_list1_contents[i], e.Current);
+			}
+			Assert.IsFalse(e.MoveNext());
 		}
-			
+
 		[Test]
-		public void TestGetRange ()
+		public void ConstructWithSizeTest()
 		{
-			List<int> l = MakeList ();
+			List<object> l_1 = new List<object>(1);
+			List<object> l_2 = new List<object>(50);
+			List<object> l_3 = new List<object>(0);
 
-			List<int> r = l.GetRange (2, 4);
-			AssertEquals ("Size is not correct", 4, r.Count);
-			AssertEquals ("Data failure", 22, r [0]);
-			AssertEquals ("Data failure", 80, r [1]);
-			AssertEquals ("Data failure", 56, r [2]);
-			AssertEquals ("Data failure", 52, r [3]);
+			Assert.AreEqual(1, l_1.Capacity);
+			Assert.AreEqual(50, l_2.Capacity);
+			Assert.AreEqual(0, l_3.Capacity);
 		}
+
+		[Test, ExpectedException(typeof(ArgumentOutOfRangeException))]
+		public void ConstructWithInvalidSizeTest()
+		{
+			List<int> l = new List<int>(-1);
+		}
+
+		[Test]
+		public void ConstructWithCollectionTest()
+		{
+			List<int> l1 = new List<int>(_list1);
+			Assert.AreEqual(_list1.Count, l1.Count);
+			Assert.AreEqual(l1.Count, l1.Capacity);
+			for (int i = 0; i < l1.Count; i++)
+			{
+				Assert.AreEqual(_list1[i], l1[i]);
+			}
+		}
+
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void ConstructWithInvalidCollectionTest()
+		{
+			List<int> n = null;
+			List<int> l1 = new List<int>(n);
+		}
+
+		[Test]
+		public void AddTest()
+		{
+			int count = _list1.Count;
+			_list1.Add(-1);
+			Assert.AreEqual(count + 1, _list1.Count);
+			Assert.AreEqual(-1, _list1[_list1.Count - 1]);
+		}
+
+		[Test]
+		public void AddRangeTest()
+		{
+			int count = _list1.Count;
+            // FIXME arrays currently do not support generic collection
+            // interfaces
+            int[] range = { -1, -2, -3 };
+            List<int> tmp = new List<int>(3);
+            foreach (int i in range)
+                tmp.Add(i);
+            // _list1.AddRange(range);
+            _list1.AddRange(tmp);
+            
+			Assert.AreEqual(count + 3, _list1.Count);
+			Assert.AreEqual(-1, _list1[_list1.Count - 3]);
+			Assert.AreEqual(-2, _list1[_list1.Count - 2]);
+			Assert.AreEqual(-3, _list1[_list1.Count - 1]);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void AddNullRangeTest()
+		{
+			int[] n = null;
+			_list1.AddRange(n);
+		}
+
+		[Test]
+		public void AsReadOnlyTest()
+		{
+			// FIXME: workaround for lack of ReadOnlyCollection<T>
+			ReadOnlyCollection<int> l = _list1.AsReadOnly();
+			Assert.IsTrue(l.IsReadOnly);
+			Assert.AreEqual(_list1.Count, l.Count);
+			try
+			{
+				l.Add(4);
+				Assert.Fail("must fail to modify read-only collection");
+			}
+			catch (NotSupportedException)
+			{ }
+		}
+
+		[Test]
+		public void BinarySearchTest()
+		{
+			List<int> l = new List<int>(_list1);
+			l.Sort();
+			Assert.AreEqual(0, l.BinarySearch(22));
+			Assert.AreEqual(-2, l.BinarySearch(23));
+			Assert.AreEqual(-(l.Count + 1), l.BinarySearch(int.MaxValue));
+		}
+
+		[Test]
+		public void SortTest()
+		{
+			List<int> l = new List<int>(_list1);
+			l.Sort();
+			Assert.AreEqual(_list1.Count, l.Count);
+			Assert.AreEqual(22, l[0]);
+			int minimum = 22;
+			foreach (int i in l)
+			{
+				Assert.IsTrue(minimum <= i);
+				minimum = i;
+			}
+		}
+
+		[Test]
+		public void ClearTest()
+		{
+			int capacity = _list1.Capacity;
+			_list1.Clear();
+			Assert.AreEqual(0, _list1.Count);
+			Assert.AreEqual(capacity, _list1.Capacity);
+		}
+
+		[Test]
+		public void ContainsTest()
+		{
+			Assert.IsTrue(_list1.Contains(22));
+			Assert.IsFalse(_list1.Contains(23));
+		}
+
+		private string StringConvert(int i)
+		{
+			return i.ToString();
+		}
+		[Test]
+		public void ConvertAllTest()
+		{
+			List<string> s = _list1.ConvertAll((Converter<int, string>)StringConvert);
+			Assert.AreEqual(_list1.Count, s.Count);
+			Assert.AreEqual("55", s[0]);
+		}
+
+		[Test]
+		public void CopyToTest()
+		{
+			int[] a = new int[2];
+			_list1.CopyTo(1, a, 0, 2);
+			Assert.AreEqual(50, a[0]);
+			Assert.AreEqual(22, a[1]);
+
+			int[] b = new int[_list1.Count + 1];
+			b[_list1.Count] = 555;
+			_list1.CopyTo(b);
+			Assert.AreEqual(55, b[0]);
+			Assert.AreEqual(555, b[_list1.Count]);
+
+			b[0] = 888;
+			_list1.CopyTo(b, 1);
+			Assert.AreEqual(888, b[0]);
+			Assert.AreEqual(55, b[1]);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void CopyToNullTest()
+		{
+			int[] a = null;
+			_list1.CopyTo(0, a, 0, 0);
+		}
+
+		static bool FindMultipleOfThree(int i)
+		{
+			return (i % 3) == 0;
+		}
+
+		static bool FindMultipleOfFour(int i)
+		{
+			return (i % 4) == 0;
+		}
+
+		static bool FindMultipleOfTwelve(int i)
+		{
+			return (i % 12) == 0;
+		}
+
+		[Test]
+		public void FindTest()
+		{
+			int i = _list1.Find(FindMultipleOfThree);
+			Assert.AreEqual(63, i);
+
+			i = _list1.Find(FindMultipleOfTwelve);
+			Assert.AreEqual(default(int), i);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void FindNullTest()
+		{
+			int i = _list1.Find(null);
+		}
+
+		[Test]
+		public void FindAllTest()
+		{
+			List<int> findings = _list1.FindAll(FindMultipleOfFour);
+			Assert.AreEqual(4, findings.Count);
+			Assert.AreEqual(80, findings[0]);
+			Assert.AreEqual(56, findings[1]);
+			Assert.AreEqual(52, findings[2]);
+			Assert.AreEqual(40, findings[3]);
+
+			findings = _list1.FindAll(FindMultipleOfTwelve);
+			Assert.IsNotNull(findings);
+			Assert.AreEqual(0, findings.Count);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void FindAllNullTest()
+		{
+			List<int> findings = _list1.FindAll(null);
+		}
+
+		[Test]
+		public void FindIndexTest()
+		{
+			int i = _list1.FindIndex(FindMultipleOfThree);
+			Assert.AreEqual(7, i);
+
+			i = _list1.FindIndex(FindMultipleOfTwelve);
+			Assert.AreEqual(-1, i);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void FindIndexNullTest()
+		{
+			int i = _list1.FindIndex(null);
+		}
+
+		[Test]
+		public void FindLastTest()
+		{
+			int i = _list1.FindLast(FindMultipleOfFour);
+			Assert.AreEqual(40, i);
+
+			i = _list1.FindLast(FindMultipleOfTwelve);
+			Assert.AreEqual(default(int), i);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void FindLastNullTest()
+		{
+			int i = _list1.FindLast(null);
+		}
+
+		// FIXME currently generates Invalid IL Code error
+		/*
+		[Test]
+		public void ForEachTest()
+		{
+			int i = 0;
+			_list1.ForEach(delegate(int j) { i += j; });
+
+			Assert.AreEqual(418, i);
+		}
+        */
+		[Test]
+		public void FindLastIndexTest()
+		{
+			int i = _list1.FindLastIndex(FindMultipleOfFour);
+			Assert.AreEqual(6, i);
+
+			i = _list1.FindLastIndex(5, FindMultipleOfFour);
+			Assert.AreEqual(5, i);
+
+			i = _list1.FindIndex(FindMultipleOfTwelve);
+			Assert.AreEqual(-1, i);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void FindLastIndexNullTest()
+		{
+			int i = _list1.FindLastIndex(null);
+		}
+
+		[Test]
+		public void RemoveTest()
+		{
+			int count = _list1.Count;
+			bool result = _list1.Remove(22);
+			Assert.IsTrue(result);
+			Assert.AreEqual(count - 1, _list1.Count);
+
+			Assert.AreEqual(-1, _list1.IndexOf(22));
+
+			result = _list1.Remove(0);
+			Assert.IsFalse(result);
+		}
+
+		[Test]
+		public void RemoveAllTest()
+		{
+			int count = _list1.Count;
+			int removedCount = _list1.RemoveAll(FindMultipleOfFour);
+			Assert.AreEqual(4, removedCount);
+			Assert.AreEqual(count - 4, _list1.Count);
+
+			removedCount = _list1.RemoveAll(FindMultipleOfTwelve);
+			Assert.AreEqual(0, removedCount);
+			Assert.AreEqual(count - 4, _list1.Count);
+		}
+
+		[Test]
+		public void RemoveAtTest()
+		{
+			int count = _list1.Count;
+			_list1.RemoveAt(0);
+			Assert.AreEqual(count - 1, _list1.Count);
+			Assert.AreEqual(50, _list1[0]);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentOutOfRangeException))]
+		public void RemoveOutOfRangeTest()
+		{
+			_list1.RemoveAt(_list1.Count);
+		}
+
+		[Test]
+		public void RemoveRangeTest()
+		{
+			int count = _list1.Count;
+			_list1.RemoveRange(1, 2);
+			Assert.AreEqual(count - 2, _list1.Count);
+			Assert.AreEqual(55, _list1[0]);
+			Assert.AreEqual(80, _list1[1]);
+
+			_list1.RemoveRange(0, 0);
+			Assert.AreEqual(count - 2, _list1.Count);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentException))]
+		public void RemoveRangeOutOfRangeTest()
+		{
+			_list1.RemoveRange(1, _list1.Count);
+		}
+
+		[Test]
+		public void ReverseTest()
+		{
+			int count = _list1.Count;
+			_list1.Reverse();
+			Assert.AreEqual(count, _list1.Count);
+
+			Assert.AreEqual(63, _list1[0]);
+			Assert.AreEqual(55, _list1[count - 1]);
+
+			_list1.Reverse(0, 2);
+
+			Assert.AreEqual(40, _list1[0]);
+			Assert.AreEqual(63, _list1[1]);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentException))]
+		public void ReverseOutOfRangeTest()
+		{
+			_list1.Reverse(1, _list1.Count);
+		}
+
+		[Test]
+		public void ToArrayTest()
+		{
+			int[] copiedContents = _list1.ToArray();
+			Assert.IsFalse(ReferenceEquals(copiedContents, _list1_contents));
+
+			Assert.AreEqual(_list1.Count, copiedContents.Length);
+			Assert.AreEqual(_list1[0], copiedContents[0]);
+		}
+
+		[Test]
+		public void TrimExcessTest()
+		{
+			List<string> l = new List<string>();
+			l.Add("foo");
+
+			Assert.IsTrue(l.Count < l.Capacity);
+			l.TrimExcess();
+			Assert.AreEqual(l.Count, l.Capacity);
+		}
+
+		bool IsPositive(int i)
+		{
+			return i >= 0;
+		}
+		[Test]
+		public void TrueForAllTest()
+		{
+			Assert.IsFalse(_list1.TrueForAll(FindMultipleOfFour));
+			Assert.IsTrue(_list1.TrueForAll(IsPositive));
+		}
+
+		[Test, ExpectedException(typeof(ArgumentNullException))]
+		public void TrueForAllNullTest()
+		{
+			_list1.TrueForAll(null);
+		}
+
+		[Test, ExpectedException(typeof(ArgumentOutOfRangeException))]
+		public void CapacityOutOfRangeTest()
+		{
+			_list1.Capacity = _list1.Count - 1;
+		}
 	}
 }
 #endif
+
Index: corlib/Test/System.Collections.Generic/ChangeLog
===================================================================
--- corlib/Test/System.Collections.Generic/ChangeLog	(revision 46228)
+++ corlib/Test/System.Collections.Generic/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2005-06-20  David Waite  <mass@akuma.org>
+
+    * ListTest.cs: Substantial new tests
+
 2005-06-18  David Waite  <mass@akuma.org>
 
     * DictionaryTest.cs (AddTest3): Added test of simple interaction with