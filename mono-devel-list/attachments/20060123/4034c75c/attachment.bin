Index: mono/mono/mini/mini.c
===================================================================
--- mono/mono/mini/mini.c	(revision 55928)
+++ mono/mono/mini/mini.c	(working copy)
@@ -2889,6 +2889,128 @@
 	return ex;
 }
 
+#define QUICKINLINE 0
+#if QUICKINLINE
+/* QUICKINLINE */
+static MonoClassField* read_field (MonoCompile* cfg, MonoMethod* method, guint32 token, MonoClass** klass)
+{
+       MonoGenericContext *generic_context = NULL;
+       MonoGenericContainer *generic_container = ((MonoMethodNormal *) method)->generic_container;
+       
+       if (method->signature->is_inflated)
+	       generic_context = ((MonoMethodInflated *) method)->context;
+       else if (generic_container)
+	       generic_context = &generic_container->context;
+       
+       return mono_field_from_token (method->klass->image, token, klass, generic_context);
+}
+
+static MonoInst* try_inline_ldfld (MonoCompile *cfg, MonoMethodHeader* h, MonoMethod *method, MonoMethodSignature *sig, MonoInst **args)
+{
+       /* IL_0000:  ldarg.0
+	* IL_0001:  ldfld  int32 X::x
+	* IL_0006:  ret
+	*/
+       
+       MonoInst *offset_ins;
+       MonoInst *ins;
+       MonoInst *load;
+       MonoClassField *field;
+       MonoClass* klass;
+       guint foffset;
+
+       if (h->code_size != 7)
+	       return NULL;
+
+       if (sig->param_count != 0 || !sig->hasthis)
+	       return NULL;
+
+       if (!(h->code [0] == CEE_LDARG_0 && h->code [1] == CEE_LDFLD && h->code [6] == CEE_RET))
+	       return NULL;
+
+       field = read_field (cfg, method, read32 (h->code + 2), &klass);
+       mono_class_init (klass);
+
+       foffset = klass->valuetype ? field->offset - sizeof (MonoObject) : field->offset;
+       
+       NEW_ICONST (cfg, offset_ins, foffset);
+       MONO_INST_NEW (cfg, ins, OP_PADD);
+       ins->inst_left = *args;
+       ins->inst_right = offset_ins;
+       ins->type = STACK_MP;
+       
+       MONO_INST_NEW (cfg, load, mono_type_to_ldind (field->type));
+       type_to_eval_stack_type (field->type, load);
+       load->inst_left = ins;
+       
+       return load;
+}
+/* 
+ *
+ * This method does a quick-and-dirty inlining of a method. It tries to find
+ * common patterns and inlines specific code sequences. This is *NOT* a
+ * general inliner.
+ * 
+ * The goal here is to inline patterns with the following properties: 
+ *	- The pattern is very commonly used 
+ *	- Inlining the pattern will NEVER increase code size
+ * 
+ * Basically, we want to get calls that we don't even have to think about the
+ * cost/benefit tradeoffs.  The methods that this routine inlines are always
+ * good choices to inline, regardless of the call site.
+ *
+ */
+
+static MonoInst*
+quick_inline_method (MonoCompile *cfg, MonoMethod *method, MonoMethodSignature *sig, MonoInst **args)
+{
+       MonoMethodHeader *header = mono_method_get_header (method);
+       MonoInst* ins;
+       
+       if ((method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) ||
+	   (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||
+	   (method->iflags & METHOD_IMPL_ATTRIBUTE_NOINLINING) ||
+	   (method->iflags & METHOD_IMPL_ATTRIBUTE_SYNCHRONIZED) ||
+	   (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||
+	   (method->klass->marshalbyref) ||
+	   !header || header->num_clauses ||
+	   /* fixme: why cant we inline valuetype returns? */
+	   MONO_TYPE_ISSTRUCT (sig->ret))
+	       return NULL;
+       
+       if (header->code_size > 10 || header->num_locals)
+	       return NULL;
+       
+       if (mono_method_has_declsec (method))
+	       return NULL;
+       
+       if (!(cfg->opt & MONO_OPT_SHARED)) {
+	       MonoVTable *vtable = mono_class_vtable (cfg->domain, method->klass);
+	       if (method->klass->flags & TYPE_ATTRIBUTE_BEFORE_FIELD_INIT) {
+		       if (cfg->run_cctors)
+			       mono_runtime_class_init (vtable);
+	       }
+	       else if (!vtable->initialized && mono_class_needs_cctor_run (method->klass, NULL))
+		       return NULL;
+       } else {
+	       /* 
+		* If we're compiling for shared code
+		* the cctor will need to be run at aot method load time, for example,
+		* or at the end of the compilation of the inlining method.
+		*/
+	       if (mono_class_needs_cctor_run (method->klass, NULL) && !((method->klass->flags & TYPE_ATTRIBUTE_BEFORE_FIELD_INIT)))
+		       return NULL;
+       }
+       
+       ins = try_inline_ldfld (cfg, header, method, sig, args);
+       if (ins)
+	       return ins;
+       
+       return NULL;
+       
+}
+#endif
+
 static MonoInst*
 mini_get_inst_for_method (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **args)
 {
@@ -2957,7 +3079,21 @@
 			return ins;
 	}
 
+#if QUICKINLINE
+/* QUICKINLINE */
+	ins = mono_arch_get_inst_for_method (cfg, cmethod, fsig, args);
+	if (ins) {
+		return ins;
+	} else {
+		if (cfg->opt & MONO_OPT_INLINE) {
+			return quick_inline_method (cfg, cmethod, fsig, args);	
+		} else {
+			return NULL;
+		}
+	}
+#else
 	return mono_arch_get_inst_for_method (cfg, cmethod, fsig, args);
+#endif
 }
 
 static void
@@ -8912,11 +9048,219 @@
 	mono_debug_close_method (cfg);
 }
 
-static void
-mono_cprop_copy_values (MonoCompile *cfg, MonoInst *tree, MonoInst **acp)
+
+#define MONO_DEBUG_LOCAL_PROP 0
+#define MONO_DEBUG_TREE_MOVER 0
+#define MONO_APPLY_TREE_MOVER_TO_SINGLE_METHOD 0
+
+typedef struct MonoTreeMoverElementNode {
+	gssize used_index;
+	gssize affected_index;
+	struct MonoTreeMoverElementNode *next_used_local;
+	struct MonoTreeMoverElementNode *next_affected_local;
+	struct MonoTreeMoverElementNode *previous_affected_local;
+	gboolean use_is_direct;
+} MonoTreeMoverElementNode;
+
+typedef struct MonoTreeMoverAffectedTree {
+	gssize affected_index;
+	struct MonoTreeMoverAffectedTree *next_affected_tree;
+} MonoTreeMoverAffectedTree;
+
+typedef struct MonoTreeMoverActElement {
+	MonoInst *definition;
+	MonoInst **use;
+	MonoTreeMoverElementNode *used_locals;
+	MonoTreeMoverElementNode *last_used_local;
+	MonoTreeMoverElementNode *affected_locals;
+	MonoTreeMoverAffectedTree *affected_trees;
+	struct MonoTreeMoverActElement *forwarding_source;
+	struct MonoTreeMoverActElement *forwarding_destination;
+	gboolean definition_is_waiting_for_use;
+	gboolean perform_move;
+	gboolean move_performed;
+	gboolean tree_can_still_be_forwarded;
+} MonoTreeMoverActElement;
+
+typedef struct MonoTreeMover {
+	MonoMemPool *pool;
+	MonoCompile *cfg;
+	
+	MonoTreeMoverElementNode *free_nodes;
+	
+	MonoInst give_up;
+	
+	MonoTreeMoverActElement *ACT;
+	
+	MonoTreeMoverElementNode *used_nodes;
+	MonoTreeMoverElementNode *last_used_node;
+	gboolean tree_has_side_effects;
+} MonoTreeMover;
+
+#define TREE_MOVER_INVALID_INDEX (-1)
+#define TREE_MOVER_GIVE_UP_DEFINITION (&(tree_mover->give_up))
+#define TREE_MOVER_GIVE_UP_USE (&(tree_mover->give_up.inst_i0))
+
+#define TREE_MOVER_NEW_NODE(__node) do {\
+	if (tree_mover->free_nodes != NULL) {\
+		(__node) = tree_mover->free_nodes;\
+		tree_mover->free_nodes = tree_mover->free_nodes->next_used_local;\
+		(__node)->next_used_local = NULL;\
+		(__node)->next_affected_local = NULL;\
+		(__node)->previous_affected_local = NULL;\
+	} else {\
+		(__node) = (MonoTreeMoverElementNode*) mono_mempool_alloc0 (tree_mover->pool, sizeof (MonoTreeMoverElementNode));\
+	}\
+} while (0)
+
+#define TREE_MOVER_DISPOSE_NODES(__node,__last_node) do {\
+	(__last_node)->next_used_local = tree_mover->free_nodes;\
+	tree_mover->free_nodes = (__node);\
+	(__node) = NULL;\
+	(__last_node) = NULL;\
+} while (0)
+
+#define TREE_MOVER_ADD_USED_NODE(__index,__use_is_direct) do {\
+	MonoTreeMoverElementNode *__node;\
+	TREE_MOVER_NEW_NODE (__node);\
+	__node->used_index = (__index);\
+	__node->affected_index = TREE_MOVER_INVALID_INDEX;\
+	__node->use_is_direct = __use_is_direct;\
+	if (tree_mover->last_used_node != NULL) {\
+		tree_mover->last_used_node->next_used_local = __node;\
+	} else {\
+		tree_mover->used_nodes = __node;\
+	}\
+	tree_mover->last_used_node = __node;\
+} while (0)
+
+#define TREE_MOVER_DISPOSE_USED_NODES do {\
+	if (tree_mover->last_used_node != NULL) {\
+			TREE_MOVER_DISPOSE_NODES (tree_mover->used_nodes, tree_mover->last_used_node);\
+	}\
+} while (0)
+
+#define TREE_MOVER_LINK_AFFECTING_NODE(__node,__affected_index) do {\
+	MonoTreeMoverActElement *__element = &(tree_mover->ACT [(__node)->used_index]);\
+	(__node)->next_affected_local = __element->affected_locals;\
+	(__node)->affected_index = __element->__affected_index;\
+	__element->affected_locals = (__node);\
+	if ((__node)->next_affected_local != NULL) {\
+		(__node)->next_affected_local->previous_affected_local = (__node);\
+	}\
+	(__node)->previous_affected_local = NULL;\
+} while (0)
+
+#define TREE_MOVER_UNLINK_AFFECTING_NODE(__node) do {\
+	if ((__node)->next_affected_local != NULL) {\
+		(__node)->next_affected_local->previous_affected_local = (__node)->previous_affected_local;\
+	}\
+	if ((__node)->previous_affected_local != NULL) {\
+		(__node)->previous_affected_local->next_affected_local = (__node)->next_affected_local;\
+	} else {\
+		MonoTreeMoverActElement *__element = &(tree_mover->ACT [(__node)->used_index]);\
+		__element->affected_locals = (__node)->next_affected_local;\
+	}\
+	(__node)->next_affected_local = NULL;\
+	(__node)->previous_affected_local = NULL;\
+	(__node)->affected_index = TREE_MOVER_INVALID_INDEX;\
+} while (0)
+
+#define TREE_MOVER_LINK_AFFECTED_TREES(__source_index,__destination_index) do {\
+	MonoTreeMoverActElement *__source_element = &(tree_mover->ACT [(__source_index)]);\
+	MonoTreeMoverAffectedTree *__node = (MonoTreeMoverAffectedTree*) mono_mempool_alloc0 (tree_mover->pool, sizeof (MonoTreeMoverAffectedTree));\
+	__node->affected_index = __destination_index;\
+	__node->next_affected_tree = __source_element->affected_trees;\
+	__source_element->affected_trees = __node;\
+} while (0)
+
+#define TREE_MOVER_KILL_ACT_SLOT(__slot) do {\
+	MonoTreeMoverElementNode *__node = ((__slot)->used_locals);\
+	MonoTreeMoverActElement *__current_slot = (__slot);\
+	while (__node != NULL) {\
+		TREE_MOVER_UNLINK_AFFECTING_NODE (__node);\
+		__node = __node->next_used_local;\
+	}\
+	if ((__slot)->used_locals != NULL) {\
+		TREE_MOVER_DISPOSE_NODES ((__slot)->used_locals, (__slot)->last_used_local);\
+	}\
+	while (__current_slot != NULL) {\
+		__current_slot->definition = TREE_MOVER_GIVE_UP_DEFINITION;\
+		__current_slot->use = TREE_MOVER_GIVE_UP_USE;\
+		__current_slot->definition_is_waiting_for_use = FALSE;\
+		__current_slot->perform_move = FALSE;\
+		__current_slot->tree_can_still_be_forwarded = FALSE;\
+		if (__current_slot->forwarding_source != NULL) {\
+			__current_slot->forwarding_source->forwarding_destination = NULL;\
+		}\
+		__current_slot = __current_slot->forwarding_destination;\
+	}\
+} while (0)
+
+#define TREE_MOVER_KILL_ACTIVE_SLOTS(__size) do {\
+	int __i;\
+	for (__i = 0; __i < __size; __i++) {\
+		MonoTreeMoverActElement *__slot = &(tree_mover->ACT [__i]);\
+		if (__slot->definition_is_waiting_for_use) {\
+			TREE_MOVER_KILL_ACT_SLOT (__slot);\
+		} else if (__slot->perform_move) {\
+			__slot->tree_can_still_be_forwarded = FALSE;\
+		}\
+	}\
+} while (0)
+
+#if 0
+static guint16 ldind_to_conv[] = {
+	CEE_CONV_I1,
+	CEE_CONV_U1,
+	CEE_CONV_I2,
+	CEE_CONV_U2,
+	CEE_CONV_I4,
+	CEE_CONV_U4,
+	CEE_CONV_I8,
+	CEE_CONV_I,
+	CEE_CONV_R4,
+	CEE_CONV_R8,
+	0
+};
+#endif
+
+static gboolean stind_needs_conversion[(CEE_STIND_R8-CEE_STIND_REF)+1][STACK_MAX] = {
+	/* INV I4    I8    PTR   R8    MP    OBJ   VTYPE */
+	{TRUE ,TRUE, TRUE, FALSE,TRUE, FALSE,FALSE,TRUE}, /* CEE_STIND_REF */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_I1  */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_I2  */
+	{TRUE ,FALSE,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_I4  */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_I8  */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_STIND_R4  */
+	{TRUE ,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}  /* CEE_STIND_R8  */
+};
+static gboolean stind_i_needs_conversion[STACK_MAX] = {TRUE ,TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE};
+static gboolean ldind_needs_conversion[(CEE_LDIND_REF-CEE_LDIND_I1)+1][STACK_MAX] = {
+	/* INV I4    I8    PTR   R8    MP    OBJ   VTYPE */
+	{TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_I1  */
+	{TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_U1  */
+	{TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_I2  */
+	{TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_U2  */
+	{TRUE, FALSE,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_I4  */
+	{TRUE, FALSE,TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_U4  */
+	{TRUE, TRUE, FALSE,TRUE, TRUE, TRUE, TRUE, TRUE}, /* CEE_LDIND_I8  */
+	{TRUE, TRUE, TRUE, FALSE,TRUE, FALSE,FALSE,TRUE}, /* CEE_LDIND_I   */
+	{TRUE, TRUE, TRUE, FALSE,TRUE, FALSE,FALSE,TRUE}, /* CEE_LDIND_R4  */
+	{TRUE, TRUE, TRUE, FALSE,TRUE, FALSE,FALSE,TRUE}, /* CEE_LDIND_R8  */
+	{TRUE, FALSE,FALSE,FALSE,FALSE,FALSE,TRUE, TRUE}  /* CEE_LDIND_REF */
+};
+
+#define TREE_MOVER_LDIND_TO_CONV(__opcode) (ldind_to_conv [(__opcode)-CEE_LDIND_I1])
+#define TREE_MOVER_STIND_NEEDS_CONVERSION(__opcode,__type) (((__opcode)!=CEE_STIND_I)?(stind_needs_conversion [(__opcode)-CEE_STIND_REF][(__type)]):(stind_i_needs_conversion [(__type)]))
+#define TREE_MOVER_LDIND_NEEDS_CONVERSION(__opcode,__type) (ldind_needs_conversion [(__opcode)-CEE_LDIND_I1][(__type)])
+
+static MonoTreeMoverActElement*
+mono_cprop_copy_values (MonoCompile *cfg, MonoTreeMover *tree_mover, MonoInst *tree, MonoInst **acp)
 {
 	MonoInst *cp;
 	int arity;
+	MonoTreeMoverActElement *used_tree = NULL;
 
 	if (tree->ssa_op == MONO_SSA_LOAD && (tree->inst_i0->opcode == OP_LOCAL || tree->inst_i0->opcode == OP_ARG) && 
 	    (cp = acp [tree->inst_i0->inst_c0]) && !tree->inst_i0->flags) {
@@ -8924,36 +9268,150 @@
 		if (cp->opcode == OP_ICONST) {
 			if (cfg->opt & MONO_OPT_CONSPROP) {
 				//{ static int c = 0; printf ("CCOPY %d %d %s\n", c++, cp->inst_c0, mono_method_full_name (cfg->method, TRUE)); }
+#if MONO_DEBUG_LOCAL_PROP
+				printf ("Propagating constant, tree ");
+				mono_print_tree (tree);
+				printf (" becomes ");
+				mono_print_tree (cp);
+				printf ("\n");
+#endif
 				*tree = *cp;
 			}
 		} else {
-			if (tree->inst_i0->inst_vtype->type == cp->inst_vtype->type) {
+			if ((tree->inst_i0->inst_vtype->type == cp->inst_vtype->type) ||
+					(tree->type == STACK_OBJ)) {
 				if (cfg->opt & MONO_OPT_COPYPROP) {
 					//{ static int c = 0; printf ("VCOPY %d\n", ++c); }
+					if (tree_mover != NULL) {
+						guint used_index = tree->inst_i0->inst_c0;
+						MonoTreeMoverActElement *used_slot = &(tree_mover->ACT [used_index]);
+						if (used_slot->tree_can_still_be_forwarded) {
+							/* Setup tree as movable (forwarding move) */
+							used_slot->definition_is_waiting_for_use = FALSE;
+							used_slot->perform_move = TRUE;
+							used_slot->tree_can_still_be_forwarded = FALSE;
+							/* Set "used_tree", so that the use location will be recorded */
+							used_tree = used_slot;
+						} else {
+							guint forwarded_index = cp->inst_c0;
+							MonoTreeMoverActElement *forwarded_slot = &(tree_mover->ACT [forwarded_index]);
+# if MONO_DEBUG_TREE_MOVER
+							printf ("Tree cannot be forwarded, killing slot %d: ", used_index);
+							mono_print_tree_nl (tree);
+							printf ("Because of this, also killing forwarded slot %d\n", forwarded_index);
+#endif
+							/* Otherwise, the definition has too many uses, kill it */
+							TREE_MOVER_KILL_ACT_SLOT (used_slot);
+							TREE_MOVER_KILL_ACT_SLOT (forwarded_slot);
+						}
+						/* Bad hack to stop the tree mover from looking again at this tree */
+						tree_mover = NULL;
+					}
+#if MONO_DEBUG_LOCAL_PROP
+					printf ("Propagating value, tree->inst_i0 ");
+					mono_print_tree (tree->inst_i0);
+					printf (" becomes ");
+					mono_print_tree (cp);
+					printf ("\n");
+#endif
 					tree->inst_i0 = cp;
 				} 
 			}
+#if MONO_DEBUG_LOCAL_PROP
+			else {
+				printf ("Values of tree->inst_i0 ");
+				mono_print_tree (tree->inst_i0);
+				printf (" and cp ");
+				mono_print_tree (cp);
+				printf (" have incompatible types in tree ");
+				mono_print_tree (tree);
+				printf ("\n");
+			}
+#endif
 		} 
 	} else {
+#if MONO_DEBUG_LOCAL_PROP
+		printf ("Propagation SKIPPED for inst ");
+		mono_print_tree (tree);
+		printf ("\n");
+#endif
 		arity = mono_burg_arity [tree->opcode];
 
 		if (arity) {
-			mono_cprop_copy_values (cfg, tree->inst_i0, acp);
+			MonoTreeMoverActElement *result = mono_cprop_copy_values (cfg, tree_mover, tree->inst_i0, acp);
+			if (result != NULL)
+				result->use = &(tree->inst_i0);
 			if (cfg->opt & MONO_OPT_CFOLD)
 				mono_constant_fold_inst (tree, NULL); 
 			/* The opcode may have changed */
 			if (mono_burg_arity [tree->opcode] > 1) {
-				mono_cprop_copy_values (cfg, tree->inst_i1, acp);
+				result = mono_cprop_copy_values (cfg, tree_mover, tree->inst_i1, acp);
+				if (result != NULL)
+					result->use = &(tree->inst_i1);
 				if (cfg->opt & MONO_OPT_CFOLD)
 					mono_constant_fold_inst (tree, NULL); 
 			}
 			mono_constant_fold_inst (tree, NULL); 
 		}
 	}
+	
+	/* Apply the tree mover after after propagation has been done */
+	if ((tree_mover != NULL) && (tree->ssa_op == MONO_SSA_LOAD) &&
+			(tree->inst_i0->opcode == OP_LOCAL || tree->inst_i0->opcode == OP_ARG)) {
+		guint used_index = tree->inst_i0->inst_c0;
+		MonoTreeMoverActElement *ACT_slot = &(tree_mover->ACT [used_index]);
+		
+		if (!tree->inst_i0->flags) {
+			/* Record local use (the tree that contains this use might be movable) */
+			TREE_MOVER_ADD_USED_NODE (used_index, TRUE);
+			
+			/* Check if ACT slot is waiting for a use, and types are compatible */
+			if ((ACT_slot->definition_is_waiting_for_use) &&
+			    (! TREE_MOVER_STIND_NEEDS_CONVERSION (ACT_slot->definition->opcode, ACT_slot->definition->inst_i1->type)) &&
+			    (! TREE_MOVER_LDIND_NEEDS_CONVERSION (tree->opcode, ACT_slot->definition->inst_i1->type))) {
+				/* Record indirect uses as well, and unlink nodes from affecting lists */
+				MonoTreeMoverElementNode *node = ACT_slot->used_locals;
+# if MONO_DEBUG_TREE_MOVER
+				printf ("Scheduling tree move for slot %d: ", used_index);
+				mono_print_tree_nl (tree);
+#endif
+				/* Record indirect uses generated by this move */
+				while (node != NULL) {
+					TREE_MOVER_ADD_USED_NODE (node->used_index, FALSE);
+					node = node->next_used_local;
+				}
+				
+				/* Setup tree as movable */
+				ACT_slot->definition_is_waiting_for_use = FALSE;
+				ACT_slot->perform_move = TRUE;
+				ACT_slot->tree_can_still_be_forwarded = TRUE;
+				
+				/* Set "used_tree", so that the use location will be recorded */
+				used_tree = ACT_slot;
+			} else {
+# if MONO_DEBUG_TREE_MOVER
+				printf ("Definition has too many, wrong or misplaced uses, killing slot %d: ", used_index);
+				mono_print_tree_nl (tree);
+#endif
+				/* Otherwise, the definition has too many uses, kill it */
+				TREE_MOVER_KILL_ACT_SLOT (ACT_slot);
+			}
+		} else {
+# if MONO_DEBUG_TREE_MOVER
+			printf ("Tree has side effects, killing slot %d: ", used_index);
+			mono_print_tree_nl (tree);
+#endif
+			/* The whole tree is unmovable (it uses a flagged local) */
+			tree_mover->tree_has_side_effects = TRUE;
+			/* Moreover, the use of a flagged local kills the definition */
+			TREE_MOVER_KILL_ACT_SLOT (ACT_slot);
+		}
+	}	
+	return used_tree;
 }
 
 static void
-mono_cprop_invalidate_values (MonoInst *tree, MonoInst **acp, int acp_size)
+mono_cprop_invalidate_values (MonoInst *tree, MonoTreeMover *tree_mover, MonoInst **acp, int acp_size)
 {
 	int arity;
 
@@ -8968,7 +9426,20 @@
 	case CEE_STIND_R8:
 	case CEE_STOBJ:
 		if ((tree->ssa_op == MONO_SSA_NOP) || (tree->ssa_op & MONO_SSA_ADDRESS_TAKEN)) {
+#if MONO_DEBUG_LOCAL_PROP
+			printf ("Indirect store clears ACP at tree ");
+			mono_print_tree (tree);
+			printf ("\n");
+#endif
 			memset (acp, 0, sizeof (MonoInst *) * acp_size);
+			if (tree_mover != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+				printf ("Killing all active slots (and recording side effect) because of inst ");
+				mono_print_tree_nl (tree);
+#endif
+				TREE_MOVER_KILL_ACTIVE_SLOTS (acp_size);
+				tree_mover->tree_has_side_effects = TRUE;
+			}
 			return;
 		}
 
@@ -8992,6 +9463,14 @@
 		MonoMethodSignature *sig = call->signature;
 		int i, byref = FALSE;
 
+		if (tree_mover != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+			printf ("Recording side effect because of inst ");
+			mono_print_tree_nl (tree);
+#endif
+			tree_mover->tree_has_side_effects = TRUE;
+		}
+
 		for (i = 0; i < sig->param_count; i++) {
 			if (sig->params [i]->byref) {
 				byref = TRUE;
@@ -8999,9 +9478,21 @@
 			}
 		}
 
-		if (byref)
+		if (byref) {
+#if MONO_DEBUG_LOCAL_PROP
+			printf ("Call with byref parameter clears ACP at tree ");
+			mono_print_tree (tree);
+			printf ("\n");
+#endif
 			memset (acp, 0, sizeof (MonoInst *) * acp_size);
-
+			if (tree_mover != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+				printf ("Killing all active slots because of inst ");
+				mono_print_tree_nl (tree);
+#endif
+				TREE_MOVER_KILL_ACTIVE_SLOTS (acp_size);
+			}
+		}
 		return;
 	}
 	default:
@@ -9014,11 +9505,11 @@
 	case 0:
 		break;
 	case 1:
-		mono_cprop_invalidate_values (tree->inst_i0, acp, acp_size);
+		mono_cprop_invalidate_values (tree->inst_i0, tree_mover, acp, acp_size);
 		break;
 	case 2:
-		mono_cprop_invalidate_values (tree->inst_i0, acp, acp_size);
-		mono_cprop_invalidate_values (tree->inst_i1, acp, acp_size);
+		mono_cprop_invalidate_values (tree->inst_i0, tree_mover, acp, acp_size);
+		mono_cprop_invalidate_values (tree->inst_i1, tree_mover, acp, acp_size);
 		break;
 	default:
 		g_assert_not_reached ();
@@ -9026,7 +9517,7 @@
 }
 
 static void
-mono_local_cprop_bb (MonoCompile *cfg, MonoBasicBlock *bb, MonoInst **acp, int acp_size)
+mono_local_cprop_bb (MonoCompile *cfg, MonoTreeMover *tree_mover, MonoBasicBlock *bb, MonoInst **acp, int acp_size)
 {
 	MonoInst *tree = bb->code;	
 	int i;
@@ -9034,35 +9525,168 @@
 	if (!tree)
 		return;
 
+# if MONO_DEBUG_TREE_MOVER
+	if (tree_mover != NULL) {
+		printf ("Running tree mover on BB%d\n", bb->block_num);
+	}
+#endif
+
 	for (; tree; tree = tree->next) {
+		if (tree_mover != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+			printf ("Running tree mover on tree ");
+			mono_print_tree_nl (tree);
+#endif
+			tree_mover->tree_has_side_effects = FALSE;
+		}
 
-		mono_cprop_copy_values (cfg, tree, acp);
+		mono_cprop_copy_values (cfg, tree_mover, tree, acp);
+		mono_cprop_invalidate_values (tree, tree_mover, acp, acp_size);
+# if MONO_DEBUG_TREE_MOVER
+		if (tree_mover != NULL) {
+			printf ("After the tree walk, tree_mover->tree_has_side_effects is %d\n", tree_mover->tree_has_side_effects);
+		}
+#endif
 
-		mono_cprop_invalidate_values (tree, acp, acp_size);
 
 		if (tree->ssa_op == MONO_SSA_STORE  && 
 		    (tree->inst_i0->opcode == OP_LOCAL || tree->inst_i0->opcode == OP_ARG)) {
 			MonoInst *i1 = tree->inst_i1;
+			MonoTreeMoverActElement *forwarding_source = NULL;
+			gboolean tree_can_be_moved = TRUE;
 
 			acp [tree->inst_i0->inst_c0] = NULL;
+#if MONO_DEBUG_LOCAL_PROP
+			printf ("Assignment clears ACP[%d] at tree ", tree->inst_i0->inst_c0);
+			mono_print_tree (tree);
+			printf ("\n");
+#endif
 
 			for (i = 0; i < acp_size; i++) {
 				if (acp [i] && acp [i]->opcode != OP_ICONST && 
 				    acp [i]->inst_c0 == tree->inst_i0->inst_c0) {
 					acp [i] = NULL;
+#if MONO_DEBUG_LOCAL_PROP
+					printf ("  Consequently, ACP[%d] is cleared\n", i);
+#endif
 				}
 			}
 
 			if (i1->opcode == OP_ICONST) {
 				acp [tree->inst_i0->inst_c0] = i1;
+				tree_can_be_moved = FALSE;
+#if MONO_DEBUG_LOCAL_PROP
+				printf ("  Consequently, ACP[%d] becomes constant ", tree->inst_i0->inst_c0);
+				mono_print_tree (i1);
+				printf ("\n");
+#endif
 				//printf ("DEF1 BB%d %d\n", bb->block_num,tree->inst_i0->inst_c0);
 			}
 			if (i1->ssa_op == MONO_SSA_LOAD && 
 			    (i1->inst_i0->opcode == OP_LOCAL || i1->inst_i0->opcode == OP_ARG) &&
 			    (i1->inst_i0->inst_c0 != tree->inst_i0->inst_c0)) {
 				acp [tree->inst_i0->inst_c0] = i1->inst_i0;
+				tree_can_be_moved = FALSE;				
+#if MONO_DEBUG_LOCAL_PROP
+				printf ("  Consequently, ACP[%d] becomes local ", tree->inst_i0->inst_c0);
+				mono_print_tree (i1->inst_i0);
+				printf ("\n");
+#endif
+				if (tree_mover != NULL) {
+					forwarding_source = &(tree_mover->ACT [i1->inst_i0->inst_c0]);
+					/* Check if source slot satisfies forwarding condition */
+					if (forwarding_source->perform_move && forwarding_source->tree_can_still_be_forwarded) {
+						tree_can_be_moved = TRUE;
+					} else {
+						forwarding_source = NULL;
+					}
+				}
 				//printf ("DEF2 BB%d %d %d\n", bb->block_num,tree->inst_i0->inst_c0,i1->inst_i0->inst_c0);
 			}
+			
+			/* Apply tree mover */
+			if (tree_mover != NULL) {
+				MonoTreeMoverActElement *defined_tree = &(tree_mover->ACT [tree->inst_i0->inst_c0]);
+				MonoTreeMoverElementNode *affected_node;
+				
+				/* First apply definition (so affected variables are linked) */
+				/* This is needed *now* so that circular definitions are detected */
+				if ((defined_tree->definition == NULL) && (defined_tree->use == NULL) && (! tree_mover->tree_has_side_effects) && tree_can_be_moved) {
+# if MONO_DEBUG_TREE_MOVER
+					printf ("Recording definition in slot %d for tree: ", tree->inst_i0->inst_c0);
+					mono_print_tree_nl (tree);
+					if (forwarding_source != NULL) {
+						printf ("Forwarding definition ");
+						mono_print_tree_nl (forwarding_source->definition);
+					}
+#endif
+					/* Record the definition */
+					defined_tree->definition = tree;
+					defined_tree->definition_is_waiting_for_use = TRUE;
+					/* Handle tree forwarding */
+					if (forwarding_source == NULL) {
+						/* Normal case, no forwarding */
+						defined_tree->forwarding_source = NULL;
+						defined_tree->used_locals = tree_mover->used_nodes;
+						defined_tree->last_used_local = tree_mover->last_used_node;
+					} else {
+						defined_tree->forwarding_source = forwarding_source;
+						forwarding_source->forwarding_destination = defined_tree;
+						defined_tree->used_locals = NULL;
+						defined_tree->last_used_local = NULL;
+						if (tree_mover->used_nodes != NULL) {
+							TREE_MOVER_DISPOSE_NODES (tree_mover->used_nodes, tree_mover->last_used_node);
+						}
+					}
+					tree_mover->used_nodes = NULL;
+					tree_mover->last_used_node = NULL;
+				} else {
+# if MONO_DEBUG_TREE_MOVER
+					printf ("Too many or wrong definitions, killing slot %d at tree: ", tree->inst_i0->inst_c0);
+					mono_print_tree_nl (tree);
+#endif
+					/* The definition is at the wrong place, kill slot */
+					TREE_MOVER_KILL_ACT_SLOT (defined_tree);
+				}
+				
+				/* Then kill all affected definitions waiting for a use */
+				affected_node = defined_tree->affected_locals;
+				while (affected_node != NULL) {
+					MonoTreeMoverElementNode *next_affected_node = affected_node->next_affected_local;
+					
+					if (affected_node->use_is_direct) {
+						MonoTreeMoverActElement *affected_slot = &(tree_mover->ACT [affected_node->affected_index]);
+						/* First of all, prevent forwarded slots from going further */
+						while ((affected_slot != NULL) && affected_slot->perform_move) {
+# if MONO_DEBUG_TREE_MOVER
+							printf ("  Direct use, preventing slot %d from being moved further\n", affected_slot->definition->inst_i0->inst_c0);
+# endif
+							affected_slot->tree_can_still_be_forwarded = FALSE;
+							affected_slot = affected_slot->forwarding_destination;
+						}
+						/* Then kill remaining slots */
+						if (affected_slot != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+							printf ("  Direct use, killing slot %d (and forwarding destinations)\n", affected_node->affected_index);
+# endif
+							TREE_MOVER_KILL_ACT_SLOT (affected_slot);
+						}
+					} else if (tree_mover->ACT [affected_node->affected_index].definition_is_waiting_for_use) {
+# if MONO_DEBUG_TREE_MOVER
+						printf ("  Indirect use, linking slots %d and %d\n", affected_node->used_index, affected_node->affected_index);
+#endif
+						TREE_MOVER_LINK_AFFECTED_TREES (affected_node->used_index, affected_node->affected_index);
+						TREE_MOVER_LINK_AFFECTED_TREES (affected_node->affected_index, affected_node->used_index);
+					}
+					TREE_MOVER_UNLINK_AFFECTING_NODE (affected_node);
+					
+					if ((next_affected_node != NULL) && (next_affected_node->affected_index != TREE_MOVER_INVALID_INDEX)) {
+						affected_node = next_affected_node;
+					} else {
+						affected_node = tree_mover->ACT [i].affected_locals;
+					}
+				}
+			}
 		}
 
 		/*
@@ -9081,19 +9705,130 @@
 		  }
 		*/
 	}
+	
+	if (tree_mover != NULL) {
+		/* At BB end, kill all definitions still waiting for a use */
+		TREE_MOVER_KILL_ACTIVE_SLOTS (acp_size);
+	}
+}
+
+
+#if (MONO_APPLY_TREE_MOVER_TO_SINGLE_METHOD)
+static char*
+mono_tree_mover_method_name = NULL;
+static gboolean check_tree_mover_method_name (MonoCompile *cfg) {
+	if (mono_tree_mover_method_name == NULL) {
+		mono_tree_mover_method_name = getenv ("MONO_TREE_MOVER_METHOD_NAME");
+	}
+	if (mono_tree_mover_method_name != NULL) {
+		char *method_name = mono_method_full_name (cfg->method, TRUE);
+		if (strstr (method_name, mono_tree_mover_method_name) != NULL) {
+			return TRUE;
+		} else {
+			return FALSE;
+		}
+	} else {
+		return TRUE;
+	}
+}
+#endif
+
+static gboolean
+apply_tree_mover (MonoTreeMover *tree_mover, MonoTreeMoverActElement *act_element) {
+	gboolean go_on;
+
+	if (act_element->forwarding_source != NULL) {
+		if (! act_element->forwarding_source->perform_move) {
+			go_on = FALSE;
+		} else if (act_element->forwarding_source->move_performed) {
+			go_on = TRUE;
+		} else {
+			go_on = apply_tree_mover (tree_mover, act_element->forwarding_source);
+		}
+	} else {
+		go_on = TRUE;
+	}
+
+	if (go_on) {
+		MonoTreeMoverAffectedTree *affected_tree;			
+# if MONO_DEBUG_TREE_MOVER
+		printf ("Finally moving definition at slot %d: ", act_element->definition->inst_i0->inst_c0);
+		mono_print_tree_nl (act_element->definition);
+#endif
+		/* Move the tree */
+		*(act_element->use) = act_element->definition->inst_i1;
+		act_element->definition->opcode = CEE_NOP;
+		act_element->definition->ssa_op = MONO_SSA_NOP;
+
+		/* Quickly kill trees affected by this move */
+		affected_tree = act_element->affected_trees;
+		while (affected_tree != NULL) {
+# if MONO_DEBUG_TREE_MOVER
+			printf ("  Consequently, killing slot %d\n", affected_tree->affected_index);
+#endif
+			tree_mover->ACT [affected_tree->affected_index].perform_move = FALSE;
+			affected_tree = affected_tree->next_affected_tree;
+		}
+		return TRUE;
+	} else {
+# if MONO_DEBUG_TREE_MOVER
+		printf ("Cannot move definition at slot %d: ", act_element->definition->inst_i0->inst_c0);
+		mono_print_tree_nl (act_element->definition);
+#endif
+		return FALSE;
+	}
+
+	return go_on;
 }
 
 static void
-mono_local_cprop (MonoCompile *cfg)
-{
+mono_local_cprop (MonoCompile *cfg) {
 	MonoBasicBlock *bb;
 	MonoInst **acp;
+	MonoTreeMover *tree_mover;
 
 	acp = alloca (sizeof (MonoInst *) * cfg->num_varinfo);
 
+	if (cfg->opt & MONO_OPT_TREEPROP) {
+		MonoMemPool *pool = mono_mempool_new();
+		tree_mover = mono_mempool_alloc0(pool, sizeof (MonoTreeMover));
+		
+		tree_mover->cfg = cfg;
+		tree_mover->pool = pool;
+		tree_mover->ACT = mono_mempool_alloc0 (pool, sizeof (MonoTreeMoverActElement) * (cfg->num_varinfo));		
+#if (MONO_APPLY_TREE_MOVER_TO_SINGLE_METHOD)
+		if (! check_tree_mover_method_name (cfg)) {
+			mono_mempool_destroy(tree_mover->pool);
+			tree_mover = NULL;
+		}
+#endif
+	} else {
+		tree_mover = NULL;
+	}
+
 	for (bb = cfg->bb_entry; bb; bb = bb->next_bb) {
+#if MONO_DEBUG_LOCAL_PROP
+		printf ("Applying mono_local_cprop to BB%d\n", bb->block_num);
+#endif
 		memset (acp, 0, sizeof (MonoInst *) * cfg->num_varinfo);
-		mono_local_cprop_bb (cfg, bb, acp, cfg->num_varinfo);
+		mono_local_cprop_bb (cfg, tree_mover, bb, acp, cfg->num_varinfo);
+	}
+	
+	if (tree_mover != NULL) {
+		/* Move the movable trees */
+		int i;
+# if MONO_DEBUG_TREE_MOVER
+		printf ("Applying tree mover...\n");
+#endif
+		for (i = 0; i < cfg->num_varinfo; i++) {
+			MonoTreeMoverActElement *act_element = &(tree_mover->ACT [i]);
+			if (act_element->perform_move && ! act_element->move_performed) {
+				apply_tree_mover (tree_mover, act_element);
+			}
+		}
+		
+		/* Global cleanup of tree mover memory */
+		mono_mempool_destroy(tree_mover->pool);
 	}
 }
 
@@ -9358,6 +10093,13 @@
 	if (parts == 2)
 		return cfg;
 
+
+	if (cfg->verbose_level > 6) {
+		printf ("Before (CONS|COPY|TREE)PROP start:\n");
+		mono_print_code (cfg);
+		printf ("Before (CONS|COPY|TREE)PROP end.\n");
+	}
+
 	if ((cfg->opt & MONO_OPT_CONSPROP) || (cfg->opt & MONO_OPT_COPYPROP)) {
 		if (cfg->comp_done & MONO_COMP_SSA) {
 			mono_ssa_cprop (cfg);
@@ -9366,6 +10108,12 @@
 		}
 	}
 
+	if (cfg->verbose_level > 6) {
+		printf ("After (CONS|COPY|TREE)PROP start:\n");
+		mono_print_code (cfg);
+		printf ("After (CONS|COPY|TREE)PROP end.\n");
+	}
+
 	if (cfg->comp_done & MONO_COMP_SSA) {			
 		//mono_ssa_deadce (cfg);
 
Index: mono/mono/mini/mini.h
===================================================================
--- mono/mono/mini/mini.h	(revision 55928)
+++ mono/mono/mini/mini.h	(working copy)
@@ -506,7 +506,8 @@
 	MONO_OPT_ABCREM   = 1 << 18,
 	MONO_OPT_SSAPRE   = 1 << 19,
 	MONO_OPT_EXCEPTION= 1 << 20,
-	MONO_OPT_SSA      = 1 << 21
+	MONO_OPT_SSA      = 1 << 21,
+	MONO_OPT_TREEPROP = 1 << 22
 };
 
 /* Bit-fields in the MonoBasicBlock.region */
Index: mono/mono/mini/driver.c
===================================================================
--- mono/mono/mini/driver.c	(revision 55928)
+++ mono/mono/mini/driver.c	(working copy)
@@ -87,12 +87,18 @@
 	{"abcrem",     "Array bound checks removal"},	
 	{"ssapre",     "SSA based Partial Redundancy Elimination"},
 	{"exception",  "Optimize exception catch blocks"},
-	{"ssa",        "Build and use SSA form"}
+	{"ssa",        "Use plain SSA form"},
+	{"treeprop",   "Tree propagation"}
 };
 
 #define DEFAULT_OPTIMIZATIONS (	\
 	MONO_OPT_PEEPHOLE |	\
 	MONO_OPT_CFOLD |	\
+	MONO_OPT_INLINE |	\
+	MONO_OPT_CONSPROP |	\
+	MONO_OPT_COPYPROP |	\
+	MONO_OPT_TREEPROP |	\
+	MONO_OPT_DEADCE |	\
 	MONO_OPT_BRANCH |	\
 	MONO_OPT_LINEARS |	\
 	MONO_OPT_INTRINS |  \
@@ -241,6 +247,7 @@
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_ABCREM,
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_ABCREM | MONO_OPT_SSAPRE,
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_ABCREM,
+       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_TREEPROP,
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_SSAPRE,
        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_ABCREM | MONO_OPT_SHARED
 };
