Index: System.Reflection.Emit/TypeBuilder.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Reflection.Emit/TypeBuilder.cs,v
retrieving revision 1.103
diff -u -r1.103 TypeBuilder.cs
--- System.Reflection.Emit/TypeBuilder.cs	29 May 2004 07:50:08 -0000	1.103
+++ System.Reflection.Emit/TypeBuilder.cs	6 Jun 2004 13:30:57 -0000
@@ -280,15 +280,15 @@
 			return (ConstructorInfo)binder.SelectMethod (bindingAttr, match, types, modifiers);
 		}
 
-		public override bool IsDefined( Type attributeType, bool inherit)
+		public override bool IsDefined (Type attributeType, bool inherit)
 		{
-			/*
-			 * MS throws NotSupported here, but we can't because some corlib
-			 * classes make calls to IsDefined.
-			 */
-			return MonoCustomAttrs.IsDefined (this, attributeType, inherit);
+			if (created != null) {
+				return MonoCustomAttrs.IsDefined (created, attributeType, inherit);
+			}
+
+			throw not_supported ();
 		}
-		
+
 		public override object[] GetCustomAttributes(bool inherit)
 		{
 			throw not_supported ();
@@ -683,19 +683,27 @@
 		}
 
 		public override EventInfo GetEvent (string name, BindingFlags bindingAttr) {
+			if (created != null) {
+				return created.GetEvent (name, bindingAttr);
+			}
+
 			throw not_supported ();
 		}
 
-		/* Needed to keep signature compatibility with MS.NET */
-		public override EventInfo[] GetEvents ()
-		{
-			return GetEvents (DefaultBindingFlags);
+		public override EventInfo[] GetEvents () {
+			if (created != null) {
+				return created.GetEvents ();
+			}
+
+			throw not_supported ();
 		}
 
 		public override EventInfo[] GetEvents (BindingFlags bindingAttr) {
-			// FIXME: Under MS.NET, this throws a NotImplementedException
-			// But mcs calls this method. How can that be?
-			return new EventInfo [0];
+			if (created != null) {
+				return created.GetEvents (bindingAttr);
+			}
+
+			throw not_supported ();
 		}
 
 		// This is only used from MonoGenericInst.initialize().
@@ -746,86 +754,33 @@
 		}
 
 		public override FieldInfo GetField( string name, BindingFlags bindingAttr) {
-			if (fields == null)
-				return null;
-
-			bool match;
-			FieldAttributes mattrs;
-			
-			foreach (FieldInfo c in fields) {
-				if (c == null)
-					continue;
-				if (c.Name != name)
-					continue;
-				match = false;
-				mattrs = c.Attributes;
-				if ((mattrs & FieldAttributes.FieldAccessMask) == FieldAttributes.Public) {
-					if ((bindingAttr & BindingFlags.Public) != 0)
-						match = true;
-				} else {
-					if ((bindingAttr & BindingFlags.NonPublic) != 0)
-						match = true;
-				}
-				if (!match)
-					continue;
-				match = false;
-				if ((mattrs & FieldAttributes.Static) != 0) {
-					if ((bindingAttr & BindingFlags.Static) != 0)
-						match = true;
-				} else {
-					if ((bindingAttr & BindingFlags.Instance) != 0)
-						match = true;
-				}
-				if (!match)
-					continue;
-				return c;
+			if (created != null) {
+				return created.GetField (name, bindingAttr);
 			}
-			return null;
+
+			throw not_supported ();
 		}
 
 		public override FieldInfo[] GetFields (BindingFlags bindingAttr) {
-			if (fields == null)
-				return new FieldInfo [0];
-			ArrayList l = new ArrayList ();
-			bool match;
-			FieldAttributes mattrs;
-			
-			foreach (FieldInfo c in fields) {
-				if (c == null)
-					continue;
-				match = false;
-				mattrs = c.Attributes;
-				if ((mattrs & FieldAttributes.FieldAccessMask) == FieldAttributes.Public) {
-					if ((bindingAttr & BindingFlags.Public) != 0)
-						match = true;
-				} else {
-					if ((bindingAttr & BindingFlags.NonPublic) != 0)
-						match = true;
-				}
-				if (!match)
-					continue;
-				match = false;
-				if ((mattrs & FieldAttributes.Static) != 0) {
-					if ((bindingAttr & BindingFlags.Static) != 0)
-						match = true;
-				} else {
-					if ((bindingAttr & BindingFlags.Instance) != 0)
-						match = true;
-				}
-				if (!match)
-					continue;
-				l.Add (c);
+			if (created != null) {
+				return created.GetFields (bindingAttr);
 			}
-			FieldInfo[] result = new FieldInfo [l.Count];
-			l.CopyTo (result);
-			return result;
+
+			throw not_supported ();
 		}
 
 		public override Type GetInterface (string name, bool ignoreCase) {
+			if (created != null) {
+				return created.GetInterface (name, ignoreCase);
+			}
+
 			throw not_supported ();
 		}
 		
 		public override Type[] GetInterfaces () {
+			if (created != null) {
+				return created.GetInterfaces ();
+			}
 			if (interfaces != null) {
 				Type[] ret = new Type [interfaces.Length];
 				interfaces.CopyTo (ret, 0);
@@ -836,11 +791,16 @@
 		}
 
 		public override MemberInfo[] GetMember (string name, MemberTypes type,
-												BindingFlags bindingAttr) {
+			if (created != null) {
+				return created.GetMember (name, type, bindingAttr);
+			}
 			throw not_supported ();
 		}
 
 		public override MemberInfo[] GetMembers (BindingFlags bindingAttr) {
+			if (created != null) {
+				return created.GetMembers (bindingAttr);
+			}
 			throw not_supported ();
 		}
 
@@ -903,7 +863,10 @@
 		}
 
 		public override MethodInfo[] GetMethods (BindingFlags bindingAttr) {
-			return GetMethodsByName (null, bindingAttr, false, this);
+			if (created != null) {
+				return created.GetMethods (bindingAttr);
+			}
+			throw not_supported ();
 		}
 
 		protected override MethodInfo GetMethodImpl (string name, BindingFlags bindingAttr,
@@ -958,73 +921,24 @@
 		}
 
 		public override Type GetNestedType( string name, BindingFlags bindingAttr) {
+			if (created != null) {
+				return created.GetNestedType (name, bindingAttr);
+			}
 			throw not_supported ();
 		}
 
 		public override Type[] GetNestedTypes (BindingFlags bindingAttr) {
-			bool match;
-			ArrayList result = new ArrayList ();
-		
-			if (subtypes == null)
-				return Type.EmptyTypes;
-			foreach (TypeBuilder t in subtypes) {
-				match = false;
-				if ((t.attrs & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPublic) {
-					if ((bindingAttr & BindingFlags.Public) != 0)
-						match = true;
-				} else {
-					if ((bindingAttr & BindingFlags.NonPublic) != 0)
-						match = true;
-				}
-				if (!match)
-					continue;
-				result.Add (t);
+			if (created != null) {
+				return created.GetNestedTypes (bindingAttr);
 			}
-			Type[] r = new Type [result.Count];
-			result.CopyTo (r);
-			return r;
+			throw not_supported ();
 		}
 
 		public override PropertyInfo[] GetProperties( BindingFlags bindingAttr) {
-			if (properties == null)
-				return new PropertyInfo [0];
-			ArrayList l = new ArrayList ();
-			bool match;
-			MethodAttributes mattrs;
-			MethodInfo accessor;
-			
-			foreach (PropertyInfo c in properties) {
-				match = false;
-				accessor = c.GetGetMethod (true);
-				if (accessor == null)
-					accessor = c.GetSetMethod (true);
-				if (accessor == null)
-					continue;
-				mattrs = accessor.Attributes;
-				if ((mattrs & MethodAttributes.MemberAccessMask) == MethodAttributes.Public) {
-					if ((bindingAttr & BindingFlags.Public) != 0)
-						match = true;
-				} else {
-					if ((bindingAttr & BindingFlags.NonPublic) != 0)
-						match = true;
-				}
-				if (!match)
-					continue;
-				match = false;
-				if ((mattrs & MethodAttributes.Static) != 0) {
-					if ((bindingAttr & BindingFlags.Static) != 0)
-						match = true;
-				} else {
-					if ((bindingAttr & BindingFlags.Instance) != 0)
-						match = true;
-				}
-				if (!match)
-					continue;
-				l.Add (c);
+			if (created != null) {
+				return created.GetProperties (bindingAttr);
 			}
-			PropertyInfo[] result = new PropertyInfo [l.Count];
-			l.CopyTo (result);
-			return result;
+			throw not_supported ();
 		}
 		
 		protected override PropertyInfo GetPropertyImpl( string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers) {
@@ -1032,42 +946,47 @@
 		}
 
 		protected override bool HasElementTypeImpl () {
-			// According to the MSDN docs, this is supported for TypeBuilders,
-			// but in reality, it is not
 			throw not_supported ();
-			//			return IsArrayImpl() || IsByRefImpl() || IsPointerImpl ();
 		}
 
 		public override object InvokeMember( string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters) {
+			if (created != null) {
+				return created.InvokeMember (name, invokeAttr, binder, target, args, 
+					modifiers, culture, namedParameters);
+			}
 			throw not_supported ();
 		}
 
 		protected override bool IsArrayImpl ()
 		{
-			return Type.IsArrayImpl (this);
+			return false;
 		}
 
 		protected override bool IsByRefImpl () {
-			// FIXME
 			return false;
 		}
+
 		protected override bool IsCOMObjectImpl () {
+			if ((GetAttributeFlagsImpl () & TypeAttributes.Import) == TypeAttributes.Import) {
+				return true;
+			}
 			return false;
 		}
+
 		protected override bool IsPointerImpl () {
-			// FIXME
 			return false;
 		}
+
 		protected override bool IsPrimitiveImpl () {
-			// FIXME
 			return false;
 		}
+
 		protected override bool IsValueTypeImpl () {
 			return ((type_is_subtype_of (this, pmodule.assemblyb.corlib_value_type, false) || type_is_subtype_of (this, typeof(System.ValueType), false)) &&
 				this != pmodule.assemblyb.corlib_value_type &&
 				this != pmodule.assemblyb.corlib_enum_type);
 		}
-		
+
 		public override RuntimeTypeHandle TypeHandle { 
 			get { 
 				throw not_supported (); 
Index: System.Reflection.Emit/ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Reflection.Emit/ChangeLog,v
retrieving revision 1.235
diff -u -r1.235 ChangeLog
--- System.Reflection.Emit/ChangeLog	29 May 2004 07:50:08 -0000	1.235
+++ System.Reflection.Emit/ChangeLog	6 Jun 2004 13:30:59 -0000
@@ -1,4 +1,10 @@
-2004-05-29  Gert Driesen (drieseng@users.sourceforge.net)
+2004-06-06  Gert Driesen <drieseng@users.sourceforge.net>
+
+	* TypeBuilder.cs: removed code duplication, fixed Get* methods
+	to return actual events/fields/... when type has been completed,
+	implemented IsCOMObjectImpl, removed uncessary FIXME's
+
+2004-05-29  Gert Driesen <drieseng@users.sourceforge.net>
 
 	* AssemblyBuilder.cs: removed extra method, fixes public API
 	compatibility with MS.NET
Index: Test/System.Reflection.Emit/TypeBuilderTest.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/Test/System.Reflection.Emit/TypeBuilderTest.cs,v
retrieving revision 1.7
diff -u -r1.7 TypeBuilderTest.cs
--- Test/System.Reflection.Emit/TypeBuilderTest.cs	16 Feb 2004 13:48:55 -0000	1.7
+++ Test/System.Reflection.Emit/TypeBuilderTest.cs	6 Jun 2004 13:31:02 -0000
@@ -1,3 +1,4 @@
+
 //
 // TypeBuilderTest.cs - NUnit Test Cases for the TypeBuilder class
 //
@@ -233,6 +234,10 @@
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("Probably not",
 					  false, tb.IsCOMObject);
+
+		tb = module.DefineType (genTypeName (), TypeAttributes.Import);
+		AssertEquals ("type with Import attribute is COM object",
+					  true, tb.IsCOMObject);
 	}
 
 	public void TestIsContextful () {
@@ -974,82 +979,416 @@
 		}
 	}
 
-	/* IsDefined actually works under mono */
-	/*
-	public void TestIsDefined () {
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestIsDefinedIncomplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.IsDefined (typeof (int), true);
+	}
 
-		try {
-			tb.IsDefined (typeof (int), true);
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+	public void TestIsDefinedComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		ConstructorInfo obsoleteCtor = typeof(ObsoleteAttribute).GetConstructor(
+			new Type[] {typeof(string)});
+
+		CustomAttributeBuilder caBuilder = new CustomAttributeBuilder (obsoleteCtor,
+			new object[] { "obsolete message" }, new FieldInfo[0], new object[0]);
+
+		tb.SetCustomAttribute (caBuilder);
+		tb.CreateType ();
+		AssertEquals (true, tb.IsDefined (typeof(ObsoleteAttribute), false));
 	}
-	*/
 
-	/* FIXME: This does not work under mono
-	public void TestGetEvents () {
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetEventsIncomplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetEvents ();
+	}
 
-		try {
-			tb.GetEvents ();
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+	[Ignore ("Re-enable this when bug #59649 is fixed")]
+	public void TestGetEventsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
 
-		try {
-			tb.GetEvents (BindingFlags.Public);
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+		MethodBuilder onclickMethod = tb.DefineMethod ("OnChange", MethodAttributes.Public, 
+			typeof(void), new Type[] { typeof(Object) });
+		onclickMethod.GetILGenerator ().Emit (OpCodes.Ret);
+
+		// create public event
+		EventBuilder eventbuilder = tb.DefineEvent ("Change", EventAttributes.None,
+			typeof(ResolveEventHandler));
+		eventbuilder.SetRaiseMethod (onclickMethod);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetEvents ().Length);
+		AssertEquals (tb.GetEvents ().Length, emittedType.GetEvents ().Length);
 	}
-	*/
 
-	public void TestGetEvent () {
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetEventsFlagsIncomplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetEvents (BindingFlags.Public);
+	}
 
-		try {
-			tb.GetEvent ("FOO", BindingFlags.Public);
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+	[Ignore ("Re-enable this when bug #59649 is fixed")]
+	public void TestGetEventsFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		MethodBuilder onchangeMethod = tb.DefineMethod ("OnChange", MethodAttributes.Public,
+			typeof(void), new Type[] { typeof(Object) });
+		onchangeMethod.GetILGenerator ().Emit (OpCodes.Ret);
+
+		// create public event
+		EventBuilder changeEvent = tb.DefineEvent ("Change", EventAttributes.None,
+			typeof(ResolveEventHandler));
+		changeEvent.SetRaiseMethod (onchangeMethod);
+
+		// create non-public event
+		EventBuilder redoChangeEvent = tb.DefineEvent ("RedoChange", EventAttributes.None,
+			typeof(ResolveEventHandler));
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetEvents (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (1, tb.GetEvents (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (2, tb.GetEvents (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length);
+		AssertEquals (tb.GetEvents (BindingFlags.Instance | BindingFlags.Public).Length,
+			emittedType.GetEvents (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (tb.GetEvents (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetEvents (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (tb.GetEvents (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length,
+			emittedType.GetEvents (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length);
 	}
 
-	public void TestGetMember () {
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetEventIncomplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetEvent ("FOO");
+	}
 
-		try {
-			tb.GetMember ("FOO", MemberTypes.All, BindingFlags.Public);
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+	[Ignore ("Re-enable this when bug #59649 is fixed")]
+	public void TestGetEventComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		MethodBuilder onclickMethod = tb.DefineMethod ("OnChange", MethodAttributes.Public,
+			typeof(void), new Type[] { typeof(Object) });
+		onclickMethod.GetILGenerator ().Emit (OpCodes.Ret);
+
+		EventBuilder eventbuilder = tb.DefineEvent ("Change", EventAttributes.None,
+			typeof(ResolveEventHandler));
+		eventbuilder.SetRaiseMethod (onclickMethod);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (tb.GetEvent ("Change"));
+		AssertEquals (tb.GetEvent ("Change"), emittedType.GetEvent ("Change"));
+		AssertNull (tb.GetEvent ("NotChange"));
+		AssertEquals (tb.GetEvent ("NotChange"), emittedType.GetEvent ("NotChange"));
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetEventFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetEvent ("FOO", BindingFlags.Public);
+	}
+
+	[Ignore ("Re-enable this when bug #59649 is fixed")]
+	public void TestGetEventFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		MethodBuilder onclickMethod = tb.DefineMethod ("OnChange", MethodAttributes.Public,
+			typeof(void), new Type[] { typeof(Object) });
+		onclickMethod.GetILGenerator ().Emit (OpCodes.Ret);
+
+		EventBuilder eventbuilder = tb.DefineEvent ("Change", EventAttributes.None,
+			typeof(ResolveEventHandler));
+		eventbuilder.SetRaiseMethod (onclickMethod);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (tb.GetEvent ("Change", BindingFlags.Instance | BindingFlags.Public));
+		AssertEquals (tb.GetEvent ("Change", BindingFlags.Instance | BindingFlags.Public),
+			emittedType.GetEvent ("Change", BindingFlags.Instance | BindingFlags.Public));
+		AssertNull (tb.GetEvent ("Change", BindingFlags.Instance | BindingFlags.NonPublic));
+		AssertEquals (tb.GetEvent ("Change", BindingFlags.Instance | BindingFlags.NonPublic),
+			emittedType.GetEvent ("Change", BindingFlags.Instance | BindingFlags.NonPublic));
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetFieldsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetFields ();
+	}
+
+	public void TestGetFieldsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("TestField", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetFields ().Length);
+		AssertEquals (tb.GetFields ().Length, emittedType.GetFields().Length);
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetFieldsFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetFields (BindingFlags.Instance | BindingFlags.Public);
+	}
+
+	public void TestGetFieldsFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("TestField", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetFields (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (tb.GetFields (BindingFlags.Instance | BindingFlags.Public).Length, 
+			emittedType.GetFields (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (0, tb.GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (tb.GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetFieldIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetField ("test");
 	}
 
-	public void TestGetMembers () {
+	public void TestGetFieldComplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("TestField", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (tb.GetField ("TestField"));
+		AssertEquals (tb.GetField ("TestField"), emittedType.GetField ("TestField"));
+		AssertNull (tb.GetField ("TestOtherField"));
+		AssertEquals (tb.GetField ("TestOtherField"), 
+			emittedType.GetField ("TestOtherField"));
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetFieldFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetField ("test", BindingFlags.Public);
+	}
+
+	public void TestGetFieldFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("TestField", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (tb.GetField ("TestField", BindingFlags.Instance | BindingFlags.Public));
+		AssertEquals (tb.GetField ("TestField", BindingFlags.Instance | BindingFlags.Public),
+			emittedType.GetField ("TestField", BindingFlags.Instance | BindingFlags.Public));
+		AssertNull (tb.GetField ("TestField", BindingFlags.Instance | BindingFlags.NonPublic));
+		AssertEquals (tb.GetField ("TestField", BindingFlags.Instance | BindingFlags.NonPublic),
+			emittedType.GetField ("TestField", BindingFlags.Instance | BindingFlags.NonPublic));
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetPropertiesIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetProperties ();
+	}
+
+	public void TestGetPropertiesComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		DefineStringProperty (tb, "CustomerName", "customerName", MethodAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetProperties ().Length);
+		AssertEquals (tb.GetProperties ().Length, emittedType.GetProperties ().Length);
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetPropertiesFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetProperties (BindingFlags.Public);
+	}
+
+	public void TestGetPropertiesFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		DefineStringProperty (tb, "CustomerName", "customerName", MethodAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetProperties (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (tb.GetProperties (BindingFlags.Instance | BindingFlags.Public).Length,
+			emittedType.GetProperties (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (0, tb.GetProperties (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (tb.GetProperties (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetProperties (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetPropertyIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetProperty ("test");
+	}
+
+	public void TestGetPropertyComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		DefineStringProperty (tb, "CustomerName", "customerName", MethodAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (emittedType.GetProperty ("CustomerName"));
+		AssertNull (emittedType.GetProperty ("OtherCustomerName"));
 
 		try {
-			tb.GetMembers (BindingFlags.Public);
+			tb.GetProperty ("CustomerName");
 			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+		} catch (NotSupportedException) {}
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetPropertyFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetProperty ("test", BindingFlags.Public);
 	}
 
-	public void TestGetInterface () {
+	public void TestGetPropertyFlagsComplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		DefineStringProperty (tb, "CustomerName", "customerName", MethodAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (emittedType.GetProperty ("CustomerName", BindingFlags.Instance | 
+			BindingFlags.Public));
+		AssertNull (emittedType.GetProperty ("CustomerName", BindingFlags.Instance |
+			BindingFlags.NonPublic));
 
 		try {
-			tb.GetInterface ("FOO", true);
+			tb.GetProperty ("CustomerName", BindingFlags.Instance | BindingFlags.Public);
 			Fail ();
 		}
-		catch (NotSupportedException) {
-		}
+		catch (NotSupportedException) { }
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMethodsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMethods ();
+	}
+
+	public void TestGetMethodsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		MethodBuilder helloMethod = tb.DefineMethod ("HelloMethod", 
+			MethodAttributes.Public, typeof(string), new Type[0]);
+		ILGenerator helloMethodIL = helloMethod.GetILGenerator ();
+		helloMethodIL.Emit (OpCodes.Ldstr, "Hi! ");
+		helloMethodIL.Emit (OpCodes.Ldarg_1);
+		MethodInfo infoMethod = typeof(string).GetMethod ("Concat", 
+			new Type[] { typeof(string), typeof(string) });
+		helloMethodIL.Emit (OpCodes.Call, infoMethod);
+		helloMethodIL.Emit (OpCodes.Ret);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (typeof(object).GetMethods (BindingFlags.Public | BindingFlags.Instance).Length + 1, 
+			tb.GetMethods ().Length);
+		AssertEquals (tb.GetMethods ().Length, emittedType.GetMethods ().Length);
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMethodsFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMethods (BindingFlags.Public);
+	}
+
+	public void TestGetMethodsFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		MethodBuilder helloMethod = tb.DefineMethod ("HelloMethod",
+			MethodAttributes.Public, typeof(string), new Type[0]);
+		ILGenerator helloMethodIL = helloMethod.GetILGenerator ();
+		helloMethodIL.Emit (OpCodes.Ldstr, "Hi! ");
+		helloMethodIL.Emit (OpCodes.Ldarg_1);
+		MethodInfo infoMethod = typeof(string).GetMethod ("Concat", 
+			new Type[] { typeof(string), typeof(string) });
+		helloMethodIL.Emit (OpCodes.Call, infoMethod);
+		helloMethodIL.Emit (OpCodes.Ret);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetMethods (BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly).Length);
+		AssertEquals (tb.GetMethods (BindingFlags.Instance | BindingFlags.Public).Length,
+			emittedType.GetMethods (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (0, tb.GetMethods (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly).Length);
+		AssertEquals (tb.GetMethods (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetMethods (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMemberIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMember ("FOO", MemberTypes.All, BindingFlags.Public);
+	}
+
+	public void TestGetMemberComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("FOO", typeof(int), FieldAttributes.Private);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetMember ("FOO", MemberTypes.Field, BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (0, tb.GetMember ("FOO", MemberTypes.Field, BindingFlags.Instance | BindingFlags.Public).Length);
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMembersIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMembers ();
+	}
+
+	public void TestGetMembersComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (tb.GetMembers ().Length, emittedType.GetMembers ().Length);
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMembersFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMembers (BindingFlags.Public);
+	}
+
+	public void TestGetMembersFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("FOO", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		Assert (tb.GetMembers (BindingFlags.Instance | BindingFlags.Public).Length != 0);
+		AssertEquals (tb.GetMembers (BindingFlags.Instance | BindingFlags.Public).Length,
+			emittedType.GetMembers (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (tb.GetMembers (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetMembers (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+	}
+
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetInterfaceIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetInterface ("FOO", true);
+	}
+
+	public void TestGetInterfaces () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		Type[] interfaces = tb.GetInterfaces ();
+		AssertEquals (0, interfaces.Length);
+
+		TypeBuilder tbInterface = module.DefineType (genTypeName (), TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract);
+		Type emittedInterface = tbInterface.CreateType ();
+
+		tb = module.DefineType (genTypeName (), TypeAttributes.Public, typeof(object), new Type[] { emittedInterface });
+		interfaces = tb.GetInterfaces ();
+		AssertEquals (1, interfaces.Length);
 	}
 
 	[Test]
@@ -1129,7 +1468,48 @@
 
 		AssertEquals ("B, C", enumVal.ToString ());
 		AssertEquals (3, (Int32)enumVal);
-	}            
+	}
+
+	private void DefineStringProperty (TypeBuilder tb, string propertyName, string fieldName, MethodAttributes methodAttribs) {
+		// define the field holding the property value
+		FieldBuilder fieldBuilder = tb.DefineField (fieldName,
+									typeof(string),
+									FieldAttributes.Private);
+
+		PropertyBuilder propertyBuilder = tb.DefineProperty (
+			propertyName, PropertyAttributes.HasDefault, typeof(string),
+			new Type[] { typeof(string) });
+
+		// First, we'll define the behavior of the "get" property for CustomerName as a method.
+		MethodBuilder getMethodBuilder = tb.DefineMethod ("Get" + propertyName,
+								methodAttribs,
+								typeof(string),
+								new Type[] { });
+
+		ILGenerator getIL = getMethodBuilder.GetILGenerator ();
+
+		getIL.Emit (OpCodes.Ldarg_0);
+		getIL.Emit (OpCodes.Ldfld, fieldBuilder);
+		getIL.Emit (OpCodes.Ret);
+
+		// Now, we'll define the behavior of the "set" property for CustomerName.
+		MethodBuilder setMethodBuilder = tb.DefineMethod ("Set" + propertyName,
+								methodAttribs,
+								null,
+								new Type[] { typeof(string) });
+
+		ILGenerator setIL = setMethodBuilder.GetILGenerator ();
+
+		setIL.Emit (OpCodes.Ldarg_0);
+		setIL.Emit (OpCodes.Ldarg_1);
+		setIL.Emit (OpCodes.Stfld, fieldBuilder);
+		setIL.Emit (OpCodes.Ret);
+
+		// Last, we must map the two methods created above to our PropertyBuilder to 
+		// their corresponding behaviors, "get" and "set" respectively. 
+		propertyBuilder.SetGetMethod (getMethodBuilder);
+		propertyBuilder.SetSetMethod (setMethodBuilder);
+	}
 }
 }
 
Index: Test/System.Reflection.Emit/ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/Test/System.Reflection.Emit/ChangeLog,v
retrieving revision 1.32
diff -u -r1.32 ChangeLog
--- Test/System.Reflection.Emit/ChangeLog	28 Apr 2004 11:00:49 -0000	1.32
+++ Test/System.Reflection.Emit/ChangeLog	6 Jun 2004 13:31:02 -0000
@@ -1,3 +1,7 @@
+2004-06-06  Gert Driesen <drieseng@users.sourceforge.net>
+
+	* TypeBuilderTest.cs: Added tests for completed/created type
+
 2004-04-28  Zoltan Varga  <vargaz@freemail.hu>
 
 	* MethodRentalTest.cs: New file.
