// created on 2/28/2006 at 9:10 PM
// Basic LaTeX/Lambda filter, adapted from FilterRTF.cs.
// Since basic means just that it works for me, please send
// feedback to <auxsvr@yahoo.com> to make it work for you too.
// Please be patient if you do, as 1) it's my first program in C# 
// 2) I really don't have much free time.

using System;
using System.Collections;
using System.IO;
using System.Text;

using Beagle.Util;
using Beagle.Daemon;

internal class TeXControlWordType {

	public enum Type {
		None,
		Comment,
		Skip, // Uninmportant symbols for the parser
		MetaDataBlock,
		MetaDataTag,
		Document,
		SplSection,
		EscSeq,
		CharProp,
		MathMode,
		MathModeEnd,
		BlockBegin,
		BlockEnd
	}
	
	public Type Types;
	public string ctrlWord;
	
	TeXControlWordType (Type types, string ctrlword)
	{
		this.Types = types;
		this.ctrlWord = ctrlword;
	}
	
	static TeXControlWordType[] types =
	{
		new TeXControlWordType (Type.None, ""),
		new TeXControlWordType (Type.MetaDataBlock, "abstract"),
		new TeXControlWordType (Type.MetaDataTag, "author"),
		new TeXControlWordType (Type.MetaDataTag, "title"),
		new TeXControlWordType (Type.MetaDataTag, "email"),
		new TeXControlWordType (Type.Document, "document"),
		new TeXControlWordType (Type.MathMode, "displaymath"),
		new TeXControlWordType (Type.MathMode, "equation"),
		//new TeXControlWordType (Type.Paragraph, "begin"),
		//new TeXControlWordType (Type.ParaEnd, "end"),
		new TeXControlWordType (Type.CharProp, "bf"),
		new TeXControlWordType (Type.CharProp, "emphasize"),
		new TeXControlWordType (Type.BlockBegin, "begin"),
		new TeXControlWordType (Type.BlockEnd, "end"),
		new TeXControlWordType (Type.Comment, "%"),
		new TeXControlWordType (Type.Skip, "^"),
		//new TeXControlWordType (Type.Skip, " "),
		//new TeXControlWordType (Type.Skip, "\n"),
		//new TeXControlWordType (Type.Skip, "\r"),
		//new TeXControlWordType (Type.Skip, ","),
		//new TeXControlWordType (Type.Skip, "!"),
		new TeXControlWordType (Type.EscSeq, "{"),
		new TeXControlWordType (Type.EscSeq, "}"),
		new TeXControlWordType (Type.EscSeq, "\\"),
	};
	
	public static TeXControlWordType Find (string strCtrlWord)
	{
		for (int i =0; i < types.Length; i++) {
			if (String.Compare (types[i].ctrlWord, strCtrlWord) == 0)
				return types[i];
		}
		return types[0];
	}
}

namespace Beagle.Filters {

	public class FilterTeX : Beagle.Daemon.Filter {
	
		public enum Position {
			None,
			InMetaData,
			InBody,
			InPara,
			InMathMode
		}
		public enum ErrorCodes {
			ERROR_TEX_OK,
			ERROR_TEX_EOF,
			ERROR_TEX_UNHANDLED_SYMBOL
		};
		
		//Maximum xattr length allowed in Linux
		int MAX_XATTR_LENGTH = 1024;
		
		Position pos;
		int groupCount;
		//int skipCount; Not used
		int hotStyleCount;
		bool bPartHotStyle;
		FileStream FsTeX;
		StreamReader SReaderTeX;
		string partText;
		bool bBlockBegin;
		
		Stack MetaDataStack;
		Stack TextDataStack;
		Stack EnvironmentDataStack;
		
		public FilterTeX ()
		{
			AddSupportedFlavor(FilterFlavor.NewFromMimeType ("text/x-tex"));
			AddSupportedFlavor(FilterFlavor.NewFromMimeType ("text/x-latex"));
			// These two are in my system mimetypes; add them just in case.
			AddSupportedFlavor(FilterFlavor.NewFromMimeType ("application/x-tex"));
			AddSupportedFlavor(FilterFlavor.NewFromMimeType ("application/x-latex"));
		
			pos = Position.None;
			groupCount = 0;
			//skipCount = 0;
			hotStyleCount = 0;
			bPartHotStyle = false;
			FsTeX = null;
			SReaderTeX = null;
			partText = "";
			bBlockBegin = false;
			
			MetaDataStack = new Stack ();
			TextDataStack = new Stack ();
			EnvironmentDataStack = new Stack ();
			
			// Is this necessary?
			SnippetMode = true;
		}
		
		override protected void DoOpen (FileInfo info)
		{
			try {
				FsTeX = new FileStream (info.FullName, FileMode.Open, FileAccess.Read);
				if (FsTeX != null)
					SReaderTeX = new StreamReader (FsTeX);
				else {
					Logger.Log.Error ("Unable to open {0}.", info.FullName);
					Finished ();
				}
			} catch (Exception e) {
				Logger.Log.Error ("Unable to open {0}.", info.FullName);
				Finished ();
			}
		}
		
		private ErrorCodes HandleControlWord (string strCtrlWord, int paramVal, bool bMeta)
		{
			TeXControlWordType ctrlWrdType = TeXControlWordType.Find (strCtrlWord.ToString());
			switch (ctrlWrdType.Types) {
			case TeXControlWordType.Type.MetaDataBlock:
				pos = Position.InMetaData;
				break;
				
			case TeXControlWordType.Type.MetaDataTag:
				if (String.Compare (strCtrlWord, "title") == 0)
					MetaDataStack.Push ("dc:title");
				else if (String.Compare (strCtrlWord, "author") == 0)
					MetaDataStack.Push ("dc:author");
				pos = Position.InMetaData;
				break;
				
			//case TeXControlWordType.Type.Paragraph:
			//	if (!bMeta)
			//		pos = Position.InPara;
			//	break;
				
			//case TeXControlWordType.Type.ParaEnd:
			//	if (!bMeta)
			//		pos = Position.InBody;
			//	break;
				
			case TeXControlWordType.Type.CharProp:
				if (pos == Position.InPara) {
					if (paramVal < 0) {
						hotStyleCount = groupCount - 1;
					}
				}
				break;
			
			case TeXControlWordType.Type.EscSeq:
				if (pos == Position.InPara) {
					TextDataStack.Push (strCtrlWord);
					TextDataStack.Push ("EscSeq");
				}
				break;
			
			//case TeXControlWordType.Type.Skip:
			//	skipCount = groupCount -1;
			//	break;
				
			case TeXControlWordType.Type.BlockBegin:
				bBlockBegin = true;
				EnvironmentDataStack.Push ("begin");
				break;
				
			case TeXControlWordType.Type.BlockEnd:
				//It will be set to false upon reaching }
				bBlockBegin = true;
				EnvironmentDataStack.Push ("end");
				Console.WriteLine ("Pushing end");
				break;
			
			case TeXControlWordType.Type.Document:
				bBlockBegin = false;
				break;
				
			case TeXControlWordType.Type.None:
				bBlockBegin = false;
				Console.WriteLine ("Unimplemented macro: {0}", strCtrlWord.ToString());
				break;
			}
			return ErrorCodes.ERROR_TEX_OK;
		}
		
		private ErrorCodes ProcessControlWords (bool bMeta)
		{
			int aByte = -1;
			char ch;
			int paramVal = -1;
			bool negParamVal = false;
			StringBuilder strCtrlWord = new StringBuilder ();
			StringBuilder strParameter = new StringBuilder();
			
			aByte = SReaderTeX.Read();
			if (aByte == -1)
				return ErrorCodes.ERROR_TEX_EOF;
			ch = (char) aByte;
			TeXControlWordType ctrlWrdType = TeXControlWordType.Find (new String (ch, 1));
			
			if (!Char.IsLetter (ch) && ctrlWrdType.Types != TeXControlWordType.Type.Comment && ctrlWrdType.Types != TeXControlWordType.Type.EscSeq) {
				Logger.Log.Error ("Unhandled symbol: {0}, {1}", ch, ctrlWrdType.Types);
				return ErrorCodes.ERROR_TEX_UNHANDLED_SYMBOL;
			}
			while (aByte != -1) {
				strCtrlWord.Append (ch);
				aByte = SReaderTeX.Peek ();
				ch = (char) aByte;
				if (Char.IsLetter (ch)) {
					aByte = SReaderTeX.Read ();
					ch = (char) aByte;
				}
				else
					break;
			}
			aByte =SReaderTeX.Peek ();
			ch = (char) aByte;
			if (aByte != -1 && ch == '-') {
				negParamVal = true;
				aByte = SReaderTeX.Read ();
				aByte = SReaderTeX.Peek ();
				ch = (char) aByte;
			}
			if (Char.IsDigit (ch)) {
				aByte = SReaderTeX.Read ();
				ch = (char) aByte;
				while (aByte != -1) {
					strParameter.Append (ch);
					aByte = SReaderTeX.Peek ();
					ch = (char) aByte;
					if (Char.IsDigit (ch)) {
						aByte = SReaderTeX.Read ();
						ch = (char) aByte;
					}
					else
						break;
				}
				if (strParameter.Length > 0)
					paramVal = Convert.ToInt32 (strParameter.ToString());
			}
			if (negParamVal && paramVal > -1)
				paramVal *= -1;
			Console.WriteLine ("Processing: '{0}'", strCtrlWord.ToString() );
			return (HandleControlWord (strCtrlWord.ToString(), paramVal, bMeta));
		}
		
		private ErrorCodes HandleControlWordArgument ()
		{
			int aByte = -1;
			char ch;
			StringBuilder strCtrlWordArg = new StringBuilder ();
			string strTemp = null;
			TeXControlWordType ctrlWrdType; 
			
			aByte = SReaderTeX.Read ();
			if (aByte == -1)
				return ErrorCodes.ERROR_TEX_EOF;
			ch = (char) aByte;
			
			while (aByte != -1) {
				strCtrlWordArg.Append (ch);
				aByte = SReaderTeX.Peek ();
				ch = (char) aByte;
				if (Char.IsLetter (ch)) {
					aByte = SReaderTeX.Read ();
					ch = (char) aByte;
				}
				else 
					break;
			}
			
			if (EnvironmentDataStack.Count > 0) {
				strTemp = (string) EnvironmentDataStack.Pop();
				if (String.Compare (strTemp, "begin") == 0) {
					EnvironmentDataStack.Push ("begin");
					Console.WriteLine ("Argument1: {0}", strCtrlWordArg.ToString());
					EnvironmentDataStack.Push (strCtrlWordArg.ToString());
					 //Closing block, stack handling
				} else if (String.Compare (strTemp, "end") == 0) {
					Console.WriteLine ("Argument2: {0}, {1}", strCtrlWordArg.ToString(), EnvironmentDataStack.Count);
				
					// Check whether there is an enclosing environment
					if (EnvironmentDataStack.Count > 3) {
						strTemp = (string) EnvironmentDataStack.Pop ();
						Console.WriteLine ("Weirdness: {0}", strTemp);
						if (String.Compare (strCtrlWordArg.ToString (), strTemp) == 0) {
							strCtrlWordArg.Remove (0, strCtrlWordArg.Length);
							// Get rid of "begin"
							strTemp = (string) EnvironmentDataStack.Pop ();
							Console.WriteLine ("assuming begin: {0}, {1}", strTemp, EnvironmentDataStack.Count);
							//Retrieve previous environment
							strCtrlWordArg.Append ((string) EnvironmentDataStack.Pop ());
							//Reset bBlockBegin
							//bBlockBegin = false;
							// BUG: Difference from here
							Console.WriteLine ("...becomes: {0}, {1}" ,strCtrlWordArg.ToString(), EnvironmentDataStack.Count);
							//EnvironmentDataStack.Push (strCtrlWordArg);
						} else
							Console.WriteLine ("Reached the impossible!\n");
							EnvironmentDataStack.Push (strTemp); //FIXME Shouldn't reach it
					}
				}
			}
			// BUG To here
			Console.WriteLine ("count: {0}", EnvironmentDataStack.Count);
			
			ctrlWrdType = TeXControlWordType.Find (strCtrlWordArg.ToString ());
			switch (ctrlWrdType.Types) {
			case TeXControlWordType.Type.MetaDataBlock:
				pos = Position.InMetaData;
				MetaDataStack.Push ("dc:" + strCtrlWordArg.ToString());
				break;
			case TeXControlWordType.Type.MathMode:
				pos = Position.InMathMode;
				break;
			case TeXControlWordType.Type.Document:
				pos = Position.InBody;
				break;
			}
			return ErrorCodes.ERROR_TEX_OK;
		}
		
		private ErrorCodes TeXParse (bool bMeta)
		{
			int aByte = -1;
			char ch;
			StringBuilder str = new StringBuilder ();
			ErrorCodes ec;
			
			while ((aByte = SReaderTeX.Read ()) != -1) {
				ch = (char) aByte;
				switch (ch) {
				case '\\': //Process keywords
					// Huge str.Length probably means a bug.
					if ((str.Length > 0) && (pos == Position.InMetaData) && (MetaDataStack.Count > 0) && (str.Length < MAX_XATTR_LENGTH)) {
						AddProperty (Beagle.Property.New ((string) MetaDataStack.Pop (), str.ToString ()));
						str.Remove (0, str.Length);
					}
					if (pos == Position.InBody && !bMeta) {
					//if ((pos == Position.InBody || pos == Position.InMathMode) && !bMeta) { FIXME
						AddTextForIndexing (str);
						str.Remove (0, str.Length);
					}
					// Position checks must come before and after ProcessControlWords.
					ec = ProcessControlWords (bMeta);
					if (ec != ErrorCodes.ERROR_TEX_OK)
						return ec;
					if (pos == Position.InBody && !bMeta) {
						AddTextForIndexing (str);
						str.Remove (0, str.Length);
					}
					Console.WriteLine ("\\string: {0}, {1}, {2}", str.ToString (), ch, pos);
					break;
				case '{': //Process groups
					Console.WriteLine ("In (, blockbegin {0}", bBlockBegin);
					if (pos == Position.InPara && !bMeta)
						AddTextForIndexing (str);
					if (bBlockBegin) {
						ec = HandleControlWordArgument ();
						if (ec != ErrorCodes.ERROR_TEX_OK)
							return ec;
						str.Remove (0, str.Length);
					}
					Console.WriteLine ("(string, pos: {0}, {1}", str.ToString (), pos);
					break;
				case '}': //process groups
					Console.WriteLine ("In }");
					if (bBlockBegin) {
						if (pos == Position.InMetaData) 
							str.Remove (0, str.Length);
					} else {
						if ((pos == Position.InMetaData) && (MetaDataStack.Count >0)) {
							AddProperty (Beagle.Property.New ((string) MetaDataStack.Pop(), str.ToString()));
							str.Remove (0, str.Length);
						} else
							str.Remove (0, str.Length);
					}
					
						
					//	AddTextForIndexing (str);
					//	AppendStructuralBreak (); Adds pagebreak in snippet mode
					
					if (hotStyleCount >0 && groupCount <=hotStyleCount) {
						HotDown ();
						hotStyleCount = 0;
					Console.WriteLine ("}string: {0}", str.ToString ());
					}
					break;
				case '\r': //ignore
				case '\n':
					str.Append (' ');
					break;
				default:
					if (pos == Position.InPara || pos == Position.InBody || pos == Position.InMetaData || pos == Position.InMathMode)
						str.Append (ch);
					break;
				}
			}
			Console.WriteLine ("partText: {0}", partText);
			if (partText.Length > 0) {
				if (bPartHotStyle && !IsHot)
					HotUp ();
				AppendText (partText);
				if (IsHot)
					HotDown ();
			}
			return ErrorCodes.ERROR_TEX_OK;
		}
		
		private void AddTextForIndexing (StringBuilder str)
		{
			string strTemp;
			string paramStr = null;
			
			bool wasHot = false;
			
			Console.WriteLine ("Indexing: {0}", str.ToString());
			while (TextDataStack.Count >0 ) {
				strTemp = (string) TextDataStack.Pop ();
				switch (strTemp) {
				case "EscSeq":
					strTemp = (string) TextDataStack.Pop ();
					str.Append (strTemp);
					break;
				}
			}
			
			strTemp = "";
			if (str.Length > 0) {
				paramStr = str.ToString ();
				str.Remove (0, str.Length);
				
				int index = paramStr.LastIndexOf (' ');
				int sindex = 0;
			
				if (index > -1) {
					if (partText.Length > 0) {
						sindex = paramStr.IndexOf (' ');
						strTemp = partText + paramStr.Substring (0, sindex);
						if (!IsHot) {
							if (bPartHotStyle)
								HotUp ();
						}
						else
							wasHot = true;
						AppendText (strTemp);
						if (!wasHot && bPartHotStyle)
							HotDown ();
						bPartHotStyle = false;
					}
					paramStr = paramStr.Substring(sindex);
					index = paramStr.LastIndexOf (' ');
					sindex = 0;
				}
				if (index > -1) {
					partText = paramStr.Substring (index);
					paramStr = paramStr.Substring (sindex, index);
				} else {
					strTemp = partText + paramStr;
					partText = strTemp;
					paramStr = "";
					strTemp = "";
				}
				
				if (hotStyleCount > 0) {
					if (!IsHot)
						HotUp ();
					bPartHotStyle = true;
				} else
					bPartHotStyle |= false;  //WHAT?
				
				if (paramStr.Length > 0)
					AppendText (paramStr);
					
				if (partText.Length < 1)
					bPartHotStyle = false;
			}
		}
		
		override protected void DoPull ()
		{
			ErrorCodes ec;
			ec = ErrorCodes.ERROR_TEX_OK;
			pos = Position.None;
			
			// Discard the buffered data, if not,
			// the buffered data can change the 
			// state "pos" variable that results 
			// in complete mess.
			// Fixes: http://bugzilla.gnome.org/show_bug.cgi?id=172294
			SReaderTeX.DiscardBufferedData ();
			
			// Rewind the file pointer to start from beginning.
			SReaderTeX.BaseStream.Seek (0, SeekOrigin.Begin);

			Console.WriteLine ("Calling TeXParse (false)");
			ec = TeXParse (false);
			if (ec != ErrorCodes.ERROR_TEX_OK)
				Logger.Log.Error ("{0}", ec);
			Finished ();
		}
		
		override protected void DoPullProperties ()
		{
			ErrorCodes ec;
			ec = ErrorCodes.ERROR_TEX_OK;
			Console.WriteLine ("Calling TeXParse (true)");
			ec = TeXParse (true);
			if (ec != ErrorCodes.ERROR_TEX_OK)
				Logger.Log.Error ("{0}", ec);
		}

	}
}	