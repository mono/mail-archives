Index: mono/mini/cpu-pentium.md
===================================================================
RCS file: /cvs/public/mono/mono/mini/cpu-pentium.md,v
retrieving revision 1.10
diff -u -r1.10 cpu-pentium.md
--- mono/mini/cpu-pentium.md	15 Jun 2003 12:59:07 -0000	1.10
+++ mono/mini/cpu-pentium.md	18 Jun 2003 07:48:45 -0000
@@ -414,6 +414,10 @@
 loadr8_membase: dest:f src1:b len:6
 loadu4_mem: dest:i len:9
 move: dest:i src1:i len:2
+cmov_eq: dest:i src1:i len:3
+cmov_membase_eq: dest:b src1:i len:11
+cmov_ne_un: dest:i src1:i len:3
+cmov_membase_ne_un: dest:b src1:i len:11
 add_imm: dest:i src1:i len:6 clob:1
 sub_imm: dest:i src1:i len:6 clob:1
 mul_imm: dest:i src1:i len:6
Index: mono/mini/inssel-x86.brg
===================================================================
RCS file: /cvs/public/mono/mono/mini/inssel-x86.brg,v
retrieving revision 1.9
diff -u -r1.9 inssel-x86.brg
--- mono/mini/inssel-x86.brg	26 May 2003 13:26:44 -0000	1.9
+++ mono/mini/inssel-x86.brg	18 Jun 2003 07:48:45 -0000
@@ -10,6 +10,24 @@
 # (C) 2002 Ximian, Inc.
 #
 
+stmt: OP_CMOV_EQ (OP_GROUP (OP_REGVAR, reg), cflags) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->left->left->tree->dreg, state->left->right->reg1);
+}
+
+stmt: OP_CMOV_EQ (OP_GROUP (base, reg), cflags) {
+	MONO_EMIT_STORE_MEMBASE (s, tree, OP_CMOV_MEMBASE_EQ, state->left->left->tree->inst_basereg,
+				 state->left->left->tree->inst_offset, state->left->right->reg1);
+}
+
+stmt: OP_CMOV_NE_UN (OP_GROUP (OP_REGVAR, reg), cflags) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->left->left->tree->dreg, state->left->right->reg1);
+}
+
+stmt: OP_CMOV_NE_UN (OP_GROUP (base, reg), cflags) {
+	MONO_EMIT_STORE_MEMBASE (s, tree, OP_CMOV_MEMBASE_NE_UN, state->left->left->tree->inst_basereg,
+				 state->left->left->tree->inst_offset, state->left->right->reg1);
+}
+
 stmt: OP_START_HANDLER {
 	MONO_EMIT_NEW_STORE_MEMBASE (s, OP_STORE_MEMBASE_REG, s->spvar->inst_basereg, s->spvar->inst_offset, X86_ESP);
 }
Index: mono/mini/linear-scan.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/linear-scan.c,v
retrieving revision 1.1
diff -u -r1.1 linear-scan.c
--- mono/mini/linear-scan.c	5 Apr 2003 19:21:32 -0000	1.1
+++ mono/mini/linear-scan.c	18 Jun 2003 07:48:45 -0000
@@ -168,7 +168,7 @@
 		vmv = l->data;
 		
 		if (vmv->reg >= 0)  {
-			if (gains [vmv->reg] > 5) {
+			if (gains [vmv->reg] > 1) {
 				cfg->varinfo [vmv->idx]->opcode = OP_REGVAR;
 				cfg->varinfo [vmv->idx]->dreg = vmv->reg;
 #ifdef DEBUG_LSCAN
Index: mono/mini/mini-ops.h
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-ops.h,v
retrieving revision 1.13
diff -u -r1.13 mini-ops.h
--- mono/mini/mini-ops.h	15 Jun 2003 12:59:07 -0000	1.13
+++ mono/mini/mini-ops.h	18 Jun 2003 07:48:45 -0000
@@ -294,6 +294,12 @@
 MINI_OP(OP_SEXT_I1,  "sext_i1")
 MINI_OP(OP_SEXT_I2,  "sext_i2")
 
+/* conditional moves */
+MINI_OP(OP_CMOV_EQ,  "cmov_eq")
+MINI_OP(OP_CMOV_MEMBASE_EQ,  "cmov_membase_eq")
+MINI_OP(OP_CMOV_NE_UN,  "cmov_ne_un")
+MINI_OP(OP_CMOV_MEMBASE_NE_UN,  "cmov_membase_ne_un")
+
 /* FP functions usually done by the CPU */
 MINI_OP(OP_SIN,     "sin")
 MINI_OP(OP_COS,     "cos")
Index: mono/mini/mini-x86.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-x86.c,v
retrieving revision 1.29
diff -u -r1.29 mini-x86.c
--- mono/mini/mini-x86.c	17 Jun 2003 14:18:03 -0000	1.29
+++ mono/mini/mini-x86.c	18 Jun 2003 07:48:45 -0000
@@ -2245,6 +2245,42 @@
 		case OP_MOVE:
 			x86_mov_reg_reg (code, ins->dreg, ins->sreg1, 4);
 			break;
+		case OP_CMOV_EQ:
+			x86_cmov_reg (code, X86_CC_EQ, FALSE, ins->dreg, ins->sreg1);
+			break;
+		case OP_CMOV_MEMBASE_EQ: {
+			int dreg;
+
+			if (ins->sreg1 == X86_EAX) 
+				dreg = X86_EDX;
+			else
+				dreg = X86_EAX;
+
+			x86_push_reg (code, dreg);
+			x86_mov_reg_membase (code, dreg, ins->inst_destbasereg, ins->inst_offset, 4);
+			x86_cmov_reg (code, X86_CC_EQ, FALSE, dreg, ins->sreg1);
+			x86_mov_membase_reg (code, ins->inst_destbasereg, ins->inst_offset, dreg, 4);
+			x86_pop_reg (code, dreg);
+			break;
+		}
+		case OP_CMOV_NE_UN:
+			x86_cmov_reg (code, X86_CC_NE, FALSE, ins->dreg, ins->sreg1);
+			break;
+		case OP_CMOV_MEMBASE_NE_UN: {
+			int dreg;
+
+			if (ins->sreg1 == X86_EAX) 
+				dreg = X86_EDX;
+			else
+				dreg = X86_EAX;
+
+			x86_push_reg (code, dreg);
+			x86_mov_reg_membase (code, dreg, ins->inst_destbasereg, ins->inst_offset, 4);
+			x86_cmov_reg (code, X86_CC_NE, FALSE, dreg, ins->sreg1);
+			x86_mov_membase_reg (code, ins->inst_destbasereg, ins->inst_offset, dreg, 4);
+			x86_pop_reg (code, dreg);
+			break;
+		}
 		case CEE_JMP: {
 			/*
 			 * Note: this 'frame destruction' logic is useful for tail calls, too.
Index: mono/mini/mini.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini.c,v
retrieving revision 1.80
diff -u -r1.80 mini.c
--- mono/mini/mini.c	17 Jun 2003 17:11:55 -0000	1.80
+++ mono/mini/mini.c	18 Jun 2003 07:48:45 -0000
@@ -5743,6 +5743,67 @@
 }
 
 static void
+cond_moves (MonoCompile *cfg) {
+	MonoBasicBlock *bb, *bbn, *bbp;
+
+	/* we skip the entry block (exit is handled specially instead ) */
+	for (bb = cfg->bb_entry->next_bb; bb; bb = bb->next_bb) {
+		MonoInst *next;
+
+		/* dont touch code inside exception clauses */
+		if (bb->region != -1)
+			continue;
+
+		if (!bb->code)
+			continue;
+
+		next = bb->code->next;
+		while (next && next->opcode == CEE_NOP)
+			next = next->next;
+
+		if (bb->in_count != 1 || bb->out_count != 1 || 
+		    bb->code->ssa_op != MONO_SSA_STORE || /*bb->code->inst_i0->opcode != OP_REGVAR ||*/ next)
+			continue;
+
+		bbp = bb->in_bb [0];
+		bbn = bb->out_bb [0];
+
+		if (bbp->out_count != 2 || (bbp->out_bb [0] != bbn && bbp->out_bb [1] != bbn) || bb->next_bb != bbn ||
+		    bbp->region != -1 || bbn->region != -1)
+			continue;
+
+		if (!(bbp->last_ins->opcode >= CEE_BEQ && bbp->last_ins->opcode <=  CEE_BLT_UN) &&
+		    bbp->last_ins->inst_true_bb != bbn)
+			continue;
+
+
+		if (bb->code->opcode == CEE_STIND_I4) {
+			mono_print_tree (bbp->last_ins);printf("\n");
+			mono_print_tree (bb->code);printf("\n");
+
+			if (bbp->last_ins->opcode == CEE_BNE_UN) {
+				bbp->last_ins->opcode = OP_CMOV_EQ;
+				bbp->last_ins->inst_i1 = bbp->last_ins->inst_i0;
+				bbp->last_ins->inst_i0 = bb->code;
+				bbp->last_ins->inst_i0->opcode = OP_GROUP;
+				bbp->next_bb = bbp->out_bb [0] = bbn;
+				bbp->out_count = 1;
+				{static int c = 0; printf ("CMOV1 %d %s\n", c++, mono_method_full_name (cfg->method, TRUE)); }
+			} else if (bbp->last_ins->opcode == CEE_BEQ) {
+				bbp->last_ins->opcode = OP_CMOV_NE_UN;
+				bbp->last_ins->inst_i1 = bbp->last_ins->inst_i0;
+				bbp->last_ins->inst_i0 = bb->code;
+				bbp->last_ins->inst_i0->opcode = OP_GROUP;
+				bbp->next_bb = bbp->out_bb [0] = bbn;
+				bbp->out_count = 1;
+				{static int c = 0; printf ("CMOV2 %d %s\n", c++, mono_method_full_name (cfg->method, TRUE)); }
+			}
+		}
+	      
+	}
+}
+
+static void
 optimize_branches (MonoCompile *cfg) {
 	int i, changed = FALSE;
 	MonoBasicBlock *bb, *bbn;
@@ -6560,6 +6621,8 @@
 
 	if (cfg->opt & MONO_OPT_CFOLD)
 		mono_constant_fold (cfg);
+
+        cond_moves (cfg);
 
 	mini_select_instructions (cfg);
 
