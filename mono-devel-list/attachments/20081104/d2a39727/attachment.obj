Index: Test/System.Collections.ObjectModel/ReadOnlyObservableCollectionTest.cs
===================================================================
--- Test/System.Collections.ObjectModel/ReadOnlyObservableCollectionTest.cs	(revision 0)
+++ Test/System.Collections.ObjectModel/ReadOnlyObservableCollectionTest.cs	(revision 0)
@@ -0,0 +1,95 @@
+﻿// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+// Authors:
+//	Brian O'Keefe (zer0keefie@gmail.com)
+//
+
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Collections.Specialized;
+using System.ComponentModel;
+using MonoTests.System.Collections.Specialized;
+using NUnit.Framework;
+
+namespace MonoTests.System.Collections.ObjectModel {
+	/// <summary>
+	///This is a test class for ReadOnlyObservableCollectionTest and is intended
+	///to contain all ReadOnlyObservableCollectionTest Unit Tests
+	///</summary>
+	[TestFixture]
+	public class ReadOnlyObservableCollectionTest {
+		[Test]
+		public void ClassTest()
+		{
+			// Because the collection cannot change, check to make sure exceptions are thrown for modifications.
+
+			List<char> initial = new List<char> ();
+			initial.Add ('A');
+			initial.Add ('B');
+			initial.Add ('C');
+
+			ObservableCollection<char> collection = new ObservableCollection<char> (initial);
+			ReadOnlyObservableCollection<char> readOnlyCollection = new ReadOnlyObservableCollection<char> (collection);
+
+			// Test the events
+
+			PropertyChangedEventHandler pceh = delegate (object sender, PropertyChangedEventArgs e) {
+				Assert.Fail ("No properties should change.");
+			};
+
+			NotifyCollectionChangedEventHandler ncceh = delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				Assert.Fail ("The collection should not change.");
+			};
+
+			((INotifyPropertyChanged)readOnlyCollection).PropertyChanged += pceh;
+
+			((INotifyCollectionChanged)readOnlyCollection).CollectionChanged += ncceh;
+
+			// Done with the events.
+			((INotifyPropertyChanged)readOnlyCollection).PropertyChanged -= pceh;
+
+			((INotifyCollectionChanged)readOnlyCollection).CollectionChanged -= ncceh;
+
+			Assert.AreEqual (3, readOnlyCollection.Count, "RO_1");
+			NotifyCollectionChangedEventArgsTest.AssertEquivalentLists (initial, readOnlyCollection, "RO_2");
+
+			// Modifying the underlying collection
+
+			bool propChanged = false;
+
+			pceh = delegate (object sender, PropertyChangedEventArgs e) {
+				propChanged = true;
+			};
+
+			ncceh = delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				NotifyCollectionChangedEventArgsTest.ValidateAddOperation (e, new char [] { 'I' }, 3, "RO_3");
+			};
+
+			((INotifyPropertyChanged)readOnlyCollection).PropertyChanged += pceh;
+
+			((INotifyCollectionChanged)readOnlyCollection).CollectionChanged += ncceh;
+
+			// In theory, this will cause the properties to change.
+			collection.Add ('I');
+
+			Assert.IsTrue (propChanged, "RO_4");
+		}
+	}
+}
Index: Test/System.Collections.ObjectModel/ObservableCollectionTest.cs
===================================================================
--- Test/System.Collections.ObjectModel/ObservableCollectionTest.cs	(revision 117799)
+++ Test/System.Collections.ObjectModel/ObservableCollectionTest.cs	(working copy)
@@ -1,97 +1,387 @@
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-// 
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-// 
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-// Copyright (c) 2007 Novell, Inc. (http://www.novell.com)
-//
-// Authors:
-//	Chris Toshok (toshok@ximian.com)
-//
-
-using System;
-using System.Collections.ObjectModel;
-using System.Collections.Specialized;
-using NUnit.Framework;
-
-namespace MonoTests.System.Collections.ObjectModel {
-
-	[TestFixture]
-	[Category ("NotWorking")]
-	public class ObservableCollectionTest {
-		[Test]
-		public void InsertItem ()
-		{
-			bool reached = false;
-			ObservableCollection<int> col = new ObservableCollection<int>();
-			col.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
-				reached = true;
-				Assert.AreEqual (NotifyCollectionChangedAction.Add, e.Action);
-				Assert.AreEqual (0, e.NewStartingIndex);
-				Assert.AreEqual (-1, e.OldStartingIndex);
-				Assert.AreEqual (1, e.NewItems.Count);
-				Assert.AreEqual (5, (int)e.NewItems[0]);
-				Assert.AreEqual (null, e.OldItems);
-			};
-			col.Insert (0, 5);
-			Assert.IsTrue (reached);
-		}
-
-		[Test]
-		public void Remove ()
-		{
-			bool reached = false;
-			ObservableCollection<int> col = new ObservableCollection<int>();
-			col.Insert (0, 5);
-			col.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
-				reached = true;
-				Assert.AreEqual (NotifyCollectionChangedAction.Remove, e.Action);
-				Assert.AreEqual (-1, e.NewStartingIndex);
-				Assert.AreEqual (0, e.OldStartingIndex);
-				Assert.AreEqual (null, e.NewItems);
-				Assert.AreEqual (1, e.OldItems.Count);
-				Assert.AreEqual (5, (int)e.OldItems[0]);
-			};
-			col.RemoveAt (0);
-			Assert.IsTrue (reached, "reached");
-		}
-
-		[Test]
-		public void Move ()
-		{
-			bool reached = false;
-			ObservableCollection<int> col = new ObservableCollection<int>();
-			col.Insert (0, 0);
-			col.Insert (1, 1);
-			col.Insert (2, 2);
-			col.Insert (3, 3);
-			col.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
-				reached = true;
-				Assert.AreEqual (NotifyCollectionChangedAction.Move, e.Action, "1");
-				Assert.AreEqual (3, e.NewStartingIndex, "2");
-				Assert.AreEqual (1, e.OldStartingIndex, "3");
-				Assert.AreEqual (1, e.NewItems.Count, "4");
-				Assert.AreEqual (1, e.NewItems[0], "5");
-				Assert.AreEqual (1, e.OldItems.Count, "6");
-				Assert.AreEqual (1, e.OldItems[0], "7");
-			};
-			col.Move (1, 3);
-			Assert.IsTrue (reached, "8");
-		}
-	}
-
-}
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+// Copyright (c) 2007 Novell, Inc. (http://www.novell.com)
+//
+// Authors:
+//	Chris Toshok (toshok@ximian.com)
+//	Brian O'Keefe (zer0keefie@gmail.com)
+//
+
+using System.Collections.ObjectModel;
+using System.Collections.Specialized;
+using NUnit.Framework;
+using System.ComponentModel;
+using System.Collections.Generic;
+using System;
+using System.Collections;
+
+namespace MonoTests.System.Collections.ObjectModel {
+
+	[TestFixture]
+	public class ObservableCollectionTest {
+
+		public ObservableCollectionTest()
+		{
+		}
+
+		#region Validators
+
+		/// <summary>
+		/// Helper function to determine if two lists contain the same elements
+		/// </summary>
+		/// <param name="expected">The expected list values</param>
+		/// <param name="actual">The actual list values</param>
+		internal static void AssertEquivalentLists(IList expected, IList actual, string message)
+		{
+			if (expected == null) {
+				Assert.IsNull (actual, "LISTEQ_1A::" + message);
+				return;
+			} else
+				Assert.IsNotNull (actual, "LISTEQ_1B::" + message);
+
+			Assert.AreEqual (expected.Count, actual.Count, "LISTEQ_2::" + message);
+
+			for (int i = 0; i < expected.Count; i++)
+				Assert.AreEqual (expected [i], actual [i], "LISTEQ_3::" + message);
+		}
+
+		private static void ValidateCommon(NotifyCollectionChangedEventArgs args, NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex, string message)
+		{
+			Assert.IsNotNull (args, "NCCVAL_1::" + message);
+
+			Assert.AreEqual (action, args.Action, "NCCVAL_2::" + message);
+
+			AssertEquivalentLists (newItems, args.NewItems, "NCCVAL_3::" + message);
+			AssertEquivalentLists (oldItems, args.OldItems, "NCCVAL_4::" + message);
+
+			Assert.AreEqual (newIndex, args.NewStartingIndex, "NCCVAL_5::" + message);
+			Assert.AreEqual (oldIndex, args.OldStartingIndex, "NCCVAL_6::" + message);
+		}
+
+		/// <summary>
+		/// Validates that a Reset operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		internal static void ValidateResetOperation(NotifyCollectionChangedEventArgs args, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Reset, null, null, -1, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that an Add operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="newItems">The items that were added to the list.</param>
+		internal static void ValidateAddOperation(NotifyCollectionChangedEventArgs args, IList newItems, string message)
+		{
+			ValidateAddOperation (args, newItems, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that an Add operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="newItems">The items that were added to the list.</param>
+		/// <param name="startIndex">The starting index of the change.</param>
+		internal static void ValidateAddOperation(NotifyCollectionChangedEventArgs args, IList newItems, int startIndex, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Add, newItems, null, startIndex, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that a Remove operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="oldItems">The items that were removed from the list.</param>
+		internal static void ValidateRemoveOperation(NotifyCollectionChangedEventArgs args, IList oldItems, string message)
+		{
+			ValidateRemoveOperation (args, oldItems, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that a Remove operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="oldItems">The items that were removed from the list.</param>
+		/// <param name="startIndex">The starting index of the change.</param>
+		internal static void ValidateRemoveOperation(NotifyCollectionChangedEventArgs args, IList oldItems, int startIndex, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Remove, null, oldItems, -1, startIndex, message);
+		}
+
+		/// <summary>
+		/// Validates that a Replace operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="oldItems">The old items.</param>
+		/// <param name="newItems">The new items.</param>
+		internal static void ValidateReplaceOperation(NotifyCollectionChangedEventArgs args, IList oldItems, IList newItems, string message)
+		{
+			ValidateReplaceOperation (args, oldItems, newItems, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that a Replace operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="oldItems">The old items.</param>
+		/// <param name="newItems">The new items.</param>
+		/// <param name="startIndex">The starting index of the change.</param>
+		internal static void ValidateReplaceOperation(NotifyCollectionChangedEventArgs args, IList oldItems, IList newItems, int startIndex, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Replace, newItems, oldItems, startIndex, startIndex, message);
+		}
+
+		/// <summary>
+		/// Validates that a Move operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="changed">The changed items.</param>
+		/// <param name="newIndex">The new index.</param>
+		/// <param name="oldIndex">The old index.</param>
+		internal static void ValidateMoveOperation(NotifyCollectionChangedEventArgs args, IList changedItems, int newIndex, int oldIndex, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Move, changedItems, changedItems, newIndex, oldIndex, message);
+		}
+
+		#endregion
+
+		[Test]
+		public void Insert()
+		{
+			bool reached = false;
+			ObservableCollection<int> col = new ObservableCollection<int> ();
+			col.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				reached = true;
+				Assert.AreEqual (NotifyCollectionChangedAction.Add, e.Action, "INS_1");
+				Assert.AreEqual (0, e.NewStartingIndex, "INS_2");
+				Assert.AreEqual (-1, e.OldStartingIndex, "INS_3");
+				Assert.AreEqual (1, e.NewItems.Count, "INS_4");
+				Assert.AreEqual (5, (int)e.NewItems [0], "INS_5");
+				Assert.AreEqual (null, e.OldItems, "INS_6");
+			};
+			col.Insert (0, 5);
+			Assert.IsTrue (reached, "INS_5");
+		}
+
+		[Test]
+		public void RemoveAt()
+		{
+			bool reached = false;
+			ObservableCollection<int> col = new ObservableCollection<int> ();
+			col.Insert (0, 5);
+			col.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				reached = true;
+				Assert.AreEqual (NotifyCollectionChangedAction.Remove, e.Action, "REMAT_1");
+				Assert.AreEqual (-1, e.NewStartingIndex, "REMAT_2");
+				Assert.AreEqual (0, e.OldStartingIndex, "REMAT_3");
+				Assert.AreEqual (null, e.NewItems, "REMAT_4");
+				Assert.AreEqual (1, e.OldItems.Count, "REMAT_5");
+				Assert.AreEqual (5, (int)e.OldItems [0], "REMAT_6");
+			};
+			col.RemoveAt (0);
+			Assert.IsTrue (reached, "REMAT_7");
+		}
+
+		[Test]
+		public void Move()
+		{
+			bool reached = false;
+			ObservableCollection<int> col = new ObservableCollection<int> ();
+			col.Insert (0, 0);
+			col.Insert (1, 1);
+			col.Insert (2, 2);
+			col.Insert (3, 3);
+			col.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				reached = true;
+				Assert.AreEqual (NotifyCollectionChangedAction.Move, e.Action, "MOVE_1");
+				Assert.AreEqual (3, e.NewStartingIndex, "MOVE_2");
+				Assert.AreEqual (1, e.OldStartingIndex, "MOVE_3");
+				Assert.AreEqual (1, e.NewItems.Count, "MOVE_4");
+				Assert.AreEqual (1, e.NewItems [0], "MOVE_5");
+				Assert.AreEqual (1, e.OldItems.Count, "MOVE_6");
+				Assert.AreEqual (1, e.OldItems [0], "MOVE_7");
+			};
+			col.Move (1, 3);
+			Assert.IsTrue (reached, "MOVE_8");
+		}
+
+		[Test]
+		public void Add()
+		{
+			ObservableCollection<char> collection = new ObservableCollection<char> ();
+			bool propertyChanged = false;
+			List<string> changedProps = new List<string> ();
+			NotifyCollectionChangedEventArgs args = null;
+
+			((INotifyPropertyChanged)collection).PropertyChanged += delegate (object sender, PropertyChangedEventArgs e) {
+				propertyChanged = true;
+				changedProps.Add (e.PropertyName);
+			};
+
+			collection.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				args = e;
+			};
+
+			collection.Add ('A');
+
+			Assert.IsTrue (propertyChanged, "ADD_1");
+			Assert.IsTrue (changedProps.Contains ("Count"), "ADD_2");
+			Assert.IsTrue (changedProps.Contains ("Item[]"), "ADD_3");
+
+			ValidateAddOperation (args, new char [] { 'A' }, 0, "ADD_4");
+		}
+
+		[Test]
+		public void Remove()
+		{
+			ObservableCollection<char> collection = new ObservableCollection<char> ();
+			bool propertyChanged = false;
+			List<string> changedProps = new List<string> ();
+			NotifyCollectionChangedEventArgs args = null;
+
+			collection.Add ('A');
+			collection.Add ('B');
+			collection.Add ('C');
+
+			((INotifyPropertyChanged)collection).PropertyChanged += delegate (object sender, PropertyChangedEventArgs e) {
+				propertyChanged = true;
+				changedProps.Add (e.PropertyName);
+			};
+
+			collection.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				args = e;
+			};
+
+			collection.Remove ('B');
+
+			Assert.IsTrue (propertyChanged, "REM_1");
+			Assert.IsTrue (changedProps.Contains ("Count"), "REM_2");
+			Assert.IsTrue (changedProps.Contains ("Item[]"), "REM_3");
+
+			ValidateRemoveOperation (args, new char [] { 'B' }, 1, "REM_4");
+		}
+
+		[Test]
+		public void Set()
+		{
+			ObservableCollection<char> collection = new ObservableCollection<char> ();
+			bool propertyChanged = false;
+			List<string> changedProps = new List<string> ();
+			NotifyCollectionChangedEventArgs args = null;
+
+			collection.Add ('A');
+			collection.Add ('B');
+			collection.Add ('C');
+
+			((INotifyPropertyChanged)collection).PropertyChanged += delegate (object sender, PropertyChangedEventArgs e) {
+				propertyChanged = true;
+				changedProps.Add (e.PropertyName);
+			};
+
+			collection.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				args = e;
+			};
+
+			collection [2] = 'I';
+
+			Assert.IsTrue (propertyChanged, "SET_1");
+			Assert.IsTrue (changedProps.Contains ("Item[]"), "SET_2");
+
+			ValidateReplaceOperation (args, new char [] { 'C' }, new char [] { 'I' }, 2, "SET_3");
+		}
+
+		[Test]
+		public void Reentrant()
+		{
+			ObservableCollection<char> collection = new ObservableCollection<char> ();
+			bool propertyChanged = false;
+			List<string> changedProps = new List<string> ();
+			NotifyCollectionChangedEventArgs args = null;
+
+			collection.Add ('A');
+			collection.Add ('B');
+			collection.Add ('C');
+
+			PropertyChangedEventHandler pceh = delegate (object sender, PropertyChangedEventArgs e) {
+				propertyChanged = true;
+				changedProps.Add (e.PropertyName);
+			};
+
+			// Adding a PropertyChanged event handler
+			((INotifyPropertyChanged)collection).PropertyChanged += pceh;
+
+			collection.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				args = e;
+			};
+
+			collection.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				// This one will attempt to break reentrancy
+				try {
+					collection.Add ('X');
+					Assert.Fail ("Reentrancy should not be allowed.");
+				} catch (InvalidOperationException) {
+				}
+			};
+
+			collection [2] = 'I';
+
+			Assert.IsTrue (propertyChanged, "REENT_1");
+			Assert.IsTrue (changedProps.Contains ("Item[]"), "REENT_2");
+
+			ValidateReplaceOperation (args, new char [] { 'C' }, new char [] { 'I' }, 2, "REENT_3");
+
+			// Removing the PropertyChanged event handler should work as well:
+			((INotifyPropertyChanged)collection).PropertyChanged -= pceh;
+		}
+
+		[Test]
+		public void Clear()
+		{
+			List<char> initial = new List<char> ();
+
+			initial.Add ('A');
+			initial.Add ('B');
+			initial.Add ('C');
+
+			ObservableCollection<char> collection = new ObservableCollection<char> (initial);
+			bool propertyChanged = false;
+			List<string> changedProps = new List<string> ();
+			NotifyCollectionChangedEventArgs args = null;
+
+			((INotifyPropertyChanged)collection).PropertyChanged += delegate (object sender, PropertyChangedEventArgs e) {
+				propertyChanged = true;
+				changedProps.Add (e.PropertyName);
+			};
+
+			collection.CollectionChanged += delegate (object sender, NotifyCollectionChangedEventArgs e) {
+				args = e;
+			};
+
+			collection.Clear ();
+
+			Assert.IsTrue (propertyChanged, "CLEAR_1");
+			Assert.IsTrue (changedProps.Contains ("Count"), "CLEAR_2");
+			Assert.IsTrue (changedProps.Contains ("Item[]"), "CLEAR_3");
+
+			ValidateResetOperation (args, "CLEAR_4");
+		}
+	}
+}
Index: Test/System.Collections.Specialized/NotifyCollectionChangedEventArgsTest.cs
===================================================================
--- Test/System.Collections.Specialized/NotifyCollectionChangedEventArgsTest.cs	(revision 0)
+++ Test/System.Collections.Specialized/NotifyCollectionChangedEventArgsTest.cs	(revision 0)
@@ -0,0 +1,870 @@
+﻿// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+// Authors:
+//	Brian O'Keefe (zer0keefie@gmail.com)
+//
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.Specialized;
+using NUnit.Framework;
+
+namespace MonoTests.System.Collections.Specialized {
+	/// <summary>
+	/// Contains test cases for WindowsBase::System.Collections.Specialized.*
+	/// </summary>
+	[TestFixture]
+	public class NotifyCollectionChangedEventArgsTest {
+		public NotifyCollectionChangedEventArgsTest()
+		{
+		}
+
+		#region Validators
+
+		/// <summary>
+		/// Helper function to determine if two lists contain the same elements
+		/// </summary>
+		/// <param name="expected">The expected list values</param>
+		/// <param name="actual">The actual list values</param>
+		internal static void AssertEquivalentLists(IList expected, IList actual, string message)
+		{
+			if (expected == null) {
+				Assert.IsNull (actual, "LISTEQ_1A::" + message);
+				return;
+			} else
+				Assert.IsNotNull (actual, "LISTEQ_1B::" + message);
+
+			Assert.AreEqual (expected.Count, actual.Count, "LISTEQ_2::" + message);
+
+			for (int i = 0; i < expected.Count; i++)
+				Assert.AreEqual (expected [i], actual [i], "LISTEQ_3::" + message);
+		}
+
+		private static void ValidateCommon(NotifyCollectionChangedEventArgs args, NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex, string message)
+		{
+			Assert.IsNotNull (args, "NCCVAL_1::" + message);
+
+			Assert.AreEqual (action, args.Action, "NCCVAL_2::" + message);
+
+			AssertEquivalentLists (newItems, args.NewItems, "NCCVAL_3::" + message);
+			AssertEquivalentLists (oldItems, args.OldItems, "NCCVAL_4::" + message);
+
+			Assert.AreEqual (newIndex, args.NewStartingIndex, "NCCVAL_5::" + message);
+			Assert.AreEqual (oldIndex, args.OldStartingIndex, "NCCVAL_6::" + message);
+		}
+
+		/// <summary>
+		/// Validates that a Reset operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		internal static void ValidateResetOperation(NotifyCollectionChangedEventArgs args, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Reset, null, null, -1, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that an Add operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="newItems">The items that were added to the list.</param>
+		internal static void ValidateAddOperation(NotifyCollectionChangedEventArgs args, IList newItems, string message)
+		{
+			ValidateAddOperation (args, newItems, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that an Add operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="newItems">The items that were added to the list.</param>
+		/// <param name="startIndex">The starting index of the change.</param>
+		internal static void ValidateAddOperation(NotifyCollectionChangedEventArgs args, IList newItems, int startIndex, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Add, newItems, null, startIndex, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that a Remove operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="oldItems">The items that were removed from the list.</param>
+		internal static void ValidateRemoveOperation(NotifyCollectionChangedEventArgs args, IList oldItems, string message)
+		{
+			ValidateRemoveOperation (args, oldItems, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that a Remove operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="oldItems">The items that were removed from the list.</param>
+		/// <param name="startIndex">The starting index of the change.</param>
+		internal static void ValidateRemoveOperation(NotifyCollectionChangedEventArgs args, IList oldItems, int startIndex, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Remove, null, oldItems, -1, startIndex, message);
+		}
+
+		/// <summary>
+		/// Validates that a Replace operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="oldItems">The old items.</param>
+		/// <param name="newItems">The new items.</param>
+		internal static void ValidateReplaceOperation(NotifyCollectionChangedEventArgs args, IList oldItems, IList newItems, string message)
+		{
+			ValidateReplaceOperation (args, oldItems, newItems, -1, message);
+		}
+
+		/// <summary>
+		/// Validates that a Replace operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="oldItems">The old items.</param>
+		/// <param name="newItems">The new items.</param>
+		/// <param name="startIndex">The starting index of the change.</param>
+		internal static void ValidateReplaceOperation(NotifyCollectionChangedEventArgs args, IList oldItems, IList newItems, int startIndex, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Replace, newItems, oldItems, startIndex, startIndex, message);
+		}
+
+		/// <summary>
+		/// Validates that a Move operation was successful.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		/// <param name="changed">The changed items.</param>
+		/// <param name="newIndex">The new index.</param>
+		/// <param name="oldIndex">The old index.</param>
+		internal static void ValidateMoveOperation(NotifyCollectionChangedEventArgs args, IList changedItems, int newIndex, int oldIndex, string message)
+		{
+			ValidateCommon (args, NotifyCollectionChangedAction.Move, changedItems, changedItems, newIndex, oldIndex, message);
+		}
+
+		#endregion
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor1Test()
+		{
+			/* Expected Behavior:
+			 *
+			 * If action is Reset, success.
+			 * If action is not Reset, throw an ArgumentException
+			 */
+
+			// Trying with Reset
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset);
+
+			ValidateResetOperation (args, "#A01");
+
+			// Trying with Add
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Add.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Remove
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Remove.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Move
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Move.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Replace
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Replace.");
+			} catch (ArgumentException) {
+			}
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, IList)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor2Test()
+		{
+			/* Expected Behavior:
+			 * 
+			 * If action is Add, success.
+			 * If action is Remove, success.
+			 * If action is Reset:
+			 *    If changedItems is null, success.
+			 *    If changedItems is non-null, throw an Argument Exception
+			 * If action is Move or Replace, throw an Argument Exception
+			 */
+
+			IList changedItems = new List<object> ();
+
+			// Trying with Add
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, changedItems);
+
+			ValidateAddOperation (args, changedItems, "#B01");
+
+			// Trying to add a null array
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, (IList)null);
+				Assert.Fail ("Cannot call .ctor if changedItems is null.");
+			} catch (ArgumentNullException) {
+			}
+
+			// Trying with Remove
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, changedItems);
+
+			ValidateRemoveOperation (args, changedItems, "#B02");
+
+			// Trying with Reset (works if changedItems is null)
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, (IList)null);
+
+			ValidateResetOperation (args, "#B03");
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, changedItems);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Move
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, changedItems);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Move.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Replace
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, changedItems);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Replace.");
+			} catch (ArgumentException) {
+			}
+
+			// Add some items, and repeat
+			changedItems.Add (new object ());
+			changedItems.Add (new object ());
+			changedItems.Add (new object ());
+
+			// Trying with Add
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, changedItems);
+
+			ValidateAddOperation (args, changedItems, "#B04");
+
+			// Trying with Remove
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, changedItems);
+
+			ValidateRemoveOperation (args, changedItems, "#B05");
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, Object)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor3Test()
+		{
+			/* Expected Behavior:
+			 * 
+			 * If action is Add, success.
+			 * If action is Remove, success.
+			 * If action is Reset:
+			 *    If changedItem is null, success.
+			 *    If changedItem is non-null, throw an Argument Exception
+			 * If action is Move or Replace, throw an Argument Exception
+			 */
+
+			object changedItem = new object ();
+
+			// Trying with Add
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, changedItem);
+
+			ValidateAddOperation (args, new object [] { changedItem }, "#C01");
+
+			// Trying with Remove
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, changedItem);
+
+			ValidateRemoveOperation (args, new object [] { changedItem }, "#C02");
+
+			// Trying with Reset
+
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, (object)null);
+
+			ValidateResetOperation (args, "#C03");
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, changedItem);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Move
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, changedItem);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Move.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Replace
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, changedItem);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Replace.");
+			} catch (ArgumentException) {
+			}
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, IList, IList)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor4Test()
+		{
+			/* Expected Behavior:
+			 * 
+			 * If action is Replace:
+			 *    If newItems is null, throw an ArgumentNullException.
+			 *    If oldItems is null, throw an ArgumentNullException
+			 *    Otherwise, success.
+			 * If action is not Replace, throw an ArgumentException
+			 */
+
+			IList newItems = new List<object> ();
+			IList oldItems = new List<object> ();
+
+			// Trying with Replace
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItems, oldItems);
+
+			ValidateReplaceOperation (args, oldItems, newItems, "#D01");
+
+			// Add some items to test this one.
+			newItems.Add (new object ());
+			newItems.Add (new object ());
+			newItems.Add (new object ());
+
+			// Trying with Replace again
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItems, oldItems);
+
+			ValidateReplaceOperation (args, oldItems, newItems, "#D02");
+
+			// Add some more items to test this one.
+			oldItems.Add (new object ());
+			oldItems.Add (new object ());
+			oldItems.Add (new object ());
+
+			// Trying with Replace again
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItems, oldItems);
+
+			ValidateReplaceOperation (args, oldItems, newItems, "#D03");
+
+			// Trying with null arguments.
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, (IList)null, oldItems);
+				Assert.Fail ("The newItems argument cannot be null.");
+			} catch (ArgumentNullException) {
+			}
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItems, (IList)null);
+				Assert.Fail ("The oldItems argument cannot be null.");
+			} catch (ArgumentNullException) {
+			}
+
+			// Trying with Reset
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, newItems, oldItems);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Move
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, newItems, oldItems);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Move.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Add
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, newItems, oldItems);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Add.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Remove
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, newItems, oldItems);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Remove.");
+			} catch (ArgumentException) {
+			}
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, IList, Int32)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor5Test()
+		{
+			/* Expected Behavior:
+			 * 
+			 * If action is Add or Remove:
+			 *    If changedItems is null, throw an ArgumentNullException.
+			 *    If startingIndex < -1, throw an ArgumentException
+			 *    Otherwise, success.
+			 * If action is Reset:
+			 *    If changedItems is non-null, throw an ArgumentException
+			 *    If startingIndex != 0, throw an ArgumentException
+			 *    Otherwise, success.
+			 * If action is Move or Replace, throw an ArgumentException
+			 */
+
+			IList changedItems = new List<object> ();
+			int startingIndex = 5; // Doesn't matter what the value of this is.
+
+			// Trying with Add
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, changedItems, startingIndex);
+
+			ValidateAddOperation (args, changedItems, startingIndex, "#E01");
+
+			// Trying with Remove
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, changedItems, startingIndex);
+
+			ValidateRemoveOperation (args, changedItems, startingIndex, "#E02");
+
+			// Add some items to test this one.
+			changedItems.Add (new object ());
+			changedItems.Add (new object ());
+			changedItems.Add (new object ());
+
+			// Trying with Add
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, changedItems, startingIndex);
+
+			ValidateAddOperation (args, changedItems, startingIndex, "#E03");
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, changedItems, -5);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Add if startingIndex < -1.");
+			} catch (ArgumentException) {
+			}
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, (IList)null, startingIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Add if changedItems is null.");
+			} catch (ArgumentNullException) {
+			}
+
+			// Trying with Remove
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, changedItems, startingIndex);
+
+			ValidateRemoveOperation (args, changedItems, startingIndex, "#E04");
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, changedItems, -5);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Remove if startingIndex < -1.");
+			} catch (ArgumentException) {
+			}
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, (IList)null, startingIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Remove if changedItems is null.");
+			} catch (ArgumentNullException) {
+			}
+
+			// Trying with Reset
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, (IList)null, -1);
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, changedItems, -1);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset unless changeItems is null");
+			} catch (ArgumentException) {
+			}
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, (IList)null, 1);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset unless startingIndex is -1");
+			} catch (ArgumentException) {
+			}
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, changedItems, startingIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Move
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, changedItems, startingIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Move.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Replace
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, changedItems, startingIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Replace.");
+			} catch (ArgumentException) {
+			}
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, Object, Int32)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor6Test()
+		{
+			object changedItem = new object ();
+			int startingIndex = 5; // Doesn't matter what the value of this is.
+
+			// Trying with Add
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, changedItem, startingIndex);
+
+			ValidateAddOperation (args, new object [] { changedItem }, startingIndex, "#F01");
+
+			// Trying with Remove
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, changedItem, startingIndex);
+
+			ValidateRemoveOperation (args, new object [] { changedItem }, startingIndex, "#F02");
+
+			// Trying with Reset
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, (object)null, -1);
+
+			ValidateResetOperation (args, "#F03");
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, changedItem, -1);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset unless changeItems is null");
+			} catch (ArgumentException) {
+			}
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, (object)null, 1);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset unless startingIndex is -1");
+			} catch (ArgumentException) {
+			}
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, changedItem, startingIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Move
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, changedItem, startingIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Move.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Replace
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, changedItem, startingIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Replace.");
+			} catch (ArgumentException) {
+			}
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, Object, Object)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor7Test()
+		{
+			object oldItem = new object ();
+			object newItem = new object (); // Doesn't matter what the value of this is.
+
+			// Trying with Add
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItem, oldItem);
+			ValidateReplaceOperation (args, new object [] { oldItem }, new object [] { newItem }, "#G01");
+
+			// Trying null items
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, (object)null, oldItem);
+			ValidateReplaceOperation (args, new object [] { oldItem }, new object [] { null }, "#G02");
+
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItem, (object)null);
+			ValidateReplaceOperation (args, new object [] { null }, new object [] { newItem }, "#G03");
+
+			// Trying with Reset
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, newItem, oldItem);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Move
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, newItem, oldItem);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Move.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Add
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, newItem, oldItem);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Add.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Remove
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, newItem, oldItem);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Remove.");
+			} catch (ArgumentException) {
+			}
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, IList, IList, Int32)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor8Test()
+		{
+			IList newItems = new List<object> ();
+			IList oldItems = new List<object> ();
+			int startIndex = 5;
+
+			// Trying with Replace
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItems, oldItems, startIndex);
+
+			ValidateReplaceOperation (args, oldItems, newItems, startIndex, "#H01");
+
+			// Add some items to test this one.
+			newItems.Add (new object ());
+			newItems.Add (new object ());
+			newItems.Add (new object ());
+
+			// Trying with Replace again
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItems, oldItems, startIndex);
+
+			ValidateReplaceOperation (args, oldItems, newItems, startIndex, "#H02");
+
+			// Add some more items to test this one.
+			oldItems.Add (new object ());
+			oldItems.Add (new object ());
+			oldItems.Add (new object ());
+
+			// Trying with Replace again
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItems, oldItems, startIndex);
+
+			ValidateReplaceOperation (args, oldItems, newItems, startIndex, "#H03");
+
+			// Trying with null arguments.
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, (IList)null, oldItems, startIndex);
+				Assert.Fail ("The newItems argument cannot be null.");
+			} catch (ArgumentNullException) {
+			}
+
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItems, (IList)null, startIndex);
+				Assert.Fail ("The oldItems argument cannot be null.");
+			} catch (ArgumentNullException) {
+			}
+
+			// Trying with Reset
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, newItems, oldItems, startIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Move
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, newItems, oldItems, startIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Move.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Add
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, newItems, oldItems, startIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Add.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Remove
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, newItems, oldItems);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Remove.");
+			} catch (ArgumentException) {
+			}
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, IList, Int32, Int32)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor9Test()
+		{
+			IList changed = new List<object> ();
+			int newIndex = 2;
+			int oldIndex = 5;
+
+			// Trying with Replace
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, changed, newIndex, oldIndex);
+
+			ValidateMoveOperation (args, changed, newIndex, oldIndex, "#I01");
+
+			// Add some items to test this one.
+			changed.Add (new object ());
+			changed.Add (new object ());
+			changed.Add (new object ());
+
+			// Trying with Replace again
+			args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, changed, newIndex, oldIndex);
+
+			ValidateMoveOperation (args, changed, newIndex, oldIndex, "#I02");
+
+			// Trying with newIndex < 0.
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, changed, -5, oldIndex);
+				Assert.Fail ("The index argument cannot be less than 0.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Reset
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, changed, newIndex, oldIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Replace
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, changed, newIndex, oldIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Replace.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Add
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, changed, newIndex, oldIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Add.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Remove
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, changed, newIndex, oldIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Remove.");
+			} catch (ArgumentException) {
+			}
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, Object, Int32, Int32)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor10Test()
+		{
+			object changed = new object ();
+			int newIndex = 2;
+			int oldIndex = 5;
+
+			// Trying with Replace
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, changed, newIndex, oldIndex);
+
+			ValidateMoveOperation (args, new object [] { changed }, newIndex, oldIndex, "#J01");
+
+			// Trying with newIndex < 0.
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, changed, -5, oldIndex);
+				Assert.Fail ("The newIndex argument cannot be less than 0.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Reset
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, changed, newIndex, oldIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Replace
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, changed, newIndex, oldIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Replace.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Add
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, changed, newIndex, oldIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Add.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Remove
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, changed, newIndex, oldIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Remove.");
+			} catch (ArgumentException) {
+			}
+		}
+
+		/// <summary>
+		/// Tests NotifyCollectionChangedEventArgs..ctor(NotifyCollectionChangedAction, Object, Object, Int32)
+		/// </summary>
+		[Test]
+		public void NotifyCollectionChangedEventArgsConstructor11Test()
+		{
+			object newItem = new object ();
+			object oldItem = new object ();
+			int startIndex = 5;
+
+			// Trying with Replace
+			NotifyCollectionChangedEventArgs args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, newItem, oldItem, startIndex);
+
+			ValidateReplaceOperation (args, new object [] { oldItem }, new object [] { newItem }, startIndex, "#K01");
+
+			// Trying with Reset
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset, newItem, oldItem, startIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Reset.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Move
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, newItem, oldItem, startIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Move.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Add
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, newItem, oldItem, startIndex);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Add.");
+			} catch (ArgumentException) {
+			}
+
+			// Trying with Remove
+			try {
+				args = new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, newItem, oldItem);
+				Assert.Fail ("Should not be able to call .ctor with NotifyCollectionChangedAction.Remove.");
+			} catch (ArgumentException) {
+			}
+		}
+	}
+}
Index: System.Collections.ObjectModel/ReadOnlyObservableCollection.cs
===================================================================
--- System.Collections.ObjectModel/ReadOnlyObservableCollection.cs	(revision 117799)
+++ System.Collections.ObjectModel/ReadOnlyObservableCollection.cs	(working copy)
@@ -21,45 +21,100 @@
 //
 // Authors:
 //	Chris Toshok (toshok@novell.com)
+//	Brian O'Keefe (zer0keefie@gmail.com)
 //
 
-using System;
-using System.Collections.Generic;
 using System.Collections.Specialized;
 using System.ComponentModel;
 
 namespace System.Collections.ObjectModel {
-
-	public class ReadOnlyObservableCollection<T> : ReadOnlyCollection<T>, INotifyCollectionChanged, INotifyPropertyChanged
-	{
-		public ReadOnlyObservableCollection (ObservableCollection<T> list)
+	/// <summary>
+	/// Implements a read-only wrapper around an <see cref="ObservableCollection`1"/>.
+	/// </summary>
+	/// <typeparam name="T">The type of items in the collection</typeparam>
+	public class ReadOnlyObservableCollection<T> : ReadOnlyCollection<T>, INotifyCollectionChanged, INotifyPropertyChanged {
+		/// <summary>
+		/// Initializes a new instance of the <see cref="ReadOnlyObservableCollection`1"/> class.
+		/// </summary>
+		/// <param name="list">The <see cref="ObservableCollection`1"/> to wrap.</param>
+		public ReadOnlyObservableCollection(ObservableCollection<T> list)
 			: base (list)
 		{
+			((INotifyPropertyChanged)list).PropertyChanged += SourceCollection_PropertyChanged;
+			((INotifyCollectionChanged)list).CollectionChanged += SourceCollection_CollectionChanged;
 		}
 
+		/// <summary>
+		/// Occurs when the collection changes.
+		/// </summary>
 		protected virtual event NotifyCollectionChangedEventHandler CollectionChanged;
+
+		/// <summary>
+		/// Occurs when a property value changes.
+		/// </summary>
 		protected virtual event PropertyChangedEventHandler PropertyChanged;
 
-		event NotifyCollectionChangedEventHandler INotifyCollectionChanged.CollectionChanged {
+		/// <summary>
+		/// Occurs when the collection changes.
+		/// </summary>
+		event NotifyCollectionChangedEventHandler INotifyCollectionChanged.CollectionChanged
+		{
 			add { this.CollectionChanged += value; }
 			remove { this.CollectionChanged -= value; }
 		}
-		event PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged {
+
+		/// <summary>
+		/// Occurs when a property value changes.
+		/// </summary>
+		event PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged
+		{
 			add { this.PropertyChanged += value; }
 			remove { this.PropertyChanged -= value; }
 		}
 
-		protected virtual void OnCollectionChanged (NotifyCollectionChangedEventArgs args)
+		/// <summary>
+		/// Raises the <see cref="E:CollectionChanged"/> event.
+		/// </summary>
+		/// <param name="args">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs args)
 		{
-			if (CollectionChanged != null)
-				CollectionChanged (this, args);
+			NotifyCollectionChangedEventHandler eh = CollectionChanged;
+
+			if (eh != null)
+				eh (this, args);
 		}
 
-		protected virtual void OnPropertyChanged (PropertyChangedEventArgs args)
+		/// <summary>
+		/// Raises the <see cref="E:PropertyChanged"/> event.
+		/// </summary>
+		/// <param name="args">The <see cref="System.ComponentModel.PropertyChangedEventArgs"/> instance containing the event data.</param>
+		protected virtual void OnPropertyChanged(PropertyChangedEventArgs args)
 		{
-			if (PropertyChanged != null)
-				PropertyChanged (this, args);
+			PropertyChangedEventHandler eh = PropertyChanged;
+
+			if (eh != null)
+				eh (this, args);
 		}
+
+		/// <summary>
+		/// Handles the CollectionChanged event of the source <see cref="ObservableCollection`1"/>.
+		/// </summary>
+		/// <param name="sender">The source of the event.</param>
+		/// <param name="e">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		private void SourceCollection_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
+		{
+			OnCollectionChanged (e);
+		}
+
+		/// <summary>
+		/// Handles the PropertyChanged event of the <see cref="ObservableCollection`1"/>.
+		/// </summary>
+		/// <param name="sender">The source of the event.</param>
+		/// <param name="e">The <see cref="System.ComponentModel.PropertyChangedEventArgs"/> instance containing the event data.</param>
+		private void SourceCollection_PropertyChanged(object sender, PropertyChangedEventArgs e)
+		{
+			OnPropertyChanged (e);
+		}
 	}
 
 }
Index: System.Collections.ObjectModel/ObservableCollection.cs
===================================================================
--- System.Collections.ObjectModel/ObservableCollection.cs	(revision 117799)
+++ System.Collections.ObjectModel/ObservableCollection.cs	(working copy)
@@ -21,78 +21,232 @@
 //
 // Authors:
 //	Chris Toshok (toshok@novell.com)
+//	Brian O'Keefe (zer0keefie@gmail.com)
 //
 
-using System;
 using System.Collections.Generic;
 using System.Collections.Specialized;
 using System.ComponentModel;
 
 namespace System.Collections.ObjectModel {
+	/// <summary>
+	/// Represents a dynamic data collection that provides notifications when items get added, removed, or when the whole list is refreshed.
+	/// </summary>
+	/// <typeparam name="T">The type of elements in the collection.</typeparam>
+	[Serializable]
+	public class ObservableCollection<T> : Collection<T>, INotifyCollectionChanged, INotifyPropertyChanged {
+		/// <summary>
+		/// Provides the <see cref="IDisposable"/> object returned by a call to <see cref="ObservableCollection.BlockReentrancy"/>.
+		/// </summary>
+		private class Reentrant : IDisposable {
+			private int count = 0;
 
-	[Serializable]
-	public class ObservableCollection<T> : Collection<T>, INotifyCollectionChanged, INotifyPropertyChanged
-	{
+			public Reentrant()
+			{
+			}
+
+			public void Enter()
+			{
+				count++;
+			}
+
+			public void Dispose()
+			{
+				count--;
+			}
+
+			public bool Busy
+			{
+				get { return count > 0; }
+			}
+		}
+
+		private Reentrant reentrant = new Reentrant ();
+
+		/// <summary>
+		/// Initializes a new instance of the <see cref="ObservableCollection`1"/> class.
+		/// </summary>
 		public ObservableCollection()
 		{
 		}
 
+		/// <summary>
+		/// Initializes a new instance of the <see cref="ObservableCollection`1"/> class that contains elements copied from the specified list.
+		/// </summary>
+		/// <param name="list">The list from which the elements are copied.</param>
 		public ObservableCollection(List<T> list)
 			: base (list)
- 		{
+		{
 		}
 
+		/// <summary>
+		/// Occurs when the collection changes.
+		/// </summary>
 		public virtual event NotifyCollectionChangedEventHandler CollectionChanged;
+
+		/// <summary>
+		/// Occurs when a property value changes.
+		/// </summary>
 		protected virtual event PropertyChangedEventHandler PropertyChanged;
 
-		event PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged {
+		/// <summary>
+		/// Occurs when a property value changes.
+		/// </summary>
+		event PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged
+		{
 			add { this.PropertyChanged += value; }
 			remove { this.PropertyChanged -= value; }
 		}
 
-		protected IDisposable BlockReentrancy ()
+		/// <summary>
+		/// Disallows reentrant attempts to change this collection.
+		/// </summary>
+		/// <returns>An <see cref="IDisposable"/> that will re-allow reentrancy when it is disposed.</returns>
+		protected IDisposable BlockReentrancy()
 		{
-			return null;
+			reentrant.Enter ();
+			return reentrant;
 		}
 
-		protected void CheckReentrancy ()
+		/// <summary>
+		/// Checks for reentrant attempts to change this collection.
+		/// </summary>
+		protected void CheckReentrancy()
 		{
+			NotifyCollectionChangedEventHandler eh = CollectionChanged;
+
+			// Only have a problem if we have more than one event listener.
+			if (reentrant.Busy && eh != null && eh.GetInvocationList ().Length > 1)
+				throw new InvalidOperationException ("Cannot modify the collection while reentrancy is blocked.");
 		}
 
-		protected override void ClearItems ()
+		/// <summary>
+		/// Removes all elements from the <see cref="T:System.Collections.ObjectModel.Collection`1"/>.
+		/// </summary>
+		protected override void ClearItems()
 		{
+			CheckReentrancy ();
+
+			base.ClearItems ();
+
+			OnCollectionChanged (new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Reset));
+			OnPropertyChanged (new PropertyChangedEventArgs ("Count"));
+			OnPropertyChanged (new PropertyChangedEventArgs ("Item[]"));
 		}
 
-		protected override void InsertItem (int index, T item)
+		/// <summary>
+		/// Inserts an element into the <see cref="T:System.Collections.ObjectModel.Collection`1"/> at the specified index.
+		/// </summary>
+		/// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
+		/// <param name="item">The object to insert. The value can be null for reference types.</param>
+		/// <exception cref="T:System.ArgumentOutOfRangeException">
+		/// 	<paramref name="index"/> is less than zero.-or-<paramref name="index"/> is greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.</exception>
+		protected override void InsertItem(int index, T item)
 		{
+			CheckReentrancy ();
+
+			base.InsertItem (index, item);
+
+			OnCollectionChanged (new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Add, item, index));
+			OnPropertyChanged (new PropertyChangedEventArgs ("Count"));
+			OnPropertyChanged (new PropertyChangedEventArgs ("Item[]"));
 		}
 
-		public void Move (int oldIndex, int newIndex)
+		/// <summary>
+		/// Moves an element in the <see cref="T:System.Collections.ObjectModel.Collection`1"/> from the specified old index to the specified new index.
+		/// </summary>
+		/// <param name="oldIndex">The old index of the item.</param>
+		/// <param name="newIndex">The new index of the item.</param>
+		public void Move(int oldIndex, int newIndex)
 		{
+			MoveItem (oldIndex, newIndex);
 		}
 
-		protected virtual void MoveItem (int oldIndex, int newIndex)
+		/// <summary>
+		/// Moves an element in the <see cref="T:System.Collections.ObjectModel.Collection`1"/> from the specified old index to the specified new index.
+		/// </summary>
+		/// <param name="oldIndex">The zero-based index at which the item is located before the move.</param>
+		/// <param name="newIndex">The zero-based index at which the item is located after the move.</param>
+		/// <exception cref="T:System.ArgumentOutOfRangeException">
+		/// 	<paramref name="oldIndex"/> or <paramref name="newIndex"/> is less than zero.-or-
+		/// 	<paramref name="oldIndex"/> or <paramref name="newIndex"/> is greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.</exception>
+		protected virtual void MoveItem(int oldIndex, int newIndex)
 		{
+			CheckReentrancy ();
+
+			T item = Items [oldIndex];
+			base.RemoveItem (oldIndex);
+			base.InsertItem (newIndex, item);
+
+			OnCollectionChanged (new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move, item, newIndex, oldIndex));
+			OnPropertyChanged (new PropertyChangedEventArgs ("Item[]"));
 		}
 
-		protected virtual void OnCollectionChanged (NotifyCollectionChangedEventArgs e)
+		/// <summary>
+		/// Raises the <see cref="E:CollectionChanged"/> event.
+		/// </summary>
+		/// <param name="e">The <see cref="System.Collections.Specialized.NotifyCollectionChangedEventArgs"/> instance containing the event data.</param>
+		protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
 		{
-			if (CollectionChanged != null)
-				CollectionChanged (this, e);
+			NotifyCollectionChangedEventHandler eh = CollectionChanged;
+
+			if (eh != null) {
+				// Make sure that the invocation is done before the collection changes,
+				// Otherwise there's a chance of data corruption.
+				using (BlockReentrancy ()) {
+					eh (this, e);
+				}
+			}
 		}
 
-		protected virtual void OnPropertyChanged (PropertyChangedEventArgs e)
+		/// <summary>
+		/// Raises the <see cref="E:PropertyChanged"/> event.
+		/// </summary>
+		/// <param name="e">The <see cref="System.ComponentModel.PropertyChangedEventArgs"/> instance containing the event data.</param>
+		protected virtual void OnPropertyChanged(PropertyChangedEventArgs e)
 		{
-			if (PropertyChanged != null)
-				PropertyChanged (this, e);
+			PropertyChangedEventHandler eh = PropertyChanged;
+
+			if (eh != null)
+				eh (this, e);
 		}
 
-		protected override void RemoveItem (int index)
+		/// <summary>
+		/// Removes the element at the specified index of the <see cref="T:System.Collections.ObjectModel.Collection`1"/>.
+		/// </summary>
+		/// <param name="index">The zero-based index of the element to remove.</param>
+		/// <exception cref="T:System.ArgumentOutOfRangeException">
+		/// 	<paramref name="index"/> is less than zero.-or-<paramref name="index"/> is equal to or greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.</exception>
+		protected override void RemoveItem(int index)
 		{
+			CheckReentrancy ();
+
+			T item = Items [index];
+
+			base.RemoveItem (index);
+
+			OnCollectionChanged (new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Remove, item, index));
+			OnPropertyChanged (new PropertyChangedEventArgs ("Count"));
+			OnPropertyChanged (new PropertyChangedEventArgs ("Item[]"));
 		}
 
-		protected override void SetItem (int index, T item)
+		/// <summary>
+		/// Replaces the element at the specified index.
+		/// </summary>
+		/// <param name="index">The zero-based index of the element to replace.</param>
+		/// <param name="item">The new value for the element at the specified index. The value can be null for reference types.</param>
+		/// <exception cref="T:System.ArgumentOutOfRangeException">
+		/// 	<paramref name="index"/> is less than zero.-or-<paramref name="index"/> is greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.</exception>
+		protected override void SetItem(int index, T item)
 		{
+			CheckReentrancy ();
+
+			T oldItem = Items [index];
+
+			base.SetItem (index, item);
+
+			OnCollectionChanged (new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace, item, oldItem, index));
+			OnPropertyChanged (new PropertyChangedEventArgs ("Item[]"));
 		}
 	}
 }
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 117799)
+++ ChangeLog	(working copy)
@@ -1,34 +1,16 @@
-2008-11-03  Alan McGovern  <alan.mcgovern@gmail.com>
+2008-11-03  Brian O'Keefe  <zer0keefie@gmail.com>
 
-	* System.Windows/WeakEventManager.cs:
-	* System.IO.Packaging/ZipPackagePart.cs: Fix the two remaining API
-	points which shouldn't be exposed.
+	* System.Collections.ObjectModel/ObservableCollection.cs:
+	* System.Collections.ObjectModel/ReadOnlyObservableCollection.cs: 
+	* System.Collections.ObjectModel/INotifyCollectionChanged.cs:
+	* System.Collections.ObjectModel/INotifyCollectionChanged.cs:
+	* System.Collections.ObjectModel/NotifyCollectionChangedAction.cs:
+	* System.Collections.ObjectModel/NotifyCollectionChangedEventArgs.cs:
+	* System.Collections.ObjectModel/NotifyCollectionChangedEventHandler.cs:
+	Add implementations for ObservableCollection and expand documentation
 
-2008-11-03  Alan McGovern  <alan.mcgovern@gmail.com>
-
-	* System.IO.Packaging/Package.cs: Temporary fix test failure until a
-	proper solution can be worked out.
-
-2008-11-03  Alan McGovern  <alan.mcgovern@gmail.com>
-
-	* Test/System.IO.Packaging/PackageTest.cs: Enable test now that it works
-
-2008-11-03  Alan McGovern  <alan.mcgovern@gmail.com>
-
-	* System.IO.Packaging/Package.cs: Fix build and also test that the
-	archive is valid when loading an existing archive.
-
 2008-11-03  Alan McGovern  <amcgovern@novell.com>
 
-	* System.IO.Packaging/Check.cs:
-	* System.IO.Packaging/Package.cs:
-	* System.IO.Packaging/PackagePart.cs:
-	* System.IO.Packaging/ZipPartStream.cs:
-	* Test/System.IO.Packaging/PackageTest.cs: Add tests to ensure that if a
-	package is readonly it won't be written to
-
-2008-11-03  Alan McGovern  <amcgovern@novell.com>
-
 	* ZipSharp/NativeZip.cs:
 	* ZipSharp/ZipArchive.cs:
 	* ZipSharp/NativeUnzip.cs:
Index: System.Collections.Specialized/NotifyCollectionChangedAction.cs
===================================================================
--- System.Collections.Specialized/NotifyCollectionChangedAction.cs	(revision 117799)
+++ System.Collections.Specialized/NotifyCollectionChangedAction.cs	(working copy)
@@ -21,18 +21,37 @@
 //
 // Authors:
 //	Chris Toshok (toshok@ximian.com)
+//	Brian O'Keefe (zer0keefie@gmail.com)
 //
 
-using System;
-
 namespace System.Collections.Specialized {
-
+	/// <summary>
+	/// Describes the action that caused a <see cref="INotifyCollectionChanged.CollectionChanged"/> event.
+	/// </summary>
 	public enum NotifyCollectionChangedAction {
+		/// <summary>
+		/// Indicates that items were added to the collection.
+		/// </summary>
 		Add,
+
+		/// <summary>
+		/// Indicates that items were removed from the collection.
+		/// </summary>
 		Remove,
+
+		/// <summary>
+		/// Indicates that one or more items in the collection was replaced with another item.
+		/// </summary>
 		Replace,
+
+		/// <summary>
+		/// Indicates that one or more items in the collection have been moved to a different location in the same collection.
+		/// </summary>
 		Move,
+
+		/// <summary>
+		/// Indicates the the collection was reset, or a drastic change was made to the items.
+		/// </summary>
 		Reset
 	}
-
 }
Index: System.Collections.Specialized/NotifyCollectionChangedEventArgs.cs
===================================================================
--- System.Collections.Specialized/NotifyCollectionChangedEventArgs.cs	(revision 117799)
+++ System.Collections.Specialized/NotifyCollectionChangedEventArgs.cs	(working copy)
@@ -21,90 +21,265 @@
 //
 // Authors:
 //	Chris Toshok (toshok@ximian.com)
+//	Brian O'Keefe (zer0keefie@gmail.com)
 //
 
-using System;
-using System.Collections;
-
 namespace System.Collections.Specialized {
-
+	/// <summary>
+	/// Provides data for the <see cref="INotifyCollectionChanged.CollectionChanged"/> event.
+	/// </summary>
 	public class NotifyCollectionChangedEventArgs : EventArgs {
+		private NotifyCollectionChangedAction action;
+		private IList oldItems, newItems;
+		private int oldIndex = -1, newIndex = -1;
 
-		NotifyCollectionChangedAction action;
+		#region Constructors
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a Reset change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This must be set to Reset.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action)
 		{
 			this.action = action;
+
+			if (action != NotifyCollectionChangedAction.Reset)
+				throw new ArgumentException ("This constructor can only be used with the Reset action.", "action");
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, IList changedItems)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a multi-item change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This can be set to Add, Remove, or Reset.</param>
+		/// <param name="changedItems">The items affected by the change.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems)
+			: this (action, changedItems, -1)
 		{
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, object changedItem)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a one-item change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This can be set to Add, Remove, or Reset.</param>
+		/// <param name="changedItem">The item affected by the change.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem)
+			: this (action, changedItem, -1)
 		{
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, IList newItems, IList oldItems)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a multi-item Replace change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This must be set to Replace.</param>
+		/// <param name="newItems">The new items that are replacing the original items.</param>
+		/// <param name="oldItems">The original items that are replaced.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems)
+			: this (action, newItems, oldItems, -1)
 		{
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a multi-item change or a Reset change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This can be set to Add, Remove, or Reset.</param>
+		/// <param name="changedItems">The items affected by the change.</param>
+		/// <param name="startingIndex">The index where the change occured.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
 		{
+			this.action = action;
+
+			if (action == NotifyCollectionChangedAction.Add || action == NotifyCollectionChangedAction.Remove) {
+				if (changedItems == null)
+					throw new ArgumentNullException ("changedItems");
+
+				if (startingIndex < -1)
+					throw new ArgumentException ("The value of startingIndex must be -1 or greater.", "startingIndex");
+
+				if (action == NotifyCollectionChangedAction.Add)
+					InitializeAdd (changedItems, startingIndex);
+				else
+					InitializeRemove (changedItems, startingIndex);
+			} else if (action == NotifyCollectionChangedAction.Reset) {
+				if (changedItems != null)
+					throw new ArgumentException ("This constructor can only be used with the Reset action if changedItems is null", "changedItems");
+
+				if (startingIndex != -1)
+					throw new ArgumentException ("This constructor can only be used with the Reset action if startingIndex is -1", "startingIndex");
+			} else {
+				throw new ArgumentException ("This constructor can only be used with the Reset, Add, or Remove actions.", "action");
+			}
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, object changedItem, int index)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a one-item change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This can be set to Add, Remove, or Reset.</param>
+		/// <param name="changedItem">The item affected by the change.</param>
+		/// <param name="index">The index where the change occured.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index)
 		{
+			IList changedItems = new object [] { changedItem };
+			this.action = action;
+
+			if (action == NotifyCollectionChangedAction.Add)
+				InitializeAdd (changedItems, index);
+			else if (action == NotifyCollectionChangedAction.Remove)
+				InitializeRemove (changedItems, index);
+			else if (action == NotifyCollectionChangedAction.Reset) {
+				if (changedItem != null)
+					throw new ArgumentException ("This constructor can only be used with the Reset action if changedItem is null", "changedItem");
+
+				if (index != -1)
+					throw new ArgumentException ("This constructor can only be used with the Reset action if index is -1", "index");
+			} else {
+				throw new ArgumentException ("This constructor can only be used with the Reset, Add, or Remove actions.", "action");
+			}
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, object newItem, object oldItem)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a one-item Replace change.
+		/// </summary>
+		/// <param name="action">The action.</param>
+		/// <param name="newItem">The new item that is replacing the original item.</param>
+		/// <param name="oldItem">The original item that is replaced.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem)
+			: this (action, newItem, oldItem, -1)
 		{
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a multi-item Replace change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This must be set to Replace.</param>
+		/// <param name="newItems">The new items that are replacing the original items.</param>
+		/// <param name="oldItems">The original items that are replaced.</param>
+		/// <param name="index">The index where the change occured.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int index)
 		{
+			this.action = action;
+
+			if (action != NotifyCollectionChangedAction.Replace)
+				throw new ArgumentException ("This constructor can only be used with the Replace action.", "action");
+
+			if (newItems == null)
+				throw new ArgumentNullException ("newItems");
+
+			if (oldItems == null)
+				throw new ArgumentNullException ("oldItems");
+
+			this.oldItems = oldItems;
+			this.newItems = newItems;
+
+			oldIndex = index;
+			newIndex = index;
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, IList changedItem, int index, int oldIndex)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a multi-item Move change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This must be set to Move.</param>
+		/// <param name="changedItems">The items affected by the change.</param>
+		/// <param name="index">The new index for the changed items.</param>
+		/// <param name="oldIndex">The old index for the changed items.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex)
 		{
+			this.action = action;
+
+			if (action != NotifyCollectionChangedAction.Move)
+				throw new ArgumentException ("This constructor can only be used with the Move action.", "action");
+
+			if (index < -1)
+				throw new ArgumentException ("The value of index must be -1 or greater.", "index");
+
+			InitializeMove (changedItems, index, oldIndex);
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a multi-item Move change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This must be set to Move.</param>
+		/// <param name="changedItem">The items affected by the change.</param>
+		/// <param name="index">The new index for the changed item.</param>
+		/// <param name="oldIndex">The old index for the changed item.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex)
+			: this (action, new object [] { changedItem }, index, oldIndex)
 		{
 		}
 
-		public NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction action, object newItem, object oldItem, int index)
-			: this (action)
+		/// <summary>
+		/// Initializes a new instance of the <see cref="NotifyCollectionChangedEventArgs"/> class that describes a one-item Replace change.
+		/// </summary>
+		/// <param name="action">The action that caused the event. This must be set to Replace.</param>
+		/// <param name="newItem">The new item that is replacing the original item.</param>
+		/// <param name="oldItem">The original item that is replaced.</param>
+		/// <param name="index">The index where the change occured.</param>
+		public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index)
 		{
+			this.action = action;
+
+			if (action != NotifyCollectionChangedAction.Replace)
+				throw new ArgumentException ("This constructor can only be used with the Replace action.", "action");
+
+			InitializeReplace (new object [] { newItem }, new object [] { oldItem }, index);
 		}
 
-		public NotifyCollectionChangedAction Action {
+		#endregion
+
+		#region Accessor Properties
+
+		public NotifyCollectionChangedAction Action
+		{
 			get { return action; }
 		}
 
-		public IList NewItems {
-			get { throw new NotImplementedException (); }
+		public IList NewItems
+		{
+			get { return newItems; }
 		}
 
-		public int NewStartingIndex {
-			get { throw new NotImplementedException (); }
+		public int NewStartingIndex
+		{
+			get { return newIndex; }
 		}
 
-		public IList OldItems {
-			get { throw new NotImplementedException (); }
+		public IList OldItems
+		{
+			get { return oldItems; }
 		}
 
-		public int OldStartingIndex {
-			get { throw new NotImplementedException (); }
+		public int OldStartingIndex
+		{
+			get { return oldIndex; }
 		}
-	}	
+
+		#endregion
+
+		#region Initialize Methods
+
+		private void InitializeAdd(IList items, int index)
+		{
+			this.newItems = ArrayList.ReadOnly (items);
+			this.newIndex = index;
+		}
+
+		private void InitializeRemove(IList items, int index)
+		{
+			this.oldItems = ArrayList.ReadOnly (items);
+			this.oldIndex = index;
+		}
+
+		private void InitializeMove(IList changedItems, int newItemIndex, int oldItemIndex)
+		{
+			InitializeAdd (changedItems, newItemIndex);
+			InitializeRemove (changedItems, oldItemIndex);
+		}
+
+		private void InitializeReplace(IList addedItems, IList removedItems, int index)
+		{
+			InitializeAdd (addedItems, index);
+			InitializeRemove (removedItems, index);
+		}
+
+		#endregion
+	}
 }
Index: System.Collections.Specialized/NotifyCollectionChangedEventHandler.cs
===================================================================
--- System.Collections.Specialized/NotifyCollectionChangedEventHandler.cs	(revision 117799)
+++ System.Collections.Specialized/NotifyCollectionChangedEventHandler.cs	(working copy)
@@ -21,12 +21,14 @@
 //
 // Authors:
 //	Chris Toshok (toshok@ximian.com)
+//	Brian O'Keefe (zer0keefie@gmail.com)
 //
 
-using System;
-
 namespace System.Collections.Specialized {
-
-	public delegate void NotifyCollectionChangedEventHandler (object sender, NotifyCollectionChangedEventArgs e);
-
+	/// <summary>
+	/// Represents the method that handles the <see cref="INotifyCollectionChanged.CollectionChanged"/> event.
+	/// </summary>
+	/// <param name="sender">The object that raised the event.</param>
+	/// <param name="e">Information about the event.</param>
+	public delegate void NotifyCollectionChangedEventHandler(object sender, NotifyCollectionChangedEventArgs e);
 }
Index: System.Collections.Specialized/CollectionChangedEventManager.cs
===================================================================
--- System.Collections.Specialized/CollectionChangedEventManager.cs	(revision 117799)
+++ System.Collections.Specialized/CollectionChangedEventManager.cs	(working copy)
@@ -21,13 +21,13 @@
 //
 // Authors:
 //	Chris Toshok (toshok@ximian.com)
-//
+//
+
+using System.Windows;
+
+namespace System.Collections.Specialized
+{
 
-using System;
-using System.Windows;
-
-namespace System.Collections.Specialized {
-
 	public class CollectionChangedEventManager : WeakEventManager
 	{
 		internal CollectionChangedEventManager ()
Index: System.Collections.Specialized/INotifyCollectionChanged.cs
===================================================================
--- System.Collections.Specialized/INotifyCollectionChanged.cs	(revision 117799)
+++ System.Collections.Specialized/INotifyCollectionChanged.cs	(working copy)
@@ -1,36 +1,37 @@
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-// 
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-// 
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-// Copyright (c) 2007 Novell, Inc. (http://www.novell.com)
-//
-// Authors:
-//	Chris Toshok (toshok@ximian.com)
-//
-
-using System;
-using System.Windows;
-
-namespace System.Collections.Specialized {
-
-	public interface INotifyCollectionChanged {
-
-		event NotifyCollectionChangedEventHandler CollectionChanged;
-	}
-
-}
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+// Copyright (c) 2007 Novell, Inc. (http://www.novell.com)
+//
+// Authors:
+//	Chris Toshok (toshok@ximian.com)
+//	Brian O'Keefe (zer0keefie@gmail.com)
+//
+
+namespace System.Collections.Specialized {
+	/// <summary>
+	/// Notifies listeners of dynamic changes, such as when items get added and removed or the whole list is refreshed.
+	/// </summary>
+	public interface INotifyCollectionChanged {
+		/// <summary>
+		/// Occurs when the collection changes.
+		/// </summary>
+		event NotifyCollectionChangedEventHandler CollectionChanged;
+	}
+}