//
// System.String.cs
//
// Authors:
//   Patrik Torstensson
//   Jeffrey Stedfast (fejj@ximian.com)
//   Dan Lewis (dihlewis@yahoo.co.uk)
//
// (C) 2001 Ximian, Inc.  http://www.ximian.com
//

using System;
using System.Text;
using System.Collections;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace System
{
	[Serializable]
	public sealed class String : IConvertible, IComparable, ICloneable, IEnumerable
	{
		[NonSerialized] private int length;
		[NonSerialized] private char start_char;

		private const int COMPARE_CASE = 0;
		private const int COMPARE_INCASE = 1;
		private const int COMPARE_ORDINAL = 2;

		public static readonly String Empty = "";

		public static unsafe bool Equals (string a, string b)
		{
			if ((a as object) == (b as object))
				return true;

			if (a == null || b == null)
				return false;

			int len = a.length;

			if (len != b.length)
				return false;

			if (len == 0)
				return true;

			fixed (char * s1 = &a.start_char, s2 = &b.start_char) {
				// it must be one char, because 0 len is done above
				if (len < 2)
					return *s1 == *s2;

				// check by twos
				int * sint1 = (int *) s1, sint2 = (int *) s2;
				int n2 = len >> 1;
				do {
					if (*sint1++ != *sint2++)
						return false;
				} while (--n2 != 0);

				// nothing left
				if ((len & 1) == 0)
					return true;

				// check the last one
				return *(char *) sint1 == *(char *) sint2;
			}
		}

		public static unsafe bool Equals2 (string a, string b)
		{
			if ((a as object) == (b as object))
				return true;

			if (a == null || b == null)
				return false;

			int len = a.length;

			if (len != b.length)
				return false;

//			if (len == 0)
//				return true;

			fixed (char * s1 = &a.start_char, s2 = &b.start_char) {
				switch (len) {
				case 0:
					return true;
				case 1:
					return *s1 == *s2;
				case 2:
					return *((int*)s1) == *((int*)s2);
				case 3:
					if (*((int*)s1) == *((int*)s2))
						return (s1[3] == s2[3]);
					else
						return false;
				case 4:
					return *((long*)s1) == *((long*)s2);
				case 5:
					if (*((long*)s1) == *((long*)s2))
						return (s1[5] == s2[5]);
					else
						return false;
				case 6:
					if (*((long*)s1) == *((long*)s2))
						return (*((int*)&s1[5]) == *((int*)&s2[5]));
					else
						return false;
				case 7:
					if (*((long*)s1) == *((long*)s2))
						return (*((int*)&s1[5]) == *((int*)&s2[5])) && (s1[7] == s2[7]);
					else
						return false;
				default:
					//Check runs from end to start to save variables
//					do {
//						len -= 4;
//						if (*((long*)&s1[len]) != *((long*)&s2[len]))
//							return false;
//					} while (len >= 8);
//
//					if (len >= 2) {
//						len -= 2;
//						if (*((int*)&s1[len]) != *((int*)&s2[len]))
//							return false;
//					}
					do {
						len -= 4;
						if (*((int*)&s1[len]) != *((int*)&s2[len]))
							return false;
						else if (*((int*)&s1[len + 2]) != *((int*)&s2[len + 2]))
							return false;
						
					} while (len >= 8);

					if (len >= 2) {
						len -= 2;
						if (*((int*)&s1[len]) != *((int*)&s2[len]))
							return false;
					}
//					do {
//						len -= 2;
//						if (*((int*)&s1[len]) != *((int*)&s2[len]))
//							return false;
//					} while (len >= 4);

					if (len == 1)
						return *s1 != *s2;

					return true;
				}
			}
		}
		
		public static unsafe bool Equals4 (string a, string b)
		{
			if ((a as object) == (b as object))
				return true;

			if (a == null || b == null)
				return false;

			int count = a.length;

			if (count != b.length)
				return false;

//			if (count == 0)
//				return true;

			fixed (char * sa= &a.start_char, sb = &b.start_char) {
				char* stringA = sa, stringB = sb;
				while (count >= 16) {
					if (
					((int*) stringA)[0] != ((int*) stringB)[0] ||
					((int*) stringA)[1] != ((int*) stringB)[1] ||
					((int*) stringA)[2] != ((int*) stringB)[2] ||
					((int*) stringA)[3] != ((int*) stringB)[3] ||
					((int*) stringA)[4] != ((int*) stringB)[4] ||
					((int*) stringA)[5] != ((int*) stringB)[5] ||
					((int*) stringA)[6] != ((int*) stringB)[6] ||
					((int*) stringA)[7] != ((int*) stringB)[7] )
						return false;
					stringA += 16;
					stringB += 16;
					count -= 16;
				}
	
				while (count >= 4) {
					if (
					((int*) stringA)[0] != ((int*) stringB)[0] ||
					((int*) stringA)[1] != ((int*) stringB)[1] )
						return false;
					stringA += 4;
					stringB += 4;
					count -= 4;
				}
	
				if (count >= 2) {
					if (((int*) stringA)[0] != ((int*) stringB)[0])
						return false;
					stringA += 2;
					stringB += 2;
					count -= 2;
				}
	
				if (count == 1) {
					if (*stringA != *stringB)
						return false;
				}
			}
			return true;
		}

		public static unsafe bool Equals3 (string a, string b)
		{
			if ((a as object) == (b as object))
				return true;

			if (a == null || b == null)
				return false;

			int count = a.length;

			if (count != b.length)
				return false;

//			if (count == 0)
//				return true;

			fixed (char* stringA= &a.start_char, stringB = &b.start_char) {
				if ((count & 1) == 1)
					if (*stringA != *stringB)
						return false;

				count = count >> 1;

				while (count >= 16) {
					if (
						((int*) stringA)[count - 16] != ((int*) stringB)[count - 16] ||
						((int*) stringA)[count - 14] != ((int*) stringB)[count - 14] ||
						((int*) stringA)[count - 12] != ((int*) stringB)[count - 12] ||
						((int*) stringA)[count - 10] != ((int*) stringB)[count - 10] ||
						((int*) stringA)[count - 8] != ((int*) stringB)[count - 8] ||
						((int*) stringA)[count - 6] != ((int*) stringB)[count - 6] ||
						((int*) stringA)[count - 4] != ((int*) stringB)[count - 4] ||
						((int*) stringA)[count - 2] != ((int*) stringB)[count - 2]
					)
						return false;
					count -= 16;
				}

				while (count >= 4) {
					if (
						((int*) stringA)[count - 4] != ((int*) stringB)[count - 4] ||
						((int*) stringA)[count - 2] != ((int*) stringB)[count - 2]
					)
						return false;
					count -= 4;
				}

				if (count >= 2) {
					if (((int*) stringA)[count - 2] != ((int*) stringB)[count - 2])
						return false;
					
					count -= 2;
				}

//				if (count == 1) {
//					if (*stringA != *stringB)
//						return false;
//				}
			}
			return true;
		}

		private unsafe static bool MemCompare (char* src, char* dest, int count)
		{
//			switch (count) {
//					case 1:
//						return *src == *dest;
//					case 2:
//						return *((int*)src) == *((int*)dest);
//					case 3:
//						return *((int*)src) == *((int*)dest);
//					case 4:
//						return *((long*)src) == *((long*)dest);
//			}
			// Compare up to 8 byte at a time.
			// On future processors maybe switch to 16
			while (count >= 4) {
				if (*((long*)dest) != *((long*)src))
					return false;
				dest += 4;
				src += 4;

				count -= 4;
			}

			if (count >= 2) {
				if (*((int*)dest) != *((int*)src))
					return false;
				dest += 2;
				src += 2;

				count -= 2;
			}

			if (count == 1) {
				if (*dest != *src)
					return false;
			}
			return true;
		}

		public static bool operator == (String a, String b)
		{
			return Equals (a, b);
		}

		public static bool operator != (String a, String b)
		{
			return !Equals (a, b);
		}

		public override bool Equals (Object obj)
		{
			return Equals (this, obj as String);
		}

		public bool Equals (String value)
		{
			return Equals (this, value);
		}

		[IndexerName ("Chars")]
		public extern char this [int index] {
		//public unsafe char this [int index] {
			[MethodImplAttribute (MethodImplOptions.InternalCall)]
			get;
			//get {
			//	fixed (char * s = &start_char) {
			//		return s[index];
			//	}
			//	//return 'c';
			//}
		}

		public Object Clone ()
		{
			return this;
		}

		public TypeCode GetTypeCode ()
		{
			return TypeCode.String;
		}

		private unsafe static void MemCopy (byte* src, byte* dest, int len)
		{
			// Copy up to 8 byte at a time.
			// On future processors maybe switch to 16
			while (len >= 8) {
				//*((long*)dest) = *((long*)src);
				*((int*)dest) = *((int*)src);
				dest += 4;
				src += 4;
				*((int*)dest) = *((int*)src);
				dest += 4;
				src += 4;
				//dest += 8;
				//src += 8;

				len -= 8;
			}

			if ((len & 4) != 0)
			{
				*((int*)dest) = *((int*)src);
				dest += 4;
				src += 4;
			}

			if ((len & 2) != 0)
			{
				*((short*)dest) = *((short*)src);
				dest += 2;
				src += 2;
			}

			if ((len & 1) != 0)
			{
				*dest = *src;
				dest += 1;
				src += 1;
			}
		}

//		private unsafe static void MemCopy (char* src, char* dest, int len)
//		{
//			// TODO change this value as the mono implementation gets faster
//			if (len > 2500) { //32
//				//InternalCopyTo (sourceIndex, destination, destinationIndex, count);
//				return;
//			}
//			// Copy up to 8 byte at a time.
//			// On future processors maybe switch to 16
//			if (len >= 32) {
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//
//				len -= 32;
//			}
//			if (len >= 16) {
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//
//				len -= 16;
//			}
//			if (len >= 8) {
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//
//				len -= 8;
//			}
//
//			if (len >= 4) {
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//
//				len -= 4;
//			}
//
//			if (len >= 2) {
//				*((int*)dest) = *((int*)src);
//				dest += 2;
//				src += 2;
//
//				len -= 2;
//			}
//
//			if (len == 1) {
//				*dest = *src;
//				dest += 1;
//				src += 1;
//			}
//		}

//		private unsafe static void MemCopy (char* src, char* dest, int len)
//		{
//			// TODO change this value as the mono implementation gets faster
//			if (len > 2500) { //32
//				//InternalCopyTo (sourceIndex, destination, destinationIndex, count);
//				return;
//			}
//			// Copy up to 8 byte at a time.
//			// On future processors maybe switch to 16
//			while (len >= 4) {
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//
//				len -= 4;
//			}
//
//			if (len % 2 == 0) {
//				*((int*)dest) = *((int*)src);
//				dest += 2;
//				src += 2;
//			}
//
//			if (len % 1 == 0) {
//				*dest = *src;
//				dest += 1;
//				src += 1;
//			}
//		}

//		private unsafe static void MemCopy (char* src, char* dest, int len)
//		{
//			// TODO change this value as the mono implementation gets faster
//			if (len > 2500) { //32
//				//InternalCopyTo (sourceIndex, destination, destinationIndex, count);
//				return;
//			}
//			// Copy up to 8 byte at a time.
//			// On future processors maybe switch to 16
//			while (len >= 4) {
//				*((long*)dest) = *((long*)src);
//				dest += 4;
//				src += 4;
//
//				len -= 4;
//			}
//
//			if (len >= 2) {
//				*((int*)dest) = *((int*)src);
//				dest += 2;
//				src += 2;
//
//				len -= 2;
//			}
//
//			if (len == 1) {
//				*dest = *src;
//				//dest += 1;
//				//src += 1;
//			}
//		}

//		private unsafe static void MemCopy (char* src, char* dest, int len)
//		{
//			switch (len) {
//			case 0:
//			case 1:
//			case 2:
//				*((int*)dest) = *((int*)src);
//					break;
//			case 3:
//			case 4:
//			case 5:
//			case 6:
//			case 7:
//			default:
//				return;
//			}
//		}

//		private unsafe static void CharCopyf (char* source, char* destination, int count)
//		{
//			// For 64-bit two int casts may be combined to produce to a long cast to gain even more speed
//			// However we should ensure then, that these get converted into two int-casts on 32-bit architecture
//			// by the JIT
//
//			// TODO change this value as the managed implementation gets faster, maybe drop icall entirely
//			if (count > 1024) {
//				InternalCharCopy (source, destination, count);
//				return;
//			}
//
//			// Copy 32 byte at a time (unroll the loop)
//			while (count >= 16) {
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//
//				count -= 16;
//			}
//
//			// Copy 8 byte at a time.
//			while (count >= 4) {
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//
//				count -= 4;
//			}
//
//			if (count >= 2) {
//				*((int*) destination) = *((int*) source);
//				destination += 2;
//				source += 2;
//
//				count -= 2;
//			}
//
//			if (count == 1) {
//				*destination = *source;
//				//dest += 1;
//				//src += 1;
//			}
//		}

		private unsafe static void CharCopy (char* source, char* destination, int count)
		{
			// Copy 32 byte at a time (unroll the loop)
			while (count >= 16) {
				((int*) destination)[0] = ((int*) source)[0];
				((int*) destination)[1] = ((int*) source)[1];
				((int*) destination)[2] = ((int*) source)[2];
				((int*) destination)[3] = ((int*) source)[3];
				((int*) destination)[4] = ((int*) source)[4];
				((int*) destination)[5] = ((int*) source)[5];
				((int*) destination)[6] = ((int*) source)[6];
				((int*) destination)[7] = ((int*) source)[7];
				destination += 16;
				source += 16;
				count -= 16;
			}

			// Copy 8 byte at a time.
			while (count >= 4) {
				((int*) destination)[0] = ((int*) source)[0];
				((int*) destination)[1] = ((int*) source)[1];
				destination += 4;
				source += 4;
				count -= 4;
			}

			if (count >= 2) {
				((int*) destination)[0] = ((int*) source)[0];
				destination += 2;
				source += 2;
				count -= 2;
			}

			if (count == 1) {
				*destination = *source;
				//dest += 1;
				//src += 1;
			}
		}

		public unsafe void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count)
		{
			// LAMESPEC: should I null-terminate?
			if (destination == null)
				throw new ArgumentNullException ("destination");

			if (sourceIndex < 0 || destinationIndex < 0 || count < 0)
				throw new ArgumentOutOfRangeException (); 

			// re-ordered to avoid possible integer overflow
			if (sourceIndex > Length - count)
				throw new ArgumentOutOfRangeException ("sourceIndex + count > Length");
			// re-ordered to avoid possible integer overflow
			if (destinationIndex > destination.Length - count)
				throw new ArgumentOutOfRangeException ("destinationIndex + count > destination.Length");

			fixed (char* source = &start_char, dest = destination) {
				CharCopy (source + sourceIndex, dest + destinationIndex, count);
			}
		}

		public char[] ToCharArray ()
		{
			return ToCharArrayInternal (0, length);
		}

		public char[] ToCharArray (int startIndex, int length)
		{
			if (startIndex < 0)
				throw new ArgumentOutOfRangeException ("startIndex", "< 0");
			if (length < 0)
				throw new ArgumentOutOfRangeException ("length", "< 0");
			// re-ordered to avoid possible integer overflow
			if (startIndex > this.length - length)
				throw new ArgumentOutOfRangeException ("startIndex + length > this.length");

			return ToCharArrayInternal (startIndex, length);
		}

		public unsafe char[] ToCharArrayInternal (int startIndex, int length)
		{
			char [] tmp = new char [length];

			fixed (char* source = &start_char, dest = tmp) {
				CharCopy (source, dest, length);
			}
			return tmp;
		}

		public unsafe String [] Split (params char [] separator)
		{
			if (length == 0)
				return new String[0];

			int start = 0;
			int found = 0;
			fixed (char* source = &start_char) {
				char* sourcePtr = source;
				if (separator == null || separator.Length == 0) {
					for (; start < length; start++) {
						if (Char.IsWhiteSpace (*sourcePtr)) {
							found++;
						}
						sourcePtr++;
					}
					return SplitUp (found);
				}
				else {
					fixed (char* test = separator) {
						for (; start < length; start++) {
							for (int x = 0; x < separator.Length; x++) {
								if (*sourcePtr == test[x]) {
									found++;
									break;
								}
							}
							sourcePtr++;
						}
					}
					return SplitUp (separator, found);
				}
			}
		}

		public unsafe String[] Split (char[] separator, int count)
		{
			if (count < 0)
				throw new ArgumentOutOfRangeException ("count");

			if (count == 0)
				return new String[0];

			if (count == 1)
				return new String[1] { this };

			if (length == 0)
				return new String[0];

			int start = 0;
			int found = 0;
			fixed (char* source = &start_char) {
				char* sourcePtr = source;
				if (separator == null || separator.Length == 0) {
					for (; start < length; start++) {
						if (Char.IsWhiteSpace (*sourcePtr)) {
							found++;
							if (found == count)
								return SplitUp (separator, found);
						}
						sourcePtr++;
					}
					return SplitUp (found);
				}
				else {
					fixed (char* test = separator) {
						for (; start < length; start++) {
							for (int x = 0; x < separator.Length; x++) {
								if (*sourcePtr == test[x]) {
									found++;
									if (found == count)
										return SplitUp (separator, found);
									break;
								}
							}
							sourcePtr++;
						}
					}
					return SplitUp (separator, found);
				}
			}
		}

		// Performs the Splitup of a String with a known number of parts that splits at default whitespaces
		private unsafe String[] SplitUp (int found)
		{
			if (found == 0 || found == 1)
				return new String[1] { this };
			
			fixed (char* source = &start_char) {
				char* sourcePtr = source;

				String[] ret = new String[found];

				int counter = 0;
				sourcePtr = source;
				char* startPtr = source;
				for (; counter < found; counter++) {
					if (Char.IsWhiteSpace (*sourcePtr)) {
						int newLen = (int)(sourcePtr - startPtr) - 1;
						if (newLen > 0) {
							String tmp = InternalAllocateStr (newLen);
							fixed (char* dest = tmp) {
								CharCopy (startPtr, dest, newLen);
							}
							startPtr = sourcePtr;
							//ret[counter] = tmp;
						}
						else {
							//ret[counter] = String.Empty;
						}
					}
					sourcePtr++;
				}
				return ret;
			}
		}

		// Performs the Splitup of a String with a known number of parts that splits using a char separator array
		private unsafe String[] SplitUp (char[] separator, int found)
		{
			if (found == 0 || found == 1)
				return new String[1] { this };
			
			fixed (char* source = &start_char) {
				char* sourcePtr = source;

				String[] ret = new String[found];

				int counter = 0;
				sourcePtr = source;
				char* startPtr = source;
				fixed (char* test = separator) {
					for (; counter < found; counter++) {
						for (int x = 0; x < separator.Length; x++) {
							if (*sourcePtr == test[x]) {
								int newLen = (int)(sourcePtr - startPtr) - 1;
								if (newLen > 0) {
									String tmp = InternalAllocateStr (newLen);
									fixed (char* dest = tmp) {
										CharCopy (startPtr, dest, newLen);
									}
									startPtr = sourcePtr;
									ret[counter] = tmp;
									break;
								}
								else {
									ret[counter] = String.Empty;
									break;
								}
							}
						}
						sourcePtr++;
					}
				}
				return ret;
			}
		}

		public unsafe String Substring (int startIndex)
		{
			if (startIndex < 0 || startIndex > this.length)
				throw new ArgumentOutOfRangeException ("startIndex");

			int newLen = this.length - startIndex;
			if (newLen == 0)
				return String.Empty;

			string tmp = InternalAllocateStr (newLen);
			fixed (char * s1 = &start_char, s2 = tmp) {
				CharCopy (s1 + startIndex, s2, newLen);
			}
			return tmp;
		}

		public unsafe String Substring (int startIndex, int length)
		{
			if (length < 0 || startIndex < 0 || startIndex + length > this.length)
				throw new ArgumentOutOfRangeException ();

			if (length == 0)
				return String.Empty;

			string tmp = InternalAllocateStr (length);
			//InternalStrcpy (tmp, 0, this, startIndex, length);
			fixed (char * s1 = &start_char, s2 = tmp) {
				CharCopy (s1 + startIndex, s2, length);
			}
			return tmp;
		}

//		public unsafe String Substring2 (int startIndex)
//		{
//			if (startIndex < 0 || startIndex > this.length)
//				throw new ArgumentOutOfRangeException ("startIndex");
//
//			//char[] c = new char[length];
//			string tmp = InternalAllocateStr (this.length - startIndex);
//			fixed (char * source = &start_char, dest = tmp) {
//				MemCopy (source, dest, length - startIndex);
//			//return new String (s1);
//			}
//			//return null;
//			//string tmp = InternalAllocateStr (length);
//			//InternalStrcpy (tmp, 0, this, startIndex, length - startIndex);
//
//			return tmp;
//		}	

//		private static readonly char[] WhiteChars = { (char) 0x9, (char) 0xA, (char) 0xB, (char) 0xC, (char) 0xD,
//			(char) 0x20, (char) 0xA0, (char) 0x2000, (char) 0x2001, (char) 0x2002, (char) 0x2003, (char) 0x2004,
//			(char) 0x2005, (char) 0x2006, (char) 0x2007, (char) 0x2008, (char) 0x2009, (char) 0x200A, (char) 0x200B,
//			(char) 0x3000, (char) 0xFEFF };

		public unsafe String Trim (params char[] trimChars)
		{
//			int start = 0;
//			int end = length;
//			fixed (char* source = &start_char) {
//				char* sourcePtr = source;
//				if (trimChars == null || trimChars.Length == 0) {
//					for (; start < length; start++) {
//						if (!Char.IsWhiteSpace (*sourcePtr)) {
//							break;
//						}
//						sourcePtr++;
//					}
//					sourcePtr = source + end;
//					for (; end > start; end--) {
//						if (!Char.IsWhiteSpace (*sourcePtr)) {
//							break;
//						}
//						sourcePtr--;
//					}
//				}
//				else {
//					fixed (char* test = trimChars) {
//						for (; start < length; start++) {
//							bool found = false;
//							for (int x = 0; x < trimChars.Length; x++) {
//								if (*sourcePtr == test[x]) {
//									found = true;
//									break;
//								}
//							}
//							if (found == false)
//								break;
//							sourcePtr++;
//						}
//						sourcePtr = source + end;
//						for (; end > start; end--) {
//							bool found = false;
//							for (int x = 0; x < trimChars.Length; x++) {
//								if (*sourcePtr == test[x]) {
//									found = true;
//									break;
//								}
//							}
//							if (found == false)
//								break;
//							sourcePtr--;
//						}
//					}
//				}
//				int newLen = end - start;
//				if (length == newLen)
//					return this;
//
//				string tmp = InternalAllocateStr (newLen);
//				fixed (char* destination = tmp) {
//					CharCopy (source + start, destination, newLen);
//				}
//				return tmp;
//			}
			int start = 0;
			int end = length;
			fixed (char* source = &start_char) {
				char* sourcePtr = source;
				if (trimChars == null || trimChars.Length == 0) {
					for (; start < length; start++) {
						if (!Char.IsWhiteSpace (*sourcePtr)) {
							break;
						}
						sourcePtr++;
					}
					sourcePtr = source + end;
					for (; end > start; end--) {
						if (!Char.IsWhiteSpace (*sourcePtr)) {
							break;
						}
						sourcePtr--;
					}
				}
				else {
					fixed (char* test = trimChars) {
						for (; start < length; start++) {
							for (int x = 0; x < trimChars.Length; x++) {
								if (*sourcePtr == test[x]) {
									goto FoundStart;
								}
							}
							sourcePtr++;
						}
						FoundStart:
						sourcePtr = source + end;
						for (; end > start; end--) {
							for (int x = 0; x < trimChars.Length; x++) {
								if (*sourcePtr == test[x]) {
									goto FoundEnd;
								}
							}
							sourcePtr--;
						}
					}
				}
				FoundEnd:
				int newLen = end - start;
				if (length == newLen)
					return this;

				string tmp = InternalAllocateStr (newLen);
				fixed (char* destination = tmp) {
					CharCopy (source + start, destination, newLen);
				}
				return tmp;
			}
		}

//		private unsafe static bool ContainsChar (char* testChar, char* searchChars, int length)
//		{
//			for (int x = 0; x < length; x++) {
//				if (*testChar == *searchChars) {
//					return true;
//				}
//				searchChars++;
//			}
//			return false;
//		}

		public unsafe String TrimStart (params char[] trimChars)
		{
			int start = 0;
			fixed (char* source = &start_char) {
				char* sourcePtr = source;
				if (trimChars == null || trimChars.Length == 0) {
					for (; start < length; start++) {
						if (!Char.IsWhiteSpace (*sourcePtr)) {
							break;
						}
						sourcePtr++;
					}
				}
				else {
					fixed (char* test = trimChars) {
						for (; start < length; start++) {
							for (int x = 0; x < trimChars.Length; x++) {
								if (*sourcePtr == test[x]) {
									goto FoundStart;
								}
							}
							sourcePtr++;
						}
					}
				}
				FoundStart:
				if (start == 0)
					return this;

				int newLen = length - start;
				string tmp = InternalAllocateStr (newLen);
				fixed (char* destination = tmp) {
					CharCopy (sourcePtr, destination, newLen);
				}
				return tmp;
			}
		}

		public unsafe String TrimEnd (params char[] trimChars)
		{
			int end = length;
			fixed (char* source = &start_char) {
				char* sourcePtr = source + end;
				if (trimChars == null || trimChars.Length == 0) {
					for (; end > 0; end--) {
						if (!Char.IsWhiteSpace (*sourcePtr)) {
							break;
						}
						sourcePtr--;
					}
				}
				else {
					fixed (char* test = trimChars) {
						for (; end > 0; end--) {
							for (int x = 0; x < trimChars.Length; x++) {
								if (*sourcePtr == test[x]) {
									goto FoundEnd;
								}
							}
							sourcePtr--;
						}
					}
				}
				FoundEnd:
				int newLen = end;
				if (length == newLen)
					return this;

				string tmp = InternalAllocateStr (newLen);
				fixed (char* destination = tmp) {
					CharCopy (source, destination, newLen);
				}
				return tmp;
			}
		}

		public static int Compare (String strA, String strB)
		{
			return Compare (strA, strB, false, CultureInfo.CurrentCulture);
		}

		public static int Compare (String strA, String strB, bool ignoreCase)
		{
			return Compare (strA, strB, ignoreCase, CultureInfo.CurrentCulture);
		}

		public static int Compare (String strA, String strB, bool ignoreCase, CultureInfo culture)
		{
			if (culture == null)
				throw new ArgumentNullException ("culture");

			if (strA == null) {
				if (strB == null)
					return 0;
				else
					return -1;

			}
			else if (strB == null) {
				return 1;
			}

			CompareOptions compopts;

			if (ignoreCase)
				compopts = CompareOptions.IgnoreCase;
			else
				compopts = CompareOptions.None;

			return culture.CompareInfo.Compare (strA, strB, compopts);
		}

		public static int Compare (String strA, int indexA, String strB, int indexB, int length)
		{
			return Compare (strA, indexA, strB, indexB, length, false, CultureInfo.CurrentCulture);
		}

		public static int Compare (String strA, int indexA, String strB, int indexB, int length, bool ignoreCase)
		{
			return Compare (strA, indexA, strB, indexB, length, ignoreCase, CultureInfo.CurrentCulture);
		}
		
		public static int Compare (String strA, int indexA, String strB, int indexB, int length, bool ignoreCase, CultureInfo culture)
		{
			if (culture == null)
				throw new ArgumentNullException ("culture");

			if ((indexA > strA.Length) || (indexB > strB.Length) || (indexA < 0) || (indexB < 0) || (length < 0))
				throw new ArgumentOutOfRangeException ();

			if (length == 0)
				return 0;
			
			if (strA == null) {
				if (strB == null) {
					return 0;
				} else {
					return -1;
				}
			}
			else if (strB == null) {
				return 1;
			}

			CompareOptions compopts;

			if (ignoreCase)
				compopts = CompareOptions.IgnoreCase;
			else
				compopts = CompareOptions.None;

			/* Need to cap the requested length to the
			 * length of the string, because
			 * CompareInfo.Compare will insist that length
			 * <= (string.Length - offset)
			 */
			int len1 = length;
			int len2 = length;
			
			if (length > (strA.Length - indexA)) {
				len1 = strA.Length - indexA;
			}

			if (length > (strB.Length - indexB)) {
				len2 = strB.Length - indexB;
			}

			return culture.CompareInfo.Compare (strA, indexA, len1, strB, indexB, len2, compopts);
		}

		public int CompareTo (Object value)
		{
			if (value == null)
				return 1;

			if (!(value is String))
				throw new ArgumentException ();

			return String.Compare (this, (String) value, false);
		}

		public int CompareTo (String strB)
		{
			if (strB == null)
				return 1;

			return Compare (this, strB, false);
		}

		public static int CompareOrdinal (String strA, String strB)
		{
			if (strA == null) {
				if (strB == null)
					return 0;
				else
					return -1;
			}
			else if (strB == null) {
				return 1;
			}

			/* Invariant, because that is cheaper to
			 * instantiate (and chances are it already has
			 * been.)
			 */
			return CultureInfo.InvariantCulture.CompareInfo.Compare (strA, strB, CompareOptions.Ordinal);
		}

		public static int CompareOrdinal (String strA, int indexA, String strB, int indexB, int length)
		{
			if ((indexA > strA.Length) || (indexB > strB.Length) || (indexA < 0) || (indexB < 0) || (length < 0))
				throw new ArgumentOutOfRangeException ();

			if (strA == null) {
				if (strB == null)
					return 0;
				else
					return -1;
			}
			else if (strB == null) {
				return 1;
			}

			/* Need to cap the requested length to the
			 * length of the string, because
			 * CompareInfo.Compare will insist that length
			 * <= (string.Length - offset)
			 */
			int len1 = length;
			int len2 = length;

			if (length > (strA.Length - indexA)) {
				len1 = strA.Length - indexA;
			}

			if (length > (strB.Length - indexB)) {
				len2 = strB.Length - indexB;
			}

			return CultureInfo.InvariantCulture.CompareInfo.Compare (strA, indexA, len1, strB, indexB, len2, CompareOptions.Ordinal);
		}

		public bool EndsWith (String value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			if (value == String.Empty)
				return true;

			if (value.length > this.length)
				return false;

			return (0 == Compare (this, length - value.length, value, 0, value.length));
		}

		public unsafe int IndexOfAny (char [] anyOf)
		{
			if (anyOf == null)
				throw new ArgumentNullException ("anyOf");

			//Für lange am schnellsten!
			fixed (char* test = &start_char, testChars = anyOf) {
				char* testPtr = test;
				char* testChar, targetChar = testChars + anyOf.Length;
				for (int pos = 0; pos < this.length; pos++) {
					testChar = testChars;
					for (; testChar < targetChar;) {
						if (*testPtr == *testChar)
							return pos;
						testChar++;
					}
					testPtr++;
				}
			}

			//Besser:
//			fixed (char* test = &start_char, testChars = anyOf) {
//				//char* testPtr = test;
//				char* testChar, targetChar = testChars + anyOf.Length;
//				for (int pos = 0; pos < this.length; pos++) {
//					testChar = testChars;
//					for (; testChar < targetChar;) {
//						if (test[pos] == *testChar)
//							return pos;
//						testChar++;
//					}
//					//testPtr++;
//				}
//			}

			//Noch besser:
//			fixed (char* test = &start_char, testChars = anyOf) {
//				//char* testPtr = test;
//				//char* testChar, targetChar = testChars + anyOf.Length;
//				for (int pos = 0; pos < this.length; pos++) {
//					//testChar = testChars;
//					for (int x = 0; x < anyOf.Length; x++) {
//						if (test[pos] == testChars[x])
//							return pos;
//						//testChar++;
//					}
//					//testPtr++;
//				}
//			}
			return -1;
		}

		public unsafe int IndexOfAny (char [] anyOf, int startIndex)
		{
			if (anyOf == null)
				throw new ArgumentNullException ("anyOf");
			if (startIndex < 0 || startIndex >= this.length)
				throw new ArgumentOutOfRangeException ("sourceIndex");

			fixed (char* test = &start_char, testChars = anyOf) {
				char* testPtr = test;
				char* testChar, targetChar = testChars + anyOf.Length;
				for (int pos = startIndex; pos < this.length; pos++) {
					testChar = testChars;
					for (; testChar < targetChar;) {
						if (*testPtr == *testChar)
							return pos;
						testChar++;
					}
					testPtr++;
				}
			}
			return -1;
		}

		public unsafe int IndexOfAny (char [] anyOf, int startIndex, int count)
		{
			if (anyOf == null)
				throw new ArgumentNullException ("anyOf");
			if (startIndex < 0 || count < 0 || startIndex + count > this.length)
				throw new ArgumentOutOfRangeException ();

			int target = startIndex + count;
			fixed (char* test = &start_char, testChars = anyOf) {
				char* testPtr = test;
				char* testChar, targetChar = testChars + anyOf.Length;
				for (int pos = startIndex; pos < target; pos++) {
					testChar = testChars;
					for (; testChar < targetChar;) {
						if (*testPtr == *testChar)
							return pos;
						testChar++;
					}
					testPtr++;
				}
			}
			return -1;
		}

		private unsafe int IndexOfAnyInternal (char [] anyOf, int startIndex, int targetIndex)
		{
			fixed (char* test = &start_char, testChars = anyOf) {
				char* testPtr = test;
				char* testChar, targetChar = testChars + anyOf.Length;
				for (int pos = startIndex; pos < targetIndex; pos++) {
					testChar = testChars;
					for (; testChar < targetChar;) {
						if (*testPtr == *testChar)
							return pos;
						testChar++;
					}
					testPtr++;
				}
			}
			return -1;
		}

		public unsafe int IndexOf (char value)
		{
			fixed (char* test = &start_char) {
				char* testPtr = test;
				for (int pos = 0; pos < this.length; pos++) {
					if (*testPtr == value)
						return pos;
					testPtr++;
				}
			}
//			fixed (char* test = &start_char) {
//				for (int pos = 0; pos < this.length; pos++) {
//					if (test[pos] == value)
//						return pos;
//				}
//			}
			return -1;
		}

		public int IndexOf (String value)
		{
			return IndexOf (value, 0, this.length);
		}

		public unsafe int IndexOf (char value, int startIndex)
		{
			if (startIndex < 0 || startIndex > this.length)
				throw new ArgumentOutOfRangeException ();

			fixed (char* test = &start_char) {
				char* testPtr = test + startIndex;
				for (int pos = startIndex; pos < this.length; pos++) {
					if (*testPtr == value)
						return pos;
					testPtr++;
				}
			}
			return -1;
//			if (startIndex < 0 || startIndex > this.length)
//				throw new ArgumentOutOfRangeException ();
//
//			if ((this.length == 0) || (startIndex == this.length))
//				return -1;
//
//			return IndexOfImpl (value, startIndex, this.length - startIndex);
		}

		public int IndexOf (String value, int startIndex)
		{
			return IndexOf (value, startIndex, this.length - startIndex);
		}

		/* This method is culture-insensitive */
		public unsafe int IndexOf (char value, int startIndex, int count)
		{
			if (startIndex < 0 || count < 0 || startIndex + count > this.length)
				throw new ArgumentOutOfRangeException ();

			fixed (char* test = &start_char) {
				char* testPtr = test + startIndex;
				for (int pos = startIndex; pos < startIndex + count; pos++) {
					if (*testPtr == value)
						return pos;
					testPtr++;
				}
			}
			return -1;

//			if ((this.length == 0) || (startIndex == this.length) || (count == 0))
//				return -1;
//
//			return IndexOfImpl (value, startIndex, count);
//			fixed (char * s = &start_char) {
//				char * ps = s + startIndex;
//				for (int pos = startIndex; pos < startIndex + count; pos++) {
//					if (*ps == value)
//						return pos;
//					ps++;
//				}
//			}
////			for (int pos = startIndex; pos < startIndex + count; pos++) {
////				if (this[pos] == value)
////					return(pos);
////			}
//			return -1;
		}

//		private unsafe int IndexOfImpl (char value, int startIndex, int count)
//		{
//			fixed (char * s = &start_char) {
//				char * ps = s + startIndex;
//				for (int pos = startIndex; pos < startIndex + count; pos++) {
//					if (*ps == value)
//						return pos;
//					ps++;
//				}
//			}
//			return -1;
//		}

		/* But this one is culture-sensitive */
		public int IndexOf (String value, int startIndex, int count)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			if (startIndex < 0 || count < 0 || startIndex + count > this.length)
				throw new ArgumentOutOfRangeException ();

			if (value.length == 0)
				return startIndex;

			if (startIndex == 0 && this.length == 0)
				return -1;

			if (count == 0)
				return -1;

			return CultureInfo.CurrentCulture.CompareInfo.IndexOf (this, value, startIndex, count);
		}

		public unsafe int LastIndexOfAny (char [] anyOf)
		{
			if (anyOf == null)
				throw new ArgumentNullException ("anyOf");

			fixed (char* test = &start_char, testChars = anyOf) {
				char* testPtr = test + this.length;
				char* testChar, targetChar = testChars + anyOf.Length;
				for (int pos = this.length; pos > 0; pos--) {
					testChar = testChars;
					for (; testChar < targetChar;) {
						if (*testPtr == *testChar)
							return pos;
						testChar++;
					}
					testPtr--;
				}
			}
			return -1;
		}

		public unsafe int LastIndexOfAny (char [] anyOf, int startIndex)
		{
			if (anyOf == null) 
				throw new ArgumentNullException ("anyOf");

			if (startIndex < 0 || startIndex > this.length)
				throw new ArgumentOutOfRangeException ();

			if (this.length == 0)
				return -1;

			fixed (char* test = &start_char, testChars = anyOf) {
				char* testPtr = test + this.length;
				char* testChar, targetChar = testChars + anyOf.Length;
				for (int pos = this.length; pos > startIndex; pos--) {
					testChar = testChars;
					for (; testChar < targetChar;) {
						if (*testPtr == *testChar)
							return pos;
						testChar++;
					}
					testPtr--;
				}
			}
			return -1;
		}

		public unsafe int LastIndexOfAny (char [] anyOf, int startIndex, int count)
		{
			if (anyOf == null) 
				throw new ArgumentNullException ("anyOf");

			if (startIndex < 0 || count < 0 || startIndex > this.length || startIndex - count < -1)
				throw new ArgumentOutOfRangeException ();

			if (this.length == 0)
				return -1;

			fixed (char* test = &start_char, testChars = anyOf) {
				char* testPtr = test + count;
				char* testChar, targetChar = testChars + anyOf.Length;
				for (int pos = startIndex + count; pos > startIndex; pos--) {
					testChar = testChars;
					for (; testChar < targetChar;) {
						if (*testPtr == *testChar)
							return pos;
						testChar++;
					}
					testPtr--;
				}
			}
			return -1;
		}

		public unsafe int LastIndexOf (char value)
		{
			fixed (char* test = &start_char) {
				char* testPtr = test + this.length;
				for (int pos = this.length; pos > 0; pos--) {
					if (*testPtr == value)
						return pos;
					testPtr--;
				}
			}
			return -1;
//			if (this.length == 0)
//				return -1;
//			else
//				return LastIndexOf (value, this.length - 1, this.length);
		}

		public int LastIndexOf (String value)
		{
			if (this.length == 0)
				/* This overload does additional checking */
				return LastIndexOf (value, 0, 0);
			else
				return LastIndexOf (value, this.length - 1, this.length);
		}

		public unsafe int LastIndexOf (char value, int startIndex)
		{
			if (startIndex < 0)
				throw new ArgumentOutOfRangeException ("startIndex");

			if (startIndex >= this.length)
				throw new ArgumentOutOfRangeException ("startIndex");

			fixed (char* test = &start_char) {
				char* testPtr = test + startIndex;
				for (int pos = startIndex; pos > 0; pos--) {
					if (*testPtr == value)
						return pos;
					testPtr--;
				}
			}
			return -1;
			//return LastIndexOf (value, startIndex, startIndex + 1);
		}

		public int LastIndexOf (String value, int startIndex)
		{
			return LastIndexOf (value, startIndex, startIndex + 1);
		}

		/* This method is culture-insensitive */
		public unsafe int LastIndexOf (char value, int startIndex, int count)
		{
//			if (startIndex == 0 && this.length == 0)
//				return -1;

			if (startIndex < 0 || count < 0)
				throw new ArgumentOutOfRangeException ();

			if (startIndex >= this.length || startIndex - count + 1 < 0)
				throw new ArgumentOutOfRangeException ();

			fixed (char* test = &start_char) {
				char* testPtr = test + startIndex;
				for (int pos = startIndex; pos > startIndex - count; pos--) {
					if (*testPtr == value)
						return pos;
					testPtr--;
				}
			}
			return -1;

//			for(int pos = startIndex; pos > startIndex - count; pos--) {
//				if (this [pos] == value)
//					return pos;
//			}
//			return -1;
		}

		/* But this one is culture-sensitive */
		public int LastIndexOf (String value, int startIndex, int count)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			if (value.length == 0)
				return 0;

			if (startIndex == 0 && this.length == 0)
				return -1;

			// This check is needed to match undocumented MS behaviour
			if (this.length == 0 && value.length > 0)
				return -1;

			if (value.length > startIndex)
				return -1;

			if (count == 0)
				return -1;

			if (startIndex < 0 || startIndex > this.length)
				throw new ArgumentOutOfRangeException ();

			if (count < 0 || startIndex - count + 1 < 0)
				throw new ArgumentOutOfRangeException ();

			return CultureInfo.CurrentCulture.CompareInfo.LastIndexOf (this, value, startIndex, count);
		}

		public String PadLeft (int totalWidth)
		{
			return PadLeft (totalWidth, ' ');
		}

		public unsafe String PadLeft (int totalWidth, char paddingChar)
		{
			if (totalWidth < 0)
				throw new ArgumentException ();

			if (totalWidth < this.length)
				return this;

			int fillCount = totalWidth - this.length;
			string tmp = InternalAllocateStr (totalWidth);
			fixed (char * source = &start_char, dest = tmp) {
				CharCopy (source, dest + fillCount, this.length);
				char * destPtr = dest, target = dest + fillCount;
				for (; destPtr < target;) {
					*destPtr = paddingChar;
					destPtr++;
				}
			}
			return tmp;
		}

		public String PadRight (int totalWidth)
		{
			return PadRight (totalWidth, ' ');
		}

		public unsafe String PadRight (int totalWidth, char paddingChar)
		{
			if (totalWidth < 0)
				throw new ArgumentException ();

			if (totalWidth < this.length)
				return this;

			int fillCount = totalWidth - this.length;
			string tmp = InternalAllocateStr (totalWidth);
			fixed (char * source = &start_char, dest = tmp) {
				CharCopy (source, dest, this.length);
				char * destPtr = dest + fillCount, target = dest + totalWidth;
				for (; destPtr < target;) {
					*destPtr = paddingChar;
					destPtr++;
				}
			}
			return tmp;
		}

		public bool StartsWith (String value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");
			
			if (value.length == 0)
				return true;

			if (this.length < value.length)
				return false;

			return (0 == Compare (this, 0, value, 0 , value.length));
		}

		/* This method is culture insensitive */
		public unsafe String Replace (char oldChar, char newChar)
		{
//			// Change Replace(char, char) to managed code, because ICU doesn't deal with replacing \0
//			char[] stringArray = this.ToCharArray();
//			for(int i = 0; i < stringArray.Length; i++)
//			{
//				if(stringArray[i] == oldChar)
//					stringArray[i] = newChar;
//			}
//			return new String(stringArray);

//			string tmp = InternalAllocateStr (length);
//			fixed (char * source = &start_char, dest = tmp) {
//				for (int x = 0; x < length; x++) {
//					if (source[x] == oldChar)
//						dest[x] = newChar;
//					else
//						dest[x] = source[x];
//				}
//			}
//			return tmp;
			
//			string tmp = InternalAllocateStr (length);
//			fixed (char* s = &start_char, d = tmp) {
//				char* source = s, dest = d, target = source + length;
//				for (; source < target;) {
//					if (*source == oldChar)
//						*dest = newChar;
//					else
//						*dest = *source;
//					source++;
//					dest++;
//				}
//			}
//			return tmp;

//			fixed (char* s = &start_char) {
//				char* source = s, target = source + length;
//				for (; source < target;) {
//					if (*source == oldChar) {
//						string tmp = InternalAllocateStr (length);
//						fixed (char* d = tmp) {
//							int pos = (int)(source - s);
//							char* dest = d + pos;
//							CharCopy (s, d, pos);
//							for (; source < target;) {
//								if (*source == oldChar)
//									*dest = newChar;
//								else
//									*dest = *source;
//								source++;
//								dest++;
//							}
//						}
//						return tmp;
//					}
//					source++;
//				}
//			}
//			return this;
			
//int pos = this.IndexOf(oldChar);
//if(pos == -1)
//return this;
//string tmp = InternalAllocateStr(length);
//fixed(char* s = &start_char, d = tmp) {
//CharCopy(s, d, pos);
//for(int i = pos; i < length ; i++)
//{
//if(s[i] == oldChar)
//d[i] = newChar;
//else
//d[i] = s[i];
//}
//}
//return tmp;
			// Check if we have chars that need to be relaced
			// If we haven't don't create a new string object
			fixed (char* source = &start_char) {
				for (int x = 0; x < length; x++) {
					if (source[x] == oldChar) {
						string tmp = InternalAllocateStr (length);
						fixed (char* dest = tmp) {
							CharCopy (source, dest, x);
							source[x] = newChar;
							for (; x < length; x++) {
								if (source[x] == oldChar)
									dest[x] = newChar;
								else
									dest[x] = source[x];
							}
						}
						return tmp;
					}
				}
			}
			return this;
			
//			fixed (char* source = &start_char) {
//				for (int x = 0; x < length; x++) {
//					if (source[x] == oldChar) {
//						string tmp = InternalAllocateStr (length);
//						fixed (char* dest = tmp) {
//							CharCopy (source, dest, x);
//							source[x] = newChar;
//							for (; x < length; x++) {
//								if (source[x] == oldChar)
//									dest[x] = newChar;
//								else
//									dest[x] = source[x];
//							}
//						}
//						return tmp;
//					}
//				}
//			}
//			return this;
		}

		/* This method is culture sensitive */
		public String Replace (String oldValue, String newValue)
		{
			if (oldValue == null)
				throw new ArgumentNullException ("oldValue");

			if (oldValue == String.Empty)
				throw new ArgumentException ("oldValue is the empty string.");

			if (this.length == 0)
				return this;

			if (newValue == null)
				newValue = String.Empty;

			return InternalReplace (oldValue, newValue, CultureInfo.CurrentCulture.CompareInfo);
		}

		public unsafe String Remove (int startIndex, int count)
		{
			if (startIndex < 0 || count < 0 || startIndex + count > this.length)
				throw new ArgumentOutOfRangeException ();

			int newLength = this.length - count;
			string tmp = InternalAllocateStr (newLength);

			fixed (char * source = &start_char, dest = tmp) {
				CharCopy (source, dest, startIndex);
				int setoff = startIndex + count;
				CharCopy (source + setoff, dest + startIndex, this.length - setoff);
			}
			return tmp;
			
			//return InternalRemove (startIndex, count);
		}

		public String ToLower ()
		{
			// CurrentCulture can never be invariant or null
			return InternalToLower (CultureInfo.CurrentCulture);
		}

		public unsafe String ToLower (CultureInfo culture)
		{
			if (culture == null)
				throw new ArgumentNullException ("culture");

			if (culture.LCID == CultureInfo.InvariantCulture.LCID) {
				string tmp = InternalAllocateStr (length);
				fixed (char* source = &start_char, dest = tmp) {

					char* destPtr = (char*)dest;
					char* sourcePtr = (char*)source;

					for (int n = 0; n < length; n++) {
						*destPtr = Char.ToLower (*sourcePtr);
						sourcePtr++;
						destPtr++;
					}
				}
				return tmp;
			}
			return InternalToLower (culture);
		}

		public String ToUpper ()
		{
			// CurrentCulture can never be invariant or null
			return InternalToUpper (CultureInfo.CurrentCulture);
		}

		public unsafe String ToUpper (CultureInfo culture)
		{
			if (culture == null)
				throw new ArgumentNullException ("culture");

			if (culture.LCID == CultureInfo.InvariantCulture.LCID) {
				string tmp = InternalAllocateStr (length);
				fixed (char* source = &start_char, dest = tmp) {

					char* destPtr = (char*)dest;
					char* sourcePtr = (char*)source;

					for (int n = 0; n < length; n++) {
						*destPtr = Char.ToUpper (*sourcePtr);
						sourcePtr++;
						destPtr++;
					}
				}
				return tmp;
			}
			return InternalToUpper (culture);
		}

		public override String ToString ()
		{
			return this;
		}

		public String ToString (IFormatProvider provider)
		{
			return this;
		}

		public String Trim ()
		{
			return Trim (null);
		}

		public static String Format (String format, Object arg0)
		{
			return Format (null, format, new Object[] {arg0});
		}

		public static String Format (String format, Object arg0, Object arg1)
		{
			return Format (null, format, new Object[] {arg0, arg1});
		}

		public static String Format (String format, Object arg0, Object arg1, Object arg2)
		{
			return Format (null, format, new Object[] {arg0, arg1, arg2});
		}

		public static string Format (string format, params object[] args)
		{
			return Format (null, format, args);
		}
	
		public static string Format (IFormatProvider provider, string format, params object[] args)
		{
			StringBuilder b = new StringBuilder ();
			FormatHelper (b, provider, format, args);
			return b.ToString ();
		}
		
		internal static void FormatHelper (StringBuilder result, IFormatProvider provider, string format, params object[] args)
		{
			if (format == null || args == null)
				throw new ArgumentNullException ();

			int ptr = 0;
			int start = ptr;
			while (ptr < format.length) {
				char c = format[ptr ++];

				if (c == '{') {
					result.Append (format, start, ptr - start - 1);

					// check for escaped open bracket

					if (format[ptr] == '{') {
						start = ptr ++;
						continue;
					}

					// parse specifier
				
					int n, width;
					bool left_align;
					string arg_format;

					ParseFormatSpecifier (format, ref ptr, out n, out width, out left_align, out arg_format);
					if (n >= args.Length)
						throw new FormatException ("Index (zero based) must be greater than or equal to zero and less than the size of the argument list.");

					// format argument

					object arg = args[n];

					string str;
					if (arg == null)
						str = "";
					else if (arg is IFormattable)
						str = ((IFormattable)arg).ToString (arg_format, provider);
					else
						str = arg.ToString ();

					// pad formatted string and append to result

					if (width > str.length) {
						string pad = new String (' ', width - str.length);

						if (left_align) {
							result.Append (str);
							result.Append (pad);
						}
						else {
							result.Append (pad);
							result.Append (str);
						}
					}
					else
						result.Append (str);

					start = ptr;
				}
				else if (c == '}' && ptr < format.length && format[ptr] == '}') {
					result.Append (format, start, ptr - start - 1);
					start = ptr ++;
				}
				else if (c == '}') {
					throw new FormatException ("Input string was not in a correct format.");
				}
			}

			if (start < format.length)
				result.Append (format.Substring (start));
		}

		public unsafe static String Copy (String str)
		{
			if (str == null)
				throw new ArgumentNullException ("str");

//			return str;
			string tmp = InternalAllocateStr (str.length);
			fixed (char * source = str, dest = tmp) {
				CharCopy (source, dest, str.length);
			}
			return tmp;

//			String tmp = InternalAllocateStr (length);
//			InternalStrcpy (tmp, 0, str);
//			return tmp;
		}

		public static String Concat (Object obj)
		{
			if (obj == null)
				return String.Empty;

			return obj.ToString ();
		}

		public static String Concat (Object obj1, Object obj2)
		{
			string s1, s2;

			s1 = (obj1 != null) ? obj1.ToString () : null;
			s2 = (obj2 != null) ? obj2.ToString () : null;
			
			if (s1 == null) {
				if (s2 == null)
					return String.Empty;
				else
					return s2;
			} else if (s2 == null)
				return s1;

			String tmp = InternalAllocateStr (s1.Length + s2.Length);
			InternalStrcpy (tmp, 0, s1);
			InternalStrcpy (tmp, s1.length, s2);

			return tmp;
		}

		public static String Concat (Object obj1, Object obj2, Object obj3)
		{
			string s1, s2, s3;
			if (obj1 == null)
				s1 = String.Empty;
			else
				s1 = obj1.ToString ();

			if (obj2 == null)
				s2 = String.Empty;
			else
				s2 = obj2.ToString ();

			if (obj3 == null)
				s3 = String.Empty;
			else
				s3 = obj3.ToString ();

			return Concat (s1, s2, s3);
		}

		public static String Concat (Object obj1, Object obj2, Object obj3, Object obj4)
		{
			// This can never be called with 4 null values because then the String
			// version would get called
			string s1, s2, s3, s4;

			if (obj1 == null)
				s1 = String.Empty;
			else
				s1 = obj1.ToString ();

			if (obj2 == null)
				s2 = String.Empty;
			else
				s2 = obj2.ToString ();

			if (obj3 == null)
				s3 = String.Empty;
			else
				s3 = obj3.ToString ();

			if (obj4 == null)
				s4 = String.Empty;
			else
				s4 = obj4.ToString ();

			return Concat (s1, s2, s3, s4);
			
		}

		public static String Concat (String s1, String s2)
		{
			if (s1 == null) {
				if (s2 == null)
					return String.Empty;
				return s2;
			}

			if (s2 == null)
				return s1; 

			String tmp = InternalAllocateStr (s1.length + s2.length);

			InternalStrcpy (tmp, 0, s1);
			InternalStrcpy (tmp, s1.length, s2);

			return tmp;
		}

		public static String Concat (String s1, String s2, String s3)
		{
			if (s1 == null){
				if (s2 == null){
					if (s3 == null)
						return String.Empty;
					return s3;
				} else {
					if (s3 == null)
						return s2;
				}
				s1 = String.Empty;
			} else {
				if (s2 == null){
					if (s3 == null)
						return s1;
					else
						s2 = String.Empty;
				} else {
					if (s3 == null)
						s3 = String.Empty;
				}
			}

			//return InternalConcat (s1, s2, s3);
			String tmp = InternalAllocateStr (s1.length + s2.length + s3.length);

			InternalStrcpy (tmp, 0, s1);
			InternalStrcpy (tmp, s1.length, s2);
			InternalStrcpy (tmp, s1.length + s2.length, s3);

			return tmp;
		}

		public static String Concat (String s1, String s2, String s3, String s4)
		{
			//if (s1 == null && s2 == null && s3 == null && s4 == null)
			//	return String.Empty;

			if (s1 == null)
				s1 = String.Empty;
			if (s2 == null)
				s2 = String.Empty;
			if (s3 == null)
				s3 = String.Empty;
			if (s4 == null)
				s4 = String.Empty;
			
			int len = s1.length + s2.length + s3.length + s4.length;
			if (len == 0)
				return String.Empty;

			String tmp = InternalAllocateStr (len);

			if (s1.length != 0)
				InternalStrcpy (tmp, 0, s1);
			if (s2.length != 0)
				InternalStrcpy (tmp, s1.length, s2);
			if (s3.length != 0)
				InternalStrcpy (tmp, s1.length + s2.length, s3);
			if (s4.length != 0)
				InternalStrcpy (tmp, len - s4.length, s4);

			return tmp;
		}

		public static String Concat (params Object[] args)
		{
			if (args == null)
				throw new ArgumentNullException ("args");

			string [] strings = new string [args.Length];
			int len = 0;

			for (int i = 0; i < args.Length; i++) {
				// use Empty for each null argument
				if (args[i] == null)
					strings[i] = String.Empty;
					// We know that length == 0
				else {
					strings[i] = args[i].ToString ();
					len += strings[i].length;
				}
				i++;
			}

			if (len == 0)
				return String.Empty;

			int currentpos = 0;
			String tmp = InternalAllocateStr (len);
			for (int i = 0; i < strings.Length; i++) {
				if (strings[i].length != 0) {
					InternalStrcpy (tmp, currentpos, strings[i]);
					currentpos += strings[i].length;
				}
			}

			return tmp;
		}

		public static String Concat (params String[] values)
		{
			if (values == null)
				throw new ArgumentNullException ("values");

			int len = 0;
			for (int i = 0; i < values.Length; i++)
				if (values[i] != null)
					len += values[i].length;
				else
					values[i] = String.Empty;

			if (len == 0)
				return String.Empty;

			int currentpos = 0;

			String tmp = InternalAllocateStr (len);
			for (int i = 0; i < values.Length; i++) {
				if (values[i].length != 0) {
					InternalStrcpy (tmp, currentpos, values[i]);
					currentpos += values[i].length;
				}
			}	

			return tmp;
		}

//		public static String Concat (params String[] values)
//		{
//			int len, i, currentpos;
//
//			if (values == null)
//				throw new ArgumentNullException ("values");
//
//			len = 0;
//			foreach (string value in values)
//				len += value != null ? value.length : 0;
//
//			if (len == 0)
//				return String.Empty;
//
//			currentpos = 0;
//
//			String tmp = InternalAllocateStr (len);
//			for (i = 0; i < values.Length; i++) {
//				if (values[i] == null)
//					continue;
//
//				InternalStrcpy (tmp, currentpos, values[i]);
//				currentpos += values[i].length;
//			}	
//
//			return tmp;
//		}

		public unsafe String Insert (int startIndex, String value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			if (startIndex < 0 || startIndex > this.length)
				throw new ArgumentOutOfRangeException ();

			String tmp = InternalAllocateStr (this.length + value.length);
			fixed (char * source = &start_char, insert = value, dest = tmp) {
				CharCopy (source, dest, startIndex);
				CharCopy (insert, dest + startIndex, value.length);
				CharCopy (source + startIndex, dest + startIndex + value.length, this.length - startIndex);
			}
			return tmp;
		}

//		public String Insert (int startIndex, String value)
//		{
//			if (value == null)
//				throw new ArgumentNullException ("value");
//
//			if (startIndex < 0 || startIndex > this.length)
//				throw new ArgumentOutOfRangeException ();
//
//			return InternalInsert (startIndex, value);
//		}


		public static string Intern (string str)
		{
			if (str == null)
				throw new ArgumentNullException ("str");

			return InternalIntern (str);
		}

		public static string IsInterned (string str)
		{
			if (str == null)
				throw new ArgumentNullException ("str");

			return InternalIsInterned (str);
		}
	
		public static string Join (string separator, string [] value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			return Join (separator, value, 0, value.Length);
		}

		public unsafe static string Join (string separator, string[] value, int startIndex, int count)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			if (startIndex < 0 || count < 0)
				throw new ArgumentOutOfRangeException ();

			if (startIndex + count > value.Length)
				throw new ArgumentOutOfRangeException ();

			if (separator == null)
				separator = String.Empty;
			//if (startIndex == value.Length)
			//	return String.Empty;

			string current;
			int length = separator.length * (count - 1);
			for (int pos = startIndex; pos != startIndex + count; pos++) {
				current = value [pos];
				if (current != null)
					length += current.length;
		
				//if (pos < startIndex + count - 1)
				//	length += separator.length;
				//length += separator.length;
			}
			//length += separator.length * count;
			//return null;
			
			if (length == 0)
				return String.Empty;

			String tmp = InternalAllocateStr (length);
			//dest = mono_string_chars(ret);
			int destpos = 0;
			int max = startIndex + count - 1;

			fixed (char * dest = tmp, sep = separator) {
				//MemCopy (s1 + startIndex, s2, newLen);
	
				for (int pos = startIndex; pos != max; pos++) {
					current = value [pos];
					if (current != null) {
						if (current.length > 0)
							fixed (char * source = current) {
								CharCopy (source, dest + destpos, current.length);
								destpos += current.length;
							}
					}
					CharCopy (sep, dest + destpos, separator.length);
					destpos += separator.length;
				}
				current = value [max];
				if (current != null) {
					if (current.length > 0)
						fixed (char * source = current) {
							CharCopy (source, dest + destpos, current.length);
						}
				}
			}
		
			return tmp;
	
			//return InternalJoin (separator, value, startIndex, count);
		}

		bool IConvertible.ToBoolean (IFormatProvider provider)
		{
			return Convert.ToBoolean (this);
		}

		byte IConvertible.ToByte (IFormatProvider provider)
		{
			return Convert.ToByte (this);
		}

		char IConvertible.ToChar (IFormatProvider provider)
		{
			return Convert.ToChar (this);
		}

		DateTime IConvertible.ToDateTime (IFormatProvider provider)
		{
			return Convert.ToDateTime (this);
		}

		decimal IConvertible.ToDecimal (IFormatProvider provider)
		{
			return Convert.ToDecimal (this);
		}

		double IConvertible.ToDouble (IFormatProvider provider)
		{
			return Convert.ToDouble (this);
		}

		short IConvertible.ToInt16 (IFormatProvider provider)
		{
			return Convert.ToInt16 (this);
		}

		int IConvertible.ToInt32 (IFormatProvider provider)
		{
			return Convert.ToInt32 (this);
		}

		long IConvertible.ToInt64 (IFormatProvider provider)
		{
			return Convert.ToInt64 (this);
		}
	
		[CLSCompliant (false)]
		sbyte IConvertible.ToSByte (IFormatProvider provider)
		{
			return Convert.ToSByte (this);
		}

		float IConvertible.ToSingle (IFormatProvider provider)
		{
			return Convert.ToSingle (this);
		}

		string IConvertible.ToString (IFormatProvider format)
		{
			return this;
		}

		object IConvertible.ToType (Type conversionType, IFormatProvider provider)
		{
			return null; // Convert.ToType (this, conversionType,  provider);
		}

		[CLSCompliant (false)]
		ushort IConvertible.ToUInt16 (IFormatProvider provider)
		{
			return Convert.ToUInt16 (this);
		}

		[CLSCompliant (false)]
		uint IConvertible.ToUInt32 (IFormatProvider provider)
		{
			return Convert.ToUInt32 (this);
		}

		[CLSCompliant (false)]
		ulong IConvertible.ToUInt64 (IFormatProvider provider)
		{
			return Convert.ToUInt64 (this);
		}

		TypeCode IConvertible.GetTypeCode ()
		{
			return TypeCode.String;
		}

		public int Length {
			get {
				return length;
			}
		}

		public CharEnumerator GetEnumerator ()
		{
			return null;// new CharEnumerator (this);
		}

		IEnumerator IEnumerable.GetEnumerator ()
		{
			return null; // new CharEnumerator (this);
		}

		private static void ParseFormatSpecifier (string str, ref int ptr, out int n, out int width,
		                                          out bool left_align, out string format)
		{
			// parses format specifier of form:
			//   N,[\ +[-]M][:F]}
			//
			// where:

			try {
				// N = argument number (non-negative integer)

				n = ParseDecimal (str, ref ptr);
				if (n < 0)
					throw new FormatException ("Input string was not in a correct format.");

				// M = width (non-negative integer)

				if (str[ptr] == ',') {
					// White space between ',' and number or sign.
					int start = ++ptr;
					while (Char.IsWhiteSpace (str [ptr]))
						++ptr;

					format = str.Substring (start, ptr - start);

					left_align = (str [ptr] == '-');
					if (left_align)
						++ ptr;

					width = ParseDecimal (str, ref ptr);
					if (width < 0)
						throw new FormatException ("Input string was not in a correct format.");
				}
				else {
					width = 0;
					left_align = false;
					format = "";
				}

				// F = argument format (string)

				if (str[ptr] == ':') {
					int start = ++ ptr;
					while (str[ptr] != '}')
						++ ptr;

					format += str.Substring (start, ptr - start);
				}
				else
					format = null;

				if (str[ptr ++] != '}')
					throw new FormatException ("Input string was not in a correct format.");
			}
			catch (IndexOutOfRangeException) {
				throw new FormatException ("Input string was not in a correct format.");
			}
		}

		private static int ParseDecimal (string str, ref int ptr)
		{
			int p = ptr;
			int n = 0;
			while (true) {
				char c = str[p];
				if (c < '0' || '9' < c)
					break;

				n = n * 10 + c - '0';
				++ p;
			}

			if (p == ptr)
				return -1;

			ptr = p;
			return n;
		}

		internal unsafe void InternalSetChar (int idx, char val)
		{
			if ((uint) idx >= (uint) Length)
				throw new ArgumentOutOfRangeException ("idx");

			fixed (char * pStr = &start_char)
			{
				pStr [idx] = val;
			}
		}

		internal unsafe void InternalSetLength (int newLength)
		{
			if (newLength > length)
				throw new ArgumentOutOfRangeException ("newLength", "newLength as to be <= length");

			length = newLength;

			// zero terminate, we can pass string objects directly via pinvoke
			fixed (char * pStr = &start_char) {
				pStr [length] = '\0';
			}
		}

		[CLSCompliant (false), MethodImplAttribute (MethodImplOptions.InternalCall)]
		unsafe public extern String (char *value);

		[CLSCompliant (false), MethodImplAttribute (MethodImplOptions.InternalCall)]
		unsafe public extern String (char *value, int startIndex, int length);

		[CLSCompliant (false), MethodImplAttribute (MethodImplOptions.InternalCall)]
		unsafe public extern String (sbyte *value);

		[CLSCompliant (false), MethodImplAttribute (MethodImplOptions.InternalCall)]
		unsafe public extern String (sbyte *value, int startIndex, int length);

		[CLSCompliant (false), MethodImplAttribute (MethodImplOptions.InternalCall)]
		unsafe public extern String (sbyte *value, int startIndex, int length, Encoding enc);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		public extern String (char [] val, int startIndex, int length);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		public extern String (char [] val);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		public extern String (char c, int count);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		public extern override int GetHashCode ();
		
		private int hash = -1;
		
		//public unsafe override int GetHashCode ()
		public unsafe int HashCodeTest ()
		{
			Console.WriteLine ("Hash: " + GetHashCode());
			if (hash == -1)
				hash = GetHashCode();
				Console.WriteLine ("Hash: " + hash);
			return hash;
			//fixed (char * data = t) {
			//	for (int i = 0; i < t.length; ++i)
			//		h = (h << 5) - h + data [i];
			//}
			//return h;
		}
		
		public unsafe int HashCodeSpeed ()
		{
			int h = 0;
			fixed (char * data = &start_char) {
				for (int i = 0; i < this.length; ++i)
					h = (h << 5) - h + data [i];
			}
			return h;
		}

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern static string InternalJoin (string separator, string[] value, int sIndex, int count);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern String InternalInsert (int sourceIndex, String value);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern String InternalReplace (char oldChar, char newChar);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern String InternalReplace (String oldValue, string newValue, CompareInfo comp);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern String InternalRemove (int sIndex, int count);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern void InternalCopyTo (int sIndex, char[] dest, int destIndex, int count);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern String[] InternalSplit (char[] separator, int count);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern String InternalTrim (char[] chars, int typ);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern int InternalIndexOfAny (char [] arr, int sIndex, int count);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern int InternalLastIndexOfAny (char [] anyOf, int sIndex, int count);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern String InternalPad (int width, char chr, bool right);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern String InternalToLower (CultureInfo culture);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern String InternalToUpper (CultureInfo culture);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		internal extern static String InternalAllocateStr (int length);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		internal extern static void InternalStrcpy (String dest, int destPos, String src);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		internal extern static void InternalStrcpy (String dest, int destPos, String src, int sPos, int count);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern static string InternalIntern (string str);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private extern static string InternalIsInterned (string str);

		[MethodImplAttribute (MethodImplOptions.InternalCall)]
		private unsafe extern static void InternalCharCopy (char *source, char *destination, int count);
	}
}
