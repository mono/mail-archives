Index: List.cs
===================================================================
--- List.cs	(revision 41250)
+++ List.cs	(working copy)
@@ -101,10 +101,12 @@
 			return BinarySearch (0, size, item, comparer);
 		}
 		
+		[MonoTODO("Check")]
 		public int BinarySearch(int index, int count, T item, IComparer<T> comparer)
 		{
 			CheckRange (index, count);
-			return Array.BinarySearch (data, index, size, item, comparer);
+//			return Array.BinarySearch (data, index, size, item, comparer);
+			return 0;
 		}
 		
 		public void Clear ()
@@ -493,16 +495,16 @@
 #endregion
 		
 		[ComVisible (false)]
-		internal class ReadOnlyList<I> : IList<I>, ICollection<I>, IEnumerable<I>
+		internal class ReadOnlyList<T> : IList<T>, ICollection<T>, IEnumerable<T>
 		{
-			IList<I> list;
+			IList<T> list;
 		
-			internal ReadOnlyList (IList<I> list)
+			internal ReadOnlyList (IList<T> list)
 			{
 				this.list = list;
 			}
 
-			public void Add (I item)
+			public void Add (T item)
 			{
 				throw new NotSupportedException ();
 			}
@@ -512,32 +514,32 @@
 				throw new NotSupportedException ();
 			}
 
-			public bool Contains (I item)
+			public bool Contains (T item)
 			{
 				return list.Contains (item);
 			}
 
-			public void CopyTo (I [] array, int index)
+			public void CopyTo (T [] array, int index)
 			{
 				list.CopyTo (array, index);
 			}
 
-			public IEnumerator<I> GetEnumerator ()
+			public IEnumerator<T> GetEnumerator ()
 			{
 				return list.GetEnumerator ();
 			}
 			
-			public int IndexOf (I item)
+			public int IndexOf (T item)
 			{
 				return list.IndexOf (item);
 			}
 
-			public void Insert (int index, I item)
+			public void Insert (int index, T item)
 			{
 				throw new NotSupportedException ();
 			}
 
-			public bool Remove (I item)
+			public bool Remove (T item)
 			{
 				throw new NotSupportedException ();
 			}
@@ -559,7 +561,7 @@
 				}
 			}
 
-			public I this [int index] {
+			public T this [int index] {
 				get {
 					return list [index];
 				}
@@ -628,6 +630,8 @@
 			}
 			
 		}
+
 	}
 }
 #endif
+
Index: IDictionary.cs
===================================================================
--- IDictionary.cs	(revision 41250)
+++ IDictionary.cs	(working copy)
@@ -37,7 +37,7 @@
 namespace System.Collections.Generic {
 	[CLSCompliant(false)]
 	[ComVisible(false)]
-	public interface IDictionary<K,V> : ICollection<KeyValuePair<K,V>> {
+	public interface IDictionary<K,V> : ICollection<KeyValuePair<K,V>>, IEnumerable<KeyValuePair<K,V>> {
 		void Add (K key, V value);
 		bool ContainsKey (K key);
 		bool Remove (K key);
@@ -47,3 +47,4 @@
 	}
 }
 #endif
+
Index: IComparer.cs
===================================================================
--- IComparer.cs	(revision 41250)
+++ IComparer.cs	(working copy)
@@ -42,3 +42,4 @@
 	}
 }
 #endif
+
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 41250)
+++ ChangeLog	(working copy)
@@ -1,155 +1,160 @@
-2005-02-21  Martin Baulig  <martin@ximian.com>
-
-	* IComparer.cs: Reverted the last change here, Equals() and
-	GetHashCode() have been removed a long time ago.
-
-2005-02-21  Kazuki Oikawa  <kazuki@panicode.com>
-
-	* IComparer.cs, IDictionary.cs: Corrected the wrong declaration.
-
-2005-02-11  Carlos Alberto Cortez <calberto.cortez@gmail.com>
-
-	* List.cs: Added internal ReadOnlyCollection class,
-	which is a wrapper for a read only IList<T> version of the List<T>.
-	Used in AsReadOnly () method.
-	
-2005-02-07  Ben Maurer  <bmaurer@ximian.com>
-
-	* List.cs (CheckRange): Comparison error. Duh!
-	(Shift): really deal with neg. delta. Also, adjust the `size'.
-
-	Based on a patch from Marc Denty (marc.denty@libertysurf.fr).
-
-	Fixes #72258.
-
-2005-01-29  Ben Maurer  <bmaurer@ximian.com>
-
-	* Queue.cs: `duh' bugs.
-
-2004-12-27  Ben Maurer  <bmaurer@ximian.com>
-
-	* Stack.cs: Stupid bug fixes.
-
-	* List.cs: My new (mostly untested ;-) impl of List
-	<T>. Implements most of the API.
-
-2004-12-26  Ben Maurer  <bmaurer@ximian.com>
-
-	* Queue.cs: New, non-linked-list based impl.
-
-2004-11-29  Ben Maurer  <bmaurer@ximian.com>
-
-	* Comparer.cs: Update this class.
-
-2004-11-25  Carlos Alberto Cortez <calberto.cortez@gmail.com>
-
-	* List.cs: Enumerator changed to behave like the MS impl.
-	
-2004-11-25  Ben Maurer  <bmaurer@ximian.com>
-
-	* Stack.cs: New, list based impl. Waiting for some gmcs fixes.
-
-2004-11-10  Martin Baulig  <martin@ximian.com>
-
-	* IDictionary.cs (IDictionary): `IsReadOnly' and `Clear' are
-	inherited from ICollection.
-
-2004-09-20  Gert Driesen <drieseng@users.sourceforge.net>
-
-	* ReadOnlyCollection.cs: Moved to System assembly
-	* Collection.cs: Moved to System assembly
-
-2004-09-07  Carlos Alberto Cortez <carlos@unixmexico.org>
-
-	* ReadOnlyCollection.cs: New file and changes to 
-	Collection.cs tu support it.
-
-2004-09-05  Marek Safar <marek.safar@seznam.cz>
-
-	* Dictionary.cs: Added new file (no implementation).
-
-2004-09-03  Carlos Alberto Cortez <carlos@unixmexico.org>
-
-	* Collection.cs: Small improvements related to
-	style, resizing, and type checking.
-
-2004-09-01  Carlos Alberto Cortez <carlos@unixmexico.org>
-
-	* Collection.cs: New file.
-
-2004-08-04  Martin Baulig  <martin@ximian.com>
-
-	* List.cs (List<T>.Enumerator): Made this a struct.
-	(List<T>.GetEnumerator): The public method now returns the
-	`Enumerator' struct.
-
-2004-08-02  Martin Baulig  <martin@ximian.com>
-
-	Started to do some API review.
-
-	* ICollection.cs (ICollection<T>): Added IsReadOnly, Add, Clear,
-	Contains and Remove.
-
-	* IList.cs (IList<T>): Removed Add, Clear, Constains, Remove,
-	IsReadOnly and IsFixedSize.
-
-2004-08-02  Martin Baulig  <martin@ximian.com>
-
-	* IList.cs (IList.Add): Changed return type to void.
-
-	* List.cs (List.Add): Likewise.
-
-2004-07-16  Martin Baulig  <martin@ximian.com>
-
-	* IComparable.cs: Removed, it's in System.
-
-2004-07-12  Duncan Mak  <duncan@ximian.com>
-
-	* KeyNotFoundException.cs: Added.
-
-2004-06-18  Ben Maurer  <bmaurer@ximian.com>
-
-	* Comparer.cs: v2 impl. Some workarounds for gmcs are enabled.
-
-2004-05-26  Sebastien Pouliot  <sebastien@ximian.com>
-
-	* Queue.cs: Fixed possible integer overflow in CopyTo methods.
-	* Stack.cs: Fixed possible integer overflow in CopyTo methods.
-
-2004-03-13  Martin Baulig  <martin@ximian.com>
-
-	* Stack.cs, Queue.cs, List.cs: Implement the non-generic interfaces.
-
-2004-03-11  Martin Baulig  <martin@ximian.com>
-
-	* List.cs: New file.
-
-2004-03-11  Martin Baulig  <martin@ximian.com>
-
-	* Stack.cs, Queue.cs: Just use `Node' for the nested class, not
-	`Node<T>' (which would create another type parameter `T'
-	overriding `T' from the outer class).	
-
-2004-02-23  Martin Baulig  <martin@ximian.com>
-
-	* Stack.cs, Queue.cs: New files.  Hmm, looks like I forgot to add
-	them to CVS; they're already on my hard disk since December or so.
-
-2003-12-08  Martin Baulig  <martin@ximian.com>
-
-	* *.cs: require GENERICS.
-
-2003-11-08 Ben Maurer  <bmaurer@users.sourceforge.net>
-
-	* *.cs: require NET_2_0 and GENERICS
-
-2003-11-07 Ben Maurer  <bmaurer@users.sourceforge.net>
-
-	* IComparable.cs, IComparer.cs, IDictionary.cs, IKeyComparer.cs, KeyValuePair.cs
-	Added.
-
-2003-11-06  Martin Baulig  <martin@ximian.com>
-
-	* ICollection.cs, IList.cs, IEnumerator.cs, IEnumerable.cs:
-	Started to implement the System.Collections.Generic classes.
-
+2005-02-27  Matthijs ter Woord <meddochat@zonnet.nl>
+
+	* Implemented Dictionary<K,V>
+
+2005-02-21  Martin Baulig  <martin@ximian.com>
+
+	* IComparer.cs: Reverted the last change here, Equals() and
+	GetHashCode() have been removed a long time ago.
+
+2005-02-21  Kazuki Oikawa  <kazuki@panicode.com>
+
+	* IComparer.cs, IDictionary.cs: Corrected the wrong declaration.
+
+2005-02-11  Carlos Alberto Cortez <calberto.cortez@gmail.com>
+
+	* List.cs: Added internal ReadOnlyCollection class,
+	which is a wrapper for a read only IList<T> version of the List<T>.
+	Used in AsReadOnly () method.
+	
+2005-02-07  Ben Maurer  <bmaurer@ximian.com>
+
+	* List.cs (CheckRange): Comparison error. Duh!
+	(Shift): really deal with neg. delta. Also, adjust the `size'.
+
+	Based on a patch from Marc Denty (marc.denty@libertysurf.fr).
+
+	Fixes #72258.
+
+2005-01-29  Ben Maurer  <bmaurer@ximian.com>
+
+	* Queue.cs: `duh' bugs.
+
+2004-12-27  Ben Maurer  <bmaurer@ximian.com>
+
+	* Stack.cs: Stupid bug fixes.
+
+	* List.cs: My new (mostly untested ;-) impl of List
+	<T>. Implements most of the API.
+
+2004-12-26  Ben Maurer  <bmaurer@ximian.com>
+
+	* Queue.cs: New, non-linked-list based impl.
+
+2004-11-29  Ben Maurer  <bmaurer@ximian.com>
+
+	* Comparer.cs: Update this class.
+
+2004-11-25  Carlos Alberto Cortez <calberto.cortez@gmail.com>
+
+	* List.cs: Enumerator changed to behave like the MS impl.
+	
+2004-11-25  Ben Maurer  <bmaurer@ximian.com>
+
+	* Stack.cs: New, list based impl. Waiting for some gmcs fixes.
+
+2004-11-10  Martin Baulig  <martin@ximian.com>
+
+	* IDictionary.cs (IDictionary): `IsReadOnly' and `Clear' are
+	inherited from ICollection.
+
+2004-09-20  Gert Driesen <drieseng@users.sourceforge.net>
+
+	* ReadOnlyCollection.cs: Moved to System assembly
+	* Collection.cs: Moved to System assembly
+
+2004-09-07  Carlos Alberto Cortez <carlos@unixmexico.org>
+
+	* ReadOnlyCollection.cs: New file and changes to 
+	Collection.cs tu support it.
+
+2004-09-05  Marek Safar <marek.safar@seznam.cz>
+
+	* Dictionary.cs: Added new file (no implementation).
+
+2004-09-03  Carlos Alberto Cortez <carlos@unixmexico.org>
+
+	* Collection.cs: Small improvements related to
+	style, resizing, and type checking.
+
+2004-09-01  Carlos Alberto Cortez <carlos@unixmexico.org>
+
+	* Collection.cs: New file.
+
+2004-08-04  Martin Baulig  <martin@ximian.com>
+
+	* List.cs (List<T>.Enumerator): Made this a struct.
+	(List<T>.GetEnumerator): The public method now returns the
+	`Enumerator' struct.
+
+2004-08-02  Martin Baulig  <martin@ximian.com>
+
+	Started to do some API review.
+
+	* ICollection.cs (ICollection<T>): Added IsReadOnly, Add, Clear,
+	Contains and Remove.
+
+	* IList.cs (IList<T>): Removed Add, Clear, Constains, Remove,
+	IsReadOnly and IsFixedSize.
+
+2004-08-02  Martin Baulig  <martin@ximian.com>
+
+	* IList.cs (IList.Add): Changed return type to void.
+
+	* List.cs (List.Add): Likewise.
+
+2004-07-16  Martin Baulig  <martin@ximian.com>
+
+	* IComparable.cs: Removed, it's in System.
+
+2004-07-12  Duncan Mak  <duncan@ximian.com>
+
+	* KeyNotFoundException.cs: Added.
+
+2004-06-18  Ben Maurer  <bmaurer@ximian.com>
+
+	* Comparer.cs: v2 impl. Some workarounds for gmcs are enabled.
+
+2004-05-26  Sebastien Pouliot  <sebastien@ximian.com>
+
+	* Queue.cs: Fixed possible integer overflow in CopyTo methods.
+	* Stack.cs: Fixed possible integer overflow in CopyTo methods.
+
+2004-03-13  Martin Baulig  <martin@ximian.com>
+
+	* Stack.cs, Queue.cs, List.cs: Implement the non-generic interfaces.
+
+2004-03-11  Martin Baulig  <martin@ximian.com>
+
+	* List.cs: New file.
+
+2004-03-11  Martin Baulig  <martin@ximian.com>
+
+	* Stack.cs, Queue.cs: Just use `Node' for the nested class, not
+	`Node<T>' (which would create another type parameter `T'
+	overriding `T' from the outer class).	
+
+2004-02-23  Martin Baulig  <martin@ximian.com>
+
+	* Stack.cs, Queue.cs: New files.  Hmm, looks like I forgot to add
+	them to CVS; they're already on my hard disk since December or so.
+
+2003-12-08  Martin Baulig  <martin@ximian.com>
+
+	* *.cs: require GENERICS.
+
+2003-11-08 Ben Maurer  <bmaurer@users.sourceforge.net>
+
+	* *.cs: require NET_2_0 and GENERICS
+
+2003-11-07 Ben Maurer  <bmaurer@users.sourceforge.net>
+
+	* IComparable.cs, IComparer.cs, IDictionary.cs, IKeyComparer.cs, KeyValuePair.cs
+	Added.
+
+2003-11-06  Martin Baulig  <martin@ximian.com>
+
+	* ICollection.cs, IList.cs, IEnumerator.cs, IEnumerable.cs:
+	Started to implement the System.Collections.Generic classes.
+
+
Index: IList.cs
===================================================================
--- IList.cs	(revision 41250)
+++ IList.cs	(working copy)
@@ -53,3 +53,4 @@
 	}
 }
 #endif
+
Index: KeyNotFoundException.cs
===================================================================
--- KeyNotFoundException.cs	(revision 41250)
+++ KeyNotFoundException.cs	(working copy)
@@ -49,3 +49,4 @@
         }
 }
 #endif
+
Index: Queue.cs
===================================================================
--- Queue.cs	(revision 41250)
+++ Queue.cs	(working copy)
@@ -254,18 +254,18 @@
 			return GetEnumerator ();
 		}
 		
-		public struct Enumerator <T> : IEnumerator <T>, IEnumerator, IDisposable {
+		public struct Enumerator <U> : IEnumerator <U>, IEnumerator, IDisposable {
 			const int NOT_STARTED = -2;
 			
 			// this MUST be -1, because we depend on it in move next.
 			// we just decr the size, so, 0 - 1 == FINISHED
 			const int FINISHED = -1;
 			
-			Queue <T> q;
+			Queue <U> q;
 			int idx;
 			int ver;
 			
-			internal Enumerator (Queue <T> q)
+			internal Enumerator (Queue <U> q)
 			{
 				this.q = q;
 				idx = NOT_STARTED;
@@ -291,7 +291,7 @@
 				return idx != FINISHED && -- idx != FINISHED;
 			}
 			
-			public T Current {
+			public U Current {
 				get {
 					if (idx < 0)
 						throw new InvalidOperationException ();
@@ -316,3 +316,4 @@
 	}
 }
 #endif
+
Index: IEnumerable.cs
===================================================================
--- IEnumerable.cs	(revision 41250)
+++ IEnumerable.cs	(working copy)
@@ -45,3 +45,4 @@
 	}
 }
 #endif
+
Index: IEnumerator.cs
===================================================================
--- IEnumerator.cs	(revision 41250)
+++ IEnumerator.cs	(working copy)
@@ -49,3 +49,4 @@
 	}
 }
 #endif
+
Index: IKeyComparer.cs
===================================================================
--- IKeyComparer.cs	(revision 41250)
+++ IKeyComparer.cs	(working copy)
@@ -43,3 +43,4 @@
 	}
 }
 #endif
+
Index: KeyValuePair.cs
===================================================================
--- KeyValuePair.cs	(revision 41250)
+++ KeyValuePair.cs	(working copy)
@@ -62,3 +62,4 @@
 	}
 }
 #endif
+
Index: ICollection.cs
===================================================================
--- ICollection.cs	(revision 41250)
+++ ICollection.cs	(working copy)
@@ -61,3 +61,4 @@
 	}
 }
 #endif
+
Index: Dictionary.cs
===================================================================
--- Dictionary.cs	(revision 41250)
+++ Dictionary.cs	(working copy)
@@ -35,11 +35,457 @@
 namespace System.Collections.Generic
 {
 	[CLSCompliant(false)]
-	public class Dictionary <K, V> {
+	public class Dictionary <K, V>: IDictionary<K, V>, ICollection<KeyValuePair<K, V>>, IEnumerable<KeyValuePair<K, V>>, IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback 
+	{
+		private List<KeyValuePair<K,V>> underlyingList;
+		private KeyCollection keys;
+		private ValueCollection values;
 
-		public Dictionary ()
+		public Dictionary(){
+			underlyingList = new List<KeyValuePair<K,V>>();
+			keys = new KeyCollection(this);
+			values = new ValueCollection(this);
+		}
+
+		public void Add(K Key, V Value){
+			if (Key == null){
+				throw new ArgumentNullException("Key");
+			}
+			if (!ContainsKey(Key)){
+				underlyingList.Add(new KeyValuePair<K, V>(Key, Value));
+			}else{
+				throw new ArgumentException();
+			}
+		}
+
+		public bool ContainsKey(K Key){
+			foreach(KeyValuePair<K,V> kvp in underlyingList){
+				if (kvp.Key.Equals(Key)){
+					return true;
+				}
+			}
+			return false;
+		}
+
+		public bool Remove(K Key){
+			if (Key == null){
+				throw new ArgumentNullException("Key");
+			}
+			foreach(KeyValuePair<K,V> kvp in underlyingList){
+				if (kvp.Key.Equals(Key)){
+					return underlyingList.Remove(kvp);
+				}
+			}
+			return false;
+		}
+
+		public V this[K Index]{
+			get{
+				if (Index == null){
+					throw new ArgumentNullException("Index");
+				}
+				if (!ContainsKey(Index)){
+					throw new KeyNotFoundException();
+				}
+				foreach(KeyValuePair<K,V> kvp in underlyingList){
+					if (kvp.Key.Equals(Index)){
+						return kvp.Value;
+					}
+				}
+				return default(V);
+			}
+			set{
+				if (Index == null){
+					throw new ArgumentNullException("Index");
+				}
+				if (!ContainsKey(Index)){
+					throw new KeyNotFoundException();
+				}
+				foreach(KeyValuePair<K,V> kvp in underlyingList){
+					if (kvp.Key.Equals(Index)){
+						KeyValuePair<K,V> Temp = kvp;
+						int TempInt = underlyingList.IndexOf(Temp);
+						underlyingList.RemoveAt(TempInt);
+						Temp.Value = value;
+						underlyingList.Insert(TempInt, Temp);
+					}
+				}
+			}
+		}
+
+		public ICollection<K> Keys{
+			get{
+				return keys;
+			}
+		}
+
+		public ICollection<V> Values{
+			get{
+				return values;
+			}
+		}
+
+		public int Count{
+			get{
+				return underlyingList.Count;
+			}
+		}
+
+		public bool IsReadOnly{
+			get{
+				return false;
+			}
+		}
+
+		void ICollection<KeyValuePair<K,V>>.Add(KeyValuePair<K,V> Kvp){
+			throw new NotSupportedException();
+		}
+
+		public void Clear(){
+			underlyingList.Clear();
+		}
+
+		bool ICollection<KeyValuePair<K,V>>.Contains(KeyValuePair<K,V> Kvp){
+			throw new NotSupportedException();
+		}
+
+		void ICollection<KeyValuePair<K,V>>.CopyTo(KeyValuePair<K,V>[] array, int index){
+			throw new NotSupportedException();
+		}
+
+		bool ICollection<KeyValuePair<K,V>>.Remove(KeyValuePair<K,V> kvp){
+			throw new NotSupportedException();
+		}
+
+		IEnumerator<KeyValuePair<K,V>> IEnumerable<KeyValuePair<K,V>>.GetEnumerator(){
+			return underlyingList.GetEnumerator();
+		}
+
+		bool IDictionary.Contains(object obj){
+			if (obj is K){
+				return ContainsKey((K)obj);
+			}
+			return false;
+		}
+
+		void IDictionary.Add(object key, object value){
+			if (key is K && value is V){
+				((IDictionary<K,V>)this).Add((K)key, (V)value);
+			}
+		}
+
+		IDictionaryEnumerator IDictionary.GetEnumerator(){
+			return null;
+		}
+
+		void IDictionary.Remove(object key){
+			if (key is K){
+				((Dictionary<K,V>)this).Remove((K)key);
+			}
+		}
+
+		object IDictionary.this[object index]{
+			get{
+				throw new NotSupportedException();
+			}
+			set{
+				throw new NotSupportedException();
+			}
+		}
+
+		ICollection IDictionary.Keys{
+			get{
+				return keys;
+			}
+		}
+
+		ICollection IDictionary.Values{
+			get{
+				return values;
+			}
+		}
+
+		bool IDictionary.IsFixedSize{
+			get{
+				throw new NotSupportedException();
+			}
+		}
+
+		void ICollection.CopyTo(Array array, int Index){
+			throw new NotSupportedException();
+		}
+
+		object ICollection.SyncRoot{
+			get{
+				throw new NotSupportedException();
+			}
+		}
+
+		bool ICollection.IsSynchronized{
+			get{
+				throw new NotSupportedException();
+			}
+		}
+
+		IEnumerator IEnumerable.GetEnumerator(){
+			throw new NotSupportedException();
+		}
+
+		public sealed class KeyCollection: ICollection<K>, IEnumerable<K>, ICollection, IEnumerable
 		{
+			private Dictionary<K,V> dictionary;
+			public KeyCollection(Dictionary<K,V> aDictionary){
+				dictionary = aDictionary;
+			}
+
+			public int Count{
+				get{
+					return dictionary.underlyingList.Count;
+				}
+			}
+
+			bool ICollection<K>.IsReadOnly{
+				get{
+					return false;
+				}
+			}
+
+			void ICollection<K>.Add(K Key){
+				throw new NotSupportedException();
+			}
+
+			void ICollection<K>.Clear(){
+				throw new NotSupportedException();
+			}
+
+			bool ICollection<K>.Contains(K Key){
+				throw new NotSupportedException();
+			}
+
+			public void CopyTo(K[] array, int Index){
+				if (array == null)
+					throw new ArgumentNullException("array");
+
+				if (Index < 0)
+					throw new ArgumentOutOfRangeException();
+
+				if (Index >= array.Length
+				  ||(array.Length - Index) < Count)
+					throw new ArgumentException();
+
+				for (int i = 0; i < Count; i++){
+					array[Index + i] = dictionary.underlyingList[i].Key;
+				}
+			}
+
+			bool ICollection<K>.Remove(K Key){
+				throw new NotSupportedException();
+			}
+
+			public IEnumerator<K> GetEnumerator(){
+				return new KeyEnumerator<K>(dictionary);
+			}
+
+			void ICollection.CopyTo(Array array, int index){
+				throw new NotSupportedException();
+			}
+
+			object ICollection.SyncRoot{
+				get{
+					throw new NotSupportedException();
+				}
+			}
+
+			bool ICollection.IsSynchronized{
+				get{
+					throw new NotSupportedException();
+				}
+			}
+
+			IEnumerator IEnumerable.GetEnumerator(){
+				return new KeyEnumerator<K>(dictionary);
+			}
+
+			public struct KeyEnumerator<K>: IEnumerator<K>, IDisposable, IEnumerator{
+				const int NOT_STARTED = -2;
+			
+				// this MUST be -1, because we depend on it in move next.
+				// we just decr the size, so, 0 - 1 == FINISHED
+				const int FINISHED = -1;
+			
+				Dictionary<K,V> l;
+				int idx;
+			
+				internal KeyEnumerator (Dictionary<K,V> l)
+				{
+					this.l = l;
+					idx = NOT_STARTED;
+				}
+			
+				// for some fucked up reason, MSFT added a useless dispose to this class
+				// It means that in foreach, we must still do a try/finally. Broken, very
+				// broken.
+				public void Dispose ()
+				{
+					idx = NOT_STARTED;
+				}
+			
+				public bool MoveNext ()
+				{
+					if (idx == NOT_STARTED)
+						idx = l.Count;
+					
+					return idx != FINISHED && -- idx != FINISHED;
+				}
+				
+				public K Current {
+					get {
+						if (idx < 0)
+							throw new InvalidOperationException ();
+					
+						return l.underlyingList[l.Count - 1 - idx].Key;
+					}
+				}
+			
+				void IEnumerator.Reset ()
+				{
+					idx = NOT_STARTED;
+				}
+			
+				object IEnumerator.Current {
+					get { return Current; }
+				}
+
+			}
 		}
+		public sealed class ValueCollection: ICollection<V>, IEnumerable<V>, ICollection, IEnumerable
+		{
+			private Dictionary<K,V> dictionary;
+			public ValueCollection(Dictionary<K,V> aDictionary){
+				dictionary = aDictionary;
+			}
+
+			public int Count{
+				get{
+					return dictionary.underlyingList.Count;
+				}
+			}
+
+			bool ICollection<V>.IsReadOnly{
+				get{
+					return false;
+				}
+			}
+
+			void ICollection<V>.Add(V Key){
+				throw new NotSupportedException();
+			}
+
+			void ICollection<V>.Clear(){
+				throw new NotSupportedException();
+			}
+
+			bool ICollection<V>.Contains(V Key){
+				throw new NotSupportedException();
+			}
+
+			public void CopyTo(V[] array, int Index){
+				if (array == null)
+					throw new ArgumentNullException("array");
+
+				if (Index < 0)
+					throw new ArgumentOutOfRangeException();
+
+				if (Index >= array.Length
+				  ||(array.Length - Index) < Count)
+					throw new ArgumentException();
+
+				for (int i = 0; i < Count; i++){
+					array[Index + i] = dictionary.underlyingList[i].Value;
+				}
+			}
+
+			bool ICollection<V>.Remove(V Key){
+				throw new NotSupportedException();
+			}
+
+			public IEnumerator<V> GetEnumerator(){
+				return new ValueEnumerator<V>(dictionary);
+			}
+
+			void ICollection.CopyTo(Array array, int index){
+				throw new NotSupportedException();
+			}
+
+			object ICollection.SyncRoot{
+				get{
+					throw new NotSupportedException();
+				}
+			}
+
+			bool ICollection.IsSynchronized{
+				get{
+					throw new NotSupportedException();
+				}
+			}
+
+			IEnumerator IEnumerable.GetEnumerator(){
+				return new ValueEnumerator<V>(dictionary);
+			}
+
+			public struct ValueEnumerator<V>: IEnumerator<V>, IDisposable, IEnumerator{
+				const int NOT_STARTED = -2;
+			
+				// this MUST be -1, because we depend on it in move next.
+				// we just decr the size, so, 0 - 1 == FINISHED
+				const int FINISHED = -1;
+			
+				Dictionary<K,V> l;
+				int idx;
+			
+				internal ValueEnumerator (Dictionary<K,V> l)
+				{
+					this.l = l;
+					idx = NOT_STARTED;
+				}
+			
+				// for some fucked up reason, MSFT added a useless dispose to this class
+				// It means that in foreach, we must still do a try/finally. Broken, very
+				// broken.
+				public void Dispose ()
+				{
+					idx = NOT_STARTED;
+				}
+			
+				public bool MoveNext ()
+				{
+					if (idx == NOT_STARTED)
+						idx = l.Count;
+					
+					return idx != FINISHED && -- idx != FINISHED;
+				}
+				
+				public V Current {
+					get {
+						if (idx < 0)
+							throw new InvalidOperationException ();
+					
+						return l.underlyingList[l.Count - 1 - idx].Value;
+					}
+				}
+			
+				void IEnumerator.Reset ()
+				{
+					idx = NOT_STARTED;
+				}
+			
+				object IEnumerator.Current {
+					get { return Current; }
+				}
+
+			}
+		}
 	}
 }
 #endif
+
Index: Stack.cs
===================================================================
--- Stack.cs	(revision 41250)
+++ Stack.cs	(working copy)
@@ -199,18 +199,18 @@
 			return GetEnumerator ();
 		}
 		
-		public struct Enumerator <T> : IEnumerator <T>, IEnumerator, IDisposable {
+		public struct Enumerator <U> : IEnumerator <U>, IEnumerator, IDisposable {
 			const int NOT_STARTED = -2;
 			
 			// this MUST be -1, because we depend on it in move next.
 			// we just decr the size, so, 0 - 1 == FINISHED
 			const int FINISHED = -1;
 			
-			Stack <T> parent;
+			Stack <U> parent;
 			int idx;
 			int ver;
 			
-			internal Enumerator (Stack <T> t)
+			internal Enumerator (Stack <U> t)
 			{
 				parent = t;
 				idx = NOT_STARTED;
@@ -236,7 +236,7 @@
 				return idx != FINISHED && -- idx != FINISHED;
 			}
 			
-			public T Current {
+			public U Current {
 				get {
 					if (idx < 0)
 						throw new InvalidOperationException ();
@@ -261,3 +261,4 @@
 	}
 }
 #endif
+
Index: Comparer.cs
===================================================================
--- Comparer.cs	(revision 41250)
+++ Comparer.cs	(working copy)
@@ -32,8 +32,8 @@
 
 namespace System.Collections.Generic {
 	[CLSCompliant(false)]
-	public abstract class Comparer<T> : IComparer<T>, System.Collections.IKeyComparer,
-		System.Collections.IComparer, System.Collections.IHashCodeProvider {
+	public abstract class Comparer<T> : IComparer<T>, IKeyComparer,
+		IComparer, IHashCodeProvider {
 	
 		public Comparer () {} /* workaround 60438 by not having a protected ctor */
 		public abstract int Compare (T x, T y);
@@ -97,9 +97,9 @@
 			throw new ArgumentException ();
 		}
 	
-		class DefaultComparer<T> : Comparer<T> {
+		class DefaultComparer<U> : Comparer<U> {
 	
-			public override int Compare (T x, T y)
+			public override int Compare (U x, U y)
 			{
 				// `null' is less than any other ref type
 				if (x == null)
@@ -107,15 +107,15 @@
 				else if (y == null)
 					return 1;
 	
-				if (x is IComparable<T>)
-					return ((IComparable<T>) x).CompareTo (y);
+				if (x is IComparable<U>)
+					return ((IComparable<U>) x).CompareTo (y);
 				else if (x is IComparable)
 					return ((IComparable) x).CompareTo (y);
 				else
 					throw new ArgumentException ("does not implement right interface");
 			}
 	
-			public override bool Equals (T x, T y)
+			public override bool Equals (U x, U y)
 			{
 				return Object.Equals (x, y);
 			}
@@ -124,3 +124,4 @@
 
 }
 #endif
+
