Index: ChangeLog
from  Raja R Harinath  <rharinath@novell.com>

	Fix bug #57151.
	* attribute.cs (Attribute.GetPositionalValue): New function.
	* class.cs (TypeContainer.VerifyMembers): New function.
	(TypeContainer.Emit): Use it.
	(ClassOrStruct): New base class for Class and Struct.
	(ClassOrStruct.ApplyAttributeBuilder): New function.  Note if 
	StructLayout(LayoutKind.Explicit) was ascribed to the struct or
	class.
	(ClassOrStruct.VerifyMembers): If the struct is explicitly laid out,
	then each non-static field should have a FieldOffset attribute.
	Otherwise, none of the fields should have a FieldOffset attribute.
	* rootcontext.cs (RootContext.ResolveCore): Resolve StructLayout 
	and FieldOffset attributes.
	* typemanager.cs (TypeManager.struct_layout_attribute_type)
	(TypeManager.field_offset_attribute_type): New core types.
	(TypeManager.InitCoreTypes): Initialize them.

Index: attribute.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/attribute.cs,v
retrieving revision 1.120
diff -u -u -r1.120 attribute.cs
--- attribute.cs 30 Apr 2004 06:13:20 -0000 1.120
+++ attribute.cs 7 May 2004 10:28:49 -0000
@@ -802,6 +812,11 @@
 			return (bool)pos_values [0];
 		}
 
+		public object GetPositionalValue (int i)
+		{
+			return (pos_values == null) ? null : pos_values[i];
+		}
+
 		object GetFieldValue (string name)
                 {
 			int i;
Index: class.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/class.cs,v
retrieving revision 1.429
diff -u -u -r1.429 class.cs
--- class.cs 7 May 2004 07:57:24 -0000 1.429
+++ class.cs 7 May 2004 10:28:50 -0000
@@ -34,6 +34,7 @@
 using System.Reflection;
 using System.Reflection.Emit;
 using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
 
 namespace Mono.CSharp {
 
@@ -1750,6 +1751,49 @@
 			return;
 		}
 
+		protected virtual void VerifyMembers ()
+		{
+			//
+			// Check for internal or private fields that were never assigned
+			//
+			if (RootContext.WarningLevel >= 3) {
+				if (fields != null){
+					foreach (Field f in fields) {
+						if ((f.ModFlags & Modifiers.Accessibility) != Modifiers.PRIVATE)
+							continue;
+						
+						if ((f.status & Field.Status.USED) == 0){
+							Report.Warning (
+								169, f.Location, "Private field " +
+								MakeName (f.Name) + " is never used");
+							continue;
+						}
+						
+						//
+						// Only report 649 on level 4
+						//
+						if (RootContext.WarningLevel < 4)
+							continue;
+						
+						if ((f.status & Field.Status.ASSIGNED) != 0)
+							continue;
+						
+						Report.Warning (
+							649, f.Location,
+							"Field " + MakeName (f.Name) + " is never assigned " +
+							" to and will always have its default value");
+					}
+				}
+
+				if (events != null){
+					foreach (Event e in events){
+						if (e.status == 0)
+							Report.Warning (67, "The event " + MakeName (e.Name) + " is never used");
+					}
+				}
+			}
+		}
+
 		/// <summary>
 		///   Emits the code, this step is performed after all
 		///   the types, enumerations, constructors
@@ -1822,46 +1866,8 @@
 			if (Pending != null)
 				if (Pending.VerifyPendingMethods ())
 					return;
-			
-			//
-			// Check for internal or private fields that were never assigned
-			//
-			if (RootContext.WarningLevel >= 3) {
-				if (fields != null){
-					foreach (Field f in fields) {
-						if ((f.ModFlags & Modifiers.Accessibility) != Modifiers.PRIVATE)
-							continue;
-						
-						if ((f.status & Field.Status.USED) == 0){
-							Report.Warning (
-								169, f.Location, "Private field " +
-								MakeName (f.Name) + " is never used");
-							continue;
-						}
-						
-						//
-						// Only report 649 on level 4
-						//
-						if (RootContext.WarningLevel < 4)
-							continue;
-						
-						if ((f.status & Field.Status.ASSIGNED) != 0)
-							continue;
-						
-						Report.Warning (
-							649, f.Location,
-							"Field " + MakeName (f.Name) + " is never assigned " +
-							" to and will always have its default value");
-					}
-				}
 
-				if (events != null){
-					foreach (Event e in events){
-						if (e.status == 0)
-							Report.Warning (67, "The event " + MakeName (e.Name) + " is never used");
-					}
-				}
-			}
+			VerifyMembers ();
 			
 //			if (types != null)
 //				foreach (TypeContainer tc in types)
@@ -2337,7 +2343,52 @@
 		
 	}
 
-	public class Class : TypeContainer {
+	public class ClassOrStruct : TypeContainer {
+		bool hasExplicitLayout = false;
+		public ClassOrStruct (NamespaceEntry ns, TypeContainer parent, string name, Attributes attrs, Location l)
+			: base (ns, parent, name, attrs, l)
+		{
+		}
+
+		protected override void VerifyMembers () 
+		{
+			if (Fields == null)
+				return;
+			foreach (Field f in Fields) {
+				if ((f.ModFlags & Modifiers.STATIC) != 0)
+					continue;
+				if (hasExplicitLayout) {
+					if (f.OptAttributes == null 
+					    || !f.OptAttributes.Contains (TypeManager.field_offset_attribute_type, this)) {
+						Report.Error (625, f.Location,
+							      "Instance field of type marked with" 
+							      + " StructLayout(LayoutKind.Explicit) must have a"
+							      + " FieldOffset attribute.");
+					}
+				}
+				else {
+					if (f.OptAttributes != null 
+					    && f.OptAttributes.Contains (TypeManager.field_offset_attribute_type, this)) {
+						Report.Error (636, f.Location,
+							      "The FieldOffset attribute can only be placed on members of "
+							      + "types marked with the StructLayout(LayoutKind.Explicit)");
+					}
+				}
+			}
+			base.VerifyMembers ();
+		}
+
+		public override void ApplyAttributeBuilder (object builder, Attribute a, CustomAttributeBuilder cb)
+		{
+			if (a.Type == TypeManager.struct_layout_attribute_type
+			    && (LayoutKind) a.GetPositionalValue (0) == LayoutKind.Explicit)
+				hasExplicitLayout = true;
+
+			base.ApplyAttributeBuilder (builder, a, cb);
+		}
+	}
+
+	public class Class : ClassOrStruct {
 		// <summary>
 		//   Modifiers allowed in a class declaration
 		// </summary>
@@ -2376,7 +2427,7 @@
 		}
 	}
 
-	public class Struct : TypeContainer {
+	public class Struct : ClassOrStruct {
 		// <summary>
 		//   Modifiers allowed in a struct declaration
 		// </summary>
Index: rootcontext.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/rootcontext.cs,v
retrieving revision 1.129
diff -u -u -r1.129 rootcontext.cs
--- rootcontext.cs 5 May 2004 08:49:33 -0000 1.129
+++ rootcontext.cs 7 May 2004 10:28:50 -0000
@@ -376,6 +376,8 @@
 				"System.Security.UnverifiableCodeAttribute",
 				"System.Runtime.CompilerServices.IndexerNameAttribute",
 				"System.Runtime.InteropServices.InAttribute",
+				"System.Runtime.InteropServices.StructLayoutAttribute",
+				"System.Runtime.InteropServices.FieldOffsetAttribute",
 				"System.InvalidOperationException",
 				"System.MarshalByRefObject"
 			};
Index: typemanager.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/typemanager.cs,v
retrieving revision 1.288
diff -u -u -r1.288 typemanager.cs
--- typemanager.cs 5 May 2004 08:49:33 -0000 1.288
+++ typemanager.cs 7 May 2004 10:28:50 -0000
@@ -88,6 +88,8 @@
 	static public Type typed_reference_type;
 	static public Type arg_iterator_type;
 	static public Type mbr_type;
+	static public Type struct_layout_attribute_type;
+	static public Type field_offset_attribute_type;
 
 	//
 	// An empty array of types
@@ -1069,6 +1071,8 @@
 		obsolete_attribute_type = CoreLookupType ("System.ObsoleteAttribute");
 		conditional_attribute_type = CoreLookupType ("System.Diagnostics.ConditionalAttribute");
 		cls_compliant_attribute_type = CoreLookupType ("System.CLSCompliantAttribute");
+		struct_layout_attribute_type = CoreLookupType ("System.Runtime.InteropServices.StructLayoutAttribute");
+		field_offset_attribute_type = CoreLookupType ("System.Runtime.InteropServices.FieldOffsetAttribute");
 
 		//
 		// When compiling corlib, store the "real" types here.
