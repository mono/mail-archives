Index: mono/dis/dis-cil.c
===================================================================
--- mono/dis/dis-cil.c	(revision 138601)
+++ mono/dis/dis-cil.c	(working copy)
@@ -200,7 +200,7 @@
 				fprintf (output, "(00 00 00 00 00 00 f8 ff)"); /* NaN */
 			else {
 				char *str = stringify_double (r);
-				fprintf (output, str);
+				fprintf (output, "%s", str);
 				g_free (str);
 			}
 			ptr += 8;
@@ -309,7 +309,7 @@
 				fprintf (output, "(00 00 c0 ff)"); /* NaN */
 			else {
 				char *str = stringify_double ((double) f);
-				fprintf (output, str);
+				fprintf (output, "%s", str);
 				g_free (str);
 			}
 			ptr += 4;
Index: mono/dis/main.c
===================================================================
--- mono/dis/main.c	(revision 138601)
+++ mono/dis/main.c	(working copy)
@@ -1222,7 +1222,7 @@
 		
                 param = get_generic_param (m, container);
 		if (param) {
-			fprintf (output, param);
+			fprintf (output, "%s", param);
 			g_free (param);
 		}
                 fprintf (output, "\n");
@@ -1236,7 +1236,7 @@
 
                 param = get_generic_param (m, container);
 		if (param) {
-			fprintf (output, param);
+			fprintf (output, "%s", param);
 			g_free (param);
 		}
 		fprintf (output, "\n");
Index: mono/metadata/console-unix.c
===================================================================
--- mono/metadata/console-unix.c	(revision 138601)
+++ mono/metadata/console-unix.c	(working copy)
@@ -27,6 +27,7 @@
 #include <mono/metadata/domain-internals.h>
 #include <mono/metadata/metadata.h>
 #include <mono/metadata/threadpool.h>
+#include <mono/utils/mono-io-portability.h>
 
 /* On solaris, curses.h must come before both termios.h and term.h */
 #ifdef HAVE_CURSES_H
@@ -198,7 +199,7 @@
 		return;
 
 	if (teardown_str != NULL) {
-		write (STDOUT_FILENO, teardown_str, strlen (teardown_str));
+		TEMP_FAILURE_RETRY (write (STDOUT_FILENO, teardown_str, strlen (teardown_str)));
 		g_free (teardown_str);
 		teardown_str = NULL;
 	}
@@ -267,7 +268,7 @@
 	tcsetattr (STDIN_FILENO, TCSANOW, &mono_attr);
 
 	if (keypad_xmit_str != NULL)
-		write (STDOUT_FILENO, keypad_xmit_str, strlen (keypad_xmit_str));
+		TEMP_FAILURE_RETRY (write (STDOUT_FILENO, keypad_xmit_str, strlen (keypad_xmit_str)));
 
 	// Call previous handler
 	if (save_sigcont.sa_sigaction != NULL &&
Index: mono/metadata/debug-helpers.c
===================================================================
--- mono/metadata/debug-helpers.c	(revision 138601)
+++ mono/metadata/debug-helpers.c	(working copy)
@@ -752,11 +752,11 @@
 {
 	if (klass->nested_in) {
 		print_name_space (klass->nested_in);
-		g_print (klass->nested_in->name);
+		g_print ("%s", klass->nested_in->name);
 		return "/";
 	}
 	if (klass->name_space [0]) {
-		g_print (klass->name_space);
+		g_print ("%s", klass->name_space);
 		return ".";
 	}
 	return "";
Index: mono/metadata/threadpool.c
===================================================================
--- mono/metadata/threadpool.c	(revision 138601)
+++ mono/metadata/threadpool.c	(working copy)
@@ -30,6 +30,7 @@
 #include <mono/metadata/gc-internal.h>
 #include <mono/utils/mono-time.h>
 #include <mono/utils/mono-proclib.h>
+#include <mono/utils/mono-io-portability.h>
 #include <errno.h>
 #ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
@@ -863,7 +864,7 @@
 	LeaveCriticalSection (&data->io_lock);
 	*msg = (char) state->operation;
 #ifndef PLATFORM_WIN32
-	write (data->pipe [1], msg, 1);
+	TEMP_FAILURE_RETRY (write (data->pipe [1], msg, 1));
 #else
 	send ((SOCKET) data->pipe [1], msg, 1, 0);
 #endif
Index: mono/metadata/profiler.c
===================================================================
--- mono/metadata/profiler.c	(revision 138601)
+++ mono/metadata/profiler.c	(working copy)
@@ -19,6 +19,7 @@
 #include "mono/metadata/gc-internal.h"
 #include "mono/io-layer/io-layer.h"
 #include "mono/utils/mono-dl.h"
+#include "mono/utils/mono-io-portability.h"
 #include <string.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
@@ -1372,7 +1373,7 @@
 			*end = 0;
 		res = g_strdup_printf ("%s(%s", binary, buf);
 		/* discard the filename/line info */
-		fgets (buf, sizeof (buf), addr2line->pipeout);
+		TEMP_FAILURE_RETRY (fgets (buf, sizeof (buf), addr2line->pipeout));
 	} else {
 		res = g_strdup (binary);
 	}
@@ -1618,7 +1619,7 @@
 	}
 #endif
 	{
-		MonoDl *pmodule;
+		MonoDl *pmodule = NULL;
 		const char* col = strchr (desc, ':');
 		char* libname;
 		char* path;
Index: mono/metadata/class.c
===================================================================
--- mono/metadata/class.c	(revision 138601)
+++ mono/metadata/class.c	(working copy)
@@ -4892,7 +4892,7 @@
 	MonoImage *image;
 	MonoClass *class;
 	MonoClass *parent = NULL;
-	GSList *list, *rootlist;
+	GSList *list, *rootlist = NULL;
 	int nsize;
 	char *name;
 	gboolean corlib_type = FALSE;
Index: mono/metadata/marshal.c
===================================================================
--- mono/metadata/marshal.c	(revision 138601)
+++ mono/metadata/marshal.c	(working copy)
@@ -1625,7 +1625,7 @@
 	default: {
 		char *msg = g_strdup_printf ("marshalling conversion %d not implemented", conv);
 		MonoException *exc = mono_get_exception_not_implemented (msg);
-		g_warning (msg);
+		g_warning ("%s", msg);
 		g_free (msg);
 		mono_raise_exception (exc);
 	}
@@ -5554,7 +5554,7 @@
 		if (conv == -1) {
 			char *msg = g_strdup_printf ("string marshalling conversion %d not implemented", encoding);
 			MonoException *exc = mono_get_exception_not_implemented (msg);
-			g_warning (msg);
+			g_warning ("%s", msg);
 			g_free (msg);
 			mono_raise_exception (exc);
 		}
@@ -5931,7 +5931,7 @@
 			else {
 				char *msg = g_strdup_printf ("stringbuilder marshalling conversion %d not implemented", encoding);
 				MonoException *exc = mono_get_exception_not_implemented (msg);
-				g_warning (msg);
+				g_warning ("%s", msg);
 				g_free (msg);
 				mono_raise_exception (exc);
 			}
@@ -6511,7 +6511,7 @@
 				if (conv == -1) {
 					char *msg = g_strdup_printf ("string/stringbuilder marshalling conversion %d not implemented", encoding);
 					MonoException *exc = mono_get_exception_not_implemented (msg);
-					g_warning (msg);
+					g_warning ("%s", msg);
 					g_free (msg);
 					mono_raise_exception (exc);
 				}
@@ -7210,7 +7210,7 @@
 	case MARSHAL_ACTION_MANAGED_CONV_IN: {
 		MonoClass* conv_arg_class = mono_defaults.int32_class;
 		guint8 ldop = CEE_LDIND_I4;
-		int label_null, label_false;
+		int label_null = 0, label_false;
 
 		conv_arg = mono_mb_add_local (mb, &mono_defaults.boolean_class->byval_arg);
 
Index: mono/metadata/icall.c
===================================================================
--- mono/metadata/icall.c	(revision 138601)
+++ mono/metadata/icall.c	(working copy)
@@ -2919,7 +2919,7 @@
 	const char *scope = NULL;
 	guint32 flags;
 
-	if (!method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL)
+	if (!(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))
 		return NULL;
 
 	if (!DllImportAttributeClass) {
@@ -6532,7 +6532,7 @@
  * arm-apple-darwin9.  We'll manually define the symbol on Apple as it does
  * in fact exist on all implementations (so far) 
  */
-gchar ***_NSGetEnviron();
+gchar ***_NSGetEnviron(void);
 #define environ (*_NSGetEnviron())
 #else
 extern
Index: mono/metadata/reflection.c
===================================================================
--- mono/metadata/reflection.c	(revision 138601)
+++ mono/metadata/reflection.c	(working copy)
@@ -6770,7 +6770,7 @@
 		mono_metadata_decode_row (paramt, i - 1, param_cols, MONO_PARAM_SIZE);
 		paramseq = param_cols [MONO_PARAM_SEQUENCE];
 
-		if (!param_cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_DEFAULT) 
+		if (!(param_cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_DEFAULT))
 			continue;
 
 		crow = mono_metadata_get_constant_index (image, MONO_TOKEN_PARAM_DEF | i, crow + 1);
@@ -7318,7 +7318,7 @@
 	if (info->name_space && (info->name_space [0] != '\0'))
 		g_string_printf (fullName, "%s.%s", info->name_space, info->name);
 	else
-		g_string_printf (fullName, info->name);
+		g_string_printf (fullName, "%s", info->name);
 	for (mod = info->nested; mod; mod = mod->next)
 		g_string_append_printf (fullName, "+%s", (char*)mod->data);
 
@@ -11064,7 +11064,7 @@
 		result = mono_class_from_mono_type (type);
 		*handle_class = mono_defaults.typehandle_class;
 	} else {
-		g_print (obj->vtable->klass->name);
+		g_print ("%s", obj->vtable->klass->name);
 		g_assert_not_reached ();
 	}
 	return result;
Index: mono/io-layer/security.c
===================================================================
--- mono/io-layer/security.c	(revision 138601)
+++ mono/io-layer/security.c	(working copy)
@@ -35,7 +35,7 @@
 gboolean 
 ImpersonateLoggedOnUser (gpointer handle)
 {
-	uid_t token = (uid_t) handle;
+	uid_t token = (uid_t) GPOINTER_TO_INT (handle);
 #ifdef HAVE_SETRESUID
 	if (setresuid (-1, token, getuid ()) < 0)
 		return FALSE;
Index: mono/io-layer/processes.c
===================================================================
--- mono/io-layer/processes.c	(revision 138601)
+++ mono/io-layer/processes.c	(working copy)
@@ -51,7 +51,7 @@
  * arm-apple-darwin9.  We'll manually define the symbol on Apple as it does
  * in fact exist on all implementations (so far) 
  */
-gchar ***_NSGetEnviron();
+gchar ***_NSGetEnviron(void);
 #define environ (*_NSGetEnviron())
 #else
 extern char **environ;
@@ -401,7 +401,7 @@
 static int osx_10_5_or_higher;
 
 static void
-detect_osx_10_5_or_higher ()
+detect_osx_10_5_or_higher (void)
 {
 	struct utsname u;
 	char *p;
@@ -422,7 +422,7 @@
 }
 
 static gboolean
-is_macos_10_5_or_higher ()
+is_macos_10_5_or_higher (void)
 {
 	if (osx_10_5_or_higher == 0)
 		detect_osx_10_5_or_higher ();
@@ -1559,7 +1559,7 @@
 			/* Return a pseudo handle for processes we
 			 * don't have handles for
 			 */
-			return((gpointer)(_WAPI_PROCESS_UNHANDLED + pid));
+			return GINT_TO_POINTER (_WAPI_PROCESS_UNHANDLED + pid);
 		} else {
 #ifdef DEBUG
 			g_message ("%s: Can't find pid %d", __func__, pid);
@@ -1723,8 +1723,9 @@
 
 #ifdef PLATFORM_MACOSX
 #include <mach-o/dyld.h>
+#include <mach-o/getsect.h>
 
-static GSList *load_modules ()
+static GSList *load_modules (void)
 {
 	GSList *ret = NULL;
 	WapiProcModule *mod;
@@ -1743,8 +1744,8 @@
 		sec = getsectbynamefromheader (hdr, SEG_DATA, SECT_DATA);
 
 		mod = g_new0 (WapiProcModule, 1);
-		mod->address_start = sec->addr;
-		mod->address_end = sec->addr+sec->size;
+		mod->address_start = GINT_TO_POINTER (sec->addr);
+		mod->address_end = GINT_TO_POINTER (sec->addr+sec->size);
 		mod->perms = g_strdup ("r--p");
 		mod->address_offset = 0;
 		mod->device = makedev (0, 0);
Index: mono/io-layer/sockets.c
===================================================================
--- mono/io-layer/sockets.c	(revision 138601)
+++ mono/io-layer/sockets.c	(working copy)
@@ -844,7 +844,7 @@
 	/* BSD's and MacOS X multicast sockets also need SO_REUSEPORT when SO_REUSEADDR is requested.  */
 	if (level == SOL_SOCKET && optname == SO_REUSEADDR) {
 		int type;
-		int type_len = sizeof (type);
+		socklen_t type_len = sizeof (type);
 
 		if (!getsockopt (fd, level, SO_TYPE, &type, &type_len)) {
 			if (type == SOCK_DGRAM)
Index: mono/io-layer/wthreads.c
===================================================================
--- mono/io-layer/wthreads.c	(revision 138601)
+++ mono/io-layer/wthreads.c	(working copy)
@@ -1122,7 +1122,7 @@
 		return (0);
 	}
 
-	g_assert (thread_handle->id == GetCurrentThreadId ());
+	g_assert (GPOINTER_TO_INT (thread_handle->id) == GetCurrentThreadId ());
 	/* No locking/memory barriers are needed here */
 	thread_handle->has_apc = TRUE;
 	return(1);
Index: mono/profiler/mono-profiler-aot.c
===================================================================
--- mono/profiler/mono-profiler-aot.c	(revision 138601)
+++ mono/profiler/mono-profiler-aot.c	(working copy)
@@ -124,6 +124,9 @@
 	data->methods = g_list_append (data->methods, method);
 }
 
+void
+mono_profiler_startup (const char *desc);
+
 /* the entry point */
 void
 mono_profiler_startup (const char *desc)
Index: mono/profiler/mono-profiler-logging.c
===================================================================
--- mono/profiler/mono-profiler-logging.c	(revision 138601)
+++ mono/profiler/mono-profiler-logging.c	(working copy)
@@ -16,6 +16,7 @@
 #include <mono/metadata/debug-helpers.h>
 #include <mono/metadata/mono-gc.h>
 #include <mono/io-layer/atomic.h>
+#include <mono/utils/mono-io-portability.h>
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -709,7 +710,7 @@
 #else
 #define FILE_HANDLE_TYPE int
 #define OPEN_FILE() profiler->file = open (profiler->file_name, O_WRONLY|O_CREAT|O_TRUNC, 0664);
-#define WRITE_BUFFER(b,s) write (profiler->file, (b), (s))
+#define WRITE_BUFFER(b,s) TEMP_FAILURE_RETRY (write (profiler->file, (b), (s)))
 #define FLUSH_FILE()
 #define CLOSE_FILE() close (profiler->file);
 #endif
Index: mono/profiler/mono-cov.c
===================================================================
--- mono/profiler/mono-cov.c	(revision 138601)
+++ mono/profiler/mono-cov.c	(working copy)
@@ -124,6 +124,9 @@
 {
 }
 
+void
+mono_profiler_startup (const char *desc);
+
 /* the entry point */
 void
 mono_profiler_startup (const char *desc)
Index: mono/monograph/monograph.c
===================================================================
--- mono/monograph/monograph.c	(revision 138601)
+++ mono/monograph/monograph.c	(working copy)
@@ -934,9 +934,9 @@
 		next = tmp->data;
 		if (!next->dfn) {
 			if (!bb->cil_code)
-				fprintf (output, "\t\"DF entry\" -> \"IL_%04x (%d)\"\n", next->cil_code - code, *dfn + 1);
+				fprintf (output, "\t\"DF entry\" -> \"IL_%04x (%d)\"\n", (unsigned int)(next->cil_code - code), *dfn + 1);
 			else
-				fprintf (output, "\t\"IL_%04x (%d)\" -> \"IL_%04x (%d)\"\n", bb->cil_code - code, bb->dfn, next->cil_code - code, *dfn + 1);
+				fprintf (output, "\t\"IL_%04x (%d)\" -> \"IL_%04x (%d)\"\n", (unsigned int)(bb->cil_code - code), bb->dfn, (unsigned int)(next->cil_code - code), *dfn + 1);
 			df_visit (next, dfn, code);
 		}
 	}
@@ -963,7 +963,7 @@
 			fprintf (output, "\tB%p [shape=record,label=\"end\"]\n", bb);
 		else {
 			code = mono_disasm_code (&graph_dh, method, bb->cil_code, bb->cil_code + bb->cil_length);
-			fprintf (output, "\tB%p [shape=record,label=\"IL_%04x\\n%s\"]\n", bb, bb->cil_code - il_code, code);
+			fprintf (output, "\tB%p [shape=record,label=\"IL_%04x\\n%s\"]\n", bb, (unsigned int)(bb->cil_code - il_code), code);
 			g_free (code);
 		}
 	}
Index: mono/mini/method-to-ir.c
===================================================================
--- mono/mini/method-to-ir.c	(revision 138601)
+++ mono/mini/method-to-ir.c	(working copy)
@@ -2380,7 +2380,7 @@
 mono_emit_rgctx_method_call_full (MonoCompile *cfg, MonoMethod *method, MonoMethodSignature *sig,
 		MonoInst **args, MonoInst *this, MonoInst *imt_arg, MonoInst *vtable_arg)
 {
-	int rgctx_reg;
+	int rgctx_reg = 0;
 	MonoInst *ins;
 	MonoCallInst *call;
 
@@ -10271,7 +10271,7 @@
 		cfg->cbb = bb;
 		for (; ins; ins = ins->next) {
 			const char *spec = INS_INFO (ins->opcode);
-			int regtype, regindex;
+			int regtype = 0, regindex;
 			gint32 prev_bb;
 
 			if (G_UNLIKELY (cfg->verbose_level > 2))
@@ -10280,7 +10280,7 @@
 			g_assert (ins->opcode >= MONO_CEE_LAST);
 
 			for (regindex = 0; regindex < 4; regindex ++) {
-				int vreg;
+				int vreg = 0;
 
 				if (regindex == 0) {
 					regtype = spec [MONO_INST_DEST];
Index: mono/mini/mini-exceptions.c
===================================================================
--- mono/mini/mini-exceptions.c	(revision 138601)
+++ mono/mini/mini-exceptions.c	(working copy)
@@ -44,6 +44,7 @@
 #include <mono/metadata/mono-debug.h>
 #include <mono/metadata/profiler.h>
 #include <mono/utils/mono-mmap.h>
+#include <mono/utils/mono-io-portability.h>
 
 #include "mini.h"
 #include "debug-mini.h"
@@ -1561,7 +1562,7 @@
 
 			if (nread <= 0)
 				break;
-			write (STDERR_FILENO, buffer, nread);
+			TEMP_FAILURE_RETRY (write (STDERR_FILENO, buffer, nread));
 		}		
 
 		waitpid (pid, &status, WNOHANG);
@@ -1643,7 +1644,7 @@
 	printf ("\t<Stack traces in thread dumps not supported on this platform>\n");
 #endif
 
-	fprintf (stdout, text->str);
+	fprintf (stdout, "%s", text->str);
 	g_string_free (text, TRUE);
 	fflush (stdout);
 }
Index: mono/mini/graph.c
===================================================================
--- mono/mini/graph.c	(revision 138601)
+++ mono/mini/graph.c	(working copy)
@@ -309,6 +309,7 @@
 	char *com;
 	const char *fn;
 	FILE *fp;
+	int res;
 
 	fn = "/tmp/minidtree.graph";
 	fp = fopen (fn, "w+");
@@ -332,7 +333,7 @@
 
 	//com = g_strdup_printf ("dot %s -Tpng -o %s.png; eog %s.png", fn, fn, fn);
 	com = g_strdup_printf ("dot %s -Tps -o %s.ps;gv %s.ps", fn, fn, fn);
-	system (com);
+	res = system (com);
 	g_free (com);
 }
 
Index: mono/mini/helpers.c
===================================================================
--- mono/mini/helpers.c	(revision 138601)
+++ mono/mini/helpers.c	(working copy)
@@ -112,7 +112,7 @@
 {
 #ifndef DISABLE_LOGGING
 	GHashTable *offset_to_bb_hash = NULL;
-	int i, cindex, bb_num;
+	int i, cindex, bb_num, res;
 	FILE *ofd;
 #ifdef PLATFORM_WIN32
 	const char *tmp = g_get_tmp_dir ();
@@ -219,7 +219,7 @@
 #endif
 
 	cmd = g_strdup_printf (ARCH_PREFIX AS_CMD " %s -o %s", as_file, o_file);
-	system (cmd); 
+	res = system (cmd); 
 	g_free (cmd);
 	if (!objdump_args)
 		objdump_args = "";
@@ -230,12 +230,12 @@
 	 * everything as data.
 	 */
 	cmd = g_strdup_printf (ARCH_PREFIX "strip -x %s", o_file);
-	system (cmd);
+	res = system (cmd);
 	g_free (cmd);
 #endif
 	
 	cmd = g_strdup_printf (ARCH_PREFIX DIS_CMD " %s %s", objdump_args, o_file);
-	system (cmd);
+	res = system (cmd);
 	g_free (cmd);
 	
 #ifndef PLATFORM_WIN32
Index: mono/mini/aot-compiler.c
===================================================================
--- mono/mini/aot-compiler.c	(revision 138601)
+++ mono/mini/aot-compiler.c	(working copy)
@@ -4609,7 +4609,7 @@
 	char symbol [256];
 
 	/* Don't make GOT global so accesses to it don't need relocations */
-	sprintf (symbol, acfg->got_symbol);
+	sprintf (symbol, "%s", acfg->got_symbol);
 	emit_section_change (acfg, ".bss", 0);
 	emit_alignment (acfg, 8);
 	emit_local_symbol (acfg, symbol, "got_end", FALSE);
Index: mono/utils/mono-io-portability.h
===================================================================
--- mono/utils/mono-io-portability.h	(revision 138601)
+++ mono/utils/mono-io-portability.h	(working copy)
@@ -1,6 +1,7 @@
 #ifndef __MONO_IO_PORTABILITY_H
 #define __MONO_IO_PORTABILITY_H
 
+#include <errno.h>
 #include <glib.h>
 #include <mono/utils/mono-compiler.h>
 
@@ -22,4 +23,12 @@
 #define IS_PORTABILITY_CASE (__mono_io_portability_helpers & PORTABILITY_CASE)
 #define IS_PORTABILITY_SET (__mono_io_portability_helpers > 0)
 
+#ifndef TEMP_FAILURE_RETRY
+#define TEMP_FAILURE_RETRY(expr) G_STMT_START {		\
+	size_t _tmp_res;				\
+	do _tmp_res = (size_t) (expr);			\
+	while (_tmp_res == -1L && errno == EINTR);	\
+} G_STMT_END
 #endif
+
+#endif
Index: mono/utils/dlmalloc.c
===================================================================
--- mono/utils/dlmalloc.c	(revision 138601)
+++ mono/utils/dlmalloc.c	(working copy)
@@ -2504,6 +2504,8 @@
   return 0;
 }
 
+#if 0
+
 /* support for mallopt */
 static int change_mparam(int param_number, int value) {
   size_t val = (size_t)value;
@@ -2527,6 +2529,8 @@
   }
 }
 
+#endif /* 0 */
+
 #if DEBUG
 /* ------------------------- Debugging Support --------------------------- */
 
@@ -2837,6 +2841,8 @@
 }
 #endif /* !NO_MALLINFO */
 
+#if 0
+
 static void internal_malloc_stats(mstate m) {
   if (!PREACTION(m)) {
     size_t maxfp = 0;
@@ -2869,6 +2875,8 @@
   }
 }
 
+#endif /* 0 */
+
 /* ----------------------- Operations on smallbins ----------------------- */
 
 /*
Index: mono/utils/mono-proclib.c
===================================================================
--- mono/utils/mono-proclib.c	(revision 138601)
+++ mono/utils/mono-proclib.c	(working copy)
@@ -157,7 +157,6 @@
 #if USE_SYSCTL
 	int mib [4];
 	int res;
-	char *p;
 	size_t data_len = sizeof (struct kinfo_proc);
 	struct kinfo_proc processi;
 
Index: mono/utils/mono-counters.c
===================================================================
--- mono/utils/mono-counters.c	(revision 138601)
+++ mono/utils/mono-counters.c	(working copy)
@@ -105,14 +105,14 @@
 		      int64val = ((LongFunc)counter->addr) ();
 	      else
 		      int64val = *(gint64*)counter->addr;
-	      fprintf (outfile, ENTRY_FMT "%lld\n", counter->name, int64val);
+	      fprintf (outfile, ENTRY_FMT "%lld\n", counter->name, (long long)int64val);
 	      break;
 	case MONO_COUNTER_ULONG:
 	      if (counter->type & MONO_COUNTER_CALLBACK)
 		      uint64val = ((ULongFunc)counter->addr) ();
 	      else
 		      uint64val = *(guint64*)counter->addr;
-	      fprintf (outfile, ENTRY_FMT "%llu\n", counter->name, uint64val);
+	      fprintf (outfile, ENTRY_FMT "%llu\n", counter->name, (unsigned long long)uint64val);
 	      break;
 	case MONO_COUNTER_WORD:
 	      if (counter->type & MONO_COUNTER_CALLBACK)
@@ -122,7 +122,7 @@
 #if SIZEOF_VOID_P == 8
 	      fprintf (outfile, ENTRY_FMT "%lld\n", counter->name, (gint64)wordval);
 #else
-	      fprintf (outfile, ENTRY_FMT "%d\n", counter->name, wordval);
+	      fprintf (outfile, ENTRY_FMT "%d\n", counter->name, (gint)wordval);
 #endif
 	      break;
 	case MONO_COUNTER_DOUBLE:
Index: mono/utils/strtod.c
===================================================================
--- mono/utils/strtod.c	(revision 138601)
+++ mono/utils/strtod.c	(working copy)
@@ -1561,7 +1561,7 @@
 	double aadj, aadj1, adj, rv, rv0;
 	Long L;
 	ULong y, z;
-	Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
+	Bigint *bb = NULL, *bb1, *bd = NULL, *bd0, *bs = NULL, *delta = NULL;
 #ifdef SET_INEXACT
 	int inexact, oldinexact;
 #endif
@@ -2434,6 +2434,8 @@
 	return sign ? -dval(rv) : dval(rv);
 	}
 
+#if 0
+
  static int
 quorem
 #ifdef KR_headers
@@ -2579,6 +2581,10 @@
 		(char *)(r+1);
 	}
 
+#endif /* 0 */
+
+#if 0
+
  static char *
 #ifdef KR_headers
 nrv_alloc(s, rve, n) char *s, **rve; int n;
@@ -2595,6 +2601,10 @@
 	return rv;
 	}
 
+#endif /* 0 */
+
+#if 0
+
 /* freedtoa(s) must be used to free values s returned by dtoa
  * when MULTIPLE_THREADS is #defined.  It should be used in all cases,
  * but for consistency with earlier versions of dtoa, it is optional
@@ -2619,6 +2629,8 @@
 #endif
 	}
 
+#endif /* 0 */
+
 #if 0
 /* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.
  *
