Index: System/MonoType.cs
===================================================================
--- System/MonoType.cs	(revision 41357)
+++ System/MonoType.cs	(working copy)
@@ -8,12 +8,8 @@
 //	Gonzalo Paniagua (gonzalo@ximian.com)
 //
 // (c) 2001-2003 Ximian, Inc.
-// (c) 2003,2004 Novell, Inc. (http://www.novell.com)
+// Copyright (C) 2003-2005 Novell, Inc (http://www.novell.com)
 //
-
-//
-// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
-//
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
 // "Software"), to deal in the Software without restriction, including
@@ -34,10 +30,12 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 
+using System.Globalization;
 using System.Reflection;
 using System.Runtime.CompilerServices;
-using System.Globalization;
 using System.Runtime.Serialization;
+using System.Security;
+using System.Security.Permissions;
 
 namespace System
 {
@@ -90,7 +88,7 @@
 			if (types == null) {
 				if (count > 1)
 					throw new AmbiguousMatchException ();
-				return found;
+				return (ConstructorInfo) CheckMethodSecurity (found);
 			}
 			match = new MethodBase [count];
 			if (count == 1)
@@ -105,7 +103,7 @@
 			}
 			if (binder == null)
 				binder = Binder.DefaultBinder;
-			return (ConstructorInfo)binder.SelectMethod (bindingAttr, match, types, modifiers);
+			return (ConstructorInfo) CheckMethodSecurity (binder.SelectMethod (bindingAttr, match, types, modifiers));
 		}
 
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]
@@ -203,7 +201,7 @@
 				return null;
 			
 			if (count == 1 && typesLen == 0) 
-				return found;
+				return (MethodInfo) CheckMethodSecurity (found);
 
 			match = new MethodBase [count];
 			if (count == 1)
@@ -218,12 +216,12 @@
 			}
 			
 			if (types == null) 
-				return (MethodInfo) Binder.FindMostDerivedMatch (match);
+				return (MethodInfo) CheckMethodSecurity (Binder.FindMostDerivedMatch (match));
 
 			if (binder == null)
 				binder = Binder.DefaultBinder;
 			
-			return (MethodInfo)binder.SelectMethod (bindingAttr, match, types, modifiers);
+			return (MethodInfo) CheckMethodSecurity (binder.SelectMethod (bindingAttr, match, types, modifiers));
 		}
 
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]
@@ -579,5 +577,22 @@
 			get;
 		}
 #endif
+
+		[MethodImplAttribute(MethodImplOptions.InternalCall)]
+		internal static extern bool InternalReflectedLinkDemand (MethodBase mb);
+
+		private MethodBase CheckMethodSecurity (MethodBase mb)
+		{
+			if (!SecurityManager.SecurityEnabled || (mb == null))
+				return mb;
+
+			// Sadly we have no way to know which kind of security this is
+			// so we must do it the hard way. Actually this isn't so bad 
+			// because we can skip the (mb.Attributes & MethodAttributes.HasSecurity)
+			// icall required (and do it ourselves)
+
+			// this (unlike the Invoke step) is _and stays_ a LinkDemand (caller)
+			return InternalReflectedLinkDemand (mb) ? null : mb;
+		}
 	}
 }
Index: System.Reflection/MonoMethod.cs
===================================================================
--- System.Reflection/MonoMethod.cs	(revision 41374)
+++ System.Reflection/MonoMethod.cs	(working copy)
@@ -6,11 +6,8 @@
 //   Paolo Molaro (lupus@ximian.com)
 //
 // (C) 2001 Ximian, Inc.  http://www.ximian.com
+// Copyright (C) 2004-2005 Novell, Inc (http://www.novell.com)
 //
-
-//
-// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
-//
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
 // "Software"), to deal in the Software without restriction, including
@@ -31,11 +28,12 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 
-using System;
 using System.Globalization;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Runtime.Serialization;
+using System.Security;
+using System.Security.Permissions;
 
 namespace System.Reflection {
 	
@@ -110,12 +108,24 @@
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]
 		internal extern Object InternalInvoke (Object obj, Object[] parameters);
 		
-		public override Object Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) {
+		[MethodImplAttribute(MethodImplOptions.InternalCall)]
+		internal extern void InternalReflectedLinkDemand ();
+ 
+		public override Object Invoke (Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) 
+		{
 			if (binder == null)
 				binder = Binder.DefaultBinder;
 			ParameterInfo[] pinfo = GetParameters ();
 			if (!Binder.ConvertArgs (binder, parameters, pinfo, culture))
 				throw new ArgumentException ("parameters");
+
+			if (SecurityManager.SecurityEnabled) {
+				// sadly Attributes doesn't tell us which kind of security this is so
+				// we must do it the hard way - and it also means that we can skip calling
+				// Attribute (which is another an icall)
+				InternalReflectedLinkDemand ();
+			}
+
 			try {
 				return InternalInvoke (obj, parameters);
 			} catch (InvalidOperationException) {
@@ -309,13 +319,25 @@
 		 */
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]
 		internal extern Object InternalInvoke (Object obj, Object[] parameters);
+
+		[MethodImplAttribute(MethodImplOptions.InternalCall)]
+		internal extern void InternalReflectedLinkDemand ();
 		
-		public override Object Invoke (Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) {
+		public override Object Invoke (Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) 
+		{
 			if (binder == null)
 				binder = Binder.DefaultBinder;
 			ParameterInfo[] pinfo = GetParameters ();
 			if (!Binder.ConvertArgs (binder, parameters, pinfo, culture))
 				throw new ArgumentException ("parameters");
+
+			if (SecurityManager.SecurityEnabled) {
+				// sadly Attributes doesn't tell us which kind of security this is so
+				// we must do it the hard way - and it also means that we can skip calling
+				// Attribute (which is another an icall)
+				InternalReflectedLinkDemand ();
+			}
+
 			try {
 				return InternalInvoke (obj, parameters);
 			} catch (InvalidOperationException) {
