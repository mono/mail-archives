Index: Mono.Cairo/Pattern.cs
===================================================================
--- Mono.Cairo/Pattern.cs	(revision 49641)
+++ Mono.Cairo/Pattern.cs	(working copy)
@@ -38,7 +38,6 @@
 	        public LinearGradient (double x0, double y0, double x1, double y1) : base()
                 {
                         pattern = CairoAPI.cairo_pattern_create_linear (x0, y0, x1, y1);
-			Reference ();
                 }		
 	}
    
@@ -49,7 +48,6 @@
                 {
                         pattern = CairoAPI.cairo_pattern_create_radial (cx0, cy0, radius0,
 								    cx1, cy1, radius1);
-			Reference ();
                 }
 	}
 
@@ -77,7 +75,6 @@
 					pattern = CairoAPI.cairo_pattern_create_rgb (color.R, color.G, color.B);
 				else
 					pattern = CairoAPI.cairo_pattern_create_rgba (color.R, color.G, color.B, color.A);
-				Reference ();
 			}
 		}
 
@@ -86,7 +83,6 @@
 			public SurfacePattern (Surface surface)
 			{
 				pattern = CairoAPI.cairo_pattern_create_for_surface (surface.Pointer);
-				Reference ();
 			}
 
 			public Extend Extend {
Index: Mono.Cairo/Graphics.cs
===================================================================
--- Mono.Cairo/Graphics.cs	(revision 49641)
+++ Mono.Cairo/Graphics.cs	(working copy)
@@ -99,7 +99,6 @@
         public class Graphics : IDisposable 
         {
                 internal IntPtr state = IntPtr.Zero;
-		//private Surface surface;
 		
                 public Graphics (Surface surface)
                 {
@@ -281,7 +280,6 @@
                 public Cairo.Surface Target {
                         set {
 				state = CairoAPI.cairo_create (value.Pointer);				
-                                //CairoAPI.cairo_set_target_surface (state, value.Handle);
                         }
 
                         get {
@@ -342,39 +340,44 @@
                         CairoAPI.cairo_curve_to (state, x1, y1, x2, y2, x3, y3);
                 }
 
-                public void RelMoveTo (PointD p)
+                public void RelMoveTo (Distance d)
 				{
-						RelMoveTo (p.X, p.Y);
+						RelMoveTo (d.Dx, d.Dy);
 				}
 				
-                public void RelMoveTo (double x, double y)
+                public void RelMoveTo (double dx, double dy)
                 {
-                        CairoAPI.cairo_rel_move_to (state, x, y);
+                        CairoAPI.cairo_rel_move_to (state, dx, dy);
                 }
 
-                public void RelLineTo (PointD p)
+                public void RelLineTo (Distance d)
                 {
-						RelLineTo (p.X, p.Y);
+						RelLineTo (d.Dx, d.Dy);
                 }
 
-                public void RelLineTo (double x, double y)
+                public void RelLineTo (double dx, double dy)
 				{
-                        CairoAPI.cairo_rel_line_to (state, x, y);
+                        CairoAPI.cairo_rel_line_to (state, dx, dy);
 				}
 
+                public void RelCurveTo (Distance d1, Distance d2, Distance d3)
+		{
+			RelCurveTo (d1.Dx, d1.Dy, d2.Dx, d2.Dy, d3.Dx, d3.Dy);
+		}
+
                 public void RelCurveTo (double dx1, double dy1, double dx2, double dy2, double dx3, double dy3)
                 {
                         CairoAPI.cairo_rel_curve_to (state, dx1, dy1, dx2, dy2, dx3, dy3); 
                 }
 
-                public void Arc (double xc, double yc, double radius, double angel1, double angel2)
+                public void Arc (double xc, double yc, double radius, double angle1, double angle2)
                 {
-                        CairoAPI.cairo_arc (state, xc, yc, radius, angel1, angel2);
+                        CairoAPI.cairo_arc (state, xc, yc, radius, angle1, angle2);
                 }
 
-                public void ArcNegative (double xc, double yc, double radius, double angel1, double angel2)
+                public void ArcNegative (double xc, double yc, double radius, double angle1, double angle2)
                 {
-                        CairoAPI.cairo_arc_negative (state, xc, yc, radius, angel1, angel2);
+                        CairoAPI.cairo_arc_negative (state, xc, yc, radius, angle1, angle2);
                 }
 		
                 public void Rectangle (PointD p, double width, double height)
@@ -471,21 +474,6 @@
 			return CairoAPI.cairo_in_fill (state, x, y);
 		}
 
-
-#region Modified state
-
-                public void SetTargetImage (
-                        string data, Cairo.Format format, int width, int height, int stride)
-                {
-                        CairoAPI.cairo_image_surface_create_for_data (data, format, width, height, stride);
-                }
-
-		public void SetTargetDrawable (IntPtr dpy, IntPtr drawable, IntPtr visual, int width, int height)
-		{
-			CairoAPI.cairo_xlib_surface_create (dpy, drawable, visual, width, height);
-		}		
-#endregion
-
                 public void Rotate (double angle)
                 {
                         CairoAPI.cairo_rotate (state, angle);
Index: Mono.Cairo/Surface.cs
===================================================================
--- Mono.Cairo/Surface.cs	(revision 49641)
+++ Mono.Cairo/Surface.cs	(working copy)
@@ -46,8 +46,6 @@
 			lock (surfaces.SyncRoot){
 				surfaces [surface] = this;
 			}
-			
-			CairoAPI.cairo_surface_reference (surface);
 		}
 		
 		public int Width {
@@ -66,8 +64,9 @@
 		public PdfSurface (string filename, double width, double height)
 		{
 			surface = CairoAPI.cairo_pdf_surface_create (filename, width, height);
-
-			CairoAPI.cairo_surface_reference (surface);
+			lock (surfaces.SyncRoot){
+				surfaces [surface] = this;
+			}
 		}
 
 		public void SetDPI (double x_dpi, double y_dpi)
@@ -81,8 +80,9 @@
 		public PostscriptSurface (string filename, double width, double height)
 		{
 			surface = CairoAPI.cairo_ps_surface_create (filename, width, height);
-
-			CairoAPI.cairo_surface_reference (surface);
+			lock (surfaces.SyncRoot){
+				surfaces [surface] = this;
+			}
 		}
 
 		public void SetDPI (double x_dpi, double y_dpi)
@@ -97,8 +97,9 @@
 		public Win32Surface (IntPtr hdc)
 		{
 			surface = CairoAPI.cairo_win32_surface_create (hdc);
-
-			CairoAPI.cairo_surface_reference (surface);
+			lock (surfaces.SyncRoot){
+				surfaces [surface] = this;
+			}
 		}
 	}
 
@@ -107,16 +108,18 @@
 		public XlibSurface (IntPtr display, IntPtr drawable, IntPtr visual, int width, int height)
 		{
 			surface = CairoAPI.cairo_xlib_surface_create (display, drawable, visual, width, height);
-
-			CairoAPI.cairo_surface_reference (surface);
+			lock (surfaces.SyncRoot){
+				surfaces [surface] = this;
+			}
 		}
 
 		/* FIXME: has the same parameters as above
 		public XlibSurface (IntPtr display, IntPtr bitmap, IntPtr screen, int width, int height)
 		{
 			surface = CairoAPI.cairo_xlib_surface_create_for_bitmap (display, bitmap, screen, width, height);
-
-			CairoAPI.cairo_surface_reference (surface);
+			lock (surfaces.SyncRoot){
+				surfaces [surface] = this;
+			}
 		}
 		*/
 
Index: Samples/png/fillstroke.cs
===================================================================
--- Samples/png/fillstroke.cs	(revision 49641)
+++ Samples/png/fillstroke.cs	(working copy)
@@ -40,7 +40,7 @@
 		
 		gr.MoveTo ( new PointD (0.5, 0.1) );
 		gr.LineTo ( new PointD (0.9, 0.9) );
-		gr.RelLineTo ( new PointD (-0.4, 0.0) );
+		gr.RelLineTo ( new Distance (-0.4, 0.0) );
 		gr.CurveTo ( new PointD (0.2, 0.9),
 			     new PointD ( 0.2, 0.5),
 			     new PointD (0.5, 0.5)
@@ -48,9 +48,9 @@
 		gr.ClosePath ();
 		
 		gr.MoveTo ( new PointD (0.25, 0.1) );
-		gr.RelLineTo ( new PointD (0.2, 0.2) );
-		gr.RelLineTo ( new PointD ( -0.2, 0.2) );
-		gr.RelLineTo ( new PointD (-0.2, -0.2) );
+		gr.RelLineTo ( new Distance (0.2, 0.2) );
+		gr.RelLineTo ( new Distance ( -0.2, 0.2) );
+		gr.RelLineTo ( new Distance (-0.2, -0.2) );
 		gr.ClosePath ();	       
 		
 		gr.Color = new Color (0, 0, 1, 1);
Index: Samples/gtk/fillstroke.cs
===================================================================
--- Samples/gtk/fillstroke.cs	(revision 49641)
+++ Samples/gtk/fillstroke.cs	(working copy)
@@ -66,7 +66,7 @@
 		
 		gr.MoveTo ( new PointD (0.5, 0.1) );
 		gr.LineTo ( new PointD (0.9, 0.9) );
-		gr.RelLineTo ( new PointD (-0.4, 0.0) );
+		gr.RelLineTo ( new Distance (-0.4, 0.0) );
 		gr.CurveTo ( new PointD (0.2, 0.9),
 			     new PointD ( 0.2, 0.5),
 			     new PointD (0.5, 0.5)
@@ -74,9 +74,9 @@
 		gr.ClosePath ();
 		
 		gr.MoveTo ( new PointD (0.25, 0.1) );
-		gr.RelLineTo ( new PointD (0.2, 0.2) );
-		gr.RelLineTo ( new PointD ( -0.2, 0.2) );
-		gr.RelLineTo ( new PointD (-0.2, -0.2) );
+		gr.RelLineTo ( new Distance (0.2, 0.2) );
+		gr.RelLineTo ( new Distance ( -0.2, 0.2) );
+		gr.RelLineTo ( new Distance (-0.2, -0.2) );
 		gr.ClosePath ();	       
 		
 		gr.Color = new Color (0, 0, 1, 1);
Index: Samples/x11/fillstroke.cs
===================================================================
--- Samples/x11/fillstroke.cs	(revision 49641)
+++ Samples/x11/fillstroke.cs	(working copy)
@@ -41,7 +41,7 @@
 		
 		gr.MoveTo ( new PointD (0.5, 0.1) );
 		gr.LineTo ( new PointD (0.9, 0.9) );
-		gr.RelLineTo ( new PointD (-0.4, 0.0) );
+		gr.RelLineTo ( new Distance (-0.4, 0.0) );
 		gr.CurveTo ( new PointD (0.2, 0.9),
 					     new PointD ( 0.2, 0.5),
 					     new PointD (0.5, 0.5)
@@ -49,9 +49,9 @@
 		gr.ClosePath ();
 		
 		gr.MoveTo ( new PointD (0.25, 0.1) );
-		gr.RelLineTo ( new PointD (0.2, 0.2) );
-		gr.RelLineTo ( new PointD ( -0.2, 0.2) );
-		gr.RelLineTo ( new PointD (-0.2, -0.2) );
+		gr.RelLineTo ( new Distance (0.2, 0.2) );
+		gr.RelLineTo ( new Distance ( -0.2, 0.2) );
+		gr.RelLineTo ( new Distance (-0.2, -0.2) );
 		gr.ClosePath ();
 		
 		gr.Color = new Color (0, 0, 1, 1);
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 49641)
+++ ChangeLog	(working copy)
@@ -1,3 +1,16 @@
+2005-09-07  John Luke  <john.luke@gmail.com>
+
+	* Mono.Cairo/Graphics.cs: the Relative path methods
+	should use a Distance not a PointD, and update some
+	parameter names for better documentation purposes
+	remove SetTargetImage (), and SetTargetDrawable ()
+	use Graphics.Target = Surface instead
+	* Mono.Cairo/Surface.cs: don't reference the surface after
+	we create it as it is not necessary
+	add the new surfaces to the surfaces hashtable on instantiation 
+	* Mono.Cairo/Pattern.cs: don't reference the pattern after
+	we create it as it is not necessary
+	
 2005-09-07 Hisham Mardam Bey <hisham.mardambey@gmail.com>
 
 	* Samples/png: Fixed samples with new changes.
