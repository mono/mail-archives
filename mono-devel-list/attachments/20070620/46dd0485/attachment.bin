// This program demonstrates a bug in the Mono Odbc stack: OdbcDataReader.
// When reading bytes from a Varchar (possibly NVarchar), binary zeros from the fragments are 
// not stripped. Using GetBytes, the correct result is returned.

using System;
using DBC.ORM;
using DBC.Data;
using System.Data;
using System.Data.Odbc;

class ZeroBug {
  private static void FindZero( string ged ) {
    Console.WriteLine( "Looking for binary zero in string '{0}'", ged );
    for ( int i = 0; i < ged.Length; ++i ) {
      if ( ged[i] == 0 ) {
	Console.WriteLine( "Found binary zero at pos {0}", i );
      }
    }
  }

  public static void Main() {
    
    // Connect to the database - you need to adjust this to your db/odbc settings
    OdbcConnection dbcon   = new OdbcConnection();
    dbcon.ConnectionString = "DSN=madstest;UID=mmw;PWD=mmw";
    dbcon.Open();
    
    // Drop the table foo, if it exists
    OdbcCommand dbcmd = new OdbcCommand();
    dbcmd.Connection = dbcon;
    dbcmd.CommandType = CommandType.Text;
    dbcmd.CommandText = "Drop table foo";
    try {
      dbcmd.ExecuteNonQuery();
    }
    catch ( System.Data.Odbc.OdbcException e ) {
      Console.WriteLine( "Got an exception - assuming foo table did not exist, ignoring: " 
			 + e.Message );
    }

    // Create table
    dbcmd.CommandText = "Create table foo ( bar long varchar )";
    dbcmd.ExecuteNonQuery();

    // Insert a record into foo
    dbcmd.CommandText = "Insert into foo (bar) values ( '"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "This string has more than 255 characters"
      + "' )";
    dbcmd.ExecuteNonQuery();
    
    // Now, get the record back - try and read it two different ways.
    dbcmd.CommandText = "SELECT bar FROM foo" ;
  
    OdbcDataReader reader;

    // Read it as a string    
    reader = (OdbcDataReader) dbcmd.ExecuteReader();
    string readAsString = "";
    while( reader.Read() ) {
      // Console.WriteLine( "Type of read data is {0}", reader[0].GetType().ToString() );
      readAsString = reader[0].ToString();
    }
    reader.Close();
    // Look for a binary zero - this will find a binary zero on pos 254 (BUG)
    Console.WriteLine( "readAsString: " );
    FindZero( readAsString );
      
    // Now, read it using GetBytes
    reader = (OdbcDataReader) dbcmd.ExecuteReader();
    byte[] buffer = new byte[2048];
    long total = 0;
    while( reader.Read() ) {
      // Console.WriteLine( "Type of read data is {0}", reader[0].GetType().ToString() );
      total = reader.GetBytes( 0, 0, buffer, 0, 2048 );
    }
    reader.Close();
    // Convert bytes read to string - look for binary zero - there is none (OK)
    string readAsBytes = System.Text.Encoding.Default.GetString( buffer, 0, (int) total );
    Console.WriteLine( "readAsBytes: " );
    FindZero( readAsBytes );
  }
}
