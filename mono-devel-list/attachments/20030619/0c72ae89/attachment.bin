Index: ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.IO/ChangeLog,v
retrieving revision 1.181
diff -u -r1.181 ChangeLog
--- ChangeLog	18 Jun 2003 15:04:28 -0000	1.181
+++ ChangeLog	19 Jun 2003 23:26:16 -0000
@@ -1,3 +1,11 @@
+2003-06-19  Ben Maurer <bmaurer@users.sourceforge.net>
+	* FileStream.cs: By default buf is not allocated. Only when the
+	buffer is first used is it allocated. Also, if the Read method is
+	called with a buffer that is larger than buf_size, the buffer
+	passed to the method is the only one used. As a result, it is
+	possible to read multiple files while allocating only one buffer
+	by creating that buffer in the code that calls FileStream.
+
 2003-06-18  Nick Drochak <ndrochak@gol.com>
 
 	* FileSystemInfo.cs: Refresh cache when changeing file times.
Index: FileStream.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.IO/FileStream.cs,v
retrieving revision 1.40
diff -u -r1.40 FileStream.cs
--- FileStream.cs	12 Jun 2003 08:35:22 -0000	1.40
+++ FileStream.cs	19 Jun 2003 23:26:16 -0000
@@ -50,7 +50,11 @@
 				this.canseek = false;
 			}
 			
-			InitBuffer (bufferSize);
+			if (bufferSize < 0)
+				throw new ArgumentOutOfRangeException ("Buffer size cannot be negative.");
+			if (bufferSize < 8)
+				bufferSize = 8;
+			buf_size = bufferSize;
 
 			/* Can't set append mode */
 			this.append_startpos=0;
@@ -96,8 +100,12 @@
 			if (Directory.Exists (name)) {
 				throw new UnauthorizedAccessException ("Access to the path '" + Path.GetFullPath (name) + "' is denied.");
 			}
-
-			InitBuffer (bufferSize);
+			
+			if (bufferSize < 0)
+				throw new ArgumentOutOfRangeException ("Buffer size cannot be negative.");
+			if (bufferSize < 8)
+				bufferSize = 8;
+			buf_size = bufferSize;
 
 			/* Append streams can't be read (see FileMode
 			 * docs)
@@ -244,6 +252,8 @@
 					if (buf_length == 0) {
 						return -1;
 					}
+				} else if (buf == null) {
+					buf = new byte [buf_size];
 				}
 				
 				return(buf [buf_offset ++]);
@@ -261,6 +271,9 @@
 			lock(this) {
 				if (buf_offset == buf_size) {
 					FlushBuffer ();
+				} 
+				if (buf == null) {
+					buf = new byte [buf_size];
 				}
 
 				buf [buf_offset ++] = value;
@@ -292,6 +305,20 @@
 			int copied = 0;
 
 			lock(this) {
+				
+				if (buf_length == 0 && count > buf_size) {
+					
+					copied = ReadData (handle, dest,
+						      dest_offset,
+						      count);
+				
+					/* Make the next buffer read
+					 * start from the right place
+					 */
+					buf_start = copied;
+					return copied;
+				}
+				
 				int n = ReadSegment (dest, dest_offset, count);
 				copied += n;
 				count -= n;
@@ -530,7 +557,10 @@
 				count = buf_length - buf_offset;
 			}
 			
+			if (buf == null) return 0;
+				
 			if (count > 0) {
+				
 				Buffer.BlockCopy (buf, buf_offset,
 						  dest, dest_offset,
 						  count);
@@ -548,6 +578,7 @@
 			}
 			
 			if (count > 0) {
+				if (buf == null) buf = new byte [buf_size];
 				Buffer.BlockCopy (src, src_offset,
 						  buf, buf_offset,
 						  count);
@@ -590,6 +621,7 @@
 		private void RefillBuffer ()
 		{
 			FlushBuffer();
+			if (buf == null) buf = new byte [buf_size];
 			
 			buf_length = ReadData (handle, buf, 0,
 					       buf_size);
@@ -614,21 +646,6 @@
 			}
 			
 			return(amount);
-		}
-		
-		
-		private void InitBuffer (int size)
-		{
-			if (size < 0)
-				throw new ArgumentOutOfRangeException ("Buffer size cannot be negative.");
-			if (size < 8)
-				size = 8;
-		
-			buf = new byte [size];
-			buf_size = size;
-			buf_start = 0;
-			buf_offset = buf_length = 0;
-			buf_dirty = false;
 		}
 
 		// fields
@@ -642,12 +659,12 @@
 		private long append_startpos;
 		
 
-		private byte [] buf;			// the buffer
+		private byte [] buf = null;		// the buffer
 		private int buf_size;			// capacity in bytes
-		private int buf_length;			// number of valid bytes in buffer
-		private int buf_offset;			// position of next byte
-		private bool buf_dirty;			// true if buffer has been written to
-		private long buf_start;			// location of buffer in file
+		private int buf_length = 0;		// number of valid bytes in buffer
+		private int buf_offset = 0;		// position of next byte
+		private bool buf_dirty = false;		// true if buffer has been written to
+		private long buf_start = 0;		// location of buffer in file
 		private string name = "[Unknown]";	// name of file.
 
 		IntPtr handle;				// handle to underlying file
