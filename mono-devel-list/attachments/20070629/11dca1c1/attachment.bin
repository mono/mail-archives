Index: Cecil.FlowAnalysis/Impl/ControlFlow/FlowGraphBuilder.cs
===================================================================
--- Cecil.FlowAnalysis/Impl/ControlFlow/FlowGraphBuilder.cs	(revisión: 80813)
+++ Cecil.FlowAnalysis/Impl/ControlFlow/FlowGraphBuilder.cs	(copia de trabajo)
@@ -41,9 +41,6 @@
 
 		internal FlowGraphBuilder (MethodDefinition method)
 		{
-			if (method.Body.ExceptionHandlers.Count > 0) {
-				throw new ArgumentException ("Exception handlers are not supported.", "body");
-			}
 			_SystemVoid = method.DeclaringType.Module.Import (typeof(void));
 			_body = method.Body;
 			DelimitBlocks ();
@@ -82,6 +79,12 @@
 					if (null != instruction.Next) MarkBlockStart (instruction.Next);
 				}
 			}
+			// the first instruction in a try block starts a blocks
+			foreach (ExceptionHandler exceptionHandler in _body.ExceptionHandlers) {
+				if (exceptionHandler.TryStart != null) {
+					MarkBlockStart (exceptionHandler.TryStart);
+				}
+			}
 		}
 
 		private void MarkBlockEnds (InstructionCollection instructions)
@@ -312,8 +315,29 @@
 								CecilFormatter.FormatInstruction (instruction)));
 					}
 				}
+				ConnectExceptionHandlerBlocks (block);
 			}
 		}
+		
+		private void ConnectExceptionHandlerBlocks (InstructionBlock block) {
+			foreach (ExceptionHandler exceptionHandler in _body.ExceptionHandlers) {
+				if (block.FirstInstruction == exceptionHandler.TryStart) {
+					IList catchBlocks = new ArrayList ();
+					foreach (ExceptionHandler catchExceptionHandler in _body.ExceptionHandlers) {
+						if (catchExceptionHandler.HandlerStart != null) {
+							catchBlocks.Add (GetBlock (catchExceptionHandler.HandlerStart));
+						}
+					}
+					Instruction last = block.LastInstruction;
+					IInstructionBlock[] successors = new IInstructionBlock [catchBlocks.Count + 1];
+					for (int index = 0; index < catchBlocks.Count; index++) {
+						successors[index] = (IInstructionBlock)catchBlocks[index];
+					}
+					successors[successors.Length -1] = GetBranchTargetBlock (last);
+					block.SetSuccessors (successors);
+				}
+			}
+		}
 
 		private IInstructionBlock GetBranchTargetBlock (Instruction instruction)
 		{
Index: Cecil.FlowAnalysis.Tests/ControlFlowTestFixture.cs
===================================================================
--- Cecil.FlowAnalysis.Tests/ControlFlowTestFixture.cs	(revisión: 80813)
+++ Cecil.FlowAnalysis.Tests/ControlFlowTestFixture.cs	(copia de trabajo)
@@ -237,5 +237,17 @@
 		{
 			RunTestCase ("StringPredicate");
 		}
+		
+		[Test]
+		public void SimpleTryCatch () 
+		{
+			RunTestCase ("SimpleTryCatch");
+		}
+		
+		[Test]
+		public void SimpleTryTryCatch () 
+		{
+			RunTestCase ("SimpleTryCatchCatch");
+		}
 	}
 }
Index: testcases/FlowAnalysis/SimpleTryCatchCatch.il
===================================================================
--- testcases/FlowAnalysis/SimpleTryCatchCatch.il	(revisión: 0)
+++ testcases/FlowAnalysis/SimpleTryCatchCatch.il	(revisión: 0)
@@ -0,0 +1,28 @@
+.assembly TestCase {}
+
+.class public auto ansi beforefieldinit TestCase
+	extends [mscorlib]System.Object
+{
+	.method public hidebysig static void Main() cil managed
+	{
+		.maxstack 3
+		IL_0000:  ldstr "message"
+		IL_0005:  call void class [mscorlib]System.Console::WriteLine(string)
+		.try { // 0
+			IL_000a:  ldstr "TestTryCatch"
+			IL_000f:  call void class [mscorlib]System.Console::WriteLine(string)
+			IL_0014:  leave IL_0029
+		} // end .try 0
+		catch [mscorlib]System.SystemException { // 0
+			IL_0019:  pop 
+			IL_001a:  rethrow 
+			IL_001c:  leave IL_0029
+		} // end handler 0
+		catch [mscorlib]System.Exception { // 1
+			IL_0021:  pop 
+			IL_0022:  rethrow 
+			IL_0024:  leave IL_0029
+		} // end handler 1
+		IL_0029:  ret 
+	}
+}
Index: testcases/FlowAnalysis/SimpleTryCatch-cfg.txt
===================================================================
--- testcases/FlowAnalysis/SimpleTryCatch-cfg.txt	(revisión: 0)
+++ testcases/FlowAnalysis/SimpleTryCatch-cfg.txt	(revisión: 0)
@@ -0,0 +1,24 @@
+block 1:
+	body:
+		IL_0000: ldstr "message"
+		IL_0005: call void System.Console::WriteLine(string)
+	successors:
+		block 2
+block 2:
+	body:
+		IL_000a: ldstr "TestTryCatch"
+		IL_000f: call void System.Console::WriteLine(string)
+		IL_0014: leave IL_0021
+	successors:
+		block 3
+		block 4
+block 3:
+	body:
+		IL_0019: pop
+		IL_001a: rethrow
+		IL_001c: leave IL_0021
+	successors:
+		block 4
+block 4:
+	body:
+		IL_0021: ret
\ Sin fin-de-línea al final del archivo
Index: testcases/FlowAnalysis/SimpleTryCatch.il
===================================================================
--- testcases/FlowAnalysis/SimpleTryCatch.il	(revisión: 0)
+++ testcases/FlowAnalysis/SimpleTryCatch.il	(revisión: 0)
@@ -0,0 +1,23 @@
+.assembly TestCase {}
+
+.class public auto ansi beforefieldinit TestCase
+	extends [mscorlib]System.Object
+{
+	.method public hidebysig static void Main() cil managed
+	{
+		.maxstack 3
+		IL_0000: ldstr "message"
+		IL_0005: call void class [mscorlib]System.Console::WriteLine(string)
+		.try {
+			IL_000a: ldstr "TestTryCatch"
+			IL_000f: call void class [mscorlib]System.Console::WriteLine(string)
+			IL_0014: leave IL_0021
+		}
+		catch [mscorlib]System.Object { 
+			IL_0019: pop 
+			IL_001a: rethrow 
+			IL_001c: leave IL_0021
+		} 
+		IL_0021: ret 
+	}
+}
Index: testcases/FlowAnalysis/SimpleTryCatchCatch-cfg.txt
===================================================================
--- testcases/FlowAnalysis/SimpleTryCatchCatch-cfg.txt	(revisión: 0)
+++ testcases/FlowAnalysis/SimpleTryCatchCatch-cfg.txt	(revisión: 0)
@@ -0,0 +1,32 @@
+block 1:
+	body:
+		IL_0000: ldstr "message"
+		IL_0005: call void System.Console::WriteLine(string)
+	successors:
+		block 2
+block 2:
+	body:
+		IL_000a: ldstr "TestTryCatch"
+		IL_000f: call void System.Console::WriteLine(string)
+		IL_0014: leave IL_0029
+	successors:
+		block 3
+		block 4
+		block 5
+block 3:
+	body:
+		IL_0019: pop
+		IL_001a: rethrow
+		IL_001c: leave IL_0029
+	successors:
+		block 5
+block 4:
+	body:
+		IL_0021: pop
+		IL_0022: rethrow
+		IL_0024: leave IL_0029
+	successors:
+		block 5
+block 5:
+	body:
+		IL_0029: ret
\ Sin fin-de-línea al final del archivo
