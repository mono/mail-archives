Index: mono/mini/mini-mips.c
===================================================================
--- mono/mini/mini-mips.c	(revision 122151)
+++ mono/mini/mini-mips.c	(working copy)
@@ -2657,18 +2657,21 @@
 			goto loop_start;
 #endif
 		case OP_IBEQ:
+		case OP_LBEQ:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(ins, OP_MIPS_BEQ, last_ins->sreg1, last_ins->sreg2);
 			last_ins->opcode = OP_NOP;
 			break;
 
 		case OP_IBNE_UN:
+		case OP_LBNE_UN:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(ins, OP_MIPS_BNE, last_ins->sreg1, last_ins->sreg2);
 			last_ins->opcode = OP_NOP;
 			break;
 
 		case OP_IBGE:
+		case OP_LBGE:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(last_ins, OP_MIPS_SLT, last_ins->sreg1, last_ins->sreg2);
 			last_ins->dreg = mono_alloc_ireg (cfg);
@@ -2676,6 +2679,7 @@
 			break;
 
 		case OP_IBGE_UN:
+		case OP_LBGE_UN:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(last_ins, OP_MIPS_SLTU, last_ins->sreg1, last_ins->sreg2);
 			last_ins->dreg = mono_alloc_ireg (cfg);
@@ -2683,6 +2687,7 @@
 			break;
 
 		case OP_IBLT:
+		case OP_LBLT:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(last_ins, OP_MIPS_SLT, last_ins->sreg1, last_ins->sreg2);
 			last_ins->dreg = mono_alloc_ireg (cfg);
@@ -2690,6 +2695,7 @@
 			break;
 
 		case OP_IBLT_UN:
+		case OP_LBLT_UN:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(last_ins, OP_MIPS_SLTU, last_ins->sreg1, last_ins->sreg2);
 			last_ins->dreg = mono_alloc_ireg (cfg);
@@ -2697,6 +2703,7 @@
 			break;
 
 		case OP_IBLE:
+		case OP_LBLE:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(last_ins, OP_MIPS_SLT, last_ins->sreg2, last_ins->sreg1);
 			last_ins->dreg = mono_alloc_ireg (cfg);
@@ -2704,6 +2711,7 @@
 			break;
 
 		case OP_IBLE_UN:
+		case OP_LBLE_UN:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(last_ins, OP_MIPS_SLTU, last_ins->sreg2, last_ins->sreg1);
 			last_ins->dreg = mono_alloc_ireg (cfg);
@@ -2711,6 +2719,7 @@
 			break;
 
 		case OP_IBGT:
+		case OP_LBGT:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(last_ins, OP_MIPS_SLT, last_ins->sreg2, last_ins->sreg1);
 			last_ins->dreg = mono_alloc_ireg (cfg);
@@ -2718,6 +2727,7 @@
 			break;
 
 		case OP_IBGT_UN:
+		case OP_LBGT_UN:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(last_ins, OP_MIPS_SLTU, last_ins->sreg2, last_ins->sreg1);
 			last_ins->dreg = mono_alloc_ireg (cfg);
@@ -2726,6 +2736,7 @@
 
 		case OP_CEQ:
 		case OP_ICEQ:
+		case OP_LCEQ:
 			g_assert (ins_is_compare(last_ins));
 			last_ins->opcode = OP_IXOR;
 			last_ins->dreg = mono_alloc_ireg(cfg);
@@ -2734,6 +2745,7 @@
 
 		case OP_CLT:
 		case OP_ICLT:
+		case OP_LCLT:
 			INS_REWRITE(ins, OP_MIPS_SLT, last_ins->sreg1, last_ins->sreg2);
 			last_ins->opcode = OP_NOP;
 			break;
@@ -2747,6 +2759,7 @@
 
 		case OP_CGT:
 		case OP_ICGT:
+		case OP_LCGT:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(ins, OP_MIPS_SLT, last_ins->sreg2, last_ins->sreg1);
 			MONO_DELETE_INS(bb, last_ins);
@@ -2754,6 +2767,7 @@
 
 		case OP_CGT_UN:
 		case OP_ICGT_UN:
+		case OP_LCGT_UN:
 			g_assert (ins_is_compare(last_ins));
 			INS_REWRITE(ins, OP_MIPS_SLTU, last_ins->sreg2, last_ins->sreg1);
 			MONO_DELETE_INS(bb, last_ins);
@@ -2984,8 +2998,12 @@
 					mips_lw (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
 					break;
 				case 8:
+#if _MIPS_SIM == _ABIO32
 					mips_lw (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
 					mips_lw (code, ainfo->reg + 1, inst->inst_basereg, inst->inst_offset + 4);
+#elif _MIPS_SIM == _ABIN32
+					mips_ld (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
+#endif
 					break;
 				default:
 					g_assert_not_reached ();
@@ -3437,18 +3455,22 @@
 		case OP_REM_IMM:
 			g_assert_not_reached ();
 		case OP_IOR:
+		case OP_LOR:
 			mips_or (code, ins->dreg, ins->sreg1, ins->sreg2);
 			break;
 		case OP_OR_IMM:
 		case OP_IOR_IMM:
+		case OP_LOR_IMM:
 			g_assert (!(ins->inst_imm & 0xffff0000));
 			mips_ori (code, ins->dreg, ins->sreg1, ins->inst_imm);
 			break;
 		case OP_IXOR:
+		case OP_LXOR:
 			mips_xor (code, ins->dreg, ins->sreg1, ins->sreg2);
 			break;
 		case OP_XOR_IMM:
 		case OP_IXOR_IMM:
+		case OP_LXOR_IMM:
 			/* unsigned 16-bit immediate */
 			g_assert (!(ins->inst_imm & 0xffff0000));
 			mips_xori (code, ins->dreg, ins->sreg1, ins->inst_imm);
@@ -3873,6 +3895,7 @@
 		}
 		case OP_CEQ:
 		case OP_ICEQ:
+		case OP_LCEQ:
 			mips_addiu (code, ins->dreg, mips_zero, 1);
 			mips_beq (code, mips_at, mips_zero, 2);
 			mips_nop (code);
@@ -3882,6 +3905,8 @@
 		case OP_CLT_UN:
 		case OP_ICLT:
 		case OP_ICLT_UN:
+		case OP_LCLT:
+		case OP_LCLT_UN:
 			mips_addiu (code, ins->dreg, mips_zero, 1);
 			mips_bltz (code, mips_at, 2);
 			mips_nop (code);
@@ -3891,6 +3916,8 @@
 		case OP_CGT_UN:
 		case OP_ICGT:
 		case OP_ICGT_UN:
+		case OP_LCGT:
+		case OP_LCGT_UN:
 			mips_addiu (code, ins->dreg, mips_zero, 1);
 			mips_bgtz (code, mips_at, 2);
 			mips_nop (code);
@@ -4020,9 +4047,13 @@
 			mips_ldc1 (code, ins->dreg, mips_at, ((guint32)ins->inst_p0) & 0xffff);
 #else
 			mips_load_const (code, mips_at, ins->inst_p0);
+#if _MIPS_SIM == _ABIO32
 			mips_lwc1 (code, ins->dreg, mips_at, 4);
 			mips_lwc1 (code, ins->dreg+1, mips_at, 0);
+#elif _MIPS_SIM == _ABIN32
+			mips_ldc1 (code, ins->dreg, mips_at, 0);
 #endif
+#endif
 			break;
 		case OP_R4CONST:
 			if (((guint32)ins->inst_p0) & (1 << 15))
@@ -4050,19 +4081,25 @@
 			}
 			break;
 		case OP_LOADR8_MEMBASE:
+#if _MIPS_SIM == _ABIO32
 			if (mips_is_imm16 (ins->inst_offset)) {
-#if _MIPS_SIM == _ABIO32
 				mips_lwc1 (code, ins->dreg, ins->inst_basereg, ins->inst_offset+4);
 				mips_lwc1 (code, ins->dreg+1, ins->inst_basereg, ins->inst_offset);
-#elif _MIPS_SIM == _ABIN32
-				mips_ldc1 (code, ins->dreg, ins->inst_basereg, ins->inst_offset);
-#endif
 			} else {
 				mips_load_const (code, mips_at, ins->inst_offset);
 				mips_addu (code, mips_at, mips_at, ins->inst_basereg);
 				mips_lwc1 (code, ins->dreg, mips_at, 4);
 				mips_lwc1 (code, ins->dreg+1, mips_at, 0);
 			}
+#elif _MIPS_SIM == _ABIN32
+			if (mips_is_imm16 (ins->inst_offset)) {
+				mips_ldc1 (code, ins->dreg, ins->inst_basereg, ins->inst_offset);
+			} else {
+				mips_load_const (code, mips_at, ins->inst_offset);
+				mips_addu (code, mips_at, mips_at, ins->inst_basereg);
+				mips_ldc1 (code, ins->dreg, mips_at, 0);
+			}
+#endif
 			break;
 		case OP_STORER4_MEMBASE_REG:
 			g_assert (mips_is_imm16 (ins->inst_offset));
@@ -4123,6 +4160,9 @@
 		case OP_FCONV_TO_I:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
 			break;
+		case OP_FCONV_TO_I8:
+			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 8, TRUE);
+			break;
 		case OP_FCONV_TO_U4:
 		case OP_FCONV_TO_U:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
@@ -4303,8 +4343,68 @@
 			mono_add_patch_info (cfg, offset, (MonoJumpInfoType)ins->inst_c1, ins->inst_p0);
 			mips_load (code, ins->dreg, 0x0f0f0f0f);
 			break;
+#ifdef _MIPS_SIM == _ABIN32	
+		case OP_LCONV_TO_R8:
+			mips_dmtc1 (code, ins->dreg, ins->sreg1);
+			mips_cvtdl(code,ins->dreg,ins->dreg);
+			break;
+		case OP_LCONV_TO_R4:
+			mips_dmtc1 (code, ins->dreg, ins->sreg1);
+			mips_cvtdw(code,ins->dreg,ins->dreg);
+			break;
+		case OP_LCONV_TO_R_UN:{
+			static const guint64 adjust_val = 0x41F0000000000000ULL;
+			/* convert unsigned long to double */
+			mips_dmtc1 (code, mips_ftemp, ins->sreg1);
+			mips_bgez (code, ins->sreg1, 5);
+			mips_cvtdl (code, ins->dreg, mips_ftemp);
 
+			mips_load_const (code, mips_at, &adjust_val);
+			mips_ldc1  (code, mips_ftemp, mips_at, 0);
+			mips_faddd (code, ins->dreg, ins->dreg, mips_ftemp);
+			break;
+		}
+		case OP_FREM:{
+			max_len = ((guint8 *)ins_get_spec (ins->opcode))[MONO_INST_LEN];
+			max_len = max_len*20;
+			cfg->code_size = max_len;
+			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
+			code = cfg->native_code + offset;
 
+			guint32 *divisor_is_m1;
+			guint32 *divisor_is_zero;
+			code = emit_float_to_int (cfg, code, mips_t0, ins->sreg1, 8, TRUE);
+			code = emit_float_to_int (cfg, code, mips_t1, ins->sreg2, 8, TRUE);
+			
+			mips_addiu (code, mips_at, mips_zero, 0xffff);
+			divisor_is_m1 = (guint32 *)(void *)code;
+			mips_bne (code, mips_t1, mips_at, 0);
+			mips_nop (code);
+
+			/* Divide by -1 -- throw exception */
+			EMIT_SYSTEM_EXCEPTION_NAME("ArithmeticException");
+
+			mips_patch (divisor_is_m1, (guint32)code);
+
+			/* Put divide in branch delay slot (NOT YET) */
+			divisor_is_zero = (guint32 *)(void *)code;
+			mips_bne (code, mips_t1, mips_zero, 0);
+			mips_nop (code);
+
+			/* Divide by zero -- throw exception */
+			EMIT_SYSTEM_EXCEPTION_NAME("DivideByZeroException");
+
+			mips_patch (divisor_is_zero, (guint32)code);
+			mips_div (code, mips_t0, mips_t1);
+			mips_mflo (code, mips_t0);
+			mips_dmtc1 (code, ins->dreg, mips_t0);
+		}
+
+			break;
+
+#endif
+
+
 		default:
 			g_warning ("unknown opcode %s in %s()\n", mono_inst_name (ins->opcode), __FUNCTION__);
 			g_assert_not_reached ();
@@ -4487,11 +4587,14 @@
 	if (sig && sig->ret && MONO_TYPE_ISSTRUCT (sig->ret)) {
 		cfg->vret_addr->inst_offset += delta;
 	}
+/* FIXME Wrong offset when an argument is passed by reference */
+#if _MIPS_SIM != _ABIN32
 	for (i = 0; i < sig->param_count + sig->hasthis; ++i) {
 		MonoInst *inst = cfg->args [i];
 
 		inst->inst_offset += delta;
 	}
+#endif
 
 	/*
 	 * loads and stores based off the frame reg that (used to) lie
@@ -4808,9 +4911,17 @@
 					mips_lw (code, mips_at, inst->inst_basereg, inst->inst_offset);
 					mips_sh (code, mips_at, inst->inst_basereg, inst->inst_offset);
 					break;
-				case 0: /* XXX */
+				case 0:
+					break;
 				case 4:
+					mips_lwc1 (code, mips_ftemp, inst->inst_basereg, cfg->stack_offset+ainfo->offset);
+					mips_swc1 (code, mips_ftemp, inst->inst_basereg, inst->inst_offset);
+					break;
 				case 8:
+#if _MIPS_SIM == _ABIN32
+					mips_ldc1 (code, mips_ftemp, inst->inst_basereg, cfg->stack_offset+ainfo->offset);
+					mips_sdc1 (code, mips_ftemp, inst->inst_basereg, inst->inst_offset);
+#endif
 					break;
 				default:
 					g_assert_not_reached ();
@@ -4970,15 +5081,15 @@
 	mips_addiu (code, mips_sp, mips_sp, -32);
 	switch (save_mode) {
 	case SAVE_TWO:
-		mips_sw (code, mips_v0, mips_sp, save_offset);
-		mips_sw (code, mips_v1, mips_sp, save_offset + SIZEOF_REGISTER);
+		MIPS_SW (code, mips_v0, mips_sp, save_offset);
+		MIPS_SW (code, mips_v1, mips_sp, save_offset + SIZEOF_REGISTER);
 		if (enable_arguments) {
 			MIPS_MOVE (code, mips_a1, mips_v0);
 			MIPS_MOVE (code, mips_a2, mips_v1);
 		}
 		break;
 	case SAVE_ONE:
-		MIPS_SW (code, mips_v0, mips_sp, save_offset);
+		MIPS_SW (code, mips_v0, mips_sp, save_offset); 
 		if (enable_arguments) {
 			MIPS_MOVE (code, mips_a1, mips_v0);
 		}
@@ -5001,8 +5112,8 @@
 
 	switch (save_mode) {
 	case SAVE_TWO:
-		mips_lw (code, mips_v0, mips_sp, save_offset);
-		mips_lw (code, mips_v1, mips_sp, save_offset + SIZEOF_REGISTER);
+		MIPS_LW (code, mips_v0, mips_sp, save_offset);
+		MIPS_LW (code, mips_v1, mips_sp, save_offset + SIZEOF_REGISTER);
 		break;
 	case SAVE_ONE:
 		MIPS_LW (code, mips_v0, mips_sp, save_offset);
Index: mono/mini/mini-mips.h
===================================================================
--- mono/mini/mini-mips.h	(revision 122151)
+++ mono/mini/mini-mips.h	(working copy)
@@ -168,7 +168,7 @@
 					 MIPS_FP_PAIR(mips_f31))
 #endif
 
-#define mips_ftemp mips_f18
+#define mips_ftemp mips_f4
 
 #define MONO_ARCH_USE_FPSTACK FALSE
 #define MONO_ARCH_FPSTACK_SIZE 0
Index: mono/mini/mini-codegen.c
===================================================================
--- mono/mini/mini-codegen.c	(revision 122151)
+++ mono/mini/mini-codegen.c	(working copy)
@@ -1042,6 +1042,7 @@
 		} else {
 			ins->sreg1 = -1;
 		}
+#if SIZEOF_REGISTER == 4
 		if (spec_src2) {
 			bank = sreg2_bank (spec);
 			g_assert (ins->sreg2 != -1);
@@ -1062,6 +1063,7 @@
 		} else {
 			ins->sreg2 = -1;
 		}
+#endif
 		if (spec_dest) {
 			int dest_dreg;
 
@@ -1323,6 +1325,7 @@
 		 * If dreg is a fixed regpair, free up both of the needed hregs to avoid
 		 * various complex situations.
 		 */
+#if SIZEOF_REGISTER == 4
 		if (MONO_ARCH_INST_IS_REGPAIR (spec_dest)) {
 			guint32 dreg2, dest_dreg2;
 
@@ -1340,7 +1343,7 @@
 				}
 			}
 		}
-
+#endif
 		if (dreg_fixed_mask) {
 			g_assert (!bank);
 			if (is_global_ireg (ins->dreg)) {
@@ -1378,7 +1381,7 @@
 			DEBUG (printf ("\tassigned dreg %s to dest R%d\n", mono_regname_full (val, bank), ins->dreg));
 			ins->dreg = val;
 		}
-
+#if SIZEOF_REGISTER == 4
 		/* Handle regpairs */
 		if (MONO_ARCH_INST_IS_REGPAIR (spec_dest)) {
 			int reg2 = prev_dreg + 1;
@@ -1428,6 +1431,7 @@
 				mono_regstate_free_int (rs, val);
 			}
 		}
+#endif
 
 		if (prev_dreg >= 0 && is_soft_reg (prev_dreg, bank) && (spec_dest != 'b')) {
 			/* 
Index: mono/arch/mips/mips-codegen.h
===================================================================
--- mono/arch/mips/mips-codegen.h	(revision 122151)
+++ mono/arch/mips/mips-codegen.h	(working copy)
@@ -193,6 +193,7 @@
 #define mips_format_r(code,op,rs,rt,rd,sa,func) mips_emit32 ((code), (((op)<<26)|((rs)<<21)|((rt)<<16)|((rd)<<11)|((sa)<<6)|(func)))
 #define mips_format_divmul(code,op,src1,src2,fun) mips_emit32 ((code), (((op)<<26)|((src1)<<21)|((src2)<<16)|(fun)))
 
+#define mips_is_imm32(val) ((gint64)(val) >= (gint64)-(1<<31) && (gint64)(val) <= (gint64)((1<<31)-1))
 #define mips_is_imm16(val) ((gint)(val) >= (gint)-(1<<15) && (gint)(val) <= (gint)((1<<15)-1))
 
 /* Load always using lui/addiu pair (for later patching) */
@@ -211,20 +212,54 @@
 	} while (0)
 
 /* load constant - no patch-up */
-#define mips_load_const(c,D,v) do {	\
-		if (!mips_is_imm16 ((v)))	{	\
-			if (((guint32)(v)) & (1 << 15)) {		\
+
+#if SIZEOF_REGISTER == 4
+
+#define mips_load_const(c,D,v) do {    \
+		if (mips_is_imm16 ((v)))       \
+		{\
+			mips_addiu ((c), (D), mips_zero, ((guint32)(v)) & 0xffff); \
+		}\
+		else if (mips_is_imm32 ((v))){\
+			if (((guint32)(v)) & (1 << 15))                 \
 				mips_lui ((c), (D), mips_zero, (((guint32)(v))>>16)+1); \
-			} \
-			else {			\
+			else     \
 				mips_lui ((c), (D), mips_zero, (((guint32)(v))>>16)); \
-			}						\
 			if (((guint32)(v)) & 0xffff) \
 				mips_addiu ((c), (D), (D), ((guint32)(v)) & 0xffff); \
-		}							\
-		else							\
+		}  \
+        } while (0)
+
+#elif SIZEOF_REGISTER == 8
+
+#define mips_load_const(c,D,v) do {    \
+		if (mips_is_imm16 ((v)))       \
+		{\
 			mips_addiu ((c), (D), mips_zero, ((guint32)(v)) & 0xffff); \
-	} while (0)
+		}\
+		else if (mips_is_imm32 ((v))){\
+			if (((guint32)(v)) & (1 << 15))                 \
+				mips_lui ((c), (D), mips_zero, (((guint32)(v))>>16)+1); \
+			else     \
+				mips_lui ((c), (D), mips_zero, (((guint32)(v))>>16)); \
+			if (((guint32)(v)) & 0xffff) \
+				mips_addiu ((c), (D), (D), ((guint32)(v)) & 0xffff); \
+			}                                                       \
+		else            \
+		{\
+			mips_lui ((c), (D), mips_zero, (((guint64)(v))>>48));                   \
+			mips_daddiu ((c), (D), (D), (((guint64)(v))>>32) & 0xffff); \
+			mips_dsll((c), (D), (D), 16);           \
+			if (((guint64)(v)) & (1 << 15))         \
+				mips_daddiu ((c), (D), (D), ((((guint64)(v))>>16) & 0xffff) + 1); \
+			else            \
+				mips_daddiu ((c), (D), (D), (((guint64)(v))>>16) & 0xffff); \
+				mips_dsll((c), (D), (D), 16);           \
+			if (((guint64)(v)) & 0xffff) \
+				mips_daddiu ((c), (D), (D), ((guint64)(v)) & 0xffff); \
+		}  \
+        } while (0)
+#endif
 
 /* arithmetric ops */
 #define mips_add(c,dest,src1,src2) mips_format_r(c,0,src1,src2,dest,0,32)
@@ -425,7 +460,11 @@
 #define mips_mfc1(c,dest,src) mips_format_r(c,17,0,dest,src,0,0)
 #define mips_mtc1(c,dest,src) mips_format_r(c,17,4,src,dest,0,0)
 #define mips_dmfc1(c,dest,src) mips_format_r(c,17,1,0,dest,src,0)
+#if _MIPS_SIM == _ABIN32
+#define mips_dmtc1(c,dest,src) mips_format_r(c,17,5,src,dest,0,0)
+#elif 
 #define mips_dmtc1(c,dest,src) mips_format_r(c,17,1,0,src,dest,0)
+#endif
 #define mips_ldc1(c,dest,base,offset) mips_ldc(c,1,dest,base,offset)
 #define mips_ldxc1(c,dest,base,idx) mips_format_r(c,19,base,idx,0,dest,1)
 #define mips_lwc1(c,dest,base,offset) mips_lwc(c,1,dest,base,offset)