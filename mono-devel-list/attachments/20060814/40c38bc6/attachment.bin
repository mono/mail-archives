Index: Test/System.Diagnostics/ChangeLog
===================================================================
--- Test/System.Diagnostics/ChangeLog	(revision 63733)
+++ Test/System.Diagnostics/ChangeLog	(working copy)
@@ -1,3 +1,14 @@
+2006-08-14  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* EventLogTest.cs: Enable tests. On 2.0 profile, set environment
+	variables to force local file implementation to be used for unit tests
+	and to force machine-level registry key to be written to a directory
+	in the user's home directory. This avoids permission issues for the
+	unit tests, and allows us to clean up the files/directory that are
+	created during the test run. Skip asserts that rely on reading
+	eventlog entries when the eventlog implementation is either native
+	win32 eventlog or null implementation.
+
 2006-08-11  Gert Driesen  <drieseng@users.sourceforge.net>
 
 	* EventLogTest.cs: new test, currently not enabled due to UnixRegistry
Index: Test/System.Diagnostics/EventLogTest.cs
===================================================================
--- Test/System.Diagnostics/EventLogTest.cs	(revision 63733)
+++ Test/System.Diagnostics/EventLogTest.cs	(working copy)
@@ -41,6 +41,8 @@
 
 using System;
 using System.Diagnostics;
+using System.Globalization;
+using System.IO;
 
 using Microsoft.Win32;
 
@@ -49,9 +51,68 @@
 namespace MonoTests.System.Diagnostics
 {
 	[TestFixture]
-	[Ignore ("Enable after unixregistry bug has been tracked and fixed.")]
 	public class EventLogTest
 	{
+#if NET_2_0
+		private string _originalEventLogImpl = null;
+		private string _originalEventLogPath = null;
+		private string _originalRegistryMachinePath = null;
+		private const string EVENTLOG_TYPE_VAR = "MONO_EVENTLOG_TYPE";
+		private const string EVENTLOG_PATH_VAR = "MONO_EVENTLOG_PATH";
+		private const string REGISTRY_MACHINE_STORE_VAR = "MONO_REGISTRY_MACHINE";
+#endif
+
+		// IMPORTANT: also update constants in EventLogTest
+		private const string LOCAL_FILE_IMPL = "local";
+		private const string NATIVE_WIN32_IMPL = "win32";
+		private const string NULL_IMPL = "null";
+
+#if NET_2_0 // Environment.SetEnvironmentVariable is only available in 2.0 profile
+		[SetUp]
+		public void SetUp ()
+		{
+			// save original eventlog implementation type (if set)
+			string _originalEventLogImpl = Environment.GetEnvironmentVariable (
+				EVENTLOG_TYPE_VAR);
+			// use local file implementation
+			Environment.SetEnvironmentVariable (EVENTLOG_TYPE_VAR, "local");
+
+			// save original eventlog path (if set)
+			string _originalEventLogPath = Environment.GetEnvironmentVariable (
+				EVENTLOG_PATH_VAR);
+			// use directory in user home directory to avoid directory
+			// permission issues
+			Environment.SetEnvironmentVariable (EVENTLOG_PATH_VAR, Path.Combine (
+				Environment.GetFolderPath (Environment.SpecialFolder.Personal),
+					".mono/eventlog"));
+
+			// save original machine-level registry store (if set)
+			_originalRegistryMachinePath = Environment.GetEnvironmentVariable (
+				REGISTRY_MACHINE_STORE_VAR);
+			// use directory in user home directory to avoid directory
+			// permission issues
+			Environment.SetEnvironmentVariable (REGISTRY_MACHINE_STORE_VAR, Path.Combine (
+				Environment.GetFolderPath (Environment.SpecialFolder.Personal),
+					".mono/registry"));
+		}
+
+		[TearDown]
+		public void TearDown ()
+		{
+			// restore original eventlog implementation type
+			Environment.SetEnvironmentVariable (EVENTLOG_TYPE_VAR, 
+				_originalEventLogImpl);
+
+			// restore original eventlog path
+			Environment.SetEnvironmentVariable (EVENTLOG_PATH_VAR,
+				_originalEventLogPath);
+
+			// restore original machine-level registry store
+			Environment.SetEnvironmentVariable (REGISTRY_MACHINE_STORE_VAR,
+				_originalRegistryMachinePath);
+		}
+#endif
+
 		[Test]
 		public void Constructor1 ()
 		{
@@ -1134,6 +1195,12 @@
 					Assert.IsTrue (EventLog.SourceExists ("monotempsource"), "#5");
 					Assert.AreEqual ("monotemplog", EventLog.LogNameFromSourceName ("monotempsource", ".").ToLower (), "#6");
 
+					// null implementation does not store written entries, and
+					// reading eventlog entries is not yet implemented for the
+					// native win32 implementation
+					if (EventLogImplType == NATIVE_WIN32_IMPL || EventLogImplType == NULL_IMPL)
+						return;
+
 					EventLogEntry entry = eventLog.Entries[eventLog.Entries.Count - 1];
 					Assert.IsNotNull (entry, "#7");
 					Assert.IsNotNull (entry.Category, "#8");
@@ -1220,6 +1287,12 @@
 					Assert.IsTrue (EventLog.SourceExists ("monotempsource"), "#5");
 					Assert.AreEqual ("monotemplog", EventLog.LogNameFromSourceName ("monotempsource", ".").ToLower (), "#6");
 
+					// null implementation does not store written entries, and
+					// reading eventlog entries is not yet implemented for the
+					// native win32 implementation
+					if (EventLogImplType == NATIVE_WIN32_IMPL || EventLogImplType == NULL_IMPL)
+						return;
+
 					EventLogEntry entry = eventLog.Entries[eventLog.Entries.Count - 1];
 					Assert.IsNotNull (entry, "#7");
 					Assert.IsNotNull (entry.Category, "#8");
@@ -1302,5 +1375,39 @@
 					eventLogKey.Close ();
 			}
 		}
+
+		// IMPORTANT: keep this in sync with System.Diagnostics.EventLog.EventLogImplType
+		private static string EventLogImplType {
+			get {
+				string implType = Environment.GetEnvironmentVariable ("MONO_EVENTLOG_TYPE");
+				if (implType == null) {
+					// if user explicitly set the eventlog file path, then assume
+					// he wants to enable the local file implementation
+					string filePath = Environment.GetEnvironmentVariable ("MONO_EVENTLOG_PATH");
+					if (filePath != null)
+						return LOCAL_FILE_IMPL;
+					// FIXME: enable the commented code once reading eventlog
+					// entries has been implemented for the native win32
+					// eventlog implementation
+					/*
+					if (Win32EventLogEnabled)
+						return NATIVE_WIN32_IMPL;
+					*/
+					implType = NULL_IMPL;
+				} else {
+					if (string.Compare (implType, LOCAL_FILE_IMPL, true) == 0)
+						implType = LOCAL_FILE_IMPL;
+					else if (string.Compare (implType, NATIVE_WIN32_IMPL, true) == 0)
+						implType = NATIVE_WIN32_IMPL;
+					else if (string.Compare (implType, NULL_IMPL, true) == 0)
+						implType = NULL_IMPL;
+					else
+						throw new NotSupportedException (string.Format (
+							CultureInfo.InvariantCulture, "Eventlog implementation"
+							+ " '{0}' is not supported.", implType));
+				}
+				return implType;
+			}
+		}
 	}
 }
Index: System.dll.sources
===================================================================
--- System.dll.sources	(revision 63733)
+++ System.dll.sources	(working copy)
@@ -451,7 +451,6 @@
 System.Diagnostics/InstanceDataCollectionCollection.cs
 System.Diagnostics/InstanceDataCollection.cs
 System.Diagnostics/InstanceData.cs
-System.Diagnostics/LocalFileEventLog.cs
 System.Diagnostics/MonitoringDescriptionAttribute.cs
 System.Diagnostics/NullEventLog.cs
 System.Diagnostics/OverflowAction.cs
@@ -485,6 +484,8 @@
 System.Diagnostics/TraceListenerCollection.cs
 System.Diagnostics/TraceListener.cs
 System.Diagnostics/TraceSwitch.cs
+System.Diagnostics/UnixEventLog.cs
+System.Diagnostics/Win32EventLog.cs
 System/FileStyleUriParser.cs
 System/FtpStyleUriParser.cs
 System/GenericUriParser.cs
Index: System.Diagnostics/UnixEventLog.cs
===================================================================
--- System.Diagnostics/UnixEventLog.cs	(revision 0)
+++ System.Diagnostics/UnixEventLog.cs	(revision 0)
@@ -0,0 +1,287 @@
+//
+// System.Diagnostics.UnixEventLog.cs
+//
+// Author:
+//	Gert Driesen <driesen@users.sourceforge.net>
+//	Atsushi Enum <atsushi@ximian.com>
+//
+// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
+//
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Globalization;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Security;
+using System.Text;
+
+namespace System.Diagnostics
+{
+	internal class UnixEventLog : EventLogImpl
+	{
+		const string DateFormat = "yyyyMMddHHmmssfff";
+		static readonly object lockObject = new object ();
+
+		public UnixEventLog (EventLog coreEventLog) : base (coreEventLog)
+		{
+		}
+
+		public override void BeginInit () {
+		}
+
+		public override void Clear ()
+		{
+			if (!Directory.Exists (LogStore))
+				return;
+
+			foreach (string file in Directory.GetFiles (LogStore, "*.log"))
+				File.Delete (file);
+			Directory.Delete (LogStore);
+		}
+
+		public override void Close ()
+		{
+			// we don't hold any unmanaged resources
+		}
+
+		public override void CreateEventSource (EventSourceCreationData sourceData)
+		{
+			// create event log root store and log store, and modify access
+			// permissions (unix only)
+			EnsureLogStore ();
+		}
+
+		public override void Dispose (bool disposing)
+		{
+			Close ();
+		}
+
+		public override void EndInit () { }
+
+		public override EventLogEntry[] GetEntries ()
+		{
+			if (!Directory.Exists (LogStore))
+				return new EventLogEntry [0];
+
+			int entryCount = GetEntryCount ();
+			EventLogEntry [] entries = new EventLogEntry [entryCount];
+			for (int i = 0; i < entryCount; i++) {
+				entries [i] = GetEntry (i);
+			}
+			return entries;
+		}
+
+		protected override int GetEntryCount ()
+		{
+			if (!Directory.Exists (LogStore))
+				return 0;
+
+			string[] logFiles = Directory.GetFiles (LogStore, "*.log");
+			return logFiles.Length;
+		}
+
+		protected override EventLogEntry GetEntry (int index)
+		{
+			// our file names are one-based
+			string file = Path.Combine (LogStore, (index + 1).ToString (
+				CultureInfo.InvariantCulture) + ".log");
+
+			using (TextReader tr = File.OpenText (file)) {
+				int eventIndex = int.Parse (Path.GetFileNameWithoutExtension (file),
+					CultureInfo.InvariantCulture);
+				int id = int.Parse (tr.ReadLine ().Substring (9));
+				long instanceId = long.Parse (tr.ReadLine ().Substring (12),
+					CultureInfo.InvariantCulture);
+				EventLogEntryType type = (EventLogEntryType)
+					Enum.Parse (typeof (EventLogEntryType), tr.ReadLine ().Substring (11));
+				string source = tr.ReadLine ().Substring (8);
+				string category = tr.ReadLine ().Substring (10);
+				short categoryNumber = short.Parse(category, CultureInfo.InvariantCulture);
+				string categoryName = "(" + category + ")";
+				DateTime date = DateTime.ParseExact (tr.ReadLine ().Substring (15),
+					DateFormat, CultureInfo.InvariantCulture);
+				int size = int.Parse (tr.ReadLine ().Substring (15));
+				char [] buf = new char [size];
+				tr.Read (buf, 0, size);
+				ArrayList replacementTemp = new ArrayList ();
+				StringBuilder sb = new StringBuilder ();
+				for (int i = 0; i < buf.Length; i++) {
+					char c = buf[i];
+					if (c == '\0') {
+						replacementTemp.Add (sb.ToString ());
+						sb.Length = 0;
+					} else {
+						sb.Append (c);
+					}
+				}
+				if (sb.Length > 0) {
+					replacementTemp.Add (sb.ToString ());
+				}
+				string [] replacementStrings = new string [replacementTemp.Count];
+				replacementTemp.CopyTo (replacementStrings, 0);
+				DateTime timeWritten = File.GetLastWriteTime (file);
+
+				byte [] bin = Convert.FromBase64String (tr.ReadToEnd ());
+				return new EventLogEntry (categoryName, categoryNumber, eventIndex,
+					id, source, new string(buf), null, Environment.MachineName, 
+					type, date, timeWritten, bin, replacementStrings, instanceId);
+			}
+		}
+
+		[MonoTODO]
+		protected override string GetLogDisplayName ()
+		{
+			return CoreEventLog.Log;
+		}
+
+		protected override void WriteEventLogEntry (EventLogEntry entry)
+		{
+			lock (lockObject) {
+				// make sure log store directory exists
+				EnsureLogStore ();
+
+				int index = GetNewIndex ();
+				string logPath = Path.Combine (LogStore, index.ToString (CultureInfo.InvariantCulture) + ".log");
+				try {
+					using (TextWriter w = File.CreateText (logPath)) {
+						w.WriteLine ("EventID: {0}", entry.EventID);
+#if NET_2_0
+						w.WriteLine ("InstanceID: {0}", entry.InstanceId);
+#else
+						w.WriteLine ("InstanceID: {0}", entry.EventID);
+#endif
+						w.WriteLine ("EntryType: {0}", entry.EntryType);
+						w.WriteLine ("Source: {0}", entry.Source);
+						w.WriteLine ("Category: {0}", entry.CategoryNumber.ToString (
+							CultureInfo.InvariantCulture));
+						w.WriteLine ("TimeGenerated: {0}", entry.TimeGenerated.ToString (
+							DateFormat, CultureInfo.InvariantCulture));
+						StringBuilder sb = new StringBuilder ();
+						if (entry.ReplacementStrings != null) {
+							for (int i = 0; i < entry.ReplacementStrings.Length; i++) {
+								if (i > 0)
+									sb.Append ('\0');
+								string replacement = entry.ReplacementStrings[i];
+								sb.Append (replacement);
+							}
+						}
+						w.WriteLine ("MessageLength: {0}", sb.Length);
+						w.Write (sb.ToString ());
+						if (entry.Data != null)
+							w.Write (Convert.ToBase64String (entry.Data));
+					}
+				} catch (IOException) {
+					File.Delete (logPath);
+				}
+			}
+		}
+
+		private bool RunningOnLinux {
+			get {
+				return ((int) Environment.OSVersion.Platform == 4 ||
+#if NET_2_0
+					Environment.OSVersion.Platform == PlatformID.Unix);
+#else
+					(int) Environment.OSVersion.Platform == 128);
+#endif
+			}
+		}
+
+		private string LogStore {
+			get {
+				if (RunningOnLinux)
+					return Path.Combine (EventLogStore, CoreEventLog.Log.ToLower ());
+				return Path.Combine (EventLogStore, CoreEventLog.Log);
+			}
+		}
+
+		private string EventLogStore {
+			get {
+				string eventStore = Environment.GetEnvironmentVariable (EventLog.EVENTLOG_PATH_VAR);
+				if (eventStore != null)
+					return eventStore;
+				if (RunningOnLinux) {
+					return "/var/lib/mono/eventlog";
+				} else {
+					return Path.Combine (Environment.GetFolderPath (
+						Environment.SpecialFolder.CommonApplicationData),
+						"mono/eventlog");
+				}
+			}
+		}
+
+		private void EnsureLogStore ()
+		{
+			if (!Directory.Exists (LogStore)) {
+				Directory.CreateDirectory (LogStore);
+				ModifyAccessPermissions (LogStore, "777");
+				ModifyAccessPermissions (LogStore, "+t");
+			}
+		}
+
+		private int GetNewIndex () {
+			// our file names are one-based
+			int maxIndex = 0;
+			string[] logFiles = Directory.GetFiles (LogStore, "*.log");
+			for (int i = 0; i < logFiles.Length; i++) {
+				try {
+					string file = logFiles[i];
+					int index = int.Parse (Path.GetFileNameWithoutExtension (
+						file), CultureInfo.InvariantCulture);
+					if (index > maxIndex)
+						maxIndex = index;
+				} catch {
+				}
+			}
+			return ++maxIndex;
+		}
+
+		private static void ModifyAccessPermissions (string path, string permissions)
+		{
+			ProcessStartInfo pi = new ProcessStartInfo ();
+			pi.FileName = "chmod";
+			pi.RedirectStandardOutput = true;
+			pi.RedirectStandardError = true;
+			pi.UseShellExecute = false;
+			pi.Arguments = string.Format ("{0} \"{1}\"", permissions, path);
+
+			Process p = null;
+			try {
+				p = Process.Start (pi);
+			} catch (Exception ex) {
+				throw new SecurityException ("Access permissions could not be modified.", ex);
+			}
+
+			p.WaitForExit ();
+			if (p.ExitCode != 0) {
+				// TODO: read cause from stderr, or stdout
+				p.Close ();
+				throw new SecurityException ("Access permissions could not be modified.");
+			}
+			p.Close ();
+		}
+	}
+}

Property changes on: System.Diagnostics/UnixEventLog.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Index: System.Diagnostics/NullEventLog.cs
===================================================================
--- System.Diagnostics/NullEventLog.cs	(revision 63733)
+++ System.Diagnostics/NullEventLog.cs	(working copy)
@@ -3,6 +3,7 @@
 //
 // Author:
 //   Atsushi Enomoto  <atsushi@ximian.com>
+//   Gert Driesen  <drieseng@users.sourceforge.net>
 //
 // (C) 2006 Novell, Inc.
 //
@@ -30,33 +31,18 @@
 
 using System;
 using System.Diagnostics;
-using System.ComponentModel;
-using System.ComponentModel.Design;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Net;
 
 namespace System.Diagnostics
 {
+	// Empty implementation that does not need any specific platform
+	// but should be enough to get applications to run that WRITE to eventlog
 	internal class NullEventLog : EventLogImpl
 	{
-		EventLogEntryCollection empty_entries =
-			new EventLogEntryCollection (new EventLogEntry [0]);
-
 		public NullEventLog (EventLog coreEventLog)
 			: base (coreEventLog)
 		{
 		}
 
-		public override EventLogEntryCollection Entries {
-			get { return empty_entries; }
-		}
-
-		public override string LogDisplayName {
-			get { return String.Empty; }
-		}
-
 		public override void BeginInit ()
 		{
 		}
@@ -69,58 +55,40 @@
 		{
 		}
 
-		public override void Dispose (bool disposing)
+		public override void CreateEventSource (EventSourceCreationData sourceData)
 		{
 		}
 
-		public override void EndInit ()
+		public override void Dispose (bool disposing)
 		{
 		}
-	}
 
-	internal class NullEventLogFactory : EventLogFactory
-	{
-		EventLog [] empty_logs = new EventLog [0];
-
-		public override EventLogImpl Create (EventLog source)
+		public override void EndInit ()
 		{
-			return new NullEventLog (source);
 		}
 
-		public override void CreateEventSource (string source, string logName, string machineName)
+		public override EventLogEntry[] GetEntries ()
 		{
+			return new EventLogEntry[0];
 		}
 
-		public override void Delete (string logName, string machineName)
+		protected override int GetEntryCount ()
 		{
+			return 0;
 		}
 
-		public override void DeleteEventSource (string source, string machineName)
+		protected override EventLogEntry GetEntry (int index)
 		{
+			return null;
 		}
 
-		public override bool Exists (string logName, string machineName)
+		protected override string GetLogDisplayName ()
 		{
-			return false;
+			return CoreEventLog.Log;
 		}
 
-		public override EventLog [] GetEventLogs (string machineName)
+		protected override void WriteEventLogEntry (EventLogEntry entry)
 		{
-			return empty_logs;
 		}
-
-		public override string LogNameFromSourceName (string source, string machineName)
-		{
-			return String.Empty;
-		}
-
-		public override bool SourceExists (string source, string machineName)
-		{
-			return false;
-		}
-
-		public override void WriteEntry (string source, string message, EventLogEntryType type, int eventID, short category, byte[] rawData)
-		{
-		}
 	}
 }
Index: System.Diagnostics/ChangeLog
===================================================================
--- System.Diagnostics/ChangeLog	(revision 63733)
+++ System.Diagnostics/ChangeLog	(working copy)
@@ -1,3 +1,42 @@
+2006-08-14  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* EventLogEntry.cs: Added InstanceId property (2.0 only). Moved
+	Obsolete attribute to correct property.
+	* EventSourceCreationData.cs: Updated copyright. For internal ctor,
+	set log name to "Application" if value is null or zero-length string.
+	* EventLogImpl.cs: EventImpl now acts as base class for event log 
+	implemenations.
+	* NullEventLog.cs: Modified to implement new abstract methods of base
+	class. Removed factory class.
+	* EventLog.cs: EventLog implementation that uses registry for
+	keeping track of logs and sources to match .NET (and Windows). To
+	specifiy the event log implementation to use, the MONO_EVENTLOG_TYPE
+	environment variable can be used. Possible values are:
+	- win32	: read/write entries using the native win32 eventlog
+	- local	: read/write entries as files to a local directory
+	- null	: silently ignore all entries
+	The default is "null", meaning entries will be silently ignored.
+	If the MONO_EVENTLOG_PATH environment variable is set (see below), 
+	and MONO_EVENTLOG_TYPE is not set then the local file implementation
+	will automatically be used.
+	* UnixEventLog.cs: Event log implementation for linux which uses a
+	local file store. The MONO_EVENTLOG_PATH environment can be used to
+	explicitly set the directory to use for storing eventlog entries.
+	If the MONO_EVENTLOG_PATH environment variable is not set, then the
+	following directory will be used for storing eventlog entries:
+	- windows	: %APPDATA%\mono\eventlog
+	- unix		: /var/lib/mono/eventlog
+	On unix, the directory permission for individual eventlog log 
+	directories is set to 777 (with +t bit) allowing everyone to read and
+	write eventlog entries while only allowing entries to be deleted by
+	the user(s) that created them.
+	* Win32EventLog.cs: Event log implementation for Windows NT and 
+	higher which uses the Win32 native event log. Currently, reading
+	eventlog entries is not implemented.
+	* EventLogEntryCollection.cs: Delegate implementation to event log
+	implemenation. Use lazy init for enumerating entries.
+
+
 2006-08-14  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* LocalFileEventLog.cs : change lengthy environment variable name.
Index: System.Diagnostics/EventLogEntry.cs
===================================================================
--- System.Diagnostics/EventLogEntry.cs	(revision 63733)
+++ System.Diagnostics/EventLogEntry.cs	(working copy)
@@ -31,6 +31,9 @@
 //
 
 using System.ComponentModel;
+#if NET_2_0
+using System.Runtime.InteropServices;
+#endif
 using System.Runtime.Serialization;
 using System.Security.Permissions;
 
@@ -56,12 +59,15 @@
 		private DateTime timeGenerated;
 		private DateTime timeWritten;
 		private string userName;
+#if NET_2_0
+		private long instanceId;
+#endif
 
 		internal EventLogEntry (string category, short categoryNumber, int index, 
-					int eventID, string message, string source,
-					string userName, string machineName, EventLogEntryType entryType,
-					DateTime timeGenerated, DateTime timeWritten, byte[] data,
-					string[] replacementStrings)
+					int eventID, string source, string message, string userName, 
+					string machineName, EventLogEntryType entryType, 
+					DateTime timeGenerated, DateTime timeWritten, byte[] data, 
+					string[] replacementStrings, long instanceId)
 		{
 			this.category = category;
 			this.categoryNumber = categoryNumber;
@@ -76,6 +82,9 @@
 			this.timeGenerated = timeGenerated;
 			this.timeWritten = timeWritten;
 			this.userName = userName;
+#if NET_2_0
+			this.instanceId = instanceId;
+#endif
 		}
 
 		[MonoTODO]
@@ -98,14 +107,14 @@
 			get { return data; }
 		}
 
-#if NET_2_0
-		[Obsolete ("Use InstanceId")]
-#endif
 		[MonitoringDescription ("The type of this event entry.")]
 		public EventLogEntryType EntryType {
 			get { return entryType; }
 		}
 
+#if NET_2_0
+		[Obsolete ("Use InstanceId")]
+#endif
 		[MonitoringDescription ("An ID number for this event entry.")]
 		public int EventID {
 			get { return eventID; }
@@ -116,6 +125,13 @@
 			get { return index; }
 		}
 
+#if NET_2_0
+		[ComVisible (false)]
+		public long InstanceId {
+			get { return instanceId; }
+		}
+#endif
+
 		[MonitoringDescription ("The Computer on which this event entry occured.")]
 		public string MachineName {
 			get { return machineName; }
Index: System.Diagnostics/EventSourceCreationData.cs
===================================================================
--- System.Diagnostics/EventSourceCreationData.cs	(revision 63733)
+++ System.Diagnostics/EventSourceCreationData.cs	(working copy)
@@ -1,10 +1,10 @@
 //
 // System.Diagnostics.EventSourceCreationData
 //
-// Authors:
-//	Gert Driesen (drieseng@users.sourceforge.net)
+// Author:
+//	Gert Driesen <driesen@users.sourceforge.net>
 //
-// (C) 2006 Novell
+// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
 //
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -45,14 +45,20 @@
 		int _categoryCount;
 
 		public EventSourceCreationData (string source, string logName)
-			: this (source, logName, ".")
 		{
+			_source = source;
+			_logName = logName;
+			_machineName = ".";
 		}
 
 		internal EventSourceCreationData (string source, string logName, string machineName)
 		{
 			_source = source;
-			_logName = logName;
+			if (logName == null || logName.Length == 0) {
+				_logName = "Application";
+			} else {
+				_logName = logName;
+			}
 			_machineName = machineName;
 		}
 
Index: System.Diagnostics/EventLogImpl.cs
===================================================================
--- System.Diagnostics/EventLogImpl.cs	(revision 63733)
+++ System.Diagnostics/EventLogImpl.cs	(working copy)
@@ -4,11 +4,11 @@
 // Authors:
 //   Andreas Nahr (ClassDevelopment@A-SoftTech.com)
 //   Atsushi Enomoto  <atsushi@ximian.com>
+//   Gert Driesen (drieseng@users.sourceforge.net)
 //
 // (C) 2003 Andreas Nahr
 // (C) 2006 Novell, Inc.
 //
-
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -31,134 +31,120 @@
 //
 
 using System;
-using System.Diagnostics;
 using System.ComponentModel;
 using System.ComponentModel.Design;
-using System.Collections;
+using System.Diagnostics;
 using System.Globalization;
-using System.IO;
-using System.Net;
 
+using Microsoft.Win32;
+
 namespace System.Diagnostics
 {
 	internal abstract class EventLogImpl
 	{
-		static EventLogFactory factory;
+		readonly EventLog _coreEventLog;
 
-		static EventLogImpl ()
+		protected EventLogImpl (EventLog coreEventLog)
 		{
-			factory = GetFactory ();
+			_coreEventLog = coreEventLog;
 		}
 
-		static EventLogFactory GetFactory ()
-		{
-			if (LocalFileEventLogUtil.IsEnabled)
-				return new LocalFileEventLogFactory ();
+		public event EntryWrittenEventHandler EntryWritten;
 
-			//throw new NotSupportedException (String.Format ("No EventLog implementation is supported. Consider setting MONO_LOCAL_EVENTLOG_PATH environment variable."));
-			return new NullEventLogFactory ();
+		protected EventLog CoreEventLog {
+			get { return _coreEventLog; }
 		}
 
-		EventLog log;
+		public int EntryCount {
+			get {
+				if (_coreEventLog.Log == null || _coreEventLog.Log.Length == 0) {
+					throw new ArgumentException ("Log property is not set.");
+				}
 
-		protected EventLogImpl (EventLog coreEventLog)
-		{
-			this.log = coreEventLog;
-		}
+				if (!EventLog.Exists (_coreEventLog.Log, _coreEventLog.MachineName)) {
+					throw new InvalidOperationException (string.Format (
+						CultureInfo.InvariantCulture, "The event log '{0}' on "
+						+ " computer '{1}' does not exist.", _coreEventLog.Log,
+						_coreEventLog.MachineName));
+				}
 
-		public static EventLogImpl Create (EventLog source)
-		{
-			return factory.Create (source);
+				return GetEntryCount ();
+			}
 		}
 
-		public static event EntryWrittenEventHandler EntryWritten;
+		public EventLogEntry this[int index] {
+			get {
+				if (_coreEventLog.Log == null || _coreEventLog.Log.Length == 0) {
+					throw new ArgumentException ("Log property is not set.");
+				}
 
-		public abstract EventLogEntryCollection Entries { get; }
+				if (!EventLog.Exists (_coreEventLog.Log, _coreEventLog.MachineName)) {
+					throw new InvalidOperationException (string.Format (
+						CultureInfo.InvariantCulture, "The event log '{0}' on "
+						+ " computer '{1}' does not exist.", _coreEventLog.Log,
+						_coreEventLog.MachineName));
+				}
 
-		public abstract string LogDisplayName { get; }
+				if (index < 0 || index >= EntryCount)
+					throw new ArgumentException ("Index out of range");
 
+				return GetEntry (index);
+			}
+		}
+
+		public string LogDisplayName {
+			get {
+#if NET_2_0
+				// to-do perform valid character checks
+				if (_coreEventLog.Log != null && _coreEventLog.Log.Length == 0) {
+					throw new InvalidOperationException ("Event log names must"
+						+ " consist of printable characters and cannot contain"
+						+ " \\, *, ?, or spaces.");
+				}
+#endif
+				if (_coreEventLog.Log != null) {
+					if (!EventLog.Exists (_coreEventLog.Log, _coreEventLog.MachineName)) {
+						throw new InvalidOperationException (string.Format (
+							CultureInfo.InvariantCulture, "Cannot find Log {0}"
+							+ " on computer {1}.", _coreEventLog.Log,
+							_coreEventLog.MachineName));
+					}
+				}
+
+				return GetLogDisplayName ();
+			}
+		}
+
 		public abstract void BeginInit ();
 
 		public abstract void Clear ();
 
 		public abstract void Close ();
 
-		public static void CreateEventSource (string source, string logName, string machineName)
-		{
-			factory.CreateEventSource (source, logName, machineName);
-		}
+		public abstract void CreateEventSource (EventSourceCreationData sourceData);
 
-		public static void Delete (string logName, string machineName)
-		{
-			factory.Delete (logName, machineName);
-		}
-
-		public static void DeleteEventSource (string source, string machineName)
-		{
-			factory.DeleteEventSource (source, machineName);
-		}
-
 		public abstract void Dispose (bool disposing);
 
 		public abstract void EndInit ();
 
-		public static bool Exists (string logName, string machineName)
-		{
-			return factory.Exists (logName, machineName);
-		}
+		public abstract EventLogEntry[] GetEntries ();
 
-		public static EventLog[] GetEventLogs (string machineName)
-		{
-			return factory.GetEventLogs (machineName);
-		}
+		protected abstract int GetEntryCount ();
 
-		public static string LogNameFromSourceName (string source, string machineName)
-		{
-			return factory.LogNameFromSourceName (source, machineName);
-		}
+		protected abstract EventLogEntry GetEntry (int index);
 
-		public static bool SourceExists (string source, string machineName)
-		{
-			return factory.SourceExists (source, machineName);
-		}
+		protected abstract string GetLogDisplayName ();
 
+		protected abstract void WriteEventLogEntry (EventLogEntry entry);
+
 		public void WriteEntry (string message, EventLogEntryType type, int eventID, short category, byte[] rawData)
 		{
-			WriteEntry (log.Source, message, type, eventID, category, rawData);
+			EventLogEntry entry = new EventLogEntry (string.Empty, category, 0, eventID,
+				_coreEventLog.Source, message, string.Empty, _coreEventLog.MachineName,
+				type, DateTime.Now, DateTime.Now, rawData, new string [] { message }, eventID);
+			WriteEventLogEntry (entry);
+			if (EntryWritten != null)
+				EntryWritten (null, new EntryWrittenEventArgs (entry));
 		}
-
-		public static void WriteEntry (string source, string message, EventLogEntryType type, int eventID, short category, byte[] rawData)
-		{
-			factory.WriteEntry (source, message, type, eventID, category, rawData);
-			if (EntryWritten != null) {
-				// FIXME: some arguments are improper.
-				EventLogEntry e = new EventLogEntry ("",
-					category, 0, eventID, message, source,
-					"", ".", type, DateTime.Now, DateTime.Now,
-					rawData, null);
-				EntryWritten (null, new EntryWrittenEventArgs (e));
-			}
-		}
 	}
-
-	internal abstract class EventLogFactory
-	{
-		public abstract EventLogImpl Create (EventLog source);
-
-		public abstract void CreateEventSource (string source, string logName, string machineName);
-
-		public abstract void Delete (string logName, string machineName);
-
-		public abstract void DeleteEventSource (string source, string machineName);
-
-		public abstract bool Exists (string logName, string machineName);
-
-		public abstract EventLog[] GetEventLogs (string machineName);
-
-		public abstract string LogNameFromSourceName (string source, string machineName);
-
-		public abstract bool SourceExists (string source, string machineName);
-
-		public abstract void WriteEntry (string source, string message, EventLogEntryType type, int eventID, short category, byte[] rawData);
-	}
 }
Index: System.Diagnostics/Win32EventLog.cs
===================================================================
--- System.Diagnostics/Win32EventLog.cs	(revision 0)
+++ System.Diagnostics/Win32EventLog.cs	(revision 0)
@@ -0,0 +1,234 @@
+//
+// System.Diagnostics.Win32EventLog.cs
+//
+// Author:
+//	Gert Driesen <driesen@users.sourceforge.net>
+//
+// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
+//
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.ComponentModel;
+using System.Diagnostics;
+using System.Globalization;
+using System.Runtime.InteropServices;
+
+namespace System.Diagnostics
+{
+	internal class Win32EventLog : EventLogImpl
+	{
+		private int _oldestEventLogEntry = -1;
+
+		public Win32EventLog (EventLog coreEventLog) : base (coreEventLog)
+		{
+		}
+
+		public override void BeginInit () { }
+
+		public override void Clear () {
+			IntPtr hEventLog = OpenEventLog ();
+			int ret = PInvoke.ClearEventLog (hEventLog, null);
+			if (ret != 1) {
+				throw new Win32Exception (Marshal.GetLastWin32Error ());
+			}
+			CloseEventLog (hEventLog);
+		}
+
+		public override void Close () {
+			// we don't hold any unmanaged resources
+		}
+
+		public override void CreateEventSource (EventSourceCreationData sourceData)
+		{
+		}
+
+		public override void Dispose (bool disposing) {
+			Close ();
+		}
+
+		public override void EndInit () { }
+
+		public override EventLogEntry[] GetEntries ()
+		{
+			return new EventLogEntry[0];
+		}
+
+		protected override int GetEntryCount ()
+		{
+			IntPtr hEventLog = OpenEventLog ();
+			try {
+				int entryCount = 0;
+				int retVal = PInvoke.GetNumberOfEventLogRecords (hEventLog, ref entryCount);
+				if (retVal != 1) {
+					throw new Win32Exception (Marshal.GetLastWin32Error ());
+				}
+				return entryCount;
+			} finally {
+				CloseEventLog (hEventLog);
+			}
+		}
+
+		[MonoTODO ("Read buffer data")]
+		protected override EventLogEntry GetEntry (int index)
+		{
+			index += OldestEventLogEntry;
+
+			IntPtr hEventLog = OpenEventLog ();
+			try {
+				int bytesRead = 0;
+				int minBufferNeeded = 0;
+				byte[] buffer = new byte[0x7ffff]; // according to MSDN this is the max size of the buffer
+
+				int ret = PInvoke.ReadEventLog (hEventLog, ReadFlags.Seek |
+					ReadFlags.ForwardsRead, index, buffer, buffer.Length,
+					ref bytesRead, ref minBufferNeeded);
+				if (ret != 1) {
+					throw new InvalidOperationException ("Event log cannot be read.");
+				}
+
+				// TODO read data from buffer and construct EventLogEntry !!!!!!!!!!!!
+				return null;
+			} finally {
+				CloseEventLog (hEventLog);
+			}
+		}
+
+		[MonoTODO]
+		protected override string GetLogDisplayName ()
+		{
+			return CoreEventLog.Log;
+		}
+
+		protected override void WriteEventLogEntry (EventLogEntry entry)
+		{
+			IntPtr hEventLog = OpenEventLog ();
+			try {
+				byte[] rawData = (entry.Data == null) ? new byte[0] : entry.Data;
+				int ret = PInvoke.ReportEvent (hEventLog, (ushort) entry.EntryType,
+					(ushort) entry.CategoryNumber, (uint) entry.EventID, IntPtr.Zero,
+					(ushort) 1, (uint) rawData.Length, new string[] { entry.Message },
+					rawData);
+				if (ret != 1) {
+					throw new Win32Exception (Marshal.GetLastWin32Error ());
+				}
+			} finally {
+				CloseEventLog (hEventLog);
+			}
+		}
+
+		private int OldestEventLogEntry {
+			get {
+				if (_oldestEventLogEntry == -1) {
+					IntPtr hEventLog = OpenEventLog ();
+					try {
+						int ret = PInvoke.GetOldestEventLogRecord (hEventLog, ref _oldestEventLogEntry);
+						if (ret != 1) {
+							throw new Win32Exception (Marshal.GetLastWin32Error ());
+						}
+					} finally {
+						CloseEventLog (hEventLog);
+					}
+				}
+
+				return _oldestEventLogEntry;
+			}
+		}
+
+
+		private IntPtr OpenEventLog ()
+		{
+			string logName = CoreEventLog.GetLogName ();
+			IntPtr hEventLog = PInvoke.OpenEventLog (CoreEventLog.MachineName,
+				logName);
+			if (hEventLog == IntPtr.Zero) {
+				// TODO: include cause of error
+				throw new InvalidOperationException (string.Format (
+					CultureInfo.InvariantCulture, "Event Log '{0}' on computer"
+					+ " '{1}' cannot be opened."));
+			}
+			return hEventLog;
+		}
+
+		private void CloseEventLog (IntPtr hEventLog)
+		{
+			int ret = PInvoke.CloseEventLog (hEventLog);
+			if (ret != 1) {
+				throw new Win32Exception (Marshal.GetLastWin32Error ());
+			}
+		}
+
+		private class PInvoke
+		{
+			[DllImport ("advapi32.dll", SetLastError=true)]
+			public static extern int ClearEventLog (IntPtr hEventLog, string lpBackupFileName);
+
+			[DllImport ("advapi32.dll", SetLastError=true)]
+			public static extern int CloseEventLog (IntPtr hEventLog);
+
+			[DllImport ("advapi32.dll", SetLastError=true)]
+			public static extern int GetNumberOfEventLogRecords (IntPtr hEventLog, ref int NumberOfRecords);
+
+			[DllImport ("advapi32.dll", SetLastError=true)]
+			public static extern int GetOldestEventLogRecord (IntPtr hEventLog, ref int OldestRecord);
+
+			[DllImport ("advapi32.dll", SetLastError=true)]
+			public static extern IntPtr OpenEventLog (string machineName, string logName);
+
+			[DllImport ("Advapi32.dll", SetLastError=true)]
+			public static extern int ReportEvent (IntPtr hHandle, ushort wType,
+				ushort wCategory, uint dwEventID, IntPtr sid, ushort wNumStrings,
+				uint dwDataSize, string[] lpStrings, byte[] lpRawData);
+
+			[DllImport ("advapi32.dll", SetLastError=true)]
+			public static extern int ReadEventLog (IntPtr hEventLog, ReadFlags dwReadFlags, int dwRecordOffset, byte[] buffer, int nNumberOfBytesToRead, ref int pnBytesRead, ref int pnMinNumberOfBytesNeeded);
+		}
+
+		private enum ReadFlags
+		{
+			Sequential = 0x001,
+			Seek = 0x002,
+			ForwardsRead = 0x004,
+			BackwardsRead = 0x008
+		}
+	}
+}
+
+// http://msdn.microsoft.com/library/en-us/eventlog/base/eventlogrecord_str.asp:
+//
+// struct EVENTLOGRECORD {
+//	int Length;
+//	int Reserved;
+//	int RecordNumber;
+//	int TimeGenerated;
+//	int TimeWritten;
+//	int EventID;
+//	ushort EventType;
+//	ushort NumStrings;
+//	ushort EventCategory;
+//	ushort ReservedFlags;
+//	int ClosingRecordNumber;
+//	int StringOffset;
+//	int UserSidLength;
+//	int UserSidOffset;
+//	int DataLength;  DWORD DataOffset;
+// }

Property changes on: System.Diagnostics/Win32EventLog.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Index: System.Diagnostics/EventLogEntryCollection.cs
===================================================================
--- System.Diagnostics/EventLogEntryCollection.cs	(revision 63733)
+++ System.Diagnostics/EventLogEntryCollection.cs	(working copy)
@@ -37,44 +37,81 @@
 
 	public class EventLogEntryCollection : ICollection, IEnumerable {
 
-		private ArrayList eventLogs = new ArrayList ();
+		readonly EventLogImpl _impl;
 
-		internal EventLogEntryCollection(IEnumerable entries)
+		internal EventLogEntryCollection(EventLogImpl impl)
 		{
-			foreach (object entry in entries)
-				eventLogs.Add (entry);
+			_impl = impl;
 		}
 
 		public int Count {
-			get {return eventLogs.Count;}
+			get { return _impl.EntryCount; }
 		}
 
 		public virtual EventLogEntry this [int index] {
-			get {return (EventLogEntry) eventLogs[index];}
+			get { return _impl[index]; }
 		}
 
 		bool ICollection.IsSynchronized {
-			get {return eventLogs.IsSynchronized;}
+			get { return false; }
 		}
 
 		object ICollection.SyncRoot {
-			get {return eventLogs.SyncRoot;}
+			get { return this; }
 		}
 
-		public void CopyTo (EventLogEntry[] eventLogs, int index)
+		public void CopyTo (EventLogEntry[] eventLogEntries, int index)
 		{
-			eventLogs.CopyTo (eventLogs, index);
+			EventLogEntry[] entries = _impl.GetEntries ();
+			Array.Copy (entries, 0, eventLogEntries, index, entries.Length);
 		}
 
 		public IEnumerator GetEnumerator ()
 		{
-			return eventLogs.GetEnumerator ();
+			return new EventLogEntryEnumerator (_impl);
 		}
 
 		void ICollection.CopyTo (Array array, int index)
 		{
-			eventLogs.CopyTo (array, index);
+			EventLogEntry[] entries = _impl.GetEntries ();
+			Array.Copy (entries, 0, array, index, entries.Length);
 		}
-	}
+
+		private class EventLogEntryEnumerator : IEnumerator
+		{
+			internal EventLogEntryEnumerator (EventLogImpl impl)
+			{
+				_impl = impl;
+			}
+
+			object IEnumerator.Current {
+				get { return Current; }
+			}
+
+			public EventLogEntry Current
+			{
+				get { return _currentEntry; }
+			}
+
+			public bool MoveNext ()
+			{
+				_currentIndex++;
+				if (_currentIndex >= _impl.EntryCount)
+					return false;
+				_currentEntry = _impl[_currentIndex];
+				return _currentEntry != null;
+			}
+
+			public void Reset ()
+			{
+				_currentIndex = - 1;
+				_currentEntry = null;
+			}
+
+			readonly EventLogImpl _impl;
+			int _currentIndex = -1;
+			EventLogEntry _currentEntry;
+		}
 }
+}
 
Index: System.Diagnostics/EventLog.cs
===================================================================
--- System.Diagnostics/EventLog.cs	(revision 63733)
+++ System.Diagnostics/EventLog.cs	(working copy)
@@ -2,13 +2,14 @@
 // System.Diagnostics.EventLog.cs
 //
 // Authors:
-//   Jonathan Pryor (jonpryor@vt.edu)
-//   Andreas Nahr (ClassDevelopment@A-SoftTech.com)
+//	Jonathan Pryor (jonpryor@vt.edu)
+//	Andreas Nahr (ClassDevelopment@A-SoftTech.com)
+//	Gert Driesen (drieseng@users.sourceforge.net)
 //
-// (C) 2002
-// (C) 2003 Andreas Nahr
+// Copyright (C) 2002
+// Copyright (C) 2003 Andreas Nahr
+// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
 //
-
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -32,9 +33,14 @@
 
 using System;
 using System.Diagnostics;
+using System.Collections;
 using System.ComponentModel;
 using System.ComponentModel.Design;
+using System.Globalization;
+using System.IO;
 
+using Microsoft.Win32;
+
 namespace System.Diagnostics 
 {
 	[DefaultEvent ("EntryWritten")]
@@ -42,17 +48,24 @@
 	[Designer ("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, " + Consts.AssemblyMicrosoft_VisualStudio)]
 	public class EventLog : Component, ISupportInitialize 
 	{
-
 		private string source;
 		private string logName;
 		private string machineName;
 		private bool doRaiseEvents = false;
 		private ISynchronizeInvoke synchronizingObject = null;
 
+		// IMPORTANT: also update constants in EventLogTest
+		private const string LOCAL_FILE_IMPL = "local";
+		private const string NATIVE_WIN32_IMPL = "win32";
+		private const string NULL_IMPL = "null";
+
+		private const string EVENTLOG_TYPE_VAR = "MONO_EVENTLOG_TYPE";
+		internal const string EVENTLOG_PATH_VAR = "MONO_EVENTLOG_PATH";
+
 		private EventLogImpl Impl;
 
 		public EventLog()
-			: this ("")
+			: this (string.Empty)
 		{
 		}
 
@@ -61,19 +74,27 @@
 		{
 		}
 
-		public EventLog(string logName, string machineName) 
-			: this (logName, machineName, "")
+		public EventLog(string logName, string machineName)
+			: this (logName, machineName, string.Empty)
 		{
 		}
 
 		public EventLog(string logName, string machineName, string source)
 		{
+			if (logName == null) {
+				throw new ArgumentNullException ("logName");
+			}
+			if (machineName == null || machineName.Length == 0)
+				throw new ArgumentException (string.Format (
+					CultureInfo.InvariantCulture, "Invalid value '{0}' for"
+					+ " parameter 'machineName'.", machineName));
+
 			this.source = source;
 			this.machineName = machineName;
 			this.logName = logName;
 
-			this.Impl = EventLogImpl.Create (this);
-			EventLogImpl.EntryWritten += new EntryWrittenEventHandler (EntryWrittenHandler);
+			Impl = CreateEventLogImpl (this);
+			Impl.EntryWritten += new EntryWrittenEventHandler (EntryWrittenHandler);
 		}
 
 		private void EntryWrittenHandler (object sender, EntryWrittenEventArgs e)
@@ -92,15 +113,23 @@
 		[Browsable (false), DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
 		[MonitoringDescription ("The entries in the log.")]
 		public EventLogEntryCollection Entries {
-			get {return Impl.Entries;}
+			get {return new EventLogEntryCollection(Impl);}
 		}
 
 		[ReadOnly (true), DefaultValue (""), RecommendedAsConfigurable (true)]
 		[TypeConverter ("System.Diagnostics.Design.LogConverter, " + Consts.AssemblySystem_Design)]
 		[MonitoringDescription ("Name of the log that is read and written.")]
 		public string Log {
-			get {return logName;}
-			set {logName = value;}
+			get {
+				if (source != null && source.Length > 0)
+					return GetLogName ();
+				return logName;
+			}
+			set {
+				if (value == null)
+					throw new ArgumentNullException ("value");
+				logName = value;
+			}
 		}
 
 		[Browsable (false)]
@@ -119,8 +148,8 @@
 		[TypeConverter ("System.Diagnostics.Design.StringValueConverter, " + Consts.AssemblySystem_Design)]
 		[MonitoringDescription ("The application name that writes the log.")]
 		public string Source {
-			get {return source;}
-			set {source = value;}
+			get { return source; }
+			set { source = (value == null) ? string.Empty : value; }
 		}
 
 		[Browsable (false), DefaultValue (null)]
@@ -154,17 +183,143 @@
 			string logName, 
 			string machineName)
 		{
-			EventLogImpl.CreateEventSource (source, logName, machineName);
+			CreateEventSource (new EventSourceCreationData (source, logName,
+				machineName));
 		}
 
+#if NET_2_0
+		[MonoTODO ("Support remote machine")]
+		public
+#else
+		private
+#endif
+		static void CreateEventSource (EventSourceCreationData sourceData)
+		{
+			if (sourceData.Source == null || sourceData.Source.Length == 0) {
+				throw new ArgumentException ("Source is not set");
+			}
+			if (sourceData.LogName == null || sourceData.LogName.Length == 0) {
+				throw new ArgumentException ("LogName is not set");
+			}
+
+			if (SourceExists (sourceData.Source, sourceData.MachineName)) {
+				throw new ArgumentException (string.Format (CultureInfo.InvariantCulture,
+					"Source '{0}' already exists on '{1}'.", sourceData.Source,
+					sourceData.MachineName));
+			}
+
+			using (RegistryKey eventLogKey = GetEventLogKey (sourceData.MachineName, true)) {
+				if (eventLogKey == null)
+					throw new InvalidOperationException ("EventLog registry key is missing.");
+
+				bool logKeyCreated = false;
+				RegistryKey logKey = null;
+				try {
+					logKey = eventLogKey.OpenSubKey (sourceData.LogName, true);
+					if (logKey == null) {
+						logKey = eventLogKey.CreateSubKey (sourceData.LogName);
+						logKey.SetValue ("Sources", new string[] { sourceData.LogName,
+							sourceData.Source });
+						UpdateLogRegistry (logKey);
+
+						using (RegistryKey sourceKey = logKey.CreateSubKey (sourceData.LogName)) {
+							UpdateSourceRegistry (sourceKey, sourceData);
+						}
+
+						logKeyCreated = true;
+					}
+
+					try {
+						EventLogImpl impl = CreateEventLogImpl (sourceData.LogName,
+							sourceData.MachineName, sourceData.Source);
+						impl.CreateEventSource (sourceData);
+					} catch (Exception) {
+						if (logKeyCreated) {
+							try {
+								eventLogKey.DeleteSubKeyTree (sourceData.LogName);
+							} catch {
+							}
+						}
+						throw;
+					}
+
+					if (sourceData.LogName != sourceData.Source) {
+						if (!logKeyCreated) {
+							string[] sources = (string[]) logKey.GetValue ("Sources");
+							if (sources == null) {
+								logKey.SetValue ("Sources", new string[] { sourceData.LogName,
+									sourceData.Source });
+							} else {
+								bool found = false;
+								for (int i = 0; i < sources.Length; i++) {
+									if (sources[i] == sourceData.Source) {
+										found = true;
+										break;
+									}
+								}
+								if (!found) {
+									string[] newSources = new string[sources.Length + 1];
+									Array.Copy (sources, 0, newSources, 0, sources.Length);
+									newSources[sources.Length] = sourceData.Source;
+									logKey.SetValue ("Sources", newSources);
+								}
+							}
+						}
+						using (RegistryKey sourceKey = logKey.CreateSubKey (sourceData.Source)) {
+							UpdateSourceRegistry (sourceKey, sourceData);
+						}
+					}
+				} finally {
+					if (logKey != null)
+						logKey.Close ();
+				}
+			}
+		}
+
 		public static void Delete(string logName)
 		{
 			Delete (logName, ".");
 		}
 
-		public static void Delete(string logName, string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static void Delete (string logName, string machineName)
 		{
-			EventLogImpl.Delete (logName, machineName);
+			if (machineName == null || machineName.Length == 0)
+				throw new ArgumentException ("Invalid format for argument"
+					+ " machineName.");
+
+			if (logName == null || logName.Length == 0)
+				throw new ArgumentException ("Log to delete was not specified.");
+
+			using (RegistryKey eventLogKey = GetEventLogKey (machineName, true)) {
+				if (eventLogKey == null)
+					throw new InvalidOperationException ("The event log key does not exist.");
+
+				using (RegistryKey logKey = eventLogKey.OpenSubKey (logName, false)) {
+					if (logKey == null)
+						throw new InvalidOperationException (string.Format (
+							CultureInfo.InvariantCulture, "Event Log '{0}'"
+							+ " does not exist on computer '{1}'.", logName,
+							machineName));
+
+					// remove all eventlog entries for specified log
+					using (EventLog eventLog = new EventLog (logName, machineName)) {
+						eventLog.Clear ();
+					}
+
+					// remove file holding event log entries
+					string file = (string) logKey.GetValue ("File");
+					if (file != null) {
+						try {
+							File.Delete (file);
+						} catch (Exception) {
+							// .NET seems to ignore failures here
+						}
+					}
+				}
+
+				eventLogKey.DeleteSubKeyTree (logName);
+			}
 		}
 
 		public static void DeleteEventSource(string source)
@@ -172,13 +327,37 @@
 			DeleteEventSource (source, ".");
 		}
 
-		public static void DeleteEventSource(string source, 
-			string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static void DeleteEventSource (string source, string machineName)
 		{
-			EventLogImpl.DeleteEventSource (source, machineName);
+			if (machineName == null || machineName.Length == 0)
+				throw new ArgumentException (string.Format (
+					CultureInfo.InvariantCulture, "Invalid value '{0}' for"
+					+ " parameter 'machineName'.", machineName));
+
+			using (RegistryKey logKey = FindLogKeyBySource (source, machineName, true)) {
+				if (logKey == null) {
+					throw new ArgumentException (string.Format (
+						CultureInfo.InvariantCulture, "The source '{0}' is not"
+						+ " registered on computer '{1}'.", source, machineName));
+				}
+
+				logKey.DeleteSubKeyTree (source);
+
+				string[] sources = (string[]) logKey.GetValue ("Sources");
+				if (sources != null) {
+					ArrayList temp = new ArrayList ();
+					for (int i = 0; i < sources.Length; i++)
+						if (sources[i] != source)
+							temp.Add (sources[i]);
+					string[] newSources = new string[temp.Count];
+					temp.CopyTo (newSources, 0);
+					logKey.SetValue ("Sources", newSources);
+				}
+			}
 		}
 
-		protected override void Dispose(bool disposing)
+		protected override void Dispose (bool disposing)
 		{
 			Impl.Dispose (disposing);
 		}
@@ -193,25 +372,45 @@
 			return Exists (logName, ".");
 		}
 
-		public static bool Exists(string logName, string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static bool Exists (string logName, string machineName)
 		{
-			return EventLogImpl.Exists (logName, machineName);
+			using (RegistryKey logKey = FindLogKeyByName (logName, machineName, false)) {
+				return (logKey != null);
+			}
 		}
 
-		public static EventLog[] GetEventLogs()
+		public static EventLog[] GetEventLogs ()
 		{
 			return GetEventLogs (".");
 		}
 
-		public static EventLog[] GetEventLogs(string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static EventLog[] GetEventLogs (string machineName)
 		{
-			return EventLogImpl.GetEventLogs (machineName);
+			using (RegistryKey eventLogKey = GetEventLogKey (machineName, false)) {
+				if (eventLogKey == null) {
+					throw new InvalidOperationException ("TODO");
+				}
+				string[] logNames = eventLogKey.GetSubKeyNames ();
+				EventLog[] eventLogs = new EventLog[logNames.Length];
+				for (int i = 0; i < logNames.Length; i++) {
+					EventLog eventLog = new EventLog (logNames[i], machineName);
+					eventLogs[i] = eventLog;
+				}
+				return eventLogs;
+			}
 		}
 
-		public static string LogNameFromSourceName(string source, 
-			string machineName)
+		[MonoTODO ("Support remote machine")]
+		public static string LogNameFromSourceName (string source, string machineName)
 		{
-			return EventLogImpl.LogNameFromSourceName (source, machineName);
+			using (RegistryKey logKey = FindLogKeyBySource (source, machineName, false)) {
+				if (logKey == null)
+					return string.Empty;
+
+				return GetLogName (logKey);
+			}
 		}
 
 		public static bool SourceExists(string source)
@@ -219,9 +418,20 @@
 			return SourceExists (source, ".");
 		}
 
-		public static bool SourceExists(string source, string machineName)
+		[MonoTODO ("Support remote machines")]
+		public static bool SourceExists (string source, string machineName)
 		{
-			return EventLogImpl.SourceExists (source, machineName);
+			if (machineName == null || machineName.Length == 0)
+				throw new ArgumentException (string.Format (
+					CultureInfo.InvariantCulture, "Invalid value '{0}' for"
+					+ " parameter 'machineName'.", machineName));
+
+			RegistryKey logKey = FindLogKeyBySource (source, machineName, false);
+			if (logKey != null) {
+				logKey.Close ();
+				return true;
+			}
+			return false;
 		}
 
 		public void WriteEntry(string message)
@@ -244,6 +454,18 @@
 			int eventID,
 			short category)
 		{
+			if (Source.Length == 0) {
+				throw new ArgumentException ("Source property was not set"
+					+ "before writing to the event log.");
+			}
+
+			if (!SourceExists (Source, MachineName)) {
+				if (Log == null || Log.Length == 0) {
+					Log = "Application";
+				}
+				CreateEventSource (Source, Log, MachineName);
+			}
+
 			WriteEntry (message, type, eventID, category, null);
 		}
 
@@ -281,7 +503,10 @@
 			EventLogEntryType type, int eventID, short category, 
 			byte[] rawData)
 		{
-			EventLogImpl.WriteEntry (source, message, type, eventID, category, rawData);
+			using (EventLog eventLog = new EventLog ()) {
+				eventLog.Source = source;
+				eventLog.WriteEntry (message, type, eventID, category, rawData);
+			}
 		}
 
 		internal void OnEntryWritten (EventLogEntry newEntry)
@@ -292,6 +517,174 @@
 
 		[MonitoringDescription ("Raised for each EventLog entry written.")]
 		public event EntryWrittenEventHandler EntryWritten;
+
+		internal string GetLogName ()
+		{
+			if (logName != null && logName.Length > 0)
+				return logName;
+
+			// if no log name has been set, then use source to determine name of log
+			logName = LogNameFromSourceName (source, machineName);
+			return logName;
+		}
+
+		private static EventLogImpl CreateEventLogImpl (string logName, string machineName, string source)
+		{
+			EventLog eventLog = new EventLog (logName, machineName, source);
+			return CreateEventLogImpl (eventLog);
+		}
+
+		private static EventLogImpl CreateEventLogImpl (EventLog eventLog)
+		{
+			switch (EventLogImplType) {
+			case LOCAL_FILE_IMPL:
+				return new UnixEventLog (eventLog);
+			case NATIVE_WIN32_IMPL:
+				return new Win32EventLog (eventLog);
+			case NULL_IMPL:
+				return new NullEventLog (eventLog);
+			default:
+				// we should never get there
+				throw new NotSupportedException (string.Format (
+					CultureInfo.InvariantCulture, "Eventlog implementation"
+					+ " '{0}' is not supported.", EventLogImplType));
+			}
+		}
+
+		private static bool Win32EventLogEnabled {
+			get {
+				return (Environment.OSVersion.Platform == PlatformID.Win32NT);
+			}
+		}
+
+		// IMPORTANT: also modify corresponding property in EventLogTest
+		private static string EventLogImplType
+		{
+			get {
+				string implType = Environment.GetEnvironmentVariable (EVENTLOG_TYPE_VAR);
+				if (implType == null) {
+					// if user explicitly set the eventlog file path, then assume
+					// he wants to enable the local file implementation
+					string filePath = Environment.GetEnvironmentVariable (EVENTLOG_PATH_VAR);
+					if (filePath != null)
+						return LOCAL_FILE_IMPL;
+					// FIXME: enable the commented code once reading eventlog
+					// entries has been implemented for the native win32
+					// eventlog implementation
+					/*
+					if (Win32EventLogEnabled)
+						return NATIVE_WIN32_IMPL;
+					*/
+					implType = NULL_IMPL;
+				} else {
+					if (string.Compare (implType, LOCAL_FILE_IMPL, true) == 0)
+						implType = LOCAL_FILE_IMPL;
+					else if (string.Compare (implType, NATIVE_WIN32_IMPL, true) == 0)
+						implType = NATIVE_WIN32_IMPL;
+					else if (string.Compare (implType, NULL_IMPL, true) == 0)
+						implType = NULL_IMPL;
+					else 
+						throw new NotSupportedException (string.Format (
+							CultureInfo.InvariantCulture, "Eventlog implementation"
+							+ " '{0}' is not supported.", implType));
+				}
+				return implType;
+			}
+		}
+
+		private static void UpdateLogRegistry (RegistryKey logKey)
+		{
+			if (!Win32EventLogEnabled)
+				return;
+
+			// TODO: write other Log values:
+			// - MaxSize
+			// - Retention
+			// - AutoBackupLogFiles
+
+			if (logKey.GetValue ("File") == null) {
+				string logName = GetLogName (logKey);
+				string file;
+				if (logName.Length > 8) {
+					file = logName.Substring (0, 8) + ".evt";
+				} else {
+					file = logName + ".evt";
+				}
+				string configPath = Path.Combine (Environment.GetFolderPath (
+					Environment.SpecialFolder.System), "config");
+				logKey.SetValue ("File", Path.Combine (configPath, file));
+			}
+
+		}
+
+		private static void UpdateSourceRegistry (RegistryKey sourceKey, EventSourceCreationData data)
+		{
+			if (data.CategoryCount > 0)
+				sourceKey.SetValue ("CategoryCount", data.CategoryCount);
+
+			if (data.CategoryResourceFile != null && data.CategoryResourceFile.Length > 0)
+				sourceKey.SetValue ("CategoryMessageFile", data.CategoryResourceFile);
+
+			if (data.MessageResourceFile != null && data.MessageResourceFile.Length > 0)
+				sourceKey.SetValue ("EventMessageFile", data.MessageResourceFile);
+
+			if (data.ParameterResourceFile != null && data.ParameterResourceFile.Length > 0)
+				sourceKey.SetValue ("ParameterMessageFile", data.ParameterResourceFile);
+		}
+
+		private static string GetLogName (RegistryKey logKey) {
+			string logName = logKey.Name;
+			return logName.Substring (logName.LastIndexOf ("\\") + 1);
+		}
+
+		[MonoTODO ("Support remote machines")]
+		private static RegistryKey GetEventLogKey (string machineName, bool writable)
+		{
+			return Registry.LocalMachine.OpenSubKey (@"SYSTEM\CurrentControlSet\Services\EventLog", writable);
+		}
+
+		private static RegistryKey FindLogKeyByName (string logName, string machineName, bool writable)
+		{
+			using (RegistryKey eventLogKey = GetEventLogKey (machineName, writable)) {
+				if (eventLogKey == null) {
+					return null;
+				}
+
+				return eventLogKey.OpenSubKey (logName, writable);
+			}
+		}
+
+		private static RegistryKey FindLogKeyBySource (string source, string machineName, bool writable)
+		{
+			if (source == null || source.Length == 0)
+				return null;
+
+			RegistryKey eventLogKey = null;
+			try {
+				eventLogKey = GetEventLogKey (machineName, writable);
+				if (eventLogKey == null)
+					return null;
+
+				string[] subKeys = eventLogKey.GetSubKeyNames ();
+				for (int i = 0; i < subKeys.Length; i++) {
+					RegistryKey sourceKey = null;
+					try {
+						RegistryKey logKey = eventLogKey.OpenSubKey (subKeys[i], writable);
+						if (logKey != null) {
+							sourceKey = logKey.OpenSubKey (source, writable);
+							if (sourceKey != null)
+								return logKey;
+						}
+					} finally {
+						if (sourceKey != null)
+							sourceKey.Close ();
+					}
+				}
+				return null;
+			} finally {
+				if (eventLogKey != null)
+					eventLogKey.Close ();
+			}
+		}
 	}
 }
-
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 63733)
+++ ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2006-08-14  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* System.dll.sources: Added UnixEventLog.cs and Win32EventLog.cs.
+	Removed LocalFileEventLog.cs.
+
 2006-08-14  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* System.dll.sources : added LocalFileEventLog.cs and NullEventLog.cs.
