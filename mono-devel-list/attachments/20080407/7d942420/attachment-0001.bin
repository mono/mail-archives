Index: build/library.make
===================================================================
--- build/library.make	(revision 99955)
+++ build/library.make	(working copy)
@@ -60,7 +60,7 @@
 endif
 
 ifndef NO_TEST
-test_nunit_lib = nunit.framework.dll nunit.core.dll nunit.util.dll
+test_nunit_lib = nunit.framework.dll nunit.core.dll nunit.util.dll nunit.mocks.dll
 test_nunit_dep = $(test_nunit_lib:%=$(topdir)/class/lib/$(PROFILE)/%)
 test_nunit_ref = $(test_nunit_dep:%=-r:%)
 library_CLEAN_FILES += TestResult*.xml
Index: build/ChangeLog
===================================================================
--- build/ChangeLog	(revision 99955)
+++ build/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2008-04-06  Michael Barker <mike@middlesoft.co.uk>
+
+	* library.make: Added nunit.mocks.dll to this list of nunit
+	assembilies
+
 2008-03-24  Zoltan Varga  <vargaz@gmail.com>
 
 	* library.make (check): Add a standard check target and make it the same as
Index: class/System.Messaging/Test/System.Messaging/BinaryMessageFormatterTest.cs
===================================================================
--- class/System.Messaging/Test/System.Messaging/BinaryMessageFormatterTest.cs	(revision 0)
+++ class/System.Messaging/Test/System.Messaging/BinaryMessageFormatterTest.cs	(revision 0)
@@ -0,0 +1,109 @@
+//
+// BinaryMessageFormatterTest.cs -
+//      NUnit Test Cases for BinaryMessageFormatter
+//
+// Author:
+//      Michael Barker  <mike@middlesoft.co.uk>
+//
+// Copyright (C) 2008 Michael Barker
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Messaging;
+
+using NUnit.Framework;
+
+namespace MonoTests.System.Messaging
+{
+	[TestFixture]
+	public class BinaryMessageFormatterTest
+	{
+		[Test]
+		public void FormatString ()
+		{
+			string s = "this is a test string";
+			Console.Out.Flush ();
+			Message m = new Message ();
+			m.Formatter = new BinaryMessageFormatter ();
+			m.Formatter.Write (m, s);
+			
+			Stream stream = m.BodyStream;
+			Assert.IsTrue (stream.Length > 0);
+			
+			Message m2 = new Message ();
+			m2.Formatter = new BinaryMessageFormatter ();
+			m2.BodyStream = stream;
+			
+			Assert.AreEqual(s, m2.Formatter.Read (m2), "The string did not serialise/deserialise properly");
+		}
+		
+		[Serializable]
+		private class Thingy
+		{
+			private int iii;
+			private string sss;
+			private DateTime ttt;
+			
+			public int Iii {
+				get { return iii; }
+				set { iii = value; }
+			}
+			
+			public string Sss {
+				get { return sss; }
+				set { sss = value; }
+			}
+			
+			public DateTime Ttt {
+				get { return ttt; }
+				set { ttt = value; }
+			}
+		}
+		
+		[Test]
+		public void FormatComplexObject ()
+		{
+			Thingy t0 = new Thingy();
+			t0.Iii = 42;
+			t0.Sss = "Some Text";
+			t0.Ttt = DateTime.Now;
+			
+			Message m = new Message ();
+			m.Formatter = new BinaryMessageFormatter ();
+			m.Formatter.Write (m, t0);
+			Stream stream = m.BodyStream;
+			
+			Assert.IsTrue (stream.Length > 0);
+			
+			Message m2 = new Message ();
+			m2.Formatter = new BinaryMessageFormatter ();
+			m2.BodyStream = stream;
+			Thingy t1 = (Thingy) m2.Formatter.Read (m2);
+			
+			Assert.AreEqual(t0.Iii, t1.Iii, "The string did not serialise/deserialise properly");
+			Assert.AreEqual(t0.Sss, t1.Sss, "The string did not serialise/deserialise properly");
+			Assert.AreEqual(t0.Ttt, t1.Ttt, "The string did not serialise/deserialise properly");
+		}
+		
+	}
+}
Index: class/System.Messaging/Test/System.Messaging/ChangeLog
===================================================================
--- class/System.Messaging/Test/System.Messaging/ChangeLog	(revision 99955)
+++ class/System.Messaging/Test/System.Messaging/ChangeLog	(working copy)
@@ -1,3 +1,14 @@
+2008-04-06  Michael Barker <mike@middlesoft.co.uk>
+	* BinaryMessageFormatterTest.cs:  Added tests
+	for a simple string and a complex object.
+	* MessageQueueTest.cs:  Added basic send/receive
+	tests.
+	* XmlMessageFormatterTest.cs:  Added tests for a simple string and a
+	complex object.
+	
+2008-04-02  Michael Barker <mike@middlesoft.co.uk>
+	* MessageTest.cs: Added tests for construction, defaults and properties
+
 2005-09-22  Sebastien Pouliot  <sebastien@ximian.com>
 
 	* MessageQueuePermissionAttributeTest.cs: Removed *Choice security 
Index: class/System.Messaging/Test/System.Messaging/MessageTest.cs
===================================================================
--- class/System.Messaging/Test/System.Messaging/MessageTest.cs	(revision 0)
+++ class/System.Messaging/Test/System.Messaging/MessageTest.cs	(revision 0)
@@ -0,0 +1,220 @@
+using System;
+using System.Messaging;
+using System.Reflection;
+using NUnit.Framework;
+
+namespace MonoTests.System.Messaging
+{
+	[TestFixture]
+	public class MessageTest 
+	{
+		[Test]
+		public void CheckDefaultValues ()
+		{
+			Message m = new Message ();
+			Assert.IsNull (m.Body, "Body default should be Null");
+			Assert.AreEqual (typeof (XmlMessageFormatter), m.Formatter.GetType (),
+					"Formatter default should be XmlMessageFormatter");
+			Assert.AreEqual (AcknowledgeTypes.None, m.AcknowledgeType, 
+					"AnknowledgeType default should be None");
+			Assert.AreEqual (null, m.AdministrationQueue, 
+					"AdministrationQueue default should be null");
+			Assert.AreEqual (0, m.AppSpecific, "AppSpecific default should be 0");
+			Assert.AreEqual (true, m.AttachSenderId, "AttachSenderId default should be true");
+			Assert.AreEqual ("", m.AuthenticationProviderName, 
+					"AuthenticationProviderName should default to \"\"");
+			Assert.AreEqual (CryptographicProviderType.RsaFull, m.AuthenticationProviderType, 
+					"AuthenticationProviderType should default to RsaFull");
+			Assert.AreEqual (null, m.BodyStream, "BodyStream should default to null");
+			Assert.AreEqual (Guid.Empty, m.ConnectorType, "ConnectorType should default to empty");
+			Assert.AreEqual (null, m.CorrelationId, "CorrelationId should default to null");
+			Assert.AreEqual (new byte[0], m.DestinationSymmetricKey, 
+					"DestinationSymmetricKey should default to an empty array");
+			Assert.AreEqual (new byte[0], m.DigitalSignature,
+					"DigitalSignature default to an empty array");
+			Assert.AreEqual (EncryptionAlgorithm.Rc2, m.EncryptionAlgorithm,
+					"EncryptionAlgorithm should default to Rc2");
+			Assert.AreEqual (new byte[0], m.Extension, 
+					"Extension should default to an empty array");
+			Assert.AreEqual (HashAlgorithm.Sha, m.HashAlgorithm, 
+					"Extension should default to Sha");
+			Assert.AreEqual ("", m.Label, "Label should default to \"\"");
+			Assert.AreEqual (MessagePriority.Normal, m.Priority,
+					"Priority should default to Normal");
+			Assert.AreEqual (false, m.Recoverable, "Recoverable should default to false");
+			Assert.AreEqual (null, m.ResponseQueue, "ResponseQueue should default to null");
+			//Assert.AreEqual (null, m.SecurityContext, "SecurityContext should default to null");
+			Assert.AreEqual (new byte[0], m.SenderCertificate, 
+					"SenderCertificate should default to an empty array");
+			Assert.AreEqual (Message.InfiniteTimeout, m.TimeToBeReceived,
+					"TimeToBeReceived should default to InfiniteTimeout");
+			Assert.AreEqual (Message.InfiniteTimeout, m.TimeToReachQueue,
+					"TimeToReadQueue should default to InfiniteTimeout");
+			Assert.AreEqual (false, m.UseAuthentication, 
+					"UseAuthentication should default to false");
+			Assert.AreEqual (false, m.UseDeadLetterQueue,
+					"UseDeadLetterQueue should default to false");
+			Assert.AreEqual (false, m.UseEncryption, "Encryption should default to false");
+			Assert.AreEqual (false, m.UseJournalQueue, 
+					"UseJournalQueue should default to false");
+			Assert.AreEqual (false, m.UseTracing, "UseTracing should default to false");
+		}
+
+		[Test]
+		public void CheckProperties ()
+		{
+			Message m = new Message();
+			CheckProperty (m, "Formatter", new BinaryMessageFormatter());
+			CheckProperty (m, "AcknowledgeType", AcknowledgeTypes.FullReceive);  
+			//CheckProperty (m, "AdministrationQueue", new MessageQueue()); 
+			CheckProperty (m, "AppSpecific", 42);
+			CheckProperty (m, "AttachSenderId", false);
+			CheckProperty (m, "AuthenticationProviderName", "something-else");
+			CheckProperty (m, "AuthenticationProviderType", CryptographicProviderType.Dss); 
+			CheckProperty (m, "ConnectorType", Guid.NewGuid());
+			CheckProperty (m, "CorrelationId", "something-else");
+			CheckProperty (m, "DestinationSymmetricKey", new byte[] { 0xFF });
+			CheckProperty (m, "DigitalSignature", new byte[] { 0xFF });
+			CheckProperty (m, "EncryptionAlgorithm", EncryptionAlgorithm.Rc4); 
+			CheckProperty (m, "Extension", new byte[] { 0xFF });
+			CheckProperty (m, "Label", "something-else");
+			CheckProperty (m, "Priority", MessagePriority.High);
+			CheckProperty (m, "Recoverable", true);
+			//CheckProperty (m, "ResponseQueue", new MessageQueue());
+			//Assert.AreEqual (null, m.SecurityContext, "SecurityContext should default to null");
+			CheckProperty (m, "SenderCertificate", new byte[] { 0xFF }); 
+			CheckProperty (m, "TimeToBeReceived", new TimeSpan(42));
+			CheckProperty (m, "TimeToReachQueue", new TimeSpan(42));
+			CheckProperty (m, "UseAuthentication", true); 
+			CheckProperty (m, "UseDeadLetterQueue", true);
+			CheckProperty (m, "UseEncryption", true);
+			CheckProperty (m, "UseJournalQueue", true); 
+			CheckProperty (m, "UseTracing", true); 
+		}
+
+		private void CheckProperty(object o, string propertyName, object val)
+		{
+			Type t = o.GetType();
+			PropertyInfo p = t.GetProperty(propertyName);
+			p.SetValue(o, val, new object[0]);
+			object newVal = p.GetValue(o, new object[0]);
+			Assert.AreEqual (val, newVal, "Property " + propertyName + " failed");
+		}
+		
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentAcknowledgment ()
+		{
+			Message m = new Message ();
+			object o = m.Acknowledgment;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentDestinationQueue ()
+		{
+			Message m = new Message ();
+			object o = m.DestinationQueue;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentId ()
+		{
+			Message m = new Message ();
+			object o = m.Id;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentIsFirstInTransactoin ()
+		{
+			Message m = new Message ();
+			object o = m.IsFirstInTransaction;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentIsLastInTransactoin ()
+		{
+			Message m = new Message ();
+			object o = m.IsLastInTransaction;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentMessageType ()
+		{
+			Message m = new Message ();
+			object o = m.MessageType;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentSenderId ()
+		{
+			Message m = new Message ();
+			object o = m.SenderId;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentSentTime ()
+		{
+			Message m = new Message ();
+			object o = m.SentTime;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentSenderVersion ()
+		{
+			Message m = new Message ();
+			object o = m.SenderVersion;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentSourceMachine ()
+		{
+			Message m = new Message ();
+			object o = m.SourceMachine;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentTransactionId ()
+		{
+			Message m = new Message ();
+			object o = m.TransactionId;
+		}
+		
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException))]
+		public void UnsentTransactionStatusQueue ()
+		{
+			Message m = new Message ();
+			object o = m.TransactionStatusQueue;
+		}
+
+		[Test]
+		public void ConstructOneArg ()
+		{
+			string s = "this is a test string";
+			Message m = new Message (s);
+			Assert.AreEqual (s, m.Body, "body should be a simple string");
+			Assert.AreEqual (typeof (XmlMessageFormatter), m.Formatter.GetType (),
+					"Formatter should be XmlMessageFormatter");
+		}
+
+		[Test]
+		public void ConstructTwoArgs ()
+		{
+			String s = "this is a test string";
+			Message m = new Message (s, new BinaryMessageFormatter ());
+			Assert.AreEqual (s, m.Body, "Body should be a simple string");
+			Assert.AreEqual (typeof (BinaryMessageFormatter), m.Formatter.GetType(),
+					"Formatter should be BinaryMessageFormatter");
+		}
+	}
+}
Index: class/System.Messaging/Test/System.Messaging/MessageQueueTest.cs
===================================================================
--- class/System.Messaging/Test/System.Messaging/MessageQueueTest.cs	(revision 0)
+++ class/System.Messaging/Test/System.Messaging/MessageQueueTest.cs	(revision 0)
@@ -0,0 +1,118 @@
+//
+// Test.System.Messaging
+//
+// Authors:
+//      Michael Barker (mike@middlesoft.co.uk)
+//
+// (C) 2008 Michael Barker
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Messaging;
+
+using Mono.Messaging;
+using NUnit.Framework;
+using NUnit.Mocks;
+//using Rhino.Mocks;
+
+namespace MonoTests.System.Messaging
+{
+	[TestFixture]
+	public class MessageQueueTest
+	{
+		DynamicMock qMock;
+		DynamicMock providerMock;
+		IQueue queue;
+		IMessagingProvider provider;
+
+		[SetUp]
+		public void SetUp ()
+		{
+			qMock = new DynamicMock (typeof (IQueue));
+			queue = (IQueue) qMock.MockInstance;
+			providerMock = new DynamicMock (typeof (IMessagingProvider));
+			provider = (IMessagingProvider) providerMock.MockInstance;
+		}
+
+		[Test]
+		public void CheckDefaultValues ()
+		{
+			MessageQueue mq = new MessageQueue ();
+			Assert.AreEqual (".", mq.MachineName, "MachineName should default to '.'");
+		}
+
+		[Test]
+		public void SendMessage()
+		{
+			Message m = new Message ("This is a test string");
+			
+			String queueName = "testq";
+			QueueReference qr = new QueueReference (QueueReference.LOCALHOST, false, queueName);
+
+			providerMock.ExpectAndReturn ("GetQueue", queue, qr);	
+			qMock.Expect ("Deliver", m);	
+			
+			MessageQueue mq = MessagingUtil.CreateMessageQueue (provider, qr);
+			mq.Send (m);
+			
+			providerMock.Verify ();
+			qMock.Verify ();
+		}
+		
+		[Test]
+		public void SendStringAsMessage ()
+		{
+			String queueName = "testq";
+			QueueReference qr = new QueueReference (QueueReference.LOCALHOST, false, queueName);
+	
+			providerMock.ExpectAndReturn ("GetQueue", queue, qr);	
+			qMock.Expect ("Deliver");	
+			
+			MessageQueue mq = MessagingUtil.CreateMessageQueue (provider, qr);
+			mq.Send ("This is some message text");
+			
+			providerMock.Verify ();
+			qMock.Verify ();
+		}
+		
+		[Test]
+		public void ReceiveMessage ()
+		{
+			String queueName = "testq";
+			QueueReference qr = new QueueReference (QueueReference.LOCALHOST, false, queueName);
+			string body = "This is a test string";
+	
+			providerMock.ExpectAndReturn ("GetQueue", queue, qr);	
+			qMock.ExpectAndReturn ("Receive", new Message (body));	
+			
+			MessageQueue mq = MessagingUtil.CreateMessageQueue (provider, qr);
+			Message m = mq.Receive ();
+			Assert.AreEqual (body, m.Body, "Body value was not passed correctly");
+			
+			providerMock.Verify ();
+			qMock.Verify ();
+		}
+
+	}
+}
Index: class/System.Messaging/Test/System.Messaging/XmlMessageFormatterTest.cs
===================================================================
--- class/System.Messaging/Test/System.Messaging/XmlMessageFormatterTest.cs	(revision 0)
+++ class/System.Messaging/Test/System.Messaging/XmlMessageFormatterTest.cs	(revision 0)
@@ -0,0 +1,111 @@
+//
+// BinaryMessageFormatterTest.cs -
+//      NUnit Test Cases for BinaryMessageFormatter
+//
+// Author:
+//      Michael Barker  <mike@middlesoft.co.uk>
+//
+// Copyright (C) 2008 Michael Barker
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Messaging;
+
+using NUnit.Framework;
+
+namespace MonoTests.System.Messaging
+{
+	[TestFixture]
+	public class XmlMessageFormatterTest
+	{
+		[Test]
+		public void FormatString ()
+		{
+			string s = "this is a test string";
+			Console.Out.Flush ();
+			Message m = new Message ();
+			m.Formatter = new XmlMessageFormatter (new Type[] { typeof (string) });
+			m.Formatter.Write (m, s);
+			Stream stream = m.BodyStream;
+			
+			Assert.IsTrue (stream.Length > 0);
+			
+			Message m2 = new Message ();
+			m2.Formatter = new XmlMessageFormatter (new Type[] { typeof (string) });
+			m2.BodyStream = stream;
+			
+			Assert.AreEqual (s, (string) m2.Formatter.Read (m2), "The string did not serialise/deserialise properly");
+		}
+		
+		
+		[Test]
+		public void FormatComplexObject ()
+		{
+			Thingy t0 = new Thingy();
+			t0.Iii = 42;
+			t0.Sss = "Some Text";
+			t0.Ttt = DateTime.Now;
+			
+			Message m = new Message ();
+			m.Formatter = new XmlMessageFormatter (new Type[] { typeof (Thingy) });
+			m.Formatter.Write (m, t0);
+			Stream stream = m.BodyStream;
+			
+			Assert.IsTrue (stream.Length > 0);
+			
+			Message m2 = new Message ();
+			m2.Formatter = new XmlMessageFormatter (new Type[] { typeof (Thingy) });
+			m2.BodyStream = stream;
+			Thingy t1 = (Thingy) m2.Formatter.Read (m2);
+			
+			Assert.AreEqual (t0.Iii, t1.Iii, "The int did not serialise/deserialise properly");
+			Assert.AreEqual (t0.Sss, t1.Sss, "The string did not serialise/deserialise properly");
+			Assert.AreEqual (t0.Ttt, t1.Ttt, "The date did not serialise/deserialise properly");
+		}
+		
+	}
+
+	[Serializable]
+	public class Thingy
+	{
+		private int iii;
+		private string sss;
+		private DateTime ttt;
+		
+		public int Iii {
+			get { return iii; }
+			set { iii = value; }
+		}
+		
+		public string Sss {
+			get { return sss; }
+			set { sss = value; }
+		}
+		
+		public DateTime Ttt {
+			get { return ttt; }
+			set { ttt = value; }
+		}
+	}
+
+}
Index: class/System.Messaging/Test/Mono.Messaging/QueueReferenceTest.cs
===================================================================
--- class/System.Messaging/Test/Mono.Messaging/QueueReferenceTest.cs	(revision 0)
+++ class/System.Messaging/Test/Mono.Messaging/QueueReferenceTest.cs	(revision 0)
@@ -0,0 +1,52 @@
+//
+// Test.System.Messaging
+//
+// Authors:
+//      Michael Barker (mike@middlesoft.co.uk)
+//
+// (C) 2008 Michael Barker
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Mono.Messaging;
+
+using NUnit.Framework;
+
+namespace MonoTests.Mono.Messsaging
+{
+	[TestFixture]
+	public class QueueReferenceTest
+	{
+		[Test]
+		public void Equals()
+		{
+			QueueReference qr1 = new QueueReference("abc", false, "def");
+			QueueReference qr2 = new QueueReference("abc", false, "def");
+			//Assert.IsTrue(qr1.Equals(qr2), "QueueReferences should be equal");
+			Assert.AreEqual(qr1, qr2, "QueueReferences should be equal");
+		}
+	}
+
+	
+}
Index: class/System.Messaging/Test/Mono.Messaging/ChangeLog
===================================================================
--- class/System.Messaging/Test/Mono.Messaging/ChangeLog	(revision 0)
+++ class/System.Messaging/Test/Mono.Messaging/ChangeLog	(revision 0)
@@ -0,0 +1,2 @@
+2008-04-06  Michael Barker <mike@middlesoft.co.uk>
+	* QueueReferenceTest.cs:  Added test for QueueReference.
Index: class/System.Messaging/System.Messaging/XmlMessageFormatter.cs
===================================================================
--- class/System.Messaging/System.Messaging/XmlMessageFormatter.cs	(revision 99955)
+++ class/System.Messaging/System.Messaging/XmlMessageFormatter.cs	(working copy)
@@ -31,21 +31,25 @@
 
 using System;
 using System.Collections;
-using System.ComponentModel;
+using System.ComponentModel;
+using System.IO;
+using System.Xml.Serialization;
 
+
 namespace System.Messaging 
 {
 	public class XmlMessageFormatter: IMessageFormatter, ICloneable 
-	{
+	{
+		private Type[] targetTypes = new Type[0];		
+	
 		[MonoTODO]
 		public XmlMessageFormatter()
 		{
 		}
 		
 		[MonoTODO]
-		public XmlMessageFormatter(string[] targetTypeNames)
+		public XmlMessageFormatter(string[] targetTypeNames) : this (GetTypesFromNames (targetTypeNames))
 		{
-			initializeFromNames(targetTypeNames);
 		}
 		
 		[MonoTODO]
@@ -54,11 +58,13 @@
 			this.targetTypes = targetTypes;
 		}
 
-		private Type[] targetTypes = null;
-		
-		[MonoTODO]
-		private void initializeFromNames(string[] targetTypeNames)
-		{
+		private static Type[] GetTypesFromNames(string[] targetTypeNames)
+		{
+			Type[] ts = new Type[targetTypeNames.Length];
+			for (int i = 0; i < targetTypeNames.Length; i++)
+				ts[i] = Type.GetType (targetTypeNames[i]);
+			
+			return ts;
 		}
 
 		[MessagingDescription ("XmlMsgTargetTypeNames")]
@@ -69,12 +75,12 @@
 				if (targetTypes == null)
 					return null;
 					
-				ArrayList listOfNames = new ArrayList();
-				foreach(Type type in targetTypes)
-					listOfNames.Add(type.FullName);
-				return (string[])listOfNames.ToArray(typeof(string));
+				ArrayList listOfNames = new ArrayList (targetTypes.Length);
+				foreach (Type type in targetTypes)
+					listOfNames.Add (type.FullName);
+				return (string[]) listOfNames.ToArray (typeof (string));
 			}
-			set { initializeFromNames(value); }
+			set { targetTypes = GetTypesFromNames (value); }
 		}
 
 		[Browsable (false)]
@@ -88,25 +94,41 @@
 		
 		[MonoTODO]
 		public bool CanRead(Message message)
-		{
+		{
+			// Need an implementation of XmlNodeReader.
 			throw new NotImplementedException();
 		}
 		
 		public object Clone()
 		{
 			return new XmlMessageFormatter((Type[])targetTypes.Clone());
-		}
-		
+		}
+				
 		[MonoTODO]
 		public object Read(Message message)
-		{
-			throw new NotImplementedException();
+		{
+			message.BodyStream.Seek (0, SeekOrigin.Begin);
+			object result = null;
+			foreach (Type t in targetTypes) {
+				XmlSerializer serializer = new XmlSerializer (t);
+				try {
+					return serializer.Deserialize (message.BodyStream);
+				} catch (InvalidOperationException e) {
+					Console.WriteLine (e);
+				}
+			}
+			string error = "Unable to deserialize message body.  Type is not one of: " 
+				+ String.Join (",", TargetTypeNames);
+			throw new InvalidOperationException (error);
 		}
 		
 		[MonoTODO]
 		public void Write(Message message, object obj)
 		{
-			throw new NotImplementedException();
+			XmlSerializer serializer = new XmlSerializer (obj.GetType ());
+			Stream s = new MemoryStream ();
+			serializer.Serialize (s, obj);
+			message.BodyStream = s;
 		}
 	}
 }
Index: class/System.Messaging/System.Messaging/BinaryMessageFormatter.cs
===================================================================
--- class/System.Messaging/System.Messaging/BinaryMessageFormatter.cs	(revision 99955)
+++ class/System.Messaging/System.Messaging/BinaryMessageFormatter.cs	(working copy)
@@ -31,7 +31,8 @@
 //
 
 using System;
-using System.ComponentModel;
+using System.ComponentModel;
+using System.IO;
 using System.Runtime.Serialization.Formatters;
 using System.Runtime.Serialization.Formatters.Binary;
 
@@ -87,8 +88,9 @@
 		public object Read (Message message)
 		{
 			if (message == null)
-				throw new ArgumentNullException ();
-
+				throw new ArgumentNullException ();
+			
+			message.BodyStream.Seek (0, SeekOrigin.Begin);
 			return _formatter.Deserialize (message.BodyStream);
 		}
 
@@ -96,9 +98,15 @@
 		public void Write (Message message, object obj)
 		{
 			if (message == null)
-				throw new ArgumentNullException ();
-
-			_formatter.Serialize (message.BodyStream, obj);
+				throw new ArgumentNullException ();
+				
+			Stream stream = message.BodyStream;
+			if (stream == null) {
+				stream = new MemoryStream ();
+				message.BodyStream = stream;
+			}
+			
+			_formatter.Serialize (stream, obj);
 		}
 
 		public object Clone ()
Index: class/System.Messaging/System.Messaging/ChangeLog
===================================================================
--- class/System.Messaging/System.Messaging/ChangeLog	(revision 99955)
+++ class/System.Messaging/System.Messaging/ChangeLog	(working copy)
@@ -1,3 +1,14 @@
+2008-04-06  Michael Barker <mike@middlesoft.co.uk>
+	* BinaryMessageFormatter.cs:  Small fix for infinte loop.
+	* MessageQueue.cs:  Added send/receive basic implemenetation and an 
+	internal construtor to inject the IMessagingProvider instance.
+	* Message.cs:  Implemented the body stream functionality.
+	* System.Messaging/XmlMessageFormatter.cs:
+
+2008-04-02  Michael Barker <mike@middlesoft.co.uk>
+	* Message.cs:  Added basic implemenation for Message properties.
+	Removed MS carriage returns.
+
 2004-09-10  Sebastien Pouliot  <sebastien@ximian.com>
 
 	* MessageQueuePermission.cs: Implemented enough TODO so compilers can
Index: class/System.Messaging/System.Messaging/Message.cs
===================================================================
--- class/System.Messaging/System.Messaging/Message.cs	(revision 99955)
+++ class/System.Messaging/System.Messaging/Message.cs	(working copy)
@@ -1,12 +1,12 @@
-//
-// System.Messaging
-//
-// Authors:
-//      Peter Van Isacker (sclytrack@planetinternet.be)
-//      Rafael Teixeira   (rafaelteixeirabr@hotmail.com)
-//
-// (C) 2003 Peter Van Isacker
-//
+//
+// System.Messaging
+//
+// Authors:
+//      Peter Van Isacker (sclytrack@planetinternet.be)
+//      Rafael Teixeira   (rafaelteixeirabr@hotmail.com)
+//
+// (C) 2003 Peter Van Isacker
+//
 
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -28,436 +28,408 @@
 // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
-
-using System;
-using System.IO;
-using System.ComponentModel;
-
-namespace System.Messaging 
-{
-	[DesignerAttribute ("System.Messaging.Design.MessageDesigner, " + Consts.AssemblySystem_Design)]
-	public class Message: Component 
-	{
-		#region Constructor
-		
-		[MonoTODO]
-		public Message()
-		{
-		}
-
-		[MonoTODO]
-		public Message (object body)
-		{
-		}
-
-		[MonoTODO]
-		public Message (object body, IMessageFormatter formatter)
-		{
-		}
-		
-		#endregion //Constructor
-		
-		[MonoTODO]
-		public static readonly TimeSpan InfiniteTimeout;
-		
-		#region Properties
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgAcknowledgeType")]
-		public AcknowledgeTypes AcknowledgeType {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgAcknowledgement")]
-		public Acknowledgment Acknowledgment {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgAdministrationQueue")]
-		public MessageQueue AdministrationQueue {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgAppSpecific")]
-		public int AppSpecific {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MsgArrivedTime")]
-		public DateTime ArrivedTime {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgAttachSenderId")]
-		public bool AttachSenderId {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MsgAuthenticated")]
-		public bool Authenticated {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgAuthenticationProviderName")]
-		public string AuthenticationProviderName {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgAuthenticationProviderType")]
-		public CryptographicProviderType AuthenticationProviderType {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[Browsable (false)]
-		public object Body {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[Editor ("System.ComponentModel.Design.BinaryEditor, " + Consts.AssemblySystem_Design, "System.Drawing.Design.UITypeEditor, " + Consts.AssemblySystem_Drawing)]
-		[MessagingDescription ("MsgBodyStream")]
-		public Stream BodyStream {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MsgBodyType")]
-		[ReadOnly (true)]
-		public int BodyType {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgConnectorType")]
-		public Guid ConnectorType {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgCorrelationId")]
-		public string CorrelationId {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription("MsgDestinationQueue")]
-		public MessageQueue DestinationQueue {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgDestinationSymmetricKey")]
-		public byte[] DestinationSymmetricKey {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgDigitalSignature")]
-		public byte[] DigitalSignature {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgEncryptionAlgorithm")]
-		public EncryptionAlgorithm EncryptionAlgorithm {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgExtension")]
-		public byte[] Extension {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[Browsable(false)]
-		public IMessageFormatter Formatter {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgHashAlgorithm")]
-		public HashAlgorithm HashAlgorithm {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgId")]
-		public string Id {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription("MsgIsFirstInTransaction")]
-		public bool IsFirstInTransaction {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription("MsgIsLastInTransaction")]
-		public bool IsLastInTransaction {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgLabel")]
-		public string Label {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription("MsgMessageType")]
-		public MessageType MessageType {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgPriority")]
-		public MessagePriority Priority {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgRecoverable")]
-		public bool Recoverable {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgResponseQueue")]
-		public MessageQueue ResponseQueue {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
-		[ReadOnly(true)]
-		[MessagingDescription("MsgSenderCertificate")]
-		public byte[] SenderCertificate {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MsgSenderId")]
-		public byte[] SenderId {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgSenderVersion")]
-		public long SenderVersion {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgSentTime")]
-		public DateTime SentTime {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MsgSourceMachine")]
-		public string SourceMachine {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgTimeToBeReceived")]
-		[TypeConverter (typeof(TimeoutConverter))]
-		public TimeSpan TimeToBeReceived {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgTimeToReachQueue")]
-		[TypeConverter (typeof(TimeoutConverter))]
-		public TimeSpan TimeToReachQueue {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MsgTransactionId")]
-		public string TransactionId {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgTransactionStatusQueue")]
-		public MessageQueue TransactionStatusQueue {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgUseAuthentication")]
-		public bool UseAuthentication {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgUseDeadLetterQueue")]
-		public bool UseDeadLetterQueue {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgUseEncryption")]
-		public bool UseEncryption {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgUseJournalQueue")]
-		public bool UseJournalQueue {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[ReadOnly (true)]
-		[MessagingDescription ("MsgUseTracing")]
-		public bool UseTracing {
-			[MonoTODO]
-			get {throw new NotImplementedException();}
-			[MonoTODO]
-			set {throw new NotImplementedException();}
-		}
-
-		#endregion //Properties
-	}
-}
+
+using System;
+using System.IO;
+using System.ComponentModel;
+
+namespace System.Messaging 
+{
+	[DesignerAttribute ("System.Messaging.Design.MessageDesigner, " + Consts.AssemblySystem_Design)]
+	public class Message : Component 
+	{
+		private static readonly byte[] EMPTY = new byte[0];
+		private AcknowledgeTypes acknowledgeType = AcknowledgeTypes.None;
+		private MessageQueue administrationQueue = null;
+		private int appSpecific = 0;
+		private bool attachSenderId = true;
+		private String authenticationProviderName = String.Empty;
+		private CryptographicProviderType authenticationProviderType = 
+			CryptographicProviderType.RsaFull;
+		private object body;
+		private Stream bodyStream = null;
+		private Guid connectorType = Guid.Empty;
+		private string correlationId = null;
+		private byte[] destinationSymmetricKey = EMPTY;
+		private byte[] digitalSignature = EMPTY;
+		private EncryptionAlgorithm encryptionAlgorithm = EncryptionAlgorithm.Rc2;
+		private byte[] extension = EMPTY;
+		private IMessageFormatter formatter;
+		private HashAlgorithm hashAlgorithm = HashAlgorithm.Sha;
+		private string label = String.Empty;
+		private MessagePriority priority = MessagePriority.Normal;
+		private bool recoverable = false;
+		private MessageQueue responseQueue = null;
+		//private SecurityContext securityContext = null;
+		private byte[] senderCertificate = EMPTY;
+		private TimeSpan timeToBeReceived = InfiniteTimeout;
+		private TimeSpan timeToReachQueue = InfiniteTimeout;
+		private bool useAuthentication = false;
+		private bool useDeadLetterQueue = false;
+		private bool useEncryption = false;
+		private bool useJournalQueue = false;
+		private bool useTracing = false;
+
+
+		#region Constructor
+		
+		public Message () : this (null, new XmlMessageFormatter())
+		{
+		}
+
+		public Message (object body) : this (body, new XmlMessageFormatter())
+ 		{
+		}
+
+		public Message (object body, IMessageFormatter formatter)
+		{
+			this.body = body;
+			this.formatter = formatter;
+		}
+		
+		#endregion //Constructor
+		
+		[MonoTODO]
+		public static readonly TimeSpan InfiniteTimeout;
+		
+		#region Properties
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgAcknowledgeType")]
+		public AcknowledgeTypes AcknowledgeType {
+			get { return acknowledgeType; }
+			set { acknowledgeType = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgAcknowledgement")]
+		public Acknowledgment Acknowledgment {
+			get {
+				throw new InvalidOperationException("Message has not been sent");
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgAdministrationQueue")]
+		public MessageQueue AdministrationQueue {
+			get { return administrationQueue; }
+			set { administrationQueue = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgAppSpecific")]
+		public int AppSpecific {
+			get { return appSpecific; }
+			set { appSpecific = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MsgArrivedTime")]
+		public DateTime ArrivedTime {
+			get { throw new InvalidOperationException ("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgAttachSenderId")]
+		public bool AttachSenderId {
+			get { return attachSenderId; }
+			set { attachSenderId = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MsgAuthenticated")]
+		public bool Authenticated {
+			get { throw new InvalidOperationException ("Message has not been sent");}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgAuthenticationProviderName")]
+		public string AuthenticationProviderName {
+			get { return authenticationProviderName; }
+			set { authenticationProviderName = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgAuthenticationProviderType")]
+		public CryptographicProviderType AuthenticationProviderType {
+			get { return authenticationProviderType; }
+			set { authenticationProviderType = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[Browsable (false)]
+		public object Body {
+			get { return body; }
+			set { body = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[Editor ("System.ComponentModel.Design.BinaryEditor, " + Consts.AssemblySystem_Design, "System.Drawing.Design.UITypeEditor, " + Consts.AssemblySystem_Drawing)]
+		[MessagingDescription ("MsgBodyStream")]
+		public Stream BodyStream {
+			get { return bodyStream; }
+			set { bodyStream = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MsgBodyType")]
+		[ReadOnly (true)]
+		public int BodyType {
+			[MonoTODO]
+			get {throw new NotImplementedException();}
+			[MonoTODO]
+			set {throw new NotImplementedException();}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgConnectorType")]
+		public Guid ConnectorType {
+			get { return connectorType; }
+			set { connectorType = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgCorrelationId")]
+		public string CorrelationId {
+			get { return correlationId; }
+			set { correlationId = value; }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription("MsgDestinationQueue")]
+		public MessageQueue DestinationQueue {
+			get { throw new InvalidOperationException ("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgDestinationSymmetricKey")]
+		public byte[] DestinationSymmetricKey {
+			get { return destinationSymmetricKey; }
+			set { destinationSymmetricKey = value; }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgDigitalSignature")]
+		public byte[] DigitalSignature {
+			get { return digitalSignature; }
+			set { digitalSignature = value; }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgEncryptionAlgorithm")]
+		public EncryptionAlgorithm EncryptionAlgorithm {
+			get { return encryptionAlgorithm; }
+			set { encryptionAlgorithm = value; }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgExtension")]
+		public byte[] Extension {
+			get { return extension; }
+			set { 
+				if (value == null)
+					throw new ArgumentException("Extension may not be null");
+				extension = value;
+			}
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[Browsable(false)]
+		public IMessageFormatter Formatter {
+			get {
+				return formatter;
+			}
+			set {
+				formatter = value;
+			}
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgHashAlgorithm")]
+		public HashAlgorithm HashAlgorithm {
+			get { return hashAlgorithm; }
+			set { hashAlgorithm = value; }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgId")]
+		public string Id {
+			get { throw new InvalidOperationException("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription("MsgIsFirstInTransaction")]
+		public bool IsFirstInTransaction {
+			get { throw new InvalidOperationException("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription("MsgIsLastInTransaction")]
+		public bool IsLastInTransaction {
+			get { throw new InvalidOperationException("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgLabel")]
+		public string Label {
+			get { return label; }
+			set { label = value; }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription("MsgMessageType")]
+		public MessageType MessageType {
+			get { throw new InvalidOperationException("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgPriority")]
+		public MessagePriority Priority {
+			get { return priority; }
+			set { priority = value; }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgRecoverable")]
+		public bool Recoverable {
+			get { return recoverable; }
+			set { recoverable = value; }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgResponseQueue")]
+		public MessageQueue ResponseQueue {
+			get { return responseQueue; }
+			set { responseQueue = value; }
+		}
+
+		[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
+		[ReadOnly(true)]
+		[MessagingDescription("MsgSenderCertificate")]
+		public byte[] SenderCertificate {
+			get { return senderCertificate; }
+			set { senderCertificate = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MsgSenderId")]
+		public byte[] SenderId {
+			get { throw new InvalidOperationException("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgSenderVersion")]
+		public long SenderVersion {
+			get { throw new InvalidOperationException("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgSentTime")]
+		public DateTime SentTime {
+			get { throw new InvalidOperationException("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MsgSourceMachine")]
+		public string SourceMachine {
+			get { throw new InvalidOperationException("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgTimeToBeReceived")]
+		[TypeConverter (typeof(TimeoutConverter))]
+		public TimeSpan TimeToBeReceived {
+			get { return timeToBeReceived; }
+			set { timeToBeReceived = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgTimeToReachQueue")]
+		[TypeConverter (typeof(TimeoutConverter))]
+		public TimeSpan TimeToReachQueue {
+			get { return timeToReachQueue; }
+			set { timeToReachQueue = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MsgTransactionId")]
+		public string TransactionId {
+			get { throw new InvalidOperationException ("Message has not been sent"); }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgTransactionStatusQueue")]
+		public MessageQueue TransactionStatusQueue {
+			get { throw new InvalidOperationException ("Message has not been sent"); }
+			[MonoTODO]
+			set {throw new NotImplementedException();}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgUseAuthentication")]
+		public bool UseAuthentication {
+			get { return useAuthentication; }
+			set { useAuthentication = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgUseDeadLetterQueue")]
+		public bool UseDeadLetterQueue {
+			get { return useDeadLetterQueue; }
+			set { useDeadLetterQueue = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgUseEncryption")]
+		public bool UseEncryption {
+			get { return useEncryption; }
+			set { useEncryption = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgUseJournalQueue")]
+		public bool UseJournalQueue {
+			get { return useJournalQueue; }
+			set { useJournalQueue = value; }
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[ReadOnly (true)]
+		[MessagingDescription ("MsgUseTracing")]
+		public bool UseTracing {
+			get { return useTracing; }
+			set { useTracing = value; }
+		}
+
+		#endregion //Properties
+	}
+}
Index: class/System.Messaging/System.Messaging/MessageQueue.cs
===================================================================
--- class/System.Messaging/System.Messaging/MessageQueue.cs	(revision 99955)
+++ class/System.Messaging/System.Messaging/MessageQueue.cs	(working copy)
@@ -1,12 +1,12 @@
-//
-// System.Messaging
-//
-// Authors:
-//      Peter Van Isacker (sclytrack@planetinternet.be)
-//      Rafael Teixeira   (rafaelteixeirabr@hotmail.com)
-//
-// (C) 2003 Peter Van Isacker
-//
+//
+// System.Messaging
+//
+// Authors:
+//      Peter Van Isacker (sclytrack@planetinternet.be)
+//      Rafael Teixeira   (rafaelteixeirabr@hotmail.com)
+//
+// (C) 2003 Peter Van Isacker
+//
 
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -28,752 +28,769 @@
 // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
-
-using System;
-using System.Collections;
-using System.ComponentModel;
-using System.Drawing;
-using System.Messaging.Design;
-
-namespace System.Messaging
-{
-	[TypeConverter (typeof(MessageQueueConverter))]
-	[Editor ("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, " + Consts.AssemblySystem_Drawing)]
-	[Designer ("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, " + Consts.AssemblyMicrosoft_VisualStudio)]
-	[InstallerType (typeof(MessageQueueInstaller))]
-	[DefaultEvent ("ReceiveCompleted")]
-	public class MessageQueue : Component, IEnumerable
-	{
-		#region Fields
-
-		public static readonly long InfiniteQueueSize;
-		public static readonly TimeSpan InfiniteTimeout;
-
-		private bool isPrivate = false;
-		private string queueName;
-		private string machineName;
-
-
-		#endregion //Fields
-
-
-		#region Constructor
-
-		[MonoTODO]
-		public MessageQueue ()
-		{
-			throw new NotImplementedException ();
-		}
-
-		[MonoTODO]
-		public MessageQueue (string path) {
-			this.Path = path;
-			this.isPrivate = false;
-		}
-
-		[MonoTODO]
-		private MessageQueue (string queueName, string machineName, bool isPrivate) 
-		{
-			this.queueName = queueName;
-			this.machineName = machineName;
-			this.isPrivate = isPrivate;
-		}
-
-		[MonoTODO]
-		public MessageQueue (string path, bool sharedModeDenyReceive) 
-		{
-			throw new NotImplementedException ();
-		}
-
-		#endregion //Constructor
-
-		#region Properties
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_Authenticate")]
-		public bool Authenticate {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_BasePriority")]
-		public short BasePriority {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[Browsable (false)]
-		[MessagingDescription ("MQ_CanRead")]
-		public bool CanRead {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[Browsable (false)]
-		[MessagingDescription ("MQ_CanWrite")]
-		public bool CanWrite {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_Category")]
-		public Guid Category {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_CreateTime")]
-		public DateTime CreateTime {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Content)]
-		[Browsable (false)]
-		[MessagingDescription ("MQ_DefaultPropertiesToSend")]
-		public DefaultPropertiesToSend DefaultPropertiesToSend {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[Browsable (false)]
-		[DefaultValue (false)]
-		[MessagingDescription ("MQ_DenySharedReceive")]
-		public bool DenySharedReceive {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[Browsable (false)]
-		public static bool EnableConnectionCache {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_EncryptionRequired")]
-		public EncryptionRequired EncryptionRequired {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_FormatName")]
-		public string FormatName {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[Browsable (false)]
-		[DefaultValue (null)]
-		[TypeConverter (typeof(MessageFormatterConverter))]
-		[MessagingDescription ("MQ_Formatter")]
-		public IMessageFormatter Formatter {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_GuidId")]
-		public Guid Id {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_Label")]
-		public string Label {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_LastModifyTime")]
-		public DateTime LastModifyTime {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[Browsable (false)]
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_MachineName")]
-		public string MachineName {
-			get {
-				return machineName;
-			}
-			set {
-				machineName = value;
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[TypeConverter (typeof(SizeConverter))]
-		[MessagingDescription ("MQ_MaximumJournalSize")]
-		public long MaximumJournalSize {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[TypeConverter (typeof(SizeConverter))]
-		[MessagingDescription ("MQ_MaximumQueueSize")]
-		public long MaximumQueueSize {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[Browsable (false)]
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Content)]
-		[MessagingDescription ("MQ_MessageReadPropertyFilter")]
-		public MessagePropertyFilter MessageReadPropertyFilter {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[RecommendedAsConfigurable (true)]
-		[Editor ("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, " + Consts.AssemblySystem_Drawing)]
-		[Browsable (false)]
-		[DefaultValue ("")]
-		[TypeConverter ("System.Diagnostics.Design.StringValueConverter, " + Consts.AssemblySystem_Design)]
-		[MessagingDescription ("MQ_Path")]
-		public string Path {
-			get {
-				return machineName + ":" + queueName;
-			}
-			[MonoTODO ("split input")]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[Browsable (false)]
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_QueueName")]
-		public string QueueName {
-			get {
-				return queueName;
-			}
-			set {
-				queueName = value;
-			}
-		}
-
-		[Browsable (false)]
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_ReadHandle")]
-		public IntPtr ReadHandle {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[Browsable (false)]
-		[DefaultValue (null)]
-		[MessagingDescription ("MQ_SynchronizingObject")]
-		public ISynchronizeInvoke SynchronizingObject {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_Transactional")]
-		public bool Transactional {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_WriteHandle")]
-		public bool UseJournalQueue {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-			[MonoTODO]
-			set {
-				throw new NotImplementedException ();
-			}
-		}
-
-		[Browsable (false)]
-		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
-		[MessagingDescription ("MQ_WriteHandle")]
-		public IntPtr WriteHandle {
-			[MonoTODO]
-			get {
-				throw new NotImplementedException ();
-			}
-		}
-
-		#endregion //Properties
-
-		#region Methods
-
-		[MonoTODO]
-		public IAsyncResult BeginPeek ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public IAsyncResult BeginPeek (TimeSpan timeout)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public IAsyncResult BeginPeek (TimeSpan timeout,
-									  object stateObject,
-									  AsyncCallback callback)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public IAsyncResult BeginReceive ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public IAsyncResult BeginReceive (TimeSpan timeout)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static void ClearConnectionCache ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void Close ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static MessageQueue Create (string path)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static MessageQueue Create (string path, bool transactional)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static void Delete (string path)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message EndPeek (IAsyncResult asyncResult)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message EndReceive (IAsyncResult asyncResult)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static bool Exists (string path)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message[] GetAllMessages ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public IEnumerator GetEnumerator ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static Guid GetMachineId (string machineName)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public MessageEnumerator GetMessageEnumerator ()
-		{
-			throw new NotImplementedException ();
-		}
-
-		private static ArrayList currentQueueList;
-
-		static MessageQueue ()
-		{
-			currentQueueList = new ArrayList ();
-			// for testing purposes
-			currentQueueList.Add (new MessageQueue (@"localhost:\public\TestQueue"));
-			currentQueueList.Add (new MessageQueue (@"\private\AnotherTestQueue", "localhost", true));
-		}
-
-		public static MessageQueueEnumerator GetMessageQueueEnumerator ()
-		{
-			return new MessageQueueEnumerator (currentQueueList);
-		}
-
-		private static ArrayList filteredQueueList (MessageQueueCriteria criteria)
-		{
-			ArrayList list = new ArrayList ();
-			foreach (MessageQueue queue in currentQueueList)
-				if (criteria.Match (queue.Id, queue.CreateTime, queue.Label, queue.MachineName, queue.LastModifyTime))
-					list.Add (queue);
-			return list;
-		}
-
-		public static MessageQueueEnumerator GetMessageQueueEnumerator (MessageQueueCriteria criteria)
-		{
-			return new MessageQueueEnumerator (filteredQueueList (criteria));
-		}
-
-		public static MessageQueue[] GetPrivateQueuesByMachine (string machineName)
-		{
-			if (machineName == null || machineName.Length == 0)
-				throw new ArgumentException ();
-			ArrayList list = new ArrayList ();
-			foreach (MessageQueue queue in currentQueueList)
-				if (queue.machineName == machineName && queue.isPrivate)
-					list.Add (queue);
-			return (MessageQueue[]) list.ToArray (typeof(MessageQueue));
-		}
-
-		[MonoTODO]
-		public static MessageQueue[] GetPublicQueues ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static MessageQueue[] GetPublicQueues (MessageQueueCriteria criteria)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static MessageQueue[] GetPublicQueuesByCategory (Guid category)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static MessageQueue[] GetPublicQueuesByLabel (string label)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public static MessageQueue[] GetPublicQueuesByMachine (string machineName)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message Peek ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message Peek (TimeSpan timeout)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message PeekByCorrelationId (string correlationId)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message PeekByCorrelationId (string correlationId, TimeSpan timeout)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message PeekById (string id)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message PeekById (string id, TimeSpan timeout)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void Purge ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message Receive ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message Receive (MessageQueueTransaction transaction)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message Receive (MessageQueueTransactionType transactionType)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message Receive (TimeSpan timeout)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message Receive (TimeSpan timeout, MessageQueueTransaction transaction)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message Receive (TimeSpan timeout, MessageQueueTransactionType transactionType)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveByCorrelationId (string correlationId)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveByCorrelationId (string correlationId, MessageQueueTransaction transaction)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveByCorrelationId (string correlationId, MessageQueueTransactionType transactionType)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, MessageQueueTransaction transaction)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, MessageQueueTransactionType transactionType)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveById (string id)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveById (string id, MessageQueueTransaction transaction)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveById (string id, MessageQueueTransactionType transactionType)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveById (string id, TimeSpan timeout)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveById (string id, TimeSpan timeout, MessageQueueTransaction transaction)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public Message ReceiveById (string id, TimeSpan timeout, MessageQueueTransactionType transactionType)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void Refresh ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void ResetPermissions ()
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void Send (object obj)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void Send (object obj, MessageQueueTransaction transaction)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void Send (object obj, MessageQueueTransactionType transactionType)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void Send (object obj, string label)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void Send (object obj, string label, MessageQueueTransaction transaction)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void Send (object obj, string label, MessageQueueTransactionType transactionType)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void SetPermissions (AccessControlList dacl)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void SetPermissions (MessageQueueAccessControlEntry ace)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void SetPermissions (string user, MessageQueueAccessRights rights)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		public void SetPermissions (string user, MessageQueueAccessRights rights, AccessControlEntryType entryType)
-		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
-		protected override void Dispose (bool disposing)
-		{
-			throw new NotImplementedException ();
-		}
-
-		#endregion //Methods
-
-		//TODO: Use these events.
-
-		[MessagingDescription ("MQ_PeekCompleted")]
-		public event PeekCompletedEventHandler PeekCompleted;
-
-		[MessagingDescription ("MQ_ReceiveCompleted")]
-		public event ReceiveCompletedEventHandler ReceiveCompleted;
-	}
-}
+
+using System;
+using System.Collections;
+using System.ComponentModel;
+using System.Drawing;
+using System.Messaging.Design;
+
+using Mono.Messaging;
+
+namespace System.Messaging
+{
+	[TypeConverter (typeof(MessageQueueConverter))]
+	[Editor ("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, " + Consts.AssemblySystem_Drawing)]
+	[Designer ("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, " + Consts.AssemblyMicrosoft_VisualStudio)]
+	[InstallerType (typeof(MessageQueueInstaller))]
+	[DefaultEvent ("ReceiveCompleted")]
+	public class MessageQueue : Component, IEnumerable
+	{
+		#region Fields
+
+		public static readonly long InfiniteQueueSize;
+		public static readonly TimeSpan InfiniteTimeout;
+		public static readonly string LOCAL = ".";
+
+		private bool isPrivate = false;
+		private string queueName;
+		private string machineName;
+		private readonly IMessagingProvider provider;
+		private QueueReference qRef;
+
+		#endregion //Fields
+
+
+		#region Constructor
+
+		public MessageQueue () : this(null, LOCAL, false)
+		{
+		}
+
+		public MessageQueue (string path) : this(path, LOCAL, false)
+		{
+		}
+		
+		internal MessageQueue (IMessagingProvider provider, QueueReference qRef)
+		{
+			this.provider = provider;
+			this.qRef = qRef;
+		}
+
+		
+		private MessageQueue (string queueName, string machineName, bool isPrivate) 
+			: this (null, new QueueReference (machineName, isPrivate, queueName))
+		{
+		}
+
+		public MessageQueue (string path, bool sharedModeDenyReceive) 
+		{
+			throw new NotImplementedException ();
+		}
+
+		#endregion //Constructor
+
+		#region Properties
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_Authenticate")]
+		public bool Authenticate {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_BasePriority")]
+		public short BasePriority {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[Browsable (false)]
+		[MessagingDescription ("MQ_CanRead")]
+		public bool CanRead {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[Browsable (false)]
+		[MessagingDescription ("MQ_CanWrite")]
+		public bool CanWrite {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_Category")]
+		public Guid Category {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_CreateTime")]
+		public DateTime CreateTime {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Content)]
+		[Browsable (false)]
+		[MessagingDescription ("MQ_DefaultPropertiesToSend")]
+		public DefaultPropertiesToSend DefaultPropertiesToSend {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[Browsable (false)]
+		[DefaultValue (false)]
+		[MessagingDescription ("MQ_DenySharedReceive")]
+		public bool DenySharedReceive {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[Browsable (false)]
+		public static bool EnableConnectionCache {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_EncryptionRequired")]
+		public EncryptionRequired EncryptionRequired {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_FormatName")]
+		public string FormatName {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[Browsable (false)]
+		[DefaultValue (null)]
+		[TypeConverter (typeof(MessageFormatterConverter))]
+		[MessagingDescription ("MQ_Formatter")]
+		public IMessageFormatter Formatter {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_GuidId")]
+		public Guid Id {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_Label")]
+		public string Label {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_LastModifyTime")]
+		public DateTime LastModifyTime {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[Browsable (false)]
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_MachineName")]
+		public string MachineName {
+			get {
+				return qRef.Host;
+			}
+			set {
+				qRef = qRef.SetHost (value);
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[TypeConverter (typeof(SizeConverter))]
+		[MessagingDescription ("MQ_MaximumJournalSize")]
+		public long MaximumJournalSize {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[TypeConverter (typeof(SizeConverter))]
+		[MessagingDescription ("MQ_MaximumQueueSize")]
+		public long MaximumQueueSize {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[Browsable (false)]
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Content)]
+		[MessagingDescription ("MQ_MessageReadPropertyFilter")]
+		public MessagePropertyFilter MessageReadPropertyFilter {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[RecommendedAsConfigurable (true)]
+		[Editor ("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, " + Consts.AssemblySystem_Drawing)]
+		[Browsable (false)]
+		[DefaultValue ("")]
+		[TypeConverter ("System.Diagnostics.Design.StringValueConverter, " + Consts.AssemblySystem_Design)]
+		[MessagingDescription ("MQ_Path")]
+		public string Path {
+			get {
+				return machineName + ":" + queueName;
+			}
+			[MonoTODO ("split input")]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[Browsable (false)]
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_QueueName")]
+		public string QueueName {
+			get {
+				return queueName;
+			}
+			set {
+				queueName = value;
+			}
+		}
+
+		[Browsable (false)]
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_ReadHandle")]
+		public IntPtr ReadHandle {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[Browsable (false)]
+		[DefaultValue (null)]
+		[MessagingDescription ("MQ_SynchronizingObject")]
+		public ISynchronizeInvoke SynchronizingObject {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_Transactional")]
+		public bool Transactional {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_WriteHandle")]
+		public bool UseJournalQueue {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+			[MonoTODO]
+			set {
+				throw new NotImplementedException ();
+			}
+		}
+
+		[Browsable (false)]
+		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
+		[MessagingDescription ("MQ_WriteHandle")]
+		public IntPtr WriteHandle {
+			[MonoTODO]
+			get {
+				throw new NotImplementedException ();
+			}
+		}
+
+		#endregion //Properties
+
+		#region Methods
+
+		[MonoTODO]
+		public IAsyncResult BeginPeek ()
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public IAsyncResult BeginPeek (TimeSpan timeout)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public IAsyncResult BeginPeek (TimeSpan timeout,
+									  object stateObject,
+									  AsyncCallback callback)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public IAsyncResult BeginReceive ()
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public IAsyncResult BeginReceive (TimeSpan timeout)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static void ClearConnectionCache ()
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void Close ()
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static MessageQueue Create (string path)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static MessageQueue Create (string path, bool transactional)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static void Delete (string path)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message EndPeek (IAsyncResult asyncResult)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message EndReceive (IAsyncResult asyncResult)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static bool Exists (string path)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message[] GetAllMessages ()
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public IEnumerator GetEnumerator ()
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static Guid GetMachineId (string machineName)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public MessageEnumerator GetMessageEnumerator ()
+		{
+			throw new NotImplementedException ();
+		}
+
+		private static ArrayList currentQueueList;
+
+		static MessageQueue ()
+		{
+			currentQueueList = new ArrayList ();
+			// for testing purposes
+			currentQueueList.Add (new MessageQueue (@"localhost:\public\TestQueue"));
+			currentQueueList.Add (new MessageQueue (@"\private\AnotherTestQueue", "localhost", true));
+		}
+
+		public static MessageQueueEnumerator GetMessageQueueEnumerator ()
+		{
+			return new MessageQueueEnumerator (currentQueueList);
+		}
+
+		private static ArrayList filteredQueueList (MessageQueueCriteria criteria)
+		{
+			ArrayList list = new ArrayList ();
+			foreach (MessageQueue queue in currentQueueList)
+				if (criteria.Match (queue.Id, queue.CreateTime, queue.Label, queue.MachineName, queue.LastModifyTime))
+					list.Add (queue);
+			return list;
+		}
+
+		public static MessageQueueEnumerator GetMessageQueueEnumerator (MessageQueueCriteria criteria)
+		{
+			return new MessageQueueEnumerator (filteredQueueList (criteria));
+		}
+
+		public static MessageQueue[] GetPrivateQueuesByMachine (string machineName)
+		{
+			if (machineName == null || machineName.Length == 0)
+				throw new ArgumentException ();
+			ArrayList list = new ArrayList ();
+			foreach (MessageQueue queue in currentQueueList)
+				if (queue.machineName == machineName && queue.isPrivate)
+					list.Add (queue);
+			return (MessageQueue[]) list.ToArray (typeof(MessageQueue));
+		}
+
+		[MonoTODO]
+		public static MessageQueue[] GetPublicQueues ()
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static MessageQueue[] GetPublicQueues (MessageQueueCriteria criteria)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static MessageQueue[] GetPublicQueuesByCategory (Guid category)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static MessageQueue[] GetPublicQueuesByLabel (string label)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public static MessageQueue[] GetPublicQueuesByMachine (string machineName)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message Peek ()
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message Peek (TimeSpan timeout)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message PeekByCorrelationId (string correlationId)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message PeekByCorrelationId (string correlationId, TimeSpan timeout)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message PeekById (string id)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message PeekById (string id, TimeSpan timeout)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void Purge ()
+		{
+			throw new NotImplementedException ();
+		}
+		
+		public Message Receive ()
+		{
+			IQueue q = provider.GetQueue (qRef);
+			return q.Receive ();
+		}
+		
+		[MonoTODO]
+		public Message Receive (MessageQueueTransaction transaction)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message Receive (MessageQueueTransactionType transactionType)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message Receive (TimeSpan timeout)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message Receive (TimeSpan timeout, MessageQueueTransaction transaction)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message Receive (TimeSpan timeout, MessageQueueTransactionType transactionType)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveByCorrelationId (string correlationId)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveByCorrelationId (string correlationId, MessageQueueTransaction transaction)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveByCorrelationId (string correlationId, MessageQueueTransactionType transactionType)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, MessageQueueTransaction transaction)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, MessageQueueTransactionType transactionType)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveById (string id)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveById (string id, MessageQueueTransaction transaction)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveById (string id, MessageQueueTransactionType transactionType)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveById (string id, TimeSpan timeout)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveById (string id, TimeSpan timeout, MessageQueueTransaction transaction)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public Message ReceiveById (string id, TimeSpan timeout, MessageQueueTransactionType transactionType)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void Refresh ()
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void ResetPermissions ()
+		{
+			throw new NotImplementedException ();
+		}
+		
+		///
+		/// Sends a message to this queue.  If the value is a Message
+		/// object, it will send it unchanged, otherwise it will create
+		/// a new Message object with the supplied object as the body.
+		/// 
+		public void Send (object obj)
+		{
+			if (typeof (Message) == obj.GetType ()) {
+				IQueue q = provider.GetQueue (qRef);
+				q.Deliver ((Message) obj);
+			} else {
+				Message m = new Message(obj);
+				Send(m);
+			}
+		}
+		
+		[MonoTODO]
+		public void Send (object obj, MessageQueueTransaction transaction)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void Send (object obj, MessageQueueTransactionType transactionType)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void Send (object obj, string label)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void Send (object obj, string label, MessageQueueTransaction transaction)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void Send (object obj, string label, MessageQueueTransactionType transactionType)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void SetPermissions (AccessControlList dacl)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void SetPermissions (MessageQueueAccessControlEntry ace)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void SetPermissions (string user, MessageQueueAccessRights rights)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		public void SetPermissions (string user, MessageQueueAccessRights rights, AccessControlEntryType entryType)
+		{
+			throw new NotImplementedException ();
+		}
+		[MonoTODO]
+		protected override void Dispose (bool disposing)
+		{
+			throw new NotImplementedException ();
+		}
+
+		#endregion //Methods
+
+		//TODO: Use these events.
+
+		[MessagingDescription ("MQ_PeekCompleted")]
+		public event PeekCompletedEventHandler PeekCompleted;
+
+		[MessagingDescription ("MQ_ReceiveCompleted")]
+		public event ReceiveCompletedEventHandler ReceiveCompleted;
+	}
+}
Index: class/System.Messaging/Mono.Messaging/MessagingUtil.cs
===================================================================
--- class/System.Messaging/Mono.Messaging/MessagingUtil.cs	(revision 0)
+++ class/System.Messaging/Mono.Messaging/MessagingUtil.cs	(revision 0)
@@ -0,0 +1,43 @@
+//
+// Mono.Messaging
+//
+// Authors:
+//      Michael Barker (mike@middlesoft.co.uk)
+//
+// (C) 2008 Michael Barker
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Messaging;
+
+namespace Mono.Messaging
+{
+	public class MessagingUtil
+	{
+		public static MessageQueue CreateMessageQueue (IMessagingProvider mp, QueueReference qRef)
+		{
+			return new MessageQueue (mp, qRef);
+		}
+	}
+}
Index: class/System.Messaging/Mono.Messaging/IQueue.cs
===================================================================
--- class/System.Messaging/Mono.Messaging/IQueue.cs	(revision 0)
+++ class/System.Messaging/Mono.Messaging/IQueue.cs	(revision 0)
@@ -0,0 +1,42 @@
+//
+// Mono.Messaging
+//
+// Authors:
+//      Michael Barker (mike@middlesoft.co.uk)
+//
+// (C) 2008 Michael Barker
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Messaging;
+
+namespace Mono.Messaging
+{
+	public interface IQueue
+	{
+		void Deliver (Message message);
+		Message Receive ();
+	}
+}
+
Index: class/System.Messaging/Mono.Messaging/IMessagingProvider.cs
===================================================================
--- class/System.Messaging/Mono.Messaging/IMessagingProvider.cs	(revision 0)
+++ class/System.Messaging/Mono.Messaging/IMessagingProvider.cs	(revision 0)
@@ -0,0 +1,44 @@
+//
+// Mono.Messaging
+//
+// Authors:
+//      Michael Barker (mike@middlesoft.co.uk)
+//
+// (C) 2008 Michael Barker
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Messaging;
+
+namespace Mono.Messaging
+{
+	public interface IMessagingProvider
+	{
+		///
+		/// Gets a queue instance from the queue provider using the
+		/// supplied queue reference information.
+		///
+		IQueue GetQueue (QueueReference queueReference);
+	}
+}
Index: class/System.Messaging/Mono.Messaging/QueueReference.cs
===================================================================
--- class/System.Messaging/Mono.Messaging/QueueReference.cs	(revision 0)
+++ class/System.Messaging/Mono.Messaging/QueueReference.cs	(revision 0)
@@ -0,0 +1,100 @@
+//
+// Mono.Messaging
+//
+// Authors:
+//      Michael Barker (mike@middlesoft.co.uk)
+//
+// (C) 2008 Michael Barker
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Messaging;
+
+namespace Mono.Messaging
+{
+	public sealed class QueueReference
+	{
+		private readonly string host;
+		private readonly bool isPrivate;
+		private readonly string queue;
+		public static readonly string LOCALHOST = ".";
+
+		public QueueReference (string host, bool isPrivate, string queue)
+		{
+			this.host = host;
+			this.isPrivate = isPrivate;
+			this.queue = queue;
+		}
+		
+		public string Host {
+			get { return host; }
+		}
+		
+		public string Queue {
+			get { return queue; }
+		}
+		
+		public QueueReference SetHost (string host)
+		{
+			return new QueueReference (host, this.isPrivate, this.queue);
+		}
+		
+		public QueueReference SetQueue (string queue)
+		{
+			return new QueueReference (this.host, this.isPrivate, queue);
+		}
+
+
+		public override bool Equals (object other)
+		{
+			Console.Write("Equals Called\n");
+			if (other == null)
+				return false;
+			else if (typeof (QueueReference) != other.GetType ())
+				return false;
+			else {
+				QueueReference qr = (QueueReference) other;
+				return Equals (qr);
+			}
+		}
+
+		public bool Equals (QueueReference other)
+		{
+			QueueReference qr = (QueueReference) other;
+			return host == qr.host 
+				&& isPrivate == qr.isPrivate
+				&& queue == qr.queue;
+		}
+
+		public static bool operator == (QueueReference a, QueueReference b)
+		{
+			return a.Equals (b);
+		}
+		
+		public static bool operator != (QueueReference a, QueueReference b)
+		{
+			return !a.Equals (b);
+		}
+	}
+}
Index: class/System.Messaging/Mono.Messaging/ChangeLog
===================================================================
--- class/System.Messaging/Mono.Messaging/ChangeLog	(revision 0)
+++ class/System.Messaging/Mono.Messaging/ChangeLog	(revision 0)
@@ -0,0 +1,7 @@
+2008-04-06  Michael Barker <mike@middlesoft.co.uk>
+	* IMessagingProvider.cs:  Added provider interface.
+	* IQueue.cs:  Added provider interface.
+	* MessagingUtil.cs:  Added a utility for creating a MessageQueue using
+	an internal constructor to support provider injection.
+	* QueueReference.cs:  Added flyweight to work as handle for a queue.
+
Index: class/System.Messaging/ChangeLog
===================================================================
--- class/System.Messaging/ChangeLog	(revision 99955)
+++ class/System.Messaging/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2008-04-06  Michael Barker <mike@middlesoft.co.uk>
+	* System.Messaging.dll.sources: Added entries for Mono.Messaging
+	provider layer and utility classes.
+	* System.Messaging_test.dll.sources: Added entries for addition
+	System.Messaging tests and new Mono.Messaging tests.
+	* Makefile: Added System.Xml.dll to build references.
+	
 2004-09-10  Sebastien Pouliot  <sebastien@ximian.com>
 
 	* Makefile: Activate unit tests.
Index: class/System.Messaging/System.Messaging_test.dll.sources
===================================================================
--- class/System.Messaging/System.Messaging_test.dll.sources	(revision 99955)
+++ class/System.Messaging/System.Messaging_test.dll.sources	(working copy)
@@ -1 +1,5 @@
-System.Messaging/MessageQueuePermissionAttributeTest.cs
+System.Messaging/MessageTest.cs
+System.Messaging/MessageQueueTest.cs
+System.Messaging/BinaryMessageFormatterTest.cs
+System.Messaging/XmlMessageFormatterTest.cs
+Mono.Messaging/QueueReferenceTest.cs
Index: class/System.Messaging/System.Messaging.dll.sources
===================================================================
--- class/System.Messaging/System.Messaging.dll.sources	(revision 99955)
+++ class/System.Messaging/System.Messaging.dll.sources	(working copy)
@@ -51,3 +51,7 @@
 System.Messaging.Design/TimeoutConverter.cs
 System.Messaging.Design/QueuePathDialog.cs
 System.Messaging.Design/QueuePathEditor.cs
+Mono.Messaging/IMessagingProvider.cs
+Mono.Messaging/IQueue.cs
+Mono.Messaging/MessagingUtil.cs
+Mono.Messaging/QueueReference.cs
Index: class/System.Messaging/Makefile
===================================================================
--- class/System.Messaging/Makefile	(revision 99955)
+++ class/System.Messaging/Makefile	(working copy)
@@ -7,7 +7,8 @@
 	        /r:System.dll \
 		/r:System.Configuration.Install.dll \
 		/r:System.Drawing.dll \
-		/r:System.Windows.Forms.dll
+		/r:System.Windows.Forms.dll \
+		/r:System.Xml
 TEST_MCS_FLAGS = $(LIB_MCS_FLAGS) -nowarn:0618 -nowarn:219 -nowarn:169
 
 EXTRA_DISTFILES = System.Messaging/MessageQueue.resx