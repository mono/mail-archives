--- Queue.cs	2006-10-03 07:00:40.000000000 +0200
+++ mono-1.2.3.20070215/mcs/class/System/System.Collections.Generic/Queue.cs	2007-02-15 22:08:39.000000000 +0100
@@ -41,18 +41,18 @@
 	[Serializable]
 	public class Queue<T> : IEnumerable <T>, ICollection, IEnumerable
 	{
-		T [] data;
-		int head;
-		int tail;
-		int size;
-		int version;
-		int defaultCapacity;
+		T [] _array;
+		int _head;
+		int _tail;
+		int _size;
+		int _version;
+		//int defaultCapacity;	// Useless as it was introducing breaking change with .NET
 
-		private readonly static int INITIAL_SIZE = 16;
+		// private readonly static int INITIAL_SIZE = 16;	// Useless as it was introducing breaking change with .NET
 		
 		public Queue ()
 		{
-			defaultCapacity = INITIAL_SIZE;
+			//defaultCapacity = INITIAL_SIZE;
 		}
 		
 		public Queue (int count)
@@ -60,8 +60,8 @@
 			if (count < 0)
 				throw new ArgumentOutOfRangeException ("count");
 
-			defaultCapacity = count;
-			data = new T [count];
+			//defaultCapacity = count;
+			_array = new T [count];
 		}
 		
 		public Queue (IEnumerable <T> collection)
@@ -71,15 +71,15 @@
 			
 			foreach (T t in collection)
 				Enqueue (t);
-			defaultCapacity = size;
+			//defaultCapacity = _size;
 		}
 		
 		public void Clear ()
 		{
-			if (data != null)
-				Array.Clear (data, 0, data.Length);
+			if (_array != null)
+				Array.Clear (_array, 0, _array.Length);
 			
-			head = tail = size = 0;
+			_head = _tail = _size = 0;
 		}
 		
 		public bool Contains (T item)
@@ -105,20 +105,20 @@
 			if ((uint) idx > (uint) array.Length)
 				throw new ArgumentOutOfRangeException ();
 			
-			if (array.Length - idx < size)
+			if (array.Length - idx < _size)
 				throw new ArgumentOutOfRangeException ();
 			
-			if (size == 0)
+			if (_size == 0)
 				return;
 			
-			int contents_length = data.Length;
-			int length_from_head = contents_length - head;
+			int contents_length = _array.Length;
+			int length_from_head = contents_length - _head;
 			
-			Array.Copy (data, head, array, idx, Math.Min (size, length_from_head));
-			if (size > length_from_head)
-				Array.Copy (data, 0, array, 
+			Array.Copy (_array, _head, array, idx, Math.Min (_size, length_from_head));
+			if (_size > length_from_head)
+				Array.Copy (_array, 0, array, 
 					    idx  + length_from_head,
-					    size - length_from_head);
+					    _size - length_from_head);
 			
 		}
 		
@@ -130,21 +130,21 @@
 			if ((uint) idx < (uint) array.Length)
 				throw new ArgumentOutOfRangeException ();
 			
-			if (array.Length - idx < size)
+			if (array.Length - idx < _size)
 				throw new ArgumentOutOfRangeException ();
 			
-			if (size == 0)
+			if (_size == 0)
 				return;
 			
 			try {
-				int contents_length = data.Length;
-				int length_from_head = contents_length - head;
+				int contents_length = _array.Length;
+				int length_from_head = contents_length - _head;
 				
-				Array.Copy (data, head, array, idx, Math.Min (size, length_from_head));
-				if (size > length_from_head)
-					Array.Copy (data, 0, array, 
+				Array.Copy (_array, _head, array, idx, Math.Min (_size, length_from_head));
+				if (_size > length_from_head)
+					Array.Copy (_array, 0, array, 
 						    idx  + length_from_head,
-						    size - length_from_head);
+						    _size - length_from_head);
 			} catch (ArrayTypeMismatchException) {
 				throw new ArgumentException ();
 			}
@@ -155,71 +155,78 @@
 			T ret = Peek ();
 			
 			// clear stuff out to make the GC happy
-			data [head] = default (T);
+			_array [_head] = default (T);
 			
-			if (++head == data.Length)
-				head = 0;
-			size --;
-			version ++;
+			if (++_head == _array.Length)
+				_head = 0;
+			_size --;
+			_version ++;
 			
 			return ret;
 		}
 		
 		public T Peek ()
 		{
-			if (size == 0)
+			if (_size == 0)
 				throw new InvalidOperationException ();
 			
-			return data [head];
+			return _array [_head];
 		}
 		
 		public void Enqueue (T item)
 		{
-			if (data == null || size == data.Length)
-				SetCapacity (Math.Max (size * 2, 4));
+			if (_array == null || _size == _array.Length)
+				SetCapacity (Math.Max (_size * 2, 4));
 			
-			data [tail] = item;
+			_array [_tail] = item;
 			
-			if (++tail == data.Length)
-				tail = 0;
+			if (++_tail == _array.Length)
+				_tail = 0;
 			
-			size ++;
-			version ++;
+			_size ++;
+			_version ++;
 		}
 		
 		public T [] ToArray ()
 		{
-			T [] t = new T [size];
+			T [] t = new T [_size];
 			CopyTo (t, 0);
 			return t;
 		}
 
 		public void TrimExcess ()
 		{
-			if (data != null && (size < data.Length * 0.9))
-				Array.Resize <T> (ref data, size == 0 ? defaultCapacity : size);
+			if (_array != null && (_size < _array.Length * 0.9))
+				// Aulofee customization - start
+				// This 'optimization' could make an application running under Mono behave differently from running .NET.
+				// Moreover, it was not increasing the 'version' field, was not changing the head and tail...
+				// I replaced it with a call to SetCapacity.
+				// Original line was:
+				//Array.Resize <T> (ref _array, _size == 0 ? defaultCapacity : _size);
+				SetCapacity(_size);
+				// Aulofee customization - end
 		}
 		
 		void SetCapacity (int new_size)
 		{
-			if (data != null && new_size == data.Length)
+			if (_array != null && new_size == _array.Length)
 				return;
 			
-			if (new_size < size)
+			if (new_size < _size)
 				throw new InvalidOperationException ("shouldnt happen");
 			
 			T [] new_data = new T [new_size];
-			if (size > 0)
+			if (_size > 0)
 				CopyTo (new_data, 0);
 			
-			data = new_data;
-			tail = size;
-			head = 0;
-			version ++;
+			_array = new_data;
+			_tail = _size;
+			_head = 0;
+			_version ++;
 		}
 		
 		public int Count {
-			get { return size; }
+			get { return _size; }
 		}
 		
 		bool ICollection.IsSynchronized {
@@ -250,7 +257,7 @@
 			const int NOT_STARTED = -2;
 			
 			// this MUST be -1, because we depend on it in move next.
-			// we just decr the size, so, 0 - 1 == FINISHED
+			// we just decr the _size, so, 0 - 1 == FINISHED
 			const int FINISHED = -1;
 			
 			Queue <T> q;
@@ -261,7 +268,7 @@
 			{
 				this.q = q;
 				idx = NOT_STARTED;
-				ver = q.version;
+				ver = q._version;
 			}
 			
 			// for some fucked up reason, MSFT added a useless dispose to this class
@@ -274,11 +281,11 @@
 			
 			public bool MoveNext ()
 			{
-				if (ver != q.version)
+				if (ver != q._version)
 					throw new InvalidOperationException ();
 				
 				if (idx == NOT_STARTED)
-					idx = q.size;
+					idx = q._size;
 				
 				return idx != FINISHED && -- idx != FINISHED;
 			}
@@ -288,13 +295,13 @@
 					if (idx < 0)
 						throw new InvalidOperationException ();
 					
-					return q.data [(q.size - 1 - idx + q.head) % q.data.Length];
+					return q._array [(q._size - 1 - idx + q._head) % q._array.Length];
 				}
 			}
 			
 			void IEnumerator.Reset ()
 			{
-				if (ver != q.version)
+				if (ver != q._version)
 					throw new InvalidOperationException ();
 				
 				idx = NOT_STARTED;
