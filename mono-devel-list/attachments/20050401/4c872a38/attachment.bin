using System;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using System.Collections;

namespace TestRunner {

	class ReflectionTester {
		MethodInfo ep;
		MethodInfo reset;
		object[] method_arg;
		StringWriter output;

		public ReflectionTester (Assembly a)
		{
			ep = a.GetType ("Mono.CSharp.CompilerCallableEntryPoint").GetMethod ("InvokeCompiler", 
				BindingFlags.Static | BindingFlags.Public);
			
			reset = a.GetType ("Mono.CSharp.CompilerCallableEntryPoint").GetMethod ("Reset", 
				BindingFlags.Static | BindingFlags.NonPublic);
			if (ep == null)
				throw new MissingMethodException ("static InvokeCompiler");
			method_arg = new object [1];
		}

		public string Output {
			get {
				return output.GetStringBuilder ().ToString ();
			}
		}

		public bool Invoke(string[] args)
		{
			TextWriter old_writer = Console.Error;
			output = new StringWriter ();
			Console.SetError (output);
			method_arg [0] = args;
			try {
				return (bool)ep.Invoke (null, method_arg);
			}
			finally {
				Console.SetError (old_writer);
			}
		}
		
		public void Reset ()
		{
			reset.Invoke (null, null);
		}
	}
	
	class Tester {

		static void Main (string [] args)
		{
			ReflectionTester tester = new ReflectionTester (Assembly.LoadFile (args [0]));
			
			string [] args2 = new string [args.Length - 1];
			
			for (int i = 1; i < args.Length; i ++)
				args2 [i - 1] = args [i];
			
			while (true) {
			//for (int i = 0; i < 20; i ++) {
				tester.Invoke (args2);
				Console.WriteLine (tester.Output);
			}
			
			tester.Reset ();
			
			for (int i = 0; i < 5; i ++)
				GC.Collect ();
		}

	}
}
