// Functions.cs
//
// Copyright (c) 2008 Bojan Rajkovic
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
//

using System;

namespace MathPlay
{
	public enum ApproximationType
	{
		Left,
		Right,
		Midpoint
	}
	
	static class Function
	{
		public static double Limit(double accuracy, long step, Func<long, double> f)
		{
			double lastResult, nextResult;
			long n = 0;
			lastResult = f(n);
			if (double.IsNaN(lastResult)) lastResult = 0;
			else if (double.IsInfinity(lastResult)) lastResult = 0;
			long iterations = 0;
			while (true) {
				n += step;
				nextResult = f(n);
				double differential = Math.Abs(nextResult - lastResult);
				if (differential <= accuracy) {
					return nextResult;
				} else {
					lastResult = nextResult;
					iterations++;
				}
			}
		}
	
		public static class Derivative
		{
			public static double Numeric(double startingApproximation, double minimumApproximation, double x, Func<double, double> f)
			{
				if (startingApproximation <= minimumApproximation)
					return f(x);
				double approximation = startingApproximation;
				double value = f(x);
				while (approximation > minimumApproximation) {
					value = (f(x + approximation) - f(x - approximation))/(2*approximation);
					approximation /= 2;
				}
				return value;
			}
		}
		
		public static class Integral
		{
			public static double BoxApproximation(double start, double end, long steps, Func<double, double> f, ApproximationType type)
			{
				double delta = (end - start)/steps;
				double approximationFactor = 0;
				double result = 0;
		
				switch (type) {
					case ApproximationType.Left:
						approximationFactor = 1;
						break;
					case ApproximationType.Midpoint:
						approximationFactor = .5;
						break;
					case ApproximationType.Right:
						approximationFactor = 0;
						break;
					default:
						approximationFactor = 0;
						break;
				}
							
				for (int i = 0; i <= steps; i++)
					result += f(start + (i + approximationFactor)*delta) * delta;
		
				return result;
			}
			
			public static double MidpointApproximation(double start, double end, long steps, Func<double, double> f)
			{
				double delta = (end - start)/steps;
				double result = 0;
							
				for (int i = 0; i <= steps; i++)
					result += f(start + (i + 0.5)*delta) * delta;
		
				return result;
			}		
			
			public static double MidpointApproximationInline(double start, double end, long steps)
			{
				double delta = (end - start)/steps;
				double result = 0;
				double x;
							
				for (int i = 0; i <= steps; i++) {
					x = (start + (i + 0.5)*delta);
					result += x*x*x*delta;
				}
		
				return result;
			}
			
			public static double BoxApproximationInline(double start, double end, long steps, ApproximationType type)
			{
				double delta = (end - start)/steps;
				double approximationFactor = 0;
				double result = 0;
				double x;
		
				switch (type) {
					case ApproximationType.Left:
						approximationFactor = 1;
						break;
					case ApproximationType.Midpoint:
						approximationFactor = .5;
						break;
					case ApproximationType.Right:
						approximationFactor = 0;
						break;
					default:
						approximationFactor = 0;
						break;
				}
								
				for (int i = 0; i <= steps; i++) {
					x = (start + (i + approximationFactor)*delta);
					result += x*x*x*delta;
				}
		
				return result;
			}
				
	
			public static double SimpsonApproximation(double start, double end, double accuracy, Func<double, double> f)
			{ 	
				double h = end - start;
				double s2 = 1;
				double s = f(start) + f(end);
				double s1, s3, x;
				int iterations = 0;
		
				do {
					s3 = s2;
					h /= 2;
					s1 = 0;
					x = start + h;
					do {
						s1 += 2*f(x);
						x += 2*h;
					} while (x < end);
		
					s += s1;
					s2 = (s + s1)*h/3;
					x = Math.Abs(s3 - s2)/15;
					iterations++;
				} while ( x > accuracy);
		
				return s2;
			}
		}
	}
}
