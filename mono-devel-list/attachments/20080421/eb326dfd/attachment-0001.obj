Index: System.Linq/Queryable.cs
===================================================================
--- System.Linq/Queryable.cs	(revision 101291)
+++ System.Linq/Queryable.cs	(working copy)
@@ -383,7 +383,7 @@
 		{
 			Check.Source1AndSource2 (source1, source2);
 
-			return source1.Provider.Execute<IQueryable<TSource>> (
+            return source1.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source1.Expression,
@@ -443,21 +443,21 @@
 
 		#region DefaultIfEmpty
 
-		public static TSource DefaultIfEmpty<TSource> (this IQueryable<TSource> source)
+        public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source)
 		{
 			Check.Source (source);
 
-			return source.Provider.Execute<TSource> (
+			return source.Provider.CreateQuery<TSource> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression));
 		}
 
-		public static TSource DefaultIfEmpty<TSource> (this IQueryable<TSource> source, TSource defaultValue)
+        public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source, TSource defaultValue)
 		{
 			Check.Source (source);
 
-			return source.Provider.Execute<TSource> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
@@ -468,21 +468,21 @@
 
 		#region Distinct
 
-		public static bool Distinct<TSource> (this IQueryable<TSource> source)
+        public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source)
 		{
 			Check.Source (source);
 
-			return source.Provider.Execute<bool> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression));
 		}
 
-		public static bool Distinct<TSource> (this IQueryable<TSource> source, IEqualityComparer<TSource> comparer)
+        public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source, IEqualityComparer<TSource> comparer)
 		{
 			Check.Source (source);
 
-			return source.Provider.Execute<bool> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
@@ -527,7 +527,7 @@
 		{
 			Check.Source1AndSource2 (source1, source2);
 
-			return source1.Provider.Execute<IQueryable<TSource>> (
+			return source1.Provider.CreateQuery<TSource> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source1.Expression,
@@ -538,7 +538,7 @@
 		{
 			Check.Source1AndSource2 (source1, source2);
 
-			return source1.Provider.Execute<IQueryable<TSource>> (
+            return source1.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source1.Expression,
@@ -604,7 +604,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IQueryable<IGrouping<TKey, TSource>>> (
+			return source.Provider.CreateQuery<IGrouping<TKey, TSource>> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -614,7 +614,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IQueryable<IGrouping<TKey, TSource>>> (
+			return source.Provider.CreateQuery<IGrouping<TKey, TSource>> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -625,7 +625,7 @@
 		{
 			Check.SourceAndKeyElementSelectors (source, keySelector, elementSelector);
 
-			return source.Provider.Execute<IQueryable<IGrouping<TKey, TSource>>> (
+			return source.Provider.CreateQuery<IGrouping<TKey, TSource>> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey), typeof (TElement)),
 					source.Expression,
@@ -636,7 +636,7 @@
 		{
 			Check.SourceAndKeyResultSelectors (source, keySelector, resultSelector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+            return source.Provider.CreateQuery<TResult>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey), typeof (TResult)),
 					source.Expression,
@@ -647,7 +647,7 @@
 		{
 			Check.SourceAndKeyElementSelectors (source, keySelector, elementSelector);
 
-			return source.Provider.Execute<IQueryable<IGrouping<TKey, TElement>>> (
+            return source.Provider.CreateQuery<IGrouping<TKey, TElement>>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey), typeof (TElement)),
 					source.Expression,
@@ -659,7 +659,7 @@
 		{
 			Check.GroupBySelectors (source, keySelector, elementSelector, resultSelector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+			return source.Provider.CreateQuery<TResult> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey), typeof (TElement), typeof (TResult)),
 					source.Expression,
@@ -672,7 +672,7 @@
 		{
 			Check.SourceAndKeyResultSelectors (source, keySelector, resultSelector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+            return source.Provider.CreateQuery <TResult> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey), typeof (TResult)),
 					source.Expression,
@@ -684,7 +684,7 @@
 		{
 			Check.GroupBySelectors (source, keySelector, elementSelector, resultSelector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+            return source.Provider.CreateQuery <TResult> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey), typeof (TElement), typeof (TResult)),
 					source.Expression,
@@ -710,7 +710,7 @@
 			if (resultSelector == null)
 				throw new ArgumentNullException ("resultSelector");
 
-			return outer.Provider.Execute<IQueryable<TResult>> (
+			return outer.Provider.CreateQuery <TResult> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TOuter), typeof (TInner), typeof (TKey), typeof (TResult)),
 					outer.Expression,
@@ -733,7 +733,7 @@
 			if (resultSelector == null)
 				throw new ArgumentNullException ("resultSelector");
 
-			return outer.Provider.Execute<IQueryable<TResult>> (
+            return outer.Provider.CreateQuery < TResult > (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TOuter), typeof (TInner), typeof (TKey), typeof (TResult)),
 					outer.Expression,
@@ -752,7 +752,7 @@
 		{
 			Check.Source1AndSource2 (source1, source2);
 
-			return source1.Provider.Execute<IQueryable<TSource>> (
+            return source1.Provider.CreateQuery <TSource> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source1.Expression,
@@ -763,7 +763,7 @@
 		{
 			Check.Source1AndSource2 (source1, source2);
 
-			return source1.Provider.Execute<IQueryable<TSource>> (
+            return source1.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source1.Expression,
@@ -779,7 +779,7 @@
 		{
 			Check.JoinSelectors (outer, inner, outerKeySelector, innerKeySelector, resultSelector);
 
-			return outer.Provider.Execute<IQueryable<TResult>> (
+            return outer.Provider.CreateQuery <TResult> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TOuter), typeof (TInner), typeof (TKey), typeof (TResult)),
 					outer.Expression,
@@ -793,7 +793,7 @@
 		{
 			Check.JoinSelectors (outer, inner, outerKeySelector, innerKeySelector, resultSelector);
 
-			return outer.Provider.Execute<IQueryable<TResult>> (
+            return outer.Provider.CreateQuery<TResult>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TOuter), typeof (TInner), typeof (TKey), typeof (TResult)),
 					outer.Expression,
@@ -951,7 +951,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+			return source.Provider.CreateQuery<TSource> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -962,7 +962,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+            return source.Provider.CreateQuery <TSource> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -978,7 +978,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+			return source.Provider.CreateQuery<TSource> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -989,7 +989,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+			return source.Provider.CreateQuery<TSource> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -1005,7 +1005,7 @@
 		{
 			Check.Source (source);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+			return source.Provider.CreateQuery<TSource> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression));
@@ -1019,7 +1019,7 @@
 		{
 			Check.SourceAndSelector (source, selector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+            return source.Provider.CreateQuery<TResult>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TResult)),
 					source.Expression,
@@ -1030,7 +1030,7 @@
 		{
 			Check.SourceAndSelector (source, selector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+			return source.Provider.CreateQuery<TResult> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TResult)),
 					source.Expression,
@@ -1045,7 +1045,7 @@
 		{
 			Check.SourceAndSelector (source, selector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+            return source.Provider.CreateQuery<TResult>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TResult)),
 					source.Expression,
@@ -1056,7 +1056,7 @@
 		{
 			Check.SourceAndSelector (source, selector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+            return source.Provider.CreateQuery<TResult>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TResult)),
 					source.Expression,
@@ -1067,7 +1067,7 @@
 		{
 			Check.SourceAndCollectionSelectorAndResultSelector (source, collectionSelector, resultSelector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+            return source.Provider.CreateQuery<TResult>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TCollection), typeof (TResult)),
 					source.Expression,
@@ -1079,7 +1079,7 @@
 		{
 			Check.SourceAndCollectionSelectorAndResultSelector (source, collectionSelector, resultSelector);
 
-			return source.Provider.Execute<IQueryable<TResult>> (
+            return source.Provider.CreateQuery<TResult>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TCollection), typeof (TResult)),
 					source.Expression,
@@ -1172,7 +1172,7 @@
 		{
 			Check.Source (source);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
@@ -1187,7 +1187,7 @@
 		{
 			Check.SourceAndPredicate (source, predicate);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
@@ -1198,7 +1198,7 @@
 		{
 			Check.SourceAndPredicate (source, predicate);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
@@ -1441,7 +1441,7 @@
 		{
 			Check.Source (source);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+			return source.Provider.CreateQuery<TSource> (
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
@@ -1456,7 +1456,7 @@
 		{
 			Check.SourceAndPredicate (source, predicate);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
@@ -1467,7 +1467,7 @@
 		{
 			Check.SourceAndPredicate (source, predicate);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
@@ -1482,7 +1482,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IOrderedQueryable<TSource>> (
+            return (IOrderedQueryable<TSource>)source.Provider.CreateQuery(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -1493,7 +1493,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IOrderedQueryable<TSource>> (
+            return (IOrderedQueryable<TSource>)source.Provider.CreateQuery(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -1509,7 +1509,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IOrderedQueryable<TSource>> (
+            return (IOrderedQueryable<TSource>)source.Provider.CreateQuery(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -1520,7 +1520,7 @@
 		{
 			Check.SourceAndKeySelector (source, keySelector);
 
-			return source.Provider.Execute<IOrderedQueryable<TSource>> (
+            return (IOrderedQueryable<TSource>)source.Provider.CreateQuery(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource), typeof (TKey)),
 					source.Expression,
@@ -1536,7 +1536,7 @@
 		{
 			Check.Source1AndSource2 (source1, source2);
 
-			return source1.Provider.Execute<IOrderedQueryable<TSource>> (
+            return source1.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source1.Expression,
@@ -1547,7 +1547,7 @@
 		{
 			Check.Source1AndSource2 (source1, source2);
 
-			return source1.Provider.Execute<IOrderedQueryable<TSource>> (
+            return source1.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source1.Expression,
@@ -1564,7 +1564,7 @@
 		{
 			Check.SourceAndPredicate (source, predicate);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
@@ -1575,7 +1575,7 @@
 		{
 			Check.SourceAndPredicate (source, predicate);
 
-			return source.Provider.Execute<IQueryable<TSource>> (
+            return source.Provider.CreateQuery<TSource>(
 				StaticCall (
 					MakeGeneric (MethodBase.GetCurrentMethod (), typeof (TSource)),
 					source.Expression,
Index: Test/System.Core.Tests-2008.csproj
===================================================================
--- Test/System.Core.Tests-2008.csproj	(revision 101291)
+++ Test/System.Core.Tests-2008.csproj	(working copy)
@@ -105,6 +105,7 @@
     <Compile Include="System.Linq.Expressions\ExpressionTest_Utils.cs" />
     <Compile Include="System.Linq\EnumerableMoreTest.cs" />
     <Compile Include="System.Linq\EnumerableTest.cs" />
+    <Compile Include="System.Linq\QueryableProviderTest.cs" />
     <Compile Include="System.Linq\QueryableTest.cs" />
     <Compile Include="System\TimeZoneInfo.AdjustmentRuleTest.cs" />
     <Compile Include="System\TimeZoneInfo.TransitionTimeTest.cs" />
Index: Test/System.Linq/ChangeLog
===================================================================
--- Test/System.Linq/ChangeLog	(revision 101291)
+++ Test/System.Linq/ChangeLog	(working copy)
@@ -1,32 +1,37 @@
-2008-01-22  Jb Evain  <jbevain@novell.com>
-
-	* EnumerableMoreTest.cs: add tests by
-	Andreas Noever <andreas.noever@gmail.com>.
-
-2007-11-27  Scott Peterson <lunchtimemama@gmail.com>
-
-	* EnumerableTest.cs: Added orderby test.
-
-2007-11-22  Jb Evain  <jbevain@novell.com>
-
-	* EnumerableTest.cs: Add test for Range.
-
-2007-11-13  Jb Evain  <jbevain@novell.com>
-
-	* EnumerableTest.cs: unit tests are good.
-
-2007-11-08  Jb Evain  <jbevain@novell.com>
-
-	* EnumerableTest.cs: add test for SequenceEqual.
-
-2007-11-08  Jb Evain  <jbevain@novell.com>
-
-	* EnumerableTest.cs: add simple test for Union.
-
-2007-11-08  Jb Evain  <jbevain@novell.com>
-
-	* EnumerableTest.cs: add simple test for intersect.
-
-2007-11-06  Jb Evain  <jbevain@novell.com>
-
-	* EnumerableTest.cs: add simple test for Except.
+2008-01-22  Jb Evain  <jbevain@novell.com>
+
+	* EnumerableMoreTest.cs: add tests by
+	Andreas Noever <andreas.noever@gmail.com>.
+
+2007-11-27  Scott Peterson <lunchtimemama@gmail.com>
+
+	* EnumerableTest.cs: Added orderby test.
+
+2007-11-22  Jb Evain  <jbevain@novell.com>
+
+	* EnumerableTest.cs: Add test for Range.
+
+2007-11-13  Jb Evain  <jbevain@novell.com>
+
+	* EnumerableTest.cs: unit tests are good.
+
+2007-11-08  Jb Evain  <jbevain@novell.com>
+
+	* EnumerableTest.cs: add test for SequenceEqual.
+
+2007-11-08  Jb Evain  <jbevain@novell.com>
+
+	* EnumerableTest.cs: add simple test for Union.
+
+2007-11-08  Jb Evain  <jbevain@novell.com>
+
+	* EnumerableTest.cs: add simple test for intersect.
+
+2007-11-06  Jb Evain  <jbevain@novell.com>
+
+	* EnumerableTest.cs: add simple test for Except.
+
+2007-11-06  Leonid Freydovich <leonidf@mainsoft.com>
+
+	* QueryableProviderTest.cs: add simple test for Queryable.
+
Index: Test/System.Linq/QueryableProviderTest.cs
===================================================================
--- Test/System.Linq/QueryableProviderTest.cs	(revision 0)
+++ Test/System.Linq/QueryableProviderTest.cs	(revision 0)
@@ -0,0 +1,443 @@
+﻿using System;
+using System.Text;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Linq.Expressions;
+using System.Reflection;
+
+using NUnit.Framework;
+
+
+namespace MonoTests.System.Linq
+{
+    
+    [TestFixture]
+    public class QueryableProviderTest
+    {
+        QueryProvider _provider;
+
+        Query<int> _src;
+
+        int[] _array = { 1, 2, 3 };
+        int[] _otherArray = { 0, 2 };
+
+        public QueryableProviderTest()
+        {
+            _provider = new QueryProvider();
+            _src = new Query<int>(_provider, _array);
+            
+        }
+       
+        [SetUp]
+        public void MyTestCleanup() 
+        {
+            _provider.Init();
+        }
+
+        [Test]
+        public void TestAggregate()
+        {
+            _src.Aggregate<int>((n, m) => n + m);
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+            
+        }
+
+        [Test]
+        public void TestAll()
+        {
+            _src.All<int>((n) => true);  
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestAny()
+        {
+            _src.Any<int>();
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestAverage()
+        {
+            _src.Average<int>((n) => n);
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestCast()
+        {
+            _src.Cast<int>();
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestConcat()
+        {
+            _src.Concat<int>(_otherArray);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestContains()
+        {
+            _src.Contains<int>(3);
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+
+        [Test]
+        public void TestCount()
+        {
+            _src.Count<int>();
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestDefaultIfEmpty()
+        {
+            _src.DefaultIfEmpty<int>(0);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestDistinct()
+        {
+            _src.Distinct<int>();
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestElementAt()
+        {
+            _src.ElementAt<int>(1);
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestElementAtOrDefault()
+        {
+            _src.ElementAtOrDefault<int>(1);
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestExcept()
+        {
+            _src.Except<int>(_otherArray);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestFirst()
+        {
+            _src.First<int>();
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestFirstOrDefault()
+        {
+            _src.FirstOrDefault<int>((n) => n > 1);
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestGroupBy()
+        {
+            _src.GroupBy<int, bool>((n) => n > 2);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestGroupJoin()
+        {
+            _src.GroupJoin<int, int, bool, int>(_otherArray, (n) => n > 1, (n) => n > 1, (n, col) => n);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestIntersect()
+        {
+            _src.Intersect<int>(_otherArray);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestJoin()
+        {
+            _src.Join<int, int, int, int>(_otherArray, (n) => n, (n => n), (n, m) => n + m);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestLast()
+        {
+            _src.Last<int>((n) => n > 1);
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestLastOrDefault()
+        {
+            _src.LastOrDefault<int>();
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestLongCount()
+        {
+            _src.LongCount<int>();
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestMax()
+        {
+            _src.Max<int>();
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestMin()
+        {
+            _src.Min<int>();
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestOfType()
+        {
+            _src.OfType<int>();
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestOrderBy()
+        {
+            _src.OrderBy<int, bool>((n) => n > 1);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestOrderByDescending()
+        {
+            _src.OrderByDescending<int, bool>((n) => n > 1);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestReverse()
+        {
+            _src.Reverse<int>();
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestSelect()
+        {
+            _src.Select<int, int>((n) => n);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestSelectMany()
+        {
+            _src.SelectMany<int, int>((n) => new int[] { n });
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestSequenceEqual()
+        {
+            _src.SequenceEqual<int>(_otherArray);
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestSingle()
+        {
+            (new Query<int>(_provider, new int[] { 1 })).Single<int>();
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestSingleOrDefault()
+        {
+            (new Query<int>(_provider, new int[] { 1 })).SingleOrDefault<int>();
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestSkip()
+        {
+            _src.Skip<int>(1);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestSkipWhile()
+        {
+            _src.SkipWhile<int>((n) => n > 1);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestSum()
+        {
+            _src.Sum<int>((n) => n);
+            Assert.AreEqual(StatusEnum.Execute, _provider.Status);
+        }
+
+        [Test]
+        public void TestTake()
+        {
+            _src.Take<int>(3);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+
+        [Test]
+        public void TestTakeWhile()
+        {
+            _src.TakeWhile<int>((n) => n < 2);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestThenBy()
+        {
+            _src.ThenBy<int, bool>((n) => n < 2);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestThenByDescending()
+        {
+            _src.ThenByDescending<int, bool>((n) => n < 2);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestUnion()
+        {
+            _src.Union<int>(_otherArray);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        [Test]
+        public void TestWhere()
+        {
+            _src.Where<int>((n) => true);
+            Assert.AreEqual(StatusEnum.CreateQuery, _provider.Status);
+        }
+
+        public class Query<T> : IQueryable<T>, IQueryable, IEnumerable<T>, IEnumerable, IOrderedQueryable<T>, IOrderedQueryable
+        {
+            IQueryProvider provider;
+
+            Expression expression;
+
+            IEnumerable<T> _context;
+
+            public Query(IQueryProvider provider, IEnumerable<T> context)
+            {
+                _context = context;
+                this.provider = provider;
+                this.expression = Expression.Constant(this);
+            }
+
+            Expression IQueryable.Expression
+            {
+
+                get { return this.expression; }
+
+            }
+
+
+
+            Type IQueryable.ElementType
+            {
+
+                get { return typeof(T); }
+
+            }
+
+
+            IQueryProvider IQueryable.Provider
+            {
+
+                get { return this.provider; }
+
+            }
+
+
+            public IEnumerator<T> GetEnumerator()
+            {
+                throw new NotImplementedException();
+            }
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                throw new NotImplementedException();
+            }
+
+        }
+
+        public enum StatusEnum { NotInitilized, Execute, CreateQuery }
+
+        public class QueryProvider : IQueryProvider
+        {
+
+            private StatusEnum _status = StatusEnum.NotInitilized;
+
+            public StatusEnum Status
+            {
+                get { return _status; }
+                set { _status = value; }
+            }
+
+            public void Init()
+            {
+                _status = StatusEnum.NotInitilized;
+            }
+
+            public QueryProvider()
+            {
+                Init();
+            }
+
+            #region IQueryProvider Members
+
+            IQueryable<S> IQueryProvider.CreateQuery<S>(Expression expression)
+            {
+                Status = StatusEnum.CreateQuery;
+                return null;
+            }
+
+            IQueryable IQueryProvider.CreateQuery(Expression expression)
+            {
+                Status = StatusEnum.CreateQuery;
+                return null;
+
+            }
+
+            S IQueryProvider.Execute<S>(Expression expression)
+            {
+                Status = StatusEnum.Execute;
+                return default(S);
+            }
+
+
+
+            object IQueryProvider.Execute(Expression expression)
+            {
+                Status = StatusEnum.Execute;
+                return null;
+
+            }
+
+            #endregion
+        }
+    }
+}
