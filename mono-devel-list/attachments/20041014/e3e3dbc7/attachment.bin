Common subdirectories: Mono.Posix/bak and Mono.Posix.new/bak
diff -u -p -N --exclude='CVS*' Mono.Posix/make-map.cs Mono.Posix.new/make-map.cs
--- Mono.Posix/make-map.cs	2004-10-14 22:26:22.523955872 -0400
+++ Mono.Posix.new/make-map.cs	2004-10-14 22:19:25.761313000 -0400
@@ -1,9 +1,12 @@
 //
 // MakeMap.cs: Builds a C map of constants defined on C# land
 //
-// Author: Miguel de Icaza (miguel@novell.com)
+// Authors:
+//  Miguel de Icaza (miguel@novell.com)
+//  Jonathan Pryor (jonpryor@vt.edu)
 //
 // (C) 2003 Novell, Inc.
+// (C) 2004 Jonathan Pryor
 //
 
 //
@@ -29,86 +32,189 @@
 using System;
 using System.IO;
 using System.Reflection;
-using Mono.Posix;
-	
+
+delegate void CreateFileHandler (string assembly_name, string file_prefix);
+delegate void AssemblyAttributesHandler (Assembly assembly);
+delegate void TypeHandler (Type t, string ns, string fn, string etype, bool bits);
+delegate void CloseFileHandler (string file_prefix);
+
 class MakeMap {
 
-	static int Main (string [] args)
+	public static int Main (string [] args)
+	{
+		FileGenerator[] generators = new FileGenerator[]{
+			new HeaderFileGenerator (),
+			new SourceFileGenerator (),
+			new WrapperFileGenerator ()
+		};
+
+		MakeMap composite = new MakeMap ();
+		foreach (FileGenerator g in generators) {
+			composite.FileCreators += new CreateFileHandler (g.CreateFile);
+			composite.AssemblyAttributesHandler += 
+				new AssemblyAttributesHandler (g.WriteAssemblyAttributes);
+			composite.TypeHandler += new TypeHandler (g.WriteType);
+			composite.FileClosers += new CloseFileHandler (g.CloseFile);
+		}
+
+		return composite.Run (args);
+	}
+
+	event CreateFileHandler FileCreators;
+	event AssemblyAttributesHandler AssemblyAttributesHandler;
+	event TypeHandler TypeHandler;
+	event CloseFileHandler FileClosers;
+
+	int Run (string[] args)
 	{
 		if (args.Length != 2){
 			Console.WriteLine ("Usage is: make-map assembly output");
 			return 1;
 		}
 		
-		StreamWriter sh = new StreamWriter (File.Create (args [1] + ".h"));
-		StreamWriter sc = new StreamWriter (File.Create (args [1] + ".c"));
-		sh.WriteLine ("/* This file was automatically generated by make-map from {0} */\n", args [0]);
-		sc.WriteLine ("/* This file was automatically generated by make-map from {0} */\n", args [0]);
+		string assembly_name = args[0];
+		string output = args[1];
+
+		FileCreators (assembly_name, output);
+
+		Assembly assembly = Assembly.LoadFrom (assembly_name);
+		AssemblyAttributesHandler (assembly);
+		
+		Type [] exported_types = assembly.GetTypes ();
+			
+		foreach (Type t in exported_types) {
+			bool bits;
+			if (!CanMapType (t, out bits))
+				continue;
+
+			string fn = t.FullName.Replace (".", "_");
+			string ns = t.Namespace.Replace (".", "_");
+      string etype = GetNativeType (t);
+
+			TypeHandler (t, ns, fn, etype, bits);
+		}
+		FileClosers (output);
+
+		return 0;
+	}
+
+	static bool CanMapType (Type t, out bool bits)
+	{
+		object [] attributes = t.GetCustomAttributes (false);
+		bool map = false;
+		bits = false;
 		
-		Assembly a = Assembly.LoadFrom (args [0]);
-		object [] x = a.GetCustomAttributes (false);
+		foreach (object attr in attributes) {
+			if (attr.GetType ().Name == "MapAttribute")
+				map = true;
+			if (attr.GetType ().Name == "FlagsAttribute")
+				bits = true;
+		}
+		return map;
+	}
+
+	static string GetNativeType (Type t)
+	{
+		string ut = Enum.GetUnderlyingType (t).Name;
+		switch (ut) {
+			case "Byte":   return "unsigned char";
+			case "SByte":  return "signed char";
+			case "Int16":  return "short";
+			case "UInt16": return "unsigned short";
+			case "Int32":  return "int";
+			case "UInt32": return "unsigned int";
+			case "Int64":  return "gint64";
+			case "UInt64": return "guint64";
+		}
+		return "int /* **unknown** " + ut + " */";
+	}
+}
+
+abstract class FileGenerator {
+	public abstract void CreateFile (string assembly_name, string file_prefix);
+
+	public virtual void WriteAssemblyAttributes (Assembly assembly)
+	{
+	}
+
+	public abstract void WriteType (Type t, string ns, string fn, string etype, bool bits);
+	public abstract void CloseFile (string file_prefix);
+
+	protected static void WriteHeader (StreamWriter s, string assembly)
+	{
+		s.WriteLine (
+				"/*\n" +
+				" * This file was automatically generated by make-map from {0}.\n" +
+				" *\n" +
+				" * DO NOT MODIFY.\n" +
+				" */\n", assembly);
+	}
+}
+
+class HeaderFileGenerator : FileGenerator {
+	StreamWriter sh;
+
+	public override void CreateFile (string assembly_name, string file_prefix)
+	{
+		sh = File.CreateText (file_prefix + ".h");
+		WriteHeader (sh, assembly_name);
+		sh.WriteLine ("#ifndef INC_Mono_Posix_" + file_prefix + "_H");
+		sh.WriteLine ("#define INC_Mono_Posix_" + file_prefix + "_H\n");
+		sh.WriteLine ("#include <glib/gtypes.h>\n");
+		sh.WriteLine ("G_BEGIN_DECLS\n");
+	}
+
+	public override void WriteType (Type t, string ns, string fn, string etype, bool bits)
+	{
+		WriteLiteralValues (sh, t, fn);
+		sh.WriteLine ("int {1}_From{2} ({0} x, {0} *r);", etype, ns, t.Name);
+		sh.WriteLine ("int {1}_To{2} ({0} x, {0} *r);", etype, ns, t.Name);
+		sh.WriteLine ();
+	}
+
+	static void WriteLiteralValues (StreamWriter sh, Type t, string n)
+	{
+		object inst = Activator.CreateInstance (t);
+		foreach (FieldInfo fi in t.GetFields ()){
+			if (!fi.IsLiteral)
+				continue;
+			sh.WriteLine ("#define {0}_{1} 0x{2:x}", n, fi.Name, fi.GetValue (inst));
+		}
+	}
+
+	public override void CloseFile (string file_prefix)
+	{
+		sh.WriteLine ("G_END_DECLS\n");
+		sh.WriteLine ("#endif /* ndef INC_Mono_Posix_" + file_prefix + "_H */\n");
+		sh.Close ();
+	}
+}
+
+class SourceFileGenerator : FileGenerator {
+	StreamWriter sc;
+
+	public override void CreateFile (string assembly_name, string file_prefix)
+	{
+		sc = File.CreateText (file_prefix + ".c");
+		WriteHeader (sc, assembly_name);
+
+		if (file_prefix.IndexOf ("/") != -1)
+			file_prefix = file_prefix.Substring (file_prefix.IndexOf ("/") + 1);
+		sc.WriteLine ("#include \"{0}.h\"", file_prefix);
+		sc.WriteLine ();
+	}
+
+	public override void WriteAssemblyAttributes (Assembly assembly)
+	{
+		object [] x = assembly.GetCustomAttributes (false);
 		Console.WriteLine ("Got: " + x.Length);
-		foreach (object aattr in a.GetCustomAttributes (false)){
+		foreach (object aattr in assembly.GetCustomAttributes (false)) {
 			Console.WriteLine ("Got: " + aattr.GetType ().Name);
 			if (aattr.GetType ().Name == "IncludeAttribute"){
 				WriteDefines (sc, aattr);
 				WriteIncludes (sc, aattr);
 			}
 		}
-		string f = args [1];
-		
-		if (f.IndexOf ("/") != -1)
-			f = f.Substring (f.IndexOf ("/") + 1);
-		sc.WriteLine ("#include \"{0}.h\"", f);
-		
-		Type [] exported_types = a.GetTypes ();
-			
-		foreach (Type t in exported_types){
-			object [] attributes = t.GetCustomAttributes (false);
-			bool do_map = false;
-			bool do_bits = false;
-			
-			foreach (object attr in attributes){
-				if (attr.GetType ().Name == "MapAttribute")
-					do_map = true;
-				if (attr.GetType ().Name == "FlagsAttribute")
-					do_bits = true;
-				
-			}
-			if (!do_map)
-				continue;
-			
-			string n = t.FullName.Replace (".", "_");
-			object inst = Activator.CreateInstance (t);
-			foreach (FieldInfo fi in t.GetFields ()){
-				if (!fi.IsLiteral)
-					continue;
-				sh.WriteLine ("#define {0}_{1} 0x{2:x}", n, fi.Name, fi.GetValue (inst));
-			}
-			sh.WriteLine ();
-			
-			sc.WriteLine ("int map_{0} (int x)", n);
-			sc.WriteLine ("{");
-			if (do_bits)
-				sc.WriteLine ("\tint r = 0;");
-			foreach (FieldInfo fi in t.GetFields ()){
-				if (!fi.IsLiteral)
-					continue;
-				if (do_bits)
-					sc.WriteLine ("\tif ((x & {0}_{1}) != 0)\n\t\tr |= {1};", n, fi.Name);
-				else
-					sc.WriteLine ("\tif (x == {0}_{1})\n\t\t return {1};", n, fi.Name);
-			}
-			if (do_bits)
-				sc.WriteLine ("\treturn r;");
-			else
-				sc.WriteLine ("\treturn -1;");
-			sc.WriteLine ("}\n");
-		}
-		sh.Close ();
-		sc.Close ();
-
-		return 0;
 	}
 
 	static void WriteDefines (TextWriter writer, object o)
@@ -133,5 +239,124 @@ class MakeMap {
 		string [] includes = (string []) method.Invoke (o, null);
 		foreach (string inc in includes)
 			writer.WriteLine ("#include <{0}>", inc);
+		writer.WriteLine ();
+	}
+
+	public override void WriteType (Type t, string ns, string fn, string etype, bool bits)
+	{
+		WriteFromManagedType (t, ns, fn, etype, bits);
+		WriteToManagedType (t, ns, fn, etype, bits);
+	}
+
+	private void WriteFromManagedType (Type t, string ns, string fn, string etype, bool bits)
+	{
+		sc.WriteLine ("int {1}_From{2} ({0} x, {0} *r)", etype, ns, t.Name);
+		sc.WriteLine ("{");
+		sc.WriteLine ("\t*r = 0;");
+		foreach (FieldInfo fi in t.GetFields ()) {
+			if (!fi.IsLiteral)
+				continue;
+			if (bits)
+				// properly handle case where [Flags] enumeration has helper
+				// synonyms.  e.g. DEFFILEMODE and ACCESSPERMS for mode_t.
+				sc.WriteLine ("\tif ((x & {0}_{1}) == {0}_{1})", fn, fi.Name);
+			else
+				sc.WriteLine ("\tif (x == {0}_{1})", fn, fi.Name);
+			sc.WriteLine ("#ifdef {0}", fi.Name);
+			if (bits)
+				sc.WriteLine ("\t\t*r |= {1};", fn, fi.Name);
+			else
+				sc.WriteLine ("\t\t{{*r = {1}; return 0;}}", fn, fi.Name);
+			sc.WriteLine ("#else /* def {0} */\n\t\t{{errno = EINVAL; return -1;}}", fi.Name);
+			sc.WriteLine ("#endif /* ndef {0} */", fi.Name);
+		}
+		if (bits)
+			sc.WriteLine ("\treturn 0;");
+		else
+			sc.WriteLine ("\terrno = EINVAL; return -1;"); // return error if not matched
+		sc.WriteLine ("}\n");
+	}
+
+	private void WriteToManagedType (Type t, string ns, string fn, string etype, bool bits)
+	{
+		sc.WriteLine ("int {1}_To{2} ({0} x, {0} *r)", etype, ns, t.Name);
+		sc.WriteLine ("{");
+		sc.WriteLine ("\t*r = 0;", etype);
+		foreach (FieldInfo fi in t.GetFields ()) {
+			if (!fi.IsLiteral)
+				continue;
+			sc.WriteLine ("#ifdef {0}", fi.Name);
+			if (bits)
+				// properly handle case where [Flags] enumeration has helper
+				// synonyms.  e.g. DEFFILEMODE and ACCESSPERMS for mode_t.
+				sc.WriteLine ("\tif ((x & {1}) == {1})\n\t\t*r |= {0}_{1};", fn, fi.Name);
+			else
+				sc.WriteLine ("\tif (x == {1})\n\t\t{{*r = {0}_{1}; return 0;}}", fn, fi.Name);
+			sc.WriteLine ("#endif /* ndef {0} */", fi.Name);
+		}
+		if (bits)
+			sc.WriteLine ("\treturn 0;");
+		else
+			sc.WriteLine ("\terrno = EINVAL; return -1;");
+		sc.WriteLine ("}\n");
+	}
+
+	public override void CloseFile (string file_prefix)
+	{
+		sc.Close ();
 	}
 }
+
+class WrapperFileGenerator : FileGenerator {
+	StreamWriter scs;
+
+	public override void CreateFile (string assembly_name, string file_prefix)
+	{
+		scs = File.CreateText (file_prefix + ".cs");
+		WriteHeader (scs, assembly_name);
+		scs.WriteLine ("using System;");
+		scs.WriteLine ("using System.Runtime.InteropServices;");
+		scs.WriteLine ("using Mono.Posix;\n");
+		scs.WriteLine ("namespace Mono.Posix {\n");
+		scs.WriteLine ("\tpublic sealed /* static */ class PosixConvert");
+		scs.WriteLine ("\t{");
+		scs.WriteLine ("\t\tprivate PosixConvert () {}\n");
+		scs.WriteLine ("\t\tprivate const string LIB = \"MonoPosixHelper\";\n");
+	}
+
+	public override void WriteType (Type t, string ns, string fn, string etype, bool bits)
+	{
+		string mtype = Enum.GetUnderlyingType(t).Name;
+		scs.WriteLine ("\t\t[DllImport (LIB, " + 
+			"EntryPoint=\"{0}_From{1}\")]\n" +
+			"\t\tprivate static extern int From{1} ({1} value, out {2} rval);\n",
+			ns, t.Name, mtype);
+		scs.WriteLine ("\t\tpublic static {0} From{1} ({1} value)", mtype, t.Name);
+		scs.WriteLine ("\t\t{");
+		scs.WriteLine ("\t\t\t{0} rval;", mtype);
+		scs.WriteLine ("\t\t\tif (From{0} (value, out rval) == -1)\n" + 
+				"\t\t\t\tthrow new ArgumentOutOfRangeException (\"value\");", t.Name);
+		scs.WriteLine ("\t\t\treturn rval;");
+		scs.WriteLine ("\t\t}\n");
+		scs.WriteLine ("\t\t[DllImport (LIB, " + 
+			"EntryPoint=\"{0}_To{1}\")]\n" +
+			"\t\tprivate static extern int To{1} ({2} value, out {1} rval);\n",
+			ns, t.Name, mtype);
+		scs.WriteLine ("\t\tpublic static {1} To{1} ({0} value)", mtype, t.Name);
+		scs.WriteLine ("\t\t{");
+		scs.WriteLine ("\t\t\t{0} rval;", t.Name);
+		scs.WriteLine ("\t\t\tif (To{0} (value, out rval) == -1)\n" + 
+				"\t\t\t\tthrow new ArgumentOutOfRangeException (\"value\");", t.Name);
+		scs.WriteLine ("\t\t\treturn rval;");
+		scs.WriteLine ("\t\t}\n");
+	}
+
+	public override void CloseFile (string file_prefix)
+	{
+		scs.WriteLine ("\t}");
+		scs.WriteLine ("}\n");
+		scs.Close ();
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixConvert.cs Mono.Posix.new/PosixConvert.cs
--- Mono.Posix/PosixConvert.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixConvert.cs	2004-10-14 22:19:27.356070000 -0400
@@ -0,0 +1,445 @@
+/* This file was automatically generated by make-map from Mono.Posix.dll */
+
+
+using System;
+using System.Runtime.InteropServices;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed /* static */ class PosixConvert
+	{
+		private PosixConvert () {}
+
+		private const string LIB = "MonoPosixHelper";
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromError")]
+		private static extern int FromError (Error value, out Int32 rval);
+
+		public static Int32 FromError (Error value)
+		{
+			Int32 rval;
+			if (FromError (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToError")]
+		private static extern int ToError (Int32 value, out Error rval);
+
+		public static Error ToError (Int32 value)
+		{
+			Error rval;
+			if (ToError (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromOpenFlags")]
+		private static extern int FromOpenFlags (OpenFlags value, out Int32 rval);
+
+		public static Int32 FromOpenFlags (OpenFlags value)
+		{
+			Int32 rval;
+			if (FromOpenFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToOpenFlags")]
+		private static extern int ToOpenFlags (Int32 value, out OpenFlags rval);
+
+		public static OpenFlags ToOpenFlags (Int32 value)
+		{
+			OpenFlags rval;
+			if (ToOpenFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromFilePermissions")]
+		private static extern int FromFilePermissions (FilePermissions value, out UInt32 rval);
+
+		public static UInt32 FromFilePermissions (FilePermissions value)
+		{
+			UInt32 rval;
+			if (FromFilePermissions (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToFilePermissions")]
+		private static extern int ToFilePermissions (UInt32 value, out FilePermissions rval);
+
+		public static FilePermissions ToFilePermissions (UInt32 value)
+		{
+			FilePermissions rval;
+			if (ToFilePermissions (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromCmdFlags")]
+		private static extern int FromCmdFlags (CmdFlags value, out Int32 rval);
+
+		public static Int32 FromCmdFlags (CmdFlags value)
+		{
+			Int32 rval;
+			if (FromCmdFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToCmdFlags")]
+		private static extern int ToCmdFlags (Int32 value, out CmdFlags rval);
+
+		public static CmdFlags ToCmdFlags (Int32 value)
+		{
+			CmdFlags rval;
+			if (ToCmdFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromLockType")]
+		private static extern int FromLockType (LockType value, out Int16 rval);
+
+		public static Int16 FromLockType (LockType value)
+		{
+			Int16 rval;
+			if (FromLockType (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToLockType")]
+		private static extern int ToLockType (Int16 value, out LockType rval);
+
+		public static LockType ToLockType (Int16 value)
+		{
+			LockType rval;
+			if (ToLockType (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromSeekFlags")]
+		private static extern int FromSeekFlags (SeekFlags value, out Int16 rval);
+
+		public static Int16 FromSeekFlags (SeekFlags value)
+		{
+			Int16 rval;
+			if (FromSeekFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToSeekFlags")]
+		private static extern int ToSeekFlags (Int16 value, out SeekFlags rval);
+
+		public static SeekFlags ToSeekFlags (Int16 value)
+		{
+			SeekFlags rval;
+			if (ToSeekFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromDirectoryNotify")]
+		private static extern int FromDirectoryNotify (DirectoryNotify value, out Int32 rval);
+
+		public static Int32 FromDirectoryNotify (DirectoryNotify value)
+		{
+			Int32 rval;
+			if (FromDirectoryNotify (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToDirectoryNotify")]
+		private static extern int ToDirectoryNotify (Int32 value, out DirectoryNotify rval);
+
+		public static DirectoryNotify ToDirectoryNotify (Int32 value)
+		{
+			DirectoryNotify rval;
+			if (ToDirectoryNotify (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromPosixFadviseFlags")]
+		private static extern int FromPosixFadviseFlags (PosixFadviseFlags value, out Int32 rval);
+
+		public static Int32 FromPosixFadviseFlags (PosixFadviseFlags value)
+		{
+			Int32 rval;
+			if (FromPosixFadviseFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToPosixFadviseFlags")]
+		private static extern int ToPosixFadviseFlags (Int32 value, out PosixFadviseFlags rval);
+
+		public static PosixFadviseFlags ToPosixFadviseFlags (Int32 value)
+		{
+			PosixFadviseFlags rval;
+			if (ToPosixFadviseFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromSignum")]
+		private static extern int FromSignum (Signum value, out Int32 rval);
+
+		public static Int32 FromSignum (Signum value)
+		{
+			Int32 rval;
+			if (FromSignum (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToSignum")]
+		private static extern int ToSignum (Int32 value, out Signum rval);
+
+		public static Signum ToSignum (Int32 value)
+		{
+			Signum rval;
+			if (ToSignum (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromMountFlags")]
+		private static extern int FromMountFlags (MountFlags value, out UInt64 rval);
+
+		public static UInt64 FromMountFlags (MountFlags value)
+		{
+			UInt64 rval;
+			if (FromMountFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToMountFlags")]
+		private static extern int ToMountFlags (UInt64 value, out MountFlags rval);
+
+		public static MountFlags ToMountFlags (UInt64 value)
+		{
+			MountFlags rval;
+			if (ToMountFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromUmountFlags")]
+		private static extern int FromUmountFlags (UmountFlags value, out Int32 rval);
+
+		public static Int32 FromUmountFlags (UmountFlags value)
+		{
+			Int32 rval;
+			if (FromUmountFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToUmountFlags")]
+		private static extern int ToUmountFlags (Int32 value, out UmountFlags rval);
+
+		public static UmountFlags ToUmountFlags (Int32 value)
+		{
+			UmountFlags rval;
+			if (ToUmountFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromWaitOptions")]
+		private static extern int FromWaitOptions (WaitOptions value, out Int32 rval);
+
+		public static Int32 FromWaitOptions (WaitOptions value)
+		{
+			Int32 rval;
+			if (FromWaitOptions (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToWaitOptions")]
+		private static extern int ToWaitOptions (Int32 value, out WaitOptions rval);
+
+		public static WaitOptions ToWaitOptions (Int32 value)
+		{
+			WaitOptions rval;
+			if (ToWaitOptions (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromAccessMode")]
+		private static extern int FromAccessMode (AccessMode value, out Int32 rval);
+
+		public static Int32 FromAccessMode (AccessMode value)
+		{
+			Int32 rval;
+			if (FromAccessMode (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToAccessMode")]
+		private static extern int ToAccessMode (Int32 value, out AccessMode rval);
+
+		public static AccessMode ToAccessMode (Int32 value)
+		{
+			AccessMode rval;
+			if (ToAccessMode (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromPathConf")]
+		private static extern int FromPathConf (PathConf value, out Int32 rval);
+
+		public static Int32 FromPathConf (PathConf value)
+		{
+			Int32 rval;
+			if (FromPathConf (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToPathConf")]
+		private static extern int ToPathConf (Int32 value, out PathConf rval);
+
+		public static PathConf ToPathConf (Int32 value)
+		{
+			PathConf rval;
+			if (ToPathConf (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromSysConf")]
+		private static extern int FromSysConf (SysConf value, out Int32 rval);
+
+		public static Int32 FromSysConf (SysConf value)
+		{
+			Int32 rval;
+			if (FromSysConf (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToSysConf")]
+		private static extern int ToSysConf (Int32 value, out SysConf rval);
+
+		public static SysConf ToSysConf (Int32 value)
+		{
+			SysConf rval;
+			if (ToSysConf (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromConfStr")]
+		private static extern int FromConfStr (ConfStr value, out Int32 rval);
+
+		public static Int32 FromConfStr (ConfStr value)
+		{
+			Int32 rval;
+			if (FromConfStr (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToConfStr")]
+		private static extern int ToConfStr (Int32 value, out ConfStr rval);
+
+		public static ConfStr ToConfStr (Int32 value)
+		{
+			ConfStr rval;
+			if (ToConfStr (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromLockFlags")]
+		private static extern int FromLockFlags (LockFlags value, out Int32 rval);
+
+		public static Int32 FromLockFlags (LockFlags value)
+		{
+			Int32 rval;
+			if (FromLockFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToLockFlags")]
+		private static extern int ToLockFlags (Int32 value, out LockFlags rval);
+
+		public static LockFlags ToLockFlags (Int32 value)
+		{
+			LockFlags rval;
+			if (ToLockFlags (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_FromPollEvents")]
+		private static extern int FromPollEvents (PollEvents value, out Int16 rval);
+
+		public static Int16 FromPollEvents (PollEvents value)
+		{
+			Int16 rval;
+			if (FromPollEvents (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+		[DllImport (LIB, EntryPoint="Mono_Posix_ToPollEvents")]
+		private static extern int ToPollEvents (Int16 value, out PollEvents rval);
+
+		public static PollEvents ToPollEvents (Int16 value)
+		{
+			PollEvents rval;
+			if (ToPollEvents (value, out rval) == -1)
+				throw new ArgumentOutOfRangeException ("value");
+			return rval;
+		}
+
+    // convert from octal representation.
+    public static FilePermissions ToFilePermissions (string value)
+    {
+      uint n = Convert.ToUInt32 (value, 8);
+      return ToFilePermissions (n);
+    }
+
+		public static readonly DateTime UnixEpoch = 
+			new DateTime (1970, 1, 1).ToLocalTime();
+
+		public static DateTime ToDateTime (time_t time)
+		{
+			return FromTimeT (time);
+		}
+
+		public static time_t FromDateTime (DateTime time)
+		{
+			return ToTimeT (time);
+    }
+
+		public static DateTime FromTimeT (time_t time)
+		{
+			return UnixEpoch.Add (TimeSpan.FromSeconds (time));
+		}
+
+		public static time_t ToTimeT (DateTime time)
+		{
+			// return time.Subtract (UnixEpoch);
+			long diff = time.Ticks - UnixEpoch.Ticks;
+			return (time_t)((diff / TimeSpan.TicksPerSecond));
+		}
+	}
+}
+
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixDirectory.cs Mono.Posix.new/PosixDirectory.cs
--- Mono.Posix/PosixDirectory.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixDirectory.cs	2004-10-14 22:19:27.363069000 -0400
@@ -0,0 +1,121 @@
+//
+// Mono.Posix/PosixDirectory.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Text.RegularExpressions;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed class PosixDirectory
+	{
+		private PosixDirectory () {}
+
+		public static PosixDirectoryInfo CreateDirectory (string path, FilePermissions mode)
+		{
+			int r = Syscall.mkdir (path, mode);
+			PosixIOException.ThrowIf (r);
+			return new PosixDirectoryInfo (path);
+		}
+
+		public static PosixDirectoryInfo CreateDirectory (string path)
+		{
+			FilePermissions mode = FilePermissions.ACCESSPERMS;
+			return CreateDirectory (path, mode);
+		}
+
+		public static void Delete (string path)
+		{
+			Delete (path, false);
+		}
+
+		public static void Delete (string path, bool recursive)
+		{
+			if (!recursive) {
+				foreach (Dirent d in GetEntries (path)) {
+					File.Delete (d.d_name);
+				}
+			}
+			int r = Syscall.rmdir (path);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static bool Exists (string path)
+		{
+			int r = Syscall.access (path, AccessMode.F_OK);
+			if (r == 0)
+				return true;
+			return false;
+		}
+
+		public static Dirent[] GetEntries (string path)
+		{
+			return new PosixDirectoryInfo(path).GetEntries ();
+		}
+
+		public static Dirent[] GetEntries (string path, Regex regex)
+		{
+			return new PosixDirectoryInfo(path).GetEntries (regex);
+		}
+
+		public static Dirent[] GetEntries (string path, string regex)
+		{
+			return new PosixDirectoryInfo(path).GetEntries (regex);
+		}
+
+		public static PosixFileSystemInfo[] GetFileSystemEntries (string path)
+		{
+			return new PosixDirectoryInfo(path).GetFileSystemEntries ();
+		}
+
+		public static PosixFileSystemInfo[] GetFileSystemEntries (string path, Regex regex)
+		{
+			return new PosixDirectoryInfo(path).GetFileSystemEntries (regex);
+		}
+
+		public static PosixFileSystemInfo[] GetFileSystemEntries (string path, string regex)
+		{
+			return new PosixDirectoryInfo(path).GetFileSystemEntries (regex);
+		}
+
+		public static Stat GetDirectoryStatus (string path)
+		{
+			return PosixFile.GetFileStatus (path);
+		}
+
+		public static void SetCurrentDirectory (string path)
+		{
+			int r = Syscall.chdir (path);
+			PosixIOException.ThrowIf (r);
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixDirectoryInfo.cs Mono.Posix.new/PosixDirectoryInfo.cs
--- Mono.Posix/PosixDirectoryInfo.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixDirectoryInfo.cs	2004-10-14 22:19:27.374068000 -0400
@@ -0,0 +1,191 @@
+//
+// Mono.Posix/PosixDirectoryInfo.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Text;
+using System.Text.RegularExpressions;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public class PosixDirectoryInfo : PosixFileSystemInfo
+	{
+		public PosixDirectoryInfo (string path)
+			: base (path)
+		{
+		}
+
+		internal PosixDirectoryInfo (string path, Stat stat)
+			: base (path, stat)
+		{
+		}
+
+		public void Create (FilePermissions mode)
+		{
+			int r = Syscall.mkdir (Path, mode);
+			PosixIOException.ThrowIf (r);
+			base.Refresh ();
+		}
+
+		public void Create ()
+		{
+			FilePermissions mode = FilePermissions.ACCESSPERMS;
+			Create (mode);
+		}
+
+		public override void Delete ()
+		{
+			Delete (false);
+		}
+
+		public void Delete (bool recursive)
+		{
+			if (recursive) {
+				foreach (Dirent d in GetEntries ()) {
+					File.Delete (d.d_name);
+				}
+			}
+			int r = Syscall.rmdir (Path);
+			PosixIOException.ThrowIf (r);
+			base.Refresh ();
+		}
+
+		public Dirent[] GetEntries ()
+		{
+			IntPtr dirp = Syscall.opendir (Path);
+			if (dirp == IntPtr.Zero)
+				PosixIOException.Throw ();
+
+			bool complete = false;
+			try {
+				Dirent[] entries = GetEntries (dirp);
+				complete = true;
+				return entries;
+			}
+			finally {
+				int r = Syscall.closedir (dirp);
+				// don't throw an exception if an exception is in progress
+				if (complete)
+					PosixIOException.ThrowIf (r);
+			}
+		}
+
+		private static Dirent[] GetEntries (IntPtr dirp)
+		{
+			ArrayList entries = new ArrayList ();
+
+			int r;
+			IntPtr result;
+			do {
+				Dirent d = new Dirent ();
+				r = Syscall.readdir_r (dirp, d, out result);
+				if (r == 0 && result != IntPtr.Zero)
+					entries.Add (d);
+			} while  (r == 0 && result != IntPtr.Zero);
+			if (r != 0)
+				PosixIOException.Throw ();
+
+			return (Dirent[]) entries.ToArray (typeof(Dirent));
+		}
+
+		public Dirent[] GetEntries (Regex regex)
+		{
+			IntPtr dirp = Syscall.opendir (Path);
+			if (dirp == IntPtr.Zero)
+				PosixIOException.Throw ();
+
+			try {
+				return GetEntries (dirp, regex);
+			}
+			finally {
+				int r = Syscall.closedir (dirp);
+				PosixIOException.ThrowIf (r);
+			}
+		}
+
+		private static Dirent[] GetEntries (IntPtr dirp, Regex regex)
+		{
+			ArrayList entries = new ArrayList ();
+
+			int r;
+			IntPtr result;
+			do {
+				Dirent d = new Dirent ();
+				r = Syscall.readdir_r (dirp, d, out result);
+				if (r == 0 && result != IntPtr.Zero && regex.Match (d.d_name).Success) {
+					entries.Add (d);
+				}
+			} while  (r == 0 && result != IntPtr.Zero);
+			if (r != 0)
+				PosixIOException.Throw ();
+
+			return (Dirent[]) entries.ToArray (typeof(Dirent));
+		}
+
+		public Dirent[] GetEntries (string regex)
+		{
+			Regex re = new Regex (regex);
+			return GetEntries (re);
+		}
+
+		public PosixFileSystemInfo[] GetFileSystemEntries ()
+		{
+			Dirent[] dentries = GetEntries ();
+			PosixFileSystemInfo[] entries = new PosixFileSystemInfo[dentries.Length];
+			for (int i = 0; i != entries.Length; ++i)
+				entries [i] = PosixFileSystemInfo.Create (dentries[i].d_name);
+			return entries;
+		}
+
+		public PosixFileSystemInfo[] GetFileSystemEntries (Regex regex)
+		{
+			Dirent[] dentries = GetEntries (regex);
+			PosixFileSystemInfo[] entries = new PosixFileSystemInfo[dentries.Length];
+			for (int i = 0; i != entries.Length; ++i) {
+				PosixFileSystemInfo p;
+				Stat s = PosixFile.GetFileStatus (dentries[i].d_name);
+				if (PosixFileSystemInfo.IsType (s.st_mode, FilePermissions.S_IFDIR))
+					p = new PosixDirectoryInfo (dentries [i].d_name, s);
+				else
+					p = new PosixFileInfo (dentries [i].d_name, s);
+				entries [i] = p;
+			}
+			return entries;
+		}
+
+		public PosixFileSystemInfo[] GetFileSystemEntries (string regex)
+		{
+			Regex re = new Regex (regex);
+			return GetFileSystemEntries (re);
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixEnvironment.cs Mono.Posix.new/PosixEnvironment.cs
--- Mono.Posix/PosixEnvironment.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixEnvironment.cs	2004-10-14 22:19:27.381067000 -0400
@@ -0,0 +1,138 @@
+//
+// Mono.Posix/PosixEnvironment.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Text;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed /* static */ class PosixEnvironment
+	{
+		private PosixEnvironment () {}
+
+		public static string CurrentDirectory {
+			get {
+				StringBuilder buf = new StringBuilder (16);
+				IntPtr r = IntPtr.Zero;
+				do {
+					buf.Capacity *= 2;
+					r = Syscall.getcwd (buf, (size_t) buf.Capacity);
+				} while (r == IntPtr.Zero && Syscall.GetLastError() == Error.ERANGE);
+				if (r == IntPtr.Zero)
+					PosixIOException.Throw ();
+				return buf.ToString ();
+			}
+			set {
+				PosixDirectory.SetCurrentDirectory (value);
+			}
+		}
+
+		public static string MachineName {
+			get {
+				StringBuilder buf = new StringBuilder (8);
+				int r = 0;
+				Error e;
+				do {
+					buf.Capacity *= 2;
+					r = Syscall.gethostname (buf);
+				} while (r == (-1) && ((e = Syscall.GetLastError()) == Error.EINVAL) || 
+						(e == Error.ENAMETOOLONG));
+				if (r == (-1))
+					PosixIOException.Throw ();
+				return buf.ToString ();
+			}
+			set {
+				Syscall.sethostname (value);
+			}
+		}
+
+		public static long GetConfigurationValue (SysConf name)
+		{
+			long r = Syscall.sysconf (name);
+			if (r == -1 && Syscall.GetLastError() == Error.EINVAL)
+				PosixIOException.Throw ();
+			return r;
+		}
+
+		public static string GetConfigurationString (ConfStr name)
+		{
+			size_t len = Syscall.confstr (name, null, (size_t) 0);
+			if (len == (size_t) 0)
+				return "";
+			StringBuilder buf = new StringBuilder (len+1);
+			len = Syscall.confstr (name, buf, len);
+			return buf.ToString ();
+		}
+
+		public static void SetNiceValue (int inc)
+		{
+			int r = Syscall.nice (inc);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static string UserName {
+			get {return PosixUser.GetCurrentUserName();}
+		}
+
+		public static pid_t CreateSession ()
+		{
+			return Syscall.setsid ();
+		}
+
+		public static void SetProcessGroup ()
+		{
+			int r = Syscall.setpgrp ();
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static pid_t GetProcessGroup ()
+		{
+			return Syscall.getpgrp ();
+		}
+
+		public static gid_t[] GetSupplementaryGroups ()
+		{
+			int ngroups = Syscall.getgroups ((size_t) 0, new gid_t[]{});
+			if (ngroups == -1)
+				PosixIOException.Throw ();
+			gid_t[] groups = new gid_t[ngroups];
+			int r = Syscall.getgroups (groups);
+			PosixIOException.ThrowIf (r);
+			return groups;
+		}
+
+		public static void SetSupplementaryGroups (gid_t[] list)
+		{
+			int r = Syscall.setgroups (list);
+			PosixIOException.ThrowIf (r);
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixFile.cs Mono.Posix.new/PosixFile.cs
--- Mono.Posix/PosixFile.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixFile.cs	2004-10-14 22:19:27.394065000 -0400
@@ -0,0 +1,498 @@
+//
+// Mono.Posix/PosixFile.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Text;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public struct PosixPipes
+	{
+		public PosixPipes (PosixStream reading, PosixStream writing)
+		{
+			Reading = reading;
+			Writing = writing;
+		}
+
+		public PosixStream Reading;
+		public PosixStream Writing;
+	}
+
+	public sealed class PosixFile
+	{
+		private PosixFile () {}
+
+		public static bool CanAccess (string path, AccessMode mode)
+		{
+			int r = Syscall.access (path, mode);
+			return r == 0;
+		}
+
+		public static void Delete (string path)
+		{
+			int r = Syscall.unlink (path);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static bool Exists (string path)
+		{
+			int r = Syscall.access (path, AccessMode.F_OK);
+			if (r == 0)
+				return true;
+			return false;
+		}
+
+		public static long GetConfigurationValue (string path, PathConf name)
+		{
+			Syscall.SetLastError (Error.ESUCCESS);
+			long r = Syscall.pathconf (path, name);
+			if (r == -1 && Syscall.GetLastError() != Error.ESUCCESS)
+				PosixIOException.Throw ();
+			return r;
+		}
+
+		public static DateTime GetLastAccessTime (string path)
+		{
+			return new PosixFileInfo (path).LastAccessTime;
+		}
+
+		public static Stat GetFileStatus (string path)
+		{
+			Stat stat;
+			int r = Syscall.stat (path, out stat);
+			PosixIOException.ThrowIf (r);
+			return stat;
+		}
+
+		public static DateTime GetLastWriteTime (string path)
+		{
+			return new PosixFileInfo(path).LastWriteTime;
+		}
+
+		public static DateTime GetLastStatusChangeTime (string path)
+		{
+			return new PosixFileInfo (path).LastStatusChangeTime;
+		}
+
+		public static FilePermissions GetPermissions (string path)
+		{
+			return new PosixFileInfo (path).Permissions;
+		}
+
+		public static string ReadLink (string path)
+		{
+			string r = TryReadLink (path);
+			if (r == null)
+				PosixIOException.Throw ();
+			return r;
+		}
+
+		public static string TryReadLink (string path)
+		{
+			// Who came up with readlink(2)?  There doesn't seem to be a way to
+			// properly handle it.
+			StringBuilder sb = new StringBuilder (512);
+			int r = Syscall.readlink (path, sb);
+			if (r == -1)
+				return null;
+			return sb.ToString().Substring (0, r);
+		}
+
+		public static void SetPermissions (string path, FilePermissions perms)
+		{
+			int r = Syscall.chmod (path, perms);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static PosixStream Create (string path)
+		{
+			FilePermissions mode = // 0644
+				FilePermissions.S_IRUSR | FilePermissions.S_IWUSR |
+				FilePermissions.S_IRGRP | FilePermissions.S_IROTH; 
+			return Create (path, mode);
+		}
+
+		public static PosixStream Create (string path, FilePermissions mode)
+		{
+			int fd = Syscall.creat (path, mode);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public static PosixPipes CreatePipes ()
+		{
+			int reading, writing;
+			int r = Syscall.pipe (out reading, out writing);
+			PosixIOException.ThrowIf (r);
+			return new PosixPipes (new PosixStream (reading), new PosixStream (writing));
+		}
+
+		public static PosixStream Open (string path, OpenFlags flags)
+		{
+			int fd = Syscall.open (path, flags);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public static PosixStream Open (string path, OpenFlags flags, FilePermissions mode)
+		{
+			int fd = Syscall.open (path, flags, mode);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public static PosixStream Open (string path, FileMode mode)
+		{
+			OpenFlags flags = ToOpenFlags (mode, FileAccess.ReadWrite);
+			int fd = Syscall.open (path, flags);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public static PosixStream Open (string path, FileMode mode, FileAccess access)
+		{
+			OpenFlags flags = ToOpenFlags (mode, access);
+			int fd = Syscall.open (path, flags);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public static PosixStream Open (string path, FileMode mode, FileAccess access, FilePermissions perms)
+		{
+			OpenFlags flags = ToOpenFlags (mode, access);
+			int fd = Syscall.open (path, flags, perms);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public static PosixStream OpenRead (string path)
+		{
+			return Open (path, FileMode.Open, FileAccess.Read);
+		}
+
+		public static PosixStream OpenWrite (string path)
+		{
+			return Open (path, FileMode.OpenOrCreate, FileAccess.Write);
+		}
+
+		public static void SetOwner (string path, uid_t owner, gid_t group)
+		{
+			int r = Syscall.chown (path, owner, group);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static void SetOwner (string path, string owner)
+		{
+			Passwd pw = Syscall.getpwnam (owner);
+			if (pw == null)
+				throw new ArgumentException (Locale.GetText ("invalid username"), "owner");
+			uid_t uid = pw.pw_uid;
+			gid_t gid = pw.pw_gid;
+			SetOwner (path, uid, gid);
+		}
+
+		public static void SetOwner (string path, string owner, string group)
+		{
+			uid_t uid = PosixUser.GetUserId (owner);
+			gid_t gid = PosixGroup.GetGroupId (group);
+
+			SetOwner (path, uid, gid);
+		}
+
+		public static void SetLinkOwner (string path, uid_t owner, gid_t group)
+		{
+			int r = Syscall.lchown (path, owner, group);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static void SetLinkOwner (string path, string owner)
+		{
+			Passwd pw = Syscall.getpwnam (owner);
+			if (pw == null)
+				throw new ArgumentException (Locale.GetText ("invalid username"), "owner");
+			uid_t uid = pw.pw_uid;
+			gid_t gid = pw.pw_gid;
+			SetLinkOwner (path, uid, gid);
+		}
+
+		public static void SetLinkOwner (string path, string owner, string group)
+		{
+			uid_t uid = PosixUser.GetUserId (owner);
+			gid_t gid = PosixGroup.GetGroupId (group);
+
+			SetLinkOwner (path, uid, gid);
+		}
+
+		public static OpenFlags ToOpenFlags (FileMode mode, FileAccess access)
+		{
+			OpenFlags flags = 0;
+			switch (mode) {
+			case FileMode.CreateNew:
+				flags = OpenFlags.O_CREAT | OpenFlags.O_EXCL;
+				break;
+			case FileMode.Create:
+				flags = OpenFlags.O_CREAT | OpenFlags.O_TRUNC;
+				break;
+			case FileMode.Open:
+				// do nothing
+				break;
+			case FileMode.OpenOrCreate:
+				flags = OpenFlags.O_CREAT;
+				break;
+			case FileMode.Truncate:
+				flags = OpenFlags.O_TRUNC;
+				break;
+			case FileMode.Append:
+				flags = OpenFlags.O_APPEND;
+				break;
+			default:
+				throw new ArgumentException (Locale.GetText ("Unsupported mode value"), "mode");
+			}
+
+			// flags |= OpenFlags.O_LARGEFILE;
+
+			switch (access) {
+			case FileAccess.Read:
+				flags |= OpenFlags.O_RDONLY;
+				break;
+			case FileAccess.Write:
+				flags |= OpenFlags.O_WRONLY;
+				break;
+			case FileAccess.ReadWrite:
+				flags |= OpenFlags.O_RDWR;
+				break;
+			default:
+				throw new ArgumentException (Locale.GetText ("Unsupported access value"), "access");
+			}
+
+			return flags;
+		}
+
+		public static void AdviseNormalAccess (int fd, off_t offset, off_t len)
+		{
+			int r = Syscall.posix_fadvise (fd, offset, len,
+				PosixFadviseFlags.POSIX_FADV_NORMAL);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static void AdviseNormalAccess (int fd)
+		{
+			AdviseNormalAccess (fd,  (off_t) 0, (off_t) 0);
+		}
+
+		public static void AdviseNormalAccess (FileStream file, off_t offset, off_t len)
+		{
+			AdviseNormalAccess (file.Handle.ToInt32(), offset, len);
+		}
+
+		public static void AdviseNormalAccess (FileStream file)
+		{
+			AdviseNormalAccess (file.Handle.ToInt32());
+		}
+
+		public static void AdviseNormalAccess (PosixStream stream, off_t offset, off_t len)
+		{
+			AdviseNormalAccess (stream.FileDescriptor, offset, len);
+		}
+
+		public static void AdviseNormalAccess (PosixStream stream)
+		{
+			AdviseNormalAccess (stream.FileDescriptor);
+		}
+
+		public static void AdviseSequentialAccess (int fd, off_t offset, off_t len)
+		{
+			int r = Syscall.posix_fadvise (fd, offset, len,
+				PosixFadviseFlags.POSIX_FADV_SEQUENTIAL);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static void AdviseSequentialAccess (int fd)
+		{
+			AdviseSequentialAccess (fd, (off_t) 0, (off_t) 0);
+		}
+
+		public static void AdviseSequentialAccess (FileStream file, off_t offset, off_t len)
+		{
+			AdviseSequentialAccess (file.Handle.ToInt32(), offset, len);
+		}
+
+		public static void AdviseSequentialAccess (FileStream file)
+		{
+			AdviseSequentialAccess (file.Handle.ToInt32());
+		}
+
+		public static void AdviseSequentialAccess (PosixStream stream, off_t offset, off_t len)
+		{
+			AdviseSequentialAccess (stream.FileDescriptor, offset, len);
+		}
+
+		public static void AdviseSequentialAccess (PosixStream stream)
+		{
+			AdviseSequentialAccess (stream.FileDescriptor);
+		}
+
+		public static void AdviseRandomAccess (int fd, off_t offset, off_t len)
+		{
+			int r = Syscall.posix_fadvise (fd, offset, len,
+				PosixFadviseFlags.POSIX_FADV_RANDOM);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static void AdviseRandomAccess (int fd)
+		{
+			AdviseRandomAccess (fd, (off_t) 0, (off_t) 0);
+		}
+
+		public static void AdviseRandomAccess (FileStream file, off_t offset, off_t len)
+		{
+			AdviseRandomAccess (file.Handle.ToInt32(), offset, len);
+		}
+
+		public static void AdviseRandomAccess (FileStream file)
+		{
+			AdviseRandomAccess (file.Handle.ToInt32());
+		}
+
+		public static void AdviseRandomAccess (PosixStream stream, off_t offset, off_t len)
+		{
+			AdviseRandomAccess (stream.FileDescriptor, offset, len);
+		}
+
+		public static void AdviseRandomAccess (PosixStream stream)
+		{
+			AdviseRandomAccess (stream.FileDescriptor);
+		}
+
+		public static void AdviseNeedAccess (int fd, off_t offset, off_t len)
+		{
+			int r = Syscall.posix_fadvise (fd, offset, len,
+				PosixFadviseFlags.POSIX_FADV_WILLNEED);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static void AdviseNeedAccess (int fd)
+		{
+			AdviseNeedAccess (fd, (off_t) 0, (off_t) 0);
+		}
+
+		public static void AdviseNeedAccess (FileStream file, off_t offset, off_t len)
+		{
+			AdviseNeedAccess (file.Handle.ToInt32(), offset, len);
+		}
+
+		public static void AdviseNeedAccess (FileStream file)
+		{
+			AdviseNeedAccess (file.Handle.ToInt32());
+		}
+
+		public static void AdviseNeedAccess (PosixStream stream, off_t offset, off_t len)
+		{
+			AdviseNeedAccess (stream.FileDescriptor, offset, len);
+		}
+
+		public static void AdviseNeedAccess (PosixStream stream)
+		{
+			AdviseNeedAccess (stream.FileDescriptor);
+		}
+
+		public static void AdviseNoAccess (int fd, off_t offset, off_t len)
+		{
+			int r = Syscall.posix_fadvise (fd, offset, len,
+				PosixFadviseFlags.POSIX_FADV_DONTNEED);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static void AdviseNoAccess (int fd)
+		{
+			AdviseNoAccess (fd, (off_t) 0, (off_t) 0);
+		}
+
+		public static void AdviseNoAccess (FileStream file, off_t offset, off_t len)
+		{
+			AdviseNoAccess (file.Handle.ToInt32(), offset, len);
+		}
+
+		public static void AdviseNoAccess (FileStream file)
+		{
+			AdviseNoAccess (file.Handle.ToInt32());
+		}
+
+		public static void AdviseNoAccess (PosixStream stream, off_t offset, off_t len)
+		{
+			AdviseNoAccess (stream.FileDescriptor, offset, len);
+		}
+
+		public static void AdviseNoAccess (PosixStream stream)
+		{
+			AdviseNoAccess (stream.FileDescriptor);
+		}
+
+		public static void AdviseOnceAccess (int fd, off_t offset, off_t len)
+		{
+			int r = Syscall.posix_fadvise (fd, offset, len,
+				PosixFadviseFlags.POSIX_FADV_NOREUSE);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public static void AdviseOnceAccess (int fd)
+		{
+			AdviseOnceAccess (fd, (off_t) 0, (off_t) 0);
+		}
+
+		public static void AdviseOnceAccess (FileStream file, off_t offset, off_t len)
+		{
+			AdviseOnceAccess (file.Handle.ToInt32(), offset, len);
+		}
+
+		public static void AdviseOnceAccess (FileStream file)
+		{
+			AdviseOnceAccess (file.Handle.ToInt32());
+		}
+
+		public static void AdviseOnceAccess (PosixStream stream, off_t offset, off_t len)
+		{
+			AdviseOnceAccess (stream.FileDescriptor, offset, len);
+		}
+
+		public static void AdviseOnceAccess (PosixStream stream)
+		{
+			AdviseOnceAccess (stream.FileDescriptor);
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixFileInfo.cs Mono.Posix.new/PosixFileInfo.cs
--- Mono.Posix/PosixFileInfo.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixFileInfo.cs	2004-10-14 22:19:27.405063000 -0400
@@ -0,0 +1,180 @@
+//
+// Mono.Posix/PosixFileInfo.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Text;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public class PosixFileInfo : PosixFileSystemInfo
+	{
+		public PosixFileInfo (string path)
+			: base (path)
+		{
+		}
+
+		internal PosixFileInfo (string path, Stat stat)
+			: base (path, stat)
+		{
+		}
+
+		public override void Delete ()
+		{
+			int r = Syscall.unlink (Path);
+			PosixIOException.ThrowIf (r);
+			base.Refresh ();
+		}
+
+		public PosixStream Create ()
+		{
+			FilePermissions mode = // 0644
+				FilePermissions.S_IRUSR | FilePermissions.S_IWUSR |
+				FilePermissions.S_IRGRP | FilePermissions.S_IROTH; 
+			return Create (mode);
+		}
+
+		public PosixStream Create (FilePermissions mode)
+		{
+			int fd = Syscall.creat (Path, mode);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			base.Refresh ();
+			return new PosixStream (fd);
+		}
+
+		public PosixStream Open (OpenFlags flags)
+		{
+			int fd = Syscall.open (Path, flags);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public PosixStream Open (OpenFlags flags, FilePermissions mode)
+		{
+			int fd = Syscall.open (Path, flags, mode);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public PosixStream Open (FileMode mode)
+		{
+			OpenFlags flags = ToOpenFlags (mode, FileAccess.ReadWrite);
+			int fd = Syscall.open (Path, flags);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public PosixStream Open (FileMode mode, FileAccess access)
+		{
+			OpenFlags flags = ToOpenFlags (mode, access);
+			int fd = Syscall.open (Path, flags);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public PosixStream Open (FileMode mode, FileAccess access, FilePermissions perms)
+		{
+			OpenFlags flags = ToOpenFlags (mode, access);
+			int fd = Syscall.open (Path, flags, perms);
+			if (fd < 0)
+				PosixIOException.Throw ();
+			return new PosixStream (fd);
+		}
+
+		public PosixStream OpenRead ()
+		{
+			return Open (FileMode.Open, FileAccess.Read);
+		}
+
+		public PosixStream OpenWrite ()
+		{
+			return Open (FileMode.OpenOrCreate, FileAccess.Write);
+		}
+
+		public static OpenFlags ToOpenFlags (FileMode mode, FileAccess access)
+		{
+			OpenFlags flags = 0;
+			switch (mode) {
+			case FileMode.CreateNew:
+				flags = OpenFlags.O_CREAT | OpenFlags.O_EXCL;
+				break;
+			case FileMode.Create:
+				flags = OpenFlags.O_CREAT | OpenFlags.O_TRUNC;
+				break;
+			case FileMode.Open:
+				// do nothing
+				break;
+			case FileMode.OpenOrCreate:
+				flags = OpenFlags.O_CREAT;
+				break;
+			case FileMode.Truncate:
+				flags = OpenFlags.O_TRUNC;
+				break;
+			case FileMode.Append:
+				flags = OpenFlags.O_APPEND;
+				break;
+			default:
+				throw new ArgumentException (Locale.GetText ("Unsupported mode value"), "mode");
+			}
+
+			try {
+				// Test to see if O_LARGEFILE is supported.  PosixConvert will throw
+				// an exception if O_LARGEFILE can't be converted.
+				int ignored = PosixConvert.FromOpenFlags (OpenFlags.O_LARGEFILE);
+				flags |= OpenFlags.O_LARGEFILE;
+			}
+			catch {
+				// ignore
+			}
+
+			switch (access) {
+			case FileAccess.Read:
+				flags |= OpenFlags.O_RDONLY;
+				break;
+			case FileAccess.Write:
+				flags |= OpenFlags.O_WRONLY;
+				break;
+			case FileAccess.ReadWrite:
+				flags |= OpenFlags.O_RDWR;
+				break;
+			default:
+				throw new ArgumentException (Locale.GetText ("Unsupported access value"), "access");
+			}
+
+			return flags;
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixFileSystemInfo.cs Mono.Posix.new/PosixFileSystemInfo.cs
--- Mono.Posix/PosixFileSystemInfo.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixFileSystemInfo.cs	2004-10-14 22:19:27.412062000 -0400
@@ -0,0 +1,284 @@
+//
+// Mono.Posix/PosixFileSystemInfo.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Text;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public abstract class PosixFileSystemInfo
+	{
+		private Stat stat;
+		private string path;
+		private bool valid = false;
+
+		protected PosixFileSystemInfo (string path)
+		{
+			this.path = path;
+			int r = Syscall.stat (path, out this.stat);
+			if (r == 0)
+				valid = true;
+		}
+
+		internal PosixFileSystemInfo (String path, Stat stat)
+		{
+			this.path = path;
+			this.stat = stat;
+			this.valid = true;
+		}
+
+		protected string Path {
+			get {return path;}
+			set {path = value;}
+		}
+
+		protected void AssertValid ()
+		{
+			if (!valid)
+				throw new InvalidOperationException ("Path doesn't exist!");
+		}
+
+		public bool Exists {
+			get {
+				int r = Syscall.access (path, AccessMode.F_OK);
+				if (r == 0)
+					return true;
+				return false;
+			}
+		}
+
+		public dev_t Device {
+			get {AssertValid (); return stat.st_dev;}
+		}
+
+		public ino_t Inode {
+			get {AssertValid (); return stat.st_ino;}
+		}
+
+		public FilePermissions Mode {
+			get {AssertValid (); return stat.st_mode;}
+		}
+
+		public FilePermissions Permissions {
+			get {AssertValid (); return stat.st_mode & ~FilePermissions.S_IFMT;}
+		}
+
+		public FilePermissions FileType {
+			get {AssertValid (); return stat.st_mode & FilePermissions.S_IFMT;}
+		}
+
+		public ulong LinkCount {
+			get {AssertValid (); return stat.st_nlink.Value;}
+		}
+
+		public uid_t OwnerUser {
+			get {AssertValid (); return stat.st_uid;}
+		}
+
+		public gid_t OwnerGroup {
+			get {AssertValid (); return stat.st_gid;}
+		}
+
+		public dev_t DeviceType {
+			get {AssertValid (); return stat.st_rdev;}
+		}
+
+		public long Length {
+			get {AssertValid (); return stat.st_size.Value;}
+		}
+
+		public long BlockSize {
+			get {AssertValid (); return stat.st_blksize;}
+		}
+
+		public long BlocksAllocated {
+			get {AssertValid (); return stat.st_blocks;}
+		}
+
+		public DateTime LastAccessTime {
+			get {AssertValid (); return PosixConvert.ToDateTime (stat.st_atime);}
+		}
+
+		public DateTime LastAccessTimeUtc {
+			get {AssertValid (); return LastAccessTime.ToUniversalTime ();}
+		}
+
+		public DateTime LastWriteTime {
+			get {AssertValid (); return PosixConvert.ToDateTime (stat.st_mtime);}
+		}
+
+		public DateTime LastWriteTimeUtc {
+			get {AssertValid (); return LastWriteTime.ToUniversalTime ();}
+		}
+
+		public DateTime LastStatusChangeTime {
+			get {AssertValid (); return PosixConvert.ToDateTime (stat.st_ctime);}
+		}
+
+		public DateTime LastStatusChangeTimeUtc {
+			get {AssertValid (); return LastStatusChangeTime.ToUniversalTime ();}
+		}
+
+		public bool IsDirectory {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_IFDIR);}
+		}
+
+		public bool IsCharacterDevice {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_IFCHR);}
+		}
+
+		public bool IsBlockDevice {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_IFBLK);}
+		}
+
+		public bool IsFile {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_IFREG);}
+		}
+
+		public bool IsFIFO {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_IFIFO);}
+		}
+
+		public bool IsSymbolicLink {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_IFLNK);}
+		}
+
+		public bool IsSocket {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_IFSOCK);}
+		}
+
+		public bool IsSetUser {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_ISUID);}
+		}
+
+		public bool IsSetGroup {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_ISGID);}
+		}
+
+		public bool IsSticky {
+			get {AssertValid (); return IsType (stat.st_mode, FilePermissions.S_ISVTX);}
+		}
+
+		internal static bool IsType (FilePermissions mode, FilePermissions type)
+		{
+			return (mode & type) == type;
+		}
+
+		public bool CanAccess (AccessMode mode)
+		{
+			int r = Syscall.access (path, mode);
+			return r == 0;
+		}
+
+		public abstract void Delete ();
+
+		public long GetConfigurationValue (PathConf name)
+		{
+			Syscall.SetLastError (Error.ESUCCESS);
+			long r = Syscall.pathconf (Path, name);
+			if (r == -1 && Syscall.GetLastError() != Error.ESUCCESS)
+				PosixIOException.Throw ();
+			return r;
+		}
+
+		// TODO: Should ReadLink be in PosixSymbolicLinkInfo?
+		public string ReadLink ()
+		{
+			string r = TryReadLink ();
+			if (r == null)
+				PosixIOException.Throw ();
+			return r;
+		}
+
+		public string TryReadLink ()
+		{
+			// Who came up with readlink(2)?  There doesn't seem to be a way to
+			// properly handle it.
+			StringBuilder sb = new StringBuilder (512);
+			int r = Syscall.readlink (path, sb);
+			if (r == -1)
+				return null;
+			return sb.ToString().Substring (0, r);
+		}
+
+		public void Refresh ()
+		{
+			int r = Syscall.stat (path, out this.stat);
+			valid = r == 0;
+		}
+
+		public void SetPermissions (FilePermissions perms)
+		{
+			int r = Syscall.chmod (path, perms);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public virtual void SetOwner (uid_t owner, gid_t group)
+		{
+			int r = Syscall.chown (path, owner, group);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public void SetOwner (string owner)
+		{
+			Passwd pw = Syscall.getpwnam (owner);
+			if (pw == null)
+				throw new ArgumentException (Locale.GetText ("invalid username"), "owner");
+			uid_t uid = pw.pw_uid;
+			gid_t gid = pw.pw_gid;
+			SetOwner (uid, gid);
+		}
+
+		public void SetOwner (string owner, string group)
+		{
+			uid_t uid = PosixUser.GetUserId (owner);
+			gid_t gid = PosixGroup.GetGroupId (group);
+
+			SetOwner (uid, gid);
+		}
+
+		public override string ToString ()
+		{
+			return path;
+		}
+
+		internal static PosixFileSystemInfo Create (string path)
+		{
+			Stat stat = PosixFile.GetFileStatus (path);
+			if (IsType (stat.st_mode, FilePermissions.S_IFDIR))
+				return new PosixDirectoryInfo (path, stat);
+			else if (IsType (stat.st_mode, FilePermissions.S_IFLNK))
+				return new PosixSymbolicLinkInfo (path, stat);
+			return new PosixFileInfo (path, stat);
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixGroup.cs Mono.Posix.new/PosixGroup.cs
--- Mono.Posix/PosixGroup.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixGroup.cs	2004-10-14 22:19:27.413062000 -0400
@@ -0,0 +1,91 @@
+//
+// Mono.Posix/PosixGroup.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed class PosixGroup
+	{
+		private PosixGroup () {}
+
+		public static gid_t GetGroupId (string group)
+		{
+			return new PosixGroupInfo (group).GroupId;
+		}
+
+		public static string[] GetMembers (string group)
+		{
+			return new PosixGroupInfo (group).Members;
+		}
+
+		public static string[] GetMembers (gid_t group)
+		{
+			return new PosixGroupInfo (group).Members;
+		}
+
+		public static string GetName (gid_t group)
+		{
+			return new PosixGroupInfo (group).GroupName;
+		}
+
+		public static string GetPassword (string group)
+		{
+			return new PosixGroupInfo (group).Password;
+		}
+
+		public static string GetPassword (gid_t group)
+		{
+			return new PosixGroupInfo (group).Password;
+		}
+
+		public static PosixGroupInfo[] GetLocalGroups ()
+		{
+			Syscall.SetLastError (Error.ESUCCESS);
+			Syscall.setgrent ();
+			if (Syscall.GetLastError () != Error.ESUCCESS)
+				PosixIOException.Throw();
+			ArrayList entries = new ArrayList ();
+			try {
+				Group g;
+				while ((g = Syscall.getgrent()) != null)
+					entries.Add (new PosixGroupInfo (g));
+				if (Syscall.GetLastError() != Error.ESUCCESS)
+					PosixIOException.Throw ();
+			}
+			finally {
+				Syscall.endgrent ();
+			}
+			return (PosixGroupInfo[]) entries.ToArray (typeof(PosixGroupInfo));
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixGroupInfo.cs Mono.Posix.new/PosixGroupInfo.cs
--- Mono.Posix/PosixGroupInfo.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixGroupInfo.cs	2004-10-14 22:19:27.413062000 -0400
@@ -0,0 +1,98 @@
+//
+// Mono.Posix/PosixGroupInfo.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Text;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed class PosixGroupInfo
+	{
+		private Group group;
+
+		public PosixGroupInfo (string group)
+		{
+			this.group = new Group ();
+			Group gr;
+			int r = Syscall.getgrnam_r (group, this.group, out gr);
+			if (r != 0 || gr == null)
+				throw new ArgumentException (Locale.GetText ("invalid group name"), "group");
+		}
+
+		public PosixGroupInfo (gid_t group)
+		{
+			this.group = new Group ();
+			Group gr;
+			int r = Syscall.getgrgid_r (group, this.group, out gr);
+			if (r != 0 || gr == null)
+				throw new ArgumentException (Locale.GetText ("invalid group id"), "group");
+		}
+
+		internal PosixGroupInfo (Group group)
+		{
+			this.group = group;
+		}
+
+		public string GroupName {
+			get {return group.gr_name;}
+		}
+
+		public string Password {
+			get {return group.gr_passwd;}
+		}
+
+		public gid_t GroupId {
+			get {return group.gr_gid;}
+		}
+
+		public string[] Members {
+			get {return group.gr_mem;}
+		}
+
+		public override string ToString ()
+		{
+			StringBuilder sb = new StringBuilder ();
+			sb.AppendFormat ("{0}:{1}:{2}:", GroupName, Password, GroupId);
+			GetMembers (sb, Members);
+			return sb.ToString();
+		}
+
+		private static void GetMembers (StringBuilder sb, string[] members)
+		{
+			if (members.Length > 0)
+				sb.Append (members[0]);
+			for (int i = 1; i < members.Length; ++i) {
+				sb.Append (",");
+				sb.Append (members[i]);
+			}
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixIOException.cs Mono.Posix.new/PosixIOException.cs
--- Mono.Posix/PosixIOException.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixIOException.cs	2004-10-14 22:19:27.426060000 -0400
@@ -0,0 +1,133 @@
+//
+// Mono.Posix/PosixIOException.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Net.Sockets;
+using System.Runtime.InteropServices;
+using System.Runtime.Serialization;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	[Serializable]
+	public class PosixIOException : IOException
+	{
+		public PosixIOException ()
+			: this (Marshal.GetLastWin32Error())
+		{}
+		
+		public PosixIOException (int error)
+		{
+			this.error = error;
+		}
+		
+		public PosixIOException (int error, Exception inner)
+			: base ("POSIX-generated exception", inner)
+		{
+			this.error = error;
+		}
+
+		public PosixIOException (Error error)
+		{
+			this.error = PosixConvert.FromError (error);
+		}
+
+		public PosixIOException (Error error, Exception inner)
+			: base ("POSIX-generated exception", inner)
+		{
+			this.error = PosixConvert.FromError (error);
+		}
+
+		protected PosixIOException (SerializationInfo info, StreamingContext context)
+			: base (info, context)
+		{
+		}
+		
+		public int NativeErrorCode {
+			get {return error;}
+		}
+		
+		public Error ErrorCode {
+			get {return PosixConvert.ToError (error);}
+		}
+
+		private int error;
+
+		public override string ToString ()
+		{
+			return Syscall.strerror_r (ErrorCode);
+		}
+
+		public static Exception Create (Error errno)
+		{
+			string message = Syscall.strerror_r (errno);
+			PosixIOException p = new PosixIOException (errno);
+			switch (errno) {
+				case Error.EFAULT:        return new NullReferenceException (message, p);
+				case Error.EINVAL:        return new ArgumentException (message, p);
+				case Error.EIO:
+				  case Error.ENOSPC:
+				  case Error.EROFS:
+				  case Error.ESPIPE:
+					return new IOException (message, p);
+				case Error.ENAMETOOLONG:  return new PathTooLongException (message, p);
+				case Error.ENOENT:        return new FileNotFoundException (message, p);
+				case Error.ENOEXEC:       return new InvalidProgramException (message, p);
+				case Error.EOVERFLOW:     return new OverflowException (message, p);
+				case Error.ERANGE:        return new ArgumentOutOfRangeException (message);
+				default: /* ignore */     break;
+			}
+			return p;
+		}
+
+		public static void Throw (Error errno)
+		{
+			throw Create (errno);
+		}
+
+		public static void Throw ()
+		{
+			throw Create (Syscall.GetLastError());
+		}
+
+		public static void ThrowIf (int retval, Error errno)
+		{
+			if (retval == -1)
+				Throw (errno);
+		}
+
+		public static void ThrowIf (int retval)
+		{
+			if (retval == -1)
+				Throw ();
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixProcess.cs Mono.Posix.new/PosixProcess.cs
--- Mono.Posix/PosixProcess.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixProcess.cs	2004-10-14 22:19:27.435058000 -0400
@@ -0,0 +1,71 @@
+//
+// Mono.Posix/PosixProcess.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed class PosixProcess
+	{
+		private pid_t currentProcess;
+
+		private PosixProcess (pid_t currentProcess)
+		{
+			this.currentProcess = currentProcess;
+		}
+
+		public pid_t ProcessGroupId {
+			get {return Syscall.getpgid (currentProcess);}
+			set {
+				int r = Syscall.setpgid (currentProcess, value);
+				PosixIOException.ThrowIf (r);
+			}
+		}
+
+		public pid_t SessionId {
+			get {
+				pid_t r = Syscall.getsid (currentProcess);
+				if (r == (pid_t) (-1))
+					PosixIOException.Throw ();
+				return r;
+			}
+		}
+
+		public static PosixProcess GetCurrentProcess ()
+		{
+			return new PosixProcess (Id);
+		}
+
+		public static pid_t Id {
+			get {return Syscall.getpid ();}
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixStream.cs Mono.Posix.new/PosixStream.cs
--- Mono.Posix/PosixStream.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixStream.cs	2004-10-14 22:19:27.440058000 -0400
@@ -0,0 +1,390 @@
+//
+// Mono.Posix/PosixStream.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Text;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed class PosixStream : Stream, IDisposable
+	{
+		public const int InvalidFileDescriptor = -1;
+		public const int StandardInputFileDescriptor = 0;
+		public const int StandardOutputFileDescriptor = 1;
+		public const int StandardErrorFileDescriptor = 2;
+
+		public PosixStream (int fileDescriptor)
+			: this (fileDescriptor, true) {}
+
+		public PosixStream (int fileDescriptor, bool ownsHandle)
+		{
+			if (InvalidFileDescriptor == fileDescriptor)
+				throw new ArgumentException (Locale.GetText ("Invalid file descriptor"), "fileDescriptor");
+			
+			this.fileDescriptor = fileDescriptor;
+			this.owner = ownsHandle;
+			
+			off_t offset = Syscall.lseek (fileDescriptor, (off_t) 0, SeekFlags.SEEK_CUR);
+			if (offset != (off_t) (-1))
+				canSeek = true;
+			long read = Syscall.read (fileDescriptor, null, (size_t) 0);
+			if (read != -1)
+				canRead = true;
+			long write = Syscall.write (fileDescriptor, null, (size_t) 0);
+			if (write != -1)
+				canWrite = true;  
+		}
+
+		private void AssertNotDisposed ()
+		{
+			if (fileDescriptor == InvalidFileDescriptor)
+				throw new ObjectDisposedException ("File Descriptor has been closed");
+		}
+
+		public int FileDescriptor {
+			get {return fileDescriptor;}
+		}
+
+		public override bool CanRead {
+			get {return canRead;}
+		}
+
+		public override bool CanSeek {
+			get {return canSeek;}
+		}
+
+		public override bool CanWrite {
+			get {return canWrite;}
+		}
+
+		public override long Length {
+			get {
+				AssertNotDisposed ();
+				if (!CanSeek)
+					throw new NotSupportedException ("File descriptor doesn't support seeking");
+				Stat stat;
+				int r = Syscall.fstat (fileDescriptor, out stat);
+				PosixIOException.ThrowIf (r);
+				return stat.st_size;
+			}
+		}
+
+		public override long Position {
+			get {
+				AssertNotDisposed ();
+				if (!CanSeek)
+					throw new NotSupportedException ("The stream does not support seeking");
+				off_t pos = Syscall.lseek (fileDescriptor, (off_t) 0, SeekFlags.SEEK_CUR);
+				if (pos == (off_t)(-1))
+					PosixIOException.Throw ();
+				return pos;
+			}
+			set {
+				Seek (value, SeekOrigin.Begin);
+			}
+		}
+
+		public FilePermissions Permissions {
+			get {
+				Stat stat;
+				int r = Syscall.fstat (fileDescriptor, out stat);
+				PosixIOException.ThrowIf (r);
+				return stat.st_mode;
+			}
+			set {
+				int r = Syscall.fchmod (fileDescriptor, value);
+				PosixIOException.ThrowIf (r);
+			}
+		}
+
+		public void AdviseNormalAccess (off_t offset, off_t len)
+		{
+			PosixFile.AdviseNormalAccess (fileDescriptor, offset, len);
+		}
+
+		public void AdviseNormalAccess ()
+		{
+			PosixFile.AdviseNormalAccess (fileDescriptor);
+		}
+
+		public void AdviseSequentialAccess (off_t offset, off_t len)
+		{
+			PosixFile.AdviseSequentialAccess (fileDescriptor, offset, len);
+		}
+
+		public void AdviseSequentialAccess ()
+		{
+			PosixFile.AdviseSequentialAccess (fileDescriptor);
+		}
+
+		public void AdviseRandomAccess (off_t offset, off_t len)
+		{
+			PosixFile.AdviseRandomAccess (fileDescriptor, offset, len);
+		}
+
+		public void AdviseRandomAccess ()
+		{
+			PosixFile.AdviseRandomAccess (fileDescriptor);
+		}
+
+		public void AdviseNeedAccess (off_t offset, off_t len)
+		{
+			PosixFile.AdviseNeedAccess (fileDescriptor, offset, len);
+		}
+
+		public void AdviseNeedAccess ()
+		{
+			PosixFile.AdviseNeedAccess (fileDescriptor);
+		}
+
+		public void AdviseNoAccess (off_t offset, off_t len)
+		{
+			PosixFile.AdviseNoAccess (fileDescriptor, offset, len);
+		}
+
+		public void AdviseNoAccess ()
+		{
+			PosixFile.AdviseNoAccess (fileDescriptor);
+		}
+
+		public void AdviseOnceAccess (off_t offset, off_t len)
+		{
+			PosixFile.AdviseOnceAccess (fileDescriptor, offset, len);
+		}
+
+		public void AdviseOnceAccess ()
+		{
+			PosixFile.AdviseOnceAccess (fileDescriptor);
+		}
+
+		public override void Flush ()
+		{
+			int r = Syscall.fsync (fileDescriptor);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public override unsafe int Read ([In, Out] byte[] buffer, int offset, int count)
+		{
+			AssertNotDisposed ();
+			AssertValidBuffer (buffer, offset, count);
+			if (!CanRead)
+				throw new NotSupportedException ("Stream does not support reading");
+				 
+			long r = 0;
+			fixed (byte* buf = &buffer[offset]) {
+			do {
+					r = Syscall.read (fileDescriptor, buf, (size_t) count);
+				}	while (r == -1 && Syscall.GetLastError() == Error.EINTR);
+			}
+			if (r == -1)
+				PosixIOException.Throw ();
+			return (int) r;
+		}
+
+		private void AssertValidBuffer (byte[] buffer, int offset, int count)
+		{
+			if (buffer == null)
+				throw new ArgumentNullException ("buffer");
+			if (offset < 0)
+				throw new ArgumentOutOfRangeException ("offset", "< 0");
+			if (count < 0)
+				throw new ArgumentOutOfRangeException ("count", "< 0");
+			if (offset > buffer.Length)
+				throw new ArgumentException ("destination offset is beyond array size");
+			if (offset > (buffer.Length - count))
+				throw new ArgumentException ("would overrun buffer");
+		}
+
+		public unsafe int ReadAtOffset ([In, Out] byte[] buffer, 
+			int offset, int count, off_t fileOffset)
+		{
+			AssertNotDisposed ();
+			AssertValidBuffer (buffer, offset, count);
+			if (!CanRead)
+				throw new NotSupportedException ("Stream does not support reading");
+				 
+			long r = 0;
+			fixed (byte* buf = &buffer[offset]) {
+			do {
+					r = Syscall.pread (fileDescriptor, buf, (size_t) count, fileOffset);
+				}	while (r == -1 && Syscall.GetLastError() == Error.EINTR);
+			}
+			if (r == -1)
+				PosixIOException.Throw ();
+			return (int) r;
+		}
+
+		public override long Seek (long offset, SeekOrigin origin)
+		{
+			AssertNotDisposed ();
+			if (!CanSeek)
+				throw new NotSupportedException ("The File Descriptor does not support seeking");
+			if (offset > int.MaxValue)
+				throw new ArgumentOutOfRangeException ("offset", "too large");
+					
+			SeekFlags sf = SeekFlags.SEEK_CUR;
+			switch (origin) {
+				case SeekOrigin.Begin:   sf = SeekFlags.SEEK_SET; break;
+				case SeekOrigin.Current: sf = SeekFlags.SEEK_CUR; break;
+				case SeekOrigin.End:     sf = SeekFlags.SEEK_END; break;
+			}
+
+			off_t pos = Syscall.lseek (fileDescriptor, (off_t) offset, sf);
+			if (pos == (off_t) (-1))
+				PosixIOException.Throw ();
+			return pos;
+		}
+
+		public override void SetLength (long value)
+		{
+			AssertNotDisposed ();
+			if (value > int.MaxValue)
+				throw new ArgumentOutOfRangeException ("value", "too large");
+			if (value < 0)
+				throw new ArgumentOutOfRangeException ("value", "< 0");
+			if (!CanSeek && !CanWrite)
+				throw new NotSupportedException ("You can't truncating the current file descriptor");
+			
+			int r = Syscall.ftruncate (fileDescriptor, (off_t) value);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public override unsafe void Write (byte[] buffer, int offset, int count)
+		{
+			AssertNotDisposed ();
+			AssertValidBuffer (buffer, offset, count);
+			if (!CanWrite)
+				throw new NotSupportedException ("File Descriptor does not support writing");
+
+			long r = 0;
+			fixed (byte* buf = &buffer[offset]) {
+				do {
+					r = Syscall.write (fileDescriptor, buf, (size_t) count);
+				}	while (r == -1 && Syscall.GetLastError() == Error.EINTR);
+			}
+			if (r == -1)
+				PosixIOException.Throw ();
+		}
+		
+		public unsafe void WriteAtOffset (byte[] buffer, 
+			int offset, int count, off_t fileOffset)
+		{
+			AssertNotDisposed ();
+			AssertValidBuffer (buffer, offset, count);
+			if (!CanWrite)
+				throw new NotSupportedException ("File Descriptor does not support writing");
+
+			long r = 0;
+			fixed (byte* buf = &buffer[offset]) {
+				do {
+					r = Syscall.pwrite (fileDescriptor, buf, (size_t) count, fileOffset);
+				}	while (r == -1 && Syscall.GetLastError() == Error.EINTR);
+			}
+			if (r == -1)
+				PosixIOException.Throw ();
+		}
+		
+		public void SetOwner (uid_t user, gid_t group)
+		{
+			AssertNotDisposed ();
+
+			int r = Syscall.fchown (fileDescriptor, user, group);
+			PosixIOException.ThrowIf (r);
+		}
+
+		public void SetOwner (string user, string group)
+		{
+			AssertNotDisposed ();
+
+			uid_t uid = PosixUser.GetUserId (user);
+			gid_t gid = PosixGroup.GetGroupId (group);
+			SetOwner (uid, gid);
+		}
+
+		public void SetOwner (string user)
+		{
+			AssertNotDisposed ();
+
+			Passwd pw = Syscall.getpwnam (user);
+			if (pw == null)
+				throw new ArgumentException (Locale.GetText ("invalid username"), "user");
+			uid_t uid = pw.pw_uid;
+			gid_t gid = pw.pw_gid;
+			SetOwner (uid, gid);
+		}
+
+		public long GetConfigurationValue (PathConf name)
+		{
+			AssertNotDisposed ();
+			Syscall.SetLastError (Error.ESUCCESS);
+			long r = Syscall.fpathconf (fileDescriptor, name);
+			if (r == -1 && Syscall.GetLastError() != Error.ESUCCESS)
+				PosixIOException.Throw ();
+			return r;
+		}
+
+		~PosixStream ()
+		{
+			Close ();
+		}
+
+		public override void Close ()
+		{
+			if (fileDescriptor == InvalidFileDescriptor)
+				return;
+				
+			Flush ();
+			int r;
+			do {
+				r = Syscall.close (fileDescriptor);
+			} while (r == -1 && Syscall.GetLastError() == Error.EINTR);
+			PosixIOException.ThrowIf (r);
+			fileDescriptor = InvalidFileDescriptor;
+		}
+		
+		void IDisposable.Dispose ()
+		{
+			AssertNotDisposed ();
+			if (owner) {
+				Close ();
+			}
+			GC.SuppressFinalize (this);
+		}
+
+		private bool canSeek = false;
+		private bool canRead = false;
+		private bool canWrite = false;
+		private bool owner = true;
+		private int fileDescriptor = InvalidFileDescriptor;
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixSymbolicLinkInfo.cs Mono.Posix.new/PosixSymbolicLinkInfo.cs
--- Mono.Posix/PosixSymbolicLinkInfo.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixSymbolicLinkInfo.cs	2004-10-14 22:19:27.440058000 -0400
@@ -0,0 +1,63 @@
+//
+// Mono.Posix/PosixSymbolicLinkInfo.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Text;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public class PosixSymbolicLinkInfo : PosixFileSystemInfo
+	{
+		public PosixSymbolicLinkInfo (string path)
+			: base (path)
+		{
+		}
+
+		internal PosixSymbolicLinkInfo (string path, Stat stat)
+			: base (path, stat)
+		{
+		}
+
+		public override void Delete ()
+		{
+			int r = Syscall.unlink (Path);
+			PosixIOException.ThrowIf (r);
+			base.Refresh ();
+		}
+
+		public override void SetOwner (uid_t owner, gid_t group)
+		{
+			int r = Syscall.lchown (Path, owner, group);
+			PosixIOException.ThrowIf (r);
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixUser.cs Mono.Posix.new/PosixUser.cs
--- Mono.Posix/PosixUser.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixUser.cs	2004-10-14 22:19:27.444057000 -0400
@@ -0,0 +1,147 @@
+//
+// Mono.Posix/PosixUser.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.Text;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed class PosixUser
+	{
+		private PosixUser () {}
+
+		public static uid_t GetUserId (string user)
+		{
+			return new PosixUserInfo (user).UserId;
+		}
+
+		public static uid_t GetCurrentUser ()
+		{
+			return Syscall.getuid ();
+		}
+
+		public static string GetCurrentUserName ()
+		{
+			return GetName (GetCurrentUser());
+		}
+
+		// I would hope that this is the same as GetCurrentUserName, but it is a
+		// different syscall, so who knows.
+		public static string GetLogin ()
+		{
+			StringBuilder buf = new StringBuilder (4);
+			int r;
+			do {
+				buf.Capacity *= 2;
+				r = Syscall.getlogin_r (buf, (size_t) buf.Capacity);
+			} while (r == (-1) && Syscall.GetLastError() == Error.ERANGE);
+			PosixIOException.ThrowIf (r);
+			return buf.ToString ();
+		}
+
+		public static gid_t GetGroupId (string user)
+		{
+			return new PosixUserInfo (user).GroupId;
+		}
+
+		public static gid_t GetGroupId (uid_t user)
+		{
+			return new PosixUserInfo (user).GroupId;
+		}
+
+		public static string GetRealName (string user)
+		{
+			return new PosixUserInfo (user).RealName;
+		}
+
+		public static string GetRealName (uid_t user)
+		{
+			return new PosixUserInfo (user).RealName;
+		}
+
+		public static string GetHomeDirectory (string user)
+		{
+			return new PosixUserInfo (user).HomeDirectory;
+		}
+
+		public static string GetHomeDirectory (uid_t user)
+		{
+			return new PosixUserInfo (user).HomeDirectory;
+		}
+
+		public static string GetName (uid_t user)
+		{
+			return new PosixUserInfo (user).UserName;
+		}
+
+		public static string GetPassword (string user)
+		{
+			return new PosixUserInfo (user).Password;
+		}
+
+		public static string GetPassword (uid_t user)
+		{
+			return new PosixUserInfo (user).Password;
+		}
+
+		public static string GetShellProgram (string user)
+		{
+			return new PosixUserInfo (user).ShellProgram;
+		}
+
+		public static string GetShellProgram (uid_t user)
+		{
+			return new PosixUserInfo (user).ShellProgram;
+		}
+
+		public static PosixUserInfo[] GetLocalUsers ()
+		{
+			Syscall.SetLastError (Error.ESUCCESS);
+			Syscall.setpwent ();
+			if (Syscall.GetLastError () != Error.ESUCCESS) {
+				PosixIOException.Throw();
+			}
+			ArrayList entries = new ArrayList ();
+			try {
+				Passwd p;
+				while ((p = Syscall.getpwent()) != null)
+					entries.Add (new PosixUserInfo (p));
+				if (Syscall.GetLastError () != Error.ESUCCESS)
+					PosixIOException.Throw ();
+			}
+			finally {
+				Syscall.endpwent ();
+			}
+			return (PosixUserInfo[]) entries.ToArray (typeof(PosixUserInfo));
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixUserInfo.cs Mono.Posix.new/PosixUserInfo.cs
--- Mono.Posix/PosixUserInfo.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixUserInfo.cs	2004-10-14 22:19:27.445057000 -0400
@@ -0,0 +1,104 @@
+//
+// Mono.Posix/PosixUserInfo.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.Text;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed class PosixUserInfo
+	{
+		private Passwd passwd;
+
+		public PosixUserInfo (string user)
+		{
+			passwd = new Passwd ();
+			Passwd pw;
+			int r = Syscall.getpwnam_r (user, passwd, out pw);
+			if (r != 0 || pw == null)
+				throw new ArgumentException (Locale.GetText ("invalid username"), "user");
+		}
+
+		public PosixUserInfo (uid_t user)
+		{
+			passwd = new Passwd ();
+			Passwd pw;
+			int r = Syscall.getpwuid_r (user, passwd, out pw);
+			if (r != 0 || pw == null)
+				throw new ArgumentException (Locale.GetText ("invalid user id"), "user");
+		}
+
+		internal PosixUserInfo (Passwd passwd)
+		{
+			this.passwd = passwd;
+		}
+
+		public string UserName {
+			get {return passwd.pw_name;}
+		}
+
+		public string Password {
+			get {return passwd.pw_passwd;}
+		}
+
+		public uid_t UserId {
+			get {return passwd.pw_uid;}
+		}
+
+		public gid_t GroupId {
+			get {return passwd.pw_gid;}
+		}
+
+		public string GroupName {
+			get {return PosixGroup.GetName (passwd.pw_gid);}
+		}
+
+		public string RealName {
+			get {return passwd.pw_gecos;}
+		}
+
+		public string HomeDirectory {
+			get {return passwd.pw_dir;}
+		}
+
+		public string ShellProgram {
+			get {return passwd.pw_shell;}
+		}
+
+		public override string ToString ()
+		{
+			return string.Format ("{0}:{1}:{2}:{3}:{4}:{5}:{6}",
+					UserName, Password, UserId, GroupId, RealName, HomeDirectory, 
+					ShellProgram);
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/PosixUtils.cs Mono.Posix.new/PosixUtils.cs
--- Mono.Posix/PosixUtils.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/PosixUtils.cs	2004-10-14 22:19:27.445057000 -0400
@@ -0,0 +1,50 @@
+//
+// Mono.Posix/Utils.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Runtime.InteropServices;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public sealed class PosixUtils
+	{
+		private PosixUtils () {}
+
+		public static string MarshalString (IntPtr p)
+		{
+			// TODO: deal with character set issues.  Will PtrToStringAnsi always
+			// "Do The Right Thing"?
+			if (p == IntPtr.Zero)
+				return null;
+			return Marshal.PtrToStringAnsi (p);
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/Stdlib.cs Mono.Posix.new/Stdlib.cs
--- Mono.Posix/Stdlib.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/Stdlib.cs	2004-10-14 22:19:27.454056000 -0400
@@ -0,0 +1,161 @@
+//
+// Mono.Posix/Stdlib.cs
+//
+// Authors:
+//   Jonathan Pryor (jonpryor@vt.edu)
+//
+// (C) 2004 Jonathan Pryor
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Runtime.InteropServices;
+using Mono.Posix;
+
+namespace Mono.Posix {
+
+	public delegate void sighandler_t (int value);
+
+	//
+	// Convention: Functions that are part of the C standard library go here.
+	//
+	// For example, the man page should say something similar to:
+	//
+	//    CONFORMING TO
+	//           ISO 9899 (''ANSI C'')
+	//
+	public /* static */ class Stdlib
+	{
+		private const string LIBC = "libc";
+		private const string MPH = "MonoPosixHelper";
+
+		internal Stdlib () {}
+
+		//
+		// <signal.h>
+		//
+		[DllImport (LIBC, SetLastError=true, EntryPoint="signal")]
+		private static extern IntPtr sys_signal (int signum, sighandler_t handler);
+
+		// FIXME: signal returns sighandler_t.  What should we do?
+		public static int signal (Signum signum, sighandler_t handler)
+		{
+			int _sig = PosixConvert.FromSignum (signum);
+			IntPtr r = sys_signal (_sig, handler);
+			// handle `r'
+			return 0;
+		}
+
+		// TODO: Need access to SIG_IGN, SIG_DFL, and SIG_ERR values.
+
+		//
+		// <stdio.h>
+		//
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern void perror (string s);
+
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern int rename (string oldpath, string newpath);
+
+		[DllImport (LIBC)]
+		public static extern void clearerr (IntPtr stream);
+
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern IntPtr fopen (string path, string mode);
+
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern IntPtr fdopen (int filedes, string mode);
+
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern IntPtr freopen (string path, string mode, IntPtr stream);
+
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern int fclose (IntPtr stream);
+
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern int fflush (IntPtr stream);
+
+		[DllImport (LIBC)]
+		public static extern int feof (IntPtr stream);
+
+		[DllImport (LIBC)]
+		public static extern int ferror (IntPtr stream);
+
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern int fileno (IntPtr stream);
+
+		[DllImport (LIBC, SetLastError=true)]
+		private static extern int sys_printf (string format, string arg);
+
+		public static int printf (string message)
+		{
+			return sys_printf ("%s", message);
+		}
+
+		[DllImport (LIBC, SetLastError=true)]
+		private static extern int sys_fprintf (IntPtr stream, string format, string arg);
+
+		public static int fprintf (IntPtr stream, string message)
+		{
+			return sys_fprintf (stream, "%s", message);
+		}
+
+		//
+		// <stdlib.h>
+		//
+		[DllImport (MPH, SetLastError=true, EntryPoint="Mono_Posix_Stdlib_calloc")]
+		public static extern IntPtr calloc (size_t nmemb, size_t size);
+
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern void exit (int status);
+
+		[DllImport (LIBC, SetLastError=true)]
+		public static extern void free (IntPtr ptr);
+
+		[DllImport (MPH, SetLastError=true, EntryPoint="Mono_Posix_Stdlib_malloc")]
+		public static extern IntPtr malloc (size_t size);
+
+		[DllImport (MPH, SetLastError=true, EntryPoint="Mono_Posix_Stdlib_calloc")]
+		public static extern IntPtr realloc (IntPtr ptr, size_t size);
+
+		//
+		// <string.h>
+		//
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="strerror")]
+		private static extern IntPtr sys_strerror (int errnum);
+
+		public static IntPtr sys_strerror (Error errnum)
+		{
+			int e = PosixConvert.FromError (errnum);
+			return sys_strerror (e);
+		}
+
+		public static string strerror (Error errnum)
+		{
+			IntPtr r = sys_strerror (errnum);
+			return PosixUtils.MarshalString (r);
+		}
+	}
+}
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/Syscall.cs Mono.Posix.new/Syscall.cs
--- Mono.Posix/Syscall.cs	2004-10-14 22:26:22.457965904 -0400
+++ Mono.Posix.new/Syscall.cs	2004-10-14 22:19:28.670871000 -0400
@@ -1,10 +1,12 @@
 //
-// Mono.Posix.Syscall.cs: System calls to Posix subsystem features
+// Mono.Posix/Syscall.cs
 //
-// Author:
+// Authors:
 //   Miguel de Icaza (miguel@novell.com)
+//   Jonathan Pryor (jonpryor@vt.edu)
 //
 // (C) 2003 Novell, Inc.
+// (C) 2004 Jonathan Pryor
 //
 // This file implements the low-level syscall interface to the POSIX
 // subsystem.
@@ -52,15 +54,155 @@
 //
 
 using System;
-using System.Text;
+using System.Collections;
 using System.Runtime.InteropServices;
+using System.Text;
+using Mono.Posix;
+
+[assembly:Mono.Posix.IncludeAttribute (
+	new string [] {"sys/types.h", "sys/stat.h", "sys/poll.h", "sys/wait.h", "sys/mount.h",
+		"unistd.h", "fcntl.h", "signal.h", "poll.h", "grp.h", "errno.h"}, 
+	new string [] {"_GNU_SOURCE", "_XOPEN_SOURCE"})]
 
-[assembly:Mono.Posix.IncludeAttribute (new string [] {"sys/types.h", "sys/stat.h", "sys/wait.h", "unistd.h", "fcntl.h", "signal.h", "poll.h"},
-				       new string [] {"_GNU_SOURCE"})]
 namespace Mono.Posix {
 
+	[Map]
+	public enum Error : int {
+		// errors & their values liberally copied from
+		// FC2 /usr/include/asm/errno.h
+		
+		ESUCCESS        =   0, // Operation succeeded (extension)
+		EPERM           =   1, // Operation not permitted 
+		ENOENT          =   2, // No such file or directory 
+		ESRCH           =   3, // No such process 
+		EINTR           =   4, // Interrupted system call 
+		EIO             =   5, // I/O error 
+		ENXIO           =   6, // No such device or address 
+		E2BIG           =   7, // Arg list too long 
+		ENOEXEC         =   8, // Exec format error 
+		EBADF           =   9, // Bad file number 
+		ECHILD          =  10, // No child processes 
+		EAGAIN          =  11, // Try again 
+		ENOMEM          =  12, // Out of memory 
+		EACCES          =  13, // Permission denied 
+		EFAULT          =  14, // Bad address 
+		ENOTBLK         =  15, // Block device required 
+		EBUSY           =  16, // Device or resource busy 
+		EEXIST          =  17, // File exists 
+		EXDEV           =  18, // Cross-device link 
+		ENODEV          =  19, // No such device 
+		ENOTDIR         =  20, // Not a directory 
+		EISDIR          =  21, // Is a directory 
+		EINVAL          =  22, // Invalid argument 
+		ENFILE          =  23, // File table overflow 
+		EMFILE          =  24, // Too many open files 
+		ENOTTY          =  25, // Not a typewriter 
+		ETXTBSY         =  26, // Text file busy 
+		EFBIG           =  27, // File too large 
+		ENOSPC          =  28, // No space left on device 
+		ESPIPE          =  29, // Illegal seek 
+		EROFS           =  30, // Read-only file system 
+		EMLINK          =  31, // Too many links 
+		EPIPE           =  32, // Broken pipe 
+		EDOM            =  33, // Math argument out of domain of func 
+		ERANGE          =  34, // Math result not representable 
+		EDEADLK         =  35, // Resource deadlock would occur 
+		ENAMETOOLONG    =  36, // File name too long 
+		ENOLCK          =  37, // No record locks available 
+		ENOSYS          =  38, // Function not implemented 
+		ENOTEMPTY       =  39, // Directory not empty 
+		ELOOP           =  40, // Too many symbolic links encountered 
+		EWOULDBLOCK     =  EAGAIN, // Operation would block 
+		ENOMSG          =  42, // No message of desired type 
+		EIDRM           =  43, // Identifier removed 
+		ECHRNG          =  44, // Channel number out of range 
+		EL2NSYNC        =  45, // Level 2 not synchronized 
+		EL3HLT          =  46, // Level 3 halted 
+		EL3RST          =  47, // Level 3 reset 
+		ELNRNG          =  48, // Link number out of range 
+		EUNATCH         =  49, // Protocol driver not attached 
+		ENOCSI          =  50, // No CSI structure available 
+		EL2HLT          =  51, // Level 2 halted 
+		EBADE           =  52, // Invalid exchange 
+		EBADR           =  53, // Invalid request descriptor 
+		EXFULL          =  54, // Exchange full 
+		ENOANO          =  55, // No anode 
+		EBADRQC         =  56, // Invalid request code 
+		EBADSLT         =  57, // Invalid slot 
+                      
+		EDEADLOCK	      =  EDEADLK,
+                      
+		EBFONT          =  59, // Bad font file format 
+		ENOSTR          =  60, // Device not a stream 
+		ENODATA         =  61, // No data available 
+		ETIME           =  62, // Timer expired 
+		ENOSR           =  63, // Out of streams resources 
+		ENONET          =  64, // Machine is not on the network 
+		ENOPKG          =  65, // Package not installed 
+		EREMOTE         =  66, // Object is remote 
+		ENOLINK         =  67, // Link has been severed 
+		EADV            =  68, // Advertise error 
+		ESRMNT          =  69, // Srmount error 
+		ECOMM           =  70, // Communication error on send 
+		EPROTO          =  71, // Protocol error 
+		EMULTIHOP       =  72, // Multihop attempted 
+		EDOTDOT         =  73, // RFS specific error 
+		EBADMSG         =  74, // Not a data message 
+		EOVERFLOW       =  75, // Value too large for defined data type 
+		ENOTUNIQ        =  76, // Name not unique on network 
+		EBADFD          =  77, // File descriptor in bad state 
+		EREMCHG         =  78, // Remote address changed 
+		ELIBACC         =  79, // Can not access a needed shared library 
+		ELIBBAD         =  80, // Accessing a corrupted shared library 
+		ELIBSCN         =  81, // .lib section in a.out corrupted 
+		ELIBMAX         =  82, // Attempting to link in too many shared libraries 
+		ELIBEXEC        =  83, // Cannot exec a shared library directly 
+		EILSEQ          =  84, // Illegal byte sequence 
+		ERESTART        =  85, // Interrupted system call should be restarted 
+		ESTRPIPE        =  86, // Streams pipe error 
+		EUSERS          =  87, // Too many users 
+		ENOTSOCK        =  88, // Socket operation on non-socket 
+		EDESTADDRREQ    =  89, // Destination address required 
+		EMSGSIZE        =  90, // Message too long 
+		EPROTOTYPE      =  91, // Protocol wrong type for socket 
+		ENOPROTOOPT     =  92, // Protocol not available 
+		EPROTONOSUPPORT =  93, // Protocol not supported 
+		ESOCKTNOSUPPORT	=  94, // Socket type not supported 
+		EOPNOTSUPP      =  95, // Operation not supported on transport endpoint 
+		EPFNOSUPPORT    =  96, // Protocol family not supported 
+		EAFNOSUPPORT    =  97, // Address family not supported by protocol 
+		EADDRINUSE      =  98, // Address already in use 
+		EADDRNOTAVAIL   =  99, // Cannot assign requested address 
+		ENETDOWN        = 100, // Network is down 
+		ENETUNREACH     = 101, // Network is unreachable 
+		ENETRESET       = 102, // Network dropped connection because of reset 
+		ECONNABORTED    = 103, // Software caused connection abort 
+		ECONNRESET      = 104, // Connection reset by peer 
+		ENOBUFS         = 105, // No buffer space available 
+		EISCONN         = 106, // Transport endpoint is already connected 
+		ENOTCONN        = 107, // Transport endpoint is not connected 
+		ESHUTDOWN       = 108, // Cannot send after transport endpoint shutdown 
+		ETOOMANYREFS    = 109, // Too many references: cannot splice 
+		ETIMEDOUT       = 110, // Connection timed out 
+		ECONNREFUSED    = 111, // Connection refused 
+		EHOSTDOWN       = 112, // Host is down 
+		EHOSTUNREACH    = 113, // No route to host 
+		EALREADY        = 114, // Operation already in progress 
+		EINPROGRESS     = 115, // Operation now in progress 
+		ESTALE          = 116, // Stale NFS file handle 
+		EUCLEAN         = 117, // Structure needs cleaning 
+		ENOTNAM         = 118, // Not a XENIX named type file 
+		ENAVAIL         = 119, // No XENIX semaphores available 
+		EISNAM          = 120, // Is a named type file 
+		EREMOTEIO       = 121, // Remote I/O error 
+		EDQUOT          = 122, // Quota exceeded 
+
+		ENOMEDIUM       = 123, // No medium found 
+		EMEDIUMTYPE     = 124, // Wrong medium type 
+	}
+
 	[Map][Flags]
-	public enum OpenFlags {
+	public enum OpenFlags : int {
 		//
 		// One of these
 		//
@@ -80,600 +222,1811 @@ namespace Mono.Posix {
 		O_SYNC      = 256,
 
 		//
-		// These are non-Posix, think of a way of exposing
-		// this for Linux users.
+		// These are non-Posix.  Using them will result in errors/exceptions on
+		// non-supported platforms.
+		//
+		// (For example, "C-wrapped" system calls -- calls with implementation in
+		// MonoPosixHelper -- will return -1 with errno=EINVAL.  C#-wrapped system
+		// calls will generate an exception in PosixConvert, as the value can't be
+		// converted on the target platform.)
 		//
 		
-		// O_NOFOLLOW  = 512,
-		// O_DIRECTORY = 1024,
-		// O_DIRECT    = 2048,
-		// O_ASYNC     = 4096,
-		// O_LARGEFILE = 8192
+		O_NOFOLLOW  = 512,
+		O_DIRECTORY = 1024,
+		O_DIRECT    = 2048,
+		O_ASYNC     = 4096,
+		O_LARGEFILE = 8192
 	}
 	
+	// mode_t
 	[Flags][Map]
-	public enum FileMode {
-		S_ISUID   = 2048,
-		S_ISGID   = 1024,
-		S_ISVTX   = 512,
-		S_IRUSR   = 256,
-		S_IWUSR   = 128,
-		S_IXUSR   = 64,
-		S_IRGRP   = 32,
-		S_IWGRP   = 16,
-		S_IXGRP   = 8,
-		S_IROTH   = 4,
-		S_IWOTH   = 2,
-		S_IXOTH   = 1
+	public enum FilePermissions : uint {
+		S_ISUID     = 0x0800, // Set user ID on execution
+		S_ISGID     = 0x0400, // Set gorup ID on execution
+		S_ISVTX     = 0x0200, // Save swapped text after use (sticky).
+		S_IRUSR     = 0x0100, // Read by owner
+		S_IWUSR     = 0x0080, // Write by owner
+		S_IXUSR     = 0x0040, // Execute by owner
+		S_IRGRP     = 0x0020, // Read by group
+		S_IWGRP     = 0x0010, // Write by group
+		S_IXGRP     = 0x0008, // Execute by group
+		S_IROTH     = 0x0004, // Read by other
+		S_IWOTH     = 0x0002, // Write by other
+		S_IXOTH     = 0x0001, // Execute by other
+
+		S_IRWXG     = (S_IRGRP | S_IWGRP | S_IXGRP),
+		S_IRWXU     = (S_IRUSR | S_IWUSR | S_IXUSR),
+		S_IRWXO     = (S_IROTH | S_IWOTH | S_IXOTH),
+		ACCESSPERMS = (S_IRWXU | S_IRWXG | S_IRWXO), // 0777
+		ALLPERMS    = (S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO), // 07777
+		DEFFILEMODE = (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH), // 0666
+
+		// Device types
+		// Why these are held in "mode_t" is beyond me...
+		S_IFMT      = 0xF000, // Bits which determine file type
+		S_IFDIR     = 0x4000, // Directory
+		S_IFCHR     = 0x2000, // Character device
+		S_IFBLK     = 0x6000, // Block device
+		S_IFREG     = 0x8000, // Regular file
+		S_IFIFO     = 0x1000, // FIFO
+		S_IFLNK     = 0xA000, // Symbolic link
+		S_IFSOCK    = 0xC000, // Socket
+	}
+
+	public struct Flock {
+		public LockType l_type;
+		public SeekFlags l_whence;
+		public long l_start;
+		public long l_len;
+		public int l_pid;
+	}
+
+	[Map]
+	public enum CmdFlags : int {
+		// Form /usr/include/bits/fcntl.h
+		F_DUPFD    =    0, // Duplicate file descriptor.
+		F_GETFD    =    1, // Get file descriptor flags.
+		F_SETFD    =    2, // Set file descriptor flags.
+		F_GETFL    =    3, // Get file status flags.
+		F_SETFL    =    4, // Set file status flags.
+		F_GETLK    =   12, // Get record locking info. [64]
+		F_SETLK    =   13, // Set record locking info (non-blocking). [64]
+		F_SETLKW   =   14, // Set record locking info (blocking). [64]
+		F_SETOWN   =    8, // Set owner of socket (receiver of SIGIO).
+		F_GETOWN   =    9, // Get owner of socket (receiver of SIGIO).
+		F_SETSIG   =   10, // Set number of signal to be sent.
+		F_GETSIG   =   11, // Get number of signal to be sent.
+		F_SETLEASE = 1024, // Set a lease.
+		F_GETLEASE = 1025, // Enquire what lease is active.
+		F_NOTIFY   = 1026, // Required notifications on a directory
+	}
+
+	[Map]
+	public enum LockType : short {
+		F_RDLCK = 0, // Read lock.
+		F_WRLCK = 1, // Write lock.
+		F_UNLCK = 2, // Remove lock.
+	}
+
+	[Map]
+	public enum SeekFlags : short {
+		// values liberally copied from /usr/include/unistd.h
+		SEEK_SET = 0, // Seek from beginning of file.
+		SEEK_CUR = 1, // Seek from current position.
+		SEEK_END = 2, // Seek from end of file.
+
+		L_SET    = SEEK_SET, // BSD alias for SEEK_SET
+		L_INCR   = SEEK_CUR, // BSD alias for SEEK_CUR
+		L_XTND   = SEEK_END, // BSD alias for SEEK_END
+	}
+	
+	[Map, Flags]
+	public enum DirectoryNotify : int {
+		// from /usr/include/bits/fcntl.h
+		DN_ACCESS    = 0x00000001, // File accessed.
+		DN_MODIFY    = 0x00000002, // File modified.
+		DN_CREATE    = 0x00000004, // File created.
+		DN_DELETE    = 0x00000008, // File removed.
+		DN_RENAME    = 0x00000010, // File renamed.
+		DN_ATTRIB    = 0x00000020, // File changed attributes.
+		DN_MULTISHOT = unchecked ((int)0x80000000), // Don't remove notifier
+	}
+
+	[Map]
+	public enum PosixFadviseFlags : int {
+		POSIX_FADV_NORMAL     = 0,  // No further special treatment.
+		POSIX_FADV_RANDOM     = 1,  // Expect random page references.
+		POSIX_FADV_SEQUENTIAL = 2,  // Expect sequential page references.
+		POSIX_FADV_WILLNEED   = 3,  // Will need these pages.
+		POSIX_FADV_DONTNEED   = 4,  // Don't need these pages.
+		POSIX_FADV_NOREUSE    = 5,  // Data will be accessed once.
+	}
+
+	[Map]
+	public enum PosixMadviseFlags : int {
+		POSIX_MADV_NORMAL     = 0,  // No further special treatment.
+		POSIX_MADV_RANDOM     = 1,  // Expect random page references.
+		POSIX_MADV_SEQUENTIAL = 2,  // Expect sequential page references.
+		POSIX_MADV_WILLNEED   = 3,  // Will need these pages.
+		POSIX_MADV_DONTNEED   = 4,  // Don't need these pages.
+	}
+
+	[Map]
+	public enum Signum : int {
+		SIGHUP    =  1, // Hangup (POSIX).
+		SIGINT    =  2, // Interrupt (ANSI).
+		SIGQUIT   =  3, // Quit (POSIX).
+		SIGILL    =  4, // Illegal instruction (ANSI).
+		SIGTRAP   =  5, // Trace trap (POSIX).
+		SIGABRT   =  6, // Abort (ANSI).
+		SIGIOT    =  6, // IOT trap (4.2 BSD).
+		SIGBUS    =  7, // BUS error (4.2 BSD).
+		SIGFPE    =  8, // Floating-point exception (ANSI).
+		SIGKILL   =  9, // Kill, unblockable (POSIX).
+		SIGUSR1   = 10, // User-defined signal 1 (POSIX).
+		SIGSEGV   = 11, // Segmentation violation (ANSI).
+		SIGUSR2   = 12, // User-defined signal 2 (POSIX).
+		SIGPIPE   = 13, // Broken pipe (POSIX).
+		SIGALRM   = 14, // Alarm clock (POSIX).
+		SIGTERM   = 15, // Termination (ANSI).
+		SIGSTKFLT = 16, // Stack fault.
+		SIGCLD    = SIGCHLD, // Same as SIGCHLD (System V).
+		SIGCHLD   = 17, // Child status has changed (POSIX).
+		SIGCONT   = 18, // Continue (POSIX).
+		SIGSTOP   = 19, // Stop, unblockable (POSIX).
+		SIGTSTP   = 20, // Keyboard stop (POSIX).
+		SIGTTIN   = 21, // Background read from tty (POSIX).
+		SIGTTOU   = 22, // Background write to tty (POSIX).
+		SIGURG    = 23, // Urgent condition on socket (4.2 BSD).
+		SIGXCPU   = 24, // CPU limit exceeded (4.2 BSD).
+		SIGXFSZ   = 25, // File size limit exceeded (4.2 BSD).
+		SIGVTALRM = 26, // Virtual alarm clock (4.2 BSD).
+		SIGPROF   = 27, // Profiling alarm clock (4.2 BSD).
+		SIGWINCH  = 28, // Window size change (4.3 BSD, Sun).
+		SIGPOLL   = SIGIO, // Pollable event occurred (System V).
+		SIGIO     = 29, // I/O now possible (4.2 BSD).
+		SIGPWR    = 30, // Power failure restart (System V).
+		SIGSYS    = 31, // Bad system call.
+		SIGUNUSED = 31
+	}
+
+	[Map][Flags]
+	public enum MountFlags : ulong {
+		MS_RDONLY      = 1,    // Mount read-only.
+		MS_NOSUID      = 2,    // Ignore suid and sgid bits.
+		MS_NODEV       = 4,    // Disallow access to device special files.
+		MS_NOEXEC      = 8,    // Disallow program execution.
+		MS_SYNCHRONOUS = 16,   // Writes are synced at once.
+		MS_REMOUNT     = 32,   // Alter flags of a mounted FS.
+		MS_MANDLOCK    = 64,   // Allow mandatory locks on an FS.
+		S_WRITE        = 128,  // Write on file/directory/symlink.
+		S_APPEND       = 256,  // Append-only file.
+		S_IMMUTABLE    = 512,  // Immutable file.
+		MS_NOATIME     = 1024, // Do not update access times.
+		MS_NODIRATIME  = 2048, // Do not update directory access times.
+		MS_BIND        = 4096, // Bind directory at different place.
+		MS_RMT_MASK    = (MS_RDONLY | MS_MANDLOCK),
+		MS_MGC_VAL     = 0xc0ed0000, // Magic flag number to indicate "new" flags
+		MS_MGC_MSK     = 0xffff0000, // Magic flag number mask
+	}
+
+	[Map][Flags]
+	public enum UmountFlags : int {
+		MNT_FORCE  = 1, // Force unmount even if busy
+		MNT_DETACH,     // Perform a lazy unmount.
 	}
 
 	[Flags][Map]
-	public enum WaitOptions {
+	public enum WaitOptions : int {
 		WNOHANG,
 		WUNTRACED
 	}
 
-	[Flags][Map]
-	public enum AccessMode {
+  [Flags][Map]
+	public enum AccessMode : int {
 		R_OK = 1,
 		W_OK = 2,
 		X_OK = 4,
-		F_OK = 8
+		F_OK = 8,
 	}
 
 	[Map]
-	public enum Signals {
-		SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS,
-		SIGFPE, SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE,
-		SIGALRM, SIGTERM, SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP,
-		SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM,
-		SIGPROF, SIGWINCH, SIGIO,
-		
-		// SIGPWR,
-		SIGSYS,
-		// SIGRTMIN
+	public enum PathConf : int {
+		_PC_LINK_MAX,
+		_PC_MAX_CANON,
+		_PC_MAX_INPUT,
+		_PC_NAME_MAX,
+		_PC_PATH_MAX,
+		_PC_PIPE_BUF,
+		_PC_CHOWN_RESTRICTED,
+		_PC_NO_TRUNC,
+		_PC_VDISABLE,
+		_PC_SYNC_IO,
+		_PC_ASYNC_IO,
+		_PC_PRIO_IO,
+		_PC_SOCK_MAXBUF,
+		_PC_FILESIZEBITS,
+		_PC_REC_INCR_XFER_SIZE,
+		_PC_REC_MAX_XFER_SIZE,
+		_PC_REC_MIN_XFER_SIZE,
+		_PC_REC_XFER_ALIGN,
+		_PC_ALLOC_SIZE_MIN,
+		_PC_SYMLINK_MAX,
+		_PC_2_SYMLINKS
 	}
 
-	[Flags][Map]
+	[Map]
+	public enum SysConf : int {
+		_SC_ARG_MAX,
+		_SC_CHILD_MAX,
+		_SC_CLK_TCK,
+		_SC_NGROUPS_MAX,
+		_SC_OPEN_MAX,
+		_SC_STREAM_MAX,
+		_SC_TZNAME_MAX,
+		_SC_JOB_CONTROL,
+		_SC_SAVED_IDS,
+		_SC_REALTIME_SIGNALS,
+		_SC_PRIORITY_SCHEDULING,
+		_SC_TIMERS,
+		_SC_ASYNCHRONOUS_IO,
+		_SC_PRIORITIZED_IO,
+		_SC_SYNCHRONIZED_IO,
+		_SC_FSYNC,
+		_SC_MAPPED_FILES,
+		_SC_MEMLOCK,
+		_SC_MEMLOCK_RANGE,
+		_SC_MEMORY_PROTECTION,
+		_SC_MESSAGE_PASSING,
+		_SC_SEMAPHORES,
+		_SC_SHARED_MEMORY_OBJECTS,
+		_SC_AIO_LISTIO_MAX,
+		_SC_AIO_MAX,
+		_SC_AIO_PRIO_DELTA_MAX,
+		_SC_DELAYTIMER_MAX,
+		_SC_MQ_OPEN_MAX,
+		_SC_MQ_PRIO_MAX,
+		_SC_VERSION,
+		_SC_PAGESIZE,
+		_SC_RTSIG_MAX,
+		_SC_SEM_NSEMS_MAX,
+		_SC_SEM_VALUE_MAX,
+		_SC_SIGQUEUE_MAX,
+		_SC_TIMER_MAX,
+		/* Values for the argument to `sysconf'
+			 corresponding to _POSIX2_* symbols.  */
+		_SC_BC_BASE_MAX,
+		_SC_BC_DIM_MAX,
+		_SC_BC_SCALE_MAX,
+		_SC_BC_STRING_MAX,
+		_SC_COLL_WEIGHTS_MAX,
+		_SC_EQUIV_CLASS_MAX,
+		_SC_EXPR_NEST_MAX,
+		_SC_LINE_MAX,
+		_SC_RE_DUP_MAX,
+		_SC_CHARCLASS_NAME_MAX,
+		_SC_2_VERSION,
+		_SC_2_C_BIND,
+		_SC_2_C_DEV,
+		_SC_2_FORT_DEV,
+		_SC_2_FORT_RUN,
+		_SC_2_SW_DEV,
+		_SC_2_LOCALEDEF,
+		_SC_PII,
+		_SC_PII_XTI,
+		_SC_PII_SOCKET,
+		_SC_PII_INTERNET,
+		_SC_PII_OSI,
+		_SC_POLL,
+		_SC_SELECT,
+		_SC_UIO_MAXIOV,
+		_SC_IOV_MAX = _SC_UIO_MAXIOV,
+		_SC_PII_INTERNET_STREAM,
+		_SC_PII_INTERNET_DGRAM,
+		_SC_PII_OSI_COTS,
+		_SC_PII_OSI_CLTS,
+		_SC_PII_OSI_M,
+		_SC_T_IOV_MAX,
+		/* Values according to POSIX 1003.1c (POSIX threads).  */
+		_SC_THREADS,
+		_SC_THREAD_SAFE_FUNCTIONS,
+		_SC_GETGR_R_SIZE_MAX,
+		_SC_GETPW_R_SIZE_MAX,
+		_SC_LOGIN_NAME_MAX,
+		_SC_TTY_NAME_MAX,
+		_SC_THREAD_DESTRUCTOR_ITERATIONS,
+		_SC_THREAD_KEYS_MAX,
+		_SC_THREAD_STACK_MIN,
+		_SC_THREAD_THREADS_MAX,
+		_SC_THREAD_ATTR_STACKADDR,
+		_SC_THREAD_ATTR_STACKSIZE,
+		_SC_THREAD_PRIORITY_SCHEDULING,
+		_SC_THREAD_PRIO_INHERIT,
+		_SC_THREAD_PRIO_PROTECT,
+		_SC_THREAD_PROCESS_SHARED,
+		_SC_NPROCESSORS_CONF,
+		_SC_NPROCESSORS_ONLN,
+		_SC_PHYS_PAGES,
+		_SC_AVPHYS_PAGES,
+		_SC_ATEXIT_MAX,
+		_SC_PASS_MAX,
+		_SC_XOPEN_VERSION,
+		_SC_XOPEN_XCU_VERSION,
+		_SC_XOPEN_UNIX,
+		_SC_XOPEN_CRYPT,
+		_SC_XOPEN_ENH_I18N,
+		_SC_XOPEN_SHM,
+		_SC_2_CHAR_TERM,
+		_SC_2_C_VERSION,
+		_SC_2_UPE,
+		_SC_XOPEN_XPG2,
+		_SC_XOPEN_XPG3,
+		_SC_XOPEN_XPG4,
+		_SC_CHAR_BIT,
+		_SC_CHAR_MAX,
+		_SC_CHAR_MIN,
+		_SC_INT_MAX,
+		_SC_INT_MIN,
+		_SC_LONG_BIT,
+		_SC_WORD_BIT,
+		_SC_MB_LEN_MAX,
+		_SC_NZERO,
+		_SC_SSIZE_MAX,
+		_SC_SCHAR_MAX,
+		_SC_SCHAR_MIN,
+		_SC_SHRT_MAX,
+		_SC_SHRT_MIN,
+		_SC_UCHAR_MAX,
+		_SC_UINT_MAX,
+		_SC_ULONG_MAX,
+		_SC_USHRT_MAX,
+		_SC_NL_ARGMAX,
+		_SC_NL_LANGMAX,
+		_SC_NL_MSGMAX,
+		_SC_NL_NMAX,
+		_SC_NL_SETMAX,
+		_SC_NL_TEXTMAX,
+		_SC_XBS5_ILP32_OFF32,
+		_SC_XBS5_ILP32_OFFBIG,
+		_SC_XBS5_LP64_OFF64,
+		_SC_XBS5_LPBIG_OFFBIG,
+		_SC_XOPEN_LEGACY,
+		_SC_XOPEN_REALTIME,
+		_SC_XOPEN_REALTIME_THREADS,
+		_SC_ADVISORY_INFO,
+		_SC_BARRIERS,
+		_SC_BASE,
+		_SC_C_LANG_SUPPORT,
+		_SC_C_LANG_SUPPORT_R,
+		_SC_CLOCK_SELECTION,
+		_SC_CPUTIME,
+		_SC_THREAD_CPUTIME,
+		_SC_DEVICE_IO,
+		_SC_DEVICE_SPECIFIC,
+		_SC_DEVICE_SPECIFIC_R,
+		_SC_FD_MGMT,
+		_SC_FIFO,
+		_SC_PIPE,
+		_SC_FILE_ATTRIBUTES,
+		_SC_FILE_LOCKING,
+		_SC_FILE_SYSTEM,
+		_SC_MONOTONIC_CLOCK,
+		_SC_MULTI_PROCESS,
+		_SC_SINGLE_PROCESS,
+		_SC_NETWORKING,
+		_SC_READER_WRITER_LOCKS,
+		_SC_SPIN_LOCKS,
+		_SC_REGEXP,
+		_SC_REGEX_VERSION,
+		_SC_SHELL,
+		_SC_SIGNALS,
+		_SC_SPAWN,
+		_SC_SPORADIC_SERVER,
+		_SC_THREAD_SPORADIC_SERVER,
+		_SC_SYSTEM_DATABASE,
+		_SC_SYSTEM_DATABASE_R,
+		_SC_TIMEOUTS,
+		_SC_TYPED_MEMORY_OBJECTS,
+		_SC_USER_GROUPS,
+		_SC_USER_GROUPS_R,
+		_SC_2_PBS,
+		_SC_2_PBS_ACCOUNTING,
+		_SC_2_PBS_LOCATE,
+		_SC_2_PBS_MESSAGE,
+		_SC_2_PBS_TRACK,
+		_SC_SYMLOOP_MAX,
+		_SC_STREAMS,
+		_SC_2_PBS_CHECKPOINT,
+		_SC_V6_ILP32_OFF32,
+		_SC_V6_ILP32_OFFBIG,
+		_SC_V6_LP64_OFF64,
+		_SC_V6_LPBIG_OFFBIG,
+		_SC_HOST_NAME_MAX,
+		_SC_TRACE,
+		_SC_TRACE_EVENT_FILTER,
+		_SC_TRACE_INHERIT,
+		_SC_TRACE_LOG,
+		_SC_LEVEL1_ICACHE_SIZE,
+		_SC_LEVEL1_ICACHE_ASSOC,
+		_SC_LEVEL1_ICACHE_LINESIZE,
+		_SC_LEVEL1_DCACHE_SIZE,
+		_SC_LEVEL1_DCACHE_ASSOC,
+		_SC_LEVEL1_DCACHE_LINESIZE,
+		_SC_LEVEL2_CACHE_SIZE,
+		_SC_LEVEL2_CACHE_ASSOC,
+		_SC_LEVEL2_CACHE_LINESIZE,
+		_SC_LEVEL3_CACHE_SIZE,
+		_SC_LEVEL3_CACHE_ASSOC,
+		_SC_LEVEL3_CACHE_LINESIZE,
+		_SC_LEVEL4_CACHE_SIZE,
+		_SC_LEVEL4_CACHE_ASSOC,
+		_SC_LEVEL4_CACHE_LINESIZE
+	}
+
+	[Map]
+	public enum ConfStr : int {
+		_CS_PATH,			/* The default search path.  */
+		_CS_V6_WIDTH_RESTRICTED_ENVS,
+		_CS_GNU_LIBC_VERSION,
+		_CS_GNU_LIBPTHREAD_VERSION,
+		_CS_LFS_CFLAGS = 1000,
+		_CS_LFS_LDFLAGS,
+		_CS_LFS_LIBS,
+		_CS_LFS_LINTFLAGS,
+		_CS_LFS64_CFLAGS,
+		_CS_LFS64_LDFLAGS,
+		_CS_LFS64_LIBS,
+		_CS_LFS64_LINTFLAGS,
+		_CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
+		_CS_XBS5_ILP32_OFF32_LDFLAGS,
+		_CS_XBS5_ILP32_OFF32_LIBS,
+		_CS_XBS5_ILP32_OFF32_LINTFLAGS,
+		_CS_XBS5_ILP32_OFFBIG_CFLAGS,
+		_CS_XBS5_ILP32_OFFBIG_LDFLAGS,
+		_CS_XBS5_ILP32_OFFBIG_LIBS,
+		_CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
+		_CS_XBS5_LP64_OFF64_CFLAGS,
+		_CS_XBS5_LP64_OFF64_LDFLAGS,
+		_CS_XBS5_LP64_OFF64_LIBS,
+		_CS_XBS5_LP64_OFF64_LINTFLAGS,
+		_CS_XBS5_LPBIG_OFFBIG_CFLAGS,
+		_CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
+		_CS_XBS5_LPBIG_OFFBIG_LIBS,
+		_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
+		_CS_POSIX_V6_ILP32_OFF32_CFLAGS,
+		_CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
+		_CS_POSIX_V6_ILP32_OFF32_LIBS,
+		_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
+		_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
+		_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
+		_CS_POSIX_V6_ILP32_OFFBIG_LIBS,
+		_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
+		_CS_POSIX_V6_LP64_OFF64_CFLAGS,
+		_CS_POSIX_V6_LP64_OFF64_LDFLAGS,
+		_CS_POSIX_V6_LP64_OFF64_LIBS,
+		_CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
+		_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
+		_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
+		_CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
+		_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
+	}
+
+	[Map]
+	public enum LockFlags : int {
+		F_ULOCK = 0, // Unlock a previously locked region.
+		F_LOCK  = 1, // Lock a region for exclusive use.
+		F_TLOCK = 2, // Test and lock a region for exclusive use.
+		F_TEST  = 3, // Test a region for other process locks.
+	}
+
+	[Map][Flags]
 	public enum PollEvents : short {
-		POLLIN = 0x002,
-		POLLPRI,
-		POLLOUT,
-		POLLERR,
-		POLLHUP,
-		POLLNVAL
+		POLLIN      = 0x0001, // There is data to read
+		POLLPRI     = 0x0002, // There is urgent data to read
+		POLLOUT     = 0x0004, // Writing now will not block
+		POLLERR     = 0x0008, // Error condition
+		POLLHUP     = 0x0010, // Hung up
+		POLLNVAL    = 0x0020, // Invalid request; fd not open
+		// XPG4.2 definitions (via _XOPEN_SOURCE)
+		POLLRDNORM  = 0x0040, // Normal data bay be read
+		POLLRDBAND  = 0x0080, // Priority data may be read
+		POLLWRNORM  = 0x0100, // Writing now will not block
+		POLLWRBAND  = 0x0200, // Priority data may be written
 	}
-	
+
 	[StructLayout(LayoutKind.Sequential)]
-	public struct pollfd {
+	public struct Pollfd {
 		public int fd;
 		public PollEvents events;
 		public PollEvents revents;
 	}
 
-	public class Syscall {
+	public class Dirent
+	{
+		public ino_t  d_ino;
+		public off_t  d_off;
+		public ushort d_reclen;
+		public byte   d_type;
+		public string d_name;
+
+		public override string ToString ()
+		{
+			return d_name;
+		}
+	}
+
+	public class Group
+	{
+		public string   gr_name;
+		public string   gr_passwd;
+		public gid_t    gr_gid;
+		public string[] gr_mem;
+	}
+
+	public class Passwd
+	{
+		public string pw_name;
+		public string pw_passwd;
+		public uid_t  pw_uid;
+		public gid_t  pw_gid;
+		public string pw_gecos;
+		public string pw_dir;
+		public string pw_shell;
+	}
+
+	public struct Stat {
+		public  dev_t             st_dev;       // device
+		public  ino_t             st_ino;       // inode
+		public  FilePermissions   st_mode;      // protection
+		private uint              _padding_;    // padding for structure alignment
+		public  nlink_t           st_nlink;     // number of hard links
+		public  uid_t             st_uid;       // user ID of owner
+		public  gid_t             st_gid;       // group ID of owner
+		public  dev_t             st_rdev;      // device type (if inode device)
+		public  off_t             st_size;      // total size, in bytes
+		public  blksize_t         st_blksize;   // blocksize for filesystem I/O
+		public  blkcnt_t          st_blocks;    // number of blocks allocated
+		public  time_t            st_atime;     // time of last access
+		public  time_t            st_mtime;     // time of last modification
+		public  time_t            st_ctime;     // time of last status change
+	}
+
+	//
+	// Convention: Functions *not* part of the standard C library AND part of
+	// a POSIX and/or Unix standard (X/Open, SUS, XPG, etc.) go here.
+	//
+	// For example, the man page should be similar to:
+	//
+	//    CONFORMING TO (or CONFORMS TO)
+	//           XPG2, SUSv2, POSIX, etc.
+	//
+	// BSD- and GNU-specific exports can also be placed here.
+	//
+	// The only methods in here should be:
+	//  (1) low-level functions
+	//  (2) "Trivial" function overloads.  For example, if the parameters to a
+	//      function are releated (e.g. getgroups(2))
+	//  (3) The return type SHOULD NOT be changed.  If you want to provide a
+	//      convenient function with a nicer return type, place it into one of
+	//      the Posix* wrapper classes, and give it a .NET-styled name.
+	//  (4) Exceptions SHOULD NOT be thrown.  EXCEPTION: if you're wrapping
+	//      *broken* methods which make assumptions about input data, such as
+	//      that an argument refers to N bytes of data.  This is currently
+	//      limited to cuserid(3) and encrypt(3).
+	//
+	public sealed class Syscall : Stdlib
+	{
+		private Syscall () {}
+
+		//
+		// <dirent.h>
+		//
+
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int exit (int status);
+		public static extern IntPtr opendir (string name);
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int fork ();
+		public static extern int closedir (IntPtr dir);
+
+		// Slight modification of seekdir(3).  Returns -1 on error, 0 on success.
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_seekdir")]
+		public static extern int seekdir (IntPtr dir, off_t offset);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_telldir")]
+		public static extern off_t telldir (IntPtr dir);
 
 		[DllImport ("libc", SetLastError=true)]
-		public unsafe static extern IntPtr read (int fileDescriptor, void *buf, IntPtr count);
+		public static extern void rewinddir (IntPtr dir);
+
+		private struct _Dirent {
+			public ino_t  d_ino;
+			public off_t  d_off;
+			public ushort d_reclen;
+			public byte   d_type;
+			public IntPtr d_name;
+		}
+
+		private static void CopyDirent (Dirent to, ref _Dirent from)
+		{
+			try {
+				to.d_ino    = from.d_ino;
+				to.d_off    = from.d_off;
+				to.d_reclen = from.d_reclen;
+				to.d_type   = from.d_type;
+				if (from.d_name != IntPtr.Zero)
+					to.d_name = PosixUtils.MarshalString (from.d_name);
+				else 
+					to.d_name = null;
+			}
+			finally {
+				Stdlib.free (from.d_name);
+				from.d_name = IntPtr.Zero;
+			}
+		}
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_readdir")]
+		private static extern int sys_readdir (IntPtr dir, out _Dirent dentry);
+
+		public static Dirent readdir (IntPtr dir)
+		{
+			_Dirent dentry;
+			int r = sys_readdir (dir, out dentry);
+			if (r != 0)
+				return null;
+			Dirent d = new Dirent ();
+			CopyDirent (d, ref dentry);
+			return d;
+		}
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_readdir_r")]
+		private static extern int sys_readdir_r (IntPtr dirp, out _Dirent entry, out IntPtr result);
+
+		public static int readdir_r (IntPtr dirp, Dirent entry, out IntPtr result)
+		{
+			entry.d_ino    = (ino_t) 0;
+			entry.d_off    = (off_t) 0;
+			entry.d_reclen = 0;
+			entry.d_type   = 0;
+			entry.d_name   = null;
+
+			_Dirent _d;
+			int r = sys_readdir_r (dirp, out _d, out result);
+
+			if (r == 0 && result != IntPtr.Zero) {
+				CopyDirent (entry, ref _d);
+			}
+
+			return r;
+		}
 
 		[DllImport ("libc", SetLastError=true)]
-		public unsafe static extern IntPtr write (int fileDescriptor, void *buf, IntPtr count);
+		public static extern int dirfd (IntPtr dir);
+
+		//
+		// <errno.h>
+		//
+
+		public static Error GetLastError ()
+		{
+			// 0 doesn't have a special macro, so it generates an error when going
+			// through the mapping infrastructure.  Since 0 is a common "no error"
+			// value, handle it here.
+			int errno = Marshal.GetLastWin32Error ();
+			if (errno == 0)
+				return Error.ESUCCESS;
+			return PosixConvert.ToError (errno);
+		}
+
+		[DllImport ("MonoPosixHelper", EntryPoint="Mono_Posix_Syscall_SetLastError")]
+		private static extern void SetLastError (int error);
+
+		public static void SetLastError (Error error)
+		{
+			if (error == Error.ESUCCESS)
+				SetLastError (0);
+			else {
+				int _error = PosixConvert.FromError (error);
+				SetLastError (_error);
+			}
+		}
+
+		[DllImport ("libc", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_strerror_r")]
+		private static extern int sys_strerror_r (int errnum, 
+				[Out] StringBuilder buf, size_t n);
+
+		public static int strerror_r (Error errnum, StringBuilder buf, size_t n)
+		{
+			int e = PosixConvert.FromError (errnum);
+			return sys_strerror_r (e, buf, n);
+		}
+
+		public static int strerror_r (Error errnum, StringBuilder buf)
+		{
+			return strerror_r (errnum, buf, (size_t) buf.Capacity);
+		}
+
+		// Shoud this be here?  By convention, it shouldn't be, but I'm not sure
+		// which class would be better.
+		public static string strerror_r (Error errnum)
+		{
+			StringBuilder buf = new StringBuilder (16);
+			int r = 0;
+			do {
+				buf.Capacity *= 2;
+				r = strerror_r (errnum, buf);
+			} while (r == -1 && GetLastError() == Error.ERANGE);
+
+			if (r == -1)
+				return "** Unknown error code: " + ((int) errnum) + "**";
+			return buf.ToString();
+		}
 
-		[DllImport ("libc", EntryPoint="poll", SetLastError=true)]
-		public static extern int syscall_poll (pollfd [] fds, int nfds, int timeout);
+		//
+		// <fcntl.h>
+		//
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_fcntl")]
+		public static extern int fcntl (int fd, CmdFlags cmd);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_fcntl_arg")]
+		public static extern int fcntl (int fd, CmdFlags cmd, long arg);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_fcntl_lock")]
+		public static extern int fcntl (int fd, CmdFlags cmd, ref Flock @lock);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_open")]
+		public static extern int open (string pathname, OpenFlags flags);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_open_mode")]
+		public static extern int open (string pathname, OpenFlags flags, FilePermissions mode);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_creat")]
+		public static extern int creat (string pathname, FilePermissions mode);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_posix_fadvise")]
+		public static extern int posix_fadvise (int fd, off_t offset, 
+			off_t len, PosixFadviseFlags advice);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_posix_fallocate")]
+		public static extern int posix_fallocate (int fd, off_t offset, off_t len);
 
-		public static int poll (pollfd [] fds, int nfds, int timeout)
+		//
+		// <grp.h>
+		//
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int setgroups (size_t size, gid_t[] list);
+
+		public static int setgroups (gid_t[] list)
 		{
-			int res;
+			return setgroups ((size_t) list.Length, list);
+		}
 
-			pollfd [] send = new pollfd [nfds];
+		private struct _Group
+		{
+			public IntPtr gr_name;
+			public IntPtr gr_passwd;
+			public gid_t  gr_gid;
+			public IntPtr gr_mem;
+			public IntPtr _gr_buf_;
+		}
 
-			for (int i = 0; i < nfds; i++) {
-				send [i].fd = fds [i].fd;
-				send [i].events = (PollEvents) map_Mono_Posix_PollEvents (fds [i].events);
+		private static void CopyGroup (Group to, ref _Group from)
+		{
+			try {
+				to.gr_gid    = from.gr_gid;
+				to.gr_name   = PosixUtils.MarshalString (from.gr_name);
+				to.gr_passwd = PosixUtils.MarshalString (from.gr_passwd);
+				to.gr_mem    = ExtractMembers (from.gr_mem);
+			}
+			finally {
+				Stdlib.free (from.gr_mem);
+				Stdlib.free (from._gr_buf_);
+				from.gr_mem   = IntPtr.Zero;
+				from._gr_buf_ = IntPtr.Zero;
 			}
+		}
 
-			res = syscall_poll (send, nfds, timeout);
+		// `mem' is a C `char **'.  This will be fun to extract...
+		private static string[] ExtractMembers (IntPtr mem)
+		{
+			if (mem == IntPtr.Zero)
+				return new string[]{};
 
-			for (int i = 0; i < nfds; i++) {
-				fds [i].revents = (PollEvents) map_Mono_Posix_PollEvents (send [i].revents);
+			ArrayList members = new ArrayList ();
+			int ptr_size = IntPtr.Size;
+			int offset = 0;
+			IntPtr item = Marshal.ReadIntPtr (mem, offset);
+			while (item != IntPtr.Zero) {
+				members.Add (PosixUtils.MarshalString (item));
+				offset += ptr_size;
+				item = Marshal.ReadIntPtr (mem, offset);
 			}
+			return (string[]) members.ToArray (typeof(string));
+		}
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getgrnam")]
+		private static extern int sys_getgrnam (string name, out _Group group);
 
-			return res;
+		public static Group getgrnam (string name)
+		{
+			_Group group;
+			int r = sys_getgrnam (name, out group);
+			if (r != 0)
+				return null;
+			Group gr = new Group ();
+			CopyGroup (gr, ref group);
+			return gr;
 		}
 
-		[DllImport ("MonoPosixHelper")]
-		internal extern static int map_Mono_Posix_PollEvents (PollEvents pe);
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getgrgid")]
+		private static extern int sys_getgrgid (gid_t uid, out _Group group);
 
-		[DllImport ("libc", EntryPoint="open", SetLastError=true)]
-		internal static extern int syscall_open (string pathname, int flags, int mode);
+		public static Group getgrgid (gid_t uid)
+		{
+			_Group group;
+			int r = sys_getgrgid (uid, out group);
+			if (r != 0)
+				return null;
+			Group gr = new Group ();
+			CopyGroup (gr, ref group);
+			return gr;
+		}
 
-		[DllImport ("MonoPosixHelper")]
-		internal extern static int map_Mono_Posix_OpenFlags (OpenFlags flags);
-		[DllImport ("MonoPosixHelper")]
-		internal extern static int map_Mono_Posix_FileMode (FileMode mode);
-		
-		public static int open (string pathname, OpenFlags flags)
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getgrnam_r")]
+		private static extern int sys_getgrnam_r (string name, out _Group grbuf, out IntPtr grbufp);
+
+		public static int getgrnam_r (string name, Group grbuf, out Group grbufp)
 		{
-			if ((flags & OpenFlags.O_CREAT) != 0)
-				throw new ArgumentException ("If you pass O_CREAT, you must call the method with the mode flag");
-			
-			int posix_flags = map_Mono_Posix_OpenFlags (flags);
-			return syscall_open (pathname, posix_flags, 0);
+			grbufp = null;
+			_Group group;
+			IntPtr _grbufp;
+			int r = sys_getgrnam_r (name, out group, out _grbufp);
+			if (r == 0 && _grbufp != IntPtr.Zero) {
+				CopyGroup (grbuf, ref group);
+				grbufp = grbuf;
+			}
+			return r;
 		}
 
-		public static int open (string pathname, OpenFlags flags, FileMode mode)
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getgrgid_r")]
+		private static extern int sys_getgrgid_r (gid_t uid, out _Group grbuf, out IntPtr grbufp);
+
+		public static int getgrgid_r (gid_t uid, Group grbuf, out Group grbufp)
 		{
-			int posix_flags = map_Mono_Posix_OpenFlags (flags);
-			int posix_mode = map_Mono_Posix_FileMode (mode);
+			grbufp = null;
+			_Group group;
+			IntPtr _grbufp;
+			int r = sys_getgrgid_r (uid, out group, out _grbufp);
+			if (r == 0 && _grbufp != IntPtr.Zero) {
+				CopyGroup (grbuf, ref group);
+				grbufp = grbuf;
+			}
+			return r;
+		}
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getgrent")]
+		private static extern int sys_getgrent (out _Group grbuf);
 
-			return syscall_open (pathname, posix_flags, posix_mode);
+		public static Group getgrent ()
+		{
+			_Group group;
+			int r = sys_getgrent (out group);
+			if (r != 0)
+				return null;
+			Group gr = new Group();
+			CopyGroup (gr, ref group);
+			return gr;
 		}
-		
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int close (int fileDescriptor);
+		public static extern void setgrent ();
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern void endgrent ();
 
-		[DllImport ("libc", EntryPoint="waitpid", SetLastError=true)]
-		unsafe internal static extern int syscall_waitpid (int pid, int * status, int options);
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_fgetgrent")]
+		private static extern int sys_fgetgrent (IntPtr stream, out _Group grbuf);
 
-		[DllImport ("MonoPosixHelper")]
-		internal extern static int map_Mono_Posix_WaitOptions (WaitOptions wait_options);
-		
-		public static int waitpid (int pid, out int status, WaitOptions options)
+		public static Group fgetgrent (IntPtr stream)
 		{
-			unsafe {
-				int s = 0;
-				int r = syscall_waitpid (pid, &s, map_Mono_Posix_WaitOptions (options));
-				status = s;
-				return r;
+			_Group group;
+			int r = sys_fgetgrent (stream, out group);
+			if (r != 0)
+				return null;
+			Group gr = new Group ();
+			CopyGroup (gr, ref group);
+			return gr;
+		}
+
+		//
+		// <pwd.h>
+		//
+		private struct _Passwd
+		{
+			public IntPtr pw_name;
+			public IntPtr pw_passwd;
+			public uid_t  pw_uid;
+			public gid_t  pw_gid;
+			public IntPtr pw_gecos;
+			public IntPtr pw_dir;
+			public IntPtr pw_shell;
+			public IntPtr _pw_buf_;
+		}
+
+		private static void CopyPasswd (Passwd to, ref _Passwd from)
+		{
+			try {
+				to.pw_name   = PosixUtils.MarshalString (from.pw_name);
+				to.pw_passwd = PosixUtils.MarshalString (from.pw_passwd);
+				to.pw_uid    = from.pw_uid;
+				to.pw_gid    = from.pw_gid;
+				to.pw_gecos  = PosixUtils.MarshalString (from.pw_gecos);
+				to.pw_dir    = PosixUtils.MarshalString (from.pw_dir);
+				to.pw_shell  = PosixUtils.MarshalString (from.pw_shell);
+			}
+			finally {
+				Stdlib.free (from._pw_buf_);
+				from._pw_buf_ = IntPtr.Zero;
 			}
 		}
-		
-		public static int waitpid (int pid, WaitOptions options)
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getpwnam")]
+		private static extern int sys_getpwnam (string name, out _Passwd passwd);
+
+		public static Passwd getpwnam (string name)
+		{
+			_Passwd passwd;
+			int r = sys_getpwnam (name, out passwd);
+			if (r != 0)
+				return null;
+			Passwd pw = new Passwd ();
+			CopyPasswd (pw, ref passwd);
+			return pw;
+		}
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getpwuid")]
+		private static extern int sys_getpwuid (uid_t uid, out _Passwd passwd);
+
+		public static Passwd getpwuid (uid_t uid)
 		{
-			unsafe {
-				return syscall_waitpid (pid, null, map_Mono_Posix_WaitOptions (options));
+			_Passwd passwd;
+			int r = sys_getpwuid (uid, out passwd);
+			if (r != 0)
+				return null;
+			Passwd pw = new Passwd ();
+			CopyPasswd (pw, ref passwd);
+			return pw;
+		}
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getpwnam_r")]
+		private static extern int sys_getpwnam_r (string name, out _Passwd pwbuf, out IntPtr pwbufp);
+
+		public static int getpwnam_r (string name, Passwd pwbuf, out Passwd pwbufp)
+		{
+			pwbufp = null;
+			_Passwd passwd;
+			IntPtr _pwbufp;
+			int r = sys_getpwnam_r (name, out passwd, out _pwbufp);
+			if (r == 0 && _pwbufp != IntPtr.Zero) {
+				CopyPasswd (pwbuf, ref passwd);
+				pwbufp = pwbuf;
 			}
+			return r;
 		}
 
-		[DllImport ("MonoPosixHelper", EntryPoint="wifexited")]
-		public static extern int WIFEXITED (int status);
-		[DllImport ("MonoPosixHelper", EntryPoint="wexitstatus")]
-		public static extern int WEXITSTATUS (int status);
-		[DllImport ("MonoPosixHelper", EntryPoint="wifsignaled")]
-		public static extern int WIFSIGNALED (int status);
-		[DllImport ("MonoPosixHelper", EntryPoint="wtermsig")]
-		public static extern int WTERMSIG (int status);
-		[DllImport ("MonoPosixHelper", EntryPoint="wifstopped")]
-		public static extern int WIFSTOPPED (int status);
-		[DllImport ("MonoPosixHelper", EntryPoint="wstopsig")]
-		public static extern int WSTOPSIG (int status);
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getpwuid_r")]
+		private static extern int sys_getpwuid_r (uid_t uid, out _Passwd pwbuf, out IntPtr pwbufp);
 
-		[DllImport ("libc", SetLastError=true)]
-		internal static extern int syscall_creat (string pathname, int flags);
+		public static int getpwuid_r (uid_t uid, Passwd pwbuf, out Passwd pwbufp)
+		{
+			pwbufp = null;
+			_Passwd passwd;
+			IntPtr _pwbufp;
+			int r = sys_getpwuid_r (uid, out passwd, out _pwbufp);
+			if (r == 0 && _pwbufp != IntPtr.Zero) {
+				CopyPasswd (pwbuf, ref passwd);
+				pwbufp = pwbuf;
+			}
+			return r;
+		}
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getpwent")]
+		private static extern int sys_getpwent (out _Passwd pwbuf);
 
-		public static int creat (string pathname, FileMode flags)
+		public static Passwd getpwent ()
 		{
-			return syscall_creat (pathname, map_Mono_Posix_FileMode (flags));
+			_Passwd passwd;
+			int r = sys_getpwent (out passwd);
+			if (r != 0)
+				return null;
+			Passwd pw = new Passwd ();
+			CopyPasswd (pw, ref passwd);
+			return pw;
 		}
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int link (string oldPath, string newPath);
+		public static extern void setpwent ();
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int unlink (string path);
+		public static extern void endpwent ();
 
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_fgetpwent")]
+		private static extern int sys_fgetpwent (IntPtr stream, out _Passwd pwbuf);
+
+		public static Passwd fgetpwent (IntPtr stream)
+		{
+			_Passwd passwd;
+			int r = sys_fgetpwent (stream, out passwd);
+			if (r != 0)
+				return null;
+			Passwd pw = new Passwd ();
+			CopyPasswd (pw, ref passwd);
+			return pw;
+		}
+
+		//
+		// <signal.h>
+		//
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int symlink (string oldpath, string newpath);
-		
-		// TODO: execve
+		private static extern void psignal (int sig, string s);
+
+		public static void psignal (Signum sig, string s)
+		{
+			int signum = PosixConvert.FromSignum (sig);
+			psignal (signum, s);
+		}
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int chdir (string path);
+		private static extern int sys_kill (pid_t pid, int sig);
 
-		// TODO: time
-		// TODO: mknod
+		public static int kill (pid_t pid, Signum sig)
+		{
+			int _sig = PosixConvert.FromSignum (sig);
+			return sys_kill (pid, _sig);
+		}
 
-		
-		[DllImport ("libc", EntryPoint="chmod", SetLastError=true)]
-		internal static extern int syscall_chmod (string path, int mode);
+		[DllImport ("libc", SetLastError=true, EntryPoint="strsignal")]
+		private static extern IntPtr sys_strsignal (int sig);
 
-		public static int chmod (string path, FileMode mode)
+		public static IntPtr sys_strsignal (Signum sig)
 		{
-			return syscall_chmod (path, map_Mono_Posix_FileMode (mode));
+			int s = PosixConvert.FromSignum (sig);
+			return sys_strsignal (s);
 		}
 
+		public static string strsignal (Signum sig)
+		{
+			IntPtr r = sys_strsignal (sig);
+			return PosixUtils.MarshalString (r);
+		}
+
+		// TODO: sigaction(2)
+		// TODO: sigsuspend(2)
+		// TODO: sigpending(2)
+
+
+		//
+		// <stdio.h>
+		//
+		[DllImport ("MonoPosixHelper", EntryPoint="Mono_Posix_Syscall_L_ctermid")]
+		private static extern int _L_ctermid ();
+
+		public static readonly int L_ctermid = _L_ctermid ();
+
+		[DllImport ("MonoPosixHelper", EntryPoint="Mono_Posix_Syscall_L_cuserid")]
+		private static extern int _L_cuserid ();
+
+		public static readonly int L_cuserid = _L_cuserid ();
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="cuserid")]
+		private static extern IntPtr sys_cuserid ([Out] StringBuilder @string);
+
+		[Obsolete ("\"Nobody knows precisely what cuserid() does... DO NOT USE cuserid()." +
+				"`string' must hold L_cuserid characters.  Use Unistd.getlogin_r instead.")]
+		public static string cuserid (StringBuilder @string)
+		{
+			if (@string.Capacity < L_cuserid) {
+				throw new ArgumentOutOfRangeException ("string", "string.Capacity < L_cuserid");
+			}
+			IntPtr r = sys_cuserid (@string);
+			return PosixUtils.MarshalString (r);
+		}
+
+		//
+		// <stdlib.h>
+		//
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int chown (string path, int owner, int group);
+		public static extern int ttyslot ();
+
+		[DllImport ("crypt", SetLastError=true)]
+		public static extern void setkey (string key);
+
+		//
+		// <sys/mman.h>
+		//
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_posix_madvise")]
+		public static extern int posix_madvise (IntPtr addr, size_t len, 
+			PosixMadviseFlags advice);
+
+		//
+		// <sys/mount.h>
+		//
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_mount")]
+		public static extern int mount (string source, string target, 
+				string filesystemtype, MountFlags mountflags, string data);
+
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int lchown (string path, int owner, int group);
-		
+		public static extern int umount (string target);
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="umount2")]
+		private static extern int sys_umount2 (string target, int flags);
+
+		public static int umount2 (string target, UmountFlags flags)
+		{
+			int _flags = PosixConvert.FromUmountFlags (flags);
+			return sys_umount2 (target, _flags);
+		}
+
+		//
+		// <sys/poll.h>
+		//
+		private struct _pollfd {
+			public int fd;
+			public short events;
+			public short revents;
+		}
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="poll")]
+		private static extern int sys_poll (_pollfd[] ufds, uint nfds, int timeout);
+
+		public static int poll (Pollfd [] fds, uint nfds, int timeout)
+		{
+			if (fds.Length < nfds)
+				throw new ArgumentOutOfRangeException ("fds", "Must refer to at least `nfds' elements");
+
+			_pollfd[] send = new _pollfd[nfds];
+
+			for (int i = 0; i < send.Length; i++) {
+				send [i].fd     = fds [i].fd;
+				send [i].events = PosixConvert.FromPollEvents (fds [i].events);
+			}
+
+			int r = sys_poll (send, nfds, timeout);
+
+			for (int i = 0; i < send.Length; i++) {
+				fds [i].revents = PosixConvert.ToPollEvents (send [i].revents);
+			}
+
+			return r;
+		}
+
+		public static int poll (Pollfd [] fds, int timeout)
+		{
+			return poll (fds, (uint) fds.Length, timeout);
+		}
+
+		//
+		// <sys/ptrace.h>
+		//
+
+		// TODO: ptrace(2)
+
+		//
+		// <sys/resource.h>
+		//
+
+		// TODO: setrlimit(2)
+		// TODO: getrlimit(2)
+		// TODO: getrusage(2)
+
+		//
+		// <sys/stat.h>
+		//
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_stat")]
+		public static extern int stat (string file_name, out Stat buf);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_fstat")]
+		public static extern int fstat (int filedes, out Stat buf);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_lstat")]
+		public static extern int lstat (string file_name, out Stat buf);
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="chmod")]
+		private static extern int sys_chmod (string path, uint mode);
+
+		public static int chmod (string path, FilePermissions mode)
+		{
+			uint _mode = PosixConvert.FromFilePermissions (mode);
+			return sys_chmod (path, _mode);
+		}
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="fchmod")]
+		private static extern int sys_fchmod (int filedes, uint mode);
+
+		public static int fchmod (int filedes, FilePermissions mode)
+		{
+			uint _mode = PosixConvert.FromFilePermissions (mode);
+			return sys_fchmod (filedes, _mode);
+		}
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="umask")]
+		private static extern int sys_umask (uint mask);
+
+		public static int umask (FilePermissions mask)
+		{
+			uint _mask = PosixConvert.FromFilePermissions (mask);
+			return sys_umask (_mask);
+		}
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="mkdir")]
+		public static extern int sys_mkdir (string oldpath, uint mode);
+
+		public static int mkdir (string oldpath, FilePermissions mode)
+		{
+			uint _mode = PosixConvert.FromFilePermissions (mode);
+			return sys_mkdir (oldpath, _mode);
+		}
+
+		// TODO: mknod(2)
+
+		//
+		// <sys/time.h>
+		//
+
+		// TODO: times(2)
+		// TODO: gettimeofday(2)
+		// TODO: settimeofday(2)
+
+		//
+		// <sys/timeb.h>
+		//
+
+		// TODO: ftime(3)
+
+		//
+		// <sys/wait.h>
+		//
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int lseek (int fileDescriptor, int offset, int whence);
+		public static extern pid_t wait (ref int status);
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int getpid ();
-		
-		// TODO: mount
-		// TODO: umount
+		private static extern pid_t waitpid (pid_t pid, ref int status, int options);
+
+		public static pid_t waitpid (pid_t pid, ref int status, WaitOptions options)
+		{
+			int _options = PosixConvert.FromWaitOptions (options);
+			return waitpid (pid, ref status, _options);
+		}
+
+		[DllImport ("MonoPosixHelper", EntryPoint="Mono_Posix_Syscall_WIFEXITED")]
+		private static extern int _WIFEXITED (int status);
+
+		public static bool WIFEXITED (int status)
+		{
+			return _WIFEXITED (status) != 0;
+		}
+
+		[DllImport ("MonoPosixHelper", EntryPoint="Mono_Posix_Syscall_WEXITSTATUS")]
+		public static extern int WEXITSTATUS (int status);
+
+		[DllImport ("MonoPosixHelper", EntryPoint="Mono_Posix_Syscall_WIFSIGNALED")]
+		private static extern int _WIFSIGNALED (int status);
+
+		public static bool WIFSIGNALED (int status)
+		{
+			return _WIFSIGNALED (status) != 0;
+		}
+
+		[DllImport ("MonoPosixHelper", EntryPoint="Mono_Posix_Syscall_WTERMSIG")]
+		private static extern int _WTERMSIG (int status);
+
+		public static Signum WTERMSIG (int status)
+		{
+			int r = _WTERMSIG (status);
+			return PosixConvert.ToSignum (r);
+		}
+
+		[DllImport ("MonoPosixHelper", EntryPoint="Mono_Posix_Syscall_WIFSTOPPED")]
+		private static extern int _WIFSTOPPED (int status);
+
+		public static bool WIFSTOPPED (int status)
+		{
+			return _WIFSTOPPED (status) != 0;
+		}
+
+		[DllImport ("MonoPosixHelper", EntryPoint="Mono_Posix_Syscall_WSTOPSIG")]
+		private static extern int _WSTOPSIG (int status);
+
+		public static Signum WSTOPSIG (int status)
+		{
+			int r = _WSTOPSIG (status);
+			return PosixConvert.ToSignum (r);
+		}
+
+		//
+		// <time.h>
+		//
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_stime")]
+		public static extern int stime (ref time_t t);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_time")]
+		public static extern time_t time (out time_t t);
+
+		//
+		// <ulimit.h>
+		//
+
+		// TODO: ulimit(3)
+
+		//
+		// <unistd.h>
+		//
+		[DllImport ("libc", SetLastError=true, EntryPoint="access")]
+		private static extern int sys_access (string pathname, int mode);
+
+		public static int access (string pathname, AccessMode mode)
+		{
+			int _mode = PosixConvert.FromAccessMode (mode);
+			return sys_access (pathname, _mode);
+		}
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_lseek")]
+		public static extern off_t lseek (int fd, off_t offset, SeekFlags whence);
+
+    [DllImport ("libc", SetLastError=true)]
+		public static extern int close (int fd);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_read")]
+		public static unsafe extern long read (int fd, void *buf, size_t count);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_write")]
+		public static unsafe extern long write (int fd, void *buf, size_t count);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_pread")]
+		public static unsafe extern long pread (int fd, void *buf, size_t count, off_t offset);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_pwrite")]
+		public static unsafe extern long pwrite (int fd, void *buf, size_t count, off_t offset);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_pipe")]
+		public static extern int pipe (out int reading, out int writing);
+
+		public static int pipe (int[] filedes)
+		{
+			if (filedes == null || filedes.Length != 2) {
+				// TODO: set errno
+				return -1;
+			}
+			int reading, writing;
+			int r = pipe (out reading, out writing);
+			filedes[0] = reading;
+			filedes[1] = writing;
+			return r;
+		}
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int setuid (int uid);
-		
+		public static extern uint alarm (uint seconds);
+
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int getuid ();
+		public static extern int sleep (uint seconds);
 
-		// TODO: stime
-		// TODO: ptrace
-		
-		[DllImport ("libc")]
-		public static extern uint alarm (uint seconds);
+		[DllImport ("libc", SetLastError=true)]
+		public static extern uint ualarm (uint usecs, uint interval);
 
 		[DllImport ("libc", SetLastError=true)]
 		public static extern int pause ();
 
-		// TODO: utime
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int chown (string path, uid_t owner, gid_t group);
 
-		[DllImport ("libc")]
-		internal extern static int syscall_access (string pathname, int mode);
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int fchown (int fd, uid_t owner, gid_t group);
 
-		[DllImport ("MonoPosixHelper")]
-		internal extern static int map_Mono_Posix_AccessMode (AccessMode mode);
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int lchown (string path, uid_t owner, gid_t group);
 
-		public static int access (string pathname, AccessMode mode)
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int chdir (string path);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int fchdir (int fd);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getcwd")]
+		public static extern IntPtr getcwd ([Out] StringBuilder buf, size_t size);
+
+		public static StringBuilder getcwd (StringBuilder buf)
 		{
-			return syscall_access (pathname, map_Mono_Posix_AccessMode (mode));
+			getcwd (buf, (size_t) buf.Capacity);
+			return buf;
 		}
 
+		// getwd(2) is deprecated; don't expose it.
+
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int nice (int increment);
+		public static extern int dup (int fd);
 
-		// TODO: ftime
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int dup2 (int fd, int fd2);
 
-		[DllImport ("libc")]
-		public static extern void sync ();
+		// TODO: does Mono marshal arrays properly?
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int execve (string path, string[] argv, string[] envp);
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern void kill (int pid, int sig);
+		public static extern int execv (string path, string[] argv);
 
+		// TODO: execle, execl
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int rename (string oldPath, string newPath);
-		
+		public static extern int execvp (string path, string[] argv);
+
 		[DllImport ("libc", SetLastError=true)]
-		internal extern static int syscall_mkdir (string pathname, int mode);
+		public static extern int nice (int inc);
 
-		public static int mkdir (string pathname, FileMode mode)
-		{
-			return syscall_mkdir (pathname, map_Mono_Posix_FileMode (mode));
-		}
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int _exit (int status);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_fpathconf")]
+		public static extern long fpathconf (int filedes, PathConf name);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_pathconf")]
+		public static extern long pathconf (string path, PathConf name);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_sysconf")]
+		public static extern long sysconf (SysConf name);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_confstr")]
+		public static extern size_t confstr (ConfStr name, [Out] StringBuilder buf, size_t len);
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int rmdir (string path);
+		public static extern pid_t getpid ();
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int dup (int fileDescriptor);
+		public static extern int setpgid (pid_t pid, pid_t pgid);
 
-		// TODO: pipe
-		// TODO: times
+		[DllImport ("libc", SetLastError=true)]
+		public static extern pid_t getpgid (pid_t pid);
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int setgid (int gid);
+		public static extern int setpgrp ();
+
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int getgid ();
+		public static extern pid_t getpgrp ();
 
-		
-		public delegate void sighandler_t (int v);
-		
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int signal (int signum, sighandler_t handler);
-		
+		public static extern pid_t setsid ();
+
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int geteuid ();
-		
+		public static extern pid_t getsid (pid_t pid);
+
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int getegid ();
+		public static extern uid_t getuid ();
 
-		// TODO: fcntl
-		
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int setpgid (int pid, int pgid);
+		public static extern uid_t geteuid ();
 
-		// TODO: ulimit
+		[DllImport ("libc", SetLastError=true)]
+		public static extern gid_t getgid ();
 
-		[DllImport ("libc")]
-		public static extern int umask (int umask);
+		[DllImport ("libc", SetLastError=true)]
+		public static extern gid_t getegid ();
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int chroot (string path);
+		public static extern int getgroups (int size, gid_t[] list);
+
+		public static int getgroups (gid_t[] list)
+		{
+			return getgroups (list.Length, list);
+		}
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int dup2 (int oldFileDescriptor, int newFileDescriptor);
+		public static extern int setuid (uid_t uid);
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int getppid ();
+		public static extern int setreuid (uid_t ruid, uid_t euid);
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int getpgrp ();
+		public static extern int setregid (gid_t rgid, gid_t egid);
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int setsid ();
-		
-		// TODO: sigaction
-		
+		public static extern int seteuid (uid_t uid);
+
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int setreuid (int ruid, int euid);
+		public static extern int setegid (gid_t uid);
 
 		[DllImport ("libc", SetLastError=true)]
-		public static extern int setregid (int rgid, int egid);
+		public static extern int setgid (gid_t gid);
 
-		// these don't exactly match POSIX, but it's a nice way to get user/group names
-		
-		[DllImport ("MonoPosixHelper", SetLastError=true)]
-		private static extern string helper_Mono_Posix_GetUserName (int uid);
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int getresuid (out uid_t ruid, out uid_t euid, out uid_t suid);
 
-		[DllImport ("MonoPosixHelper", SetLastError=true)]
-		private static extern string helper_Mono_Posix_GetGroupName (int gid);
-		
-		public static string getusername(int uid) { return helper_Mono_Posix_GetUserName(uid); }
-		public static string getgroupname(int gid) { return helper_Mono_Posix_GetGroupName(gid); }
-		
-		// TODO: sigsuspend
-		// TODO: sigpending
-		// TODO: setrlimit
-		// TODO: getrlimit
-		// TODO: getrusage
-		// TODO: gettimeofday
-		// TODO: settimeofday
-		
-		[DllImport ("libc", EntryPoint="gethostname", SetLastError=true)]
-		static extern int syscall_gethostname (byte[] p, int len);
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int getresgid (out gid_t rgid, out gid_t egid, out gid_t sgid);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int setresuid (uid_t ruid, uid_t euid, uid_t suid);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int setresgid (gid_t rgid, gid_t egid, gid_t sgid);
+
+		[DllImport ("libc", SetLastError=true)]
+		[Obsolete ("DO NOT directly call fork(2); it bypasses essential " + 
+				"shutdown code.\nUse System.Diagnostics.Process instead")]
+		public static extern pid_t fork ();
+
+		[DllImport ("libc", SetLastError=true)]
+		[Obsolete ("DO NOT directly call vfork(2); it bypasses essential " + 
+				"shutdown code.\nUse System.Diagnostics.Process instead")]
+		public static extern pid_t vfork ();
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="ttyname")]
+		[Obsolete ("Not re-entrant.  Use ttyname_r instead.")]
+		public static extern IntPtr sys_ttyname (int fd);
 
-		public static string GetHostName ()
+		[Obsolete ("Not re-entrant.  Use ttyname_r instead.")]
+		public static string ttyname (int fd)
 		{
-			byte [] buf = new byte [256];
-			int res = syscall_gethostname (buf, buf.Length);
-			if (res == -1)
-				return "localhost";
-			for (res = 0; res < buf.Length; ++res) {
-				if (buf [res] == 0)
-					break;
-			}
-				
-			return Encoding.UTF8.GetString (buf, 0, res);
+			IntPtr r = sys_ttyname (fd);
+			return PosixUtils.MarshalString (r);
 		}
 
-		public static string gethostname ()
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_ttyname_r")]
+		public static extern int ttyname_r (int fd, [Out] StringBuilder buf, size_t buflen);
+
+		public static int ttyname_r (int fd, StringBuilder buf)
 		{
-			return GetHostName ();
+			return ttyname_r (fd, buf, (size_t) buf.Capacity);
 		}
-		
 
 		[DllImport ("libc", EntryPoint="isatty")]
-		static extern int syscall_isatty (int desc);
-		
-		public static bool isatty (int desc)
+		private static extern int sys_isatty (int fd);
+
+		public static bool isatty (int fd)
 		{
-			int res = syscall_isatty (desc);
-			if (res == 1)
-				return true;
-			else
-				return false;
+			return sys_isatty (fd) == 1;
 		}
-		
 
-		[DllImport ("MonoPosixHelper")]
-		internal extern static int helper_Mono_Posix_Stat (string filename, bool dereference,
-			out int device, out int inode, out int mode,
-			out int nlinks, out int uid, out int gid,
-			out int rdev, out long size, out long blksize, out long blocks,
-			out long atime, out long mtime, out long ctime);
-		
-		private static int stat2(string filename, bool dereference, out Stat stat) {
-			int device, inode, mode;
-			int nlinks, uid, gid, rdev;
-			long size, blksize, blocks;
-			long atime, mtime, ctime;
-
-			int ret = helper_Mono_Posix_Stat(filename, dereference,
-				out device, out inode, out mode,
-				out nlinks, out uid, out gid,
-				out rdev, out size, out blksize, out blocks,
-				out atime, out mtime, out ctime);
-				
-			stat = new Stat(
-				device, inode, mode,
-				nlinks, uid, gid,
-				rdev, size, blksize, blocks,
-				atime, mtime, ctime);
-
-			if (ret != 0) return ret;
-
-			return 0;
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int link (string oldpath, string newpath);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int symlink (string oldpath, string newpath);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_readlink")]
+		public static extern int readlink (string path, [Out] StringBuilder buf, size_t bufsiz);
+
+		public static int readlink (string path, [Out] StringBuilder buf)
+		{
+			return readlink (path, buf, (size_t) buf.Capacity);
 		}
 
-		public static int stat(string filename, out Stat stat) {
-			return stat2(filename, false, out stat);
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int unlink (string pathname);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int rmdir (string pathname);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern pid_t tcgetpgrp (int fd);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int tcsetpgrp (int fd, pid_t pgrp);
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="getlogin")]
+		[Obsolete ("Not re-entrant.  Use getlogin_r instead.")]
+		public static extern IntPtr sys_getlogin ();
+
+		[Obsolete ("Not re-entrant.  Use getlogin_r instead.")]
+		public static string getlogin ()
+		{
+			IntPtr r = sys_getlogin ();
+			return PosixUtils.MarshalString (r);
 		}
 
-		public static int lstat(string filename, out Stat stat) {
-			return stat2(filename, true, out stat);
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getlogin_r")]
+		public static extern int getlogin_r ([Out] StringBuilder name, size_t bufsize);
+
+		public static int getlogin_r (StringBuilder name)
+		{
+			return getlogin_r (name, (size_t) name.Capacity);
 		}
-		
-		[DllImport ("libc")]
-		private static extern int readlink(string path, byte[] buffer, int buflen);
 
-		public static string readlink(string path) {
-			byte[] buf = new byte[512];
-			int ret = readlink(path, buf, buf.Length);
-			if (ret == -1) return null;
-			char[] cbuf = new char[512];
-			int chars = System.Text.Encoding.Default.GetChars(buf, 0, ret, cbuf, 0);
-			return new String(cbuf, 0, chars);
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_gethostname")]
+		public static extern int gethostname ([Out] StringBuilder name, size_t len);
+
+		public static int gethostname (StringBuilder name)
+		{
+			return gethostname (name, (size_t) name.Capacity);
 		}
 
-		[DllImport ("libc", EntryPoint="strerror")]
-		static extern IntPtr _strerror(int errnum);
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_gethostname")]
+		public static extern int sethostname (string name, size_t len);
 
-		public static string strerror (int errnum)
+		public static int sethostname (string name)
 		{
-			return Marshal.PtrToStringAnsi (_strerror (errnum));
+			return sethostname (name, (size_t) name.Length);
 		}
 
-		[DllImport ("libc")]
-		public static extern IntPtr opendir(string path);
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_gethostid")]
+		public static extern long gethostid ();
 
-		[DllImport ("libc")]
-		public static extern int closedir(IntPtr dir);
-		
-		[DllImport ("MonoPosixHelper", EntryPoint="helper_Mono_Posix_readdir")]
-		public static extern string readdir(IntPtr dir);
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_sethostid")]
+		public static extern int sethostid (long hostid);
 
-		[DllImport ("MonoPosixHelper")]
-		internal extern static int helper_Mono_Posix_getpwnamuid (int mode, string in_username, int in_uid,
-			out string account, out string password, out int uid,
-			out int gid, out string gecos, out string homedir,
-			out string shell);
-		
-		public static int getpwnam (string username, out Passwd passwd) {
-			return getpwnamuid(0, username, 0, out passwd);
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_getdomainname")]
+		public static extern int getdomainname ([Out] StringBuilder name, size_t len);
+
+		public static int getdomainname (StringBuilder name)
+		{
+			return getdomainname (name, (size_t) name.Capacity);
 		}
-		
-		public static int getpwuid (int uid, out Passwd passwd) {
-			return getpwnamuid(1, null, uid, out passwd);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true,
+				EntryPoint="Mono_Posix_Syscall_setdomainname")]
+		public static extern int setdomainname (string name, size_t len);
+
+		public static int setdomainname (string name)
+		{
+			return setdomainname (name, (size_t) name.Length);
 		}
-		
-		private static int getpwnamuid (int mode, string in_username, int in_uid, out Passwd passwd) {
-			string account, password, name, home, shell;
-			int uid, gid;
-
-			int ret = helper_Mono_Posix_getpwnamuid(mode, in_username, in_uid,
-				out account, out password, out uid,
-				out gid, out name, out home,
-				out shell);
-				
-			if (ret != 0) {
-				passwd = new Passwd();
-				return ret;
-			}
-			
-			passwd = new Passwd(
-				account, password, uid, gid,
-				name, home, shell);
 
-			return 0;
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int vhangup ();
+
+		// Revoke doesn't appear to be POSIX.  Include it?
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int revoke (string file);
+
+		// TODO: profil?  It's not POSIX.
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int acct (string filename);
+
+		[DllImport ("libc", SetLastError=true, EntryPoint="getusershell")]
+		public static extern IntPtr sys_getusershell ();
+
+		public static string getusershell ()
+		{
+			IntPtr r = sys_getusershell ();
+			return PosixUtils.MarshalString (r);
 		}
 
-	}
-	
-	public enum StatModeMasks {
-		TypeMask = 0xF000, // bitmask for the file type bitfields
-		OwnerMask = 0x1C0, // mask for file owner permissions
-		GroupMask = 0x38, // mask for group permissions
-		OthersMask = 0x7, // mask for permissions for others (not in group)
-	}
-	
-	[Flags]
-	public enum StatMode {
-		Socket = 0xC000, // socket
-		SymLink = 0xA000, // symbolic link
-		Regular = 0x8000, // regular file
-		BlockDevice = 0x6000, // block device
-		Directory = 0x4000, // directory
-		CharDevice = 0x2000, // character device
-		FIFO = 0x1000, // fifo
-		SUid = 0x800, // set UID bit
-		SGid = 0x400, // set GID bit
-		Sticky = 0x200, // sticky bit
-		OwnerRead = 0x100, // owner has read permission
-		OwnerWrite = 0x80, // owner has write permission
-		OwnerExecute = 0x40, // owner has execute permission
-		GroupRead = 0x20, // group has read permission
-		GroupWrite = 0x10, // group has write permission
-		GroupExecute = 0x8, // group has execute permission
-		OthersRead = 0x4, // others have read permission
-		OthersWrite = 0x2, // others have write permisson
-		OthersExecute = 0x1, // others have execute permission	
-	}
-	
-	public struct Stat {
-		public readonly int Device;
-		public readonly int INode;
-		public readonly StatMode Mode;
-		public readonly int NLinks;
-		public readonly int Uid;
-		public readonly int Gid;
-		public readonly long DeviceType;
-		public readonly long Size;
-		public readonly long BlockSize;
-		public readonly long Blocks;
-		public readonly DateTime ATime;
-		public readonly DateTime MTime;
-		public readonly DateTime CTime;
-		
-		public static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1).ToLocalTime();
-		
-		public static DateTime UnixToDateTime(long unix) {
-			return UnixEpoch.Add(TimeSpan.FromSeconds(unix));
+		[DllImport ("libc", SetLastError=true)]
+		public static extern void setusershell ();
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern void endusershell ();
+
+		[DllImport ("libc", SetLastError=true)]
+		private static extern int daemon (int nochdir, int noclose);
+
+		public static int daemon (bool nochdir, bool noclose)
+		{
+			return daemon (nochdir ? 1 : 0, noclose ? 1 : 0);
 		}
 
-		internal Stat(
-			int device, int inode, int mode,
-			int nlinks, int uid, int gid,
-			int rdev, long size, long blksize, long blocks,
-			long atime, long mtime, long ctime) {
-			Device = device;
-			INode = inode;
-			Mode = (StatMode)mode;
-			NLinks = nlinks;
-			Uid = uid;
-			Gid = gid;
-			DeviceType = rdev;
-			Size = size;
-			BlockSize = blksize;
-			Blocks = blocks;
-			if (atime != 0)
-				ATime = UnixToDateTime(atime);
-			else
-				ATime = new DateTime();
-			if (mtime != 0)
-				MTime = UnixToDateTime(mtime);
-			else
-				MTime = new DateTime();
-			if (ctime != 0)
-				CTime = UnixToDateTime(ctime);
-			else
-				CTime = new DateTime();
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int chroot (string path);
+
+		// skipping getpass(3) as the man page states:
+		//   This function is obsolete.  Do not use it.
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int fsync (int fd);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int fdatasync (int fd);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern void sync ();
+
+		[DllImport ("libc", SetLastError=true)]
+		[Obsolete ("Dropped in POSIX 1003.1-2001.  " +
+				"Use Unistd.sysconf (SysConf._SC_PAGESIZE).")]
+		public static extern int getpagesize ();
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_truncate")]
+		public static extern int truncate (string path, off_t length);
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_ftruncate")]
+		public static extern int ftruncate (int fd, off_t length);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int getdtablesize ();
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern int brk (IntPtr end_data_segment);
+
+		[DllImport ("libc", SetLastError=true)]
+		public static extern IntPtr sbrk (IntPtr increment);
+
+		// TODO: syscall(2)?
+		// Probably safer to skip entirely.
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_lockf")]
+		public static extern int lockf (int fd, LockFlags cmd, off_t len);
+
+		[DllImport ("crypt", SetLastError=true, EntryPoint="crypt")]
+		public static extern IntPtr sys_crypt (string key, string salt);
+
+		public static string crypt (string key, string salt)
+		{
+			IntPtr r = sys_crypt (key, salt);
+			return PosixUtils.MarshalString (r);
 		}
-	}
-	
-	public struct Passwd {
 
-		public readonly string Account;
-		public readonly string Password;
-		public readonly int Uid;
-		public readonly int Gid;
-		public readonly string Name;
-		public readonly string Home;
-		public readonly string Shell;
-
-		internal Passwd (
-			string account, string password, int uid,
-			int gid, string name, string home,
-			string shell) {
-
-			Account = account;
-			Password = password;
-			Uid = uid;
-			Gid = gid;
-			Name = name;
-			Home = home;
-			Shell = shell;
+		[DllImport ("crypt", SetLastError=true, EntryPoint="encrypt")]
+		private static extern void sys_encrypt ([In, Out] byte[] block, int edflag);
+
+		public static void encrypt (byte[] block, bool decode)
+		{
+			if (block.Length < 64)
+				throw new ArgumentOutOfRangeException ("block", "Must refer to at least 64 bytes");
+			sys_encrypt (block, decode ? 1 : 0);
 		}
+
+		[DllImport ("MonoPosixHelper", SetLastError=true, 
+				EntryPoint="Mono_Posix_Syscall_swab")]
+		public static unsafe extern void swab (void* from, void* to, ssize_t n);
+
+		//
+		// <utime.h>
+		//
+
+		// TODO: utime(2)
 	}
 }
+
+// vim: noexpandtab
diff -u -p -N --exclude='CVS*' Mono.Posix/Types.cs Mono.Posix.new/Types.cs
--- Mono.Posix/Types.cs	1969-12-31 19:00:00.000000000 -0500
+++ Mono.Posix.new/Types.cs	2004-10-14 22:19:28.744859000 -0400
@@ -0,0 +1,2937 @@
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl blkcnt_t long int
+//
+
+namespace Mono.Posix {
+
+	public struct blkcnt_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<blkcnt_t>
+#endif
+	{
+		private long value;
+
+		public blkcnt_t (long value)
+		{
+			this.value = value;
+		}
+
+		public blkcnt_t (int v)
+		{
+			this.value = checked ((long) v);
+		}
+		public long Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is blkcnt_t))
+				return false;
+			return ((blkcnt_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<blkcnt_t> Methods
+		//
+		public int CompareTo (blkcnt_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (blkcnt_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is blkcnt_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.blkcnt_t"));
+			blkcnt_t xv = (blkcnt_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator long (blkcnt_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator int (blkcnt_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator blkcnt_t (long v)
+		{
+			return new blkcnt_t (v);
+		}
+
+		public static explicit operator blkcnt_t (int v)
+		{
+			return new blkcnt_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (blkcnt_t lhs, blkcnt_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (blkcnt_t lhs, blkcnt_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (blkcnt_t lhs, blkcnt_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (blkcnt_t lhs, blkcnt_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl blksize_t long int
+//
+
+namespace Mono.Posix {
+
+	public struct blksize_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<blksize_t>
+#endif
+	{
+		private long value;
+
+		public blksize_t (long value)
+		{
+			this.value = value;
+		}
+
+		public blksize_t (int v)
+		{
+			this.value = checked ((long) v);
+		}
+		public long Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is blksize_t))
+				return false;
+			return ((blksize_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<blksize_t> Methods
+		//
+		public int CompareTo (blksize_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (blksize_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is blksize_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.blksize_t"));
+			blksize_t xv = (blksize_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator long (blksize_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator int (blksize_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator blksize_t (long v)
+		{
+			return new blksize_t (v);
+		}
+
+		public static explicit operator blksize_t (int v)
+		{
+			return new blksize_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (blksize_t lhs, blksize_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (blksize_t lhs, blksize_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (blksize_t lhs, blksize_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (blksize_t lhs, blksize_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl dev_t ulong long uint int
+//
+
+namespace Mono.Posix {
+
+	public struct dev_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<dev_t>
+#endif
+	{
+		private ulong value;
+
+		public dev_t (ulong value)
+		{
+			this.value = value;
+		}
+
+		public dev_t (long v)
+		{
+			this.value = checked ((ulong) v);
+		}
+
+		public dev_t (uint v)
+		{
+			this.value = checked ((ulong) v);
+		}
+
+		public dev_t (int v)
+		{
+			this.value = checked ((ulong) v);
+		}
+		public ulong Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is dev_t))
+				return false;
+			return ((dev_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<dev_t> Methods
+		//
+		public int CompareTo (dev_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (dev_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is dev_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.dev_t"));
+			dev_t xv = (dev_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator ulong (dev_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator long (dev_t v)
+		{
+			return checked ((long) v.Value);
+		}
+
+		public static implicit operator uint (dev_t v)
+		{
+			return checked ((uint) v.Value);
+		}
+
+		public static implicit operator int (dev_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator dev_t (ulong v)
+		{
+			return new dev_t (v);
+		}
+
+		public static explicit operator dev_t (long v)
+		{
+			return new dev_t (v);
+		}
+
+		public static explicit operator dev_t (uint v)
+		{
+			return new dev_t (v);
+		}
+
+		public static explicit operator dev_t (int v)
+		{
+			return new dev_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (dev_t lhs, dev_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (dev_t lhs, dev_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (dev_t lhs, dev_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (dev_t lhs, dev_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl ino_t ulong long uint int
+//
+
+namespace Mono.Posix {
+
+	public struct ino_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<ino_t>
+#endif
+	{
+		private ulong value;
+
+		public ino_t (ulong value)
+		{
+			this.value = value;
+		}
+
+		public ino_t (long v)
+		{
+			this.value = checked ((ulong) v);
+		}
+
+		public ino_t (uint v)
+		{
+			this.value = checked ((ulong) v);
+		}
+
+		public ino_t (int v)
+		{
+			this.value = checked ((ulong) v);
+		}
+		public ulong Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is ino_t))
+				return false;
+			return ((ino_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<ino_t> Methods
+		//
+		public int CompareTo (ino_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (ino_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is ino_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.ino_t"));
+			ino_t xv = (ino_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator ulong (ino_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator long (ino_t v)
+		{
+			return checked ((long) v.Value);
+		}
+
+		public static implicit operator uint (ino_t v)
+		{
+			return checked ((uint) v.Value);
+		}
+
+		public static implicit operator int (ino_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator ino_t (ulong v)
+		{
+			return new ino_t (v);
+		}
+
+		public static explicit operator ino_t (long v)
+		{
+			return new ino_t (v);
+		}
+
+		public static explicit operator ino_t (uint v)
+		{
+			return new ino_t (v);
+		}
+
+		public static explicit operator ino_t (int v)
+		{
+			return new ino_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (ino_t lhs, ino_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (ino_t lhs, ino_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (ino_t lhs, ino_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (ino_t lhs, ino_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl nlink_t ulong long uint int
+//
+
+namespace Mono.Posix {
+
+	public struct nlink_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<nlink_t>
+#endif
+	{
+		private ulong value;
+
+		public nlink_t (ulong value)
+		{
+			this.value = value;
+		}
+
+		public nlink_t (long v)
+		{
+			this.value = checked ((ulong) v);
+		}
+
+		public nlink_t (uint v)
+		{
+			this.value = checked ((ulong) v);
+		}
+
+		public nlink_t (int v)
+		{
+			this.value = checked ((ulong) v);
+		}
+		public ulong Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is nlink_t))
+				return false;
+			return ((nlink_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<nlink_t> Methods
+		//
+		public int CompareTo (nlink_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (nlink_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is nlink_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.nlink_t"));
+			nlink_t xv = (nlink_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator ulong (nlink_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator long (nlink_t v)
+		{
+			return checked ((long) v.Value);
+		}
+
+		public static implicit operator uint (nlink_t v)
+		{
+			return checked ((uint) v.Value);
+		}
+
+		public static implicit operator int (nlink_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator nlink_t (ulong v)
+		{
+			return new nlink_t (v);
+		}
+
+		public static explicit operator nlink_t (long v)
+		{
+			return new nlink_t (v);
+		}
+
+		public static explicit operator nlink_t (uint v)
+		{
+			return new nlink_t (v);
+		}
+
+		public static explicit operator nlink_t (int v)
+		{
+			return new nlink_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (nlink_t lhs, nlink_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (nlink_t lhs, nlink_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (nlink_t lhs, nlink_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (nlink_t lhs, nlink_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl off_t long int
+//
+
+namespace Mono.Posix {
+
+	public struct off_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<off_t>
+#endif
+	{
+		private long value;
+
+		public off_t (long value)
+		{
+			this.value = value;
+		}
+
+		public off_t (int v)
+		{
+			this.value = checked ((long) v);
+		}
+		public long Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is off_t))
+				return false;
+			return ((off_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<off_t> Methods
+		//
+		public int CompareTo (off_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (off_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is off_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.off_t"));
+			off_t xv = (off_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator long (off_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator int (off_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator off_t (long v)
+		{
+			return new off_t (v);
+		}
+
+		public static explicit operator off_t (int v)
+		{
+			return new off_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (off_t lhs, off_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (off_t lhs, off_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (off_t lhs, off_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (off_t lhs, off_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl size_t ulong long uint int
+//
+
+namespace Mono.Posix {
+
+	public struct size_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<size_t>
+#endif
+	{
+		private ulong value;
+
+		public size_t (ulong value)
+		{
+			this.value = value;
+		}
+
+		public size_t (long v)
+		{
+			this.value = checked ((ulong) v);
+		}
+
+		public size_t (uint v)
+		{
+			this.value = checked ((ulong) v);
+		}
+
+		public size_t (int v)
+		{
+			this.value = checked ((ulong) v);
+		}
+		public ulong Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is size_t))
+				return false;
+			return ((size_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<size_t> Methods
+		//
+		public int CompareTo (size_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (size_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is size_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.size_t"));
+			size_t xv = (size_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator ulong (size_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator long (size_t v)
+		{
+			return checked ((long) v.Value);
+		}
+
+		public static implicit operator uint (size_t v)
+		{
+			return checked ((uint) v.Value);
+		}
+
+		public static implicit operator int (size_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator size_t (ulong v)
+		{
+			return new size_t (v);
+		}
+
+		public static explicit operator size_t (long v)
+		{
+			return new size_t (v);
+		}
+
+		public static explicit operator size_t (uint v)
+		{
+			return new size_t (v);
+		}
+
+		public static explicit operator size_t (int v)
+		{
+			return new size_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (size_t lhs, size_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (size_t lhs, size_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (size_t lhs, size_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (size_t lhs, size_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl ssize_t long int
+//
+
+namespace Mono.Posix {
+
+	public struct ssize_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<ssize_t>
+#endif
+	{
+		private long value;
+
+		public ssize_t (long value)
+		{
+			this.value = value;
+		}
+
+		public ssize_t (int v)
+		{
+			this.value = checked ((long) v);
+		}
+		public long Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is ssize_t))
+				return false;
+			return ((ssize_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<ssize_t> Methods
+		//
+		public int CompareTo (ssize_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (ssize_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is ssize_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.ssize_t"));
+			ssize_t xv = (ssize_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator long (ssize_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator int (ssize_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator ssize_t (long v)
+		{
+			return new ssize_t (v);
+		}
+
+		public static explicit operator ssize_t (int v)
+		{
+			return new ssize_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (ssize_t lhs, ssize_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (ssize_t lhs, ssize_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (ssize_t lhs, ssize_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (ssize_t lhs, ssize_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl pid_t int 
+//
+
+namespace Mono.Posix {
+
+	public struct pid_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<pid_t>
+#endif
+	{
+		private int value;
+
+		public pid_t (int value)
+		{
+			this.value = value;
+		}
+		public int Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is pid_t))
+				return false;
+			return ((pid_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<pid_t> Methods
+		//
+		public int CompareTo (pid_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (pid_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is pid_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.pid_t"));
+			pid_t xv = (pid_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator int (pid_t v)
+		{
+			return v.Value;
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator pid_t (int v)
+		{
+			return new pid_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (pid_t lhs, pid_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (pid_t lhs, pid_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (pid_t lhs, pid_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (pid_t lhs, pid_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl gid_t uint int
+//
+
+namespace Mono.Posix {
+
+	public struct gid_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<gid_t>
+#endif
+	{
+		private uint value;
+
+		public gid_t (uint value)
+		{
+			this.value = value;
+		}
+
+		public gid_t (int v)
+		{
+			this.value = checked ((uint) v);
+		}
+		public uint Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is gid_t))
+				return false;
+			return ((gid_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<gid_t> Methods
+		//
+		public int CompareTo (gid_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (gid_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is gid_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.gid_t"));
+			gid_t xv = (gid_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator uint (gid_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator int (gid_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator gid_t (uint v)
+		{
+			return new gid_t (v);
+		}
+
+		public static explicit operator gid_t (int v)
+		{
+			return new gid_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (gid_t lhs, gid_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (gid_t lhs, gid_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (gid_t lhs, gid_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (gid_t lhs, gid_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl uid_t uint int
+//
+
+namespace Mono.Posix {
+
+	public struct uid_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<uid_t>
+#endif
+	{
+		private uint value;
+
+		public uid_t (uint value)
+		{
+			this.value = value;
+		}
+
+		public uid_t (int v)
+		{
+			this.value = checked ((uint) v);
+		}
+		public uint Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is uid_t))
+				return false;
+			return ((uid_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<uid_t> Methods
+		//
+		public int CompareTo (uid_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (uid_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is uid_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.uid_t"));
+			uid_t xv = (uid_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator uint (uid_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator int (uid_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator uid_t (uint v)
+		{
+			return new uid_t (v);
+		}
+
+		public static explicit operator uid_t (int v)
+		{
+			return new uid_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (uid_t lhs, uid_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (uid_t lhs, uid_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (uid_t lhs, uid_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (uid_t lhs, uid_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
+// 
+// Generated file: DO NOT MODIFY!
+//
+// File generated by: stub-vt.pl time_t long int
+//
+
+namespace Mono.Posix {
+
+	public struct time_t 
+		: System.IFormattable, System.IConvertible, System.IComparable
+#if NET_2_0
+		, System.IComparable<time_t>
+#endif
+	{
+		private long value;
+
+		public time_t (long value)
+		{
+			this.value = value;
+		}
+
+		public time_t (int v)
+		{
+			this.value = checked ((long) v);
+		}
+		public long Value {
+			get {return this.value;}
+			set {this.value = value;}
+		}
+
+		//
+		// Base class overrides
+		// 
+
+		public override bool Equals (object o)
+		{
+			if (!(o is time_t))
+				return false;
+			return ((time_t) o).value == this.value;
+		}
+
+		public override int GetHashCode ()
+		{
+			return this.value.GetHashCode ();
+		}
+
+		public override string ToString ()
+		{
+			return this.value.ToString ();
+		}
+
+#if NET_2_0
+		//
+		// IComparable<time_t> Methods
+		//
+		public int CompareTo (time_t value)
+		{
+			return this.value.CompareTo (value.value);
+		}
+
+		public bool Equals (time_t value)
+		{
+			return this.value == value.value;
+		}
+#endif
+
+		//
+		// IComparable Methods
+		//
+		public int CompareTo (object v)
+		{
+			if (v == null)
+				return 1;
+			if (!(v is time_t))
+				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.time_t"));
+			time_t xv = (time_t) v;
+			if (value == xv.value)
+				return 0;
+			if (value > xv.value)
+				return 1;
+			return -1;
+		}
+
+		//
+		// IFormattable Methods
+		//
+		public string ToString (System.IFormatProvider fp)
+		{
+			return this.value.ToString (fp);
+		}
+
+		public string ToString (string format)
+		{
+			return this.value.ToString (format);
+		}
+
+		public string ToString (string format, System.IFormatProvider fp)
+		{
+			return this.value.ToString (format, fp);
+		}
+
+		//
+		// IConvertible Methods
+		//
+		public System.TypeCode GetTypeCode ()
+		{
+			return this.value.GetTypeCode ();
+		}
+
+		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
+		{
+			System.IConvertible c = this.value;
+			return c.ToType (conversionType, provider);
+		}
+
+		ulong System.IConvertible.ToUInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt64 (this.value, provider);
+		}
+
+		double System.IConvertible.ToDouble (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDouble (this.value, provider);
+		}
+
+		short System.IConvertible.ToInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt16 (this.value, provider);
+		}
+
+		uint System.IConvertible.ToUInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt32 (this.value, provider);
+		}
+
+		ushort System.IConvertible.ToUInt16 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToUInt16 (this.value, provider);
+		}
+
+		char System.IConvertible.ToChar (System.IFormatProvider provider)
+		{
+			return System.Convert.ToChar (this.value, provider);
+		}
+
+		decimal System.IConvertible.ToDecimal (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDecimal (this.value, provider);
+		}
+
+		long System.IConvertible.ToInt64 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt64 (this.value, provider);
+		}
+
+		byte System.IConvertible.ToByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToByte (this.value, provider);
+		}
+
+		System.DateTime System.IConvertible.ToDateTime (System.IFormatProvider provider)
+		{
+			return System.Convert.ToDateTime (this.value, provider);
+		}
+
+		sbyte System.IConvertible.ToSByte (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSByte (this.value, provider);
+		}
+
+		float System.IConvertible.ToSingle (System.IFormatProvider provider)
+		{
+			return System.Convert.ToSingle (this.value, provider);
+		}
+
+		bool System.IConvertible.ToBoolean (System.IFormatProvider provider)
+		{
+			return System.Convert.ToBoolean (this.value, provider);
+		}
+
+		int System.IConvertible.ToInt32 (System.IFormatProvider provider)
+		{
+			return System.Convert.ToInt32 (this.value, provider);
+		}
+
+		//
+		// Implicit Operators
+		//
+		public static implicit operator long (time_t v)
+		{
+			return v.Value;
+		}
+
+		public static implicit operator int (time_t v)
+		{
+			return checked ((int) v.Value);
+		}
+
+		//
+		// Explicit Operators
+		//
+		public static explicit operator time_t (long v)
+		{
+			return new time_t (v);
+		}
+
+		public static explicit operator time_t (int v)
+		{
+			return new time_t (v);
+		}
+
+		//
+		// Operator Overloading
+		//
+		public static bool operator == (time_t lhs, time_t rhs)
+		{
+			return lhs.value == rhs.value;
+		}
+
+		public static bool operator != (time_t lhs, time_t rhs)
+		{
+			return lhs.value != rhs.value;
+		}
+
+		public static bool operator < (time_t lhs, time_t rhs)
+		{
+			return lhs.value < rhs.value;
+		}
+
+		public static bool operator > (time_t lhs, time_t rhs)
+		{
+			return lhs.value > rhs.value;
+		}
+	}
+}
+
