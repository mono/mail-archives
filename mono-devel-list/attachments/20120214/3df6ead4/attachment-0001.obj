//  
//  	Authors
//  		Jonathan Shore
//  
//  	Copyright:
//  		2012 Genetic Finance LLC 
//  		2002 Systematic Trading LLC
//  
//  		This software is only to be used for the purpose for which
//  		it has been provided.  No part of it is to be reproduced,
//  		disassembled, transmitted, stored in a retrieval system nor
//  		translated in any human or computer language in any way or
//  		for any other purposes whatsoever without the prior written
//  		consent of Genetic Finance LLC and Systematic Trading LLC
// 
//  
// 
using System;
using System.Reflection.Emit;
using System.Diagnostics;

namespace InlineCompiler
{
	class MainClass
	{
		
		private static Func<double,double> GetFunctionA ()
		{
			DynamicMethod squareit = new DynamicMethod ("SquareIt", typeof(double), new Type[] { typeof(double) });
			ILGenerator il = squareit.GetILGenerator();
			il.Emit (OpCodes.Ldarg_0);
			il.Emit (OpCodes.Dup);
			il.Emit (OpCodes.Mul);
			il.Emit (OpCodes.Ret);
			
			return (Func<double,double>)squareit.CreateDelegate (typeof (Func<double,double>));
		}
		
		private static Func<double,double> GetFunctionB ()
		{
			return _f;
		}
		
		private static void TestA (int iter1, int iter2)
		{
			Stopwatch watch = new Stopwatch ();
			watch.Start();
			
			double sum = 0;
			for (int i = 0 ; i < iter1 ; i++)
			{
				var f = GetFunctionA ();
				for (int j = 0 ; j < iter2 ; j++)
					sum += f(i);
			}
			
			watch.Stop();
			Console.WriteLine ("A: sum: " + sum + ", elapsed: " + watch.Elapsed);
		}
		
		private static void TestB (int iter1, int iter2)
		{
			Stopwatch watch = new Stopwatch ();
			watch.Start();
			
			double sum = 0;
			for (int i = 0 ; i < iter1 ; i++)
			{
				var f = GetFunctionB ();
				for (int j = 0 ; j < iter2 ; j++)
					sum += f(i);
			}
			
			watch.Stop();
			Console.WriteLine ("B: sum: " + sum + ", elapsed: " + watch.Elapsed);
		}
		
		
		public static void Main (string[] args)
		{
			TestA (1, 1000000000);
			TestB (1, 1000000000);
		}
		
		
		// Variables
		
		static Func<double,double> _f = (v) => v*v;
	}
}
