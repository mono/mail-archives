Index: mono/mono/metadata/class.c
===================================================================
--- mono/mono/metadata/class.c	(revision 71046)
+++ mono/mono/metadata/class.c	(working copy)
@@ -2751,6 +2751,7 @@
 	if (!MONO_CLASS_IS_INTERFACE (class)) {
 		/* Imported COM Objects always derive from __ComObject. */
 		if (MONO_CLASS_IS_IMPORT (class)) {
+			mono_init_com_types ();
 			if (parent == mono_defaults.object_class)
 				parent = mono_defaults.com_object_class;
 		}
Index: mono/mono/metadata/domain.c
===================================================================
--- mono/mono/metadata/domain.c	(revision 71046)
+++ mono/mono/metadata/domain.c	(working copy)
@@ -811,18 +811,16 @@
 	mono_defaults.internals_visible_class = mono_class_from_name (
 	        mono_defaults.corlib, "System.Runtime.CompilerServices", "InternalsVisibleToAttribute");
 
-	mono_defaults.variant_class = mono_class_from_name (
-	        mono_defaults.corlib, "System", "Variant");
-
-	mono_defaults.com_object_class = mono_class_from_name (
-	        mono_defaults.corlib, "System", "__ComObject");
-
-	mono_defaults.com_interop_proxy_class = mono_class_from_name (
-	        mono_defaults.corlib, "Mono.Interop", "ComInteropProxy");
-
 	mono_defaults.safehandle_class = mono_class_from_name (
 		mono_defaults.corlib, "System.Runtime.InteropServices", "SafeHandle");
 
+	/* these are initialized lazily when COM features are used */
+	mono_defaults.variant_class = NULL;
+	mono_defaults.com_object_class = NULL;
+	mono_defaults.com_interop_proxy_class = NULL;
+	mono_defaults.iunknown_class = NULL;
+	mono_defaults.idispatch_class = NULL;
+
 	/*
 	 * Note that mono_defaults.generic_*_class is only non-NULL if we're
 	 * using the 2.0 corlib.
@@ -889,6 +887,46 @@
 }
 
 /**
+ * mono_init_com_types:
+ *
+ * Initializes all types needed for COM Interop in mono_defaults structure. 
+ */
+void 
+mono_init_com_types (void)
+{
+	static gboolean initialized = FALSE;
+
+	if (initialized)
+		return;
+	
+	/* FIXME: do I need some threading protection here */
+
+	g_assert (mono_defaults.corlib);
+
+	mono_defaults.variant_class = mono_class_from_name (
+	        mono_defaults.corlib, "System", "Variant");
+	g_assert (mono_defaults.variant_class != 0);
+
+	mono_defaults.com_object_class = mono_class_from_name (
+	        mono_defaults.corlib, "System", "__ComObject");
+	g_assert (mono_defaults.com_object_class != 0);
+
+	mono_defaults.com_interop_proxy_class = mono_class_from_name (
+	        mono_defaults.corlib, "Mono.Interop", "ComInteropProxy");
+	g_assert (mono_defaults.com_interop_proxy_class != 0);
+
+	mono_defaults.iunknown_class = mono_class_from_name (
+	        mono_defaults.corlib, "Mono.Interop", "IUnknown");
+	g_assert (mono_defaults.iunknown_class != 0);
+
+	mono_defaults.idispatch_class = mono_class_from_name (
+	        mono_defaults.corlib, "Mono.Interop", "IDispatch");
+	g_assert (mono_defaults.idispatch_class != 0);
+
+	initialized = TRUE;
+}
+
+/**
  * mono_cleanup:
  *
  * Cleans up all metadata modules. 
Index: mono/mono/metadata/ChangeLog
===================================================================
--- mono/mono/metadata/ChangeLog	(revision 71046)
+++ mono/mono/metadata/ChangeLog	(working copy)
@@ -1,4 +1,11 @@
+2007-01-15  Jonathan Chambers  <joncham@gmail.com>
 
+	* domain.c, domain-internals.h (mono_init_com_types): Add
+	mono_init_com_types function for lazy COM initialization.
+	* class-internals.h: Added iunknown_class and idispatch_class
+	to MonoDefaults struct.
+	* class.c, object.c, marshal.c: Support lazy COM initialization.
+
 Mon Jan 15 10:27:31 CET 2007 Paolo Molaro <lupus@ximian.com>
 
 	* reflection.c: align fields rva data so it's faster to load at
Index: mono/mono/metadata/object.c
===================================================================
--- mono/mono/metadata/object.c	(revision 71046)
+++ mono/mono/metadata/object.c	(working copy)
@@ -1493,7 +1493,7 @@
 		MonoClass *klass;
 		type = ((MonoReflectionType *)rp->class_to_proxy)->type;
 		klass = mono_class_from_mono_type (type);
-		if ((klass->is_com_object || klass == mono_defaults.com_object_class) && !mono_class_vtable (mono_domain_get (), klass)->remote)
+		if ((klass->is_com_object || (mono_defaults.com_object_class && klass == mono_defaults.com_object_class)) && !mono_class_vtable (mono_domain_get (), klass)->remote)
 			remote_class->default_vtable = mono_class_proxy_vtable (domain, remote_class, MONO_REMOTING_TARGET_COMINTEROP);
 		else
 			remote_class->default_vtable = mono_class_proxy_vtable (domain, remote_class, MONO_REMOTING_TARGET_UNKNOWN);
Index: mono/mono/metadata/class-internals.h
===================================================================
--- mono/mono/metadata/class-internals.h	(revision 71046)
+++ mono/mono/metadata/class-internals.h	(working copy)
@@ -689,6 +689,8 @@
 	MonoClass *variant_class;
 	MonoClass *com_object_class;
 	MonoClass *com_interop_proxy_class;
+	MonoClass *iunknown_class;
+	MonoClass *idispatch_class;
 	MonoClass *safehandle_class;
 } MonoDefaults;
 
Index: mono/mono/metadata/domain-internals.h
===================================================================
--- mono/mono/metadata/domain-internals.h	(revision 71046)
+++ mono/mono/metadata/domain-internals.h	(working copy)
@@ -161,6 +161,9 @@
 #define mono_domain_assemblies_unlock(domain) LeaveCriticalSection(&(domain)->assemblies_lock)
 
 void 
+mono_init_com_types (void) MONO_INTERNAL;
+
+void 
 mono_cleanup (void) MONO_INTERNAL;
 
 void
Index: mono/mono/metadata/marshal.c
===================================================================
--- mono/mono/metadata/marshal.c	(revision 71046)
+++ mono/mono/metadata/marshal.c	(working copy)
@@ -293,6 +293,9 @@
 {
 	MonoClass *klass = NULL;
 	MonoRealProxy* real_proxy = NULL;
+
+	mono_init_com_types ();
+
 	if (!obj)
 		return FALSE;
 	klass = mono_object_class (obj);
@@ -1823,8 +1826,12 @@
 		static MonoMethod* get_transparent_proxy = NULL;
 		int real_proxy;
 		guint32 pos_failed = 0;
-		MonoClass *klass = mono_class_from_mono_type (type);
+		MonoClass *klass = NULL;
+		
+		mono_init_com_types ();
 
+		klass = mono_class_from_mono_type (type);
+
 		mono_mb_emit_ldloc (mb, 1);
 		mono_mb_emit_byte (mb, CEE_LDNULL);
 		mono_mb_emit_byte (mb, CEE_STIND_REF);
@@ -2146,6 +2153,8 @@
 		guint32 pos_failed = 0, pos_rcw = 0;
 		char * msg;
 
+		mono_init_com_types ();
+
 		mono_mb_emit_ldloc (mb, 1);
 		//mono_mb_emit_ldloc (mb, 0);
 		mono_mb_emit_ptr (mb, 0);
@@ -2392,6 +2401,7 @@
 				break;
 			}
 			case MONO_TYPE_OBJECT: {
+				mono_init_com_types ();
 				if (to_object) {
 					static MonoMethod *variant_clear = NULL;
 					static MonoMethod *get_object_for_native_variant = NULL;
@@ -3221,6 +3231,8 @@
 	if ((res = mono_marshal_find_in_cache (cache, method)))
 		return res;
 
+	mono_init_com_types ();
+
 	sig = mono_method_signature (method);
 	mb = mono_mb_new (method->klass, method->name, MONO_WRAPPER_COMINTEROP);
 
@@ -3331,6 +3343,8 @@
 	if ((res = mono_marshal_find_in_cache (cache, method)))
 		return res;
 
+	mono_init_com_types ();
+
 	sig = signature_no_pinvoke (method);
 
 	/* we cant remote methods without this pointer */
@@ -3403,7 +3417,7 @@
 		return method;
 
 	/* this seems to be the best plase to put this, as all remoting invokes seem to get filtered through here */
-	if ((method->klass->is_com_object || method->klass == mono_defaults.com_object_class) && !mono_class_vtable (mono_domain_get (), method->klass)->remote)
+	if ((method->klass->is_com_object || (mono_defaults.com_object_class && method->klass == mono_defaults.com_object_class)) && !mono_class_vtable (mono_domain_get (), method->klass)->remote)
 		return cominterop_get_invoke(method);
 
 	sig = signature_no_pinvoke (method);
@@ -6621,6 +6635,8 @@
 	MonoMethodBuilder *mb = m->mb;
 	MonoClass *klass = t->data.klass;
 
+	mono_init_com_types ();
+
 	switch (action) {
 	case MARSHAL_ACTION_CONV_IN: {
 		*conv_arg_type = &mono_defaults.int_class->byval_arg;
@@ -6792,6 +6808,8 @@
 	static MonoMethod *get_object_for_native_variant = NULL;
 	static MonoMethod *get_native_variant_for_object = NULL;
 	
+	mono_init_com_types ();
+
 	if (!get_object_for_native_variant)
 		get_object_for_native_variant = mono_class_get_method_from_name (mono_defaults.marshal_class, "GetObjectForNativeVariant", 1);
 	g_assert (get_object_for_native_variant);