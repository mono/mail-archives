Index: mcs/class/corlib/Mono.Interop/ChangeLog
===================================================================
--- mcs/class/corlib/Mono.Interop/ChangeLog	(revision 68057)
+++ mcs/class/corlib/Mono.Interop/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2006-10-18  Jonathan Chambers  <joncham@gmail.com>
+
+	* IUnknown.cs: Added.
+	* IDispatch.cs: Added.
+
 2006-08-10  Jonathan Chambers  <joncham@gmail.com>
 
 	* ComInteropProxy.cs: Fix default constructor being always
Index: mcs/class/corlib/Mono.Interop/IDispatch.cs
===================================================================
--- mcs/class/corlib/Mono.Interop/IDispatch.cs	(revision 0)
+++ mcs/class/corlib/Mono.Interop/IDispatch.cs	(revision 0)
@@ -0,0 +1,41 @@
+//
+// Mono.Interop.IDispatch
+//
+// Authors:
+//   Jonathan Chambers <joncham@gmail.com>
+//
+// Copyright (C) 2006 Jonathan Chambers
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Runtime.InteropServices;
+
+
+namespace Mono.Interop
+{
+	[Guid ("00020400-0000-0000-C000-000000000046")]
+	internal interface IDispatch
+	{
+	}
+}
Index: mcs/class/corlib/Mono.Interop/IUnknown.cs
===================================================================
--- mcs/class/corlib/Mono.Interop/IUnknown.cs	(revision 0)
+++ mcs/class/corlib/Mono.Interop/IUnknown.cs	(revision 0)
@@ -0,0 +1,41 @@
+//
+// Mono.Interop.IUnknown
+//
+// Authors:
+//   Jonathan Chambers <joncham@gmail.com>
+//
+// Copyright (C) 2006 Jonathan Chambers
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Runtime.InteropServices;
+
+
+namespace Mono.Interop
+{
+	[Guid ("00000000-0000-0000-C000-000000000046")]
+	internal interface IUnknown
+	{
+	}
+}
Index: mcs/class/corlib/corlib.dll.sources
===================================================================
--- mcs/class/corlib/corlib.dll.sources	(revision 68057)
+++ mcs/class/corlib/corlib.dll.sources	(working copy)
@@ -22,6 +22,8 @@
 Mono.Globalization.Unicode/NormalizationTableUtil.cs
 Mono/Runtime.cs
 Mono.Interop/ComInteropProxy.cs
+Mono.Interop/IDispatch.cs
+Mono.Interop/IUnknown.cs
 Mono.Math/BigInteger.cs
 Mono.Math.Prime/ConfidenceFactor.cs
 Mono.Math.Prime/PrimalityTests.cs
Index: mcs/class/corlib/System/ChangeLog
===================================================================
--- mcs/class/corlib/System/ChangeLog	(revision 68057)
+++ mcs/class/corlib/System/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2006-11-18  Jonathan Chambers  <joncham@gmail.com>
+
+	* __ComObject.cs: Remove IDispatchMono.
+	
 2006-11-14  Miguel de Icaza  <miguel@novell.com>
 
 	* Array.cs: TODOs will from now on be used to flag information
Index: mcs/class/corlib/System/__ComObject.cs
===================================================================
--- mcs/class/corlib/System/__ComObject.cs	(revision 68057)
+++ mcs/class/corlib/System/__ComObject.cs	(working copy)
@@ -188,7 +188,7 @@
 		{
 			get
 			{
-				IntPtr pUnk = GetInterface (typeof (IDispatchMono));
+				IntPtr pUnk = GetInterface (typeof (IDispatch));
 				if (pUnk == IntPtr.Zero)
 					throw new InvalidComObjectException ("COM object that has been separated from its underlying RCW cannot be used.");
 				return pUnk;
@@ -211,11 +211,6 @@
 			}
 		}
 
-		[Guid ("00020400-0000-0000-C000-000000000046")]
-		internal interface IDispatchMono
-		{
-		}
-
 		public override bool Equals (object obj)
 		{
 			if (obj == null)
Index: mcs/class/corlib/ChangeLog
===================================================================
--- mcs/class/corlib/ChangeLog	(revision 68057)
+++ mcs/class/corlib/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2006-11-18  Jonathan Chambers  <joncham@gmail.com>
+
+	* corlib.dll.sources: Added Mono.Interop/IUnknown.cs
+	and Mono.Interop/IDispatch.cs.
+	
 2006-11-01  Sebastien Pouliot  <sebastien@ximian.com> 
 
 	* corlib_test.dll.sources: Added unit tests and CAS tests for 
Index: mono/mono/metadata/ChangeLog
===================================================================
--- mono/mono/metadata/ChangeLog	(revision 68057)
+++ mono/mono/metadata/ChangeLog	(working copy)
@@ -1,3 +1,13 @@
+2006-11-18  Jonathan Chambers  <joncham@gmail.com>
+  
+	* marshal.c: 
+		(mono_marshal_emit_managed_wrapper): Level of indirection for 
+		mono_marshal_get_managed_wrapper so that a wrapper for a managed method
+		can be generated without a delegate class.
+		(mono_marshal_get_managed_wrapper): Move wrapper logic to mono_marshal_emit_managed_wrapper.
+	
+	Signed-off-by: Jonathan Chambers <joncham@gmail.com>
+
 2006-11-13  Dick Porter  <dick@ximian.com>
 
 	* file-io.c (get_file_attributes): If the file is a symlink try
Index: mono/mono/metadata/marshal.c
===================================================================
--- mono/mono/metadata/marshal.c	(revision 68057)
+++ mono/mono/metadata/marshal.c	(working copy)
@@ -7710,45 +7710,17 @@
 
 	return res;
 }
-			     
-/*
- * generates IL code to call managed methods from unmanaged code 
- */
-MonoMethod *
-mono_marshal_get_managed_wrapper (MonoMethod *method, MonoClass *delegate_klass, MonoObject *this)
+			    
+/* FIXME: moving GC */
+static void
+mono_marshal_emit_managed_wrapper (MonoMethodBuilder *mb, MonoMethodSignature *invoke_sig, MonoMarshalSpec **mspecs, EmitMarshalContext* m, MonoMethod *method, MonoObject* this)
 {
-	static MonoClass *UnmanagedFunctionPointerAttribute;
-	MonoMethodSignature *sig, *csig, *invoke_sig;
-	MonoMethodBuilder *mb;
-	MonoMethod *res, *invoke;
-	MonoMarshalSpec **mspecs;
-	MonoMethodPInvoke piinfo;
-	GHashTable *cache;
+	MonoMethodSignature *sig, *csig;
 	int i, *tmp_locals;
-	EmitMarshalContext m;
 
-	g_assert (method != NULL);
-	g_assert (!mono_method_signature (method)->pinvoke);
+	sig = m->sig;
+	csig = m->csig;
 
-	/* 
-	 * FIXME: Should cache the method+delegate type pair, since the same method
-	 * could be called with different delegates, thus different marshalling
-	 * options.
-	 */
-	cache = method->klass->image->managed_wrapper_cache;
-	if (!this && (res = mono_marshal_find_in_cache (cache, method)))
-		return res;
-
-	invoke = mono_class_get_method_from_name (delegate_klass, "Invoke", mono_method_signature (method)->param_count);
-	invoke_sig = mono_method_signature (invoke);
-
-	mspecs = g_new0 (MonoMarshalSpec*, mono_method_signature (invoke)->param_count + 1);
-	mono_method_get_marshal_info (invoke, mspecs);
-
-	sig = mono_method_signature (method);
-
-	mb = mono_mb_new (method->klass, method->name, MONO_WRAPPER_NATIVE_TO_MANAGED);
-
 	/* allocate local 0 (pointer) src_ptr */
 	mono_mb_add_local (mb, &mono_defaults.int_class->byval_arg);
 	/* allocate local 1 (pointer) dst_ptr */
@@ -7764,73 +7736,6 @@
 	mono_mb_emit_icon (mb, 0);
 	mono_mb_emit_stloc (mb, 2);
 
-	/* we copy the signature, so that we can modify it */
-	csig = signature_dup (method->klass->image, sig);
-	csig->hasthis = 0;
-	csig->pinvoke = 1;
-
-	m.mb = mb;
-	m.sig = sig;
-	m.piinfo = NULL;
-	m.retobj_var = 0;
-	m.csig = csig;
-	m.image = method->klass->image;
-
-#ifdef PLATFORM_WIN32
-	/* 
-	 * Under windows, delegates passed to native code must use the STDCALL
-	 * calling convention.
-	 */
-	csig->call_convention = MONO_CALL_STDCALL;
-#endif
-
-	/* Change default calling convention if needed */
-	/* Why is this a modopt ? */
-	if (invoke_sig->ret && invoke_sig->ret->num_mods) {
-		for (i = 0; i < invoke_sig->ret->num_mods; ++i) {
-			MonoClass *cmod_class = mono_class_get (delegate_klass->image, invoke_sig->ret->modifiers [i].token);
-			g_assert (cmod_class);
-			if ((cmod_class->image == mono_defaults.corlib) && !strcmp (cmod_class->name_space, "System.Runtime.CompilerServices")) {
-				if (!strcmp (cmod_class->name, "CallConvCdecl"))
-					csig->call_convention = MONO_CALL_C;
-				else if (!strcmp (cmod_class->name, "CallConvStdcall"))
-					csig->call_convention = MONO_CALL_STDCALL;
-				else if (!strcmp (cmod_class->name, "CallConvFastcall"))
-					csig->call_convention = MONO_CALL_FASTCALL;
-				else if (!strcmp (cmod_class->name, "CallConvThiscall"))
-					csig->call_convention = MONO_CALL_THISCALL;
-			}
-		}
-	}
-
-	/* Handle the UnmanagedFunctionPointerAttribute */
-	if (!UnmanagedFunctionPointerAttribute)
-		UnmanagedFunctionPointerAttribute = mono_class_from_name (mono_defaults.corlib, "System.Runtime.InteropServices", "UnmanagedFunctionPointerAttribute");
-
-	/* The attribute is only available in Net 2.0 */
-	if (UnmanagedFunctionPointerAttribute) {
-		MonoReflectionUnmanagedFunctionPointerAttribute *attr;
-		MonoCustomAttrInfo *cinfo;
-
-		/* 
-		 * The pinvoke attributes are stored in a real custom attribute so we have to
-		 * construct it.
-		 */
-		cinfo = mono_custom_attrs_from_class (delegate_klass);
-		if (cinfo) {
-			attr = (MonoReflectionUnmanagedFunctionPointerAttribute*)mono_custom_attrs_get_attr (cinfo, UnmanagedFunctionPointerAttribute);
-			if (attr) {
-				memset (&piinfo, 0, sizeof (piinfo));
-				m.piinfo = &piinfo;
-				piinfo.piflags = (attr->call_conv << 8) | (attr->charset ? (attr->charset - 1) * 2 : 1) | attr->set_last_error;
-
-				csig->call_convention = attr->call_conv - 1;
-			}
-			if (!cinfo->cached)
-				mono_custom_attrs_free (cinfo);
-		}
-	}
-
 	/* fixme: howto handle this ? */
 	if (sig->hasthis) {
 		if (this) {
@@ -7854,7 +7759,7 @@
 		case MONO_TYPE_ARRAY:
 		case MONO_TYPE_SZARRAY:
 		case MONO_TYPE_STRING:
-			tmp_locals [i] = emit_marshal (&m, i, sig->params [i], mspecs [i + 1], 0, &csig->params [i], MARSHAL_ACTION_MANAGED_CONV_IN);
+			tmp_locals [i] = emit_marshal (m, i, sig->params [i], mspecs [i + 1], 0, &csig->params [i], MARSHAL_ACTION_MANAGED_CONV_IN);
 
 			break;
 		default:
@@ -7881,7 +7786,7 @@
 	mono_mb_emit_managed_call (mb, method, NULL);
 
 	if (mspecs [0] && mspecs [0]->native == MONO_NATIVE_CUSTOM) {
-		emit_marshal (&m, 0, sig->ret, mspecs [0], 0, NULL, MARSHAL_ACTION_MANAGED_CONV_RESULT);
+		emit_marshal (m, 0, sig->ret, mspecs [0], 0, NULL, MARSHAL_ACTION_MANAGED_CONV_RESULT);
 	}
 	else
 	if (!sig->ret->byref) { 
@@ -7907,12 +7812,12 @@
 			break;
 		case MONO_TYPE_STRING:
 			csig->ret = &mono_defaults.int_class->byval_arg;
-			emit_marshal (&m, 0, sig->ret, mspecs [0], 0, NULL, MARSHAL_ACTION_MANAGED_CONV_RESULT);
+			emit_marshal (m, 0, sig->ret, mspecs [0], 0, NULL, MARSHAL_ACTION_MANAGED_CONV_RESULT);
 			break;
 		case MONO_TYPE_VALUETYPE:
 		case MONO_TYPE_CLASS:
 		case MONO_TYPE_SZARRAY:
-			emit_marshal (&m, 0, sig->ret, mspecs [0], 0, NULL, MARSHAL_ACTION_MANAGED_CONV_RESULT);
+			emit_marshal (m, 0, sig->ret, mspecs [0], 0, NULL, MARSHAL_ACTION_MANAGED_CONV_RESULT);
 			break;
 		default:
 			g_warning ("return type 0x%02x unknown", sig->ret->type);	
@@ -7928,13 +7833,13 @@
 		MonoMarshalSpec *spec = mspecs [i + 1];
 
 		if (spec && spec->native == MONO_NATIVE_CUSTOM) {
-			emit_marshal (&m, i, t, mspecs [i + 1], tmp_locals [i], NULL, MARSHAL_ACTION_MANAGED_CONV_OUT);
+			emit_marshal (m, i, t, mspecs [i + 1], tmp_locals [i], NULL, MARSHAL_ACTION_MANAGED_CONV_OUT);
 		}
 		else if (t->byref) {
 			switch (t->type) {
 			case MONO_TYPE_CLASS:
 			case MONO_TYPE_VALUETYPE:
-				emit_marshal (&m, i, t, mspecs [i + 1], tmp_locals [i], NULL, MARSHAL_ACTION_MANAGED_CONV_OUT);
+				emit_marshal (m, i, t, mspecs [i + 1], tmp_locals [i], NULL, MARSHAL_ACTION_MANAGED_CONV_OUT);
 				break;
 			}
 		}
@@ -7944,7 +7849,7 @@
 			case MONO_TYPE_SZARRAY:
 			case MONO_TYPE_CLASS:
 			case MONO_TYPE_VALUETYPE:
-				emit_marshal (&m, i, invoke_sig->params [i], mspecs [i + 1], tmp_locals [i], NULL, MARSHAL_ACTION_MANAGED_CONV_OUT);
+				emit_marshal (m, i, invoke_sig->params [i], mspecs [i + 1], tmp_locals [i], NULL, MARSHAL_ACTION_MANAGED_CONV_OUT);
 				break;
 			default:
 				g_assert_not_reached ();
@@ -7952,17 +7857,127 @@
 		}
 	}
 
-	if (m.retobj_var) {
-		mono_mb_emit_ldloc (mb, m.retobj_var);
+	if (m->retobj_var) {
+		mono_mb_emit_ldloc (mb, m->retobj_var);
 		mono_mb_emit_byte (mb, MONO_CUSTOM_PREFIX);
-		mono_mb_emit_op (mb, CEE_MONO_RETOBJ, m.retobj_class);
+		mono_mb_emit_op (mb, CEE_MONO_RETOBJ, m->retobj_class);
 	}
 	else {
 		if (!MONO_TYPE_IS_VOID(sig->ret))
 			mono_mb_emit_ldloc (mb, 3);
 		mono_mb_emit_byte (mb, CEE_RET);
 	}
+}
 
+
+/*
+ * generates IL code to call managed methods from unmanaged code 
+ */
+MonoMethod *
+mono_marshal_get_managed_wrapper (MonoMethod *method, MonoClass *delegate_klass, MonoObject *this)
+{
+	static MonoClass *UnmanagedFunctionPointerAttribute;
+	MonoMethodSignature *sig, *csig, *invoke_sig;
+	MonoMethodBuilder *mb;
+	MonoMethod *res, *invoke;
+	MonoMarshalSpec **mspecs;
+	MonoMethodPInvoke piinfo;
+	GHashTable *cache;
+	int i;
+	EmitMarshalContext m;
+
+	g_assert (method != NULL);
+	g_assert (!mono_method_signature (method)->pinvoke);
+
+	/* 
+	 * FIXME: Should cache the method+delegate type pair, since the same method
+	 * could be called with different delegates, thus different marshalling
+	 * options.
+	 */
+	cache = method->klass->image->managed_wrapper_cache;
+	if (!this && (res = mono_marshal_find_in_cache (cache, method)))
+		return res;
+
+	invoke = mono_class_get_method_from_name (delegate_klass, "Invoke", mono_method_signature (method)->param_count);
+	invoke_sig = mono_method_signature (invoke);
+
+	mspecs = g_new0 (MonoMarshalSpec*, mono_method_signature (invoke)->param_count + 1);
+	mono_method_get_marshal_info (invoke, mspecs);
+
+	sig = mono_method_signature (method);
+
+	mb = mono_mb_new (method->klass, method->name, MONO_WRAPPER_NATIVE_TO_MANAGED);
+
+
+	/* we copy the signature, so that we can modify it */
+	csig = signature_dup (method->klass->image, sig);
+	csig->hasthis = 0;
+	csig->pinvoke = 1;
+
+	m.mb = mb;
+	m.sig = sig;
+	m.piinfo = NULL;
+	m.retobj_var = 0;
+	m.csig = csig;
+	m.image = method->klass->image;
+
+#ifdef PLATFORM_WIN32
+	/* 
+	 * Under windows, delegates passed to native code must use the STDCALL
+	 * calling convention.
+	 */
+	csig->call_convention = MONO_CALL_STDCALL;
+#endif
+
+	/* Change default calling convention if needed */
+	/* Why is this a modopt ? */
+	if (invoke_sig->ret && invoke_sig->ret->num_mods) {
+		for (i = 0; i < invoke_sig->ret->num_mods; ++i) {
+			MonoClass *cmod_class = mono_class_get (delegate_klass->image, invoke_sig->ret->modifiers [i].token);
+			g_assert (cmod_class);
+			if ((cmod_class->image == mono_defaults.corlib) && !strcmp (cmod_class->name_space, "System.Runtime.CompilerServices")) {
+				if (!strcmp (cmod_class->name, "CallConvCdecl"))
+					csig->call_convention = MONO_CALL_C;
+				else if (!strcmp (cmod_class->name, "CallConvStdcall"))
+					csig->call_convention = MONO_CALL_STDCALL;
+				else if (!strcmp (cmod_class->name, "CallConvFastcall"))
+					csig->call_convention = MONO_CALL_FASTCALL;
+				else if (!strcmp (cmod_class->name, "CallConvThiscall"))
+					csig->call_convention = MONO_CALL_THISCALL;
+			}
+		}
+	}
+
+	/* Handle the UnmanagedFunctionPointerAttribute */
+	if (!UnmanagedFunctionPointerAttribute)
+		UnmanagedFunctionPointerAttribute = mono_class_from_name (mono_defaults.corlib, "System.Runtime.InteropServices", "UnmanagedFunctionPointerAttribute");
+
+	/* The attribute is only available in Net 2.0 */
+	if (UnmanagedFunctionPointerAttribute) {
+		MonoReflectionUnmanagedFunctionPointerAttribute *attr;
+		MonoCustomAttrInfo *cinfo;
+
+		/* 
+		 * The pinvoke attributes are stored in a real custom attribute so we have to
+		 * construct it.
+		 */
+		cinfo = mono_custom_attrs_from_class (delegate_klass);
+		if (cinfo) {
+			attr = (MonoReflectionUnmanagedFunctionPointerAttribute*)mono_custom_attrs_get_attr (cinfo, UnmanagedFunctionPointerAttribute);
+			if (attr) {
+				memset (&piinfo, 0, sizeof (piinfo));
+				m.piinfo = &piinfo;
+				piinfo.piflags = (attr->call_conv << 8) | (attr->charset ? (attr->charset - 1) * 2 : 1) | attr->set_last_error;
+
+				csig->call_convention = attr->call_conv - 1;
+			}
+			if (!cinfo->cached)
+				mono_custom_attrs_free (cinfo);
+		}
+	}
+
+	mono_marshal_emit_managed_wrapper (mb, invoke_sig, mspecs, &m, method, this);
+
 	if (!this)
 		res = mono_mb_create_and_cache (cache, method,
 											 mb, csig, sig->param_count + 16);