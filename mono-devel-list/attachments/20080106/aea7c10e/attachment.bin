Index: System.CodeDom.Compiler/CodeGenerator.cs
===================================================================
--- System.CodeDom.Compiler/CodeGenerator.cs	(revision 92052)
+++ System.CodeDom.Compiler/CodeGenerator.cs	(working copy)
@@ -39,9 +39,77 @@
 using System.Collections;
 	
 namespace System.CodeDom.Compiler {
-
-	public abstract class CodeGenerator : ICodeGenerator
-	{
+	public abstract class CodeGenerator : ICodeGenerator {
+		// Mappings from Type to MethodInfo (e.g.
+		// from typeof (CodeArgumentReferenceExpression) to
+		// MethodInfo for GenerateArgumentReferenceExpression) 
+		private static readonly Hashtable statementMethods;
+		private static readonly Hashtable expressionMethods;
+		private static readonly Type [] expressionTypes = new Type [] {
+			typeof (CodeArgumentReferenceExpression),
+			typeof (CodeArrayCreateExpression),
+			typeof (CodeArrayIndexerExpression),
+			typeof (CodeBaseReferenceExpression),
+			typeof (CodeBinaryOperatorExpression),
+			typeof (CodeCastExpression),
+#if NET_2_0
+			typeof (CodeDefaultValueExpression),
+#endif
+			typeof (CodeDelegateCreateExpression),
+			typeof (CodeDelegateInvokeExpression),
+			typeof (CodeDirectionExpression),
+			typeof (CodeEventReferenceExpression),
+			typeof (CodeFieldReferenceExpression),
+			typeof (CodeIndexerExpression),
+			typeof (CodeMethodInvokeExpression),
+			typeof (CodeMethodReferenceExpression),
+			typeof (CodeObjectCreateExpression),
+			typeof (CodeParameterDeclarationExpression),
+			typeof (CodePrimitiveExpression),
+			typeof (CodePropertyReferenceExpression),
+			typeof (CodePropertySetValueReferenceExpression),
+			typeof (CodeSnippetExpression),
+			typeof (CodeThisReferenceExpression),
+			typeof (CodeTypeOfExpression),
+			typeof (CodeTypeReferenceExpression),
+			typeof (CodeVariableReferenceExpression)
+		};
+		private static readonly Type [] statementTypes = new Type [] {
+			typeof (CodeAssignStatement),
+			typeof (CodeAttachEventStatement),
+			typeof (CodeCommentStatement),
+			typeof (CodeConditionStatement),
+			typeof (CodeExpressionStatement),
+			typeof (CodeGotoStatement),
+			typeof (CodeIterationStatement),
+			typeof (CodeLabeledStatement),
+			typeof (CodeMethodReturnStatement),
+			typeof (CodeRemoveEventStatement),
+			typeof (CodeThrowExceptionStatement),
+			typeof (CodeTryCatchFinallyStatement),
+			typeof (CodeVariableDeclarationStatement)
+		};
+		
+		static CodeGenerator ()
+		{
+			statementMethods = CreateMethodTable (statementTypes);
+			expressionMethods = CreateMethodTable (expressionTypes);
+		}
+		
+		private static Hashtable CreateMethodTable (Type [] types)
+		{
+			Hashtable table = new Hashtable (types.Length);
+			// for each type CodeXYZ, add method "GenerateXYZ(a) to table
+			foreach (Type type in types) {
+				string methodName = type.Name.Replace ("Code", "Generate");
+				MethodInfo method = typeof (CodeGenerator).GetMethod (
+					methodName, BindingFlags.Instance | BindingFlags.NonPublic
+				);
+				table.Add (type, method);
+			}
+			return table;
+		} 	
+	
 		private IndentedTextWriter output;
 		private CodeGeneratorOptions options;
 		private CodeTypeMember currentMember;
@@ -279,129 +347,17 @@
 		{
 			if (e == null)
 				throw new ArgumentNullException ("Value cannot be null.");
+				
+			Type type = e.GetType ();
+			MethodInfo method = (MethodInfo)expressionMethods [type];
+			if (method == null)
+				throw new ArgumentException ("Element type " + type + " is not supported.");
 
-			CodeArgumentReferenceExpression argref = e as CodeArgumentReferenceExpression;
-			if (argref != null) {
-				GenerateArgumentReferenceExpression (argref);
-				return;
+			try {
+				method.Invoke (this, new object [] { e });
+			} catch (TargetInvocationException exc) {
+				throw exc.InnerException;
 			}
-			CodeArrayCreateExpression mkarray = e as CodeArrayCreateExpression;
-			if (mkarray != null) {
-				GenerateArrayCreateExpression (mkarray);
-				return;
-			}
-			CodeArrayIndexerExpression arrayidx = e as CodeArrayIndexerExpression;
-			if (arrayidx != null) {
-				GenerateArrayIndexerExpression (arrayidx);
-				return;
-			}
-			CodeBaseReferenceExpression baseref = e as CodeBaseReferenceExpression;
-			if (baseref != null) {
-				GenerateBaseReferenceExpression (baseref);
-				return;
-			}
-			CodeBinaryOperatorExpression binary = e as CodeBinaryOperatorExpression;
-			if (binary != null) {
-				GenerateBinaryOperatorExpression (binary);
-				return;
-			}
-			CodeCastExpression cast = e as CodeCastExpression;
-			if (cast != null) {
-				GenerateCastExpression (cast);
-				return;
-			}
-			CodeDelegateCreateExpression mkdel = e as CodeDelegateCreateExpression;
-			if (mkdel != null) {
-				GenerateDelegateCreateExpression (mkdel);
-				return;
-			}
-			CodeDelegateInvokeExpression delinvoke = e as CodeDelegateInvokeExpression;
-			if (delinvoke != null) {
-				GenerateDelegateInvokeExpression (delinvoke);
-				return;
-			}
-			CodeDirectionExpression direction = e as CodeDirectionExpression;
-			if (direction != null) {
-				GenerateDirectionExpression (direction);
-				return;
-			}
-			CodeEventReferenceExpression eventref = e as CodeEventReferenceExpression;
-			if ( eventref != null ) {
-				GenerateEventReferenceExpression( eventref );
-				return;
-			}
-			CodeFieldReferenceExpression fieldref = e as CodeFieldReferenceExpression;
-			if (fieldref != null) {
-				GenerateFieldReferenceExpression (fieldref);
-				return;
-			}
-			CodeIndexerExpression idx = e as CodeIndexerExpression;
-			if (idx != null) {
-				GenerateIndexerExpression (idx);
-				return;
-			}
-			CodeMethodInvokeExpression methodinv = e as CodeMethodInvokeExpression;
-			if (methodinv != null) {
-				GenerateMethodInvokeExpression (methodinv);
-				return;
-			}
-			CodeMethodReferenceExpression methodref = e as CodeMethodReferenceExpression;
-			if (methodref != null) {
-				GenerateMethodReferenceExpression (methodref);
-				return;
-			}
-			CodeObjectCreateExpression objref = e as CodeObjectCreateExpression;
-			if (objref != null) {
-				GenerateObjectCreateExpression (objref);
-				return;
-			}
-			CodeParameterDeclarationExpression param = e as CodeParameterDeclarationExpression;
-			if (param != null) {
-				GenerateParameterDeclarationExpression (param);
-				return;
-			}
-			CodePrimitiveExpression primitive = e as CodePrimitiveExpression;
-			if (primitive != null) {
-				GeneratePrimitiveExpression (primitive);
-				return;
-			}
-			CodePropertyReferenceExpression propref = e as CodePropertyReferenceExpression;
-			if (propref != null) {
-				GeneratePropertyReferenceExpression (propref);
-				return;
-			}
-			CodePropertySetValueReferenceExpression propset = e as CodePropertySetValueReferenceExpression;
-			if (propset != null) {
-				GeneratePropertySetValueReferenceExpression (propset);
-				return;
-			}
-			CodeSnippetExpression snippet = e as CodeSnippetExpression;
-			if (snippet != null) {
-				GenerateSnippetExpression (snippet);
-				return;
-			}
-			CodeThisReferenceExpression thisref = e as CodeThisReferenceExpression;
-			if (thisref != null) {
-				GenerateThisReferenceExpression (thisref);
-				return;
-			}
-			CodeTypeOfExpression typeOf = e as CodeTypeOfExpression;
-			if (typeOf != null) {
-				GenerateTypeOfExpression (typeOf);
-				return;
-			}
-			CodeTypeReferenceExpression typeref = e as CodeTypeReferenceExpression;
-			if (typeref != null) {
-				GenerateTypeReferenceExpression (typeref);
-				return;
-			}
-			CodeVariableReferenceExpression varref = e as CodeVariableReferenceExpression;
-			if (varref != null) {
-				GenerateVariableReferenceExpression (varref);
-				return;
-			}
-
-			throw new ArgumentException ("Element type " + e + " is not supported.");
 		}
 
 		protected abstract void GenerateExpressionStatement (CodeExpressionStatement statement);
@@ -478,34 +434,41 @@
 
 		protected virtual void GeneratePrimitiveExpression (CodePrimitiveExpression e)
 		{
-			if (e.Value == null) {
+			object value = e.Value;
+			if (value == null) {
 				output.Write (NullToken);
 				return;
 			}
 
-			Type type = e.Value.GetType ();
-			if (type == typeof (bool)) {
-				output.Write (e.Value.ToString ().ToLower (CultureInfo.InvariantCulture));
-			} else if (type == typeof (char)) {
-				output.Write ("'" + e.Value.ToString () + "'");
-			} else if (type == typeof (string)) {
-				output.Write (QuoteSnippetString ((string) e.Value));
-			} else if (type == typeof (float)) {
-				GenerateSingleFloatValue((float) e.Value);
-			} else if (type == typeof (double)) {
-				GenerateDoubleValue((double) e.Value);
-			} else if (type == typeof (decimal)) {
-				this.GenerateDecimalValue((decimal) e.Value);
-			} else if (type == typeof (byte) || type == typeof (short) || 
-				type == typeof (int) || type == typeof (long)) {
+			Type type = value.GetType ();
+			TypeCode typeCode = Type.GetTypeCode (type);
+			switch (typeCode) {
+			case TypeCode.Boolean:
+				output.Write (value.ToString ().ToLower (CultureInfo.InvariantCulture));
+				break;
+			case TypeCode.Char:
+				output.Write ("'" + value.ToString () + "'");
+				break;
+			case TypeCode.String:
+				output.Write (QuoteSnippetString ((string) value));
+				break;
+			case TypeCode.Single:
+				GenerateSingleFloatValue ((float) value);
+				break;
+			case TypeCode.Double:
+				GenerateDoubleValue ((double) value);
+				break;
+			case TypeCode.Decimal:
+				GenerateDecimalValue ((decimal) value);
+				break;
+			case TypeCode.Byte:
+			case TypeCode.Int16:
+			case TypeCode.Int32:
+			case TypeCode.Int64:
 				// All of these should be IFormatable, I am just being safe/slow 
-				IFormattable formattable = e.Value as IFormattable;
-				if (formattable != null) {
-					output.Write (formattable.ToString (null, CultureInfo.InvariantCulture));
-				} else {
-					output.Write (e.Value.ToString ());
-				}
-			} else {
+				output.Write (((IFormattable)value).ToString (null, CultureInfo.InvariantCulture));
+				break;
+			default:
 				throw new ArgumentException (string.Format(CultureInfo.InvariantCulture,
 					"Invalid Primitive Type: {0}. Only CLS compliant primitive " +
 					"types can be used. Consider using CodeObjectCreateExpression.",
@@ -544,8 +507,6 @@
 
 		protected void GenerateStatement (CodeStatement s)
 		{
-			bool handled = false;
-
 #if NET_2_0
 			if (s.StartDirectives.Count > 0)
 				GenerateDirectives (s.StartDirectives);
@@ -553,56 +514,6 @@
 			if (s.LinePragma != null)
 				GenerateLinePragmaStart (s.LinePragma);
 
-			CodeAssignStatement assign = s as CodeAssignStatement;
-			if (assign != null) {
-				GenerateAssignStatement (assign);
-				handled = true;
-			}
-			CodeAttachEventStatement attach = s as CodeAttachEventStatement;
-			if (attach != null) {
-				GenerateAttachEventStatement (attach);
-				handled = true;
-			}
-			CodeCommentStatement comment = s as CodeCommentStatement;
-			if (comment != null) {
-				GenerateCommentStatement (comment);
-				handled = true;
-			}
-			CodeConditionStatement condition = s as CodeConditionStatement;
-			if (condition != null) {
-				GenerateConditionStatement (condition);
-				handled = true;
-			}
-			CodeExpressionStatement expression = s as CodeExpressionStatement;
-			if (expression != null) {
-				GenerateExpressionStatement (expression);
-				handled = true;
-			}
-			CodeGotoStatement gotostmt = s as CodeGotoStatement;
-			if (gotostmt != null) {
-				GenerateGotoStatement (gotostmt);
-				handled = true;
-			}
-			CodeIterationStatement iteration = s as CodeIterationStatement;
-			if (iteration != null) {
-				GenerateIterationStatement (iteration);
-				handled = true;
-			}
-			CodeLabeledStatement label = s as CodeLabeledStatement;
-			if (label != null) {
-				GenerateLabeledStatement (label);
-				handled = true;
-			}
-			CodeMethodReturnStatement returnstmt = s as CodeMethodReturnStatement;
-			if (returnstmt != null) {
-				GenerateMethodReturnStatement (returnstmt);
-				handled = true;
-			}
-			CodeRemoveEventStatement remove = s as CodeRemoveEventStatement;
-			if (remove != null) {
-				GenerateRemoveEventStatement (remove);
-				handled = true;
-			}
 			CodeSnippetStatement snippet = s as CodeSnippetStatement;
 			if (snippet != null) {
 #if NET_2_0
@@ -616,27 +527,19 @@
 #else
 				GenerateSnippetStatement (snippet);
 #endif
-				handled = true;
+			} else {
+				Type type = s.GetType ();
+				MethodInfo method = (MethodInfo)statementMethods [type];
+				if (method == null)
+					throw new ArgumentException ("Element type " + type + " is not supported.");
+
+				try {
+					method.Invoke (this, new object [] { s });
+				} catch (TargetInvocationException exc) {
+					throw exc.InnerException;
+				}
 			}
-			CodeThrowExceptionStatement exception = s as CodeThrowExceptionStatement;
-			if (exception != null) {
-				GenerateThrowExceptionStatement (exception);
-				handled = true;
-			}
-			CodeTryCatchFinallyStatement trycatch = s as CodeTryCatchFinallyStatement;
-			if (trycatch != null) {
-				GenerateTryCatchFinallyStatement (trycatch);
-				handled = true;
-			}
-			CodeVariableDeclarationStatement declaration = s as CodeVariableDeclarationStatement;
-			if (declaration != null) {
-				GenerateVariableDeclarationStatement (declaration);
-				handled = true;
-			}
 
-			if (!handled)
-				throw new ArgumentException ("Element type " + s + " is not supported.");
-
 			if (s.LinePragma != null)
 				GenerateLinePragmaEnd (s.LinePragma);
 
Index: System.CodeDom.Compiler/ChangeLog
===================================================================
--- System.CodeDom.Compiler/ChangeLog	(revision 92052)
+++ System.CodeDom.Compiler/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2008-01-06  Juraj Skripsky  <js@hotfeet.ch>
+
+	* CodeGenerator.cs (GenerateExpression, GenerateStatement): Use
+	hashtables for the mapping from type of given expression/statement
+	to method to be called.
+	Replace if-else sequence with switch in GeneratePrimitiveExpression.
+
 2007-12-15  Marek Habersack  <mhabersack@novell.com>
 
 	* Compiler.cs: added support for the default collection of
