<tt>
Here&nbsp;is&nbsp;another&nbsp;attempt&nbsp;at&nbsp;a&nbsp;COM&nbsp;Interop&nbsp;patch.&nbsp;First,&nbsp;all&nbsp;changes/contributions&nbsp;are&nbsp;MIT&nbsp;X11.&nbsp;Now,&nbsp;for&nbsp;a&nbsp;brief&nbsp;overview&nbsp;;-).&lt;br&gt;&lt;br&gt;I&nbsp;implemented&nbsp;COM&nbsp;Interop&nbsp;on&nbsp;top&nbsp;of&nbsp;the&nbsp;current&nbsp;remoting&nbsp;infrastructure.&nbsp;This&nbsp;allows&nbsp;for&nbsp;two&nbsp;main&nbsp;things.&nbsp;1.&nbsp;Forwarding&nbsp;of&nbsp;method&nbsp;calls&nbsp;to&nbsp;the&nbsp;underlying&nbsp;unmanaged&nbsp;COM&nbsp;object.&nbsp;2.&nbsp;Casting&nbsp;RCW&nbsp;(Runtime&nbsp;Callable&nbsp;Wrappers&nbsp;-&nbsp;the&nbsp;managed&nbsp;wrapper&nbsp;around&nbsp;the&nbsp;unmanaged&nbsp;COM&nbsp;object)&nbsp;to&nbsp;interfaces&nbsp;not&nbsp;specified&nbsp;as&nbsp;implemented&nbsp;in&nbsp;metadata.&nbsp;This&nbsp;can&nbsp;occur&nbsp;if&nbsp;a&nbsp;QueryInterface&nbsp;for&nbsp;that&nbsp;interface's&nbsp;Guid&nbsp;(IID)&nbsp;succeeds&nbsp;on&nbsp;the&nbsp;underlying&nbsp;object.<br>
&lt;br&gt;&lt;br&gt;So,&nbsp;when&nbsp;a&nbsp;user&nbsp;says&nbsp;&amp;quot;MyComObj&nbsp;obj&nbsp;=&nbsp;new&nbsp;MyComObj()&amp;quot;&nbsp;the&nbsp;runtime&nbsp;creates&nbsp;a&nbsp;ComInteropProxy&nbsp;and&nbsp;returns&nbsp;it's&nbsp;TransparentProxy.&nbsp;However,&nbsp;instead&nbsp;of&nbsp;forwarding&nbsp;methods&nbsp;via&nbsp;the&nbsp;remoting&nbsp;invoke&nbsp;mechanism&nbsp;using&nbsp;messages,&nbsp;I&nbsp;shortcut&nbsp;to&nbsp;a&nbsp;Com&nbsp;Interop&nbsp;invoke.&nbsp;The&nbsp;is&nbsp;a&nbsp;great&nbsp;performance&nbsp;boost&nbsp;(by&nbsp;a&nbsp;few&nbsp;orders&nbsp;of&nbsp;magnitude&nbsp;if&nbsp;I&nbsp;recall).&nbsp;I&nbsp;first&nbsp;emit&nbsp;the&nbsp;invoke&nbsp;call,&nbsp;which&nbsp;transitions&nbsp;the&nbsp;call&nbsp;from&nbsp;a&nbsp;call&nbsp;on&nbsp;the&nbsp;transparent&nbsp;proxy,&nbsp;into&nbsp;a&nbsp;call&nbsp;on&nbsp;the&nbsp;actuall&nbsp;RCW.&nbsp;<br>
&lt;br&gt;&lt;br&gt;The&nbsp;method&nbsp;implementation&nbsp;is&nbsp;done&nbsp;by&nbsp;cominterop_get_native_wrapper.&nbsp;This&nbsp;emits&nbsp;a&nbsp;method&nbsp;whose&nbsp;signature&nbsp;matches&nbsp;the&nbsp;managed&nbsp;method.&nbsp;The&nbsp;emitted&nbsp;method&nbsp;calls&nbsp;a&nbsp;final&nbsp;emitted&nbsp;method&nbsp;created&nbsp;by&nbsp;cominterop_get_native_wrapper_adjusted.&nbsp;The&nbsp;two&nbsp;methods,&nbsp;created&nbsp;by&nbsp;cominterop_get_native_wrapper&nbsp;and&nbsp;cominterop_get_native_wrapper_adjusted&nbsp;are&nbsp;1-1.&nbsp;The&nbsp;adjusted&nbsp;method&nbsp;matches&nbsp;the&nbsp;unmanaged&nbsp;signature,&nbsp;and&nbsp;as&nbsp;thus&nbsp;can&nbsp;reuse&nbsp;all&nbsp;the&nbsp;existing&nbsp;unmanaged&nbsp;calling&nbsp;functionality&nbsp;provided&nbsp;by&nbsp;mono_marshal_emit_native_wrapper.&nbsp;The&nbsp;only&nbsp;small&nbsp;change&nbsp;to&nbsp;mono_marshal_emit_native_wrapper&nbsp;was&nbsp;that&nbsp;the&nbsp;function&nbsp;pointer&nbsp;is&nbsp;push&nbsp;onto&nbsp;the&nbsp;stack&nbsp;at&nbsp;call&nbsp;time,&nbsp;rather&nbsp;than&nbsp;when&nbsp;the&nbsp;method&nbsp;is&nbsp;emitted&nbsp;since&nbsp;the&nbsp;function&nbsp;pointer&nbsp;depends&nbsp;on&nbsp;the&nbsp;object&nbsp;making&nbsp;the&nbsp;call&nbsp;(different&nbsp;objects&nbsp;implementing&nbsp;the&nbsp;same&nbsp;interface&nbsp;could&nbsp;have&nbsp;different&nbsp;implementations,&nbsp;and&nbsp;thus&nbsp;vtables,&nbsp;thus&nbsp;function&nbsp;pointers).&nbsp;<br>
&lt;br&gt;&lt;br&gt;Another&nbsp;minor&nbsp;note&nbsp;is&nbsp;the&nbsp;internal&nbsp;calls&nbsp;added&nbsp;to&nbsp;__ComObject.&nbsp;This&nbsp;is&nbsp;so&nbsp;I&nbsp;can&nbsp;store&nbsp;a&nbsp;hashtable&nbsp;of&nbsp;COM&nbsp;interfaces&nbsp;and&nbsp;later&nbsp;release&nbsp;them&nbsp;in&nbsp;the&nbsp;finalizer&nbsp;to&nbsp;ensure&nbsp;proper&nbsp;reference&nbsp;counting.&nbsp;I&nbsp;had&nbsp;a&nbsp;Hashtable&nbsp;in&nbsp;managed&nbsp;code&nbsp;intially&nbsp;but&nbsp;couldn't&nbsp;access&nbsp;it&nbsp;in&nbsp;my&nbsp;finalizer.<br>
&lt;br&gt;&lt;br&gt;I&nbsp;also&nbsp;implemented&nbsp;a&nbsp;series&nbsp;of&nbsp;COM&nbsp;Interop&nbsp;related&nbsp;methods&nbsp;in&nbsp;the&nbsp;Marshal&nbsp;class.&lt;br&gt;&lt;br&gt;On&nbsp;windows&nbsp;you&nbsp;should&nbsp;be&nbsp;able&nbsp;to&nbsp;run&nbsp;some&nbsp;basic&nbsp;tests.&nbsp;I&nbsp;added&nbsp;a&nbsp;few&nbsp;to&nbsp;the&nbsp;cominterop.cs&nbsp;test&nbsp;file&nbsp;but&nbsp;disabled&nbsp;them&nbsp;for&nbsp;the&nbsp;moment.&nbsp;COM&nbsp;is&nbsp;a&nbsp;binary&nbsp;standard&nbsp;and&nbsp;I&nbsp;wasn't&nbsp;sure&nbsp;what&nbsp;vtable&nbsp;layouts&nbsp;would&nbsp;be&nbsp;like&nbsp;on&nbsp;Solaris,&nbsp;ARM,&nbsp;etc.&nbsp;(I&nbsp;know&nbsp;HP&nbsp;is&nbsp;different)&nbsp;and&nbsp;didn't&nbsp;want&nbsp;to&nbsp;cause&nbsp;regressions&nbsp;on&nbsp;those&nbsp;platforms.&nbsp;But,&nbsp;on&nbsp;windows/linux&nbsp;x86/64&nbsp;you&nbsp;can&nbsp;enable&nbsp;them&nbsp;and&nbsp;run&nbsp;them.&nbsp;Or&nbsp;more&nbsp;excitingly&nbsp;you&nbsp;can&nbsp;add&nbsp;a&nbsp;reference&nbsp;to&nbsp;an&nbsp;interop&nbsp;assembly&nbsp;on&nbsp;MS&nbsp;and&nbsp;test&nbsp;run&nbsp;real&nbsp;COM&nbsp;objects&nbsp;(Internet&nbsp;Explorer&nbsp;for&nbsp;example).&nbsp;The&nbsp;largest&nbsp;thing&nbsp;missing&nbsp;right&nbsp;now&nbsp;is&nbsp;the&nbsp;marshalling&nbsp;of&nbsp;com&nbsp;objects.&nbsp;So,&nbsp;you&nbsp;can't&nbsp;call&nbsp;any&nbsp;methods&nbsp;that&nbsp;have&nbsp;parameters/return&nbsp;value&nbsp;of&nbsp;COM&nbsp;objects.&nbsp;This&nbsp;will&nbsp;be&nbsp;the&nbsp;next&nbsp;thing&nbsp;I&nbsp;work&nbsp;on.<br>
&lt;br&gt;&lt;br&gt;I'm&nbsp;sure&nbsp;there&nbsp;are&nbsp;some&nbsp;issues,&nbsp;so&nbsp;please&nbsp;review&nbsp;and&nbsp;I'll&nbsp;fix&nbsp;them&nbsp;ASAP.&lt;br&gt;&lt;br&gt;Thanks,&lt;br&gt;Jonathan&lt;br&gt;<br>

</tt>
