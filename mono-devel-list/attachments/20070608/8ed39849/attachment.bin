// reflection on explicitly-implemented members?

using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

class Foo : IEnumerable, IEnumerable<Foo>, IEnumerator, IEnumerator<Foo> {
	IEnumerator IEnumerable.GetEnumerator ()
	{
		return null;
	}

	IEnumerator<Foo> IEnumerable<Foo>.GetEnumerator ()
	{
		return null;
	}

	bool IEnumerator.MoveNext ()
	{
		return false;
	}

	object IEnumerator.Current { get { return null; } }
	Foo IEnumerator<Foo>.Current { get { return null; } }

	void IEnumerator.Reset ()
	{
	}

	void IDisposable.Dispose ()
	{
	}

	void PrivateMethod ()
	{
	}
}

class Test {
	public static void Main ()
	{
		Type t = typeof(Foo);
		BindingFlags f = BindingFlags.Instance |
				BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic |
				BindingFlags.DeclaredOnly;
		foreach (MethodInfo m in t.GetMethods(f)) {
			PrintMethod (m);
		}
		foreach (PropertyInfo p in t.GetProperties (f)) {
			PrintProperty (p);
			PrintMethod (p.GetGetMethod(true) ?? p.GetSetMethod(true));
		}
#if false
		MethodInfo mi = t.GetMethod ("System.Collections.IEnumerable.GetEnumerator", f);
		PrintMethod (mi);
		mi = t.GetMethod ("System.Collections.Generic.IEnumerable<Foo>.GetEnumerator", f);
		PrintMethod (mi);
#endif
	}

	private static void PrintMethod (MethodInfo m)
	{
		Console.WriteLine ("Method: {0}", m.Name);
		foreach (PropertyInfo pi in m.GetType().GetProperties()) {
			Console.WriteLine ("\t{0}: {1}", pi.Name, pi.GetValue (m, null));
		}
	}

	private static void PrintProperty (PropertyInfo m)
	{
		Console.WriteLine ("Property: {0}", m.Name);
		foreach (PropertyInfo pi in m.GetType().GetProperties()) {
			Console.WriteLine ("\t{0}: {1}", pi.Name, pi.GetValue (m, null));
		}
	}
}
