Index: mono/mono/mini/ssapre.c
===================================================================
--- mono/mono/mini/ssapre.c	(revision 39911)
+++ mono/mono/mini/ssapre.c	(working copy)
@@ -186,6 +186,11 @@
 	if (bb_info->next_interesting_bb != NULL) {
 		printf (", NEXT %d [ID %d]", bb_info->next_interesting_bb->cfg_dfn, bb_info->next_interesting_bb->bb->block_num);
 	}
+	if (bb_info->dt_covered_by_interesting_BBs) {
+		printf (" (COVERED)");
+	} else {
+		printf (" (NEVER DOWN SAFE)");
+	}	
 	printf ("\n");
 	if (bb_info->has_phi) {
 		printf (" PHI, class %d [ ", bb_info->phi_redundancy_class);
@@ -796,7 +801,7 @@
  * (with all the info that comes from the MonoBasicBlock).
  */
 static void
-process_bb (MonoSsapreWorkArea *area, MonoBasicBlock *bb, int *dt_dfn, int *upper_descendants) {
+process_bb (MonoSsapreWorkArea *area, MonoBasicBlock *bb, int *dt_dfn, int *upper_descendants, int current_depth) {
 	MonoSsapreBBInfo *bb_info;
 	int descendants;
 	GList *dominated_bb;
@@ -863,9 +868,12 @@
 		current_inst = current_inst->next;
 	}
 	
+	if (current_depth > area->dt_depth) {
+		area->dt_depth = current_depth;
+	}
 	descendants = 0;
 	for (dominated_bb = g_list_first (bb->dominated); dominated_bb != NULL; dominated_bb = g_list_next (dominated_bb)) {
-		process_bb (area, (MonoBasicBlock*) (dominated_bb->data), dt_dfn, &descendants);
+		process_bb (area, (MonoBasicBlock*) (dominated_bb->data), dt_dfn, &descendants, current_depth + 1);
 	}
 	bb_info->dt_descendants = descendants;
 	*upper_descendants += (descendants + 1);
@@ -879,6 +887,7 @@
 	int i;
 	for (i = 0; i < area->num_bblocks; i++) {
 		MonoSsapreBBInfo *bb_info = &(area->bb_infos [i]);
+		bb_info->dt_covered_by_interesting_BBs = FALSE;
 		bb_info->has_phi = FALSE;
 		bb_info->phi_defines_a_real_occurrence = FALSE;
 		bb_info->phi_is_down_safe = FALSE;
@@ -957,6 +966,18 @@
 }
 
 /*
+ * See paper, section 5.1, definition of "Dominate"
+ */
+static gboolean
+dominates (MonoSsapreBBInfo *dominator, MonoSsapreBBInfo *dominated) {
+	if ((dominator->dt_dfn <= dominated->dt_dfn) && (dominated->dt_dfn <= (dominator->dt_dfn + dominator->dt_descendants))) {
+		return TRUE;
+	} else {
+		return FALSE;
+	}
+}
+
+/*
  * See paper, figure 18, function Set_var_phis
  */
 static void process_phi_variable_in_phi_insertion (MonoSsapreWorkArea *area, gssize variable, MonoBitSet *phi_bbs) {
@@ -984,6 +1005,9 @@
 	MonoSsapreBBInfo *current_bb = NULL;
 	MonoSsapreBBInfo *previous_interesting_bb = NULL;
 	int i, j, current_bb_dt_dfn;
+	int top;
+	MonoSsapreBBInfo **stack;
+	gboolean *interesting_stack;
 	
 	mono_bitset_clear_all (area->expression_occurrences_buffer);
  	for (current_expression = expression->occurrences; current_expression != NULL; current_expression = current_expression->next) {
@@ -1023,16 +1047,60 @@
 		}
 	}
 	
+	top = -1;
+	stack = (MonoSsapreBBInfo **) alloca (sizeof (MonoSsapreBBInfo *) * (area->dt_depth));
+	interesting_stack = (gboolean *) alloca (sizeof (gboolean) * (area->dt_depth));
+	
+	/* Setup the list of interesting BBs, and their "DT coverage" */
 	for (current_bb = area->bb_infos, current_bb_dt_dfn = 0; current_bb_dt_dfn < area->num_bblocks; current_bb++, current_bb_dt_dfn++) {
+		gboolean current_bb_is_interesting;
+		
 		if ((current_bb->first_expression_in_bb != NULL) || (current_bb->has_phi) || (current_bb->has_phi_argument)) {
+			current_bb_is_interesting = TRUE;
+			
 			if (previous_interesting_bb != NULL) {
 				previous_interesting_bb->next_interesting_bb = current_bb;
 			} else {
 				area->first_interesting_bb = current_bb;
 			}
 			previous_interesting_bb = current_bb;
+		} else {
+			current_bb_is_interesting = FALSE;
 		}
+		
+		if (top >= 0) {
+			while ((top >= 0) && (! dominates (stack [top], current_bb))) {
+				gboolean top_covers_his_idominator = ((interesting_stack [top]) || (stack [top]->dt_covered_by_interesting_BBs));
+				
+				if ((top > 0) && (! top_covers_his_idominator)) {
+					stack [top - 1]->dt_covered_by_interesting_BBs = FALSE;
+				}
+				
+				top--;
+			}
+		} else {
+			top = -1;
+		}
+		
+		top++;
+		
+		interesting_stack [top] = current_bb_is_interesting;
+		stack [top] = current_bb;
+		if (stack [top]->dt_descendants == 0) {
+			stack [top]->dt_covered_by_interesting_BBs = FALSE;
+		} else {
+			stack [top]->dt_covered_by_interesting_BBs = TRUE;
+		}
 	}
+	while (top > 0) {
+		gboolean top_covers_his_idominator = ((interesting_stack [top]) || (stack [top]->dt_covered_by_interesting_BBs));
+		
+		if (! top_covers_his_idominator) {
+			stack [top - 1]->dt_covered_by_interesting_BBs = FALSE;
+		}
+		
+		top--;
+	}
 }
 
 /*
@@ -1065,18 +1133,6 @@
 		} while(0)
 
 /*
- * See paper, section 5.1, definition of "Dominate"
- */
-static gboolean
-dominates (MonoSsapreBBInfo *dominator, MonoSsapreBBInfo *dominated) {
-	if ((dominator->dt_dfn <= dominated->dt_dfn) && (dominated->dt_dfn <= (dominator->dt_dfn + dominator->dt_descendants))) {
-		return TRUE;
-	} else {
-		return FALSE;
-	}
-}
-
-/*
  * See paper, section 5.4.
  * The two passes are coded sequentially (no separate "rename1" and "rename2" functions).
  */
@@ -1139,7 +1195,11 @@
 		}
 		
 		if (current_bb->has_phi) {
-			current_bb->phi_is_down_safe = TRUE;
+			if (current_bb->dt_covered_by_interesting_BBs) {
+				current_bb->phi_is_down_safe = TRUE;
+			} else {
+				current_bb->phi_is_down_safe = FALSE;
+			}
 			current_bb->phi_redundancy_class = current_class;
 			current_class++;
 			PUSH_PHI_OCCURRENCE (current_bb);
@@ -2006,7 +2066,8 @@
 	area.current_occurrence = (MonoSsapreExpressionOccurrence*) mono_mempool_alloc (area.mempool, sizeof (MonoSsapreExpressionOccurrence));
 	dt_dfn = 0;
 	descendants = 0;
-	process_bb (&area, cfg->bblocks [0], &dt_dfn, &descendants);
+	area.dt_depth = 0;
+	process_bb (&area, cfg->bblocks [0], &dt_dfn, &descendants, 1);
 	for (block = 0; block < area.num_bblocks; block++) {
 		MonoSsapreBBInfo *bb_info = &(area.bb_infos [block]);
 		MonoBasicBlock *bb = bb_info->bb;
Index: mono/mono/mini/ssapre.h
===================================================================
--- mono/mono/mini/ssapre.h	(revision 39911)
+++ mono/mono/mini/ssapre.h	(working copy)
@@ -17,12 +17,12 @@
 /*
  * Hack to apply SSAPRE only to a given method (invaluable in debugging)
  */
-#define MONO_APPLY_SSAPRE_TO_SINGLE_METHOD 0
+#define MONO_APPLY_SSAPRE_TO_SINGLE_METHOD 1
 
 /*
  * Hack to apply SSAPRE only to a given expression (invaluable in debugging)
  */
-#define MONO_APPLY_SSAPRE_TO_SINGLE_EXPRESSION 0
+#define MONO_APPLY_SSAPRE_TO_SINGLE_EXPRESSION 1
 
 /*
  * All the different kind of arguments we can handle.
@@ -136,8 +136,15 @@
 	/* (the last existing phi definition, or NULL if there is none) */
 	MonoInst *phi_insertion_point;
 	
-	/* Information reused during the analysis of each expression: */
+	/* Information recomputed during the analysis of each expression: */
 	
+	/* True if the whole BB subtree in the dominator tree is "covered" with */
+	/* BBs marked "interesting" (a BB where this is false cannot be down */
+	/* safe, since there would be a path to exit with no occurrence at all). */
+	/* A more formal way of stating this is that on the DT there is no path */
+	/* from this BB to any leaf that does not meet an interesting BB */
+	gboolean dt_covered_by_interesting_BBs;
+	
 	/* True if this BB has a PHI occurrence */
 	gboolean has_phi;
 	/* True if this PHI defines a real occurrence */
@@ -155,7 +162,6 @@
 	/* Array of the class numbers of the PHI arguments (has "in_count" elements) */
 	int *phi_arguments_classes;
 	
-	
 	/* True if this BB has a PHI argument */
 	gboolean has_phi_argument;
 	/* True if this PHI argument "has real use" */
@@ -364,6 +370,9 @@
 	MonoBitSet *left_argument_bb_bitset;
 	MonoBitSet *right_argument_bb_bitset;
 	
+	/* The depth of the dominator tree */
+	int dt_depth;
+	
 	/* The expression worklist */
 	MonoSsapreExpression *worklist;
 	
