Index: Novell.Directory.Ldap.Events/DirectoryExceptionEventArgs.cs
===================================================================
--- Novell.Directory.Ldap.Events/DirectoryExceptionEventArgs.cs	(revision 55795)
+++ Novell.Directory.Ldap.Events/DirectoryExceptionEventArgs.cs	(working copy)
@@ -41,8 +41,8 @@
   /// <seealso cref='Novell.Directory.Ldap.Events.Edir.EdirEventArgs'/>
   public class DirectoryExceptionEventArgs : BaseEventArgs
   {
-    protected LdapException ldap_exception_object;
-    public LdapException LdapExceptionObject
+    protected Exception ldap_exception_object;
+    public Exception LdapExceptionObject
     {
       get
       {
@@ -50,7 +50,7 @@
       }
     }
 
-    public DirectoryExceptionEventArgs(LdapMessage message, LdapException ldapException)
+    public DirectoryExceptionEventArgs(LdapMessage message, Exception ldapException)
       : base(message)
     {
       ldap_exception_object = ldapException;
Index: Novell.Directory.Ldap.Events/LdapEventSource.cs
===================================================================
--- Novell.Directory.Ldap.Events/LdapEventSource.cs	(revision 55795)
+++ Novell.Directory.Ldap.Events/LdapEventSource.cs	(working copy)
@@ -269,6 +269,13 @@
       }
     }
 
+	  protected void NotifyExceptionListeners(LdapMessage sourceMessage, Exception unknownException)
+	  {
+		  if (null != directory_exception_event)
+		  {
+			  directory_exception_event(this, new DirectoryExceptionEventArgs(sourceMessage, unknownException));
+		  }
+	  }
   
     ///  <summary> This is a nested class that is supposed to monitor 
     ///  LdapMessageQueue for events generated by the LDAP Server.
@@ -345,7 +352,11 @@
 	  {
 	    m_objLdapEventSource.NotifyExceptionListeners(response, e);
 	  }
-	}
+	  catch (Exception e)
+	  {
+		  m_objLdapEventSource.NotifyExceptionListeners(response, e);
+	  }
+  }
       } // end of method run
       
       protected void processmessage(LdapMessage response) 
Index: Novell.Directory.Ldap.Rfc2251/RfcBindRequest.cs
===================================================================
--- Novell.Directory.Ldap.Rfc2251/RfcBindRequest.cs	(revision 55795)
+++ Novell.Directory.Ldap.Rfc2251/RfcBindRequest.cs	(working copy)
@@ -100,7 +100,7 @@
 		/// ID needs only be one Value for every instance,
 		/// thus we create it only once.
 		/// </summary>
-		new private static readonly Asn1Identifier ID = new Asn1Identifier(Asn1Identifier.APPLICATION, true, LdapMessage.BIND_REQUEST);
+		private static readonly Asn1Identifier ID = new Asn1Identifier(Asn1Identifier.APPLICATION, true, LdapMessage.BIND_REQUEST);
 		
 		
 		//*************************************************************************
Index: Novell.Directory.Ldap.Rfc2251/RfcModifyDNRequest.cs
===================================================================
--- Novell.Directory.Ldap.Rfc2251/RfcModifyDNRequest.cs	(revision 55795)
+++ Novell.Directory.Ldap.Rfc2251/RfcModifyDNRequest.cs	(working copy)
@@ -59,7 +59,7 @@
 		}
 		
 		/// <summary> </summary>
-		public RfcModifyDNRequest(RfcLdapDN entry, RfcRelativeLdapDN newrdn, Asn1Boolean deleteoldrdn, RfcLdapSuperDN newSuperior):base(4)
+		public RfcModifyDNRequest(RfcLdapDN entry, RfcRelativeLdapDN newrdn, Asn1Boolean deleteoldrdn, RfcLdapDN newSuperior):base(4)
 		{
 			add(entry);
 			add(newrdn);
Index: Novell.Directory.Ldap/Connection.cs
===================================================================
--- Novell.Directory.Ldap/Connection.cs	(revision 55795)
+++ Novell.Directory.Ldap/Connection.cs	(working copy)
@@ -328,9 +328,9 @@
 		private BindProperties bindProperties = null;
 		private int bindSemaphoreId = 0; // 0 is never used by to lock a semaphore
 		
-		private Thread reader = null; // New thread that reads data from the server.
-		private Thread deadReader = null; // Identity of last reader thread
-		private System.IO.IOException deadReaderException = null; // Last exception of reader
+		private SupportClass.ThreadClass reader = null; // New thread that reads data from the server.
+		private SupportClass.ThreadClass deadReader = null; // Identity of last reader thread
+		private System.Exception deadReaderException = null; // Last exception of reader
 		
 		private LBEREncoder encoder;
 		private LBERDecoder decoder;
@@ -431,7 +431,6 @@
 			Connection c = new Connection();
 			c.host = this.host;
 			c.port = this.port;
-			Novell.Directory.Ldap.Connection.protocol = Connection.protocol;
 			return c;
 		}
 		
@@ -551,14 +550,14 @@
 		*
 		* @param the thread id to match
 		*/
-		private void  waitForReader(Thread thread)
+		private void  waitForReader(SupportClass.ThreadClass thread)
 		{
 			// wait for previous reader thread to terminate
 			System.Threading.Thread rInst;
 			System.Threading.Thread tInst;
 			if(reader!=null)
 			{
-				rInst=reader;
+				rInst=reader.Instance;
 			}
 			else
 			{
@@ -567,7 +566,7 @@
 
 			if(thread!=null)
 			{
-				tInst=thread;
+				tInst=thread.Instance;
 			}
 			else
 			{
@@ -591,7 +590,7 @@
 						if (thread == null)
 						/* then we wanted a shutdown */
 							return ;
-						System.IO.IOException lex = deadReaderException;
+						System.Exception lex = deadReaderException;
 						deadReaderException = null;
 						deadReader = null;
 						// Reader thread terminated
@@ -608,7 +607,7 @@
 				}
 				if(reader!=null)
 				{
-					rInst=reader;
+					rInst=reader.Instance;
 				}
 				else
 				{
@@ -617,7 +616,7 @@
 
 				if(thread!=null)
 				{
-					tInst=thread;
+					tInst=thread.Instance;
 				}
 				else
 				{
@@ -1113,6 +1112,8 @@
 			}
 			bindProperties = null;
 			
+			in_Renamed = null;
+			out_Renamed = null;
 			if (socket != null)
 			{
 #if !TARGET_JVM
@@ -1128,11 +1129,7 @@
 						sock.Close();
 					}
 					else
-					{
-						if(in_Renamed != null)
-							in_Renamed.Close();						
 						socket.Close();
-					}
 				}
 				catch (System.IO.IOException ie)
 				{
@@ -1140,8 +1137,6 @@
 				}
 				socket = null;
 				sock = null;
-				in_Renamed=null;
-				out_Renamed=null;
 			}
 			freeWriteSemaphore(semId);
 			return ;
@@ -1202,7 +1197,8 @@
 		internal void  startReader()
 		{
 			// Start Reader Thread
-			Thread r = new Thread(new ThreadStart(new ReaderThread(this).Run));
+			SupportClass.ThreadClass r =new SupportClass.ThreadClass(new System.Threading.ThreadStart(new ReaderThread(this).Run));
+//			Thread r = new Thread(new ThreadStart(new ReaderThread(this).Run));
 			r.IsBackground = true; // If the last thread running, allow exit.
 			r.Start();
 			waitForReader(r);
@@ -1247,6 +1243,7 @@
 				sock.Connect(ephost);
 */
 //				NetworkStream nstream = new NetworkStream(this.socket,true);
+				
 				// Load Mono.Security.dll
 				Assembly a = Assembly.LoadFrom("Mono.Security.dll");
 				Type tSslClientStream = a.GetType("Mono.Security.Protocol.Tls.SslClientStream");
@@ -1401,8 +1398,8 @@
 				System.String reason = "reader: thread stopping";
 				InterThreadException notify = null;
 				Message info = null;
-				System.IO.IOException ioex = null;
-				this.enclosingInstance.reader = System.Threading.Thread.CurrentThread;				
+				System.Exception lastEx = null;
+				this.enclosingInstance.reader = SupportClass.ThreadClass.Current();				
 //				Enclosing_Instance.reader = SupportClass.ThreadClass.Current();
 //				Console.WriteLine("Inside run:" + this.enclosingInstance.reader.Name);
 				try
@@ -1502,25 +1499,37 @@
 						}
 					}
 				}
-				catch(ThreadAbortException tae)
+				catch (ThreadAbortException)
 				{
 					// Abort has been called on reader
 					// before closing sockets, from shutdown
 					return;
 				}
+
 				catch (System.IO.IOException ioe)
 				{
-					
-					ioex = ioe;
+
+					lastEx = ioe;
 					if ((this.enclosingInstance.stopReaderMessageID != Novell.Directory.Ldap.Connection.STOP_READING) && this.enclosingInstance.clientActive)
 					{
 						// Connection lost waiting for results from host:port
-						notify = new InterThreadException(ExceptionMessages.CONNECTION_WAIT, new System.Object[]{this.enclosingInstance.host, this.enclosingInstance.port}, LdapException.CONNECT_ERROR, ioe, info);
+						notify = new InterThreadException(ExceptionMessages.CONNECTION_WAIT, new System.Object[] { this.enclosingInstance.host, this.enclosingInstance.port }, LdapException.CONNECT_ERROR, ioe, info);
 					}
 					// The connection is no good, don't use it any more
 					this.enclosingInstance.in_Renamed = null;
 					this.enclosingInstance.out_Renamed = null;
 				}
+				catch (Exception ex)
+				{
+					//We have to handle all exceptions so the application does not terminate in .NET 2.0
+					//in the event of a background thread unhandled exception.
+					lastEx = ex;
+
+					notify = new InterThreadException(ExceptionMessages.CONNECTION_ERROR, new System.Object[] { this.enclosingInstance.host, this.enclosingInstance.port }, LdapException.OPERATIONS_ERROR, ex, info);
+
+					this.enclosingInstance.in_Renamed = null;
+					this.enclosingInstance.out_Renamed = null;
+				}
 				finally
 				{
 					/*
@@ -1552,7 +1561,7 @@
 						this.enclosingInstance.stopReaderMessageID = Novell.Directory.Ldap.Connection.CONTINUE_READING;
 					}
 				}
-				this.enclosingInstance.deadReaderException = ioex;
+				this.enclosingInstance.deadReaderException = lastEx;
 				this.enclosingInstance.deadReader = this.enclosingInstance.reader;
 				this.enclosingInstance.reader = null;
 				return ;
Index: Novell.Directory.Ldap/LdapException.cs
===================================================================
--- Novell.Directory.Ldap/LdapException.cs	(revision 55795)
+++ Novell.Directory.Ldap/LdapException.cs	(working copy)
@@ -180,7 +180,7 @@
 		{
 			get
 			{
-				return InnerException;
+				return rootException;
 			}
 			
 		}
@@ -251,6 +251,8 @@
 		private System.Object[] arguments = null;
 		// The Matched DN
 		private System.String matchedDN = null;
+		// The Root Cause
+		private System.Exception rootException = null;
 		// A message from the server
 		private System.String serverMessage = null;
 		
@@ -1011,13 +1013,14 @@
 		/// be matched by the server on a search operation.
 		/// </param>
 		/* package */
-		internal LdapException(System.String messageOrKey, System.Object[] arguments, int resultCode, System.String serverMsg, System.String matchedDN, System.Exception rootException):base(messageOrKey, rootException)
+		internal LdapException(System.String messageOrKey, System.Object[] arguments, int resultCode, System.String serverMsg, System.String matchedDN, System.Exception rootException)
 			    //:base(Novell.Directory.Ldap.Utilclass.ResourcesHandler.getMessage(messageOrKey, arguments))
 		//Once resorcehandler starts working properly need to uncomment
 		{
 			this.messageOrKey = messageOrKey;
 			this.arguments = arguments;
 			this.resultCode = resultCode;
+			this.rootException = rootException;
 			this.matchedDN = matchedDN;
 			this.serverMessage = serverMsg;
 			return ;
@@ -1123,8 +1126,8 @@
 				{
 					tmsg = exception + ": Server Message: " + serverMessage;
 				}
-				
-				msg = msg + '\n' + tmsg;
+
+                msg = msg + Environment.NewLine + tmsg;
 			}
 			
 			// Add Matched DN message
@@ -1136,14 +1139,17 @@
 				{
 					tmsg = exception + ": Matched DN: " + matchedDN;
 				}
-				
-				msg = msg + '\n' + tmsg;
+
+                msg = msg + Environment.NewLine + tmsg;
 			}
 			
-			if (InnerException != null)
+			if (rootException != null)
 			{
-				msg = msg + '\n' + InnerException.ToString();
+                msg = msg + Environment.NewLine + rootException.ToString();
 			}
+
+            msg = msg + Environment.NewLine + this.StackTrace.ToString();
+
 			return msg;
 		}
 	}
Index: Novell.Directory.Ldap/LdapModifyDNRequest.cs
===================================================================
--- Novell.Directory.Ldap/LdapModifyDNRequest.cs	(revision 55795)
+++ Novell.Directory.Ldap/LdapModifyDNRequest.cs	(working copy)
@@ -139,7 +139,7 @@
 		/// <param name="cont">           Any controls that apply to the modifyDN request,
 		/// or null if none.
 		/// </param>
-		public LdapModifyDNRequest(System.String dn, System.String newRdn, System.String newParentdn, bool deleteOldRdn, LdapControl[] cont):base(LdapMessage.MODIFY_RDN_REQUEST, new RfcModifyDNRequest(new RfcLdapDN(dn), new RfcRelativeLdapDN(newRdn), new Asn1Boolean(deleteOldRdn), ((System.Object) newParentdn != null)?new RfcLdapSuperDN(newParentdn):null), cont)
+		public LdapModifyDNRequest(System.String dn, System.String newRdn, System.String newParentdn, bool deleteOldRdn, LdapControl[] cont):base(LdapMessage.MODIFY_RDN_REQUEST, new RfcModifyDNRequest(new RfcLdapDN(dn), new RfcRelativeLdapDN(newRdn), new Asn1Boolean(deleteOldRdn), ((System.Object) newParentdn != null)?new RfcLdapDN(newParentdn):null), cont)
 		{
 			return ;
 		}
Index: Novell.Directory.Ldap/LdapResponse.cs
===================================================================
--- Novell.Directory.Ldap/LdapResponse.cs	(revision 55795)
+++ Novell.Directory.Ldap/LdapResponse.cs	(working copy)
@@ -198,7 +198,6 @@
 					
 					default: 
 						ex = new LdapException(LdapException.resultCodeToString(ResultCode), ResultCode, ErrorMessage, MatchedDN);
-//						ex = new LdapException("49", 49, "hello error", "hi error..");
 						break;
 					
 				}
Index: Novell.Directory.Ldap/LdapSearchConstraints.cs
===================================================================
--- Novell.Directory.Ldap/LdapSearchConstraints.cs	(revision 55795)
+++ Novell.Directory.Ldap/LdapSearchConstraints.cs	(working copy)
@@ -238,9 +238,9 @@
 		private int serverTimeLimit = 0;
 		private int maxResults = 1000;
 		private int batchSize = 1;
-		new private static System.Object nameLock; // protect agentNum
+		private static System.Object nameLock; // protect agentNum
 		private static int lSConsNum = 0; // Debug, LdapConnection number
-		new private System.String name; // String name for debug
+		private System.String name; // String name for debug
 		
 		/// <summary> Indicates that aliases are never dereferenced.
 		/// 
Index: Novell.Directory.Ldap/Message.cs
===================================================================
--- Novell.Directory.Ldap/Message.cs	(revision 55795)
+++ Novell.Directory.Ldap/Message.cs	(working copy)
@@ -419,9 +419,10 @@
 
 		private void  cleanup()
 		{
-			stopTimer(); // Make sure timer stopped
 			try
 			{
+				stopTimer(); // Make sure timer stopped
+				
 				acceptReplies = false;
 				if (conn != null)
 				{
@@ -549,7 +550,7 @@
 				System.Threading.Monitor.Pulse(replies);
 			}
 			// Notify a thread waiting for any message id
-			agent.sleepersAwake(false);
+			agent.sleepersAwake(true);
 			return ;
 		}
 
Index: Novell.Directory.Ldap/MessageAgent.cs
===================================================================
--- Novell.Directory.Ldap/MessageAgent.cs	(revision 55795)
+++ Novell.Directory.Ldap/MessageAgent.cs	(working copy)
@@ -140,17 +140,19 @@
 				messages.Add(msgs[i]);
 				((Message) (msgs[i])).Agent = this;
 			}
-			lock (messages)
+
+			lock (messages.SyncRoot)
 			{
 				if (msgs.Length > 1)
 				{
-					System.Threading.Monitor.PulseAll(messages); // wake all threads waiting for messages
+					System.Threading.Monitor.PulseAll(messages.SyncRoot); // wake all threads waiting for messages
 				}
 				else if (msgs.Length == 1)
 				{
-					System.Threading.Monitor.Pulse(messages); // only wake one thread
+					System.Threading.Monitor.Pulse(messages.SyncRoot); // only wake one thread
 				}
 			}
+
 			return ;
 		}
 		
@@ -161,13 +163,14 @@
 		/* package */
 		internal void  sleepersAwake(bool all)
 		{
-			lock (messages)
+			lock (messages.SyncRoot)
 			{
 				if (all)
-					System.Threading.Monitor.PulseAll(messages);
+					System.Threading.Monitor.PulseAll(messages.SyncRoot);
 				else
-					System.Threading.Monitor.Pulse(messages);
+					System.Threading.Monitor.Pulse(messages.SyncRoot);
 			}
+
 			return ;
 		}
 		
@@ -368,12 +371,13 @@
 			else
 			{
 				// A msgId was NOT specified, any message will do
-				lock (messages)
+				lock (messages.SyncRoot)
 				{
 					while (true)
 					{
 						int next = indexLastRead + 1;
 						Message info;
+
 						for (int i = 0; i < messages.Count; i++)
 						{
 							if (next >= messages.Count)
@@ -411,9 +415,10 @@
 						}
 						
 						// No data, wait for something to come in.
+						// Don't do this inside the sync lock!!!
 						try
 						{
-							System.Threading.Monitor.Wait(messages);
+							System.Threading.Monitor.Wait(messages.SyncRoot);
 						}
 						catch (System.Threading.ThreadInterruptedException ex)
 						{
Index: Novell.Directory.Ldap/MessageVector.cs
===================================================================
--- Novell.Directory.Ldap/MessageVector.cs	(revision 55795)
+++ Novell.Directory.Ldap/MessageVector.cs	(working copy)
@@ -38,8 +38,10 @@
 	/// to Vector needed for handling messages.
 	/// </summary>
 	/* package */
-	class MessageVector:System.Collections.ArrayList
-	{
+	class MessageVector:System.Collections.IList
+	{
+		private System.Collections.ArrayList _innerList;
+
 		/// <summary>Returns an array containing all of the elements in this MessageVector.
 		/// The elements returned are in the same order in the array as in the
 		/// Vector.  The contents of the vector are cleared.
@@ -53,7 +55,7 @@
 			
 			get
 			{
-				lock (this)
+				lock (this.SyncRoot)
 				{
 					System.Object[] results = new System.Object[Count];
 					Array.Copy((System.Array) ToArray(), 0, (System.Array) results, 0, Count);
@@ -68,9 +70,9 @@
 			
 		}
 		/* package */
-		internal MessageVector(int cap, int incr):base(cap)
-		{
-			return ;
+		internal MessageVector(int cap, int incr):base()
+		{
+			_innerList = System.Collections.ArrayList.Synchronized(new System.Collections.ArrayList(cap));
 		}
 		
 		/// <summary> Finds the Message object with the given MsgID, and returns the Message
@@ -88,7 +90,7 @@
 		/* package */
 		internal Message findMessageById(int msgId)
 		{
-			lock (this)
+			lock (this.SyncRoot)
 			{
 				Message msg = null;
 				for (int i = 0; i < Count; i++)
@@ -103,7 +105,108 @@
 					}
 				}
 				throw new System.FieldAccessException();
-			}
-		}
-	}
+			}
+		}
+
+		#region ArrayList members
+		public object[] ToArray()
+		{
+			return _innerList.ToArray();
+		}
+		#endregion
+
+		#region IList Members
+
+		public int Add(object value)
+		{
+			return _innerList.Add(value);
+		}
+
+		public void Clear()
+		{
+			_innerList.Clear();
+		}
+
+		public bool Contains(object value)
+		{
+			return _innerList.Contains(value);
+		}
+
+		public int IndexOf(object value)
+		{
+			return _innerList.IndexOf(value);
+		}
+
+		public void Insert(int index, object value)
+		{
+			_innerList.Insert(index, value);
+		}
+
+		public bool IsFixedSize
+		{
+			get { return _innerList.IsFixedSize; }
+		}
+
+		public bool IsReadOnly
+		{
+			get { return _innerList.IsReadOnly; }
+		}
+
+		public void Remove(object value)
+		{
+			_innerList.Remove(value);
+		}
+
+		public void RemoveAt(int index)
+		{
+			_innerList.RemoveAt(index);
+		}
+
+		public object this[int index]
+		{
+			get
+			{
+				return _innerList[index];
+			}
+			set
+			{
+				_innerList[index] = value;
+			}
+		}
+
+		#endregion
+
+		#region ICollection Members
+
+		public void CopyTo(Array array, int index)
+		{
+			_innerList.CopyTo(array, index);
+		}
+
+		public int Count
+		{
+			get { return _innerList.Count; }
+		}
+
+		public bool IsSynchronized
+		{
+			get { return _innerList.IsSynchronized; }
+		}
+
+		public object SyncRoot
+		{
+			get { return _innerList.SyncRoot; }
+		}
+
+		#endregion
+
+		#region IEnumerable Members
+
+		public System.Collections.IEnumerator GetEnumerator()
+		{
+			return _innerList.GetEnumerator();
+		}
+
+		#endregion
 }
+}
Index: Novell.Directory.Ldap/SupportClass.cs
===================================================================
--- Novell.Directory.Ldap/SupportClass.cs	(revision 55795)
+++ Novell.Directory.Ldap/SupportClass.cs	(working copy)
@@ -549,10 +549,10 @@
 		/// <summary>
 		/// Removes the first occurrence of an specific object from an ArrayList instance.
 		/// </summary>
-		/// <param name="arrayList">The ArrayList instance</param>
+		/// <param name="arrayList">The IList instance</param>
 		/// <param name="element">The element to remove</param>
 		/// <returns>True if item is found in the ArrayList; otherwise, false</returns>  
-		public static System.Boolean VectorRemoveElement(System.Collections.ArrayList arrayList, System.Object element)
+		public static System.Boolean VectorRemoveElement(System.Collections.IList arrayList, System.Object element)
 		{
 			System.Boolean containsItem = arrayList.Contains(element);
 			arrayList.Remove(element);
@@ -751,7 +751,11 @@
 			/// </summary>
 			public void Abort()
 			{
-				threadField.Abort();
+				try
+				{
+					threadField.Abort();
+				}
+				catch(Exception) {}
 			}
 	      
 			/// <summary>
