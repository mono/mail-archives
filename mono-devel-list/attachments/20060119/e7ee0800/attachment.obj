Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Extensions/SetReplicationFilterRequest.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Extensions/SetReplicationFilterRequest.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Extensions/SetReplicationFilterRequest.cs	(working copy)
@@ -80,6 +80,7 @@
 		/// <exception> LdapException A general exception which includes an error
 		/// message and an Ldap error code.
 		/// </exception>
+		[CLSCompliant(false)]
 		public SetReplicationFilterRequest(System.String serverDN, System.String[][] replicationFilter):base(ReplicationConstants.SET_REPLICATION_FILTER_REQ, null)
 		{
 			
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapModifyDNRequest.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapModifyDNRequest.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapModifyDNRequest.cs	(working copy)
@@ -139,7 +139,7 @@
 		/// <param name="cont">           Any controls that apply to the modifyDN request,
 		/// or null if none.
 		/// </param>
-		public LdapModifyDNRequest(System.String dn, System.String newRdn, System.String newParentdn, bool deleteOldRdn, LdapControl[] cont):base(LdapMessage.MODIFY_RDN_REQUEST, new RfcModifyDNRequest(new RfcLdapDN(dn), new RfcRelativeLdapDN(newRdn), new Asn1Boolean(deleteOldRdn), ((System.Object) newParentdn != null)?new RfcLdapSuperDN(newParentdn):null), cont)
+		public LdapModifyDNRequest(System.String dn, System.String newRdn, System.String newParentdn, bool deleteOldRdn, LdapControl[] cont):base(LdapMessage.MODIFY_RDN_REQUEST, new RfcModifyDNRequest(new RfcLdapDN(dn), new RfcRelativeLdapDN(newRdn), new Asn1Boolean(deleteOldRdn), ((System.Object) newParentdn != null)?new RfcLdapDN(newParentdn):null), cont)
 		{
 			return ;
 		}
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapException.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapException.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapException.cs	(working copy)
@@ -180,7 +180,7 @@
 		{
 			get
 			{
-				return InnerException;
+				return rootException;
 			}
 			
 		}
@@ -251,6 +251,8 @@
 		private System.Object[] arguments = null;
 		// The Matched DN
 		private System.String matchedDN = null;
+		// The Root Cause
+		private System.Exception rootException = null;
 		// A message from the server
 		private System.String serverMessage = null;
 		
@@ -771,7 +773,7 @@
 		public const int SSL_PROVIDER_NOT_FOUND = 114;
 		/*
 		* Note: Error strings have been pulled out into
-		* ResultCodeMessages.properties
+		* ResultCodeMessages.txt
 		*/
 		
 		/// <summary> Constructs a default exception with no specific error information.</summary>
@@ -1011,13 +1013,14 @@
 		/// be matched by the server on a search operation.
 		/// </param>
 		/* package */
-		internal LdapException(System.String messageOrKey, System.Object[] arguments, int resultCode, System.String serverMsg, System.String matchedDN, System.Exception rootException):base(messageOrKey, rootException)
+		internal LdapException(System.String messageOrKey, System.Object[] arguments, int resultCode, System.String serverMsg, System.String matchedDN, System.Exception rootException)
 			    //:base(Novell.Directory.Ldap.Utilclass.ResourcesHandler.getMessage(messageOrKey, arguments))
 		//Once resorcehandler starts working properly need to uncomment
 		{
 			this.messageOrKey = messageOrKey;
 			this.arguments = arguments;
 			this.resultCode = resultCode;
+			this.rootException = rootException;
 			this.matchedDN = matchedDN;
 			this.serverMessage = serverMsg;
 			return ;
@@ -1122,9 +1125,9 @@
 				if (tmsg.ToUpper().Equals("SERVER_MSG".ToUpper()))
 				{
 					tmsg = exception + ": Server Message: " + serverMessage;
-				}
-				
-				msg = msg + '\n' + tmsg;
+				}
+
+                msg = msg + Environment.NewLine + tmsg;
 			}
 			
 			// Add Matched DN message
@@ -1135,15 +1138,18 @@
 				if (tmsg.ToUpper().Equals("MATCHED_DN".ToUpper()))
 				{
 					tmsg = exception + ": Matched DN: " + matchedDN;
-				}
-				
-				msg = msg + '\n' + tmsg;
+				}
+
+                msg = msg + Environment.NewLine + tmsg;
 			}
 			
-			if (InnerException != null)
-			{
-				msg = msg + '\n' + InnerException.ToString();
-			}
+			if (rootException != null)
+			{
+                msg = msg + Environment.NewLine + rootException.ToString();
+			}
+
+            msg = msg + Environment.NewLine + this.StackTrace.ToString();
+
 			return msg;
 		}
 	}
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/Connection.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/Connection.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/Connection.cs	(working copy)
@@ -34,10 +34,8 @@
 using Novell.Directory.Ldap.Asn1;
 using Novell.Directory.Ldap.Rfc2251;
 using Novell.Directory.Ldap.Utilclass;
-#if !TARGET_JVM
-using Mono.Security.Protocol.Tls;
-using Mono.Security.X509.Extensions;
-#endif
+//using Mono.Security.Protocol.Tls;
+//using Mono.Security.X509.Extensions;
 using Syscert = System.Security.Cryptography.X509Certificates;
 using System.Security.Cryptography;
 using System.Net;
@@ -45,9 +43,7 @@
 using System.Collections;
 using System.IO;
 using System.Text;
-#if !TARGET_JVM
-using Mono.Security.X509;
-#endif
+//using Mono.Security.X509;
 using System.Text.RegularExpressions;
 using System.Globalization;
 using System.Reflection;
@@ -83,37 +79,38 @@
 	sealed class Connection
 	{
 		public event CertificateValidationCallback OnCertificateValidation;
-		public  enum    CertificateProblem  : long
+        	public  enum    CertificateProblem  : long
 		{
-			CertEXPIRED                   = 0x800B0101,
-			CertVALIDITYPERIODNESTING     = 0x800B0102,
-			CertROLE                      = 0x800B0103,
-			CertPATHLENCONST              = 0x800B0104,
-			CertCRITICAL                  = 0x800B0105,
-			CertPURPOSE                   = 0x800B0106,
-			CertISSUERCHAINING            = 0x800B0107,
-			CertMALFORMED                 = 0x800B0108,
-			CertUNTRUSTEDROOT             = 0x800B0109,
-			CertCHAINING                  = 0x800B010A,
-			CertREVOKED                   = 0x800B010C,
-			CertUNTRUSTEDTESTROOT         = 0x800B010D,
-			CertREVOCATION_FAILURE        = 0x800B010E,
-			CertCN_NO_MATCH               = 0x800B010F,
-			CertWRONG_USAGE               = 0x800B0110,
-			CertUNTRUSTEDCA               = 0x800B0112
-		}
-		private static String GetProblemMessage(CertificateProblem Problem)
-		{
-			String ProblemMessage = "";
-			String ProblemCodeName = CertificateProblem.GetName(typeof(CertificateProblem), Problem);
-			if(ProblemCodeName != null)
-				ProblemMessage = ProblemMessage + ProblemCodeName;
-			else
-				ProblemMessage = "Unknown Certificate Problem";
-			return ProblemMessage;
-		}
+                        CertEXPIRED                   = 0x800B0101,
+                        CertVALIDITYPERIODNESTING     = 0x800B0102,
+                        CertROLE                      = 0x800B0103,
+                        CertPATHLENCONST              = 0x800B0104,
+                        CertCRITICAL                  = 0x800B0105,
+                        CertPURPOSE                   = 0x800B0106,
+                        CertISSUERCHAINING            = 0x800B0107,
+                        CertMALFORMED                 = 0x800B0108,
+                        CertUNTRUSTEDROOT             = 0x800B0109,
+                        CertCHAINING                  = 0x800B010A,
+                        CertREVOKED                   = 0x800B010C,
+                        CertUNTRUSTEDTESTROOT         = 0x800B010D,
+                        CertREVOCATION_FAILURE        = 0x800B010E,
+                        CertCN_NO_MATCH               = 0x800B010F,
+                        CertWRONG_USAGE               = 0x800B0110,
+                        CertUNTRUSTEDCA               = 0x800B0112
+                }
  
-		private ArrayList handshakeProblemsEncountered = new ArrayList();
+                private static String GetProblemMessage(CertificateProblem Problem)
+                {
+                        String ProblemMessage = "";
+                        String ProblemCodeName = CertificateProblem.GetName(typeof(CertificateProblem), Problem);
+                        if(ProblemCodeName != null)
+                                ProblemMessage = ProblemMessage + ProblemCodeName;
+                        else
+                                ProblemMessage = "Unknown Certificate Problem";
+                        return ProblemMessage;
+                }
+ 
+                private ArrayList handshakeProblemsEncountered = new ArrayList();
 		private void  InitBlock()
 		{
 			writeSemaphore = new System.Object();
@@ -328,9 +325,9 @@
 		private BindProperties bindProperties = null;
 		private int bindSemaphoreId = 0; // 0 is never used by to lock a semaphore
 		
-		private Thread reader = null; // New thread that reads data from the server.
-		private Thread deadReader = null; // Identity of last reader thread
-		private System.IO.IOException deadReaderException = null; // Last exception of reader
+		private SupportClass.ThreadClass reader = null; // New thread that reads data from the server.
+		private SupportClass.ThreadClass deadReader = null; // Identity of last reader thread
+		private System.Exception deadReaderException = null; // Last exception of reader
 		
 		private LBEREncoder encoder;
 		private LBERDecoder decoder;
@@ -431,7 +428,6 @@
 			Connection c = new Connection();
 			c.host = this.host;
 			c.port = this.port;
-			Novell.Directory.Ldap.Connection.protocol = Connection.protocol;
 			return c;
 		}
 		
@@ -551,14 +547,14 @@
 		*
 		* @param the thread id to match
 		*/
-		private void  waitForReader(Thread thread)
+		private void  waitForReader(SupportClass.ThreadClass thread)
 		{
 			// wait for previous reader thread to terminate
 			System.Threading.Thread rInst;
 			System.Threading.Thread tInst;
 			if(reader!=null)
 			{
-				rInst=reader;
+				rInst=reader.Instance;
 			}
 			else
 			{
@@ -567,7 +563,7 @@
 
 			if(thread!=null)
 			{
-				tInst=thread;
+				tInst=thread.Instance;
 			}
 			else
 			{
@@ -591,7 +587,7 @@
 						if (thread == null)
 						/* then we wanted a shutdown */
 							return ;
-						System.IO.IOException lex = deadReaderException;
+						System.Exception lex = deadReaderException;
 						deadReaderException = null;
 						deadReader = null;
 						// Reader thread terminated
@@ -608,7 +604,7 @@
 				}
 				if(reader!=null)
 				{
-					rInst=reader;
+					rInst=reader.Instance;
 				}
 				else
 				{
@@ -617,7 +613,7 @@
 
 				if(thread!=null)
 				{
-					tInst=thread;
+					tInst=thread.Instance;
 				}
 				else
 				{
@@ -647,10 +643,10 @@
 
 
 /****************************************************************************/
- public  bool ServerCertificateValidation(
-                        Syscert.X509Certificate certificate,
-                        int[]                   certificateErrors)
-                {
+		public  bool ServerCertificateValidation(
+			Syscert.X509Certificate certificate,
+			int[]                   certificateErrors)
+		{
 			if (null != OnCertificateValidation)
 			{
 				return OnCertificateValidation(certificate, certificateErrors);
@@ -665,34 +661,33 @@
 		{
 			bool retFlag=false;
 
-                        if (certificateErrors != null &&
-                                certificateErrors.Length > 0)
-                        {
+            if (certificateErrors != null &&
+                certificateErrors.Length > 0)
+            {
 				if( certificateErrors.Length==1 && certificateErrors[0] == -2146762481)
 				{
-						retFlag = true;
+					retFlag = true;
 				}
 				else
-                                {
-                                	Console.WriteLine("Detected errors in the Server Certificate:");
+                {
+                  	Console.WriteLine("Detected errors in the Server Certificate:");
                                                                                                 
-       		                         for (int i = 0; i < certificateErrors.Length; i++)
-               		                 {
+       				for (int i = 0; i < certificateErrors.Length; i++)
+               		{
 						handshakeProblemsEncountered.Add((CertificateProblem)((uint)certificateErrors[i]));
-                       		                 Console.WriteLine(certificateErrors[i]);
-                                	 }
+						Console.WriteLine(certificateErrors[i]);
+                    }
 					retFlag = false;
 				}
-                        }
+			}
 			else
 			{
 				retFlag = true;
 			}
 
- 
-                        // Skip the server cert errors.
-                        return retFlag;
-                }
+			// Skip the server cert errors.
+            return retFlag;
+		}
 
 
 /***********************************************************************/	
@@ -734,7 +729,6 @@
 			{
 				if ((in_Renamed == null) || (out_Renamed == null))
 				{
-#if !TARGET_JVM
 					if(Ssl)
 					{
 						this.host = host;
@@ -744,19 +738,20 @@
 						IPEndPoint ephost = new IPEndPoint(hostadd,port);
 						sock.Connect(ephost);
 						NetworkStream nstream = new NetworkStream(sock,true);
+
 						// Load Mono.Security.dll
 						Assembly a;
 						try
 						{
-							a = Assembly.LoadWithPartialName("Mono.Security");
+							a = Assembly.LoadFrom("Mono.Security.dll");
 						}
 						catch(System.IO.FileNotFoundException)
 						{
 							throw new LdapException(ExceptionMessages.SSL_PROVIDER_MISSING, LdapException.SSL_PROVIDER_NOT_FOUND, null);
 						}
 						Type tSslClientStream = a.GetType("Mono.Security.Protocol.Tls.SslClientStream");
-						BindingFlags flags = (BindingFlags.NonPublic  | BindingFlags.Public |
-							BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly);
+						BindingFlags flags = (BindingFlags.NonPublic  | BindingFlags.Public |
+							BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly);
 
 						object[] consArgs = new object[4];
 						consArgs[0] = nstream;
@@ -787,21 +782,18 @@
 											false,
 											Mono.Security.Protocol.Tls.SecurityProtocolType.Ssl3|Mono.Security.Protocol.Tls.SecurityProtocolType.Tls);
 						sslstream.ServerCertValidationDelegate += new CertificateValidationCallback(ServerCertificateValidation);*/
-						//						byte[] buffer = new byte[0];
-						//						sslstream.Read(buffer, 0, buffer.Length);
-						//						sslstream.doHandshake();												
+//						byte[] buffer = new byte[0];
+//						sslstream.Read(buffer, 0, buffer.Length);
+//						sslstream.doHandshake();												
 						/*
-						in_Renamed = (System.IO.Stream) sslstream;
+ 						in_Renamed = (System.IO.Stream) sslstream;
 						out_Renamed = (System.IO.Stream) sslstream;*/
 					}
 					else{
-#endif
 						socket = new System.Net.Sockets.TcpClient(host, port);				
 						in_Renamed = (System.IO.Stream) socket.GetStream();
 						out_Renamed = (System.IO.Stream) socket.GetStream();
-#if !TARGET_JVM
 					}
-#endif
 				}
 				else
 				{
@@ -997,8 +989,8 @@
 						strMsg += GetProblemMessage((CertificateProblem)handshakeProblemsEncountered[0]); 
 						for (int nProbIndex = 1; nProbIndex < handshakeProblemsEncountered.Count; nProbIndex++)
 						{
-							strMsg += ", " + GetProblemMessage((CertificateProblem)handshakeProblemsEncountered[nProbIndex]);
-						} 
+                                                        strMsg += ", " + GetProblemMessage((CertificateProblem)handshakeProblemsEncountered[nProbIndex]);
+                                                } 
 					}
 					else
 					{
@@ -1113,12 +1105,13 @@
 			}
 			bindProperties = null;
 			
+			in_Renamed = null;
+			out_Renamed = null;
 			if (socket != null)
 			{
-#if !TARGET_JVM
 				// Just before closing the sockets, abort the reader thread
 				reader.Abort();
-#endif
+				
 				// Close the socket
 				try
 				{
@@ -1128,11 +1121,7 @@
 						sock.Close();
 					}
 					else
-					{
-						if(in_Renamed != null)
-							in_Renamed.Close();						
 						socket.Close();
-					}
 				}
 				catch (System.IO.IOException ie)
 				{
@@ -1140,8 +1129,6 @@
 				}
 				socket = null;
 				sock = null;
-				in_Renamed=null;
-				out_Renamed=null;
 			}
 			freeWriteSemaphore(semId);
 			return ;
@@ -1202,7 +1189,8 @@
 		internal void  startReader()
 		{
 			// Start Reader Thread
-			Thread r = new Thread(new ThreadStart(new ReaderThread(this).Run));
+			SupportClass.ThreadClass r =new SupportClass.ThreadClass(new System.Threading.ThreadStart(new ReaderThread(this).Run));
+//			Thread r = new Thread(new ThreadStart(new ReaderThread(this).Run));
 			r.IsBackground = true; // If the last thread running, allow exit.
 			r.Start();
 			waitForReader(r);
@@ -1236,7 +1224,7 @@
 		/* package */
 		internal void  startTLS()
 		{
-#if !TARGET_JVM			
+			
 			try
 			{
 				waitForReader(null);
@@ -1247,11 +1235,12 @@
 				sock.Connect(ephost);
 */
 //				NetworkStream nstream = new NetworkStream(this.socket,true);
+				
 				// Load Mono.Security.dll
 				Assembly a = Assembly.LoadFrom("Mono.Security.dll");
 				Type tSslClientStream = a.GetType("Mono.Security.Protocol.Tls.SslClientStream");
-				BindingFlags flags = (BindingFlags.NonPublic  | BindingFlags.Public |
-					BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly);
+				BindingFlags flags = (BindingFlags.NonPublic  | BindingFlags.Public |
+					BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly);
 
 				object[] consArgs = new object[4];
 				consArgs[0] = socket.GetStream();
@@ -1278,7 +1267,7 @@
 				/*
 				SslClientStream sslstream = new SslClientStream(
 									socket.GetStream(),
-									nstream,
+//									nstream,
 									host,
 									false,
 									Mono.Security.Protocol.Tls.SecurityProtocolType.Ssl3| Mono.Security.Protocol.Tls.SecurityProtocolType.Tls);
@@ -1297,7 +1286,6 @@
 				throw new LdapException("The host is unknown", LdapException.CONNECT_ERROR, null, uhe);
 			}
 			return ;
-#endif
 		}
 		
 		/*
@@ -1351,25 +1339,6 @@
 		}
 ///TLS not supported in first release		
 
-		internal Stream InputStream
-		{
-			get { return in_Renamed; }
-		}
-
-		internal Stream OutputStream
-		{
-			get { return out_Renamed; }
-		}
-
-		internal void ReplaceStreams(Stream newIn, Stream newOut)
-		{
-			// wait for reader to stop, see LdapConnection.Bind
-			waitForReader(null);
-			in_Renamed = newIn;
-			out_Renamed = newOut;
-			startReader();
-		}
-
 		public class ReaderThread
 		{
 			private void  InitBlock(Connection enclosingInstance)
@@ -1401,55 +1370,55 @@
 				System.String reason = "reader: thread stopping";
 				InterThreadException notify = null;
 				Message info = null;
-				System.IO.IOException ioex = null;
-				this.enclosingInstance.reader = System.Threading.Thread.CurrentThread;				
+				System.Exception lastEx = null;
+				this.enclosingInstance.reader = SupportClass.ThreadClass.Current();				
 //				Enclosing_Instance.reader = SupportClass.ThreadClass.Current();
-//				Console.WriteLine("Inside run:" + this.enclosingInstance.reader.Name);
-				try
-				{
-					for (; ; )
-					{
-						// -------------------------------------------------------
-						// Decode an RfcLdapMessage directly from the socket.
-						// -------------------------------------------------------
-						Asn1Identifier asn1ID;
-						System.IO.Stream myIn;
+//				Console.WriteLine("Inside run:" + this.enclosingInstance.reader.Name);
+				try
+				{
+					for (; ; )
+					{
+						// -------------------------------------------------------
+						// Decode an RfcLdapMessage directly from the socket.
+						// -------------------------------------------------------
+						Asn1Identifier asn1ID;
+						System.IO.Stream myIn;
 						/* get current value of in, keep value consistant
 						* though the loop, i.e. even during shutdown
-						*/
-						myIn = this.enclosingInstance.in_Renamed;
-						if (myIn == null)
-						{
-							break;
-						}
-						asn1ID = new Asn1Identifier(myIn);
-						int tag = asn1ID.Tag;
-						if (asn1ID.Tag != Asn1Sequence.TAG)
-						{
-							continue; // loop looking for an RfcLdapMessage identifier
-						}
-						
-						// Turn the message into an RfcMessage class
-						Asn1Length asn1Len = new Asn1Length(myIn);
-						
-						RfcLdapMessage msg = new RfcLdapMessage(this.enclosingInstance.decoder, myIn, asn1Len.Length);
-						
-						// ------------------------------------------------------------
-						// Process the decoded RfcLdapMessage.
-						// ------------------------------------------------------------
-						int msgId = msg.MessageID;
-						
-						// Find the message which requested this response.
-						// It is possible to receive a response for a request which
-						// has been abandoned. If abandoned, throw it away
-						try
-						{
-							info = this.enclosingInstance.messages.findMessageById(msgId);
-							info.putReply(msg); // queue & wake up waiting thread
-						}
-						catch (System.FieldAccessException ex)
-						{
-							
+						*/
+						myIn = this.enclosingInstance.in_Renamed;
+						if (myIn == null)
+						{
+							break;
+						}
+						asn1ID = new Asn1Identifier(myIn);
+						int tag = asn1ID.Tag;
+						if (asn1ID.Tag != Asn1Sequence.TAG)
+						{
+							continue; // loop looking for an RfcLdapMessage identifier
+						}
+
+						// Turn the message into an RfcMessage class
+						Asn1Length asn1Len = new Asn1Length(myIn);
+
+						RfcLdapMessage msg = new RfcLdapMessage(this.enclosingInstance.decoder, myIn, asn1Len.Length);
+
+						// ------------------------------------------------------------
+						// Process the decoded RfcLdapMessage.
+						// ------------------------------------------------------------
+						int msgId = msg.MessageID;
+
+						// Find the message which requested this response.
+						// It is possible to receive a response for a request which
+						// has been abandoned. If abandoned, throw it away
+						try
+						{
+							info = this.enclosingInstance.messages.findMessageById(msgId);
+							info.putReply(msg); // queue & wake up waiting thread
+						}
+						catch (System.FieldAccessException ex)
+						{
+
 							/*
 							* We get the NoSuchFieldException when we could not find
 							* a matching message id.  First check to see if this is
@@ -1457,9 +1426,9 @@
 							* we throw it away. If it is we call any unsolicited
 							* listeners that might have been registered to listen for these
 							* messages.
-							*/
-							
-							
+							*/
+
+
 							/* Note the location of this code.  We could have required
 							* that message ID 0 be just like other message ID's but
 							* since message ID 0 has to be treated specially we have
@@ -1469,58 +1438,70 @@
 							* of messages after checking if this is an unsolicited
 							* notification but that would have inefficient as
 							* message ID 0 is a rare event (as of this time).
-							*/
-							if (msgId == 0)
-							{
-								
-								
-								// Notify any listeners that might have been registered
-								this.enclosingInstance.notifyAllUnsolicitedListeners(msg);
-								
+							*/
+							if (msgId == 0)
+							{
+
+
+								// Notify any listeners that might have been registered
+								this.enclosingInstance.notifyAllUnsolicitedListeners(msg);
+
 								/*
 								* Was this a server shutdown unsolicited notification.
 								* IF so we quit. Actually calling the return will
 								* first transfer control to the finally clause which
 								* will do the necessary clean up.
-								*/
-								if (this.enclosingInstance.unsolSvrShutDnNotification)
-								{
-									notify = new InterThreadException(ExceptionMessages.SERVER_SHUTDOWN_REQ, new System.Object[]{this.enclosingInstance.host, this.enclosingInstance.port}, LdapException.CONNECT_ERROR, null, null);
-									
-									return ;
-								}
-							}
-							else
-							{
-								
-							}
-						}
-						if ((this.enclosingInstance.stopReaderMessageID == msgId) || (this.enclosingInstance.stopReaderMessageID == Novell.Directory.Ldap.Connection.STOP_READING))
-						{
-							// Stop the reader Thread.
-							return ;
-						}
-					}
+								*/
+								if (this.enclosingInstance.unsolSvrShutDnNotification)
+								{
+									notify = new InterThreadException(ExceptionMessages.SERVER_SHUTDOWN_REQ, new System.Object[] { this.enclosingInstance.host, this.enclosingInstance.port }, LdapException.CONNECT_ERROR, null, null);
+
+									return;
+								}
+							}
+							else
+							{
+
+							}
+						}
+						if ((this.enclosingInstance.stopReaderMessageID == msgId) || (this.enclosingInstance.stopReaderMessageID == Novell.Directory.Ldap.Connection.STOP_READING))
+						{
+							// Stop the reader Thread.
+							return;
+						}
+					}
+				}
+				catch (ThreadAbortException)
+				{
+					// Abort has been called on reader
+					// before closing sockets, from shutdown
+					return;
+				}
+
+				catch (System.IO.IOException ioe)
+				{
+
+					lastEx = ioe;
+					if ((this.enclosingInstance.stopReaderMessageID != Novell.Directory.Ldap.Connection.STOP_READING) && this.enclosingInstance.clientActive)
+					{
+						// Connection lost waiting for results from host:port
+						notify = new InterThreadException(ExceptionMessages.CONNECTION_WAIT, new System.Object[] { this.enclosingInstance.host, this.enclosingInstance.port }, LdapException.CONNECT_ERROR, ioe, info);
+					}
+					// The connection is no good, don't use it any more
+					this.enclosingInstance.in_Renamed = null;
+					this.enclosingInstance.out_Renamed = null;
+				}
+				catch (Exception ex)
+				{
+					//We have to handle all exceptions so the application does not terminate in .NET 2.0
+					//in the event of a background thread unhandled exception.
+					lastEx = ex;
+
+					notify = new InterThreadException(ExceptionMessages.CONNECTION_ERROR, new System.Object[] { this.enclosingInstance.host, this.enclosingInstance.port }, LdapException.OPERATIONS_ERROR, ex, info);
+
+					this.enclosingInstance.in_Renamed = null;
+					this.enclosingInstance.out_Renamed = null;
 				}
-				catch(ThreadAbortException tae)
-				{
-					// Abort has been called on reader
-					// before closing sockets, from shutdown
-					return;
-				}
-				catch (System.IO.IOException ioe)
-				{
-					
-					ioex = ioe;
-					if ((this.enclosingInstance.stopReaderMessageID != Novell.Directory.Ldap.Connection.STOP_READING) && this.enclosingInstance.clientActive)
-					{
-						// Connection lost waiting for results from host:port
-						notify = new InterThreadException(ExceptionMessages.CONNECTION_WAIT, new System.Object[]{this.enclosingInstance.host, this.enclosingInstance.port}, LdapException.CONNECT_ERROR, ioe, info);
-					}
-					// The connection is no good, don't use it any more
-					this.enclosingInstance.in_Renamed = null;
-					this.enclosingInstance.out_Renamed = null;
-				}
 				finally
 				{
 					/*
@@ -1552,7 +1533,7 @@
 						this.enclosingInstance.stopReaderMessageID = Novell.Directory.Ldap.Connection.CONTINUE_READING;
 					}
 				}
-				this.enclosingInstance.deadReaderException = ioex;
+				this.enclosingInstance.deadReaderException = lastEx;
 				this.enclosingInstance.deadReader = this.enclosingInstance.reader;
 				this.enclosingInstance.reader = null;
 				return ;
@@ -1666,7 +1647,7 @@
 		static Connection()
 		{
 			nameLock = new System.Object();
-			sdk = new System.Text.StringBuilder("2.1.4").ToString();
+			sdk = new System.Text.StringBuilder("2.1.3").ToString();
 			protocol = 3;
 		}
 	}
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapConnection.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapConnection.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapConnection.cs	(working copy)
@@ -34,18 +34,7 @@
 using Novell.Directory.Ldap.Asn1;
 using Novell.Directory.Ldap.Rfc2251;
 using Novell.Directory.Ldap.Utilclass;
-#if !TARGET_JVM
-using Mono.Security.Protocol.Tls;
-#else
-using org.ietf.jgss;
-using javax.security.auth;
-using javax.security.auth.login;
-using java.security;
-
-using Novell.Directory.Ldap.Security;
-using System.Collections.Specialized;
-using System.Configuration;
-#endif
+//using Mono.Security.Protocol.Tls;
 using System.Security.Cryptography.X509Certificates;
 
 namespace Novell.Directory.Ldap
@@ -587,6 +576,7 @@
 		/// <summary> The OID string that identifies a StartTLS request and response.</summary>
 		private const System.String START_TLS_OID = "1.3.6.1.4.1.1466.20037";
 		
+
 		public event CertificateValidationCallback UserDefinedServerCertValidationDelegate
 		{
 			add
@@ -599,6 +589,7 @@
 				this.conn.OnCertificateValidation -= value;
 			}
 		}
+
 		/*
 		* Constructors
 		*/
@@ -1193,24 +1184,10 @@
 		/// </exception>
 		public virtual void  Bind(System.String dn, System.String passwd)
 		{
-			Bind(dn, passwd, AuthenticationTypes.None);
+			Bind(Ldap_V3, dn, passwd, defSearchCons);
 			return ;
 		}
 		
-		public virtual void  Bind(System.String dn, System.String passwd, AuthenticationTypes authenticationTypes)
-		{
-#if TARGET_JVM
-			if (authenticationTypes != AuthenticationTypes.None &&
-				authenticationTypes != AuthenticationTypes.ServerBind &&
-				authenticationTypes != AuthenticationTypes.Anonymous)
-				BindSecure(dn, passwd, authenticationTypes);
-			else
-#endif
-				Bind(Ldap_V3, dn, passwd, defSearchCons);		
-
-			return ;
-		}
-		
 		/// <summary> Synchronously authenticates to the Ldap server (that the object is
 		/// currently connected to) using the specified name, password,
 		/// and Ldap version.
@@ -1423,7 +1400,7 @@
 		[CLSCompliantAttribute(false)]
 		public virtual void  Bind(int version, System.String dn, sbyte[] passwd, LdapConstraints cons)
 		{
-			LdapResponseQueue queue = Bind(version, dn, passwd, null, cons, null);
+			LdapResponseQueue queue = Bind(version, dn, passwd, null, cons);
 			LdapResponse res = (LdapResponse) queue.getResponse();
 			if (res != null)
 			{
@@ -1475,7 +1452,7 @@
 		[CLSCompliantAttribute(false)]
 		public virtual LdapResponseQueue Bind(int version, System.String dn, sbyte[] passwd, LdapResponseQueue queue)
 		{
-			return Bind(version, dn, passwd, queue, defSearchCons, null);
+			return Bind(version, dn, passwd, queue, defSearchCons);
 		}
 		
 		/// <summary> Asynchronously authenticates to the Ldap server (that the object is
@@ -1515,7 +1492,7 @@
 		/// message and an Ldap error code.
 		/// </exception>
 		[CLSCompliantAttribute(false)]
-		public virtual LdapResponseQueue Bind(int version, System.String dn, sbyte[] passwd, LdapResponseQueue queue, LdapConstraints cons, string mech)
+		public virtual LdapResponseQueue Bind(int version, System.String dn, sbyte[] passwd, LdapResponseQueue queue, LdapConstraints cons)
 		{
 			int msgId;
 			BindProperties bindProps;
@@ -1541,13 +1518,7 @@
 				dn = ""; // set to null if anonymous
 			}
 
-			LdapMessage msg;
-#if TARGET_JVM
-			if (mech != null)
-				msg = new LdapBindRequest(version, "", mech, passwd, cons.getControls());
-			else
-#endif
-				msg = new LdapBindRequest(version, dn, passwd, cons.getControls());
+			LdapMessage msg = new LdapBindRequest(version, dn, passwd, cons.getControls());
 			
 			msgId = msg.MessageID;
 			bindProps = new BindProperties(version, dn, "simple", anonymous, null, null);
@@ -1565,127 +1536,11 @@
 				}
 			}
 			
-#if TARGET_JVM
-			// stopping reader to enable stream replace after secure binding is complete, see Connection.ReplaceStreams()
-			if (mech != null)
-			{
-				if (conn.BindSemIdClear) {
-					// need to acquire a semaphore only if bindSemId is clear
-					// because if we receive SASL_BIND_IN_PROGRESS the semaphore is not
-					// released when the response is queued
-					conn.acquireWriteSemaphore(msgId);
-					conn.BindSemId = msgId;
-				}
-				conn.stopReaderOnReply(msgId);
-			}
-			else
-#endif
 			// The semaphore is released when the bind response is queued.
 			conn.acquireWriteSemaphore(msgId);
 			
 			return SendRequestToServer(msg, cons.TimeLimit, queue, bindProps);
 		}
-
-#if TARGET_JVM
-		private void BindSecure(System.String username, System.String password, AuthenticationTypes authenticationTypes)
-		{
-			if ((authenticationTypes & AuthenticationTypes.Secure) != 0) {			
-				LoginContext loginContext = null;
-				try {					
-					if (username != null && password != null) {
-						AuthenticationCallbackHandler callbackHandler = new AuthenticationCallbackHandler (username,password);
-						loginContext = new LoginContext (SecurityAppName, callbackHandler);
-					}
-					else
-						loginContext = new LoginContext (SecurityAppName);
-
-					loginContext.login ();
-				}
-				catch (Exception e) {
-					throw new LdapException ("Failed to create login security context", 80, "", e);
-				}
-
-				Krb5Helper krb5Helper = null;
-				try {
-					krb5Helper = new Krb5Helper ("ldap@" + conn.Host, username, loginContext.getSubject (), authenticationTypes, SecurityMech);
-				}
-				finally {
-					loginContext.logout();
-				}
-				sbyte [] token = krb5Helper.ExchangeTokens (Krb5Helper.EmptyToken);
-
-				for (;;) {
-					LdapResponseQueue queue = Bind(LdapConnection.Ldap_V3, username, token, null, null, AuthenticationMech);
-					LdapResponse res = (LdapResponse) queue.getResponse ();
-					if (res.ResultCode != LdapException.SASL_BIND_IN_PROGRESS &&
-						res.ResultCode != LdapException.SUCCESS) {
-						krb5Helper.Dispose();
-						throw new LdapException(ExceptionMessages.CONNECTION_ERROR, res.ResultCode, res.ErrorMessage);
-					}
-					Asn1OctetString serverSaslCreds = ((RfcBindResponse)res.Asn1Object.Response).ServerSaslCreds;
-					token = serverSaslCreds != null ? serverSaslCreds.byteValue () : null;
-
-					token = krb5Helper.ExchangeTokens(token == null ? Krb5Helper.EmptyToken : token);
-
-					if (res.ResultCode != LdapException.SASL_BIND_IN_PROGRESS)
-						break;
-
-					conn.ReplaceStreams (conn.InputStream,conn.OutputStream);
-				}
-
-				System.IO.Stream inStream = conn.InputStream;
-				System.IO.Stream newIn = new SecureStream (inStream, krb5Helper);
-				System.IO.Stream outStream = conn.OutputStream;
-				System.IO.Stream newOut = new SecureStream (outStream, krb5Helper);
-				conn.ReplaceStreams (newIn,newOut);
-			}		
-		}
-
-		static string SecurityMech
-		{
-			get {
-				string securityMech = null;
-					NameValueCollection config = (NameValueCollection) ConfigurationSettings.GetConfig ("System.DirectoryServices/Settings");
-					if (config != null) 
-						securityMech = config ["securitymech"];
-
-					if (securityMech == null) 
-						throw new ArgumentException("Security mechanism id not found in application settings");
-
-				return securityMech;
-			}
-		}
-
-		static string SecurityAppName
-		{
-			get {
-				string securityAppName = null; 
-					NameValueCollection config = (NameValueCollection) ConfigurationSettings.GetConfig ("System.DirectoryServices/Settings");
-					if (config != null) 
-						securityAppName = config ["securityappname"];
-
-					if (securityAppName == null) 
-						throw new ArgumentException("Application section name not found in application settings");
-
-				return securityAppName;
-			}
-		}
-
-		static string AuthenticationMech
-		{
-			get {
-				string authenticationMech = null;
-				NameValueCollection config = (NameValueCollection) ConfigurationSettings.GetConfig ("System.DirectoryServices/Settings");
-				if (config != null) 
-					authenticationMech = config ["authenticationmech"];
-
-				if (authenticationMech == null) 
-					throw new ArgumentException("Authentication mechanism not found in application settings");
-
-				return authenticationMech;
-			}
-		}
-#endif
 		
 		//*************************************************************************
 		// compare methods
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/SupportClass.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/SupportClass.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/SupportClass.cs	(working copy)
@@ -549,10 +549,10 @@
 		/// <summary>
 		/// Removes the first occurrence of an specific object from an ArrayList instance.
 		/// </summary>
-		/// <param name="arrayList">The ArrayList instance</param>
+		/// <param name="arrayList">The IList instance</param>
 		/// <param name="element">The element to remove</param>
 		/// <returns>True if item is found in the ArrayList; otherwise, false</returns>  
-		public static System.Boolean VectorRemoveElement(System.Collections.ArrayList arrayList, System.Object element)
+		public static System.Boolean VectorRemoveElement(System.Collections.IList arrayList, System.Object element)
 		{
 			System.Boolean containsItem = arrayList.Contains(element);
 			arrayList.Remove(element);
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapUrl.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapUrl.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapUrl.cs	(working copy)
@@ -1,862 +1,862 @@
-/******************************************************************************
-* The MIT License
-* Copyright (c) 2003 Novell Inc.  www.novell.com
-* 
-* Permission is hereby granted, free of charge, to any person obtaining  a copy
-* of this software and associated documentation files (the Software), to deal
-* in the Software without restriction, including  without limitation the rights
-* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
-* copies of the Software, and to  permit persons to whom the Software is 
-* furnished to do so, subject to the following conditions:
-* 
-* The above copyright notice and this permission notice shall be included in 
-* all copies or substantial portions of the Software.
-* 
-* THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
-* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
-* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
-* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-* SOFTWARE.
-*******************************************************************************/
-//
-// Novell.Directory.Ldap.LdapUrl.cs
-//
-// Author:
-//   Sunil Kumar (Sunilk@novell.com)
-//
-// (C) 2003 Novell, Inc (http://www.novell.com)
-//
-
-using System;
-using ArrayEnumeration = Novell.Directory.Ldap.Utilclass.ArrayEnumeration;
-
-namespace Novell.Directory.Ldap
-{
-	
-	/// <summary> 
-	/// Encapsulates parameters of an Ldap URL query as defined in RFC2255.
-	/// 
-	/// An LdapUrl object can be passed to LdapConnection.search to retrieve
-	/// search results.
-	/// 
-	/// </summary>
-	/// <seealso cref="LdapConnection.Search">
-	/// </seealso>
-	public class LdapUrl : System.ICloneable
-	{
-		private void  InitBlock()
-		{
-			scope = DEFAULT_SCOPE;
-		}
-		/// <summary> Returns an array of attribute names specified in the URL.
-		/// 
-		/// </summary>
-		/// <returns> An array of attribute names in the URL.
-		/// </returns>
-		virtual public System.String[] AttributeArray
-		{
-			get
-			{
-				return attrs;
-			}
-			
-		}
-		/// <summary> Returns an enumerator for the attribute names specified in the URL.
-		/// 
-		/// </summary>
-		/// <returns> An enumeration of attribute names.
-		/// </returns>
-		virtual public System.Collections.IEnumerator Attributes
-		{
-			get
-			{
-				return new ArrayEnumeration(attrs);
-			}
-			
-		}
-		/// <summary> Returns any Ldap URL extensions specified, or null if none are
-		/// specified. Each extension is a type=value expression. The =value part
-		/// MAY be omitted. The expression MAY be prefixed with '!' if it is
-		/// mandatory for evaluation of the URL.
-		/// 
-		/// </summary>
-		/// <returns> string array of extensions.
-		/// </returns>
-		virtual public System.String[] Extensions
-		{
-			get
-			{
-				return extensions;
-			}
-			
-		}
-		/// <summary> Returns the search filter or <code>null</code> if none was specified.
-		/// 
-		/// </summary>
-		/// <returns> The search filter.
-		/// </returns>
-		virtual public System.String Filter
-		{
-			get
-			{
-				return filter;
-			}
-			
-		}
-		/// <summary> Returns the name of the Ldap server in the URL.
-		/// 
-		/// </summary>
-		/// <returns> The host name specified in the URL.
-		/// </returns>
-		virtual public System.String Host
-		{
-			get
-			{
-				return host;
-			}
-			
-		}
-		/// <summary> Returns the port number of the Ldap server in the URL.
-		/// 
-		/// </summary>
-		/// <returns> The port number in the URL.
-		/// </returns>
-		virtual public int Port
-		{
-			get
-			{
-				if (port == 0)
-				{
-					return LdapConnection.DEFAULT_PORT;
-				}
-				return port;
-			}
-			
-		}
-		/// <summary> Returns the depth of search. It returns one of the following from
-		/// LdapConnection: SCOPE_BASE, SCOPE_ONE, or SCOPE_SUB.
-		/// 
-		/// </summary>
-		/// <returns> The search scope.
-		/// </returns>
-		virtual public int Scope
-		{
-			get
-			{
-				return scope;
-			}
-			
-		}
-		/// <summary> Returns true if the URL is of the type ldaps (Ldap over SSL, a predecessor
-		/// to startTls)
-		/// 
-		/// </summary>
-		/// <returns> whether this is a secure Ldap url or not.
-		/// </returns>
-		virtual public bool Secure
-		{
-			get
-			{
-				return secure;
-			}
-			
-		}
-		private static readonly int DEFAULT_SCOPE = LdapConnection.SCOPE_BASE;
-		
-		// Broken out parts of the URL
-		private bool secure = false; // URL scheme ldap/ldaps
-		private bool ipV6 = false; // TCP/IP V6
-		private System.String host = null; // Host
-		private int port = 0; // Port
-		private System.String dn = null; // Base DN
-		private System.String[] attrs = null; // Attributes
-		private System.String filter = null; // Filter
-		private int scope; // Scope
-		private System.String[] extensions = null; // Extensions
-		
-		/// <summary> Constructs a URL object with the specified string as the URL.
-		/// 
-		/// </summary>
-		/// <param name="url">     An Ldap URL string, e.g.
-		/// "ldap://ldap.example.com:80/dc=example,dc=com?cn,
-		/// sn?sub?(objectclass=inetOrgPerson)".
-		/// 
-		/// </param>
-		/// <exception> MalformedURLException The specified URL cannot be parsed.
-		/// </exception>
-		public LdapUrl(System.String url)
-		{
-			InitBlock();
-			parseURL(url);
-			return ;
-		}
-		
-		
-		/// <summary> Constructs a URL object with the specified host, port, and DN.
-		/// 
-		/// This form is used to create URL references to a particular object
-		/// in the directory.
-		/// 
-		/// </summary>
-		/// <param name="host">    Host identifier of Ldap server, or null for
-		/// "localhost".
-		/// 
-		/// </param>
-		/// <param name="port">    The port number for Ldap server (use
-		/// LdapConnection.DEFAULT_PORT for default port).
-		/// 
-		/// </param>
-		/// <param name="dn">      Distinguished name of the base object of the search.
-		/// 
-		/// </param>
-		public LdapUrl(System.String host, int port, System.String dn)
-		{
-			InitBlock();
-			this.host = host;
-			this.port = port;
-			this.dn = dn;
-			return ;
-		}
-		
-		/// <summary> Constructs an Ldap URL with all fields explicitly assigned, to
-		/// specify an Ldap search operation.
-		/// 
-		/// </summary>
-		/// <param name="host">    Host identifier of Ldap server, or null for
-		/// "localhost".
-		/// 
-		/// </param>
-		/// <param name="port">    The port number for Ldap server (use
-		/// LdapConnection.DEFAULT_PORT for default port).
-		/// 
-		/// </param>
-		/// <param name="dn">      Distinguished name of the base object of the search.
-		/// 
-		/// 
-		/// </param>
-		/// <param name="attrNames">Names or OIDs of attributes to retrieve.  Passing a
-		/// null array signifies that all user attributes are to be
-		/// retrieved. Passing a value of "*" allows you to specify
-		/// that all user attributes as well as any specified
-		/// operational attributes are to be retrieved.
-		/// 
-		/// 
-		/// </param>
-		/// <param name="scope">   Depth of search (in DN namespace). Use one of
-		/// SCOPE_BASE, SCOPE_ONE, SCOPE_SUB from LdapConnection.
-		/// 
-		/// 
-		/// </param>
-		/// <param name="filter">  The search filter specifying the search criteria.
-		/// 
-		/// 
-		/// </param>
-		/// <param name="extensions"> Extensions provide a mechanism to extend the
-		/// functionality of Ldap URLs. Currently no
-		/// Ldap URL extensions are defined. Each extension
-		/// specification is a type=value expression, and  may
-		/// be <code>null</code> or empty.  The =value part may be
-		/// omitted. The expression may be prefixed with '!' if it
-		/// is mandatory for the evaluation of the URL.
-		/// </param>
-		public LdapUrl(System.String host, int port, System.String dn, System.String[] attrNames, int scope, System.String filter, System.String[] extensions)
-		{
-			InitBlock();
-			this.host = host;
-			this.port = port;
-			this.dn = dn;
-			this.attrs = new System.String[attrNames.Length];
-			attrNames.CopyTo(this.attrs, 0);
-			this.scope = scope;
-			this.filter = filter;
-			this.extensions = new System.String[extensions.Length];
-			extensions.CopyTo(this.extensions, 0);
-			return ;
-		}
-		
-		/// <summary> Constructs an Ldap URL with all fields explicitly assigned, including
-		/// isSecure, to specify an Ldap search operation.
-		/// 
-		/// </summary>
-		/// <param name="host">    Host identifier of Ldap server, or null for
-		/// "localhost".
-		/// 
-		/// 
-		/// </param>
-		/// <param name="port">    The port number for Ldap server (use
-		/// LdapConnection.DEFAULT_PORT for default port).
-		/// 
-		/// 
-		/// </param>
-		/// <param name="dn">      Distinguished name of the base object of the search.
-		/// 
-		/// 
-		/// </param>
-		/// <param name="attrNames">Names or OIDs of attributes to retrieve.  Passing a
-		/// null array signifies that all user attributes are to be
-		/// retrieved. Passing a value of "*" allows you to specify
-		/// that all user attributes as well as any specified
-		/// operational attributes are to be retrieved.
-		/// 
-		/// 
-		/// </param>
-		/// <param name="scope">   Depth of search (in DN namespace). Use one of
-		/// SCOPE_BASE, SCOPE_ONE, SCOPE_SUB from LdapConnection.
-		/// 
-		/// 
-		/// </param>
-		/// <param name="filter">  The search filter specifying the search criteria.
-		/// from LdapConnection: SCOPE_BASE, SCOPE_ONE, SCOPE_SUB.
-		/// 
-		/// 
-		/// </param>
-		/// <param name="extensions"> Extensions provide a mechanism to extend the
-		/// functionality of Ldap URLs. Currently no
-		/// Ldap URL extensions are defined. Each extension
-		/// specification is a type=value expression, and  may
-		/// be <code>null</code> or empty.  The =value part may be
-		/// omitted. The expression may be prefixed with '!' if it
-		/// is mandatory for the evaluation of the URL.
-		/// 
-		/// 
-		/// </param>
-		/// <param name="secure">  If true creates an Ldap URL of the ldaps type
-		/// </param>
-		public LdapUrl(System.String host, int port, System.String dn, System.String[] attrNames, int scope, System.String filter, System.String[] extensions, bool secure)
-		{
-			InitBlock();
-			this.host = host;
-			this.port = port;
-			this.dn = dn;
-			this.attrs = attrNames;
-			this.scope = scope;
-			this.filter = filter;
-			this.extensions = new System.String[extensions.Length];
-			extensions.CopyTo(this.extensions, 0);
-			this.secure = secure;
-			return ;
-		}
-		
-		/// <summary> Returns a clone of this URL object.
-		/// 
-		/// </summary>
-		/// <returns> clone of this URL object.
-		/// </returns>
-		public System.Object Clone()
-		{
-			try
-			{
-				return base.MemberwiseClone();
-			}
-			catch (System.Exception ce)
-			{
-				throw new System.SystemException("Internal error, cannot create clone");
-			}
-		}
-		
-		/// <summary> Decodes a URL-encoded string.
-		/// 
-		/// Any occurences of %HH are decoded to the hex value represented.
-		/// However, this method does NOT decode "+" into " ".
-		/// 
-		/// </summary>
-		/// <param name="URLEncoded">    String to decode.
-		/// 
-		/// </param>
-		/// <returns> The decoded string.
-		/// 
-		/// </returns>
-		/// <exception> MalformedURLException The URL could not be parsed.
-		/// </exception>
-		public static System.String decode(System.String URLEncoded)
-		{
-			
-			
-			int searchStart = 0;
-			int fieldStart;
-			
-			fieldStart = URLEncoded.IndexOf("%", searchStart);
-			// Return now if no encoded data
-			if (fieldStart < 0)
-			{
-				return URLEncoded;
-			}
-			
-			// Decode the %HH value and copy to new string buffer
-			int fieldEnd = 0; // end of previous field
-			int dataLen = URLEncoded.Length;
-			
-			System.Text.StringBuilder decoded = new System.Text.StringBuilder(dataLen);
-			
-			while (true)
-			{
-				if (fieldStart > (dataLen - 3))
-				{
-					throw new System.UriFormatException("LdapUrl.decode: must be two hex characters following escape character '%'");
-				}
-				if (fieldStart < 0)
-					fieldStart = dataLen;
-				// Copy to string buffer from end of last field to start of next
-				decoded.Append(URLEncoded.Substring(fieldEnd, (fieldStart) - (fieldEnd)));
-				fieldStart += 1;
-				if (fieldStart >= dataLen)
-					break;
-				fieldEnd = fieldStart + 2;
-				try
-				{
-					decoded.Append((char) System.Convert.ToInt32(URLEncoded.Substring(fieldStart, (fieldEnd) - (fieldStart)), 16));
-				}
-				catch (System.FormatException ex)
-				{
-					throw new System.UriFormatException("LdapUrl.decode: error converting hex characters to integer \"" + ex.Message + "\"");
-				}
-				searchStart = fieldEnd;
-				if (searchStart == dataLen)
-					break;
-				fieldStart = URLEncoded.IndexOf("%", searchStart);
-			}
-			
-			return (decoded.ToString());
-		}
-		
-		/// <summary> Encodes an arbitrary string using the URL encoding rules.
-		/// 
-		///  Any illegal characters are encoded as %HH. 
-		/// 
-		/// </summary>
-		/// <param name="toEncode">    The string to encode.
-		/// 
-		/// </param>
-		/// <returns> The URL-encoded string.
-		/// 
-		/// Comment: An illegal character consists of any non graphical US-ASCII character, Unsafe, or reserved characters.
-		/// </returns>
-		public static System.String encode(System.String toEncode)
-		{
-			System.Text.StringBuilder buffer = new System.Text.StringBuilder(toEncode.Length); //empty but initial capicity of 'length'
-			System.String temp;
-			char currChar;
-			for (int i = 0; i < toEncode.Length; i++)
-			{
-				currChar = toEncode[i];
-				if ((((int) currChar <= 0x1F) || ((int) currChar == 0x7F) || (((int) currChar >= 0x80) && ((int) currChar <= 0xFF))) || ((currChar == '<') || (currChar == '>') || (currChar == '\"') || (currChar == '#') || (currChar == '%') || (currChar == '{') || (currChar == '}') || (currChar == '|') || (currChar == '\\') || (currChar == '^') || (currChar == '~') || (currChar == '[') || (currChar == '\'')) || ((currChar == ';') || (currChar == '/') || (currChar == '?') || (currChar == ':') || (currChar == '@') || (currChar == '=') || (currChar == '&')))
-				{
-					temp = System.Convert.ToString(currChar, 16);
-					if (temp.Length == 1)
-						buffer.Append("%0" + temp);
-					//if(temp.length()==2) this can only be two or one digit long.
-					else
-						buffer.Append("%" + System.Convert.ToString(currChar, 16));
-				}
-				else
-					buffer.Append(currChar);
-			}
-			return buffer.ToString();
-		}
-		
-		/// <summary> Returns the base distinguished name encapsulated in the URL.
-		/// 
-		/// </summary>
-		/// <returns> The base distinguished name specified in the URL, or null if none.
-		/// </returns>
-		public virtual System.String getDN()
-		{
-			return dn;
-		}
-		
-		/// <summary> Sets the base distinguished name encapsulated in the URL.</summary>
-		/* package */
-		internal virtual void  setDN(System.String dn)
-		{
-			this.dn = dn;
-			return ;
-		}
-		
-		/// <summary> Returns a valid string representation of this Ldap URL.
-		/// 
-		/// </summary>
-		/// <returns> The string representation of the Ldap URL.
-		/// </returns>
-		public override System.String ToString()
-		{
-			System.Text.StringBuilder url = new System.Text.StringBuilder(256);
-			// Scheme
-			if (secure)
-			{
-				url.Append("ldaps://");
-			}
-			else
-			{
-				url.Append("ldap://");
-			}
-			// Host:port/dn
-			if (ipV6)
-			{
-				url.Append("[" + host + "]");
-			}
-			else
-			{
-				url.Append(host);
-			}
-			
-			// Port not specified
-			if (port != 0)
-			{
-				url.Append(":" + port);
-			}
-			
-			if (((System.Object) dn == null) && (attrs == null) && (scope == DEFAULT_SCOPE) && ((System.Object) filter == null) && (extensions == null))
-			{
-				return url.ToString();
-			}
-			
-			url.Append("/");
-			
-			if ((System.Object) dn != null)
-			{
-				url.Append(dn);
-			}
-			
-			if ((attrs == null) && (scope == DEFAULT_SCOPE) && ((System.Object) filter == null) && (extensions == null))
-			{
-				return url.ToString();
-			}
-			
-			// attributes
-			url.Append("?");
-			if (attrs != null)
-			{
-				//should we check also for attrs != "*"
-				for (int i = 0; i < attrs.Length; i++)
-				{
-					url.Append(attrs[i]);
-					if (i < (attrs.Length - 1))
-					{
-						url.Append(",");
-					}
-				}
-			}
-			
-			if ((scope == DEFAULT_SCOPE) && ((System.Object) filter == null) && (extensions == null))
-			{
-				return url.ToString();
-			}
-			
-			// scope
-			url.Append("?");
-			if (scope != DEFAULT_SCOPE)
-			{
-				if (scope == LdapConnection.SCOPE_ONE)
-				{
-					url.Append("one");
-				}
-				else
-				{
-					url.Append("sub");
-				}
-			}
-			
-			if (((System.Object) filter == null) && (extensions == null))
-			{
-				return url.ToString();
-			}
-			
-			// filter
-			if ((System.Object) filter == null)
-			{
-				url.Append("?");
-			}
-			else
-			{
-				url.Append("?" + Filter);
-			}
-			
-			if (extensions == null)
-			{
-				return url.ToString();
-			}
-			
-			// extensions
-			url.Append("?");
-			if (extensions != null)
-			{
-				for (int i = 0; i < extensions.Length; i++)
-				{
-					url.Append(extensions[i]);
-					if (i < (extensions.Length - 1))
-					{
-						url.Append(",");
-					}
-				}
-			}
-			return url.ToString();
-		}
-		
-		private System.String[] parseList(System.String listStr, char delimiter, int listStart, int listEnd)
-		// end of list + 1
-		{
-			System.String[] list;
-			// Check for and empty string
-			if ((listEnd - listStart) < 1)
-			{
-				return null;
-			}
-			// First count how many items are specified
-			int itemStart = listStart;
-			int itemEnd;
-			int itemCount = 0;
-			while (itemStart > 0)
-			{
-				// itemStart == 0 if no delimiter found
-				itemCount += 1;
-				itemEnd = listStr.IndexOf((System.Char) delimiter, itemStart);
-				if ((itemEnd > 0) && (itemEnd < listEnd))
-				{
-					itemStart = itemEnd + 1;
-				}
-				else
-				{
-					break;
-				}
-			}
-			// Now fill in the array with the attributes
-			itemStart = listStart;
-			list = new System.String[itemCount];
-			itemCount = 0;
-			while (itemStart > 0)
-			{
-				itemEnd = listStr.IndexOf((System.Char) delimiter, itemStart);
-				if (itemStart <= listEnd)
-				{
-					if (itemEnd < 0)
-						itemEnd = listEnd;
-					if (itemEnd > listEnd)
-						itemEnd = listEnd;
-					list[itemCount] = listStr.Substring(itemStart, (itemEnd) - (itemStart));
-					itemStart = itemEnd + 1;
-					itemCount += 1;
-				}
-				else
-				{
-					break;
-				}
-			}
-			return list;
-		}
-		
-		
-		private void  parseURL(System.String url)
-		{
-			int scanStart = 0;
-			int scanEnd = url.Length;
-			
-			if ((System.Object) url == null)
-				throw new System.UriFormatException("LdapUrl: URL cannot be null");
-			
-			// Check if URL is enclosed by < & >
-			if (url[scanStart] == '<')
-			{
-				if (url[scanEnd - 1] != '>')
-					throw new System.UriFormatException("LdapUrl: URL bad enclosure");
-				scanStart += 1;
-				scanEnd -= 1;
-			}
-			
-			// Determine the URL scheme and set appropriate default port
-			if (url.Substring(scanStart, (scanStart + 4) - (scanStart)).ToUpper().Equals("URL:".ToUpper()))
-			{
-				scanStart += 4;
-			}
-			if (url.Substring(scanStart, (scanStart + 7) - (scanStart)).ToUpper().Equals("ldap://".ToUpper()))
-			{
-				scanStart += 7;
-				port = LdapConnection.DEFAULT_PORT;
-			}
-			else if (url.Substring(scanStart, (scanStart + 8) - (scanStart)).ToUpper().Equals("ldaps://".ToUpper()))
-			{
-				secure = true;
-				scanStart += 8;
-				port = LdapConnection.DEFAULT_SSL_PORT;
-			}
-			else
-			{
-				throw new System.UriFormatException("LdapUrl: URL scheme is not ldap");
-			}
-			
-			// Find where host:port ends and dn begins
-			int dnStart = url.IndexOf("/", scanStart);
-			int hostPortEnd = scanEnd;
-			bool novell = false;
-			if (dnStart < 0)
-			{
-				/*
-				* Kludge. check for ldap://111.222.333.444:389??cn=abc,o=company
-				*
-				* Check for broken Novell referral format.  The dn is in
-				* the scope position, but the required slash is missing.
-				* This is illegal syntax but we need to account for it.
-				* Fortunately it can't be confused with anything real.
-				*/
-				dnStart = url.IndexOf("?", scanStart);
-				if (dnStart > 0)
-				{
-					if (url[dnStart + 1] == '?')
-					{
-						hostPortEnd = dnStart;
-						dnStart += 1;
-						novell = true;
-					}
-					else
-					{
-						dnStart = - 1;
-					}
-				}
-			}
-			else
-			{
-				hostPortEnd = dnStart;
-			}
-			// Check for IPV6 "[ipaddress]:port"
-			int portStart;
-			int hostEnd = hostPortEnd;
-			if (url[scanStart] == '[')
-			{
-				hostEnd = url.IndexOf((System.Char) ']', scanStart + 1);
-				if ((hostEnd >= hostPortEnd) || (hostEnd == - 1))
-				{
-					throw new System.UriFormatException("LdapUrl: \"]\" is missing on IPV6 host name");
-				}
-				// Get host w/o the [ & ]
-				host = url.Substring(scanStart + 1, (hostEnd) - (scanStart + 1));
-				portStart = url.IndexOf(":", hostEnd);
-				if ((portStart < hostPortEnd) && (portStart != - 1))
-				{
-					// port is specified
-					port = System.Int32.Parse(url.Substring(portStart + 1, (hostPortEnd) - (portStart + 1)));
-				}
-				else
-				{
-				}
-			}
-			else
-			{
-				portStart = url.IndexOf(":", scanStart);
-				// Isolate the host and port
-				if ((portStart < 0) || (portStart > hostPortEnd))
-				{
-					// no port is specified, we keep the default
-					host = url.Substring(scanStart, (hostPortEnd) - (scanStart));
-				}
-				else
-				{
-					// port specified in URL
-					host = url.Substring(scanStart, (portStart) - (scanStart));
-					port = System.Int32.Parse(url.Substring(portStart + 1, (hostPortEnd) - (portStart + 1)));
-				}
-			}
-			
-			scanStart = hostPortEnd + 1;
-			if ((scanStart >= scanEnd) || (dnStart < 0))
-				return ;
-			
-			// Parse out the base dn
-			scanStart = dnStart + 1;
-			
-			int attrsStart = url.IndexOf((System.Char) '?', scanStart);
-			if (attrsStart < 0)
-			{
-				dn = url.Substring(scanStart, (scanEnd) - (scanStart));
-			}
-			else
-			{
-				dn = url.Substring(scanStart, (attrsStart) - (scanStart));
-			}
-			
-			scanStart = attrsStart + 1;
-			// Wierd novell syntax can have nothing beyond the dn
-			if ((scanStart >= scanEnd) || (attrsStart < 0) || novell)
-				return ;
-			
-			// Parse out the attributes
-			int scopeStart = url.IndexOf((System.Char) '?', scanStart);
-			if (scopeStart < 0)
-				scopeStart = scanEnd - 1;
-			attrs = parseList(url, ',', attrsStart + 1, scopeStart);
-			
-			scanStart = scopeStart + 1;
-			if (scanStart >= scanEnd)
-				return ;
-			
-			// Parse out the scope
-			int filterStart = url.IndexOf((System.Char) '?', scanStart);
-			System.String scopeStr;
-			if (filterStart < 0)
-			{
-				scopeStr = url.Substring(scanStart, (scanEnd) - (scanStart));
-			}
-			else
-			{
-				scopeStr = url.Substring(scanStart, (filterStart) - (scanStart));
-			}
-			if (scopeStr.ToUpper().Equals("".ToUpper()))
-			{
-				scope = LdapConnection.SCOPE_BASE;
-			}
-			else if (scopeStr.ToUpper().Equals("base".ToUpper()))
-			{
-				scope = LdapConnection.SCOPE_BASE;
-			}
-			else if (scopeStr.ToUpper().Equals("one".ToUpper()))
-			{
-				scope = LdapConnection.SCOPE_ONE;
-			}
-			else if (scopeStr.ToUpper().Equals("sub".ToUpper()))
-			{
-				scope = LdapConnection.SCOPE_SUB;
-			}
-			else
-			{
-				throw new System.UriFormatException("LdapUrl: URL invalid scope");
-			}
-			
-			
-			scanStart = filterStart + 1;
-			if ((scanStart >= scanEnd) || (filterStart < 0))
-				return ;
-			
-			// Parse out the filter
-			scanStart = filterStart + 1;
-			
-			System.String filterStr;
-			int extStart = url.IndexOf((System.Char) '?', scanStart);
-			if (extStart < 0)
-			{
-				filterStr = url.Substring(scanStart, (scanEnd) - (scanStart));
-			}
-			else
-			{
-				filterStr = url.Substring(scanStart, (extStart) - (scanStart));
-			}
-			
-			if (!filterStr.Equals(""))
-			{
-				filter = filterStr; // Only modify if not the default filter
-			}
-			
-			
-			scanStart = extStart + 1;
-			if ((scanStart >= scanEnd) || (extStart < 0))
-				return ;
-			
-			// Parse out the extensions
-			int end = url.IndexOf((System.Char) '?', scanStart);
-			if (end > 0)
-				throw new System.UriFormatException("LdapUrl: URL has too many ? fields");
-			extensions = parseList(url, ',', scanStart, scanEnd);
-			
-			return ;
-		}
-	}
-}
+/******************************************************************************
+* The MIT License
+* Copyright (c) 2003 Novell Inc.  www.novell.com
+* 
+* Permission is hereby granted, free of charge, to any person obtaining  a copy
+* of this software and associated documentation files (the Software), to deal
+* in the Software without restriction, including  without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
+* copies of the Software, and to  permit persons to whom the Software is 
+* furnished to do so, subject to the following conditions:
+* 
+* The above copyright notice and this permission notice shall be included in 
+* all copies or substantial portions of the Software.
+* 
+* THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+* SOFTWARE.
+*******************************************************************************/
+//
+// Novell.Directory.Ldap.LdapUrl.cs
+//
+// Author:
+//   Sunil Kumar (Sunilk@novell.com)
+//
+// (C) 2003 Novell, Inc (http://www.novell.com)
+//
+
+using System;
+using ArrayEnumeration = Novell.Directory.Ldap.Utilclass.ArrayEnumeration;
+
+namespace Novell.Directory.Ldap
+{
+	
+	/// <summary> 
+	/// Encapsulates parameters of an Ldap URL query as defined in RFC2255.
+	/// 
+	/// An LdapUrl object can be passed to LdapConnection.search to retrieve
+	/// search results.
+	/// 
+	/// </summary>
+	/// <seealso cref="LdapConnection.Search">
+	/// </seealso>
+	public class LdapUrl : System.ICloneable
+	{
+		private void  InitBlock()
+		{
+			scope = DEFAULT_SCOPE;
+		}
+		/// <summary> Returns an array of attribute names specified in the URL.
+		/// 
+		/// </summary>
+		/// <returns> An array of attribute names in the URL.
+		/// </returns>
+		virtual public System.String[] AttributeArray
+		{
+			get
+			{
+				return attrs;
+			}
+			
+		}
+		/// <summary> Returns an enumerator for the attribute names specified in the URL.
+		/// 
+		/// </summary>
+		/// <returns> An enumeration of attribute names.
+		/// </returns>
+		virtual public System.Collections.IEnumerator Attributes
+		{
+			get
+			{
+				return new ArrayEnumeration(attrs);
+			}
+			
+		}
+		/// <summary> Returns any Ldap URL extensions specified, or null if none are
+		/// specified. Each extension is a type=value expression. The =value part
+		/// MAY be omitted. The expression MAY be prefixed with '!' if it is
+		/// mandatory for evaluation of the URL.
+		/// 
+		/// </summary>
+		/// <returns> string array of extensions.
+		/// </returns>
+		virtual public System.String[] Extensions
+		{
+			get
+			{
+				return extensions;
+			}
+			
+		}
+		/// <summary> Returns the search filter or <code>null</code> if none was specified.
+		/// 
+		/// </summary>
+		/// <returns> The search filter.
+		/// </returns>
+		virtual public System.String Filter
+		{
+			get
+			{
+				return filter;
+			}
+			
+		}
+		/// <summary> Returns the name of the Ldap server in the URL.
+		/// 
+		/// </summary>
+		/// <returns> The host name specified in the URL.
+		/// </returns>
+		virtual public System.String Host
+		{
+			get
+			{
+				return host;
+			}
+			
+		}
+		/// <summary> Returns the port number of the Ldap server in the URL.
+		/// 
+		/// </summary>
+		/// <returns> The port number in the URL.
+		/// </returns>
+		virtual public int Port
+		{
+			get
+			{
+				if (port == 0)
+				{
+					return LdapConnection.DEFAULT_PORT;
+				}
+				return port;
+			}
+			
+		}
+		/// <summary> Returns the depth of search. It returns one of the following from
+		/// LdapConnection: SCOPE_BASE, SCOPE_ONE, or SCOPE_SUB.
+		/// 
+		/// </summary>
+		/// <returns> The search scope.
+		/// </returns>
+		virtual public int Scope
+		{
+			get
+			{
+				return scope;
+			}
+			
+		}
+		/// <summary> Returns true if the URL is of the type ldaps (Ldap over SSL, a predecessor
+		/// to startTls)
+		/// 
+		/// </summary>
+		/// <returns> whether this is a secure Ldap url or not.
+		/// </returns>
+		virtual public bool Secure
+		{
+			get
+			{
+				return secure;
+			}
+			
+		}
+		private static readonly int DEFAULT_SCOPE = LdapConnection.SCOPE_BASE;
+		
+		// Broken out parts of the URL
+		private bool secure = false; // URL scheme ldap/ldaps
+		private bool ipV6 = false; // TCP/IP V6
+		private System.String host = null; // Host
+		private int port = 0; // Port
+		private System.String dn = null; // Base DN
+		private System.String[] attrs = null; // Attributes
+		private System.String filter = null; // Filter
+		private int scope; // Scope
+		private System.String[] extensions = null; // Extensions
+		
+		/// <summary> Constructs a URL object with the specified string as the URL.
+		/// 
+		/// </summary>
+		/// <param name="url">     An Ldap URL string, e.g.
+		/// "ldap://ldap.example.com:80/dc=example,dc=com?cn,
+		/// sn?sub?(objectclass=inetOrgPerson)".
+		/// 
+		/// </param>
+		/// <exception> MalformedURLException The specified URL cannot be parsed.
+		/// </exception>
+		public LdapUrl(System.String url)
+		{
+			InitBlock();
+			parseURL(url);
+			return ;
+		}
+		
+		
+		/// <summary> Constructs a URL object with the specified host, port, and DN.
+		/// 
+		/// This form is used to create URL references to a particular object
+		/// in the directory.
+		/// 
+		/// </summary>
+		/// <param name="host">    Host identifier of Ldap server, or null for
+		/// "localhost".
+		/// 
+		/// </param>
+		/// <param name="port">    The port number for Ldap server (use
+		/// LdapConnection.DEFAULT_PORT for default port).
+		/// 
+		/// </param>
+		/// <param name="dn">      Distinguished name of the base object of the search.
+		/// 
+		/// </param>
+		public LdapUrl(System.String host, int port, System.String dn)
+		{
+			InitBlock();
+			this.host = host;
+			this.port = port;
+			this.dn = dn;
+			return ;
+		}
+		
+		/// <summary> Constructs an Ldap URL with all fields explicitly assigned, to
+		/// specify an Ldap search operation.
+		/// 
+		/// </summary>
+		/// <param name="host">    Host identifier of Ldap server, or null for
+		/// "localhost".
+		/// 
+		/// </param>
+		/// <param name="port">    The port number for Ldap server (use
+		/// LdapConnection.DEFAULT_PORT for default port).
+		/// 
+		/// </param>
+		/// <param name="dn">      Distinguished name of the base object of the search.
+		/// 
+		/// 
+		/// </param>
+		/// <param name="attrNames">Names or OIDs of attributes to retrieve.  Passing a
+		/// null array signifies that all user attributes are to be
+		/// retrieved. Passing a value of "*" allows you to specify
+		/// that all user attributes as well as any specified
+		/// operational attributes are to be retrieved.
+		/// 
+		/// 
+		/// </param>
+		/// <param name="scope">   Depth of search (in DN namespace). Use one of
+		/// SCOPE_BASE, SCOPE_ONE, SCOPE_SUB from LdapConnection.
+		/// 
+		/// 
+		/// </param>
+		/// <param name="filter">  The search filter specifying the search criteria.
+		/// 
+		/// 
+		/// </param>
+		/// <param name="extensions"> Extensions provide a mechanism to extend the
+		/// functionality of Ldap URLs. Currently no
+		/// Ldap URL extensions are defined. Each extension
+		/// specification is a type=value expression, and  may
+		/// be <code>null</code> or empty.  The =value part may be
+		/// omitted. The expression may be prefixed with '!' if it
+		/// is mandatory for the evaluation of the URL.
+		/// </param>
+		public LdapUrl(System.String host, int port, System.String dn, System.String[] attrNames, int scope, System.String filter, System.String[] extensions)
+		{
+			InitBlock();
+			this.host = host;
+			this.port = port;
+			this.dn = dn;
+			this.attrs = new System.String[attrNames.Length];
+			attrNames.CopyTo(this.attrs, 0);
+			this.scope = scope;
+			this.filter = filter;
+			this.extensions = new System.String[extensions.Length];
+			extensions.CopyTo(this.extensions, 0);
+			return ;
+		}
+		
+		/// <summary> Constructs an Ldap URL with all fields explicitly assigned, including
+		/// isSecure, to specify an Ldap search operation.
+		/// 
+		/// </summary>
+		/// <param name="host">    Host identifier of Ldap server, or null for
+		/// "localhost".
+		/// 
+		/// 
+		/// </param>
+		/// <param name="port">    The port number for Ldap server (use
+		/// LdapConnection.DEFAULT_PORT for default port).
+		/// 
+		/// 
+		/// </param>
+		/// <param name="dn">      Distinguished name of the base object of the search.
+		/// 
+		/// 
+		/// </param>
+		/// <param name="attrNames">Names or OIDs of attributes to retrieve.  Passing a
+		/// null array signifies that all user attributes are to be
+		/// retrieved. Passing a value of "*" allows you to specify
+		/// that all user attributes as well as any specified
+		/// operational attributes are to be retrieved.
+		/// 
+		/// 
+		/// </param>
+		/// <param name="scope">   Depth of search (in DN namespace). Use one of
+		/// SCOPE_BASE, SCOPE_ONE, SCOPE_SUB from LdapConnection.
+		/// 
+		/// 
+		/// </param>
+		/// <param name="filter">  The search filter specifying the search criteria.
+		/// from LdapConnection: SCOPE_BASE, SCOPE_ONE, SCOPE_SUB.
+		/// 
+		/// 
+		/// </param>
+		/// <param name="extensions"> Extensions provide a mechanism to extend the
+		/// functionality of Ldap URLs. Currently no
+		/// Ldap URL extensions are defined. Each extension
+		/// specification is a type=value expression, and  may
+		/// be <code>null</code> or empty.  The =value part may be
+		/// omitted. The expression may be prefixed with '!' if it
+		/// is mandatory for the evaluation of the URL.
+		/// 
+		/// 
+		/// </param>
+		/// <param name="secure">  If true creates an Ldap URL of the ldaps type
+		/// </param>
+		public LdapUrl(System.String host, int port, System.String dn, System.String[] attrNames, int scope, System.String filter, System.String[] extensions, bool secure)
+		{
+			InitBlock();
+			this.host = host;
+			this.port = port;
+			this.dn = dn;
+			this.attrs = attrNames;
+			this.scope = scope;
+			this.filter = filter;
+			this.extensions = new System.String[extensions.Length];
+			extensions.CopyTo(this.extensions, 0);
+			this.secure = secure;
+			return ;
+		}
+		
+		/// <summary> Returns a clone of this URL object.
+		/// 
+		/// </summary>
+		/// <returns> clone of this URL object.
+		/// </returns>
+		public System.Object Clone()
+		{
+			try
+			{
+				return base.MemberwiseClone();
+			}
+			catch (System.Exception ce)
+			{
+				throw new System.SystemException("Internal error, cannot create clone");
+			}
+		}
+		
+		/// <summary> Decodes a URL-encoded string.
+		/// 
+		/// Any occurences of %HH are decoded to the hex value represented.
+		/// However, this method does NOT decode "+" into " ".
+		/// 
+		/// </summary>
+		/// <param name="URLEncoded">    String to decode.
+		/// 
+		/// </param>
+		/// <returns> The decoded string.
+		/// 
+		/// </returns>
+		/// <exception> MalformedURLException The URL could not be parsed.
+		/// </exception>
+		public static System.String decode(System.String URLEncoded)
+		{
+			
+			
+			int searchStart = 0;
+			int fieldStart;
+			
+			fieldStart = URLEncoded.IndexOf("%", searchStart);
+			// Return now if no encoded data
+			if (fieldStart < 0)
+			{
+				return URLEncoded;
+			}
+			
+			// Decode the %HH value and copy to new string buffer
+			int fieldEnd = 0; // end of previous field
+			int dataLen = URLEncoded.Length;
+			
+			System.Text.StringBuilder decoded = new System.Text.StringBuilder(dataLen);
+			
+			while (true)
+			{
+				if (fieldStart > (dataLen - 3))
+				{
+					throw new System.UriFormatException("LdapUrl.decode: must be two hex characters following escape character '%'");
+				}
+				if (fieldStart < 0)
+					fieldStart = dataLen;
+				// Copy to string buffer from end of last field to start of next
+				decoded.Append(URLEncoded.Substring(fieldEnd, (fieldStart) - (fieldEnd)));
+				fieldStart += 1;
+				if (fieldStart >= dataLen)
+					break;
+				fieldEnd = fieldStart + 2;
+				try
+				{
+					decoded.Append((char) System.Convert.ToInt32(URLEncoded.Substring(fieldStart, (fieldEnd) - (fieldStart)), 16));
+				}
+				catch (System.FormatException ex)
+				{
+					throw new System.UriFormatException("LdapUrl.decode: error converting hex characters to integer \"" + ex.Message + "\"");
+				}
+				searchStart = fieldEnd;
+				if (searchStart == dataLen)
+					break;
+				fieldStart = URLEncoded.IndexOf("%", searchStart);
+			}
+			
+			return (decoded.ToString());
+		}
+		
+		/// <summary> Encodes an arbitrary string using the URL encoding rules.
+		/// 
+		///  Any illegal characters are encoded as %HH. 
+		/// 
+		/// </summary>
+		/// <param name="toEncode">    The string to encode.
+		/// 
+		/// </param>
+		/// <returns> The URL-encoded string.
+		/// 
+		/// Comment: An illegal character consists of any non graphical US-ASCII character, Unsafe, or reserved characters.
+		/// </returns>
+		public static System.String encode(System.String toEncode)
+		{
+			System.Text.StringBuilder buffer = new System.Text.StringBuilder(toEncode.Length); //empty but initial capicity of 'length'
+			System.String temp;
+			char currChar;
+			for (int i = 0; i < toEncode.Length; i++)
+			{
+				currChar = toEncode[i];
+				if ((((int) currChar <= 0x1F) || ((int) currChar == 0x7F) || (((int) currChar >= 0x80) && ((int) currChar <= 0xFF))) || ((currChar == '<') || (currChar == '>') || (currChar == '\"') || (currChar == '#') || (currChar == '%') || (currChar == '{') || (currChar == '}') || (currChar == '|') || (currChar == '\\') || (currChar == '^') || (currChar == '~') || (currChar == '[') || (currChar == '\'')) || ((currChar == ';') || (currChar == '/') || (currChar == '?') || (currChar == ':') || (currChar == '@') || (currChar == '=') || (currChar == '&')))
+				{
+					temp = System.Convert.ToString(currChar, 16);
+					if (temp.Length == 1)
+						buffer.Append("%0" + temp);
+					//if(temp.length()==2) this can only be two or one digit long.
+					else
+						buffer.Append("%" + System.Convert.ToString(currChar, 16));
+				}
+				else
+					buffer.Append(currChar);
+			}
+			return buffer.ToString();
+		}
+		
+		/// <summary> Returns the base distinguished name encapsulated in the URL.
+		/// 
+		/// </summary>
+		/// <returns> The base distinguished name specified in the URL, or null if none.
+		/// </returns>
+		public virtual System.String getDN()
+		{
+			return dn;
+		}
+		
+		/// <summary> Sets the base distinguished name encapsulated in the URL.</summary>
+		/* package */
+		internal virtual void  setDN(System.String dn)
+		{
+			this.dn = dn;
+			return ;
+		}
+		
+		/// <summary> Returns a valid string representation of this Ldap URL.
+		/// 
+		/// </summary>
+		/// <returns> The string representation of the Ldap URL.
+		/// </returns>
+		public override System.String ToString()
+		{
+			System.Text.StringBuilder url = new System.Text.StringBuilder(256);
+			// Scheme
+			if (secure)
+			{
+				url.Append("ldaps://");
+			}
+			else
+			{
+				url.Append("ldap://");
+			}
+			// Host:port/dn
+			if (ipV6)
+			{
+				url.Append("[" + host + "]");
+			}
+			else
+			{
+				url.Append(host);
+			}
+			
+			// Port not specified
+			if (port != 0)
+			{
+				url.Append(":" + port);
+			}
+			
+			if (((System.Object) dn == null) && (attrs == null) && (scope == DEFAULT_SCOPE) && ((System.Object) filter == null) && (extensions == null))
+			{
+				return url.ToString();
+			}
+			
+			url.Append("/");
+			
+			if ((System.Object) dn != null)
+			{
+				url.Append(dn);
+			}
+			
+			if ((attrs == null) && (scope == DEFAULT_SCOPE) && ((System.Object) filter == null) && (extensions == null))
+			{
+				return url.ToString();
+			}
+			
+			// attributes
+			url.Append("?");
+			if (attrs != null)
+			{
+				//should we check also for attrs != "*"
+				for (int i = 0; i < attrs.Length; i++)
+				{
+					url.Append(attrs[i]);
+					if (i < (attrs.Length - 1))
+					{
+						url.Append(",");
+					}
+				}
+			}
+			
+			if ((scope == DEFAULT_SCOPE) && ((System.Object) filter == null) && (extensions == null))
+			{
+				return url.ToString();
+			}
+			
+			// scope
+			url.Append("?");
+			if (scope != DEFAULT_SCOPE)
+			{
+				if (scope == LdapConnection.SCOPE_ONE)
+				{
+					url.Append("one");
+				}
+				else
+				{
+					url.Append("sub");
+				}
+			}
+			
+			if (((System.Object) filter == null) && (extensions == null))
+			{
+				return url.ToString();
+			}
+			
+			// filter
+			if ((System.Object) filter == null)
+			{
+				url.Append("?");
+			}
+			else
+			{
+				url.Append("?" + Filter);
+			}
+			
+			if (extensions == null)
+			{
+				return url.ToString();
+			}
+			
+			// extensions
+			url.Append("?");
+			if (extensions != null)
+			{
+				for (int i = 0; i < extensions.Length; i++)
+				{
+					url.Append(extensions[i]);
+					if (i < (extensions.Length - 1))
+					{
+						url.Append(",");
+					}
+				}
+			}
+			return url.ToString();
+		}
+		
+		private System.String[] parseList(System.String listStr, char delimiter, int listStart, int listEnd)
+		// end of list + 1
+		{
+			System.String[] list;
+			// Check for and empty string
+			if ((listEnd - listStart) < 1)
+			{
+				return null;
+			}
+			// First count how many items are specified
+			int itemStart = listStart;
+			int itemEnd;
+			int itemCount = 0;
+			while (itemStart > 0)
+			{
+				// itemStart == 0 if no delimiter found
+				itemCount += 1;
+				itemEnd = listStr.IndexOf((System.Char) delimiter, itemStart);
+				if ((itemEnd > 0) && (itemEnd < listEnd))
+				{
+					itemStart = itemEnd + 1;
+				}
+				else
+				{
+					break;
+				}
+			}
+			// Now fill in the array with the attributes
+			itemStart = listStart;
+			list = new System.String[itemCount];
+			itemCount = 0;
+			while (itemStart > 0)
+			{
+				itemEnd = listStr.IndexOf((System.Char) delimiter, itemStart);
+				if (itemStart <= listEnd)
+				{
+					if (itemEnd < 0)
+						itemEnd = listEnd;
+					if (itemEnd > listEnd)
+						itemEnd = listEnd;
+					list[itemCount] = listStr.Substring(itemStart, (itemEnd) - (itemStart));
+					itemStart = itemEnd + 1;
+					itemCount += 1;
+				}
+				else
+				{
+					break;
+				}
+			}
+			return list;
+		}
+		
+		
+		private void  parseURL(System.String url)
+		{
+			int scanStart = 0;
+			int scanEnd = url.Length;
+			
+			if ((System.Object) url == null)
+				throw new System.UriFormatException("LdapUrl: URL cannot be null");
+			
+			// Check if URL is enclosed by < & >
+			if (url[scanStart] == '<')
+			{
+				if (url[scanEnd - 1] != '>')
+					throw new System.UriFormatException("LdapUrl: URL bad enclosure");
+				scanStart += 1;
+				scanEnd -= 1;
+			}
+			
+			// Determine the URL scheme and set appropriate default port
+			if (url.Substring(scanStart, (scanStart + 4) - (scanStart)).ToUpper().Equals("URL:".ToUpper()))
+			{
+				scanStart += 4;
+			}
+			if (url.Substring(scanStart, (scanStart + 7) - (scanStart)).ToUpper().Equals("ldap://".ToUpper()))
+			{
+				scanStart += 7;
+				port = LdapConnection.DEFAULT_PORT;
+			}
+			else if (url.Substring(scanStart, (scanStart + 8) - (scanStart)).ToUpper().Equals("ldaps://".ToUpper()))
+			{
+				secure = true;
+				scanStart += 8;
+				port = LdapConnection.DEFAULT_SSL_PORT;
+			}
+			else
+			{
+				throw new System.UriFormatException("LdapUrl: URL scheme is not ldap");
+			}
+			
+			// Find where host:port ends and dn begins
+			int dnStart = url.IndexOf("/", scanStart);
+			int hostPortEnd = scanEnd;
+			bool novell = false;
+			if (dnStart < 0)
+			{
+				/*
+				* Kludge. check for ldap://111.222.333.444:389??cn=abc,o=company
+				*
+				* Check for broken Novell referral format.  The dn is in
+				* the scope position, but the required slash is missing.
+				* This is illegal syntax but we need to account for it.
+				* Fortunately it can't be confused with anything real.
+				*/
+				dnStart = url.IndexOf("?", scanStart);
+				if (dnStart > 0)
+				{
+					if (url[dnStart + 1] == '?')
+					{
+						hostPortEnd = dnStart;
+						dnStart += 1;
+						novell = true;
+					}
+					else
+					{
+						dnStart = - 1;
+					}
+				}
+			}
+			else
+			{
+				hostPortEnd = dnStart;
+			}
+			// Check for IPV6 "[ipaddress]:port"
+			int portStart;
+			int hostEnd = hostPortEnd;
+			if (url[scanStart] == '[')
+			{
+				hostEnd = url.IndexOf((System.Char) ']', scanStart + 1);
+				if ((hostEnd >= hostPortEnd) || (hostEnd == - 1))
+				{
+					throw new System.UriFormatException("LdapUrl: \"]\" is missing on IPV6 host name");
+				}
+				// Get host w/o the [ & ]
+				host = url.Substring(scanStart + 1, (hostEnd) - (scanStart + 1));
+				portStart = url.IndexOf(":", hostEnd);
+				if ((portStart < hostPortEnd) && (portStart != - 1))
+				{
+					// port is specified
+					port = System.Int32.Parse(url.Substring(portStart + 1, (hostPortEnd) - (portStart + 1)));
+				}
+				else
+				{
+				}
+			}
+			else
+			{
+				portStart = url.IndexOf(":", scanStart);
+				// Isolate the host and port
+				if ((portStart < 0) || (portStart > hostPortEnd))
+				{
+					// no port is specified, we keep the default
+					host = url.Substring(scanStart, (hostPortEnd) - (scanStart));
+				}
+				else
+				{
+					// port specified in URL
+					host = url.Substring(scanStart, (portStart) - (scanStart));
+					port = System.Int32.Parse(url.Substring(portStart + 1, (hostPortEnd) - (portStart + 1)));
+				}
+			}
+			
+			scanStart = hostPortEnd + 1;
+			if ((scanStart >= scanEnd) || (dnStart < 0))
+				return ;
+			
+			// Parse out the base dn
+			scanStart = dnStart + 1;
+			
+			int attrsStart = url.IndexOf((System.Char) '?', scanStart);
+			if (attrsStart < 0)
+			{
+				dn = url.Substring(scanStart, (scanEnd) - (scanStart));
+			}
+			else
+			{
+				dn = url.Substring(scanStart, (attrsStart) - (scanStart));
+			}
+			
+			scanStart = attrsStart + 1;
+			// Wierd novell syntax can have nothing beyond the dn
+			if ((scanStart >= scanEnd) || (attrsStart < 0) || novell)
+				return ;
+			
+			// Parse out the attributes
+			int scopeStart = url.IndexOf((System.Char) '?', scanStart);
+			if (scopeStart < 0)
+				scopeStart = scanEnd - 1;
+			attrs = parseList(url, ',', attrsStart + 1, scopeStart);
+			
+			scanStart = scopeStart + 1;
+			if (scanStart >= scanEnd)
+				return ;
+			
+			// Parse out the scope
+			int filterStart = url.IndexOf((System.Char) '?', scanStart);
+			System.String scopeStr;
+			if (filterStart < 0)
+			{
+				scopeStr = url.Substring(scanStart, (scanEnd) - (scanStart));
+			}
+			else
+			{
+				scopeStr = url.Substring(scanStart, (filterStart) - (scanStart));
+			}
+			if (scopeStr.ToUpper().Equals("".ToUpper()))
+			{
+				scope = LdapConnection.SCOPE_BASE;
+			}
+			else if (scopeStr.ToUpper().Equals("base".ToUpper()))
+			{
+				scope = LdapConnection.SCOPE_BASE;
+			}
+			else if (scopeStr.ToUpper().Equals("one".ToUpper()))
+			{
+				scope = LdapConnection.SCOPE_ONE;
+			}
+			else if (scopeStr.ToUpper().Equals("sub".ToUpper()))
+			{
+				scope = LdapConnection.SCOPE_SUB;
+			}
+			else
+			{
+				throw new System.UriFormatException("LdapUrl: URL invalid scope");
+			}
+			
+			
+			scanStart = filterStart + 1;
+			if ((scanStart >= scanEnd) || (filterStart < 0))
+				return ;
+			
+			// Parse out the filter
+			scanStart = filterStart + 1;
+			
+			System.String filterStr;
+			int extStart = url.IndexOf((System.Char) '?', scanStart);
+			if (extStart < 0)
+			{
+				filterStr = url.Substring(scanStart, (scanEnd) - (scanStart));
+			}
+			else
+			{
+				filterStr = url.Substring(scanStart, (extStart) - (scanStart));
+			}
+			
+			if (!filterStr.Equals(""))
+			{
+				filter = filterStr; // Only modify if not the default filter
+			}
+			
+			
+			scanStart = extStart + 1;
+			if ((scanStart >= scanEnd) || (extStart < 0))
+				return ;
+			
+			// Parse out the extensions
+			int end = url.IndexOf((System.Char) '?', scanStart);
+			if (end > 0)
+				throw new System.UriFormatException("LdapUrl: URL has too many ? fields");
+			extensions = parseList(url, ',', scanStart, scanEnd);
+			
+			return ;
+		}
+	}
+}
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapLocalException.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapLocalException.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapLocalException.cs	(working copy)
@@ -157,7 +157,8 @@
 		public override System.String ToString()
 		{
 			// Format the basic exception information
-			return getExceptionString("LdapLocalException");
+            string ex = getExceptionString("LdapLocalException") + Environment.NewLine + this.StackTrace.ToString();
+            return ex;
 		}
 	}
 }
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapReferralException.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapReferralException.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapReferralException.cs	(working copy)
@@ -274,7 +274,7 @@
 				{
 					tmsg = "LdapReferralException: Failed Referral: " + failedReferral;
 				}
-				msg = msg + '\n' + tmsg;
+				msg = msg + Environment.NewLine + tmsg;
 			}
 			
 			// Add referral information, display all the referrals in the list
@@ -287,10 +287,13 @@
 					if (tmsg.ToUpper().Equals("SERVER_MSG".ToUpper()))
 					{
 						tmsg = "LdapReferralException: Referral: " + referrals[i];
-					}
-					msg = msg + '\n' + tmsg;
+					}
+                    msg = msg + Environment.NewLine + tmsg;
 				}
-			}
+			}
+
+            msg = msg + Environment.NewLine + this.StackTrace.ToString();
+
 			return msg;
 		}
 	}
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/Message.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/Message.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/Message.cs	(working copy)
@@ -419,9 +419,10 @@
 
 		private void  cleanup()
 		{
-			stopTimer(); // Make sure timer stopped
 			try
-			{
+			{
+				stopTimer(); // Make sure timer stopped
+				
 				acceptReplies = false;
 				if (conn != null)
 				{
@@ -468,7 +469,7 @@
 			}
 			lock(replies)
 			{
-			replies.Add(message);
+				replies.Add(message);
 			}
 			message.RequestingMessage = msg; // Save request message info
 			switch (message.Type)
@@ -549,7 +550,7 @@
 				System.Threading.Monitor.Pulse(replies);
 			}
 			// Notify a thread waiting for any message id
-			agent.sleepersAwake(false);
+			agent.sleepersAwake(true);
 			return ;
 		}
 
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapBindRequest.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapBindRequest.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapBindRequest.cs	(working copy)
@@ -88,36 +88,7 @@
 		{
 			return ;
 		}
-
-		/// <summary> Constructs a secure bind request.
-		/// 
-		/// </summary>
-		/// <param name="version"> The Ldap protocol version, use Ldap_V3.
-		/// Ldap_V2 is not supported.
-		/// 
-		/// </param>
-		/// <param name="dn">     If non-null and non-empty, specifies that the
-		/// connection and all operations through it should
-		/// be authenticated with dn as the distinguished
-		/// name.
-		/// 
-		/// </param>
-		/// <param name="mechanism"> Security mechanism code
-		/// 
-		/// </param>
-		/// <param name="passwd"> Security credentials
-		/// 
-		/// </param>
-		/// <param name="cont">Any controls that apply to the simple bind request,
-		/// or null if none.
-		/// </param>
-		[CLSCompliantAttribute(false)]
-		public LdapBindRequest(int version, System.String dn, String mechanism, sbyte[] credentials, LdapControl[] 		
-		cont):base(LdapMessage.BIND_REQUEST, new RfcBindRequest(version, dn, mechanism, credentials), cont)
-		{
-			return ;
-		}
- 		
+		
 		/// <summary> Return an Asn1 representation of this add request.
 		/// 
 		/// #return an Asn1 representation of this object.
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/AssemblyInfo.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/AssemblyInfo.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/AssemblyInfo.cs	(working copy)
@@ -48,9 +48,7 @@
 [assembly: AssemblyCopyright(" (C) 2003 Novell, Inc")]
 [assembly: AssemblyTrademark("")]
 [assembly: AssemblyCulture("")]		
-#if !TARGET_JVM 
 [assembly: CLSCompliant(true)]
-#endif
 
 //
 // Version information for an assembly consists of the following four values:
@@ -63,10 +61,32 @@
 // You can specify all the values or you can default the Revision and Build Numbers 
 // by using the '*' as shown below:
 
-[assembly: AssemblyVersion (Consts.FxVersion)]
+[assembly: AssemblyVersion("2.1.3")]
 
-#if (!TARGET_JVM)
-[assembly: AssemblyDelaySign (true)]
-[assembly: AssemblyKeyFile ("../mono.pub")]
-#endif
-
+//
+// In order to sign your assembly you must specify a key to use. Refer to the 
+// Microsoft .NET Framework documentation for more information on assembly signing.
+//
+// Use the attributes below to control which key is used for signing. 
+//
+// Notes: 
+//   (*) If no key is specified, the assembly is not signed.
+//   (*) KeyName refers to a key that has been installed in the Crypto Service
+//       Provider (CSP) on your machine. KeyFile refers to a file which contains
+//       a key.
+//   (*) If the KeyFile and the KeyName values are both specified, the 
+//       following processing occurs:
+//       (1) If the KeyName can be found in the CSP, that key is used.
+//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
+//           in the KeyFile is installed into the CSP and used.
+//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
+//       When specifying the KeyFile, the location of the KeyFile should be
+//       relative to the project output directory which is
+//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
+//       located in the project directory, you would specify the AssemblyKeyFile 
+//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
+//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
+//       documentation for more information on this.
+//
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyName("CoversantStrongName")]
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapSearchConstraints.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapSearchConstraints.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapSearchConstraints.cs	(working copy)
@@ -238,9 +238,9 @@
 		private int serverTimeLimit = 0;
 		private int maxResults = 1000;
 		private int batchSize = 1;
-		new private static System.Object nameLock; // protect agentNum
+		private static System.Object nameLock; // protect agentNum
 		private static int lSConsNum = 0; // Debug, LdapConnection number
-		new private System.String name; // String name for debug
+		private System.String name; // String name for debug
 		
 		/// <summary> Indicates that aliases are never dereferenced.
 		/// 
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapResponse.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapResponse.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/LdapResponse.cs	(working copy)
@@ -198,7 +198,6 @@
 					
 					default: 
 						ex = new LdapException(LdapException.resultCodeToString(ResultCode), ResultCode, ErrorMessage, MatchedDN);
-//						ex = new LdapException("49", 49, "hello error", "hi error..");
 						break;
 					
 				}
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/MessageAgent.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/MessageAgent.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/MessageAgent.cs	(working copy)
@@ -139,18 +139,20 @@
 			{
 				messages.Add(msgs[i]);
 				((Message) (msgs[i])).Agent = this;
+			}
+
+			lock (messages.SyncRoot)
+			{
+				if (msgs.Length > 1)
+				{
+					System.Threading.Monitor.PulseAll(messages.SyncRoot); // wake all threads waiting for messages
+				}
+				else if (msgs.Length == 1)
+				{
+					System.Threading.Monitor.Pulse(messages.SyncRoot); // only wake one thread
+				}
 			}
-			lock (messages)
-			{
-				if (msgs.Length > 1)
-				{
-					System.Threading.Monitor.PulseAll(messages); // wake all threads waiting for messages
-				}
-				else if (msgs.Length == 1)
-				{
-					System.Threading.Monitor.Pulse(messages); // only wake one thread
-				}
-			}
+
 			return ;
 		}
 		
@@ -160,14 +162,15 @@
 		/// </summary>
 		/* package */
 		internal void  sleepersAwake(bool all)
-		{
-			lock (messages)
-			{
-				if (all)
-					System.Threading.Monitor.PulseAll(messages);
-				else
-					System.Threading.Monitor.Pulse(messages);
+		{
+			lock (messages.SyncRoot)
+			{
+				if (all)
+					System.Threading.Monitor.PulseAll(messages.SyncRoot);
+				else
+					System.Threading.Monitor.Pulse(messages.SyncRoot);
 			}
+
 			return ;
 		}
 		
@@ -367,13 +370,14 @@
 			}
 			else
 			{
-				// A msgId was NOT specified, any message will do
-				lock (messages)
-				{
+				// A msgId was NOT specified, any message will do
+				lock (messages.SyncRoot)
+				{
 					while (true)
 					{
 						int next = indexLastRead + 1;
-						Message info;
+						Message info;
+
 						for (int i = 0; i < messages.Count; i++)
 						{
 							if (next >= messages.Count)
@@ -408,17 +412,18 @@
 						if (messages.Count == 0)
 						{
 							return null;
-						}
-						
-						// No data, wait for something to come in.
-						try
-						{
-							System.Threading.Monitor.Wait(messages);
-						}
-						catch (System.Threading.ThreadInterruptedException ex)
-						{
-						}
-					} /* end while */
+						}
+
+						// No data, wait for something to come in.
+						// Don't do this inside the sync lock!!!
+						try
+						{
+							System.Threading.Monitor.Wait(messages.SyncRoot);
+						}
+						catch (System.Threading.ThreadInterruptedException ex)
+						{
+						}
+					} /* end while */
 				} /* end synchronized */
 			}
 		}
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap/MessageVector.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap/MessageVector.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap/MessageVector.cs	(working copy)
@@ -38,8 +38,10 @@
 	/// to Vector needed for handling messages.
 	/// </summary>
 	/* package */
-	class MessageVector:System.Collections.ArrayList
-	{
+	class MessageVector:System.Collections.IList
+	{
+		private System.Collections.ArrayList _innerList;
+
 		/// <summary>Returns an array containing all of the elements in this MessageVector.
 		/// The elements returned are in the same order in the array as in the
 		/// Vector.  The contents of the vector are cleared.
@@ -53,7 +55,7 @@
 			
 			get
 			{
-				lock (this)
+				lock (this.SyncRoot)
 				{
 					System.Object[] results = new System.Object[Count];
 					Array.Copy((System.Array) ToArray(), 0, (System.Array) results, 0, Count);
@@ -68,9 +70,9 @@
 			
 		}
 		/* package */
-		internal MessageVector(int cap, int incr):base(cap)
-		{
-			return ;
+		internal MessageVector(int cap, int incr):base()
+		{
+			_innerList = System.Collections.ArrayList.Synchronized(new System.Collections.ArrayList(cap));
 		}
 		
 		/// <summary> Finds the Message object with the given MsgID, and returns the Message
@@ -88,7 +90,7 @@
 		/* package */
 		internal Message findMessageById(int msgId)
 		{
-			lock (this)
+			lock (this.SyncRoot)
 			{
 				Message msg = null;
 				for (int i = 0; i < Count; i++)
@@ -103,7 +105,108 @@
 					}
 				}
 				throw new System.FieldAccessException();
-			}
-		}
-	}
+			}
+		}
+
+		#region ArrayList members
+		public object[] ToArray()
+		{
+			return _innerList.ToArray();
+		}
+		#endregion
+
+		#region IList Members
+
+		public int Add(object value)
+		{
+			return _innerList.Add(value);
+		}
+
+		public void Clear()
+		{
+			_innerList.Clear();
+		}
+
+		public bool Contains(object value)
+		{
+			return _innerList.Contains(value);
+		}
+
+		public int IndexOf(object value)
+		{
+			return _innerList.IndexOf(value);
+		}
+
+		public void Insert(int index, object value)
+		{
+			_innerList.Insert(index, value);
+		}
+
+		public bool IsFixedSize
+		{
+			get { return _innerList.IsFixedSize; }
+		}
+
+		public bool IsReadOnly
+		{
+			get { return _innerList.IsReadOnly; }
+		}
+
+		public void Remove(object value)
+		{
+			_innerList.Remove(value);
+		}
+
+		public void RemoveAt(int index)
+		{
+			_innerList.RemoveAt(index);
+		}
+
+		public object this[int index]
+		{
+			get
+			{
+				return _innerList[index];
+			}
+			set
+			{
+				_innerList[index] = value;
+			}
+		}
+
+		#endregion
+
+		#region ICollection Members
+
+		public void CopyTo(Array array, int index)
+		{
+			_innerList.CopyTo(array, index);
+		}
+
+		public int Count
+		{
+			get { return _innerList.Count; }
+		}
+
+		public bool IsSynchronized
+		{
+			get { return _innerList.IsSynchronized; }
+		}
+
+		public object SyncRoot
+		{
+			get { return _innerList.SyncRoot; }
+		}
+
+		#endregion
+
+		#region IEnumerable Members
+
+		public System.Collections.IEnumerator GetEnumerator()
+		{
+			return _innerList.GetEnumerator();
+		}
+
+		#endregion
 }
+}
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Enumerated.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Enumerated.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Enumerated.cs	(working copy)
@@ -35,6 +35,7 @@
 {
 	
 	/// <summary> This class encapsulates the ASN.1 ENUMERATED type.</summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1Enumerated:Asn1Numeric
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Choice.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Choice.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Choice.cs	(working copy)
@@ -39,6 +39,7 @@
 	/// </summary>
 	/* Can a CHOICE contain anything BUT a TAGGED Type?
 	*/
+	[CLSCompliantAttribute(true)]
 	public class Asn1Choice:Asn1Object
 	{
 		/// <summary> Sets the CHOICE value stored in this Asn1Choice.
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Set.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Set.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Set.cs	(working copy)
@@ -38,6 +38,7 @@
 	/// distinct type. This class inherits from the Asn1Structured class
 	/// which already provides functionality to hold multiple Asn1 components.
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1Set:Asn1Structured
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Tagged.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Tagged.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Tagged.cs	(working copy)
@@ -46,6 +46,7 @@
 	/// If the type is to be encoded EXPLICITLY, the base type will be encoded as
 	/// usual after the Asn1Tagged identifier has been encoded.
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1Tagged:Asn1Object
 	{
 		/// <summary> Sets the Asn1Object tagged value</summary>
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1SequenceOf.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1SequenceOf.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1SequenceOf.cs	(working copy)
@@ -38,6 +38,7 @@
 	/// from the Asn1Structured class which already provides
 	/// functionality to hold multiple Asn1 components.
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1SequenceOf:Asn1Structured
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Integer.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Integer.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Integer.cs	(working copy)
@@ -35,6 +35,7 @@
 {
 	
 	/// <summary> This class encapsulates the ASN.1 INTEGER type.</summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1Integer:Asn1Numeric
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/LBEREncoder.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/LBEREncoder.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/LBEREncoder.cs	(working copy)
@@ -67,6 +67,7 @@
 	/// Canonical, and Distinguished Encoding Rules", 1994.
 	/// 
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public class LBEREncoder : Asn1Encoder
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Numeric.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Numeric.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Numeric.cs	(working copy)
@@ -38,6 +38,7 @@
 	/// for all Asn1 numeric (integral) types. These include
 	/// Asn1Integer and Asn1Enumerated.
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public abstract class Asn1Numeric:Asn1Object
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Structured.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Structured.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Structured.cs	(working copy)
@@ -37,6 +37,7 @@
 	/// <summary> This class serves as the base type for all ASN.1
 	/// structured types.
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public abstract class Asn1Structured:Asn1Object
 	{
 		private Asn1Object[] content;
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1OctetString.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1OctetString.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1OctetString.cs	(working copy)
@@ -35,6 +35,7 @@
 {
 	
 	/// <summary> This class encapsulates the OCTET STRING type.</summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1OctetString:Asn1Object
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Object.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Object.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Object.cs	(working copy)
@@ -35,6 +35,7 @@
 {
 	
 	/// <summary> This is the base class for all other Asn1 types.</summary>
+	[CLSCompliantAttribute(true)]
 	[Serializable]
 	public abstract class Asn1Object : System.Runtime.Serialization.ISerializable
 	{
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Sequence.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Sequence.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Sequence.cs	(working copy)
@@ -40,6 +40,7 @@
 	/// This class inherits from the Asn1Structured class which
 	/// provides functionality to hold multiple Asn1 components.
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1Sequence:Asn1Structured
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Null.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Null.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Null.cs	(working copy)
@@ -35,6 +35,7 @@
 {
 	
 	/// <summary> This class represents the ASN.1 NULL type.</summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1Null:Asn1Object
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Encoder.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Encoder.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Encoder.cs	(working copy)
@@ -50,6 +50,7 @@
 	/// includes a BER encoder no application provided encoder is needed for 
 	/// building Ldap packets.
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public interface Asn1Encoder : System.Runtime.Serialization.ISerializable
 		{
 			
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Boolean.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Boolean.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Boolean.cs	(working copy)
@@ -35,6 +35,7 @@
 {
 	
 	/// <summary> This class encapsulates the ASN.1 BOOLEAN type.</summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1Boolean:Asn1Object
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1SetOf.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1SetOf.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1SetOf.cs	(working copy)
@@ -38,6 +38,7 @@
 	/// identical type. This class inherits from the Asn1Structured class
 	/// which already provides functionality to hold multiple Asn1 components.
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1SetOf:Asn1Structured
 	{
 		
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Length.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Length.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Length.cs	(working copy)
@@ -37,6 +37,7 @@
 	/// <summary> This class provides a means to manipulate ASN.1 Length's. It will
 	/// be used by Asn1Encoder's and Asn1Decoder's by composition.
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1Length
 	{
 		/// <summary> Returns the length of this Asn1Length.</summary>
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Identifier.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Identifier.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/Asn1Identifier.cs	(working copy)
@@ -72,6 +72,7 @@
 	/// 1 1 1 1 1 (> 30) multiple octet tag, more octets follow
 	/// </pre>
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public class Asn1Identifier:System.Object, System.ICloneable
 	{
 		/// <summary> Returns the CLASS of this Asn1Identifier as an int value.
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/LBERDecoder.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/LBERDecoder.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Asn1/LBERDecoder.cs	(working copy)
@@ -67,6 +67,7 @@
 	/// Canonical, and Distinguished Encoding Rules", 1994.
 	/// 
 	/// </summary>
+	[CLSCompliantAttribute(true)]
 	public class LBERDecoder : Asn1Decoder
 	{
 		public LBERDecoder()
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ResultCodeMessages.txt
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ResultCodeMessages.txt	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ResultCodeMessages.txt	(working copy)
@@ -1,61 +1,61 @@
-0=Success
-1=Operations Error
-2=Protocol Error
-3=Timelimit Exceeded
-4=Sizelimit Exceeded
-5=Compare False
-6=Compare True
-7=Authentication Method Not Supported
-8=Strong Authentication Required
-9=Partial Results
-10=Referral
-11=Administrative Limit Exceeded
-12=Unavailable Critical Extension
-13=Confidentiality Required
-14=SASL Bind In Progress
-16=No Such Attribute
-17=Undefined Attribute Type
-18=Inappropriate Matching
-19=Constraint Violation
-20=Attribute Or Value Exists
-21=Invalid Attribute Syntax
-32=No Such Object
-33=Alias Problem
-34=Invalid DN Syntax
-35=Is Leaf
-36=Alias Dereferencing Problem
-48=Inappropriate Authentication
-49=Invalid Credentials
-50=Insufficient Access Rights
-51=Busy
-52=Unavailable
-53=Unwilling To Perform
-54=Loop Detect
-64=Naming Violation
-65=Object Class Violation
-66=Not Allowed On Non-leaf
-67=Not Allowed On RDN
-68=Entry Already Exists
-69=Object Class Modifications Prohibited
-71=Affects Multiple DSAs
-80=Other
-81=Server Down
-82=Local Error
-83=Encoding Error
-84=Decoding Error
-85=Ldap Timeout
-86=Authentication Unknown
-87=Filter Error
-88=User Cancelled
-89=Parameter Error
-90=No Memory
-91=Connect Error
-92=Ldap Not Supported
-93=Control Not Found
-94=No Results Returned
-95=More Results To Return
-96=Client Loop
-97=Referral Limit Exceeded
-112=TLS not supported
-113=SSL handshake failed
-114=SSL Provider not found
\ No newline at end of file
+0=Success
+1=Operations Error
+2=Protocol Error
+3=Timelimit Exceeded
+4=Sizelimit Exceeded
+5=Compare False
+6=Compare True
+7=Authentication Method Not Supported
+8=Strong Authentication Required
+9=Partial Results
+10=Referral
+11=Administrative Limit Exceeded
+12=Unavailable Critical Extension
+13=Confidentiality Required
+14=SASL Bind In Progress
+16=No Such Attribute
+17=Undefined Attribute Type
+18=Inappropriate Matching
+19=Constraint Violation
+20=Attribute Or Value Exists
+21=Invalid Attribute Syntax
+32=No Such Object
+33=Alias Problem
+34=Invalid DN Syntax
+35=Is Leaf
+36=Alias Dereferencing Problem
+48=Inappropriate Authentication
+49=Invalid Credentials
+50=Insufficient Access Rights
+51=Busy
+52=Unavailable
+53=Unwilling To Perform
+54=Loop Detect
+64=Naming Violation
+65=Object Class Violation
+66=Not Allowed On Non-leaf
+67=Not Allowed On RDN
+68=Entry Already Exists
+69=Object Class Modifications Prohibited
+71=Affects Multiple DSAs
+80=Other
+81=Server Down
+82=Local Error
+83=Encoding Error
+84=Decoding Error
+85=Ldap Timeout
+86=Authentication Unknown
+87=Filter Error
+88=User Cancelled
+89=Parameter Error
+90=No Memory
+91=Connect Error
+92=Ldap Not Supported
+93=Control Not Found
+94=No Results Returned
+95=More Results To Return
+96=Client Loop
+97=Referral Limit Exceeded
+112=TLS not supported
+113=SSL handshake failed
+114=SSL Priovider not found
\ No newline at end of file
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/RespExtensionSet.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/RespExtensionSet.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/RespExtensionSet.cs	(working copy)
@@ -29,16 +29,9 @@
 // (C) 2003 Novell, Inc (http://www.novell.com)
 //
 using System;
-
 namespace Novell.Directory.Ldap.Utilclass
 {
 	
-#if TARGET_JVM
-    // This dummy class workarounds a MS CSC bug by using SupportClass before
-	// using its inner class (SupportClass.AbstractSetSupport)
-	class RespExtensionSetDummy : SupportClass {}
-#endif
-
 	/// <summary> This  class  extends the AbstractSet and Implements the Set
 	/// so that it can be used to maintain a list of currently
 	/// registered extended responses.
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ExceptionMessages.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ExceptionMessages.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ExceptionMessages.cs	(working copy)
@@ -39,7 +39,7 @@
 	/// Two entries are made for each message, a String identifier, and the
 	/// actual error string.  Parameters are identified as {0}, {1}, etc.
 	/// </summary>
-	public class ExceptionMessages:System.Resources.ResourceManager
+	public class ExceptionMessages
 	{
 		public System.Object[][] getContents()
 		{
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ExceptionMessages.txt
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ExceptionMessages.txt	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ExceptionMessages.txt	(working copy)
@@ -1,63 +1,63 @@
-TOSTRING={0}: {1} ({2}) {3}
-SERVER_MSG={0}: Server Message: {1}
-MATCHED_DN={0}: Matched DN: {1}
-FAILED_REFERRAL={0}: Failed Referral: {1}
-REFERRAL_ITEM={0}: Referral: {1}
-CONNECTION_ERROR=Unable to connect to server {0}:{1}
-CONNECTION_IMPOSSIBLE=Unable to reconnect to server, application has never called connect()
-CONNECTION_WAIT=Connection lost waiting for results from {0}:{1}
-CONNECTION_FINALIZED=Connection closed by the application finalizing the object
-CONNECTION_CLOSED=Connection closed by the application disconnecting
-CONNECTION_READER=Reader thread terminated
-DUP_ERROR=RfcLdapMessage: Cannot duplicate message built from the input stream
-REFERENCE_ERROR=Error attempting to follow a search continuation reference
-REFERRAL_ERROR=Error attempting to follow a referral
-REFERRAL_LOCAL=LdapSearchResults.{0}(): No entry found & request is not complete
-REFERRAL_SEND=Error sending request to referred server
-REFERENCE_NOFOLLOW=Search result reference received, and referral following is off
-REFERRAL_BIND=LdapBind.bind() function returned null
-REFERRAL_BIND_MATCH=Could not match LdapBind.bind() connection with Server Referral URL list
-NO_DUP_REQUEST=Cannot duplicate message to follow referral for {0} request, not allowed
-SERVER_CONNECT_ERROR=Error connecting to server {0} while attempting to follow a referral
-NO_SUP_PROPERTY=Requested property is not supported.
-ENTRY_PARAM_ERROR=Invalid Entry parameter
-DN_PARAM_ERROR=Invalid DN parameter
-RDN_PARAM_ERROR=Invalid DN or RDN parameter
-OP_PARAM_ERROR=Invalid extended operation parameter, no OID specified
-PARAM_ERROR=Invalid parameter
-DECODING_ERROR=Error Decoding responseValue
-ENCODING_ERROR=Encoding Error
-IO_EXCEPTION=I/O Exception on host {0}, port {1}
-INVALID_ESCAPE=Invalid value in escape sequence \"{0}\"
-SHORT_ESCAPE=Incomplete escape sequence
-UNEXPECTED_END=Unexpected end of filter
-MISSING_LEFT_PAREN=Unmatched parentheses, left parenthesis missing
-NO_OPTION=Semicolon present, but no option specified
-MISSING_RIGHT_PAREN=Unmatched parentheses, right parenthesis missing
-EXPECTING_RIGHT_PAREN=Expecting right parenthesis, found \"{0}\"
-EXPECTING_LEFT_PAREN=Expecting left parenthesis, found \"{0}\"
-NO_ATTRIBUTE_NAME=Missing attribute description
-NO_DN_NOR_MATCHING_RULE=DN and matching rule not specified
-NO_MATCHING_RULE=Missing matching rule
-INVALID_FILTER_COMPARISON=Invalid comparison operator
-INVALID_CHAR_IN_FILTER=The invalid character \"{0}\" needs to be escaped as \"{1}\"
-INVALID_ESC_IN_DESCR=Escape sequence not allowed in attribute description
-INVALID_CHAR_IN_DESCR=Invalid character \"{0}\" in attribute description
-NOT_AN_ATTRIBUTE=Schema element is not an LdapAttributeSchema object
-UNEQUAL_LENGTHS=Length of attribute Name array does not equal length of Flags array
-IMPROPER_REFERRAL=Referral not supported for command {0}
-NOT_IMPLEMENTED=Method LdapConnection.startTLS not implemented
-NO_MEMORY=All results could not be stored in memory, sort failed
-SERVER_SHUTDOWN_REQ=Received unsolicited notification from server {0}:{1} to shutdown
-INVALID_ADDRESS=Invalid syntax for address with port; {0}
-UNKNOWN_RESULT=Unknown Ldap result code {0}
-OUTSTANDING_OPERATIONS=Cannot start or stop TLS because outstanding Ldap operations exist on this connection
-WRONG_FACTORY=StartTLS cannot use the set socket factory because it does not implement LdapTLSSocketFactory
-NO_TLS_FACTORY=StartTLS failed because no LdapTLSSocketFactory has been set for this Connection
-NO_STARTTLS=An attempt to stopTLS on a connection where startTLS had not been called
-STOPTLS_ERROR=Error stopping TLS: Error getting input & output streams from the original socket
-MULTIPLE_SCHEMA=Multiple schema found when reading the subschemaSubentry for {0}
-NO_SCHEMA=No schema found when reading the subschemaSubentry for {0}
-READ_MULTIPLE=Read response is ambiguous, multiple entries returned
-CANNOT_BIND=Cannot bind. Use PoolManager.getBoundConnection()
-SSL_PROVIDER_MISSING=Please ensure that SSL Provider is properly installed.
+TOSTRING={0}: {1} ({2}) {3}
+SERVER_MSG={0}: Server Message: {1}
+MATCHED_DN={0}: Matched DN: {1}
+FAILED_REFERRAL={0}: Failed Referral: {1}
+REFERRAL_ITEM={0}: Referral: {1}
+CONNECTION_ERROR=Unable to connect to server {0}:{1}
+CONNECTION_IMPOSSIBLE=Unable to reconnect to server, application has never called connect()
+CONNECTION_WAIT=Connection lost waiting for results from {0}:{1}
+CONNECTION_FINALIZED=Connection closed by the application finalizing the object
+CONNECTION_CLOSED=Connection closed by the application disconnecting
+CONNECTION_READER=Reader thread terminated
+DUP_ERROR=RfcLdapMessage: Cannot duplicate message built from the input stream
+REFERENCE_ERROR=Error attempting to follow a search continuation reference
+REFERRAL_ERROR=Error attempting to follow a referral
+REFERRAL_LOCAL=LdapSearchResults.{0}(): No entry found & request is not complete
+REFERRAL_SEND=Error sending request to referred server
+REFERENCE_NOFOLLOW=Search result reference received, and referral following is off
+REFERRAL_BIND=LdapBind.bind() function returned null
+REFERRAL_BIND_MATCH=Could not match LdapBind.bind() connection with Server Referral URL list
+NO_DUP_REQUEST=Cannot duplicate message to follow referral for {0} request, not allowed
+SERVER_CONNECT_ERROR=Error connecting to server {0} while attempting to follow a referral
+NO_SUP_PROPERTY=Requested property is not supported.
+ENTRY_PARAM_ERROR=Invalid Entry parameter
+DN_PARAM_ERROR=Invalid DN parameter
+RDN_PARAM_ERROR=Invalid DN or RDN parameter
+OP_PARAM_ERROR=Invalid extended operation parameter, no OID specified
+PARAM_ERROR=Invalid parameter
+DECODING_ERROR=Error Decoding responseValue
+ENCODING_ERROR=Encoding Error
+IO_EXCEPTION=I/O Exception on host {0}, port {1}
+INVALID_ESCAPE=Invalid value in escape sequence \"{0}\"
+SHORT_ESCAPE=Incomplete escape sequence
+UNEXPECTED_END=Unexpected end of filter
+MISSING_LEFT_PAREN=Unmatched parentheses, left parenthesis missing
+NO_OPTION=Semicolon present, but no option specified
+MISSING_RIGHT_PAREN=Unmatched parentheses, right parenthesis missing
+EXPECTING_RIGHT_PAREN=Expecting right parenthesis, found \"{0}\"
+EXPECTING_LEFT_PAREN=Expecting left parenthesis, found \"{0}\"
+NO_ATTRIBUTE_NAME=Missing attribute description
+NO_DN_NOR_MATCHING_RULE=DN and matching rule not specified
+NO_MATCHING_RULE=Missing matching rule
+INVALID_FILTER_COMPARISON=Invalid comparison operator
+INVALID_CHAR_IN_FILTER=The invalid character \"{0}\" needs to be escaped as \"{1}\"
+INVALID_ESC_IN_DESCR=Escape sequence not allowed in attribute description
+INVALID_CHAR_IN_DESCR=Invalid character \"{0}\" in attribute description
+NOT_AN_ATTRIBUTE=Schema element is not an LdapAttributeSchema object
+UNEQUAL_LENGTHS=Length of attribute Name array does not equal length of Flags array
+IMPROPER_REFERRAL=Referral not supported for command {0}
+NOT_IMPLEMENTED=Method LdapConnection.startTLS not implemented
+NO_MEMORY=All results could not be stored in memory, sort failed
+SERVER_SHUTDOWN_REQ=Received unsolicited notification from server {0}:{1} to shutdown
+INVALID_ADDRESS=Invalid syntax for address with port; {0}
+UNKNOWN_RESULT=Unknown Ldap result code {0}
+OUTSTANDING_OPERATIONS=Cannot start or stop TLS because outstanding Ldap operations exist on this connection
+WRONG_FACTORY=StartTLS cannot use the set socket factory because it does not implement LdapTLSSocketFactory
+NO_TLS_FACTORY=StartTLS failed because no LdapTLSSocketFactory has been set for this Connection
+NO_STARTTLS=An attempt to stopTLS on a connection where startTLS had not been called
+STOPTLS_ERROR=Error stopping TLS: Error getting input & output streams from the original socket
+MULTIPLE_SCHEMA=Multiple schema found when reading the subschemaSubentry for {0}
+NO_SCHEMA=No schema found when reading the subschemaSubentry for {0}
+READ_MULTIPLE=Read response is ambiguous, multiple entries returned
+CANNOT_BIND=Cannot bind. Use PoolManager.getBoundConnection()
+SSL_PROVIDER_MISSING=Please ensure that SSL Provider is properly installed.
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ResultCodeMessages.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ResultCodeMessages.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ResultCodeMessages.cs	(working copy)
@@ -36,15 +36,15 @@
 	
 	/// <summary> This class contains strings corresponding to Ldap Result Codes.
 	/// The resources are accessed by the String representation of the result code.
-	/// </summary>
-	
-	public class ResultCodeMessages:System.Resources.ResourceManager
-	{
-		public System.Object[][] getContents()
-		{
-			return contents;
-		}
-		internal static readonly System.Object[][] contents = {new System.Object[]{"0", "Success"}, new System.Object[]{"1", "Operations Error"}, new System.Object[]{"2", "Protocol Error"}, new System.Object[]{"3", "Timelimit Exceeded"}, new System.Object[]{"4", "Sizelimit Exceeded"}, new System.Object[]{"5", "Compare False"}, new System.Object[]{"6", "Compare True"}, new System.Object[]{"7", "Authentication Method Not Supported"}, new System.Object[]{"8", "Strong Authentication Required"}, new System.Object[]{"9", "Partial Results"}, new System.Object[]{"10", "Referral"}, new System.Object[]{"11", "Administrative Limit Exceeded"}, new System.Object[]{"12", "Unavailable Critical Extension"}, new System.Object[]{"13", "Confidentiality Required"}, new System.Object[]{"14", "SASL Bind In Progress"}, new System.Object[]{"16", "No Such Attribute"}, new System.Object[]{"17", "Undefined Attribute Type"}, new System.Object[]{"18", "Inappropriate Matching"}, new System.Object[]{"19", "Constraint Violation"}, new System.Object[]{"20", "Attribute Or Value Exists"}, new System.Object[]{"21", "Invalid Attribute Syntax"}, new System.Object[]{"32", "No Such Object"}, new System.Object[]{"33", "Alias Problem"}, new System.Object[]{"34", "Invalid DN Syntax"}, new System.Object[]{"35", "Is Leaf"}, new System.Object[]{"36", "Alias Dereferencing Problem"}, new System.Object[]{"48", "Inappropriate Authentication"}, new System.Object[]{"49", "Invalid Credentials"}, new System.Object[]{"50", "Insufficient Access Rights"}, new System.Object[]{"51", "Busy"}, new System.Object[]{"52", "Unavailable"}, new System.Object[]{"53", "Unwilling To Perform"}, new System.Object[]{"54", "Loop Detect"}, new System.Object[]{"64", "Naming Violation"}, new System.Object[]{"65", "Object Class Violation"}, new System.Object[]{"66", "Not Allowed On Non-leaf"}, new System.Object[]{"67", "Not Allowed On RDN"}, new System.Object[]{"68", "Entry Already Exists"}, new System.Object[]{"69", "Object Class Modifications Prohibited"}, new System.Object[]{"71", 
-			"Affects Multiple DSAs"}, new System.Object[]{"80", "Other"}, new System.Object[]{"81", "Server Down"}, new System.Object[]{"82", "Local Error"}, new System.Object[]{"83", "Encoding Error"}, new System.Object[]{"84", "Decoding Error"}, new System.Object[]{"85", "Ldap Timeout"}, new System.Object[]{"86", "Authentication Unknown"}, new System.Object[]{"87", "Filter Error"}, new System.Object[]{"88", "User Cancelled"}, new System.Object[]{"89", "Parameter Error"}, new System.Object[]{"90", "No Memory"}, new System.Object[]{"91", "Connect Error"}, new System.Object[]{"92", "Ldap Not Supported"}, new System.Object[]{"93", "Control Not Found"}, new System.Object[]{"94", "No Results Returned"}, new System.Object[]{"95", "More Results To Return"}, new System.Object[]{"96", "Client Loop"}, new System.Object[]{"97", "Referral Limit Exceeded"}, new System.Object[]{"112", "TLS not supported"}};
-	} //End ResultCodeMessages
+	/// </summary>
+
+    public partial class ResultCodeMessages : System.Resources.ResourceManager
+    {
+        public System.Object[][] getContents()
+        {
+            return contents;
+        }
+        internal static readonly System.Object[][] contents = {new System.Object[]{"0", "Success"}, new System.Object[]{"1", "Operations Error"}, new System.Object[]{"2", "Protocol Error"}, new System.Object[]{"3", "Timelimit Exceeded"}, new System.Object[]{"4", "Sizelimit Exceeded"}, new System.Object[]{"5", "Compare False"}, new System.Object[]{"6", "Compare True"}, new System.Object[]{"7", "Authentication Method Not Supported"}, new System.Object[]{"8", "Strong Authentication Required"}, new System.Object[]{"9", "Partial Results"}, new System.Object[]{"10", "Referral"}, new System.Object[]{"11", "Administrative Limit Exceeded"}, new System.Object[]{"12", "Unavailable Critical Extension"}, new System.Object[]{"13", "Confidentiality Required"}, new System.Object[]{"14", "SASL Bind In Progress"}, new System.Object[]{"16", "No Such Attribute"}, new System.Object[]{"17", "Undefined Attribute Type"}, new System.Object[]{"18", "Inappropriate Matching"}, new System.Object[]{"19", "Constraint Violation"}, new System.Object[]{"20", "Attribute Or Value Exists"}, new System.Object[]{"21", "Invalid Attribute Syntax"}, new System.Object[]{"32", "No Such Object"}, new System.Object[]{"33", "Alias Problem"}, new System.Object[]{"34", "Invalid DN Syntax"}, new System.Object[]{"35", "Is Leaf"}, new System.Object[]{"36", "Alias Dereferencing Problem"}, new System.Object[]{"48", "Inappropriate Authentication"}, new System.Object[]{"49", "Invalid Credentials"}, new System.Object[]{"50", "Insufficient Access Rights"}, new System.Object[]{"51", "Busy"}, new System.Object[]{"52", "Unavailable"}, new System.Object[]{"53", "Unwilling To Perform"}, new System.Object[]{"54", "Loop Detect"}, new System.Object[]{"64", "Naming Violation"}, new System.Object[]{"65", "Object Class Violation"}, new System.Object[]{"66", "Not Allowed On Non-leaf"}, new System.Object[]{"67", "Not Allowed On RDN"}, new System.Object[]{"68", "Entry Already Exists"}, new System.Object[]{"69", "Object Class Modifications Prohibited"}, new System.Object[]{"71", 
+            "Affects Multiple DSAs"}, new System.Object[]{"80", "Other"}, new System.Object[]{"81", "Server Down"}, new System.Object[]{"82", "Local Error"}, new System.Object[]{"83", "Encoding Error"}, new System.Object[]{"84", "Decoding Error"}, new System.Object[]{"85", "Ldap Timeout"}, new System.Object[]{"86", "Authentication Unknown"}, new System.Object[]{"87", "Filter Error"}, new System.Object[]{"88", "User Cancelled"}, new System.Object[]{"89", "Parameter Error"}, new System.Object[]{"90", "No Memory"}, new System.Object[]{"91", "Connect Error"}, new System.Object[]{"92", "Ldap Not Supported"}, new System.Object[]{"93", "Control Not Found"}, new System.Object[]{"94", "No Results Returned"}, new System.Object[]{"95", "More Results To Return"}, new System.Object[]{"96", "Client Loop"}, new System.Object[]{"97", "Referral Limit Exceeded"}, new System.Object[]{"112", "TLS not supported"}};
+    } //End ResultCodeMessages
 }
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ResourcesHandler.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ResourcesHandler.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Utilclass/ResourcesHandler.cs	(working copy)
@@ -59,7 +59,7 @@
 		
 		
 		/// <summary> Package where resources are found</summary>
-		private static System.String pkg = "Novell.Directory.Ldap.Utilclass.";
+		private static System.String pkg = "Novell.Directory.Ldap.";
 		
 		/// <summary> The default Locale</summary>
 		private static System.Globalization.CultureInfo defaultLocale;
@@ -107,9 +107,11 @@
 		public static System.String getMessage(System.String messageOrKey, System.Object[] arguments, System.Globalization.CultureInfo locale)
 		{
 			if (defaultMessages == null)
-			{
-				defaultMessages = new ResourceManager("Novell.Directory.Ldap.Utilclass.ExceptionMessages", Assembly.GetExecutingAssembly());
-			}
+			{
+                Assembly.GetExecutingAssembly().GetManifestResourceNames();
+                
+                defaultMessages = new ResourceManager(string.Concat(pkg, "ExceptionMessages"), Assembly.GetExecutingAssembly());
+            }
 			
 			if (defaultLocale == null)
 				defaultLocale = Thread.CurrentThread.CurrentUICulture;
@@ -122,28 +124,26 @@
 				messageOrKey = "";
 			}
 			
-			string pattern;
-			try
-			{
-				pattern = defaultMessages.GetString(messageOrKey, locale);
-			}
-			catch (System.Resources.MissingManifestResourceException mre)
-			{
-				pattern = messageOrKey;
-			}
-			
+            
+
+			string pattern;
+            try
+            {
+                pattern = defaultMessages.GetString(messageOrKey, locale);
+            }
+            catch (MissingManifestResourceException)
+            {
+                pattern = messageOrKey;
+            }
+            catch (ArgumentNullException)
+            {
+                pattern = messageOrKey;
+            }
+
 			// Format the message if arguments were passed
-			if (arguments != null)
+			if (arguments != null && pattern != null)
 			{
-				StringBuilder strB = new StringBuilder();
-				strB.AppendFormat(pattern, arguments);
-				pattern = strB.ToString();
-				//				MessageFormat mf = new MessageFormat(pattern);
-				//				pattern=System.String.Format(locale,pattern,arguments);
-//				mf.setLocale(locale);
-				//this needs to be reset with the new local - i18n defect in java
-//				mf.applyPattern(pattern);
-//				pattern = mf.format(arguments);
+				pattern = string.Format(pattern, arguments);
 			}
 			return pattern;
 		}
@@ -180,26 +180,29 @@
 			if (defaultResultCodes == null)
 			{
 /*
-				defaultResultCodes = ResourceManager.CreateFileBasedResourceManager("ResultCodeMessages", "Resources", null);*/
-				defaultResultCodes = new ResourceManager("ResultCodeMessages", Assembly.GetExecutingAssembly());
+				defaultResultCodes = ResourceManager.CreateFileBasedResourceManager("ResultCodeMessages", "Resources", null);*/
+                defaultResultCodes = new ResourceManager(string.Concat(pkg, "ResultCodeMessages"), Assembly.GetExecutingAssembly());
+            }
 
-			}
-
 			if (defaultLocale == null)
 				defaultLocale = Thread.CurrentThread.CurrentUICulture;
 
 			if (locale == null)
 				locale = defaultLocale;
 
-			string result;
-			try
-			{
-				result = defaultResultCodes.GetString(Convert.ToString(code), defaultLocale);
-			}
-			catch (ArgumentNullException mre)
-			{
-				result = getMessage(ExceptionMessages.UNKNOWN_RESULT, new Object[]{code}, locale);
-			}
+			string result;
+            try
+            {
+                result = defaultResultCodes.GetString(Convert.ToString(code), locale);
+            }
+            catch (MissingManifestResourceException)
+            {
+                result = getMessage(ExceptionMessages.UNKNOWN_RESULT, new Object[] { code }, locale);
+            }
+            catch (ArgumentNullException)
+            {
+                result = getMessage(ExceptionMessages.UNKNOWN_RESULT, new Object[] { code }, locale);
+            }
 			return result;
 		}
 
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Events/DirectoryExceptionEventArgs.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Events/DirectoryExceptionEventArgs.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Events/DirectoryExceptionEventArgs.cs	(working copy)
@@ -41,8 +41,8 @@
   /// <seealso cref='Novell.Directory.Ldap.Events.Edir.EdirEventArgs'/>
   public class DirectoryExceptionEventArgs : BaseEventArgs
   {
-    protected LdapException ldap_exception_object;
-    public LdapException LdapExceptionObject
+    protected Exception ldap_exception_object;
+    public Exception LdapExceptionObject
     {
       get
       {
@@ -50,7 +50,7 @@
       }
     }
 
-    public DirectoryExceptionEventArgs(LdapMessage message, LdapException ldapException)
+    public DirectoryExceptionEventArgs(LdapMessage message, Exception ldapException)
       : base(message)
     {
       ldap_exception_object = ldapException;
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Events/LdapEventSource.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Events/LdapEventSource.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Events/LdapEventSource.cs	(working copy)
@@ -267,8 +267,15 @@
       {
 	directory_exception_event(this, new DirectoryExceptionEventArgs(sourceMessage, ldapException));
       }
-    }
-
+    }
+
+	  protected void NotifyExceptionListeners(LdapMessage sourceMessage, Exception unknownException)
+	  {
+		  if (null != directory_exception_event)
+		  {
+			  directory_exception_event(this, new DirectoryExceptionEventArgs(sourceMessage, unknownException));
+		  }
+	  }
   
     ///  <summary> This is a nested class that is supposed to monitor 
     ///  LdapMessageQueue for events generated by the LDAP Server.
@@ -315,37 +322,41 @@
       {
 	while (isrunning) 
 	{
-	  LdapMessage response = null;
-	  try 
-	  {
-	    while ((isrunning)
-		   && (!searchqueue.isResponseReceived(messageid))) 
-	    {
-	      try 
-	      {
-		Thread.Sleep(sleep_time);
-	      } 
-	      catch (ThreadInterruptedException e) 
-	      {
-		Console.WriteLine("EventsGenerator::Run Got ThreadInterruptedException e = {0}", e);
-	      }
-	    }
-	    
-	    if (isrunning) 
-	    {
-	      response = searchqueue.getResponse(messageid);
-	    }
-	    
-	    if (response != null) 
-	    {
-	      processmessage(response);
-	    }
-	  } 
-	  catch (LdapException e) 
-	  {
-	    m_objLdapEventSource.NotifyExceptionListeners(response, e);
-	  }
-	}
+	  LdapMessage response = null;
+	  try
+	  {
+		  while ((isrunning)
+			 && (!searchqueue.isResponseReceived(messageid)))
+		  {
+			  try
+			  {
+				  Thread.Sleep(sleep_time);
+			  }
+			  catch (ThreadInterruptedException e)
+			  {
+				  Console.WriteLine("EventsGenerator::Run Got ThreadInterruptedException e = {0}", e);
+			  }
+		  }
+
+		  if (isrunning)
+		  {
+			  response = searchqueue.getResponse(messageid);
+		  }
+
+		  if (response != null)
+		  {
+			  processmessage(response);
+		  }
+	  }
+	  catch (LdapException e)
+	  {
+		  m_objLdapEventSource.NotifyExceptionListeners(response, e);
+	  }
+	  catch (Exception e)
+	  {
+		  m_objLdapEventSource.NotifyExceptionListeners(response, e);
+	  }
+  }
       } // end of method run
       
       protected void processmessage(LdapMessage response) 
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Rfc2251/RfcModifyDNRequest.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Rfc2251/RfcModifyDNRequest.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Rfc2251/RfcModifyDNRequest.cs	(working copy)
@@ -52,21 +52,20 @@
 		//*************************************************************************
 		// Constructors for ModifyDNRequest
 		//*************************************************************************
-	
+		
 		/// <summary> </summary>
 		public RfcModifyDNRequest(RfcLdapDN entry, RfcRelativeLdapDN newrdn, Asn1Boolean deleteoldrdn):this(entry, newrdn, deleteoldrdn, null)
 		{
 		}
 		
 		/// <summary> </summary>
-		public RfcModifyDNRequest(RfcLdapDN entry, RfcRelativeLdapDN newrdn, Asn1Boolean deleteoldrdn, RfcLdapSuperDN newSuperior):base(4)
+		public RfcModifyDNRequest(RfcLdapDN entry, RfcRelativeLdapDN newrdn, Asn1Boolean deleteoldrdn, RfcLdapDN newSuperior):base(4)
 		{
 			add(entry);
 			add(newrdn);
 			add(deleteoldrdn);
-			if (newSuperior != null) {
+			if (newSuperior != null)
 				add(newSuperior);
-			}
 		}
 		
 		/// <summary> Constructs a new Delete Request copying from the ArrayList of
Index: class/Novell.Directory.Ldap/Novell.Directory.Ldap.Rfc2251/RfcBindRequest.cs
===================================================================
--- class/Novell.Directory.Ldap/Novell.Directory.Ldap.Rfc2251/RfcBindRequest.cs	(revision 55763)
+++ class/Novell.Directory.Ldap/Novell.Directory.Ldap.Rfc2251/RfcBindRequest.cs	(working copy)
@@ -100,7 +100,7 @@
 		/// ID needs only be one Value for every instance,
 		/// thus we create it only once.
 		/// </summary>
-		new private static readonly Asn1Identifier ID = new Asn1Identifier(Asn1Identifier.APPLICATION, true, LdapMessage.BIND_REQUEST);
+		private static readonly Asn1Identifier ID = new Asn1Identifier(Asn1Identifier.APPLICATION, true, LdapMessage.BIND_REQUEST);
 		
 		
 		//*************************************************************************
