Index: mini/method-to-ir.c
===================================================================
--- mini/method-to-ir.c	(revision 110658)
+++ mini/method-to-ir.c	(working copy)
@@ -8132,6 +8132,8 @@
 			MONO_ADD_INS (bblock, ins);
 			*sp++ = ins;
 
+			mono_decompose_opcode (cfg, ins);
+
 			++ip;
 			break;
 		}
Index: mini/mini.c
===================================================================
--- mini/mini.c	(revision 110658)
+++ mini/mini.c	(working copy)
@@ -1928,6 +1928,8 @@
 		return OP_ISUB;
 	case OP_LSUB_IMM:
 		return OP_LSUB;
+	case OP_IMUL_IMM:
+		return OP_IMUL;
 	case OP_AND_IMM:
 #if SIZEOF_VOID_P == 4
 		return OP_IAND;
Index: mini/inssel-ppc.brg
===================================================================
--- mini/inssel-ppc.brg	(revision 110658)
+++ mini/inssel-ppc.brg	(working copy)
@@ -1,9 +1,9 @@
 #define MONO_EMIT_NEW_LOAD_R8(cfg,dr,addr) do { \
-		MonoInst *inst; \
-		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst)); \
-		inst->opcode = OP_R8CONST; \
-		inst->dreg = dr; \
-		inst->inst_p0 = addr; \
+		MonoInst *inst;				   \
+		MONO_INST_NEW ((cfg), (inst), OP_R8CONST); \
+		inst->type = STACK_R8;			   \
+		inst->dreg = (dr);		       \
+		inst->inst_p0 = (void*)(addr);	       \
 		mono_bblock_add_inst (cfg->cbb, inst); \
 	} while (0)
 
Index: mini/decompose.c
===================================================================
--- mini/decompose.c	(revision 110658)
+++ mini/decompose.c	(working copy)
@@ -164,7 +164,38 @@
 		MONO_EMIT_NEW_BIALU_IMM (cfg, OP_ISHR_UN_IMM, ins->dreg, ins->sreg1, 0);
 		ins->opcode = OP_NOP;
 		break;
+#if defined(__ppc__)
 	case OP_LADD_OVF:
+		/* ADC sets the condition code */
+		MONO_EMIT_NEW_BIALU (cfg, OP_ADDCC, ins->dreg + 1, ins->sreg1 + 1, ins->sreg2 + 1);
+		MONO_EMIT_NEW_BIALU (cfg, OP_ADD_OVF_CARRY, ins->dreg + 2, ins->sreg1 + 2, ins->sreg2 + 2);
+		ins->opcode = OP_NOP;
+		g_assert_not_reached ();
+		break;
+	case OP_LADD_OVF_UN:
+		/* ADC sets the condition code */
+		MONO_EMIT_NEW_BIALU (cfg, OP_ADDCC, ins->dreg + 1, ins->sreg1 + 1, ins->sreg2 + 1);
+		MONO_EMIT_NEW_BIALU (cfg, OP_ADD_OVF_UN_CARRY, ins->dreg + 2, ins->sreg1 + 2, ins->sreg2 + 2);
+		ins->opcode = OP_NOP;
+		g_assert_not_reached ();
+		break;
+	case OP_LSUB_OVF:
+		/* SBB sets the condition code */
+		MONO_EMIT_NEW_BIALU (cfg, OP_SUBCC, ins->dreg + 1, ins->sreg1 + 1, ins->sreg2 + 1);
+		MONO_EMIT_NEW_BIALU (cfg, OP_SUB_OVF_CARRY, ins->dreg + 2, ins->sreg1 + 2, ins->sreg2 + 2);
+		ins->opcode = OP_NOP;
+		g_assert_not_reached ();
+		break;
+	case OP_LSUB_OVF_UN:
+		/* SBB sets the condition code */
+		MONO_EMIT_NEW_BIALU (cfg, OP_SUBCC, ins->dreg + 1, ins->sreg1 + 1, ins->sreg2 + 1);
+		MONO_EMIT_NEW_BIALU (cfg, OP_SUB_OVF_UN_CARRY, ins->dreg + 2, ins->sreg1 + 2, ins->sreg2 + 2);
+		ins->opcode = OP_NOP;
+		g_assert_not_reached ();
+		break;
+#else
+#error bla
+	case OP_LADD_OVF:
 		MONO_EMIT_NEW_BIALU (cfg, OP_ADDCC, ins->dreg, ins->sreg1, ins->sreg2);
 		MONO_EMIT_NEW_COND_EXC (cfg, OV, "OverflowException");
 		ins->opcode = OP_NOP;
@@ -184,6 +215,7 @@
 		MONO_EMIT_NEW_COND_EXC (cfg, C, "OverflowException");
 		ins->opcode = OP_NOP;
 		break;
+#endif
 		
 	case OP_ICONV_TO_OVF_I8:
 	case OP_ICONV_TO_OVF_I:
@@ -634,8 +666,31 @@
 				MONO_EMIT_NEW_BIALU (cfg, OP_ISUBCC, tree->dreg + 1, tree->sreg1 + 1, tree->sreg2 + 1);
 				MONO_EMIT_NEW_BIALU (cfg, OP_ISBB, tree->dreg + 2, tree->sreg1 + 2, tree->sreg2 + 2);
 				break;
+
+#if defined(__ppc__)
 			case OP_LADD_OVF:
 				/* ADC sets the condition code */
+				MONO_EMIT_NEW_BIALU (cfg, OP_ADDCC, tree->dreg + 1, tree->sreg1 + 1, tree->sreg2 + 1);
+				MONO_EMIT_NEW_BIALU (cfg, OP_ADD_OVF_CARRY, tree->dreg + 2, tree->sreg1 + 2, tree->sreg2 + 2);
+				break;
+			case OP_LADD_OVF_UN:
+				/* ADC sets the condition code */
+				MONO_EMIT_NEW_BIALU (cfg, OP_ADDCC, tree->dreg + 1, tree->sreg1 + 1, tree->sreg2 + 1);
+				MONO_EMIT_NEW_BIALU (cfg, OP_ADD_OVF_UN_CARRY, tree->dreg + 2, tree->sreg1 + 2, tree->sreg2 + 2);
+				break;
+			case OP_LSUB_OVF:
+				/* SBB sets the condition code */
+				MONO_EMIT_NEW_BIALU (cfg, OP_SUBCC, tree->dreg + 1, tree->sreg1 + 1, tree->sreg2 + 1);
+				MONO_EMIT_NEW_BIALU (cfg, OP_SUB_OVF_CARRY, tree->dreg + 2, tree->sreg1 + 2, tree->sreg2 + 2);
+				break;
+			case OP_LSUB_OVF_UN:
+				/* SBB sets the condition code */
+				MONO_EMIT_NEW_BIALU (cfg, OP_SUBCC, tree->dreg + 1, tree->sreg1 + 1, tree->sreg2 + 1);
+				MONO_EMIT_NEW_BIALU (cfg, OP_SUB_OVF_UN_CARRY, tree->dreg + 2, tree->sreg1 + 2, tree->sreg2 + 2);
+				break;
+#else
+			case OP_LADD_OVF:
+				/* ADC sets the condition code */
 				MONO_EMIT_NEW_BIALU (cfg, OP_IADDCC, tree->dreg + 1, tree->sreg1 + 1, tree->sreg2 + 1);
 				MONO_EMIT_NEW_BIALU (cfg, OP_IADC, tree->dreg + 2, tree->sreg1 + 2, tree->sreg2 + 2);
 				MONO_EMIT_NEW_COND_EXC (cfg, OV, "OverflowException");
@@ -658,6 +713,7 @@
 				MONO_EMIT_NEW_BIALU (cfg, OP_ISBB, tree->dreg + 2, tree->sreg1 + 2, tree->sreg2 + 2);
 				MONO_EMIT_NEW_COND_EXC (cfg, C, "OverflowException");
 				break;
+#endif
 			case OP_LAND:
 				MONO_EMIT_NEW_BIALU (cfg, OP_IAND, tree->dreg + 1, tree->sreg1 + 1, tree->sreg2 + 1);
 				MONO_EMIT_NEW_BIALU (cfg, OP_IAND, tree->dreg + 2, tree->sreg1 + 2, tree->sreg2 + 2);
@@ -690,6 +746,13 @@
 #elif defined(__arm__)
 				MONO_EMIT_NEW_BIALU_IMM (cfg, OP_ARM_RSBS_IMM, tree->dreg + 1, tree->sreg1 + 1, 0);
 				MONO_EMIT_NEW_BIALU_IMM (cfg, OP_ARM_RSC_IMM, tree->dreg + 2, tree->sreg1 + 2, 0);
+#elif defined(__ppc__)
+				/* This is the old version from inssel-long32.brg */
+				MONO_EMIT_NEW_UNALU (cfg, OP_INOT, tree->dreg + 1, tree->sreg1 + 1);
+				MONO_EMIT_NEW_UNALU (cfg, OP_INOT, tree->dreg + 2, tree->sreg1 + 2);
+				/* ADC sets the condition codes */
+				MONO_EMIT_NEW_BIALU_IMM (cfg, OP_ADC_IMM, tree->dreg + 1, tree->dreg + 1, 1);
+				MONO_EMIT_NEW_BIALU_IMM (cfg, OP_ADC_IMM, tree->dreg + 2, tree->dreg + 2, 0);
 #else
 				NOT_IMPLEMENTED;
 #endif
Index: mini/cpu-ppc.md
===================================================================
--- mini/cpu-ppc.md	(revision 110658)
+++ mini/cpu-ppc.md	(working copy)
@@ -53,7 +53,7 @@
 br: len:4
 throw: src1:i len:20
 rethrow: src1:i len:20
-ckfinite: src1:f
+ckfinite: dest:f src1:f
 ppc_check_finite: src1:i len:16
 add_ovf_carry: dest:i src1:i src2:i len:16
 sub_ovf_carry: dest:i src1:i src2:i len:16
@@ -94,21 +94,21 @@
 r4const: dest:f len:12
 r8const: dest:f len:12
 label: len:0
-store_membase_reg: dest:b src1:i len:4
-storei1_membase_reg: dest:b src1:i len:4
-storei2_membase_reg: dest:b src1:i len:4
-storei4_membase_reg: dest:b src1:i len:4
-storer4_membase_reg: dest:b src1:f len:8
-storer8_membase_reg: dest:b src1:f len:4
-load_membase: dest:i src1:b len:4
-loadi1_membase: dest:i src1:b len:8
-loadu1_membase: dest:i src1:b len:4
-loadi2_membase: dest:i src1:b len:4
-loadu2_membase: dest:i src1:b len:4
-loadi4_membase: dest:i src1:b len:4
-loadu4_membase: dest:i src1:b len:4
-loadr4_membase: dest:f src1:b len:4
-loadr8_membase: dest:f src1:b len:4
+store_membase_reg: dest:b src1:i len:12
+storei1_membase_reg: dest:b src1:i len:12
+storei2_membase_reg: dest:b src1:i len:12
+storei4_membase_reg: dest:b src1:i len:12
+storer4_membase_reg: dest:b src1:f len:16
+storer8_membase_reg: dest:b src1:f len:12
+load_membase: dest:i src1:b len:12
+loadi1_membase: dest:i src1:b len:16
+loadu1_membase: dest:i src1:b len:12
+loadi2_membase: dest:i src1:b len:12
+loadu2_membase: dest:i src1:b len:12
+loadi4_membase: dest:i src1:b len:12
+loadu4_membase: dest:i src1:b len:12
+loadr4_membase: dest:f src1:b len:12
+loadr8_membase: dest:f src1:b len:12
 load_memindex: dest:i src1:b src2:i len:4
 loadi1_memindex: dest:i src1:b src2:i len:8
 loadu1_memindex: dest:i src1:b src2:i len:4
@@ -303,7 +303,7 @@
 icompare: src1:i src2:i len:4
 icompare_imm: src1:i len:12
 
-long_conv_to_ovf_i4_2: dest:i src1:i src2:i len:30
+long_conv_to_ovf_i4_2: dest:i src1:i src2:i len:32
 
 vcall2: len:20 clob:c
 vcall2_reg: src1:i len:8 clob:c
Index: mini/mini-ops.h
===================================================================
--- mini/mini-ops.h	(revision 110658)
+++ mini/mini-ops.h	(working copy)
@@ -569,10 +569,10 @@
 MINI_OP(OP_ZEXT_I4,  "zext_i4", IREG, IREG, NONE)
 MINI_OP(OP_CNE,      "cne", NONE, NONE, NONE)
 /* to implement the upper half of long32 add and sub */
-MINI_OP(OP_ADD_OVF_CARRY,   "add_ovf_carry", NONE, NONE, NONE)
-MINI_OP(OP_SUB_OVF_CARRY,   "sub_ovf_carry", NONE, NONE, NONE)
-MINI_OP(OP_ADD_OVF_UN_CARRY,   "add_ovf_un_carry", NONE, NONE, NONE)
-MINI_OP(OP_SUB_OVF_UN_CARRY,   "sub_ovf_un_carry", NONE, NONE, NONE)
+MINI_OP(OP_ADD_OVF_CARRY,   "add_ovf_carry", IREG, IREG, IREG)
+MINI_OP(OP_SUB_OVF_CARRY,   "sub_ovf_carry", IREG, IREG, IREG)
+MINI_OP(OP_ADD_OVF_UN_CARRY,   "add_ovf_un_carry", IREG, IREG, IREG)
+MINI_OP(OP_SUB_OVF_UN_CARRY,   "sub_ovf_un_carry", IREG, IREG, IREG)
 
 /* FP functions usually done by the CPU */
 MINI_OP(OP_SIN,     "sin", FREG, FREG, NONE)
Index: mini/mini-ppc.c
===================================================================
--- mini/mini-ppc.c	(revision 110658)
+++ mini/mini-ppc.c	(working copy)
@@ -678,10 +678,11 @@
 	}
         DEBUG(printf("params: %d\n", sig->param_count));
 	for (i = 0; i < sig->param_count; ++i) {
-		if ((sig->call_convention == MONO_CALL_VARARG) && (i == sig->sentinelpos)) {
+		if (!sig->pinvoke && (sig->call_convention == MONO_CALL_VARARG) && (i == sig->sentinelpos)) {
                         /* Prevent implicit arguments and sig_cookie from
 			   being passed in registers */
                         gr = PPC_LAST_ARG_REG + 1;
+			/* FIXME: don't we have to set fr, too? */
                         /* Emit the signature cookie just before the implicit arguments */
                         add_general (&gr, &stack_size, &cinfo->sig_cookie, TRUE);
                 }
@@ -873,6 +874,14 @@
 		}
 	}
 
+	if (!sig->pinvoke && (sig->call_convention == MONO_CALL_VARARG) && (n == sig->sentinelpos)) {
+		/* Prevent implicit arguments and sig_cookie from
+		   being passed in registers */
+		gr = PPC_LAST_ARG_REG + 1;
+		/* Emit the signature cookie just before the implicit arguments */
+		add_general (&gr, &stack_size, &cinfo->sig_cookie, TRUE);
+	}
+
 	{
 		simpletype = mono_type_get_underlying_type (sig->ret)->type;
 		switch (simpletype) {
@@ -1033,12 +1042,25 @@
         }
 
 	if (MONO_TYPE_ISSTRUCT (sig->ret)) {
-		inst = m->ret;
 		offset += sizeof(gpointer) - 1;
 		offset &= ~(sizeof(gpointer) - 1);
-		inst->inst_offset = offset;
-		inst->opcode = OP_REGOFFSET;
-		inst->inst_basereg = frame_reg;
+
+		if (m->new_ir) {
+			m->vret_addr->opcode = OP_REGOFFSET;
+			m->vret_addr->inst_basereg = frame_reg;
+			m->vret_addr->inst_offset = offset;
+
+			if (G_UNLIKELY (m->verbose_level > 1)) {
+				printf ("vret_addr =");
+				mono_print_ins (m->vret_addr);
+			}
+		} else {
+			inst = m->ret;
+			inst->inst_offset = offset;
+			inst->opcode = OP_REGOFFSET;
+			inst->inst_basereg = frame_reg;
+		}
+
 		offset += sizeof(gpointer);
 		if (sig->call_convention == MONO_CALL_VARARG)
 			m->sig_cookie += sizeof (gpointer);
@@ -1110,6 +1132,11 @@
 void
 mono_arch_create_vars (MonoCompile *cfg)
 {
+	MonoMethodSignature *sig = mono_method_signature (cfg->method);
+
+	if (cfg->new_ir && MONO_TYPE_ISSTRUCT (sig->ret)) {
+		cfg->vret_addr = mono_compile_create_var (cfg, &mono_defaults.int_class->byval_arg, OP_ARG);
+	}
 }
 
 /* Fixme: we need an alignment solution for enter_method and mono_arch_call_opcode,
@@ -1150,6 +1177,7 @@
 			MONO_INST_NEW (cfg, arg, OP_OUTARG);
 			arg->inst_imm = cinfo->sig_cookie.offset;
 			arg->inst_left = sig_arg;
+			arg->inst_call = call;
 			/* prepend, so they get reversed */
 			arg->next = call->out_args;
 			call->out_args = arg;
@@ -1248,6 +1276,16 @@
 	return call;
 }
 
+static void
+emit_sig_cookie (MonoCompile *cfg, MonoCallInst *call, CallInfo *cinfo)
+{
+	int sig_reg = mono_alloc_ireg (cfg);
+
+	MONO_EMIT_NEW_ICONST (cfg, sig_reg, call->signature);
+	MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG,
+			ppc_r1, cinfo->sig_cookie.offset, sig_reg);
+}
+
 void
 mono_arch_emit_call (MonoCompile *cfg, MonoCallInst *call)
 {
@@ -1271,10 +1309,8 @@
 			t = &mono_defaults.int_class->byval_arg;
 		t = mono_type_get_underlying_type (t);
 
-		if ((sig->call_convention == MONO_CALL_VARARG) && (i == sig->sentinelpos)) {
-			/* FIXME: */
-			NOT_IMPLEMENTED;
-		}
+		if (!sig->pinvoke && (sig->call_convention == MONO_CALL_VARARG) && (i == sig->sentinelpos))
+			emit_sig_cookie (cfg, call, cinfo);
 
 		in = call->args [i];
 
@@ -1284,13 +1320,13 @@
 				ins->dreg = mono_alloc_ireg (cfg);
 				ins->sreg1 = in->dreg + 1;
 				MONO_ADD_INS (cfg->cbb, ins);
-				mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg, FALSE);
+				mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg + 1, FALSE);
 
 				MONO_INST_NEW (cfg, ins, OP_MOVE);
 				ins->dreg = mono_alloc_ireg (cfg);
 				ins->sreg1 = in->dreg + 2;
 				MONO_ADD_INS (cfg->cbb, ins);
-				mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg + 1, FALSE);
+				mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg, FALSE);
 			} else {
 				MONO_INST_NEW (cfg, ins, OP_MOVE);
 				ins->dreg = mono_alloc_ireg (cfg);
@@ -1301,6 +1337,8 @@
 			}
 		} else if (ainfo->regtype == RegTypeStructByAddr) {
 			if (ainfo->offset) {
+				if (!ppc_is_imm16 (ainfo->offset))
+					g_print ("emitting large offset in bb %p\n", cfg->cbb);
 				MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, ppc_r1, ainfo->offset, in->dreg);
 			} else {
 				MONO_INST_NEW (cfg, ins, OP_MOVE);
@@ -1344,6 +1382,11 @@
 		}
 	}
 
+	/* Emit the signature cookie in the case that there is no
+	   additional argument */
+	if (!sig->pinvoke && (sig->call_convention == MONO_CALL_VARARG) && (n == sig->sentinelpos))
+		emit_sig_cookie (cfg, call, cinfo);
+
 	if (cinfo->struct_ret) {
 		MonoInst *vtarg;
 
@@ -1370,18 +1413,36 @@
 	int ovf_size = ainfo->vtsize;
 	int doffset = ainfo->offset;
 	int i, soffset, dreg;
+	int size = 0;
 
-	/* FIXME: handle darwin's 1/2 byte structs */
 	soffset = 0;
+	/*
+	  Darwin needs some special handling for 1 and 2 byte arguments
+	*/
+#ifdef __APPLE__
+	g_assert (ins->klass);
+	size =  mono_class_native_size (ins->klass, NULL);
+	if (size == 2 || size == 1) {
+		int tmpr = mono_alloc_ireg (cfg);
+		//g_print ("handling outarg struct of size %d\n", size);
+		if (size == 1)
+			MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI1_MEMBASE, tmpr, src->dreg, soffset);
+		else
+			MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI2_MEMBASE, tmpr, src->dreg, soffset);
+		dreg = mono_alloc_ireg (cfg);
+		MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, dreg, tmpr);
+		mono_call_inst_add_outarg_reg (cfg, call, dreg, ainfo->reg, FALSE);
+	} else
+#endif
 	for (i = 0; i < ainfo->size; ++i) {
 		dreg = mono_alloc_ireg (cfg);
 		MONO_EMIT_NEW_LOAD_MEMBASE (cfg, dreg, src->dreg, soffset);
 		mono_call_inst_add_outarg_reg (cfg, call, dreg, ainfo->reg + i, FALSE);
 		soffset += sizeof (gpointer);
 	}
-	//g_print ("vt size: %d at R%d + %d\n", doffset, vt->inst_basereg, vt->inst_offset);
+	//g_print ("vt size for %s: %d at R%d + %d\n", cfg->method->name, doffset, src->dreg, soffset);
 	if (ovf_size != 0)
-		mini_emit_memcpy2 (cfg, ppc_r1, doffset, src->dreg, soffset, ovf_size * sizeof (gpointer), 0);
+		mini_emit_memcpy2 (cfg, ppc_r1, doffset + soffset, src->dreg, soffset, ovf_size * sizeof (gpointer), 0);
 }
 
 void
@@ -1754,14 +1815,31 @@
 void
 mono_arch_decompose_opts (MonoCompile *cfg, MonoInst *ins)
 {
+	g_assert (cfg->new_ir);
+
 	switch (ins->opcode) {
-	case OP_ICONV_TO_R4: {
+	case OP_ICONV_TO_R_UN: {
+		static const guint64 adjust_val = 0x4330000000000000ULL;
+		int msw_reg = mono_alloc_ireg (cfg);
+		int adj_reg = mono_alloc_freg (cfg);
+		int tmp_reg = mono_alloc_freg (cfg);
+		MONO_EMIT_NEW_ICONST (cfg, msw_reg, 0x43300000);
+		MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, ppc_sp, -8, msw_reg);
+		MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, ppc_sp, -4, ins->sreg1);
+		MONO_EMIT_NEW_LOAD_R8 (cfg, adj_reg, &adjust_val);
+		MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADR8_MEMBASE, tmp_reg, ppc_sp, -8);
+		MONO_EMIT_NEW_BIALU (cfg, OP_FSUB, ins->dreg, tmp_reg, adj_reg);
+		ins->opcode = OP_NOP;
+		break;
+	}
+	case OP_ICONV_TO_R4:
+	case OP_ICONV_TO_R8: {
 		/* FIXME: change precision for CEE_CONV_R4 */
 		static const guint64 adjust_val = 0x4330000080000000ULL;
-		int msw_reg = mono_regstate_next_int (cfg->rs);
-		int xored = mono_regstate_next_int (cfg->rs);
-		int adj_reg = mono_regstate_next_float (cfg->rs);
-		int tmp_reg = mono_regstate_next_float (cfg->rs);
+		int msw_reg = mono_alloc_ireg (cfg);
+		int xored = mono_alloc_ireg (cfg);
+		int adj_reg = mono_alloc_freg (cfg);
+		int tmp_reg = mono_alloc_freg (cfg);
 		MONO_EMIT_NEW_ICONST (cfg, msw_reg, 0x43300000);
 		MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, ppc_sp, -8, msw_reg);
 		MONO_EMIT_NEW_BIALU_IMM (cfg, OP_XOR_IMM, xored, ins->sreg1, 0x80000000);
@@ -1772,7 +1850,17 @@
 		ins->opcode = OP_NOP;
 		break;
 	}
+	case OP_CKFINITE: {
+		int msw_reg = mono_alloc_ireg (cfg);
+		g_print ("converted ckfinite\n");
+		MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER8_MEMBASE_REG, ppc_sp, -8, ins->sreg1);
+		MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOADI4_MEMBASE, msw_reg, ppc_sp, -8);
+		MONO_EMIT_NEW_UNALU (cfg, OP_CHECK_FINITE, -1, msw_reg);
+		MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, ins->dreg, ins->sreg1);
+		ins->opcode = OP_NOP;
+		break;
 	}
+	}
 }
 
 /* 
@@ -1822,6 +1910,7 @@
 #define NEW_INS(cfg,dest,op) do {					\
 		(dest) = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));       \
 		(dest)->opcode = (op);  \
+		(dest)->dreg = (dest)->sreg1 = (dest)->sreg2 = -1;	\
 		mono_bblock_insert_after_ins (bb, last_ins, (dest));	\
 	} while (0)
 
@@ -2009,6 +2098,11 @@
 		case OP_COMPARE_IMM:
 		case OP_ICOMPARE_IMM:
 			next = ins->next;
+			/* Branch opts can eliminate the branch */
+			if (!next || (!(MONO_IS_COND_BRANCH_OP (next) || MONO_IS_COND_EXC (next) || MONO_IS_SETCC (next)))) {
+				ins->opcode = OP_NOP;
+				break;
+			}
 			g_assert(next);
 			if (compare_opcode_is_unsigned (next->opcode)) {
 				if (!ppc_is_uimm16 (ins->inst_imm)) {
@@ -2460,14 +2554,16 @@
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_stb (code, ins->sreg1, ins->inst_offset, ins->inst_destbasereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_stbx (code, ins->sreg1, ins->inst_destbasereg, ppc_r0);
 			}
 			break;
 		case OP_STOREI2_MEMBASE_REG:
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_sth (code, ins->sreg1, ins->inst_offset, ins->inst_destbasereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_sthx (code, ins->sreg1, ins->inst_destbasereg, ppc_r0);
 			}
 			break;
 		case OP_STORE_MEMBASE_REG:
@@ -2475,7 +2571,8 @@
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_stw (code, ins->sreg1, ins->inst_offset, ins->inst_destbasereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_stwx (code, ins->sreg1, ins->inst_destbasereg, ppc_r0);
 			}
 			break;
 		case OP_STOREI1_MEMINDEX:
@@ -2497,7 +2594,8 @@
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_lwz (code, ins->dreg, ins->inst_offset, ins->inst_basereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_lwzx (code, ins->dreg, ins->inst_basereg, ppc_r0);
 			}
 			break;
 		case OP_LOADI1_MEMBASE:
@@ -2505,7 +2603,8 @@
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_lbz (code, ins->dreg, ins->inst_offset, ins->inst_basereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_lbzx (code, ins->dreg, ins->inst_basereg, ppc_r0);
 			}
 			if (ins->opcode == OP_LOADI1_MEMBASE)
 				ppc_extsb (code, ins->dreg, ins->dreg);
@@ -2514,14 +2613,16 @@
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_lhz (code, ins->dreg, ins->inst_offset, ins->inst_basereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_lhzx (code, ins->dreg, ins->inst_basereg, ppc_r0);
 			}
 			break;
 		case OP_LOADI2_MEMBASE:
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_lha (code, ins->dreg, ins->inst_basereg, ins->inst_offset);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_lhax (code, ins->dreg, ins->inst_basereg, ppc_r0);
 			}
 			break;
 		case OP_LOAD_MEMINDEX:
@@ -3181,14 +3282,16 @@
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_stfd (code, ins->sreg1, ins->inst_offset, ins->inst_destbasereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_stfdx (code, ins->sreg1, ins->inst_destbasereg, ppc_r0);
 			}
 			break;
 		case OP_LOADR8_MEMBASE:
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_lfd (code, ins->dreg, ins->inst_offset, ins->inst_basereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_lfdx (code, ins->dreg, ins->inst_destbasereg, ppc_r0);
 			}
 			break;
 		case OP_STORER4_MEMBASE_REG:
@@ -3196,14 +3299,16 @@
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_stfs (code, ins->sreg1, ins->inst_offset, ins->inst_destbasereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_stfsx (code, ins->sreg1, ins->inst_destbasereg, ppc_r0);
 			}
 			break;
 		case OP_LOADR4_MEMBASE:
 			if (ppc_is_imm16 (ins->inst_offset)) {
 				ppc_lfs (code, ins->dreg, ins->inst_offset, ins->inst_basereg);
 			} else {
-				g_assert_not_reached ();
+				ppc_load (code, ppc_r0, ins->inst_offset);
+				ppc_lfsx (code, ins->dreg, ins->inst_destbasereg, ppc_r0);
 			}
 			break;
 		case OP_LOADR4_MEMINDEX:
@@ -3592,7 +3697,13 @@
 
 	if (MONO_TYPE_ISSTRUCT (sig->ret)) {
 		ArgInfo *ainfo = &cinfo->ret;
-		inst = cfg->ret;
+
+		if (cfg->new_ir)
+			inst = cfg->vret_addr;
+		else
+			inst = cfg->ret;
+		g_assert (inst);
+
 		if (ppc_is_imm16 (inst->inst_offset)) {
 			ppc_stw (code, ainfo->reg, inst->inst_offset, inst->inst_basereg);
 		} else {
@@ -3735,8 +3846,15 @@
 				if (ainfo->vtsize) {
 					/* load the previous stack pointer in r11 (r0 gets overwritten by the memcpy) */
 					ppc_lwz (code, ppc_r11, 0, ppc_sp);
-					/* FIXME: handle overrun! with struct sizes not multiple of 4 */
-					code = emit_memcpy (code, ainfo->vtsize * sizeof (gpointer), inst->inst_basereg, doffset, ppc_r11, ainfo->offset + soffset);
+					if ((size & 3) != 0) {
+						code = emit_memcpy (code, size - soffset,
+							inst->inst_basereg, doffset,
+							ppc_r11, ainfo->offset + soffset);
+					} else {
+						code = emit_memcpy (code, ainfo->vtsize * sizeof (gpointer),
+							inst->inst_basereg, doffset,
+							ppc_r11, ainfo->offset + soffset);
+					}
 				}
 			} else if (ainfo->regtype == RegTypeStructByAddr) {
 				/* if it was originally a RegTypeBase */
