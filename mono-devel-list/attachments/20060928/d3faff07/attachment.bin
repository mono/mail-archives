// project created on 27/09/2006 at 12:05
using System;
using System.Diagnostics;
using System.Collections;
using System.Text;
using Mono.Posix;
using Mono.Unix;
using System.IO;
using System.Text.RegularExpressions;

namespace wapi_analyser
{
	class MainClass
	{
		
		Hashtable process=new Hashtable();
		Hashtable threads=new Hashtable();
		
		public static void Main(string[] args)
		{
			MainClass main=new MainClass();
			main.Analyse(main.GetData());
			main.Display();
		}
		
		public void Display()
		{
			foreach (int pid in process.Keys)
			{
				// Récupération de la ligne de commande:
					string filename="/proc/"+pid+"/cmdline";
				string cmdline="";
				try
				{
					StreamReader re = File.OpenText(filename);
					cmdline=re.ReadToEnd();
				}catch {}
				Console.WriteLine("Pid : "+pid+" Nom :"+process[pid]+" cmd : "+cmdline+" Nb threads :"+GetNbThread(pid));

			}
			
		}
		
		public int GetNbThread(int pid)
		{
			int counter=0;
			foreach (string id in threads.Keys)
			{
				if (((int)threads[id])==pid)
					counter++;
			}
			return counter;
			
		}
		
		
		
		public void Analyse(string stringdata)
		{
			string[] rawtable=stringdata.Split('\n');
			Console.WriteLine(rawtable.Length+" Handle");
			ArrayList sortedtable=new ArrayList();
			bool record=false;
			foreach (String line in rawtable)
			{
				if (line.StartsWith("collection"))
					record=true;
				if (line.Trim().StartsWith("Fileshare"))
				{
					record=false;
				}
				if (record)
					sortedtable.Add(line);
				// Check if this is a process
				if (line.IndexOf("[Process]")!=-1)
				{
					//Console.WriteLine("Process");
					// Extraction du nom du process
					string pattern=@"\[\s+.*]";
					Match match= Regex.Match(line,pattern);
					
					string processname=match.ToString();
					processname=processname.Trim(new char[]{'[',']'}).Trim();
					//Console.WriteLine(processname);
					// Extraction du pid
					pattern=@"pid:\s*\S*\s";
					match= Regex.Match(line,pattern);
					string pid=match.ToString();
					pid=pid.Replace("pid: ","");
					//Console.WriteLine(pid);
					try{
					int pidint=int.Parse(pid);
						process.Add(pidint,processname);
					}catch
					{
						Console.WriteLine("Erreur while parsing "+pid);
						Console.WriteLine("Ligne "+line);
					}
					
				}
				if (line.IndexOf("[ Thread]")!=-1)
				{
					//Console.WriteLine("Thread");
					// Extraction du thread id
//					string pattern=@"tid:\s\S*,";
//					Match match= Regex.Match(line,pattern);
//					string tid=match.ToString();
//					tid=tid.Replace("tid: -","");
//					tid=tid.Replace(",","");
//					int tidint=int.Parse(tid);
					//Console.WriteLine(tidint);
					// Recherche du pid du process
					string pattern=@"proc:\s\S*,";
					Match match= Regex.Match(line,pattern);
					string proc=match.ToString();					
					proc=proc.Replace("proc: ","");
					proc=proc.Replace(",","");
					int procint=int.Parse(proc);
					//Console.WriteLine(procint);
					threads.Add(Guid.NewGuid().ToString(),procint);
				}
				
				
				
				
			}
			//Console.WriteLine(sortedtable.Count);
			
		}
		
		
		public string GetData()
		{
			Process process=new Process();
			ProcessStartInfo info=new ProcessStartInfo();
			info.FileName="/usr/bin/mono";
			info.Arguments="--wapi=hps";
			info.UseShellExecute = false;
            info.RedirectStandardOutput = true;
			info.RedirectStandardError = true;
			process.StartInfo=info;
			process.Start();
			string sortie=process.StandardOutput.ReadToEnd();
			process.WaitForExit();
			//Console.WriteLine(sortie);
			return sortie;
			

		}
		
	}
}