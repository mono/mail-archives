Index: Mono.Data.Tds.dll.sources
===================================================================
--- Mono.Data.Tds.dll.sources	(revision 70777)
+++ Mono.Data.Tds.dll.sources	(working copy)
@@ -11,6 +11,7 @@
 Mono.Data.Tds.Protocol/Tds70.cs
 Mono.Data.Tds.Protocol/Tds80.cs
 Mono.Data.Tds.Protocol/TdsBigDecimal.cs
+Mono.Data.Tds.Protocol/TdsCharset.cs
 Mono.Data.Tds.Protocol/TdsColumnStatus.cs
 Mono.Data.Tds.Protocol/TdsColumnType.cs
 Mono.Data.Tds.Protocol/TdsComm.cs
@@ -27,10 +28,12 @@
 Mono.Data.Tds.Protocol/TdsInternalException.cs
 Mono.Data.Tds.Protocol/TdsInternalInfoMessageEventArgs.cs
 Mono.Data.Tds.Protocol/TdsInternalInfoMessageEventHandler.cs
+Mono.Data.Tds.Protocol/TdsLogger.cs
 Mono.Data.Tds.Protocol/TdsPacketSubType.cs
 Mono.Data.Tds.Protocol/TdsPacketType.cs
 Mono.Data.Tds.Protocol/TdsTimeoutException.cs
 Mono.Data.Tds.Protocol/TdsVersion.cs
+Mono.Data.Tds.Protocol/TdsTlsNetworkStream.cs
 ../../build/common/MonoTODOAttribute.cs
 Mono.Data.Tds.Protocol/TdsAsyncState.cs
 Mono.Data.Tds.Protocol/TdsAsyncResult.cs
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 70777)
+++ ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2007-01-11  Dmitry S. Kataev  <dmitryskey@hotmail.com>
+
+	* Mono.Data.Tds.dll.sources: In Mono.Data.Tds.Protocol
+	Added TdsCharset.cs TdsLogger.cs TdsTlsNetworkStream.cs.
+
 2005-09-21 Senganal T  <tsenganal@novell.com>
 
 	* Mono.Data.Tds.Protocol/Tds.cs: 
Index: Mono.Data.Tds.Protocol/TdsLogger.cs
===================================================================
--- Mono.Data.Tds.Protocol/TdsLogger.cs	(revision 0)
+++ Mono.Data.Tds.Protocol/TdsLogger.cs	(revision 0)
@@ -0,0 +1,169 @@
+//
+// Mono.Data.Tds.Protocol.TdsLogger.cs
+//
+// Author:
+//   Dmitry S. Kataev <dmitryskey@hotmail.com>
+//
+// Copyright (C) 2006,2007 Dmitry S. Kataev
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+#define TRACE
+
+using System;
+using System.Text;
+using System.Threading;
+using System.IO;
+using System.Globalization;
+using System.Diagnostics;
+
+namespace Mono.Data.Tds.Protocol {
+	internal sealed class TdsLoggerSwitch : Switch
+	{
+		public TdsLoggerSwitch (string displayName, string description): base(displayName, description)
+		{
+		}
+		
+		public bool IsEnabled {
+			get {return (SwitchSetting != 0);}
+		}			
+	}
+	
+	internal sealed class TdsLogger
+	{
+		public static string ToHexString (byte[] array, int offset, int length)
+		{
+			if (array != null)
+			{
+				StringBuilder result = new StringBuilder ((array.Length - offset) * 2);
+				for(int i = offset; i < array.Length && i < length; i++)
+					result.Append (array[i].ToString("X2", 
+						System.Globalization.CultureInfo.InvariantCulture)).Append (" ");
+				return result.ToString ();
+			}
+			else
+				return "NULL";
+		}
+		
+		private static TdsLoggerSwitch mSwitcher = new TdsLoggerSwitch ("TraceLevel", "Trace Level");
+		
+		public static bool IsEnabled {
+			get { return mSwitcher.IsEnabled;}
+		}
+		
+		private static void DumpBytes (byte[] data, int length)
+		{
+			length = System.Math.Min (data.Length, length);
+		
+			StringBuilder dump = new StringBuilder ();
+		        for (int i = 0; i <= length / 0x10; i++)
+			{
+				int tailLen = System.Math.Min (0x10, 0x10 - ((i + 1) * 0x10 - length));
+				
+				if (tailLen > 0)
+				{			
+					dump.Append ((i * 0x10).ToString ("X", CultureInfo.InvariantCulture).PadLeft (4)).Append("  ");
+
+					for (int k = 0; k < tailLen; k++)
+						dump.Append(data[i * 0x10 + k].ToString ("X2", CultureInfo.InvariantCulture)).Append(" ");
+													    
+					dump.Append ("  |".PadLeft ((0x10 - tailLen + 1) * 3));
+				
+					string dumpStr = Encoding.ASCII.GetString (data, i * 0x10, tailLen).PadRight (0x10);
+					foreach (char ch in dumpStr)
+						dump.Append (char.IsControl(ch) ? ' ' : ch);
+					
+					dump.Append ("|\n");
+				}
+			}
+			
+			Trace.WriteLine (dump.ToString ());
+		}
+		
+		public static void DumpString (string data)
+		{
+			if (mSwitcher.IsEnabled)
+				Trace.WriteLine (data);
+		}
+		
+		public static void DumpPacket (byte[] header, byte[] body, bool direction)
+		{
+			if (mSwitcher.IsEnabled)
+			{
+				byte[] packet = new byte[header.Length + body.Length];
+				header.CopyTo (packet, 0);
+				Array.Copy (body, 0, packet, header.Length, body.Length);
+				DumpPacket (packet, direction);
+			}
+		}
+		
+		public static void DumpPacket (byte[] packet, bool direction)
+		{
+			if (mSwitcher.IsEnabled)
+			{
+				int length = packet[2] * 0x100 + packet[3];
+				StringBuilder dump = new StringBuilder ();
+				dump.Append ("--- ");
+				dump.Append (direction ? "Read" : "Send");
+				dump.Append (packet[1] != 0 ? " Last " : " ");
+				
+				switch (packet[0]) {
+				case (byte)TdsPacketType.Query:
+					dump.Append ("Query Packet");
+					break;
+				case (byte)TdsPacketType.Logon:
+					dump.Append ("Logon Packet");
+					break;
+				case (byte)TdsPacketType.RPC:
+					dump.Append ("RPC Packet");
+					break;
+				case (byte)TdsPacketType.Reply:
+					dump.Append ("Reply Packet");
+					break;
+				case (byte)TdsPacketType.Cancel:
+					dump.Append ("Cancel Packet ");
+					break;
+				case (byte)TdsPacketType.Logon70:
+					dump.Append ("MS Logon Packet ");
+					break;
+				case (byte)TdsPacketType.SspAuth:
+					dump.Append ("NTLM Authentication Packet ");
+					break;
+				case (byte)TdsPacketType.PreLogin:
+				        dump.Append ("MS Prelogin Packet ");
+					break;
+				case (byte)TdsPacketType.Logoff:
+				        dump.Append ("Logoff Packet ");
+					break;
+				default:
+					dump.Append ("Unknown Packet Type " + packet[0].ToString());
+					break;
+				}
+				
+				Trace.WriteLine (dump.ToString ());
+				
+				DumpBytes (packet, length);																																																														    
+			}
+		}																																		
+	}
+}
Index: Mono.Data.Tds.Protocol/Tds50.cs
===================================================================
--- Mono.Data.Tds.Protocol/Tds50.cs	(revision 70777)
+++ Mono.Data.Tds.Protocol/Tds50.cs	(working copy)
@@ -468,7 +468,7 @@
 			int totalLength = Comm.GetTdsShort ();	
 			int count = Comm.GetTdsShort ();
 			for (int i = 0; i < count; i += 1) {
-				string columnName = Comm.GetString (Comm.GetByte ());
+				string columnName = Comm.GetString (Comm.GetByte (), null);
 				int status = Comm.GetByte ();
 				bool hidden = (status & 0x01) > 0;
 				bool isKey = (status & 0x02) > 0;
Index: Mono.Data.Tds.Protocol/TdsVersion.cs
===================================================================
--- Mono.Data.Tds.Protocol/TdsVersion.cs	(revision 70777)
+++ Mono.Data.Tds.Protocol/TdsVersion.cs	(working copy)
@@ -3,8 +3,10 @@
 //
 // Author:
 //   Daniel Morgan <danmorg@sc.rr.com>
+//   Dmitry S. Kataev <dmitryskey@hotmail.com>
 //
 // Copyright (C) 2002 Daniel Morgan
+// Portions (C) 2006,2007 Dmitry S. Kataev
 //
 
 //
@@ -31,9 +33,10 @@
 namespace Mono.Data.Tds.Protocol {
 	public enum TdsVersion
 	{
-                tds42 = 42, // used by older Sybase and Microsoft SQL (< 7.0) servers
-                tds50 = 50, // used by Sybase
-                tds70 = 70, // used by Microsoft SQL server 7.0/2000
-                tds80 = 80  // used by Microsoft SQL server 2000
+		tds42 = 42, // used by older Sybase and Microsoft SQL (< 7.0) servers
+		tds50 = 50, // used by Sybase
+		tds70 = 70, // used by Microsoft SQL server 7.0/2000
+		tds80 = 80, // used by Microsoft SQL server 2000
+		tds81 = 81  // used by Microsoft SQL server 2000 SP1/2005
 	}
 }
Index: Mono.Data.Tds.Protocol/Tds42.cs
===================================================================
--- Mono.Data.Tds.Protocol/Tds42.cs	(revision 70777)
+++ Mono.Data.Tds.Protocol/Tds42.cs	(working copy)
@@ -253,7 +253,7 @@
 
 					int tableNameLength = Comm.GetTdsShort ();
 					bytesRead += 2;
-					tableName = Comm.GetString (tableNameLength);
+					tableName = Comm.GetString (tableNameLength, null);
 					bytesRead += tableNameLength;
 					bufLength = 2 << 31 - 1;
 				}
Index: Mono.Data.Tds.Protocol/Tds70.cs
===================================================================
--- Mono.Data.Tds.Protocol/Tds70.cs	(revision 70777)
+++ Mono.Data.Tds.Protocol/Tds70.cs	(working copy)
@@ -6,10 +6,12 @@
 //   Diego Caravana (diego@toth.it)
 //   Sebastien Pouliot (sebastien@ximian.com)
 //   Daniel Morgan (danielmorgan@verizon.net)
+//   Dmitry S. Kataev (dmitryskey@hotmail.com)
 //
 // Copyright (C) 2002 Tim Coleman
 // Portions (C) 2003 Motus Technologies Inc. (http://www.motus.com)
 // Portions (C) 2003 Daniel Morgan
+// Portions (C) 2006,2007 Dmitry S. Kataev
 //
 
 //
@@ -38,11 +40,13 @@
 using System.Text;
 
 namespace Mono.Data.Tds.Protocol {
+
         public class Tds70 : Tds
 	{
 		#region Fields
 
 		public readonly static TdsVersion Version = TdsVersion.tds70;
+		internal SslMode EncryptionMode = SslMode.NoEncryption;
 
 		#endregion // Fields
 
@@ -178,7 +182,7 @@
 				magic = domainMagic;
 			else
 				magic = sqlserverMagic;
-			
+				
 			string username = connectionParameters.User;
 
 			string domain = Environment.UserDomainName;
@@ -216,8 +220,14 @@
 			
 			Comm.Append (totalPacketSize);
 
-			Comm.Append (empty, 3, pad);
-			Comm.Append ((byte) 0x70); // TDS Version 7
+			//Comm.Append (empty, 3, pad);
+			//Comm.Append ((byte) 0x70); // TDS Version 7
+			
+			if (tdsVersion == TdsVersion.tds70)
+				Comm.Append((int)0x70000000);
+			else
+				Comm.Append((int)0x71000001);
+			
 			Comm.Append ((int)this.PacketSize); // Set the Block Size
 			Comm.Append (empty, 3, pad);
 			Comm.Append (magic);
@@ -332,7 +342,12 @@
 
 			Comm.Append (connectionParameters.AttachDBFileName);
 			Comm.SendPacket ();
+			
+			if (EncryptionMode != SslMode.NoEncryption && EncryptionMode == SslMode.EncryptLogin)
+				Comm.DisableEncryption();
+			
 			MoreResults = true;
+			
 			SkipToEnd ();
 			
 			return IsConnected;
@@ -541,16 +556,24 @@
 
 				int columnSize;
 				string tableName = null;
+				byte[] collation = null;
 
 				if (IsBlobType (columnType)) {
 					columnSize = Comm.GetTdsInt ();
-					tableName = Comm.GetString (Comm.GetTdsShort ());
+					
+					if (tdsVersion > TdsVersion.tds80) 
+						collation = Comm.GetBytes (5, true);
+										
+					tableName = Comm.GetString (Comm.GetTdsShort (), null);
 				}
-
 				else if (IsFixedSizeColumn (columnType))
 					columnSize = LookupBufferSize (columnType);
-				else if (IsLargeType ((TdsColumnType) xColumnType))
+				else if (IsLargeType ((TdsColumnType) xColumnType)) {
 					columnSize = Comm.GetTdsShort ();
+					
+					if (tdsVersion > TdsVersion.tds70) 
+						collation = Comm.GetBytes (5, true);
+				}
 				else
 					columnSize = Comm.GetByte () & 0xff;
 
@@ -570,7 +593,18 @@
 					break;
 				}
 
-				string columnName = Comm.GetString (Comm.GetByte ());
+				string columnName = Comm.GetString (Comm.GetByte (), null);
+				
+				Encoding enc = Comm.Encoder;
+				if (collation != null)
+				{
+					if (collation[4] != 0)
+						enc = TdsCharset.GetEncodingFromSortOrder(collation[4]);
+					else
+						enc = TdsCharset.GetEncodingFromLCID(
+						    (collation[2] & 0x0F) * 0x10000 +
+						    collation[1] * 0x100 + collation[0]);
+				}
 
 				int index = result.Add (new TdsDataColumn ());
 				result[index]["AllowDBNull"] = nullable;
@@ -583,6 +617,7 @@
 				result[index]["NumericPrecision"] = precision;
 				result[index]["NumericScale"] = scale;
 				result[index]["BaseTableName"] = tableName;
+				result[index]["Encoder"] = enc;
 			}
 
 			return result;
@@ -644,7 +679,6 @@
                         EndExecuteQueryInternal (ar);
                 }
 
-
                 public override IAsyncResult BeginExecuteProcedure (string prolog,
                                                                     string epilog,
                                                                     string cmdText,
Index: Mono.Data.Tds.Protocol/Tds80.cs
===================================================================
--- Mono.Data.Tds.Protocol/Tds80.cs	(revision 70777)
+++ Mono.Data.Tds.Protocol/Tds80.cs	(working copy)
@@ -3,8 +3,10 @@
 //
 // Author:
 //   Tim Coleman (tim@timcoleman.com)
+//   Dmitry S. Kataev (dmitryskey@hotmail.com)
 //
 // Copyright (C) 2002 Tim Coleman
+// Portions (C) 2006,2007 Dmitry S. Kataev
 //
 
 //
@@ -30,26 +32,24 @@
 
 using Mono.Data.Tds;
 using System;
+using System.IO;
 
 namespace Mono.Data.Tds.Protocol {
-        public class Tds80 : Tds
+        public class Tds80 : Tds70
 	{
-		#region Fields
-
-		public static readonly TdsVersion Version = TdsVersion.tds80;
-
-		#endregion // Fields
-
 		#region Constructors
 
-		public Tds80 (string server, int port)
-			: this (server, port, 512, 15)
+		public Tds80 (string server, string instanceName, int port, bool encrypt)
+			: this (server, instanceName, port, 512, 15, encrypt)
 		{
 		}
 
-		public Tds80 (string server, int port, int packetSize, int timeout)
-			: base (server, port, packetSize, timeout, Version)
+		public Tds80 (string server, string instanceName, int port, int packetSize, int timeout, bool encrypt)
+			: base (server, port, packetSize, timeout)
 		{
+			tdsVersion = TdsVersion.tds80;
+			if (encrypt && (EncryptionMode = PreLogin(instanceName)) != SslMode.NoEncryption)
+				Comm.EnableEncryption(EncryptionMode);
 		}
 
 		#endregion // Constructors
@@ -58,14 +58,106 @@
 
 		public override bool Connect (TdsConnectionParameters connectionParameters)
 		{
-			throw new NotImplementedException ();
+			try
+			{
+				return base.Connect (connectionParameters);
+			}
+			catch (Exception ex)
+			{
+				if (Comm.LastSslError != null && Comm.LastSslError != String.Empty)
+				        throw new IOException(Comm.LastSslError, ex);
+				else
+				        throw;
+			} 
 		}
 
-		protected override TdsDataColumnCollection ProcessColumnInfo ()
+		private SslMode PreLogin (string instanceName)
 		{
-			throw new NotImplementedException ();
+			const short startPos = 21;
+			Comm.StartPacket(TdsPacketType.PreLogin);
+
+			// Write Netlib pointer
+			Comm.Append((short)0);
+			Comm.Append((short)startPos);
+			Comm.Append((byte)6);
+
+			// Write Encrypt flag pointer
+			Comm.Append((short)1);
+			Comm.Append((short)(startPos + 6));
+			Comm.Append((byte)1);
+
+			// Write Instance name pointer
+			Comm.Append((short)2);
+			Comm.Append((short)(startPos + 6 + 1));
+			Comm.Append((byte)(instanceName.Length + 1));
+
+			// Write process ID pointer
+			Comm.Append((short)3);
+			Comm.Append((short)(startPos + 6 + 1 + instanceName.Length + 1));
+			Comm.Append((byte)4);
+
+			// Write terminator
+			Comm.Append((byte)0xFF);
+
+			// Write fake net lib ID 8.341.0
+			Comm.Append(new byte[] { 0x08, 0x00, 0x01, 0x55, 0x00, 0x00 });
+
+			// Write force encryption flag
+			Comm.Append((byte)0);
+
+			// Write instance name
+			Comm.Append(instanceName);
+			Comm.Append((byte)0);
+
+			// Write dummy process ID
+			Comm.Append(new byte[] { 0x01, 0x02, 0x00, 0x00 });
+			
+			Comm.SendPacket();
+
+			const int entryNumber = 8, recordSize = 5;
+
+			int entriesPtr = -1;
+			byte[] responseEntries = new byte[entryNumber * recordSize + 1];
+			byte[][] responseData = new byte[entryNumber][];
+
+			do
+			{
+				if (++entriesPtr > entryNumber * recordSize)
+					throw new IOException("The prelogin packet has more than " + entryNumber + " entries");
+				responseEntries[entriesPtr] = Comm.GetByte();
+			}
+			while (responseEntries[entriesPtr] != 0xFF);
+
+			if (TdsLogger.IsEnabled)
+				TdsLogger.DumpString("PreLogin server response");
+
+			for (int i = 0; i < entriesPtr / recordSize; i++)
+			{
+				responseData[i] = new byte[responseEntries[i * recordSize + recordSize - 1]];
+				Comm.GetBytes(responseData[i].Length, true).CopyTo(responseData[i], 0);
+				
+				if (TdsLogger.IsEnabled)
+		            		TdsLogger.DumpString("Record " + i + " = " + 
+						TdsLogger.ToHexString(responseData[i], 0, responseData[i].Length));
+			}
+
+			if (entriesPtr / recordSize > 1)
+				switch (responseData[1][0])
+				{
+					case 0:
+						return SslMode.EncryptLogin;
+					case 1:
+						return SslMode.ClientForceEncryption;
+					case 3:
+						return SslMode.ServerForceEncryption;
+					default:
+						return SslMode.NoEncryption;
+				}
+			else
+				return SslMode.NoEncryption;
 		}
 
+
 		#endregion // Methods
 	}
 }
Index: Mono.Data.Tds.Protocol/TdsConnectionPool.cs
===================================================================
--- Mono.Data.Tds.Protocol/TdsConnectionPool.cs	(revision 70777)
+++ Mono.Data.Tds.Protocol/TdsConnectionPool.cs	(working copy)
@@ -69,7 +69,7 @@
 				case TdsVersion.tds70:
 					return new Tds70 (info.DataSource, info.Port, info.PacketSize, info.Timeout);
 				case TdsVersion.tds80:
-					return new Tds80 (info.DataSource, info.Port, info.PacketSize, info.Timeout);
+					return new Tds80 (info.DataSource, info.InstanceName, info.Port, info.PacketSize, info.Timeout, info.Encrypt);
 			}
 			throw new NotSupportedException ();
 		}
@@ -77,22 +77,26 @@
 	
 	public class TdsConnectionInfo
 	{
-		public TdsConnectionInfo (string dataSource, int port, int packetSize, int timeout, int minSize, int maxSize)
+		public TdsConnectionInfo (string dataSource, string instanceName, int port, int packetSize, int timeout, int minSize, int maxSize, bool encrypt)
 		{
 			DataSource = dataSource;
+			InstanceName = instanceName;
 			Port = port;
 			PacketSize = packetSize;
 			Timeout = timeout;
 			PoolMinSize = minSize;
 			PoolMaxSize = maxSize;
+			Encrypt = encrypt;
 		}
 		
 		public string DataSource;
+		public string InstanceName;
 		public int Port;
 		public int PacketSize;
 		public int Timeout;
 		public int PoolMinSize;
 		public int PoolMaxSize;
+		public bool Encrypt;
 	}
 	
 	public class TdsConnectionPool
Index: Mono.Data.Tds.Protocol/ChangeLog
===================================================================
--- Mono.Data.Tds.Protocol/ChangeLog	(revision 70777)
+++ Mono.Data.Tds.Protocol/ChangeLog	(working copy)
@@ -1,3 +1,27 @@
+2007-01-11  Dmitry S. Kataev <dmitryskey@hotmail.com>
+
+	* Tds.cs:
+		- added support of column collations
+		- added log messages for the changing of database, block size
+		and language
+		- the server protocol version is set after login phase
+	* Tds42.cs, Tds50.cs : minor changes due to new signature of GetString
+	* Tds70.cs:
+		- added support of encryption for the TDS version > 7
+		- added column collation for the TDS version > 7
+	* Tds80.cs: add implementation of prelogin phase
+	* TdsCharset.cs : added support of SQL Server collations
+	* TdsComm.cs : 
+		- added Ssl/Tls encryption
+		- minor code reformatting
+	* TdsConnectionPool.cs : 
+		- SQL Server instance name is returned
+		- added encryption flag
+	* TdsLogger.cs : added TDS network packet logger
+	* TdsPacketType.cs : added PreLogin packet type
+	* TdsTlsNetworkStream.cs : added support of TDS/TLS encrypted streams
+	* TdsVersion.cs : added TDS 8.1 protocol type
+
 2006-07-18  Dean Brettle <dean@brettle.com>
 
 	* Tds70.cs : Fixed bug in FormatParameter() which caused 
Index: Mono.Data.Tds.Protocol/TdsPacketType.cs
===================================================================
--- Mono.Data.Tds.Protocol/TdsPacketType.cs	(revision 70777)
+++ Mono.Data.Tds.Protocol/TdsPacketType.cs	(working copy)
@@ -4,9 +4,11 @@
 // Author:
 //   Tim Coleman (tim@timcoleman.com)
 //   Daniel Morgan (danielmorgan@verizon.net)
+//   Dmitry S. Kataev (dmitryskey@hotmail.com)
 //
 // Copyright (C) 2002 Tim Coleman
 // Portions (C) 2003 Daniel Morgan
+// Portions (C) 2006,2007 Dmitry S. Kataev
 //
 
 //
@@ -31,7 +33,7 @@
 //
 
 namespace Mono.Data.Tds.Protocol {
-        public enum TdsPacketType
+	public enum TdsPacketType
 	{
 		None = 0x0,
 		Query = 0x1,
@@ -41,6 +43,7 @@
 		Cancel = 0x6,
 		Logon70 = 0x10,
 		SspAuth = 0x11,
+		PreLogin = 0x12,
 		Logoff = 0x71,
 		Normal = 0x0f,
 		DBRPC = 0xe6,
Index: Mono.Data.Tds.Protocol/Tds.cs
===================================================================
--- Mono.Data.Tds.Protocol/Tds.cs	(revision 70777)
+++ Mono.Data.Tds.Protocol/Tds.cs	(working copy)
@@ -5,10 +5,12 @@
 //   Tim Coleman (tim@timcoleman.com)
 //   Sebastien Pouliot (spouliot@motus.com)
 //   Daniel Morgan (danielmorgan@verizon.net)
+//   Dmitry S. Kataev (dmitryskey@hotmail.com)
 //
 // Copyright (C) 2002 Tim Coleman
 // Portions (C) 2003 Motus Technologies Inc. (http://www.motus.com)
 // Portions (C) 2003,2005 Daniel Morgan
+// Portions (C) 2006,2007 Dmitry S. Kataev
 //
 
 //
@@ -46,7 +48,7 @@
 		#region Fields
 
 		TdsComm comm;
-		TdsVersion tdsVersion;
+		protected TdsVersion tdsVersion;
 		
 		protected internal TdsConnectionParameters connectionParms;
 		protected readonly byte[] NTLMSSP_ID = new byte[] {0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00};
@@ -610,18 +612,18 @@
 			case TdsColumnType.Text :
 				if (outParam) 
 					comm.Skip (1);
-				element = GetTextValue (false);
+				element = GetTextValue (false, (Encoding) columns[ordinal]["Encoder"]);
 				break;
 			case TdsColumnType.NText :
 				if (outParam) 
 					comm.Skip (1);
-				element = GetTextValue (true);
+				element = GetTextValue (true, (Encoding) columns[ordinal]["Encoder"]);
 				break;
 			case TdsColumnType.Char :
 			case TdsColumnType.VarChar :
 				if (outParam)
 					comm.Skip (1);
-				element = GetStringValue (false, false);
+				element = GetStringValue (false, false, (Encoding) columns[ordinal]["Encoder"]);
 				break;
 			case TdsColumnType.BigVarBinary :
 				comm.GetTdsShort ();
@@ -630,13 +632,13 @@
 				break;
 			case TdsColumnType.BigVarChar :
 				comm.Skip (2);
-				element = GetStringValue (false, false);
+				element = GetStringValue (false, false, (Encoding) columns[ordinal]["Encoder"]);
 				break;
 			case TdsColumnType.NChar :
 			case TdsColumnType.NVarChar :
 				if (outParam) 
 					comm.Skip (1);
-				element = GetStringValue (true, false);
+				element = GetStringValue (true, false, (Encoding) columns[ordinal]["Encoder"]);
 				break;
 			case TdsColumnType.Real :
 			case TdsColumnType.Float8 :
@@ -734,7 +736,7 @@
 		{
 			int len;
 			object result = DBNull.Value;
-			if (tdsVersion == TdsVersion.tds70) {
+			if (tdsVersion >= TdsVersion.tds70) {
 				len = comm.GetTdsShort ();
 				if (len != 0xffff && len > 0)
 					result = comm.GetBytes (len, true);
@@ -939,7 +941,6 @@
 		private object GetMoneyValue (TdsColumnType type)
 		{
 			int len;
-			object result = null;
 
 			switch (type) {
 			case TdsColumnType.SmallMoney :
@@ -968,9 +969,9 @@
 			}
 		}
 
-		private object GetStringValue (bool wideChars, bool outputParam)
+		private object GetStringValue (bool wideChars, bool outputParam, Encoding encoder)
 		{
-			bool shortLen = (tdsVersion == TdsVersion.tds70) && (wideChars || !outputParam);
+			bool shortLen = (tdsVersion >= TdsVersion.tds70) && (wideChars || !outputParam);
 			int len = shortLen ? comm.GetTdsShort () : (comm.GetByte () & 0xff);
 
 			if (tdsVersion < TdsVersion.tds70 && len == 0)
@@ -978,9 +979,9 @@
 			else if (len >= 0) {
 				object result;
 				if (wideChars)
-					result = comm.GetString (len / 2);
+					result = comm.GetString (len / 2, encoder);
 				else
-					result = comm.GetString (len, false);
+					result = comm.GetString (len, false, encoder);
 				if (tdsVersion < TdsVersion.tds70 && ((string) result).Equals (" "))
 					result = "";
 				return result;
@@ -994,7 +995,7 @@
 			return comm.GetTdsShort ();
 		}
 
-		private object GetTextValue (bool wideChars)
+		private object GetTextValue (bool wideChars, Encoding encoder)
 		{
 			string result = null;
 			byte hasValue = comm.GetByte ();
@@ -1014,9 +1015,9 @@
 				return "";
 
 			if (wideChars)
-				result = comm.GetString (len / 2);
+				result = comm.GetString (len / 2, encoder);
 			else
-				result = comm.GetString (len, false);
+				result = comm.GetString (len, false, encoder);
 				len /= 2;
 
 			if ((byte) tdsVersion < (byte) TdsVersion.tds70 && result == " ")
@@ -1178,7 +1179,7 @@
 
 				bool isAlias = ((values[2] & (byte) TdsColumnStatus.Rename) != 0);
 				if (isAlias) {
-					if (tdsVersion == TdsVersion.tds70) {
+					if (tdsVersion >= TdsVersion.tds70) {
 						columnNameLength = comm.GetByte ();
 						position += 2 * columnNameLength + 1;
 					}
@@ -1186,7 +1187,7 @@
 						columnNameLength = comm.GetByte ();
 						position += columnNameLength + 1;
 					}
-					baseColumnName = comm.GetString (columnNameLength);
+					baseColumnName = comm.GetString (columnNameLength, null);
 				}
 
 				byte index = (byte) (values[0] - (byte) 1);
@@ -1215,7 +1216,7 @@
 
 			while (bytesRead < totalLength) {
 				int columnNameLength = comm.GetByte ();
-				string columnName = comm.GetString (columnNameLength);
+				string columnName = comm.GetString (columnNameLength, null);
 				bytesRead = bytesRead + 1 + columnNameLength;
 				columnNames.Add (columnName);
 				i += 1;
@@ -1269,36 +1270,56 @@
 			case TdsEnvPacketSubType.BlockSize :
 				string blockSize;
 				cLen = comm.GetByte () & 0xff;
-				blockSize = comm.GetString (cLen);
+				blockSize = comm.GetString (cLen, null);
 
-				if (tdsVersion == TdsVersion.tds70) 
+				if (tdsVersion >= TdsVersion.tds70) 
 					comm.Skip (len - 2 - cLen * 2);
 				else 
 					comm.Skip (len - 2 - cLen);
 
 				packetSize = Int32.Parse (blockSize);	
 				comm.ResizeOutBuf (packetSize);
+				
+				if (TdsLogger.IsEnabled)
+					TdsLogger.DumpString("Change block size to " + blockSize);
+				
 				break;
 			case TdsEnvPacketSubType.CharSet :
 				cLen = comm.GetByte () & 0xff;
-				if (tdsVersion == TdsVersion.tds70) {
-					SetCharset (comm.GetString (cLen));
+				if (tdsVersion >= TdsVersion.tds70) {
+					SetCharset (comm.GetString (cLen, null));
 					comm.Skip (len - 2 - cLen * 2);
 				}
 				else {
-					SetCharset (comm.GetString (cLen));
+					SetCharset (comm.GetString (cLen, null));
 					comm.Skip (len - 2 - cLen);
 				}
+				
+				if (TdsLogger.IsEnabled)
+					TdsLogger.DumpString("Set charset to " + charset);
 
 				break;
 			case TdsEnvPacketSubType.Database :
 				cLen = comm.GetByte () & 0xff;
-				string newDB = comm.GetString (cLen);
+				string newDB = comm.GetString (cLen, null);
 				cLen = comm.GetByte () & 0xff;
-				comm.GetString (cLen);
+				comm.GetString (cLen, null);
+				
+				if (TdsLogger.IsEnabled)
+				{
+					string logString = "Change database";
+				
+					if (originalDatabase != null && originalDatabase.Trim() != string.Empty)
+						logString += " from " + originalDatabase; 
+				
+					TdsLogger.DumpString (logString + " to " + newDB);
+				}
+								
 				if (originalDatabase == string.Empty)
 					originalDatabase = newDB;
 				database = newDB;
+				
+				
 				break;
 			default:
 				comm.Skip (len - 1);
@@ -1309,20 +1330,36 @@
 		protected void ProcessLoginAck ()
 		{
 			GetSubPacketLength ();
+			
+			byte ask = comm.GetByte ();
+			
+			int version = comm.GetByte () * 0x1000000 + comm.GetByte () * 0x10000 + comm.GetByte() * 0x100 + comm.GetByte();
 
-			if (tdsVersion == TdsVersion.tds70) {
-				comm.Skip (5);
+			if (version >= 0x71000001) 
+				tdsVersion = TdsVersion.tds81;
+			else 
+				if (version >= 0x07010000) 
+					tdsVersion = TdsVersion.tds80;
+				else 
+					if (version >= 0x07000000) 
+						tdsVersion = TdsVersion.tds70;
+					else 
+						if (version >= 0x05000000) 
+							tdsVersion = TdsVersion.tds50;
+						else 
+			    				tdsVersion = TdsVersion.tds42;
+
+			if (tdsVersion >= TdsVersion.tds70) {
 				int nameLength = comm.GetByte ();
-				databaseProductName = comm.GetString (nameLength);
+				databaseProductName = comm.GetString (nameLength, null);
 				databaseMajorVersion = comm.GetByte ();
 				databaseProductVersion = String.Format ("{0}.{1}.{2}", databaseMajorVersion.ToString("00"),
 								comm.GetByte ().ToString("00"), 
 								(256 * comm.GetByte () + comm.GetByte ()).ToString("0000"));
 			}
 			else {
-				comm.Skip (5);
 				short nameLength = comm.GetByte ();
-				databaseProductName = comm.GetString (nameLength);
+				databaseProductName = comm.GetString (nameLength, null);
 				comm.Skip (1);
 				databaseMajorVersion = comm.GetByte ();
 				databaseProductVersion = String.Format ("{0}.{1}", databaseMajorVersion, comm.GetByte ());
@@ -1372,9 +1409,9 @@
 			} else 
 				isError = (subType == TdsPacketSubType.Error);
 
-			message = comm.GetString (comm.GetTdsShort ());
-			server = comm.GetString (comm.GetByte ());
-			procedure = comm.GetString (comm.GetByte ());
+			message = comm.GetString (comm.GetTdsShort (), null);
+			server = comm.GetString (comm.GetByte (), null);
+			procedure = comm.GetString (comm.GetByte (), null);
 			lineNumber = comm.GetByte ();
 			comm.Skip (1);
 			source = String.Empty; // FIXME
@@ -1388,7 +1425,7 @@
 		protected void ProcessOutputParam ()
 		{
 			GetSubPacketLength ();
-			comm.GetString (comm.GetByte () & 0xff);
+			comm.GetString (comm.GetByte () & 0xff, null);
 			comm.Skip (5);
 
 			TdsColumnType colType = (TdsColumnType) comm.GetByte ();
@@ -1402,7 +1439,7 @@
 			Comm.Skip (2);
 			/*byte type =*/ Comm.GetByte ();
 			/*byte status =*/ Comm.GetByte ();
-			/*string id =*/ Comm.GetString (Comm.GetByte ());
+			/*string id =*/ Comm.GetString (Comm.GetByte (), null);
 		}
 
 		protected virtual TdsPacketSubType ProcessSubPacket ()
@@ -1487,7 +1524,7 @@
 			int len;
 
 			while (position < totalLength) {
-				if (tdsVersion == TdsVersion.tds70) {
+				if (tdsVersion >= TdsVersion.tds70) {
 					len = comm.GetTdsShort ();
 					position += 2 * (len + 1);
 				}
@@ -1495,7 +1532,7 @@
 					len = comm.GetByte ();
 					position += len + 1;
 				}
-				tableNames.Add (comm.GetString (len));
+				tableNames.Add (comm.GetString (len, null));
 			}	
 		}
 
@@ -1520,8 +1557,17 @@
 
 		protected void SetLanguage (string language)
 		{
-			if (language == null || language.Length > 30)
+			if (language == null || language.Trim() == string.Empty || language.Length > 30)
 				language = "us_english";
+				
+			if (TdsLogger.IsEnabled)
+			{
+				string logString = "Change language";
+				if (this.language != null && this.language.Trim() != string.Empty)
+					logString += " from " + this.language;
+					
+				TdsLogger.DumpString(logString + " to " + language); 
+			}
 
 			this.language = language;
 		}
Index: Mono.Data.Tds.Protocol/TdsTlsNetworkStream.cs
===================================================================
--- Mono.Data.Tds.Protocol/TdsTlsNetworkStream.cs	(revision 0)
+++ Mono.Data.Tds.Protocol/TdsTlsNetworkStream.cs	(revision 0)
@@ -0,0 +1,272 @@
+//
+// Mono.Data.Tds.Protocol.TdsTlsNetworkStream.cs
+//
+// Author:
+//   Dmitry S. Kataev <dmitryskey@hotmail.com>
+//
+// Copyright (C) 2006,2007 Dmitry S. Kataev
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Net;
+using System.Net.Sockets;
+using System.Text;
+using System.Threading;
+using System.IO;
+using Mono.Security.Protocol.Tls;
+using System.Security.Cryptography.X509Certificates;
+using System.Runtime.Remoting.Messaging;
+
+namespace Mono.Data.Tds.Protocol {
+	struct TlsData
+	{
+		public const int HeaderSize = 5;			// Size of TLS record header
+		public const int HandshakeHeaderSize = 4;		// TLS handshake header hize
+		public const byte ChangeCipherSpecType = 20;		// TLS change cipher spec record type
+		public const byte AlertType = 21;			// TLS alert record type
+		public const byte HandshakeType = 22;			// TLS handshake record
+		public const byte ClientHelloSubType = 1;		// TLS handshake client hello sub type
+		public const byte ClientKeyExchangeSubType = 16;	// TLS handshake client key exchange sub type
+	}
+	
+	internal sealed class TdsTlsNetworkStream : NetworkStream
+	{
+		private byte[] packetStorage = new byte[0];
+		private byte[] inputBuffer = new byte[6144];
+		private MemoryStream memoryStream = null;
+		private bool isTdsTls = true;
+		private int bytesToRead;
+		private bool isPlainStream = true;
+
+		public bool IsPlainStream {
+			get { return isPlainStream; }
+			set { isPlainStream = value; }
+		}
+
+		public TdsTlsNetworkStream (Socket socket)
+			: base(socket)
+		{
+		}
+
+		public TdsTlsNetworkStream (Socket socket, bool mode, bool isPlain)
+			: base(socket, mode)
+		{
+			isPlainStream = isPlain;
+		}
+
+		delegate void WriteMethod (byte[] buffer, int offset, int size);
+
+		private void WriteInternal (byte[] buffer, int offset, int size)
+		{
+			if (offset > 0 || size < TlsData.HeaderSize)
+			{
+				base.Write(buffer, offset, size);
+				return;
+			}
+
+			switch (buffer[0])
+			{
+				case TlsData.HandshakeType:
+					int bodySize = size - TlsData.HeaderSize - TlsData.HandshakeHeaderSize;
+
+					if (bodySize >= 0)
+					{
+						byte handshakeType = buffer[5];
+						int handshakeSize = buffer[6] * 0x10000 + buffer[7] * 0x100 + buffer[8];
+
+						if (handshakeType == TlsData.ClientHelloSubType && handshakeSize == bodySize)
+							WriteTdsPacket(buffer, size);
+						else
+						{
+							AppendPacketToStorage(buffer, size);
+							if (handshakeType != TlsData.ClientKeyExchangeSubType || handshakeSize != bodySize)
+								FlushStorage();
+						}
+					}
+					else
+						base.Write(buffer, offset, size);
+					break;
+				case TlsData.ChangeCipherSpecType:
+					AppendPacketToStorage(buffer, size);
+					break;
+				case TlsData.AlertType:
+					break;
+				default:
+					base.Write(buffer, offset, size);
+					break;
+			}
+		}
+
+		public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state)
+		{
+			if (isPlainStream)
+				return base.BeginWrite (buffer, offset, size, callback, state);
+			else
+			{
+				WriteMethod r = new WriteMethod (WriteInternal);
+				return r.BeginInvoke (buffer, offset, size, callback, state);
+			}
+		}
+
+		public override void EndWrite (IAsyncResult asyncResult)
+		{
+			if (isPlainStream)
+				base.EndWrite(asyncResult);
+			else
+			{
+				if (asyncResult == null)
+					throw new ArgumentNullException ("asyncResult");
+
+				AsyncResult ares = asyncResult as AsyncResult;
+				if (ares == null)
+					throw new ArgumentException ("Invalid IAsyncResult", "asyncResult");
+
+				WriteMethod r = ares.AsyncDelegate as WriteMethod;
+				if (r == null)
+					throw new ArgumentException ("Invalid IAsyncResult", "asyncResult");
+
+				r.EndInvoke (asyncResult);
+			}
+		}
+
+		public override void Write (byte[] buffer, int offset, int size)
+		{
+			if (isPlainStream)
+				base.Write (buffer, offset, size);
+			else
+				WriteInternal (buffer, offset, size);
+		}
+
+		delegate int ReadMethod (byte[] buffer, int offset, int size);
+
+		private int ReadInternal (byte[] buffer, int offset, int size)
+		{
+			if (isTdsTls && memoryStream == null)
+			{
+				ReadInputStream (inputBuffer, 0, TlsData.HeaderSize);
+
+				if (inputBuffer[0] == (byte)TdsPacketType.Reply || inputBuffer[0] == (byte)TdsPacketType.PreLogin)
+				{
+					bytesToRead = inputBuffer[2] * 0x100 + inputBuffer[3] - TdsComm.HeaderLenght;
+					ReadInputStream (inputBuffer, TlsData.HeaderSize, TdsComm.HeaderLenght - TlsData.HeaderSize);
+					ReadInputStream (inputBuffer, 0, bytesToRead);
+				}
+				else
+				{
+					bytesToRead = inputBuffer[3] * 0x100 + inputBuffer[4];
+					ReadInputStream (inputBuffer, TlsData.HeaderSize, bytesToRead - TlsData.HeaderSize);
+					isTdsTls = false;
+				}
+
+				memoryStream = new MemoryStream (inputBuffer, 0, bytesToRead);
+			}
+
+			int bytesRead = memoryStream.Read (buffer, offset, size);
+			bytesToRead -= bytesRead;
+			if (bytesToRead == 0)
+				memoryStream = null;
+			return bytesRead;
+		}
+
+		public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state)
+		{
+			if (isPlainStream || (!isTdsTls && memoryStream == null))
+				return base.BeginRead (buffer, offset, size, callback, state);
+			else
+			{
+				ReadMethod r = new ReadMethod (ReadInternal);
+				return r.BeginInvoke (buffer, offset, size, callback, state);
+			}
+		}
+
+		public override int EndRead (IAsyncResult asyncResult)
+		{
+			if (isPlainStream || (!isTdsTls && memoryStream == null))
+				return base.EndRead(asyncResult);
+			else
+			{
+				if (asyncResult == null)
+					throw new ArgumentNullException ("asyncResult");
+
+				AsyncResult ares = asyncResult as AsyncResult;
+				if (ares == null)
+					throw new ArgumentException ("Invalid IAsyncResult", "asyncResult");
+
+				ReadMethod r = ares.AsyncDelegate as ReadMethod;
+				if (r == null)
+					throw new ArgumentException ("Invalid IAsyncResult", "asyncResult");
+
+				return r.EndInvoke (asyncResult);
+			}
+		}
+
+		public override int Read (byte[] buffer, int offset, int size)
+		{
+			if (isPlainStream || (!isTdsTls && memoryStream == null))
+				return base.Read (buffer, offset, size);
+			else
+				return ReadInternal (buffer, offset, size);
+		}
+
+		private void ReadInputStream (byte[] buffer, int offset, int size)
+		{
+			for (; ; )
+			{
+				int bytesRead = base.Read (buffer, offset, size);
+				if (size > bytesRead)
+				{
+					size -= bytesRead;
+					offset += bytesRead;
+				}
+				else
+					return;
+			}
+		}
+
+		private void AppendPacketToStorage (byte[] buffer, int size)
+		{
+			byte[] tmpPacket = new byte[packetStorage.Length + size];
+			packetStorage.CopyTo (tmpPacket, 0);
+			Array.Copy (buffer, 0, tmpPacket, packetStorage.Length, size);
+			packetStorage = tmpPacket;
+		}
+
+		private void FlushStorage ()
+		{
+			WriteTdsPacket (packetStorage, packetStorage.Length);
+			packetStorage = new byte[0];
+		}
+
+		private void WriteTdsPacket (byte[] buffer, int size)
+		{
+			byte[] writeBuffer = new byte[TdsComm.HeaderLenght];
+			writeBuffer[0] = (byte)TdsPacketType.PreLogin;
+			writeBuffer[1] = 1;
+			writeBuffer[2] = (byte)((size + TdsComm.HeaderLenght) / 0x100);
+			writeBuffer[3] = (byte)(size + TdsComm.HeaderLenght);
+			base.Write (writeBuffer, 0, writeBuffer.Length);
+			base.Write (buffer, 0, size);
+		}
+	}
+}
Index: Mono.Data.Tds.Protocol/TdsCharset.cs
===================================================================
--- Mono.Data.Tds.Protocol/TdsCharset.cs	(revision 0)
+++ Mono.Data.Tds.Protocol/TdsCharset.cs	(revision 0)
@@ -0,0 +1,263 @@
+//
+// Mono.Data.Tds.Protocol.TdsVersionInternal.cs
+//
+// Author:
+//   Dmitry S. Kataev (dmitryskey@hotmail.com)
+//
+//  Copyright (C) 2006,2007 Dmitry S. Kataev
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System.Collections;
+using System.Text;
+
+namespace Mono.Data.Tds.Protocol {
+	internal static class TdsCharset
+	{
+		private static Hashtable lcidCodes = new Hashtable();
+		private static Hashtable sortCodes = new Hashtable();
+		
+		static TdsCharset ()
+		{
+			lcidCodes[0x436] = 1252;
+			lcidCodes[0x41C] = 1250;
+			lcidCodes[0x401] = 1256;
+			lcidCodes[0x801] = 1256;
+			lcidCodes[0xC01] = 1256;
+			lcidCodes[0x1001] = 1256;
+			lcidCodes[0x1401] = 1256;
+			lcidCodes[0x1801] = 1256;
+			lcidCodes[0x1C01] = 1256;
+			lcidCodes[0x2001] = 1256;
+			lcidCodes[0x2401] = 1256;
+			lcidCodes[0x2801] = 1256;
+			lcidCodes[0x2C01] = 1256;
+			lcidCodes[0x3001] = 1256;
+			lcidCodes[0x3401] = 1256;
+			lcidCodes[0x3801] = 1256;
+			lcidCodes[0x3C01] = 1256;
+			lcidCodes[0x4001] = 1256;
+			lcidCodes[0x42D] = 1252;
+			lcidCodes[0x423] = 1251;
+			lcidCodes[0x402] = 1251;
+			lcidCodes[0x403] = 1252;
+			lcidCodes[0x30404] = 950;
+			lcidCodes[0x404] = 950;
+			lcidCodes[0x804] = 936;
+			lcidCodes[0x20804] = 936;
+			lcidCodes[0x1004] = 936;
+			lcidCodes[0x41a] = 1250;
+			lcidCodes[0x405] = 1250;
+			lcidCodes[0x406] = 1252;
+			lcidCodes[0x413] = 1252;
+			lcidCodes[0x813] = 1252;
+			lcidCodes[0x409] = 1252;
+			lcidCodes[0x809] = 1252;
+			lcidCodes[0x1009] = 1252;
+			lcidCodes[0x1409] = 1252;
+			lcidCodes[0xC09] = 1252;
+			lcidCodes[0x1809] = 1252;
+			lcidCodes[0x1C09] = 1252;
+			lcidCodes[0x2409] = 1252;
+			lcidCodes[0x2009] = 1252;
+			lcidCodes[0x425] = 1257;
+			lcidCodes[0x0438] = 1252;
+			lcidCodes[0x429] = 1256;
+			lcidCodes[0x40B] = 1252;
+			lcidCodes[0x40C] = 1252;
+			lcidCodes[0x80C] = 1252;
+			lcidCodes[0x100C] = 1252;
+			lcidCodes[0xC0C] = 1252;
+			lcidCodes[0x140C] = 1252;
+			lcidCodes[0x10437] = 1252;
+			lcidCodes[0x10407] = 1252;
+			lcidCodes[0x407] = 1252;
+			lcidCodes[0x807] = 1252;
+			lcidCodes[0xC07] = 1252;
+			lcidCodes[0x1007] = 1252;
+			lcidCodes[0x1407] = 1252;
+			lcidCodes[0x408] = 1253;
+			lcidCodes[0x40D] = 1255;
+			lcidCodes[0x439] = 65001;
+			lcidCodes[0x40E] = 1250;
+			lcidCodes[0x104E] = 1250;
+			lcidCodes[0x40F] = 1252;
+			lcidCodes[0x421] = 1252;
+			lcidCodes[0x410] = 1252;
+			lcidCodes[0x810] = 1252;
+			lcidCodes[0x411] = 932;
+			lcidCodes[0x10411] = 932;
+			lcidCodes[0x412] = 949;
+			lcidCodes[0x412] = 949;
+			lcidCodes[0x426] = 1257;
+			lcidCodes[0x427] = 1257;
+			lcidCodes[0x827] = 1257;
+			lcidCodes[0x41C] = 1251;
+			lcidCodes[0x414] = 1252;
+			lcidCodes[0x814] = 1252;
+			lcidCodes[0x415] = 1250;
+			lcidCodes[0x816] = 1252;
+			lcidCodes[0x416] = 1252;
+			lcidCodes[0x418] = 1250;
+			lcidCodes[0x419] = 1251;
+			lcidCodes[0x81A] = 1251;
+			lcidCodes[0xC1A] = 1251;
+			lcidCodes[0x41B] = 1250;
+			lcidCodes[0x424] = 1250;
+			lcidCodes[0x80A] = 1252;
+			lcidCodes[0x40A] = 1252;
+			lcidCodes[0xC0A] = 1252;
+			lcidCodes[0x100A] = 1252;
+			lcidCodes[0x140A] = 1252;
+			lcidCodes[0x180A] = 1252;
+			lcidCodes[0x1C0A] = 1252;
+			lcidCodes[0x200A] = 1252;
+			lcidCodes[0x240A] = 1252;
+			lcidCodes[0x280A] = 1252;
+			lcidCodes[0x2C0A] = 1252;
+			lcidCodes[0x300A] = 1252;
+			lcidCodes[0x340A] = 1252;
+			lcidCodes[0x380A] = 1252;
+			lcidCodes[0x3C0A] = 1252;
+			lcidCodes[0x400A] = 1252;
+			lcidCodes[0x41D] = 1252;
+			lcidCodes[0x41E] = 874;
+			lcidCodes[0x41F] = 1254;
+			lcidCodes[0x422] = 1251;
+			lcidCodes[0x420] = 1256;
+			lcidCodes[0x42A] = 1258;
+							
+			sortCodes[30] = 437;
+			sortCodes[31] = 437;
+			sortCodes[32] = 437;
+			sortCodes[33] = 437;
+			sortCodes[34] = 437;
+			sortCodes[40] = 850;
+			sortCodes[41] = 850;
+			sortCodes[42] = 850;
+			sortCodes[43] = 850;
+			sortCodes[44] = 850;
+			sortCodes[49] = 850;
+			sortCodes[50] = 1252;
+			sortCodes[51] = 1252;
+			sortCodes[52] = 1252;
+			sortCodes[53] = 1252;
+			sortCodes[54] = 1252;
+			sortCodes[55] = 850;
+			sortCodes[56] = 850;
+			sortCodes[57] = 850;
+			sortCodes[58] = 850;
+			sortCodes[59] = 850;
+			sortCodes[60] = 850;
+			sortCodes[61] = 850;
+			sortCodes[71] = 1252;
+			sortCodes[72] = 1252;
+			sortCodes[73] = 1252;
+			sortCodes[74] = 1252;
+			sortCodes[75] = 1252;
+			sortCodes[80] = 1250;
+			sortCodes[81] = 1250;
+			sortCodes[82] = 1250;
+			sortCodes[83] = 1250;
+			sortCodes[84] = 1250;
+			sortCodes[85] = 1250;
+			sortCodes[86] = 1250;
+			sortCodes[87] = 1250;
+			sortCodes[88] = 1250;
+			sortCodes[89] = 1250;
+			sortCodes[90] = 1250;
+			sortCodes[91] = 1250;
+			sortCodes[92] = 1250;
+			sortCodes[93] = 1250;
+			sortCodes[94] = 1250;
+			sortCodes[95] = 1250;
+			sortCodes[96] = 1250;
+			sortCodes[97] = 1250;
+			sortCodes[98] = 1250;
+			sortCodes[104] = 1251;
+			sortCodes[105] = 1251;
+			sortCodes[106] = 1251;
+			sortCodes[107] = 1251;
+			sortCodes[108] = 1251;
+			sortCodes[112] = 1253;
+			sortCodes[113] = 1253;
+			sortCodes[114] = 1253;
+			sortCodes[120] = 1253;
+			sortCodes[121] = 1253;
+			sortCodes[124] = 1253;
+			sortCodes[128] = 1254;
+			sortCodes[129] = 1254;
+			sortCodes[130] = 1254;
+			sortCodes[136] = 1255;
+			sortCodes[137] = 1255;
+			sortCodes[138] = 1255;
+			sortCodes[144] = 1256;
+			sortCodes[145] = 1256;
+			sortCodes[146] = 1256;
+			sortCodes[152] = 1257;
+			sortCodes[153] = 1257;
+			sortCodes[154] = 1257;
+			sortCodes[155] = 1257;
+			sortCodes[156] = 1257;
+			sortCodes[157] = 1257;
+			sortCodes[158] = 1257;
+			sortCodes[159] = 1257;
+			sortCodes[160] = 1257;
+			sortCodes[183] = 1252;
+			sortCodes[184] = 1252;
+			sortCodes[185] = 1252;
+			sortCodes[186] = 1252;
+			sortCodes[192] = 932;
+			sortCodes[193] = 932;
+			sortCodes[194] = 949;
+			sortCodes[195] = 949;
+			sortCodes[196] = 950;
+			sortCodes[197] = 950;
+			sortCodes[198] = 936;
+			sortCodes[199] = 936;
+			sortCodes[200] = 932;
+			sortCodes[201] = 949;
+			sortCodes[202] = 950;
+			sortCodes[203] = 936;
+			sortCodes[204] = 874;
+			sortCodes[205] = 874;
+			sortCodes[206] = 874;
+		}
+		
+		public static Encoding GetEncodingFromLCID (int lcid)
+		{
+			if (lcidCodes[lcid] != null)
+				return Encoding.GetEncoding ((int)lcidCodes[lcid]);
+			else
+				return null;
+		}
+		
+		public static Encoding GetEncodingFromSortOrder(int sort)
+		{
+			if (sortCodes[sort] != null)
+				return Encoding.GetEncoding ((int)sortCodes[sort]);
+			else
+				return null;
+		}
+	} 
+}
Index: Mono.Data.Tds.Protocol/TdsComm.cs
===================================================================
--- Mono.Data.Tds.Protocol/TdsComm.cs	(revision 70777)
+++ Mono.Data.Tds.Protocol/TdsComm.cs	(working copy)
@@ -3,8 +3,10 @@
 //
 // Author:
 //   Tim Coleman (tim@timcoleman.com)
+//   Dmitry S. Kataev (dmitryskey@hotmail.com)
 //
 // Copyright (C) 2002 Tim Coleman
+// Portions (C) 2006,2007 Dmitry S. Kataev
 //
 
 //
@@ -33,13 +35,27 @@
 using System.Net.Sockets;
 using System.Text;
 using System.Threading;
+using System.IO;
+using Mono.Security.Protocol.Tls;
+using System.Security.Cryptography.X509Certificates;
 
 namespace Mono.Data.Tds.Protocol {
-        internal sealed class TdsComm
+	internal enum SslMode
 	{
+		EncryptLogin		= 0,
+		ClientForceEncryption	= 1,
+		NoEncryption		= 2,
+		ServerForceEncryption	= 3
+	}
+
+	internal sealed class TdsComm
+	{
 		#region Fields
-
-		NetworkStream stream;
+		
+		Stream stream;
+		TdsTlsNetworkStream tdsStream;
+		SslClientStream sslStream;
+		string lastSslError;
 		int packetSize;
 		TdsPacketType packetType = TdsPacketType.None;
 		Encoding encoder;
@@ -67,13 +83,12 @@
 		Socket socket;
 		TdsVersion tdsVersion;
 
-		ManualResetEvent connected = new ManualResetEvent (false);
-		
+		ManualResetEvent connected = new ManualResetEvent(false);
+
 		#endregion // Fields
-		
+
 		#region Constructors
 
-		[MonoTODO ("Fix when asynchronous socket connect works on Linux.")]		
 		public TdsComm (string dataSource, int port, int packetSize, int timeout, TdsVersion tdsVersion)
 		{
 			this.packetSize = packetSize;
@@ -88,8 +103,9 @@
 			inBufferLength = packetSize;
 
 			IPEndPoint endPoint;
-			
-			try {
+
+			try
+			{
 				socket = new Socket (AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
 				IPHostEntry hostEntry = Dns.Resolve (dataSource);
 				endPoint = new IPEndPoint (hostEntry.AddressList [0], port);
@@ -110,14 +126,17 @@
 				  throw Tds.CreateTimeoutException (dataSource, "Open()");
 				*/
 
-				stream = new NetworkStream (socket);
-			} catch (SocketException e) {
-				throw new TdsInternalException ("Server does not exist or connection refused.", e);
+				tdsStream = new TdsTlsNetworkStream (socket);
+				stream = tdsStream;
 			}
+			catch (SocketException)
+			{
+				throw;
+			}
 		}
-		
+
 		#endregion // Constructors
-		
+
 		#region Properties
 
 		public int CommandTimeout {
@@ -129,19 +148,28 @@
 			get { return encoder; }
 			set { encoder = value; }
 		}
-		
+
 		public int PacketSize {
 			get { return packetSize; }
 			set { packetSize = value; }
 		}
+
+		public static int HeaderLenght {
+			get { return headerLength; }
+		}
 		
+		public string LastSslError {
+			get { return lastSslError; }
+		}
+
 		#endregion // Properties
-		
+
 		#region Methods
 
-		public byte[] Swap(byte[] toswap) {
+		public byte[] Swap (byte[] toswap)
+		{
 			byte[] ret = new byte[toswap.Length];
-			for(int i = 0; i < toswap.Length; i++)
+			for (int i = 0; i < toswap.Length; i++)
 				ret [toswap.Length - i - 1] = toswap[i];
 
 			return ret;
@@ -175,56 +203,57 @@
 
 		public void Append (byte b)
 		{
-			if (nextOutBufferIndex == outBufferLength) {
+			if (nextOutBufferIndex == outBufferLength)
+			{
 				SendPhysicalPacket (false);
 				nextOutBufferIndex = headerLength;
 			}
 			Store (nextOutBufferIndex, b);
 			nextOutBufferIndex++;
-		}	
-		
+		}
+
 		public void Append (byte[] b)
 		{
 			Append (b, b.Length, (byte) 0);
-		}		
+		}
 
 		public void Append (byte[] b, int len, byte pad)
 		{
 			int i = 0;
 			for ( ; i < b.Length && i < len; i++)
-			    Append (b[i]);
+				Append (b[i]);
 
 			for ( ; i < len; i++)
-			    Append (pad);
-		}	
+				Append (pad);
+		}
 
 		public void Append (short s)
 		{
-			if(!BitConverter.IsLittleEndian)
-				Append (Swap (BitConverter.GetBytes(s)));
-			else 
+			if (!BitConverter.IsLittleEndian)
+				Append (Swap (BitConverter.GetBytes (s)));
+			else
 				Append (BitConverter.GetBytes (s));
 		}
 
 		public void Append (int i)
 		{
-			if(!BitConverter.IsLittleEndian)
-				Append (Swap (BitConverter.GetBytes(i)));
+			if (!BitConverter.IsLittleEndian)
+				Append (Swap (BitConverter.GetBytes (i)));
 			else
 				Append (BitConverter.GetBytes (i));
 		}
 
 		public void Append (string s)
 		{
-			if (tdsVersion < TdsVersion.tds70) 
+			if (tdsVersion < TdsVersion.tds70)
 				Append (encoder.GetBytes (s));
-			else 
+			else
 				foreach (char c in s)
-					if(!BitConverter.IsLittleEndian)
+					if (!BitConverter.IsLittleEndian)
 						Append (Swap (BitConverter.GetBytes (c)));
 					else
 						Append (BitConverter.GetBytes (c));
-		}	
+		}
 
 		// Appends with padding
 		public byte[] Append (string s, int len, byte pad)
@@ -244,7 +273,8 @@
 
 		public void Append (long l)
 		{
-			if (tdsVersion < TdsVersion.tds70) {
+			if (tdsVersion < TdsVersion.tds70)
+			{
 				Append ((byte) (((byte) (l >> 56)) & 0xff));
 				Append ((byte) (((byte) (l >> 48)) & 0xff));
 				Append ((byte) (((byte) (l >> 40)) & 0xff));
@@ -254,7 +284,7 @@
 				Append ((byte) (((byte) (l >> 8)) & 0xff));
 				Append ((byte) (((byte) (l >> 0)) & 0xff));
 			}
-			else 
+			else
 				if (!BitConverter.IsLittleEndian)
 					Append (Swap (BitConverter.GetBytes (l)));
 				else
@@ -269,17 +299,19 @@
 		private void ConnectCallback (IAsyncResult ar)
 		{
 			Socket s = (Socket) ar.AsyncState;
-			if (Poll (s, connectionTimeout, SelectMode.SelectWrite)) {
+			if (Poll (s, connectionTimeout, SelectMode.SelectWrite))
+			{
 				socket.EndConnect (ar);
 				connected.Set ();
 			}
-                }
+		}
 
 		public byte GetByte ()
 		{
 			byte result;
 
-			if (inBufferIndex >= inBufferLength) {
+			if (inBufferIndex >= inBufferLength)
+			{
 				// out of data, read another physical packet.
 				GetPhysicalPacket ();
 			}
@@ -304,15 +336,15 @@
 				result = resBuffer;
 			}
 
-			for (i = 0; i<len; )
+			for (i = 0; i < len; )
 			{
 				if (inBufferIndex >= inBufferLength)
 					GetPhysicalPacket ();
 
 				int avail = inBufferLength - inBufferIndex;
-				avail = avail>len-i ? len-i : avail;
+				avail = avail > len - i ? len - i : avail;
 
-				System.Array.Copy (inBuffer, inBufferIndex, result, i, avail);
+				Array.Copy (inBuffer, inBufferIndex, result, i, avail);
 				i += avail;
 				inBufferIndex += avail;
 			}
@@ -320,29 +352,35 @@
 			return result;
 		}
 
-		public string GetString (int len)
+		public string GetString (int len, Encoding columnEncoder)
 		{
-			if (tdsVersion == TdsVersion.tds70) 
-				return GetString (len, true);
+			if (tdsVersion >= TdsVersion.tds70)
+				return GetString (len, true, columnEncoder);
 			else
-				return GetString (len, false);
+				return GetString (len, false, null);
 		}
 
-		public string GetString (int len, bool wide)
+		public string GetString (int len, bool wide, Encoding columnEncoder)
 		{
-			if (wide) {
+			if (wide)
+			{
 				char[] chars = new char[len];
-				for (int i = 0; i < len; ++i) {
+				for (int i = 0; i < len; ++i)
+				{
 					int lo = ((byte) GetByte ()) & 0xFF;
 					int hi = ((byte) GetByte ()) & 0xFF;
-					chars[i] = (char) (lo | ( hi << 8));
+					chars[i] = (char) (lo | (hi << 8));
 				}
 				return new String (chars);
 			}
-			else {
+			else
+			{
 				byte[] result = new byte[len];
 				Array.Copy (GetBytes (len, false), result, len);
-				return (encoder.GetString (result));
+				if (columnEncoder != null)
+					return (columnEncoder.GetString (result));
+				else
+					return (encoder.GetString (result));
 			}
 		}
 
@@ -360,19 +398,18 @@
 
 			for (int i = 0; i < 2; i += 1)
 				input[i] = GetByte ();
-			if(!BitConverter.IsLittleEndian)
+			if (!BitConverter.IsLittleEndian)
 				return (BitConverter.ToInt16 (Swap (input), 0));
 			else
 				return (BitConverter.ToInt16 (input, 0));
 		}
 
-
 		public int GetTdsInt ()
 		{
 			byte[] input = new byte[4];
 			for (int i = 0; i < 4; i += 1)
 				input[i] = GetByte ();
-			if(!BitConverter.IsLittleEndian)
+			if (!BitConverter.IsLittleEndian)
 				return (BitConverter.ToInt32 (Swap (input), 0));
 			else
 				return (BitConverter.ToInt32 (input, 0));
@@ -383,7 +420,7 @@
 			byte[] input = new byte[8];
 			for (int i = 0; i < 8; i += 1)
 				input[i] = GetByte ();
-			if(!BitConverter.IsLittleEndian)
+			if (!BitConverter.IsLittleEndian)
 				return (BitConverter.ToInt64 (Swap (input), 0));
 			else
 				return (BitConverter.ToInt64 (input, 0));
@@ -391,43 +428,33 @@
 
 		private void GetPhysicalPacket ()
 		{
-                        int dataLength = GetPhysicalPacketHeader ();
-                        GetPhysicalPacketData (dataLength);
-		}
+			int nread = 0;
 
-                private int GetPhysicalPacketHeader ()
-                {
-                        int nread = 0;
-                                                
 			// read the header
 			while (nread < 8)
 				nread += stream.Read (tmpBuf, nread, 8 - nread);
 
 			TdsPacketType packetType = (TdsPacketType) tmpBuf[0];
-			if (packetType != TdsPacketType.Logon && packetType != TdsPacketType.Query && packetType != TdsPacketType.Reply) 
+			if (packetType != TdsPacketType.Logon && packetType != TdsPacketType.Query && packetType != TdsPacketType.Reply)
 			{
 				throw new Exception (String.Format ("Unknown packet type {0}", tmpBuf[0]));
 			}
 
 			// figure out how many bytes are remaining in this packet.
-			int len = Ntohs (tmpBuf, 2) - 8;
+			int length = Ntohs (tmpBuf, 2) - 8;
 
-			if (len >= inBuffer.Length) 
-				inBuffer = new byte[len];
+			if (length >= inBuffer.Length)
+				inBuffer = new byte[length];
 
-			if (len < 0) {
-				throw new Exception (String.Format ("Confused by a length of {0}", len));
+			if (length < 0)
+			{
+				throw new Exception (String.Format ("Confused by a length of {0}", length));
 			}
-                        
-                        return len;
 
-                }
-                
-                private void GetPhysicalPacketData (int length)
-                {
-                        // now get the data
-			int nread = 0;
-			while (nread < length) {
+			// now get the data
+			nread = 0;
+			while (nread < length)
+			{
 				nread += stream.Read (inBuffer, nread, length - nread);
 			}
 
@@ -436,17 +463,19 @@
 			// adjust the bookkeeping info about the incoming buffer
 			inBufferLength = length;
 			inBufferIndex = 0;
-                }
-                
+			
+			if (TdsLogger.IsEnabled)
+				TdsLogger.DumpPacket (tmpBuf, inBuffer, true);
+		}
 
 		private static int Ntohs (byte[] buf, int offset)
 		{
 			int lo = ((int) buf[offset + 1] & 0xff);
-			int hi = (((int) buf[offset] & 0xff ) << 8);
+			int hi = (((int) buf[offset] & 0xff) << 8);
 
 			return hi | lo;
 			// return an int since we really want an _unsigned_
-		}		
+		}
 
 		public byte Peek ()
 		{
@@ -467,9 +496,10 @@
 			long uSeconds = seconds * 1000000;
 			bool bState = false;
 
-			while (uSeconds > (long) Int32.MaxValue) {
+			while (uSeconds > (long)Int32.MaxValue)
+			{
 				bState = s.Poll (Int32.MaxValue, selectMode);
-				if (bState) 
+				if (bState)
 					return true;
 				uSeconds -= Int32.MaxValue;
 			}
@@ -478,8 +508,9 @@
 
 		internal void ResizeOutBuf (int newSize)
 		{
-			if (newSize != outBufferLength) {
-				byte[] newBuf = new byte [newSize];
+			if (newSize != outBufferLength)
+			{
+				byte[] newBuf = new byte[newSize];
 				Array.Copy (outBuffer, 0, newBuf, 0, newSize);
 				outBufferLength = newSize;
 				outBuffer = newBuf;
@@ -492,25 +523,29 @@
 			nextOutBufferIndex = 0;
 			packetType = TdsPacketType.None;
 		}
-		
+
 		private void SendPhysicalPacket (bool isLastSegment)
 		{
-			if (nextOutBufferIndex > headerLength || packetType == TdsPacketType.Cancel) {
+			if (nextOutBufferIndex > headerLength || packetType == TdsPacketType.Cancel)
+			{
 				// packet type
 				Store (0, (byte) packetType);
 				Store (1, (byte) (isLastSegment ? 1 : 0));
-				Store (2, (short) nextOutBufferIndex );
+				Store (2, (short) nextOutBufferIndex);
 				Store (4, (byte) 0);
 				Store (5, (byte) 0);
-				Store (6, (byte) (tdsVersion == TdsVersion.tds70 ? 0x1 : 0x0));
+				Store (6, (byte) (tdsVersion >= TdsVersion.tds70 ? 0x1 : 0x0));
 				Store (7, (byte) 0);
 
 				stream.Write (outBuffer, 0, nextOutBufferIndex);
 				stream.Flush ();
 				packetsSent++;
+				
+				if (TdsLogger.IsEnabled)
+					TdsLogger.DumpPacket (outBuffer, false);
 			}
 		}
-		
+
 		public void Skip (long i)
 		{
 			for ( ; i > 0; i--)
@@ -529,7 +564,7 @@
 		private void Store (int index, byte value)
 		{
 			outBuffer[index] = value;
-		}		
+		}
 
 		private void Store (int index, short value)
 		{
@@ -537,9 +572,76 @@
 			outBuffer[index + 1] = (byte) (((byte) (value >> 0)) & 0xff);
 		}
 
+		private X509CertificateCollection certificates = new X509CertificateCollection ();
+
+		public void EnableEncryption (SslMode mode)
+		{
+			sslStream = new SslClientStream (tdsStream, dataSource, false, 
+				Mono.Security.Protocol.Tls.SecurityProtocolType.Tls, certificates);
+			sslStream.ServerCertValidationDelegate += new CertificateValidationCallback (CertificateValidation);
+			stream = sslStream;
+			
+			tdsStream.IsPlainStream = (mode == SslMode.NoEncryption);
+			
+			if (TdsLogger.IsEnabled)
+				TdsLogger.DumpString("Enabling TLS encryption");
+		}
+
+		public void DisableEncryption ()
+		{
+			sslStream.Close();
+			sslStream = null;
+			tdsStream.IsPlainStream = true;
+			stream = tdsStream;
+			
+			if (TdsLogger.IsEnabled)
+				TdsLogger.DumpString("Disabling TLS encryption");
+		}
+
+		private string GetCertificateError (int error) 
+		{
+			switch (error) {
+				case -2146762490:
+					return "A certificate is being used for a purpose that is not supported (CERT_E_PURPOSE 0x800B0106)";
+				case -2146762481:
+					return "The CN name of the certificate does not match the passed value (CERT_E_CN_NO_MATCH 0x800B010F)";
+				case -2146869223:
+					return "The basic constraints of the certificate are invalid or missing (TRUST_E_BASIC_CONSTRAINTS 0x80096019)";
+				case -2146869232:
+					return "The digital signature of the object did not verify (TRUST_E_BAD_DIGEST 0x80096010)";
+				case -2146762494:
+					return "The validity periods of the certification chain do not nest correctly (CERT_E_VALIDITYPERIODNESTING 0x800B0102)";
+				case -2146762495:
+					return "A required certificate is not within its validity period (CERT_E_EXPIRED 0x800B0101)";
+				case -2146762486:
+					return "A chain of certificates was not correctly created (CERT_E_CHAINING 0x800B010A)";
+				case -2146762487:
+					return "A certification chain processed correctly but terminated in a root certificate not trusted by the trust provider (CERT_E_UNTRUSTEDROOT 0x800B0109)";
+				default:
+					return "unknown Ssl error (try WinError.h) " + 
+						error.ToString("X", System.Globalization.CultureInfo.InvariantCulture);
+			}
+		}
+
+		private bool CertificateValidation (X509Certificate certificate, int[] certificateErrors)
+		{
+			if (certificateErrors.Length > 0) {
+				StringBuilder sb = new StringBuilder (certificateErrors.Length * 2);
+				foreach (int error in certificateErrors) {
+					sb.Append(GetCertificateError (error)).Append(";");
+				}
+				
+				lastSslError = sb.ToString();
+				return false;
+			}
+
+			lastSslError = null;
+			return true;
+		}
+
 		#endregion // Methods
 #if NET_2_0
-                #region Async Methods
+		#region Async Methods
 
                 public IAsyncResult BeginReadPacket (AsyncCallback callback, object stateObject)
 		{
@@ -557,7 +659,6 @@
                         return (int) ((TdsAsyncResult) ar).ReturnValue;
                 }
                 
-
                 public void OnReadPacketCallback (IAsyncResult socketAsyncResult)
                 {
                         TdsAsyncResult ar = (TdsAsyncResult) socketAsyncResult.AsyncState;
@@ -588,9 +689,8 @@
                         ar.MarkComplete ();
                 }
                 
-                #endregion // Async Methods
+		#endregion // Async Methods
 #endif // NET_2_0
 
 	}
-
 }
