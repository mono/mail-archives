Index: ChangeLog
===================================================================
--- ChangeLog	(revision 92275)
+++ ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2008-01-24  Jonathan Pryor  <jpryor@novell.com>
+
+	* signal.c: Provide support functions for Mono.Unix.UnixSignal, which 
+	  supports both polling and waiting on signal emission.
+	* map.h: Flush (adds UnixSignal-related prototypes).
+
 2008-01-05  Jonathan Pryor  <jpryor@novell.com>
 
 	* map.h, map.c: Flush; add new ST_NOEXEC, ST_REMOUNT, and ST_BIND MountFlags 
Index: signal.c
===================================================================
--- signal.c	(revision 92060)
+++ signal.c	(working copy)
@@ -3,18 +3,29 @@
  *
  * Authors:
  *   Jonathan Pryor (jonpryor@vt.edu)
+ *   Jonathan Pryor (jpryor@novell.com)
  *
  * Copyright (C) 2004-2005 Jonathan Pryor
+ * Copyright (C) 2008 Novell, Inc.
  */
 
 #include <signal.h>
 
+#ifndef PLATFORM_WIN32
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <poll.h>
+#include <pthread.h>
+#endif
+
 #include "map.h"
 #include "mph.h"
 
 G_BEGIN_DECLS
 
 typedef void (*mph_sighandler_t)(int);
+typedef struct Mono_Unix_UnixSignal_SignalInfo signal_info;
 
 void*
 Mono_Posix_Stdlib_SIG_DFL (void)
@@ -42,6 +53,7 @@
 }
 
 #ifndef PLATFORM_WIN32
+
 int
 Mono_Posix_Syscall_psignal (int sig, const char* s)
 {
@@ -49,6 +61,158 @@
 	psignal (sig, s);
 	return errno == 0 ? 0 : -1;
 }
+
+static signal_info signals[64];
+
+static inline signal_info*
+get_info (int signum)
+{
+	if (signum < 0 || signum >= sizeof(signals)/sizeof(signals [0]))
+		return NULL;
+	return &signals [signum];
+}
+
+static void
+default_handler (int signum)
+{
+	signal_info* h = get_info (signum);
+	int fd = 0;
+	if (h) {
+		++h->count;
+		if (h->write_fd > 0)
+			fd = h->write_fd;
+	}
+	if (fd) {
+		char c = signum;
+		write (fd, &c, 1);
+	}
+}
+
+static pthread_mutex_t signals_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+void*
+Mono_Unix_UnixSignal_install (int sig)
+{
+	int mr;
+	signal_info* h; 
+
+	mr = pthread_mutex_lock (&signals_mutex);
+	if (mr != 0) {
+		errno = mr;
+		return NULL;
+	}
+
+	h = get_info (sig);
+	if (h == NULL)
+		errno = EINVAL;
+	else if (h->have_handler)
+		errno = EADDRINUSE;
+	else {
+		h->count = 0;
+		h->handler = signal (sig, default_handler);
+		if (h->handler == SIG_ERR) {
+			h->handler = NULL;
+		}
+		else
+			h->have_handler = 1;
+	}
+
+	pthread_mutex_unlock (&signals_mutex);
+
+	return h;
+}
+
+int
+Mono_Unix_UnixSignal_uninstall (int sig)
+{
+	signal_info* h;
+	int mr, r = -1;
+
+	mr = pthread_mutex_lock (&signals_mutex);
+	if (mr != 0) {
+		errno = mr;
+		return -1;
+	}
+
+	h = get_info (sig);
+
+	if (h == NULL)
+		errno = EINVAL;
+	else if (!h->have_handler)
+		errno = EADDRNOTAVAIL;
+	else {
+		mph_sighandler_t p = signal (sig, h->handler);
+
+		h->handler      = NULL;
+		h->have_handler = 0;
+
+		if (p != SIG_ERR)
+			r = 0;
+	}
+
+	pthread_mutex_unlock (&signals_mutex);
+
+	return r;
+}
+
+/*
+ * returns: -1 on error:
+ *           0 on timeout
+ *         > 0 on success
+ */
+int
+Mono_Unix_UnixSignal_wait (int sig, int timeout)
+{
+	signal_info* h;
+	int close_fd = 0;
+	int filedes [2];
+	int mr, r = -1;
+
+	mr = pthread_mutex_lock (&signals_mutex);
+	if (mr != 0) {
+		errno = mr;
+		return -1;
+	}
+
+	h = get_info (sig);
+	if (!h)
+		errno = EINVAL;
+	else if (!h->have_handler)
+		errno = EADDRNOTAVAIL;
+	else if (h->count)
+		r = h->count;
+	else if ((r = pipe (filedes)) == 0) {
+		struct pollfd fds [1];
+
+		close_fd = 1;
+
+		h->write_fd    = filedes [1];
+		fds [0].fd     = filedes [0];
+		fds [0].events = POLLIN;
+
+		r = poll (fds, 1, timeout);
+		if (r == -1 && errno == EINTR) {
+			/* syscall was interrupted; retry */
+			r = poll (fds, 1, timeout);
+			if (r > 0) {
+				char c;
+				read (filedes [0], &c, 1); /* ignore error */
+				r = 1;
+			}
+		}
+	}
+
+	if (close_fd) {
+		h->write_fd = 0;
+		close (filedes [0]);
+		close (filedes [1]);
+	}
+
+	pthread_mutex_unlock (&signals_mutex);
+
+	return r;
+}
+
 #endif /* ndef PLATFORM_WIN32 */
 
 
Index: map.h
===================================================================
--- map.h	(revision 92275)
+++ map.h	(working copy)
@@ -1382,6 +1382,7 @@
 struct Mono_Posix_Timeval;
 struct Mono_Posix_Timezone;
 struct Mono_Posix_Utimbuf;
+struct Mono_Unix_UnixSignal_SignalInfo;
 
 /*
  * Inferred Structure Declarations
@@ -1541,7 +1542,14 @@
 Mono_Posix_ToUtimbuf (struct utimbuf *from, struct Mono_Posix_Utimbuf* to);
 
 
+struct Mono_Unix_UnixSignal_SignalInfo {
+	int   count;
+	int   write_fd;
+	int   have_handler;
+	void* handler;
+};
 
+
 /*
  * Functions
  */
@@ -1706,6 +1714,9 @@
 int Mono_Posix_Syscall_WSTOPSIG (int status);
 int Mono_Posix_Syscall_WTERMSIG (int status);
 int Mono_Posix_ToStatvfs (void* source, struct Mono_Posix_Statvfs* destination);
+void* Mono_Unix_UnixSignal_install (int signum);
+int Mono_Unix_UnixSignal_uninstall (int signum);
+int Mono_Unix_UnixSignal_wait (int signum, int timeout);
 int wexitstatus (int status);
 int wifexited (int status);
 int wifsignaled (int status);
