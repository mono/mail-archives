Index: mini/method-to-ir.c
===================================================================
--- mini/method-to-ir.c	(revision 159106)
+++ mini/method-to-ir.c	(working copy)
@@ -61,6 +61,10 @@
 #include "jit.h"
 #include "debugger-agent.h"
 
+#if defined(__arm__)
+#include "mini-arm.h"
+#endif
+
 #define BRANCH_COST 100
 #define INLINE_LENGTH_LIMIT 20
 #define INLINE_FAILURE do {\
@@ -2127,9 +2131,7 @@
 					 MonoInst **args, int calli, int virtual, int tail)
 {
 	MonoCallInst *call;
-#ifdef MONO_ARCH_SOFT_FLOAT
 	int i;
-#endif
 
 	if (tail)
 		MONO_INST_NEW_CALL (cfg, call, OP_TAILCALL);
@@ -2173,8 +2175,7 @@
 	} else if (!MONO_TYPE_IS_VOID (sig->ret))
 		call->inst.dreg = alloc_dreg (cfg, call->inst.type);
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-	if (COMPILE_SOFT_FLOAT (cfg)) {
+	if (mono_arch_is_soft_float () && COMPILE_SOFT_FLOAT (cfg)) {
 		/* 
 		 * If the call has a float argument, we would need to do an r8->r4 conversion using 
 		 * an icall, but that cannot be done during the call sequence since it would clobber
@@ -2202,7 +2203,6 @@
 			}
 		}
 	}
-#endif
 
 #ifdef ENABLE_LLVM
 	if (COMPILE_LLVM (cfg))
@@ -3714,10 +3714,8 @@
 {
 	MonoMethodHeaderSummary header;
 	MonoVTable *vtable;
-#ifdef MONO_ARCH_SOFT_FLOAT
 	MonoMethodSignature *sig = mono_method_signature (method);
 	int i;
-#endif
 
 	if (cfg->generic_sharing_context)
 		return FALSE;
@@ -3805,14 +3803,14 @@
 	if (mono_method_has_declsec (method))
 		return FALSE;
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-	/* FIXME: */
-	if (sig->ret && sig->ret->type == MONO_TYPE_R4)
-		return FALSE;
-	for (i = 0; i < sig->param_count; ++i)
-		if (!sig->params [i]->byref && sig->params [i]->type == MONO_TYPE_R4)
+	if (mono_arch_is_soft_float ()) {
+		/* FIXME: */
+		if (sig->ret && sig->ret->type == MONO_TYPE_R4)
 			return FALSE;
-#endif
+		for (i = 0; i < sig->param_count; ++i)
+			if (!sig->params [i]->byref && sig->params [i]->type == MONO_TYPE_R4)
+				return FALSE;
+	}
 
 	return TRUE;
 }
@@ -5088,8 +5086,9 @@
 		case MONO_TYPE_R4:
 			size = 4; break;
 		case MONO_TYPE_R8:
-#ifdef ARM_FPU_FPA
-			return NULL; /* stupid ARM FP swapped format */
+#if defined(__arm__)
+			if (mono_arm_is_fpa ())
+				return NULL; /* stupid ARM FP swapped format */
 #endif
 		case MONO_TYPE_I8:
 		case MONO_TYPE_U8:
@@ -6795,20 +6794,20 @@
 							ins->klass = mono_class_from_mono_type (ret_type);
 						}
 					} else {
-#ifdef MONO_ARCH_SOFT_FLOAT
-						if (COMPILE_SOFT_FLOAT (cfg) && !ret_type->byref && ret_type->type == MONO_TYPE_R4) {
-							MonoInst *iargs [1];
-							MonoInst *conv;
+						if (mono_arch_is_soft_float ()) {
+							if (COMPILE_SOFT_FLOAT (cfg) && !ret_type->byref && ret_type->type == MONO_TYPE_R4) {
+								MonoInst *iargs [1];
+								MonoInst *conv;
 
-							iargs [0] = *sp;
-							conv = mono_emit_jit_icall (cfg, mono_fload_r4_arg, iargs);
-							mono_arch_emit_setret (cfg, method, conv);
+								iargs [0] = *sp;
+								conv = mono_emit_jit_icall (cfg, mono_fload_r4_arg, iargs);
+								mono_arch_emit_setret (cfg, method, conv);
+							} else {
+								mono_arch_emit_setret (cfg, method, *sp);
+							}
 						} else {
 							mono_arch_emit_setret (cfg, method, *sp);
 						}
-#else
-						mono_arch_emit_setret (cfg, method, *sp);
-#endif
 					}
 				}
 			}
Index: mini/mini.c
===================================================================
--- mini/mini.c	(revision 159106)
+++ mini/mini.c	(working copy)
@@ -964,12 +964,12 @@
 		set_vreg_to_inst (cfg, vreg, inst);
 
 #if SIZEOF_REGISTER == 4
-#ifdef MONO_ARCH_SOFT_FLOAT
-	regpair = mono_type_is_long (type) || mono_type_is_float (type);
+	if (mono_arch_is_soft_float ()) {
+		regpair = mono_type_is_long (type) || mono_type_is_float (type);
+	} else {
+		regpair = mono_type_is_long (type);
+	}
 #else
-	regpair = mono_type_is_long (type);
-#endif
-#else
 	regpair = FALSE;
 #endif
 
@@ -989,12 +989,10 @@
 			printf ("  Create LVAR R%d (R%d, R%d)\n", inst->dreg, inst->dreg + 1, inst->dreg + 2);
 		}
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-		if (cfg->opt & MONO_OPT_SSA) {
+		if (mono_arch_is_soft_float () && cfg->opt & MONO_OPT_SSA) {
 			if (mono_type_is_float (type))
 				inst->flags = MONO_INST_VOLATILE;
 		}
-#endif
 
 		/* Allocate a dummy MonoInst for the first vreg */
 		MONO_INST_NEW (cfg, tree, OP_LOCAL);
@@ -1034,10 +1032,8 @@
 
 	if (mono_type_is_long (type))
 		dreg = mono_alloc_dreg (cfg, STACK_I8);
-#ifdef MONO_ARCH_SOFT_FLOAT
-	else if (mono_type_is_float (type))
+	else if (mono_arch_is_soft_float () && mono_type_is_float (type))
 		dreg = mono_alloc_dreg (cfg, STACK_R8);
-#endif
 	else
 		/* All the others are unified */
 		dreg = mono_alloc_preg (cfg);
@@ -4275,10 +4271,8 @@
 		return cfg;
 	}
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-	if (!COMPILE_LLVM (cfg))
+	if (mono_arch_is_soft_float () && !COMPILE_LLVM (cfg))
 		mono_decompose_soft_float (cfg);
-#endif
 	if (!COMPILE_LLVM (cfg))
 		mono_decompose_vtype_opts (cfg);
 	if (cfg->flags & MONO_CFG_HAS_ARRAY_ACCESS)
@@ -5920,8 +5914,12 @@
 	mono_register_opcode_emulation (OP_IMUL_OVF_UN, "__emul_op_imul_ovf_un", "int32 int32 int32", mono_imul_ovf_un, FALSE);
 #endif
 
-#if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_SOFT_FLOAT)
+#if defined(MONO_ARCH_EMULATE_MUL_DIV)
 	mono_register_opcode_emulation (OP_FDIV, "__emul_fdiv", "double double double", mono_fdiv, FALSE);
+#else
+	if (mono_arch_is_soft_float ()) {
+		mono_register_opcode_emulation (OP_FDIV, "__emul_fdiv", "double double double", mono_fdiv, FALSE);
+	}
 #endif
 
 	mono_register_opcode_emulation (OP_FCONV_TO_U8, "__emul_fconv_to_u8", "ulong double", mono_fconv_u8, FALSE);
@@ -5949,48 +5947,48 @@
 	mono_register_opcode_emulation (OP_FREM, "__emul_frem", "double double double", fmod, FALSE);
 #endif
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-	mono_register_opcode_emulation (OP_FSUB, "__emul_fsub", "double double double", mono_fsub, FALSE);
-	mono_register_opcode_emulation (OP_FADD, "__emul_fadd", "double double double", mono_fadd, FALSE);
-	mono_register_opcode_emulation (OP_FMUL, "__emul_fmul", "double double double", mono_fmul, FALSE);
-	mono_register_opcode_emulation (OP_FNEG, "__emul_fneg", "double double", mono_fneg, FALSE);
-	mono_register_opcode_emulation (CEE_CONV_R8, "__emul_conv_r8", "double int32", mono_conv_to_r8, FALSE);
-	mono_register_opcode_emulation (OP_ICONV_TO_R8, "__emul_iconv_to_r8", "double int32", mono_conv_to_r8, FALSE);
-	mono_register_opcode_emulation (CEE_CONV_R4, "__emul_conv_r4", "double int32", mono_conv_to_r4, FALSE);
-	mono_register_opcode_emulation (OP_ICONV_TO_R4, "__emul_iconv_to_r4", "double int32", mono_conv_to_r4, FALSE);
-	mono_register_opcode_emulation (OP_FCONV_TO_R4, "__emul_fconv_to_r4", "double double", mono_fconv_r4, FALSE);
-	mono_register_opcode_emulation (OP_FCONV_TO_I1, "__emul_fconv_to_i1", "int8 double", mono_fconv_i1, FALSE);
-	mono_register_opcode_emulation (OP_FCONV_TO_I2, "__emul_fconv_to_i2", "int16 double", mono_fconv_i2, FALSE);
-	mono_register_opcode_emulation (OP_FCONV_TO_I4, "__emul_fconv_to_i4", "int32 double", mono_fconv_i4, FALSE);
-	mono_register_opcode_emulation (OP_FCONV_TO_U1, "__emul_fconv_to_u1", "uint8 double", mono_fconv_u1, FALSE);
-	mono_register_opcode_emulation (OP_FCONV_TO_U2, "__emul_fconv_to_u2", "uint16 double", mono_fconv_u2, FALSE);
+	if (mono_arch_is_soft_float ()) {
+		mono_register_opcode_emulation (OP_FSUB, "__emul_fsub", "double double double", mono_fsub, FALSE);
+		mono_register_opcode_emulation (OP_FADD, "__emul_fadd", "double double double", mono_fadd, FALSE);
+		mono_register_opcode_emulation (OP_FMUL, "__emul_fmul", "double double double", mono_fmul, FALSE);
+		mono_register_opcode_emulation (OP_FNEG, "__emul_fneg", "double double", mono_fneg, FALSE);
+		mono_register_opcode_emulation (CEE_CONV_R8, "__emul_conv_r8", "double int32", mono_conv_to_r8, FALSE);
+		mono_register_opcode_emulation (OP_ICONV_TO_R8, "__emul_iconv_to_r8", "double int32", mono_conv_to_r8, FALSE);
+		mono_register_opcode_emulation (CEE_CONV_R4, "__emul_conv_r4", "double int32", mono_conv_to_r4, FALSE);
+		mono_register_opcode_emulation (OP_ICONV_TO_R4, "__emul_iconv_to_r4", "double int32", mono_conv_to_r4, FALSE);
+		mono_register_opcode_emulation (OP_FCONV_TO_R4, "__emul_fconv_to_r4", "double double", mono_fconv_r4, FALSE);
+		mono_register_opcode_emulation (OP_FCONV_TO_I1, "__emul_fconv_to_i1", "int8 double", mono_fconv_i1, FALSE);
+		mono_register_opcode_emulation (OP_FCONV_TO_I2, "__emul_fconv_to_i2", "int16 double", mono_fconv_i2, FALSE);
+		mono_register_opcode_emulation (OP_FCONV_TO_I4, "__emul_fconv_to_i4", "int32 double", mono_fconv_i4, FALSE);
+		mono_register_opcode_emulation (OP_FCONV_TO_U1, "__emul_fconv_to_u1", "uint8 double", mono_fconv_u1, FALSE);
+		mono_register_opcode_emulation (OP_FCONV_TO_U2, "__emul_fconv_to_u2", "uint16 double", mono_fconv_u2, FALSE);
 #if SIZEOF_VOID_P == 4
-	mono_register_opcode_emulation (OP_FCONV_TO_I, "__emul_fconv_to_i", "int32 double", mono_fconv_i4, FALSE);
+		mono_register_opcode_emulation (OP_FCONV_TO_I, "__emul_fconv_to_i", "int32 double", mono_fconv_i4, FALSE);
 #endif
 
-	mono_register_opcode_emulation (OP_FBEQ, "__emul_fcmp_eq", "uint32 double double", mono_fcmp_eq, FALSE);
-	mono_register_opcode_emulation (OP_FBLT, "__emul_fcmp_lt", "uint32 double double", mono_fcmp_lt, FALSE);
-	mono_register_opcode_emulation (OP_FBGT, "__emul_fcmp_gt", "uint32 double double", mono_fcmp_gt, FALSE);
-	mono_register_opcode_emulation (OP_FBLE, "__emul_fcmp_le", "uint32 double double", mono_fcmp_le, FALSE);
-	mono_register_opcode_emulation (OP_FBGE, "__emul_fcmp_ge", "uint32 double double", mono_fcmp_ge, FALSE);
-	mono_register_opcode_emulation (OP_FBNE_UN, "__emul_fcmp_ne_un", "uint32 double double", mono_fcmp_ne_un, FALSE);
-	mono_register_opcode_emulation (OP_FBLT_UN, "__emul_fcmp_lt_un", "uint32 double double", mono_fcmp_lt_un, FALSE);
-	mono_register_opcode_emulation (OP_FBGT_UN, "__emul_fcmp_gt_un", "uint32 double double", mono_fcmp_gt_un, FALSE);
-	mono_register_opcode_emulation (OP_FBLE_UN, "__emul_fcmp_le_un", "uint32 double double", mono_fcmp_le_un, FALSE);
-	mono_register_opcode_emulation (OP_FBGE_UN, "__emul_fcmp_ge_un", "uint32 double double", mono_fcmp_ge_un, FALSE);
+		mono_register_opcode_emulation (OP_FBEQ, "__emul_fcmp_eq", "uint32 double double", mono_fcmp_eq, FALSE);
+		mono_register_opcode_emulation (OP_FBLT, "__emul_fcmp_lt", "uint32 double double", mono_fcmp_lt, FALSE);
+		mono_register_opcode_emulation (OP_FBGT, "__emul_fcmp_gt", "uint32 double double", mono_fcmp_gt, FALSE);
+		mono_register_opcode_emulation (OP_FBLE, "__emul_fcmp_le", "uint32 double double", mono_fcmp_le, FALSE);
+		mono_register_opcode_emulation (OP_FBGE, "__emul_fcmp_ge", "uint32 double double", mono_fcmp_ge, FALSE);
+		mono_register_opcode_emulation (OP_FBNE_UN, "__emul_fcmp_ne_un", "uint32 double double", mono_fcmp_ne_un, FALSE);
+		mono_register_opcode_emulation (OP_FBLT_UN, "__emul_fcmp_lt_un", "uint32 double double", mono_fcmp_lt_un, FALSE);
+		mono_register_opcode_emulation (OP_FBGT_UN, "__emul_fcmp_gt_un", "uint32 double double", mono_fcmp_gt_un, FALSE);
+		mono_register_opcode_emulation (OP_FBLE_UN, "__emul_fcmp_le_un", "uint32 double double", mono_fcmp_le_un, FALSE);
+		mono_register_opcode_emulation (OP_FBGE_UN, "__emul_fcmp_ge_un", "uint32 double double", mono_fcmp_ge_un, FALSE);
 
-	mono_register_opcode_emulation (OP_FCEQ, "__emul_fcmp_ceq", "uint32 double double", mono_fceq, FALSE);
-	mono_register_opcode_emulation (OP_FCGT, "__emul_fcmp_cgt", "uint32 double double", mono_fcgt, FALSE);
-	mono_register_opcode_emulation (OP_FCGT_UN, "__emul_fcmp_cgt_un", "uint32 double double", mono_fcgt_un, FALSE);
-	mono_register_opcode_emulation (OP_FCLT, "__emul_fcmp_clt", "uint32 double double", mono_fclt, FALSE);
-	mono_register_opcode_emulation (OP_FCLT_UN, "__emul_fcmp_clt_un", "uint32 double double", mono_fclt_un, FALSE);
+		mono_register_opcode_emulation (OP_FCEQ, "__emul_fcmp_ceq", "uint32 double double", mono_fceq, FALSE);
+		mono_register_opcode_emulation (OP_FCGT, "__emul_fcmp_cgt", "uint32 double double", mono_fcgt, FALSE);
+		mono_register_opcode_emulation (OP_FCGT_UN, "__emul_fcmp_cgt_un", "uint32 double double", mono_fcgt_un, FALSE);
+		mono_register_opcode_emulation (OP_FCLT, "__emul_fcmp_clt", "uint32 double double", mono_fclt, FALSE);
+		mono_register_opcode_emulation (OP_FCLT_UN, "__emul_fcmp_clt_un", "uint32 double double", mono_fclt_un, FALSE);
+	
+		register_icall (mono_fload_r4, "mono_fload_r4", "double ptr", FALSE);
+		register_icall (mono_fstore_r4, "mono_fstore_r4", "void double ptr", FALSE);
+		register_icall (mono_fload_r4_arg, "mono_fload_r4_arg", "uint32 double", FALSE);
+		register_icall (mono_isfinite, "mono_isfinite", "uint32 double", FALSE);
+	}
 
-	register_icall (mono_fload_r4, "mono_fload_r4", "double ptr", FALSE);
-	register_icall (mono_fstore_r4, "mono_fstore_r4", "void double ptr", FALSE);
-	register_icall (mono_fload_r4_arg, "mono_fload_r4_arg", "uint32 double", FALSE);
-	register_icall (mono_isfinite, "mono_isfinite", "uint32 double", FALSE);
-#endif
-
 #ifdef COMPRESSED_INTERFACE_BITMAP
 	register_icall (mono_class_interface_match, "mono_class_interface_match", "uint32 ptr int32", TRUE);
 #endif
Index: mini/mini.h
===================================================================
--- mini/mini.h	(revision 159106)
+++ mini/mini.h	(working copy)
@@ -1821,6 +1821,7 @@
 void     mono_arch_monoctx_to_sigctx            (MonoContext *mctx, void *ctx) MONO_INTERNAL;
 gpointer mono_arch_context_get_int_reg		(MonoContext *ctx, int reg) MONO_INTERNAL;
 void     mono_arch_flush_register_windows       (void) MONO_INTERNAL;
+gboolean mono_arch_is_soft_float		(void) MONO_INTERNAL;
 gboolean mono_arch_is_inst_imm                  (gint64 imm) MONO_INTERNAL;
 MonoInst* mono_arch_get_domain_intrinsic        (MonoCompile* cfg) MONO_INTERNAL;
 gboolean mono_arch_is_int_overflow              (void *sigctx, void *info) MONO_INTERNAL;
Index: mini/mini-amd64.c
===================================================================
--- mini/mini-amd64.c	(revision 159106)
+++ mini/mini-amd64.c	(working copy)
@@ -6793,6 +6793,12 @@
 {
 }
 
+gboolean
+mono_arch_is_soft_float ()
+{
+	return FALSE;
+}
+
 gboolean 
 mono_arch_is_inst_imm (gint64 imm)
 {
Index: mini/mini-mips.c
===================================================================
--- mini/mini-mips.c	(revision 159106)
+++ mini/mini-mips.c	(working copy)
@@ -175,6 +175,12 @@
 {
 }
 
+gboolean
+mono_arch_is_soft_float ()
+{
+	return FALSE;
+}
+
 gboolean 
 mono_arch_is_inst_imm (gint64 imm)
 {
Index: mini/mini-x86.c
===================================================================
--- mini/mini-x86.c	(revision 159106)
+++ mini/mini-x86.c	(working copy)
@@ -5125,6 +5125,12 @@
 {
 }
 
+gboolean
+mono_arch_is_soft_float ()
+{
+	return FALSE;
+}
+
 gboolean 
 mono_arch_is_inst_imm (gint64 imm)
 {
Index: mini/decompose.c
===================================================================
--- mini/decompose.c	(revision 159106)
+++ mini/decompose.c	(working copy)
@@ -1368,8 +1368,6 @@
 	double vald;
 } DVal;
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-
 /**
  * mono_decompose_soft_float:
  *
@@ -1651,6 +1649,4 @@
 	mono_decompose_long_opts (cfg);
 }
 
-#endif
-
 #endif /* DISABLE_JIT */
Index: mini/ir-emit.h
===================================================================
--- mini/ir-emit.h	(revision 159106)
+++ mini/ir-emit.h	(working copy)
@@ -44,13 +44,13 @@
 static inline guint32
 alloc_freg (MonoCompile *cfg)
 {
-#ifdef MONO_ARCH_SOFT_FLOAT
-	/* Allocate an lvreg so float ops can be decomposed into long ops */
-	return alloc_lreg (cfg);
-#else
-	/* Allocate these from the same pool as the int regs */
-	return cfg->next_vreg ++;
-#endif
+	if (mono_arch_is_soft_float ()) {
+		/* Allocate an lvreg so float ops can be decomposed into long ops */
+		return alloc_lreg (cfg);
+	} else {
+		/* Allocate these from the same pool as the int regs */
+		return cfg->next_vreg ++;
+	}
 }
 
 static inline guint32
@@ -288,11 +288,7 @@
         if ((dest)->opcode == OP_VMOVE) (dest)->klass = mono_class_from_mono_type ((vartype)); \
 	} while (0)
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-#define DECOMPOSE_INTO_REGPAIR(stack_type) ((stack_type) == STACK_I8 || (stack_type) == STACK_R8)
-#else
-#define DECOMPOSE_INTO_REGPAIR(stack_type) ((stack_type) == STACK_I8)
-#endif
+#define DECOMPOSE_INTO_REGPAIR(stack_type) (((stack_type) == STACK_I8) || (mono_arch_is_soft_float () && ((stack_type) == STACK_R8)))
 
 #define NEW_VARLOADA(cfg,dest,var,vartype) do {	\
         MONO_INST_NEW ((cfg), (dest), OP_LDADDR); \
@@ -418,8 +414,6 @@
 #define EMIT_NEW_VARLOADA(cfg,dest,var,vartype) do { NEW_VARLOADA ((cfg), (dest), (var), (vartype)); MONO_ADD_INS ((cfg)->cbb, (dest)); } while (0)
 
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-
 /*
  * Since the IL stack (and our vregs) contain double values, we have to do a conversion
  * when loading/storing args/locals of type R4.
@@ -446,26 +440,14 @@
         } \
     } while (0)
 
-#define EMIT_NEW_ARGLOAD(cfg,dest,num) EMIT_NEW_VARLOAD_SFLOAT ((cfg), (dest), cfg->args [(num)], cfg->arg_types [(num)])
+#define EMIT_NEW_ARGLOAD(cfg,dest,num) do { if (mono_arch_is_soft_float ()) { EMIT_NEW_VARLOAD_SFLOAT ((cfg), (dest), cfg->args [(num)], cfg->arg_types [(num)]); } else { NEW_ARGLOAD ((cfg), (dest), (num)); MONO_ADD_INS ((cfg)->cbb, (dest)); } } while (0)
 
-#define EMIT_NEW_LOCLOAD(cfg,dest,num) EMIT_NEW_VARLOAD_SFLOAT ((cfg), (dest), cfg->locals [(num)], header->locals [(num)])
+#define EMIT_NEW_LOCLOAD(cfg,dest,num) do { if (mono_arch_is_soft_float ()) { EMIT_NEW_VARLOAD_SFLOAT ((cfg), (dest), cfg->locals [(num)], header->locals [(num)]); } else { NEW_LOCLOAD ((cfg), (dest), (num)); MONO_ADD_INS ((cfg)->cbb, (dest)); } } while (0)
 
-#define EMIT_NEW_LOCSTORE(cfg,dest,num,inst) EMIT_NEW_VARSTORE_SFLOAT ((cfg), (dest), (cfg)->locals [(num)], (cfg)->locals [(num)]->inst_vtype, (inst))
+#define EMIT_NEW_LOCSTORE(cfg,dest,num,inst) do { if (mono_arch_is_soft_float ()) { EMIT_NEW_VARSTORE_SFLOAT ((cfg), (dest), (cfg)->locals [(num)], (cfg)->locals [(num)]->inst_vtype, (inst)); } else { NEW_LOCSTORE ((cfg), (dest), (num), (inst)); MONO_ADD_INS ((cfg)->cbb, (dest)); } } while (0)
 
-#define EMIT_NEW_ARGSTORE(cfg,dest,num,inst) EMIT_NEW_VARSTORE_SFLOAT ((cfg), (dest), cfg->args [(num)], cfg->arg_types [(num)], (inst))
+#define EMIT_NEW_ARGSTORE(cfg,dest,num,inst) do { if (mono_arch_is_soft_float ()) { EMIT_NEW_VARSTORE_SFLOAT ((cfg), (dest), cfg->args [(num)], cfg->arg_types [(num)], (inst)); } else { NEW_ARGSTORE ((cfg), (dest), (num), (inst)); MONO_ADD_INS ((cfg)->cbb, (dest)); } } while (0)
 
-#else
-
-#define EMIT_NEW_ARGLOAD(cfg,dest,num) do { NEW_ARGLOAD ((cfg), (dest), (num)); MONO_ADD_INS ((cfg)->cbb, (dest)); } while (0)
-
-#define EMIT_NEW_LOCLOAD(cfg,dest,num) do { NEW_LOCLOAD ((cfg), (dest), (num)); MONO_ADD_INS ((cfg)->cbb, (dest)); } while (0)
-
-#define EMIT_NEW_LOCSTORE(cfg,dest,num,inst) do { NEW_LOCSTORE ((cfg), (dest), (num), (inst)); MONO_ADD_INS ((cfg)->cbb, (dest)); } while (0)
-
-#define EMIT_NEW_ARGSTORE(cfg,dest,num,inst) do { NEW_ARGSTORE ((cfg), (dest), (num), (inst)); MONO_ADD_INS ((cfg)->cbb, (dest)); } while (0)
-
-#endif
-
 #define EMIT_NEW_TEMPLOAD(cfg,dest,num) do { NEW_TEMPLOAD ((cfg), (dest), (num)); MONO_ADD_INS ((cfg)->cbb, (dest)); } while (0)
 
 #define EMIT_NEW_TEMPLOADA(cfg,dest,num) do { NEW_TEMPLOADA ((cfg), (dest), (num)); MONO_ADD_INS ((cfg)->cbb, (dest)); } while (0)
Index: mini/mini-s390x.c
===================================================================
--- mini/mini-s390x.c	(revision 159106)
+++ mini/mini-s390x.c	(working copy)
@@ -5551,6 +5551,12 @@
         return pthread_getspecific (lmf_addr_key);
 }
 
+gboolean
+mono_arch_is_soft_float ()
+{
+	return FALSE;
+}
+
 /*========================= End of Function ========================*/
 
 /*------------------------------------------------------------------*/
Index: mini/mini-arm.c
===================================================================
--- mini/mini-arm.c	(revision 159106)
+++ mini/mini-arm.c	(working copy)
@@ -18,11 +18,8 @@
 #include "cpu-arm.h"
 #include "trace.h"
 #include "ir-emit.h"
-#ifdef ARM_FPU_FPA
 #include "mono/arch/arm/arm-fpa-codegen.h"
-#elif defined(ARM_FPU_VFP)
 #include "mono/arch/arm/arm-vfp-codegen.h"
-#endif
 
 #if defined(__ARM_EABI__) && defined(__linux__) && !defined(PLATFORM_ANDROID)
 #define HAVE_AEABI_READ_TP 1
@@ -232,17 +229,14 @@
 	case OP_FCALL:
 	case OP_FCALL_REG:
 	case OP_FCALL_MEMBASE:
-#ifdef ARM_FPU_FPA
-		if (ins->dreg != ARM_FPA_F0)
+		if (mono_arm_is_fpa () && ins->dreg != ARM_FPA_F0)
 			ARM_MVFD (code, ins->dreg, ARM_FPA_F0);
-#elif defined(ARM_FPU_VFP)
-		if (((MonoCallInst*)ins)->signature->ret->type == MONO_TYPE_R4) {
+		if (mono_arm_is_vfp () && ((MonoCallInst*)ins)->signature->ret->type == MONO_TYPE_R4) {
 			ARM_FMSR (code, ins->dreg, ARMREG_R0);
 			ARM_CVTS (code, ins->dreg, ins->dreg);
 		} else {
 			ARM_FMDRR (code, ARMREG_R0, ARMREG_R1, ins->dreg);
 		}
-#endif
 		break;
 	}
 
@@ -1444,47 +1438,45 @@
 				MONO_ADD_INS (cfg->cbb, ins);
 				mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg + 1, FALSE);
 			} else if (!t->byref && ((t->type == MONO_TYPE_R8) || (t->type == MONO_TYPE_R4))) {
-#ifndef MONO_ARCH_SOFT_FLOAT
 				int creg;
-#endif
 
 				if (ainfo->size == 4) {
-#ifdef MONO_ARCH_SOFT_FLOAT
-					/* mono_emit_call_args () have already done the r8->r4 conversion */
-					/* The converted value is in an int vreg */
-					MONO_INST_NEW (cfg, ins, OP_MOVE);
-					ins->dreg = mono_alloc_ireg (cfg);
-					ins->sreg1 = in->dreg;
-					MONO_ADD_INS (cfg->cbb, ins);
-					mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg, FALSE);
-#else
-					MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER4_MEMBASE_REG, ARMREG_SP, (cfg->param_area - 8), in->dreg);
-					creg = mono_alloc_ireg (cfg);
-					MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8));
-					mono_call_inst_add_outarg_reg (cfg, call, creg, ainfo->reg, FALSE);
-#endif
+					if (mono_arch_is_soft_float ()) {
+						/* mono_emit_call_args () have already done the r8->r4 conversion */
+						/* The converted value is in an int vreg */
+						MONO_INST_NEW (cfg, ins, OP_MOVE);
+						ins->dreg = mono_alloc_ireg (cfg);
+						ins->sreg1 = in->dreg;
+						MONO_ADD_INS (cfg->cbb, ins);
+						mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg, FALSE);
+					} else {
+						MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER4_MEMBASE_REG, ARMREG_SP, (cfg->param_area - 8), in->dreg);
+						creg = mono_alloc_ireg (cfg);
+						MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8));
+						mono_call_inst_add_outarg_reg (cfg, call, creg, ainfo->reg, FALSE);
+					}
 				} else {
-#ifdef MONO_ARCH_SOFT_FLOAT
-					MONO_INST_NEW (cfg, ins, OP_FGETLOW32);
-					ins->dreg = mono_alloc_ireg (cfg);
-					ins->sreg1 = in->dreg;
-					MONO_ADD_INS (cfg->cbb, ins);
-					mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg, FALSE);
+					if (mono_arch_is_soft_float ()) {
+						MONO_INST_NEW (cfg, ins, OP_FGETLOW32);
+						ins->dreg = mono_alloc_ireg (cfg);
+						ins->sreg1 = in->dreg;
+						MONO_ADD_INS (cfg->cbb, ins);
+						mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg, FALSE);
 
-					MONO_INST_NEW (cfg, ins, OP_FGETHIGH32);
-					ins->dreg = mono_alloc_ireg (cfg);
-					ins->sreg1 = in->dreg;
-					MONO_ADD_INS (cfg->cbb, ins);
-					mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg + 1, FALSE);
-#else
-					MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER8_MEMBASE_REG, ARMREG_SP, (cfg->param_area - 8), in->dreg);
-					creg = mono_alloc_ireg (cfg);
-					MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8));
-					mono_call_inst_add_outarg_reg (cfg, call, creg, ainfo->reg, FALSE);
-					creg = mono_alloc_ireg (cfg);
-					MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8 + 4));
-					mono_call_inst_add_outarg_reg (cfg, call, creg, ainfo->reg + 1, FALSE);
-#endif
+						MONO_INST_NEW (cfg, ins, OP_FGETHIGH32);
+						ins->dreg = mono_alloc_ireg (cfg);
+						ins->sreg1 = in->dreg;
+						MONO_ADD_INS (cfg->cbb, ins);
+						mono_call_inst_add_outarg_reg (cfg, call, ins->dreg, ainfo->reg + 1, FALSE);
+					} else {
+						MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER8_MEMBASE_REG, ARMREG_SP, (cfg->param_area - 8), in->dreg);
+						creg = mono_alloc_ireg (cfg);
+						MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8));
+						mono_call_inst_add_outarg_reg (cfg, call, creg, ainfo->reg, FALSE);
+						creg = mono_alloc_ireg (cfg);
+						MONO_EMIT_NEW_LOAD_MEMBASE_OP (cfg, OP_LOAD_MEMBASE, creg, ARMREG_SP, (cfg->param_area - 8 + 4));
+						mono_call_inst_add_outarg_reg (cfg, call, creg, ainfo->reg + 1, FALSE);
+					}
 				}
 				cfg->flags |= MONO_CFG_HAS_FPOUT;
 			} else {
@@ -1522,11 +1514,11 @@
 				if (t->type == MONO_TYPE_R8) {
 					MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER8_MEMBASE_REG, ARMREG_SP, ainfo->offset, in->dreg);
 				} else {
-#ifdef MONO_ARCH_SOFT_FLOAT
-					MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, ARMREG_SP, ainfo->offset, in->dreg);
-#else
-					MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER4_MEMBASE_REG, ARMREG_SP, ainfo->offset, in->dreg);
-#endif
+					if (mono_arch_is_soft_float ()) {
+						MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, ARMREG_SP, ainfo->offset, in->dreg);
+					} else {
+						MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER4_MEMBASE_REG, ARMREG_SP, ainfo->offset, in->dreg);
+					}
 				}
 			} else {
 				MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, ARMREG_SP, ainfo->offset, in->dreg);
@@ -1543,9 +1535,9 @@
 			} else if (!t->byref && (t->type == MONO_TYPE_R8)) {
 				int creg;
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-				g_assert_not_reached ();
-#endif
+				if (mono_arch_is_soft_float ()) {
+					g_assert_not_reached ();
+				}
 
 				MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORER8_MEMBASE_REG, ARMREG_SP, (cfg->param_area - 8), in->dreg);
 				creg = mono_alloc_ireg (cfg);
@@ -1646,37 +1638,39 @@
 			}
 			return;
 		}
-#ifdef MONO_ARCH_SOFT_FLOAT
-		if (ret->type == MONO_TYPE_R8) {
-			MonoInst *ins;
+		if (mono_arch_is_soft_float ()) {
+			if (ret->type == MONO_TYPE_R8) {
+				MonoInst *ins;
 
-			MONO_INST_NEW (cfg, ins, OP_SETFRET);
-			ins->dreg = cfg->ret->dreg;
-			ins->sreg1 = val->dreg;
-			MONO_ADD_INS (cfg->cbb, ins);
-			return;
+				MONO_INST_NEW (cfg, ins, OP_SETFRET);
+				ins->dreg = cfg->ret->dreg;
+				ins->sreg1 = val->dreg;
+				MONO_ADD_INS (cfg->cbb, ins);
+				return;
+			}
+			if (ret->type == MONO_TYPE_R4) {
+				/* Already converted to an int in method_to_ir () */
+				MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
+				return;
+			}			
+		} else {
+			if (mono_arm_is_vfp ()) {
+				if (ret->type == MONO_TYPE_R8 || ret->type == MONO_TYPE_R4) {
+					MonoInst *ins;
+	
+					MONO_INST_NEW (cfg, ins, OP_SETFRET);
+					ins->dreg = cfg->ret->dreg;
+					ins->sreg1 = val->dreg;
+					MONO_ADD_INS (cfg->cbb, ins);
+					return;
+				}
+			} else if (mono_arm_is_fpa ()) {
+				if (ret->type == MONO_TYPE_R4 || ret->type == MONO_TYPE_R8) {
+					MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
+					return;
+				}
+			}
 		}
-		if (ret->type == MONO_TYPE_R4) {
-			/* Already converted to an int in method_to_ir () */
-			MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
-			return;
-		}			
-#elif defined(ARM_FPU_VFP)
-		if (ret->type == MONO_TYPE_R8 || ret->type == MONO_TYPE_R4) {
-			MonoInst *ins;
-
-			MONO_INST_NEW (cfg, ins, OP_SETFRET);
-			ins->dreg = cfg->ret->dreg;
-			ins->sreg1 = val->dreg;
-			MONO_ADD_INS (cfg->cbb, ins);
-			return;
-		}
-#else
-		if (ret->type == MONO_TYPE_R4 || ret->type == MONO_TYPE_R8) {
-			MONO_EMIT_NEW_UNALU (cfg, OP_FMOVE, cfg->ret->dreg, val->dreg);
-			return;
-		}
-#endif
 	}
 
 	/* FIXME: */
@@ -1685,6 +1679,29 @@
 
 #endif /* #ifndef DISABLE_JIT */
 
+gboolean
+mono_arm_is_fpa ()
+{
+	if (!strcmp (g_getenv ("MONO_ARM_FPU_MODE"), "fpa"))
+		return TRUE;
+	return FALSE;
+}
+gboolean
+mono_arm_is_vfp ()
+{
+	if (!strcmp (g_getenv ("MONO_ARM_FPU_MODE"), "vfp"))
+		return TRUE;
+	return FALSE;
+}
+
+gboolean
+mono_arch_is_soft_float ()
+{
+	if (!strcmp (g_getenv ("MONO_ARM_FPU_MODE"), "soft"))
+		return TRUE;
+	return FALSE;
+}
+
 gboolean 
 mono_arch_is_inst_imm (gint64 imm)
 {
@@ -1719,13 +1736,12 @@
 	case RegTypeStructByAddr:
 		break;
 	case RegTypeFP:
-#ifdef ARM_FPU_FPA
-		return FALSE;
-#elif defined(ARM_FPU_VFP)
-		break;
-#else
-		return FALSE;
-#endif
+		if (mono_arm_is_fpa ())
+			return FALSE;
+		else if (mono_arm_is_vfp ())
+			break;
+		else
+			return FALSE;
 	default:
 		return FALSE;
 	}
@@ -1759,11 +1775,11 @@
 		switch (t->type) {
 		case MONO_TYPE_R4:
 		case MONO_TYPE_R8:
-#ifdef MONO_ARCH_SOFT_FLOAT
-			return FALSE;
-#else
-			break;
-#endif
+			if (mono_arch_is_soft_float ()) {
+				return FALSE;
+			} else {
+				break;
+			}
 			/*
 		case MONO_TYPE_I8:
 		case MONO_TYPE_U8:
@@ -1974,20 +1990,21 @@
 		g_assert (ainfo->cinfo->vtype_retaddr);
 		/* Nothing to do */
 		break;
-#if defined(ARM_FPU_VFP)
 	case MONO_TYPE_R4:
-		*(float*)ret = *(float*)&res;
+		if (mono_arm_is_vfp ())
+			*(float*)ret = *(float*)&res;
 		break;
 	case MONO_TYPE_R8: {
-		mgreg_t regs [2];
+		if (mono_arm_is_vfp ()) {
+			mgreg_t regs [2];
 
-		regs [0] = res;
-		regs [1] = res2;
+			regs [0] = res;
+			regs [1] = res2;
 
-		*(double*)ret = *(double*)&regs;
+			*(double*)ret = *(double*)&regs;
+		}
 		break;
 	}
-#endif
 	default:
 		g_assert_not_reached ();
 	}
@@ -2603,15 +2620,15 @@
 emit_float_to_int (MonoCompile *cfg, guchar *code, int dreg, int sreg, int size, gboolean is_signed)
 {
 	/* sreg is a float, dreg is an integer reg  */
-#ifdef ARM_FPU_FPA
-	ARM_FIXZ (code, dreg, sreg);
-#elif defined(ARM_FPU_VFP)
-	if (is_signed)
-		ARM_TOSIZD (code, ARM_VFP_F0, sreg);
-	else
-		ARM_TOUIZD (code, ARM_VFP_F0, sreg);
-	ARM_FMRS (code, dreg, ARM_VFP_F0);
-#endif
+	if (mono_arm_is_fpa ())
+		ARM_FIXZ (code, dreg, sreg);
+	else if (mono_arm_is_vfp ()) {
+		if (is_signed)
+			ARM_TOSIZD (code, ARM_VFP_F0, sreg);
+		else
+			ARM_TOUIZD (code, ARM_VFP_F0, sreg);
+		ARM_FMRS (code, dreg, ARM_VFP_F0);
+	}
 	if (!is_signed) {
 		if (size == 1)
 			ARM_AND_REG_IMM8 (code, dreg, dreg, 0xff);
@@ -3600,19 +3617,19 @@
 			break;
 		}
 		case OP_FMOVE:
-#ifdef ARM_FPU_FPA
-			ARM_MVFD (code, ins->dreg, ins->sreg1);
-#elif defined(ARM_FPU_VFP)
-			ARM_CPYD (code, ins->dreg, ins->sreg1);
-#endif
+			if (mono_arm_is_fpa ()) {
+				ARM_MVFD (code, ins->dreg, ins->sreg1);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_CPYD (code, ins->dreg, ins->sreg1);
+			}
 			break;
 		case OP_FCONV_TO_R4:
-#ifdef ARM_FPU_FPA
-			ARM_MVFS (code, ins->dreg, ins->sreg1);
-#elif defined(ARM_FPU_VFP)
-			ARM_CVTD (code, ins->dreg, ins->sreg1);
-			ARM_CVTS (code, ins->dreg, ins->dreg);
-#endif
+			if (mono_arm_is_fpa ()) {
+				ARM_MVFS (code, ins->dreg, ins->sreg1);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_CVTD (code, ins->dreg, ins->sreg1);
+				ARM_CVTS (code, ins->dreg, ins->dreg);
+			}
 			break;
 		case OP_JMP:
 			/*
@@ -3939,181 +3956,203 @@
 			break;
 
 		/* floating point opcodes */
-#ifdef ARM_FPU_FPA
 		case OP_R8CONST:
-			if (cfg->compile_aot) {
-				ARM_LDFD (code, ins->dreg, ARMREG_PC, 0);
-				ARM_B (code, 1);
-				*(guint32*)code = ((guint32*)(ins->inst_p0))[0];
-				code += 4;
-				*(guint32*)code = ((guint32*)(ins->inst_p0))[1];
-				code += 4;
+			if (mono_arm_is_fpa ()) {
+				if (cfg->compile_aot) {
+					ARM_LDFD (code, ins->dreg, ARMREG_PC, 0);
+					ARM_B (code, 1);
+					*(guint32*)code = ((guint32*)(ins->inst_p0))[0];
+					code += 4;
+					*(guint32*)code = ((guint32*)(ins->inst_p0))[1];
+					code += 4;
+				} else {
+					/* FIXME: we can optimize the imm load by dealing with part of 
+					 * the displacement in LDFD (aligning to 512).
+					 */
+					code = mono_arm_emit_load_imm (code, ARMREG_LR, (guint32)ins->inst_p0);
+					ARM_LDFD (code, ins->dreg, ARMREG_LR, 0);
+				}
+			} else if (mono_arm_is_vfp ()) {
+				if (cfg->compile_aot) {
+					ARM_FLDD (code, ins->dreg, ARMREG_PC, 0);
+					ARM_B (code, 1);
+					*(guint32*)code = ((guint32*)(ins->inst_p0))[0];
+					code += 4;
+					*(guint32*)code = ((guint32*)(ins->inst_p0))[1];
+					code += 4;
+				} else {
+					/* FIXME: we can optimize the imm load by dealing with part of 
+					 * the displacement in LDFD (aligning to 512).
+					 */
+					code = mono_arm_emit_load_imm (code, ARMREG_LR, (guint32)ins->inst_p0);
+					ARM_FLDD (code, ins->dreg, ARMREG_LR, 0);
+				}
 			} else {
-				/* FIXME: we can optimize the imm load by dealing with part of 
-				 * the displacement in LDFD (aligning to 512).
-				 */
-				code = mono_arm_emit_load_imm (code, ARMREG_LR, (guint32)ins->inst_p0);
-				ARM_LDFD (code, ins->dreg, ARMREG_LR, 0);
+				g_assert_not_reached ();
 			}
 			break;
 		case OP_R4CONST:
-			if (cfg->compile_aot) {
-				ARM_LDFS (code, ins->dreg, ARMREG_PC, 0);
-				ARM_B (code, 0);
-				*(guint32*)code = ((guint32*)(ins->inst_p0))[0];
-				code += 4;
+			if (mono_arm_is_fpa ()) {
+				if (cfg->compile_aot) {
+					ARM_LDFS (code, ins->dreg, ARMREG_PC, 0);
+					ARM_B (code, 0);
+					*(guint32*)code = ((guint32*)(ins->inst_p0))[0];
+					code += 4;
+				} else {
+					code = mono_arm_emit_load_imm (code, ARMREG_LR, (guint32)ins->inst_p0);
+					ARM_LDFS (code, ins->dreg, ARMREG_LR, 0);
+				}
+			} else if (mono_arm_is_vfp ()) {
+				if (cfg->compile_aot) {
+					ARM_FLDS (code, ins->dreg, ARMREG_PC, 0);
+					ARM_B (code, 0);
+					*(guint32*)code = ((guint32*)(ins->inst_p0))[0];
+					code += 4;
+					ARM_CVTS (code, ins->dreg, ins->dreg);
+				} else {
+					code = mono_arm_emit_load_imm (code, ARMREG_LR, (guint32)ins->inst_p0);
+					ARM_FLDS (code, ins->dreg, ARMREG_LR, 0);
+					ARM_CVTS (code, ins->dreg, ins->dreg);
+				}
 			} else {
-				code = mono_arm_emit_load_imm (code, ARMREG_LR, (guint32)ins->inst_p0);
-				ARM_LDFS (code, ins->dreg, ARMREG_LR, 0);
+				g_assert_not_reached ();
 			}
 			break;
 		case OP_STORER8_MEMBASE_REG:
-			/* This is generated by the local regalloc pass which runs after the lowering pass */
-			if (!arm_is_fpimm8 (ins->inst_offset)) {
-				code = mono_arm_emit_load_imm (code, ARMREG_LR, ins->inst_offset);
-				ARM_ADD_REG_REG (code, ARMREG_LR, ARMREG_LR, ins->inst_destbasereg);
-				ARM_STFD (code, ins->sreg1, ARMREG_LR, 0);
+			if (mono_arm_is_fpa ()) {
+				/* This is generated by the local regalloc pass which runs after the lowering pass */
+				if (!arm_is_fpimm8 (ins->inst_offset)) {
+					code = mono_arm_emit_load_imm (code, ARMREG_LR, ins->inst_offset);
+					ARM_ADD_REG_REG (code, ARMREG_LR, ARMREG_LR, ins->inst_destbasereg);
+					ARM_STFD (code, ins->sreg1, ARMREG_LR, 0);
+				} else {
+					ARM_STFD (code, ins->sreg1, ins->inst_destbasereg, ins->inst_offset);
+				}
+			} else if (mono_arm_is_vfp ()) {
+				/* This is generated by the local regalloc pass which runs after the lowering pass */
+				if (!arm_is_fpimm8 (ins->inst_offset)) {
+					code = mono_arm_emit_load_imm (code, ARMREG_LR, ins->inst_offset);
+					ARM_ADD_REG_REG (code, ARMREG_LR, ARMREG_LR, ins->inst_destbasereg);
+					ARM_FSTD (code, ins->sreg1, ARMREG_LR, 0);
+				} else {
+					ARM_FSTD (code, ins->sreg1, ins->inst_destbasereg, ins->inst_offset);
+				}
 			} else {
-				ARM_STFD (code, ins->sreg1, ins->inst_destbasereg, ins->inst_offset);
+				g_assert_not_reached ();
 			}
 			break;
 		case OP_LOADR8_MEMBASE:
-			/* This is generated by the local regalloc pass which runs after the lowering pass */
-			if (!arm_is_fpimm8 (ins->inst_offset)) {
-				code = mono_arm_emit_load_imm (code, ARMREG_LR, ins->inst_offset);
-				ARM_ADD_REG_REG (code, ARMREG_LR, ARMREG_LR, ins->inst_basereg);
-				ARM_LDFD (code, ins->dreg, ARMREG_LR, 0);
+			if (mono_arm_is_fpa ()) {
+				/* This is generated by the local regalloc pass which runs after the lowering pass */
+				if (!arm_is_fpimm8 (ins->inst_offset)) {
+					code = mono_arm_emit_load_imm (code, ARMREG_LR, ins->inst_offset);
+					ARM_ADD_REG_REG (code, ARMREG_LR, ARMREG_LR, ins->inst_basereg);
+					ARM_LDFD (code, ins->dreg, ARMREG_LR, 0);
+				} else {
+					ARM_LDFD (code, ins->dreg, ins->inst_basereg, ins->inst_offset);
+				}
+			} else if (mono_arm_is_vfp ()) {
+				/* This is generated by the local regalloc pass which runs after the lowering pass */
+				if (!arm_is_fpimm8 (ins->inst_offset)) {
+					code = mono_arm_emit_load_imm (code, ARMREG_LR, ins->inst_offset);
+					ARM_ADD_REG_REG (code, ARMREG_LR, ARMREG_LR, ins->inst_basereg);
+					ARM_FLDD (code, ins->dreg, ARMREG_LR, 0);
+				} else {
+					ARM_FLDD (code, ins->dreg, ins->inst_basereg, ins->inst_offset);
+				}
 			} else {
-				ARM_LDFD (code, ins->dreg, ins->inst_basereg, ins->inst_offset);
+				g_assert_not_reached ();
 			}
 			break;
 		case OP_STORER4_MEMBASE_REG:
-			g_assert (arm_is_fpimm8 (ins->inst_offset));
-			ARM_STFS (code, ins->sreg1, ins->inst_destbasereg, ins->inst_offset);
+			if (mono_arm_is_fpa ()) {
+				g_assert (arm_is_fpimm8 (ins->inst_offset));
+				ARM_STFS (code, ins->sreg1, ins->inst_destbasereg, ins->inst_offset);
+			} else if (mono_arm_is_vfp ()) {
+				g_assert (arm_is_fpimm8 (ins->inst_offset));
+				ARM_CVTD (code, ARM_VFP_F0, ins->sreg1);
+				ARM_FSTS (code, ARM_VFP_F0, ins->inst_destbasereg, ins->inst_offset);
+			} else {
+				g_assert_not_reached ();
+			}
 			break;
 		case OP_LOADR4_MEMBASE:
-			g_assert (arm_is_fpimm8 (ins->inst_offset));
-			ARM_LDFS (code, ins->dreg, ins->inst_basereg, ins->inst_offset);
+			if (mono_arm_is_fpa ()) {
+				g_assert (arm_is_fpimm8 (ins->inst_offset));
+				ARM_LDFS (code, ins->dreg, ins->inst_basereg, ins->inst_offset);
+			} else if (mono_arm_is_vfp ()) {
+				g_assert (arm_is_fpimm8 (ins->inst_offset));
+				ARM_FLDS (code, ARM_VFP_F0, ins->inst_basereg, ins->inst_offset);
+				ARM_CVTS (code, ins->dreg, ARM_VFP_F0);
+			} else {
+				g_assert_not_reached ();
+			}
 			break;
 		case OP_ICONV_TO_R_UN: {
-			int tmpreg;
-			tmpreg = ins->dreg == 0? 1: 0;
-			ARM_CMP_REG_IMM8 (code, ins->sreg1, 0);
-			ARM_FLTD (code, ins->dreg, ins->sreg1);
-			ARM_B_COND (code, ARMCOND_GE, 8);
-			/* save the temp register */
-			ARM_SUB_REG_IMM8 (code, ARMREG_SP, ARMREG_SP, 8);
-			ARM_STFD (code, tmpreg, ARMREG_SP, 0);
-			ARM_LDFD (code, tmpreg, ARMREG_PC, 12);
-			ARM_FPA_ADFD (code, ins->dreg, ins->dreg, tmpreg);
-			ARM_LDFD (code, tmpreg, ARMREG_SP, 0);
-			ARM_ADD_REG_IMM8 (code, ARMREG_SP, ARMREG_SP, 8);
-			/* skip the constant pool */
-			ARM_B (code, 8);
-			code += 4;
-			*(int*)code = 0x41f00000;
-			code += 4;
-			*(int*)code = 0;
-			code += 4;
-			/* FIXME: adjust:
-			 * ldfltd  ftemp, [pc, #8] 0x41f00000 0x00000000
-			 * adfltd  fdest, fdest, ftemp
-			 */
-			break;
-		}
-		case OP_ICONV_TO_R4:
-			ARM_FLTS (code, ins->dreg, ins->sreg1);
-			break;
-		case OP_ICONV_TO_R8:
-			ARM_FLTD (code, ins->dreg, ins->sreg1);
-			break;
-
-#elif defined(ARM_FPU_VFP)
-
-		case OP_R8CONST:
-			if (cfg->compile_aot) {
-				ARM_FLDD (code, ins->dreg, ARMREG_PC, 0);
-				ARM_B (code, 1);
-				*(guint32*)code = ((guint32*)(ins->inst_p0))[0];
+			if (mono_arm_is_fpa ()) {
+				int tmpreg;
+				tmpreg = ins->dreg == 0? 1: 0;
+				ARM_CMP_REG_IMM8 (code, ins->sreg1, 0);
+				ARM_FLTD (code, ins->dreg, ins->sreg1);
+				ARM_B_COND (code, ARMCOND_GE, 8);
+				/* save the temp register */
+				ARM_SUB_REG_IMM8 (code, ARMREG_SP, ARMREG_SP, 8);
+				ARM_STFD (code, tmpreg, ARMREG_SP, 0);
+				ARM_LDFD (code, tmpreg, ARMREG_PC, 12);
+				ARM_FPA_ADFD (code, ins->dreg, ins->dreg, tmpreg);
+				ARM_LDFD (code, tmpreg, ARMREG_SP, 0);
+				ARM_ADD_REG_IMM8 (code, ARMREG_SP, ARMREG_SP, 8);
+				/* skip the constant pool */
+				ARM_B (code, 8);
 				code += 4;
-				*(guint32*)code = ((guint32*)(ins->inst_p0))[1];
+				*(int*)code = 0x41f00000;
 				code += 4;
-			} else {
-				/* FIXME: we can optimize the imm load by dealing with part of 
-				 * the displacement in LDFD (aligning to 512).
+				*(int*)code = 0;
+				code += 4;
+				/* FIXME: adjust:
+				 * ldfltd  ftemp, [pc, #8] 0x41f00000 0x00000000
+				 * adfltd  fdest, fdest, ftemp
 				 */
-				code = mono_arm_emit_load_imm (code, ARMREG_LR, (guint32)ins->inst_p0);
-				ARM_FLDD (code, ins->dreg, ARMREG_LR, 0);
-			}
-			break;
-		case OP_R4CONST:
-			if (cfg->compile_aot) {
-				ARM_FLDS (code, ins->dreg, ARMREG_PC, 0);
-				ARM_B (code, 0);
-				*(guint32*)code = ((guint32*)(ins->inst_p0))[0];
-				code += 4;
-				ARM_CVTS (code, ins->dreg, ins->dreg);
+			} else if (mono_arm_is_vfp ()) {
+				g_assert_not_reached ();
 			} else {
-				code = mono_arm_emit_load_imm (code, ARMREG_LR, (guint32)ins->inst_p0);
-				ARM_FLDS (code, ins->dreg, ARMREG_LR, 0);
-				ARM_CVTS (code, ins->dreg, ins->dreg);
+				g_assert_not_reached ();
 			}
 			break;
-		case OP_STORER8_MEMBASE_REG:
-			/* This is generated by the local regalloc pass which runs after the lowering pass */
-			if (!arm_is_fpimm8 (ins->inst_offset)) {
-				code = mono_arm_emit_load_imm (code, ARMREG_LR, ins->inst_offset);
-				ARM_ADD_REG_REG (code, ARMREG_LR, ARMREG_LR, ins->inst_destbasereg);
-				ARM_FSTD (code, ins->sreg1, ARMREG_LR, 0);
+		}
+		case OP_ICONV_TO_R4:
+			if (mono_arm_is_fpa ()) {
+				ARM_FLTS (code, ins->dreg, ins->sreg1);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_FMSR (code, ARM_VFP_F0, ins->sreg1);
+				ARM_FSITOS (code, ARM_VFP_F0, ARM_VFP_F0);
+				ARM_CVTS (code, ins->dreg, ARM_VFP_F0);
 			} else {
-				ARM_FSTD (code, ins->sreg1, ins->inst_destbasereg, ins->inst_offset);
+				g_assert_not_reached ();
 			}
 			break;
-		case OP_LOADR8_MEMBASE:
-			/* This is generated by the local regalloc pass which runs after the lowering pass */
-			if (!arm_is_fpimm8 (ins->inst_offset)) {
-				code = mono_arm_emit_load_imm (code, ARMREG_LR, ins->inst_offset);
-				ARM_ADD_REG_REG (code, ARMREG_LR, ARMREG_LR, ins->inst_basereg);
-				ARM_FLDD (code, ins->dreg, ARMREG_LR, 0);
+		case OP_ICONV_TO_R8:
+			if (mono_arm_is_fpa ()) {
+				ARM_FLTD (code, ins->dreg, ins->sreg1);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_FMSR (code, ARM_VFP_F0, ins->sreg1);
+				ARM_FSITOD (code, ins->dreg, ARM_VFP_F0);
 			} else {
-				ARM_FLDD (code, ins->dreg, ins->inst_basereg, ins->inst_offset);
+				g_assert_not_reached ();
 			}
 			break;
-		case OP_STORER4_MEMBASE_REG:
-			g_assert (arm_is_fpimm8 (ins->inst_offset));
-			ARM_CVTD (code, ARM_VFP_F0, ins->sreg1);
-			ARM_FSTS (code, ARM_VFP_F0, ins->inst_destbasereg, ins->inst_offset);
-			break;
-		case OP_LOADR4_MEMBASE:
-			g_assert (arm_is_fpimm8 (ins->inst_offset));
-			ARM_FLDS (code, ARM_VFP_F0, ins->inst_basereg, ins->inst_offset);
-			ARM_CVTS (code, ins->dreg, ARM_VFP_F0);
-			break;
-		case OP_ICONV_TO_R_UN: {
-			g_assert_not_reached ();
-			break;
-		}
-		case OP_ICONV_TO_R4:
-			ARM_FMSR (code, ARM_VFP_F0, ins->sreg1);
-			ARM_FSITOS (code, ARM_VFP_F0, ARM_VFP_F0);
-			ARM_CVTS (code, ins->dreg, ARM_VFP_F0);
-			break;
-		case OP_ICONV_TO_R8:
-			ARM_FMSR (code, ARM_VFP_F0, ins->sreg1);
-			ARM_FSITOD (code, ins->dreg, ARM_VFP_F0);
-			break;
-
 		case OP_SETFRET:
-			if (mono_method_signature (cfg->method)->ret->type == MONO_TYPE_R4) {
-				ARM_CVTD (code, ARM_VFP_F0, ins->sreg1);
-				ARM_FMRS (code, ARMREG_R0, ARM_VFP_F0);
+			if (mono_arm_is_fpa ()) {
+				if (mono_method_signature (cfg->method)->ret->type == MONO_TYPE_R4) {
+					ARM_CVTD (code, ARM_VFP_F0, ins->sreg1);
+					ARM_FMRS (code, ARMREG_R0, ARM_VFP_F0);
+				} else {
+					ARM_FMRRD (code, ARMREG_R0, ARMREG_R1, ins->sreg1);
+				}
 			} else {
-				ARM_FMRRD (code, ARMREG_R0, ARMREG_R1, ins->sreg1);
+				g_assert_not_reached ();
 			}
 			break;
-
-#endif
-
 		case OP_FCONV_TO_I1:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 1, TRUE);
 			break;
@@ -4175,101 +4214,117 @@
 				ARM_MOV_REG_REG (code, ins->dreg, ins->sreg1);
 			break;
 		}
-#ifdef ARM_FPU_FPA
 		case OP_FADD:
-			ARM_FPA_ADFD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			if (mono_arm_is_fpa ()) {
+				ARM_FPA_ADFD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_VFP_ADDD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			} else {
+				g_assert_not_reached ();
+			}
 			break;
 		case OP_FSUB:
-			ARM_FPA_SUFD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			if (mono_arm_is_fpa ()) {
+				ARM_FPA_SUFD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_VFP_SUBD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			} else {
+				g_assert_not_reached ();
+			}
 			break;		
 		case OP_FMUL:
-			ARM_FPA_MUFD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			if (mono_arm_is_fpa ()) {
+				ARM_FPA_MUFD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_VFP_MULD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			} else {
+				g_assert_not_reached ();
+			}
 			break;		
 		case OP_FDIV:
-			ARM_FPA_DVFD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			if (mono_arm_is_fpa ()) {
+				ARM_FPA_DVFD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_VFP_DIVD (code, ins->dreg, ins->sreg1, ins->sreg2);
+			} else {
+				g_assert_not_reached ();
+			}
 			break;		
 		case OP_FNEG:
-			ARM_MNFD (code, ins->dreg, ins->sreg1);
+			if (mono_arm_is_fpa ()) {
+				ARM_MNFD (code, ins->dreg, ins->sreg1);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_NEGD (code, ins->dreg, ins->sreg1);
+			} else {
+				g_assert_not_reached ();
+			}
 			break;
-#elif defined(ARM_FPU_VFP)
-		case OP_FADD:
-			ARM_VFP_ADDD (code, ins->dreg, ins->sreg1, ins->sreg2);
-			break;
-		case OP_FSUB:
-			ARM_VFP_SUBD (code, ins->dreg, ins->sreg1, ins->sreg2);
-			break;		
-		case OP_FMUL:
-			ARM_VFP_MULD (code, ins->dreg, ins->sreg1, ins->sreg2);
-			break;		
-		case OP_FDIV:
-			ARM_VFP_DIVD (code, ins->dreg, ins->sreg1, ins->sreg2);
-			break;		
-		case OP_FNEG:
-			ARM_NEGD (code, ins->dreg, ins->sreg1);
-			break;
-#endif
 		case OP_FREM:
 			/* emulated */
 			g_assert_not_reached ();
 			break;
 		case OP_FCOMPARE:
-#ifdef ARM_FPU_FPA
-			ARM_FCMP (code, ARM_FPA_CMF, ins->sreg1, ins->sreg2);
-#elif defined(ARM_FPU_VFP)
-			ARM_CMPD (code, ins->sreg1, ins->sreg2);
-			ARM_FMSTAT (code);
-#endif
+			if (mono_arm_is_fpa ()) {
+				ARM_FCMP (code, ARM_FPA_CMF, ins->sreg1, ins->sreg2);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_CMPD (code, ins->sreg1, ins->sreg2);
+				ARM_FMSTAT (code);
+			} else {
+				g_assert_not_reached ();
+			}
 			break;
 		case OP_FCEQ:
-#ifdef ARM_FPU_FPA
-			ARM_FCMP (code, ARM_FPA_CMF, ins->sreg1, ins->sreg2);
-#elif defined(ARM_FPU_VFP)
-			ARM_CMPD (code, ins->sreg1, ins->sreg2);
-			ARM_FMSTAT (code);
-#endif
+			if (mono_arm_is_fpa ()) {
+				ARM_FCMP (code, ARM_FPA_CMF, ins->sreg1, ins->sreg2);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_CMPD (code, ins->sreg1, ins->sreg2);
+				ARM_FMSTAT (code);
+			}
+
 			ARM_MOV_REG_IMM8_COND (code, ins->dreg, 0, ARMCOND_NE);
 			ARM_MOV_REG_IMM8_COND (code, ins->dreg, 1, ARMCOND_EQ);
 			break;
 		case OP_FCLT:
-#ifdef ARM_FPU_FPA
-			ARM_FCMP (code, ARM_FPA_CMF, ins->sreg1, ins->sreg2);
-#elif defined(ARM_FPU_VFP)
-			ARM_CMPD (code, ins->sreg1, ins->sreg2);
-			ARM_FMSTAT (code);
-#endif
+			if (mono_arm_is_fpa ()) {
+				ARM_FCMP (code, ARM_FPA_CMF, ins->sreg1, ins->sreg2);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_CMPD (code, ins->sreg1, ins->sreg2);
+				ARM_FMSTAT (code);
+			}
+
 			ARM_MOV_REG_IMM8 (code, ins->dreg, 0);
 			ARM_MOV_REG_IMM8_COND (code, ins->dreg, 1, ARMCOND_MI);
 			break;
 		case OP_FCLT_UN:
-#ifdef ARM_FPU_FPA
-			ARM_FCMP (code, ARM_FPA_CMF, ins->sreg1, ins->sreg2);
-#elif defined(ARM_FPU_VFP)
-			ARM_CMPD (code, ins->sreg1, ins->sreg2);
-			ARM_FMSTAT (code);
-#endif
+			if (mono_arm_is_fpa ()) {
+				ARM_FCMP (code, ARM_FPA_CMF, ins->sreg1, ins->sreg2);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_CMPD (code, ins->sreg1, ins->sreg2);
+				ARM_FMSTAT (code);
+			}
 			ARM_MOV_REG_IMM8 (code, ins->dreg, 0);
 			ARM_MOV_REG_IMM8_COND (code, ins->dreg, 1, ARMCOND_MI);
 			ARM_MOV_REG_IMM8_COND (code, ins->dreg, 1, ARMCOND_VS);
 			break;
 		case OP_FCGT:
 			/* swapped */
-#ifdef ARM_FPU_FPA
-			ARM_FCMP (code, ARM_FPA_CMF, ins->sreg2, ins->sreg1);
-#elif defined(ARM_FPU_VFP)
-			ARM_CMPD (code, ins->sreg2, ins->sreg1);
-			ARM_FMSTAT (code);
-#endif
+			if (mono_arm_is_fpa ()) {
+				ARM_FCMP (code, ARM_FPA_CMF, ins->sreg2, ins->sreg1);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_CMPD (code, ins->sreg2, ins->sreg1);
+				ARM_FMSTAT (code);
+			}
 			ARM_MOV_REG_IMM8 (code, ins->dreg, 0);
 			ARM_MOV_REG_IMM8_COND (code, ins->dreg, 1, ARMCOND_MI);
 			break;
 		case OP_FCGT_UN:
 			/* swapped */
-#ifdef ARM_FPU_FPA
-			ARM_FCMP (code, ARM_FPA_CMF, ins->sreg2, ins->sreg1);
-#elif defined(ARM_FPU_VFP)
-			ARM_CMPD (code, ins->sreg2, ins->sreg1);
-			ARM_FMSTAT (code);
-#endif
+			if (mono_arm_is_fpa ()) {
+				ARM_FCMP (code, ARM_FPA_CMF, ins->sreg2, ins->sreg1);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_CMPD (code, ins->sreg2, ins->sreg1);
+				ARM_FMSTAT (code);
+			}
 			ARM_MOV_REG_IMM8 (code, ins->dreg, 0);
 			ARM_MOV_REG_IMM8_COND (code, ins->dreg, 1, ARMCOND_MI);
 			ARM_MOV_REG_IMM8_COND (code, ins->dreg, 1, ARMCOND_VS);
@@ -4300,13 +4355,13 @@
 			g_assert_not_reached ();
 			break;
 		case OP_FBGE:
-#ifdef ARM_FPU_VFP
-			EMIT_COND_BRANCH_FLAGS (ins, ARMCOND_GE);
-#else
-			/* FPA requires EQ even thou the docs suggests that just CS is enough */			 
-			EMIT_COND_BRANCH_FLAGS (ins, ARMCOND_EQ);
-			EMIT_COND_BRANCH_FLAGS (ins, ARMCOND_CS);
-#endif
+			if (mono_arm_is_fpa ()) {
+				/* FPA requires EQ even thou the docs suggests that just CS is enough */			 
+				EMIT_COND_BRANCH_FLAGS (ins, ARMCOND_EQ);
+				EMIT_COND_BRANCH_FLAGS (ins, ARMCOND_CS);
+			} else if (mono_arm_is_vfp ()) {
+				EMIT_COND_BRANCH_FLAGS (ins, ARMCOND_GE);
+			}
 			break;
 		case OP_FBGE_UN:
 			EMIT_COND_BRANCH_FLAGS (ins, ARMCOND_VS); /* V set */
@@ -4314,26 +4369,28 @@
 			break;
 
 		case OP_CKFINITE: {
-#ifdef ARM_FPU_FPA
-			if (ins->dreg != ins->sreg1)
-				ARM_MVFD (code, ins->dreg, ins->sreg1);
-#elif defined(ARM_FPU_VFP)
-			ARM_ABSD (code, ARM_VFP_D1, ins->sreg1);
-			ARM_FLDD (code, ARM_VFP_D0, ARMREG_PC, 0);
-			ARM_B (code, 1);
-			*(guint32*)code = 0xffffffff;
-			code += 4;
-			*(guint32*)code = 0x7fefffff;
-			code += 4;
-			ARM_CMPD (code, ARM_VFP_D1, ARM_VFP_D0);
-			ARM_FMSTAT (code);
-			EMIT_COND_SYSTEM_EXCEPTION_FLAGS (ARMCOND_GT, "ArithmeticException");
-			ARM_CMPD (code, ins->sreg1, ins->sreg1);
-			ARM_FMSTAT (code);
-			EMIT_COND_SYSTEM_EXCEPTION_FLAGS (ARMCOND_VS, "ArithmeticException");			
+			if (mono_arm_is_fpa ()) {
+				if (ins->dreg != ins->sreg1)
+					ARM_MVFD (code, ins->dreg, ins->sreg1);
+			} else if (mono_arm_is_vfp ()) {
+				ARM_ABSD_VFP (code, ARM_VFP_D1, ins->sreg1);
+				ARM_FLDD (code, ARM_VFP_D0, ARMREG_PC, 0);
+				ARM_B (code, 1);
+				*(guint32*)code = 0xffffffff;
+				code += 4;
+				*(guint32*)code = 0x7fefffff;
+				code += 4;
+				ARM_CMPD (code, ARM_VFP_D1, ARM_VFP_D0);
+				ARM_FMSTAT (code);
+				EMIT_COND_SYSTEM_EXCEPTION_FLAGS (ARMCOND_GT, "ArithmeticException");
+				ARM_CMPD (code, ins->sreg1, ins->sreg1);
+				ARM_FMSTAT (code);
+				EMIT_COND_SYSTEM_EXCEPTION_FLAGS (ARMCOND_VS, "ArithmeticException");			
 
-			ARM_CPYD (code, ins->dreg, ins->sreg1);
-#endif
+				ARM_CPYD (code, ins->dreg, ins->sreg1);
+			} else {
+				g_assert_not_reached ();
+			}
 			break;
 		}
 		default:
Index: mini/mini-arm.h
===================================================================
--- mini/mini-arm.h	(revision 159106)
+++ mini/mini-arm.h	(working copy)
@@ -4,10 +4,6 @@
 #include <mono/arch/arm/arm-codegen.h>
 #include <glib.h>
 
-#if defined(ARM_FPU_NONE) || (defined(__ARM_EABI__) && !defined(ARM_FPU_VFP))
-#define MONO_ARCH_SOFT_FLOAT 1
-#endif
-
 #if defined(__ARM_EABI__)
 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
 #define ARM_ARCHITECTURE "armel"
@@ -18,18 +14,8 @@
 #define ARM_ARCHITECTURE "arm"
 #endif
 
-#if defined(ARM_FPU_FPA)
-#define ARM_FP_MODEL "fpa"
-#elif defined(ARM_FPU_VFP)
-#define ARM_FP_MODEL "vfp"
-#elif defined(ARM_FPU_NONE)
-#define ARM_FP_MODEL "soft-float"
-#else
-#error "At least one of ARM_FPU_NONE or ARM_FPU_FPA or ARM_FPU_VFP must be defined."
-#endif
+#define MONO_ARCH_ARCHITECTURE ARM_ARCHITECTURE
 
-#define MONO_ARCH_ARCHITECTURE ARM_ARCHITECTURE "," ARM_FP_MODEL
-
 #define MONO_ARCH_CPU_SPEC arm_cpu_desc
 
 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
@@ -54,12 +40,9 @@
 #define MONO_ARCH_CALLEE_REGS ((1<<ARMREG_R0) | (1<<ARMREG_R1) | (1<<ARMREG_R2) | (1<<ARMREG_R3) | (1<<ARMREG_IP))
 #define MONO_ARCH_CALLEE_SAVED_REGS ((1<<ARMREG_V1) | (1<<ARMREG_V2) | (1<<ARMREG_V3) | (1<<ARMREG_V4) | (1<<ARMREG_V5) | (1<<ARMREG_V6) | (1<<ARMREG_V7))
 
-#ifdef ARM_FPU_VFP
 /* Every double precision vfp register, d0/d1 is reserved for a scratch reg */
 #define MONO_ARCH_CALLEE_FREGS 0x55555550
-#else
-#define MONO_ARCH_CALLEE_FREGS 0xf
-#endif
+#define MONO_ARCH_CALLEE_FREGS_SOFT 0xf
 #define MONO_ARCH_CALLEE_SAVED_FREGS 0
 
 #define MONO_ARCH_USE_FPSTACK FALSE
@@ -67,15 +50,9 @@
 
 #define MONO_ARCH_INST_SREG2_MASK(ins) (0)
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-#define MONO_ARCH_INST_FIXED_REG(desc) (((desc) == 'l' || (desc == 'f') || (desc == 'g')) ? ARM_LSW_REG: (((desc) == 'a') ? ARMREG_R0 : -1))
-#define MONO_ARCH_INST_IS_REGPAIR(desc) ((desc) == 'l' || (desc) == 'L' || (desc) == 'f' || (desc) == 'g')
-#define MONO_ARCH_INST_IS_FLOAT(desc) (FALSE)
-#else
-#define MONO_ARCH_INST_FIXED_REG(desc) (((desc) == 'l')? ARM_LSW_REG: (((desc) == 'a') ? ARMREG_R0 : -1))
-#define MONO_ARCH_INST_IS_REGPAIR(desc) (desc == 'l' || desc == 'L')
-#define MONO_ARCH_INST_IS_FLOAT(desc) ((desc == 'f') || (desc == 'g'))
-#endif
+#define MONO_ARCH_INST_FIXED_REG(desc) (mono_arch_is_soft_float () ? (((desc) == 'l' || (desc == 'f') || (desc == 'g')) ? ARM_LSW_REG: (((desc) == 'a') ? ARMREG_R0 : -1)) : (((desc) == 'l')? ARM_LSW_REG: (((desc) == 'a') ? ARMREG_R0 : -1)))
+#define MONO_ARCH_INST_IS_REGPAIR(desc) (mono_arch_is_soft_float () ? ((desc) == 'l' || (desc) == 'L' || (desc) == 'f' || (desc) == 'g') : (desc == 'l' || desc == 'L'))
+#define MONO_ARCH_INST_IS_FLOAT(desc) (mono_arch_is_soft_float () ? FALSE : ((desc == 'f') || (desc == 'g')))
 #define MONO_ARCH_INST_REGPAIR_REG2(desc,hreg1) (desc == 'l'  || (desc == 'f') || (desc == 'g')? ARM_MSW_REG : -1)
 
 #define MONO_ARCH_FRAME_ALIGNMENT 8
@@ -204,6 +181,12 @@
 mono_arm_throw_exception_by_token (guint32 type_token, unsigned long eip, unsigned long esp, gulong *int_regs, gdouble *fp_regs);
 
 gboolean
+mono_arm_is_fpa (void);
+
+gboolean
+mono_arm_is_vfp (void);
+
+gboolean
 mono_arm_thumb_supported (void);
 
 #endif /* __MONO_MINI_ARM_H__ */
Index: mini/jit-icalls.c
===================================================================
--- mini/jit-icalls.c	(revision 159106)
+++ mini/jit-icalls.c	(working copy)
@@ -328,7 +328,6 @@
 }
 #endif
 
-#if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_SOFT_FLOAT)
 double
 mono_fdiv (double a, double b)
 {
@@ -336,7 +335,6 @@
 
 	return a / b;
 }
-#endif
 
 gint64 
 mono_lldiv (gint64 a, gint64 b)
@@ -435,8 +433,6 @@
 
 #endif
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-
 double
 mono_fsub (double a, double b)
 {
@@ -630,8 +626,6 @@
 	return *(guint32*)&v;
 }
 
-#endif
-
 MonoArray *
 mono_array_new_va (MonoMethod *cm, ...)
 {
@@ -880,17 +874,17 @@
  * 
  * To work around this issue we test for value boundaries instead. 
  */
-#if defined(__arm__) && MONO_ARCH_SOFT_FLOAT 
-	if (isnan (v) || !(v >= -0.5 && v <= ULLONG_MAX+0.5)) {
-		mono_raise_exception (mono_get_exception_overflow ());
+	if (mono_arch_is_soft_float ()) {
+		if (isnan (v) || !(v >= -0.5 && v <= ULLONG_MAX+0.5)) {
+			mono_raise_exception (mono_get_exception_overflow ());
+		}
+		res = (guint64)v;
+	} else {
+		res = (guint64)v;
+		if (isnan(v) || trunc (v) != res) {
+			mono_raise_exception (mono_get_exception_overflow ());
+		}
 	}
-	res = (guint64)v;
-#else
-	res = (guint64)v;
-	if (isnan(v) || trunc (v) != res) {
-		mono_raise_exception (mono_get_exception_overflow ());
-	}
-#endif
 	return res;
 }
 
Index: mini/mini-ia64.c
===================================================================
--- mini/mini-ia64.c	(revision 159106)
+++ mini/mini-ia64.c	(working copy)
@@ -4480,6 +4480,12 @@
 	/* Not needed because of libunwind */
 }
 
+gboolean
+mono_arch_is_soft_float ()
+{
+	return FALSE;
+}
+
 gboolean 
 mono_arch_is_inst_imm (gint64 imm)
 {
Index: mini/mini-sparc.c
===================================================================
--- mini/mini-sparc.c	(revision 159106)
+++ mini/mini-sparc.c	(working copy)
@@ -349,6 +349,12 @@
 	mono_sparc_flushw ();
 }
 
+gboolean
+mono_arch_is_soft_float ()
+{
+	return FALSE;
+}
+
 gboolean 
 mono_arch_is_inst_imm (gint64 imm)
 {
Index: mini/mini-llvm.c
===================================================================
--- mini/mini-llvm.c	(revision 159106)
+++ mini/mini-llvm.c	(working copy)
@@ -738,12 +738,10 @@
 		if (LLVMGetTypeKind (stype) == LLVMPointerTypeKind)
 			return LLVMBuildPtrToInt (ctx->builder, v, dtype, "");
 
-#ifdef MONO_ARCH_SOFT_FLOAT
-		if (stype == LLVMInt32Type () && dtype == LLVMFloatType ())
+		if (mono_arch_is_soft_float () && stype == LLVMInt32Type () && dtype == LLVMFloatType ())
 			return LLVMBuildBitCast (ctx->builder, v, dtype, "");
-		if (stype == LLVMInt32Type () && dtype == LLVMDoubleType ())
+		if (mono_arch_is_soft_float () && stype == LLVMInt32Type () && dtype == LLVMDoubleType ())
 			return LLVMBuildBitCast (ctx->builder, LLVMBuildZExt (ctx->builder, v, LLVMInt64Type (), ""), dtype, "");
-#endif
 
 		LLVMDumpValue (v);
 		LLVMDumpValue (LLVMConstNull (dtype));
Index: mini/mini-ppc.c
===================================================================
--- mini/mini-ppc.c	(revision 159106)
+++ mini/mini-ppc.c	(working copy)
@@ -1787,6 +1787,12 @@
 	MONO_EMIT_NEW_UNALU (cfg, OP_MOVE, cfg->ret->dreg, val->dreg);
 }
 
+gboolean
+mono_arch_is_soft_float ()
+{
+	return FALSE;
+}
+
 /* FIXME: this is just a useless hint: fix the interface to include the opcode */
 gboolean
 mono_arch_is_inst_imm (gint64 imm)
Index: mini/mini-alpha.c
===================================================================
--- mini/mini-alpha.c	(revision 159106)
+++ mini/mini-alpha.c	(working copy)
@@ -4262,6 +4262,12 @@
   g_free (cinfo);
 }
 
+gboolean
+mono_arch_is_soft_float ()
+{
+	return FALSE;
+}
+
 /*========================= End of Function ========================*/
 
 /*------------------------------------------------------------------*/
Index: mini/mini-s390.c
===================================================================
--- mini/mini-s390.c	(revision 159106)
+++ mini/mini-s390.c	(working copy)
@@ -1218,6 +1218,12 @@
 {
 }
 
+gboolean
+mono_arch_is_soft_float ()
+{
+	return FALSE;
+}
+
 /*========================= End of Function ========================*/
 
 /*------------------------------------------------------------------*/
