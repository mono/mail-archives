Index: typemanager.cs
===================================================================
--- typemanager.cs	(revisión: 47987)
+++ typemanager.cs	(copia de trabajo)
@@ -106,6 +106,7 @@
 	static internal Type compiler_generated_attr_type;
 	static internal Type fixed_buffer_attr_type;
 	static internal Type default_charset_type;
+	static public Type internals_visible_attr_type;
 
 	//
 	// An empty array of types
@@ -1232,6 +1233,7 @@
 		compiler_generated_attr_type = CoreLookupType ("System.Runtime.CompilerServices.CompilerGeneratedAttribute");
 		fixed_buffer_attr_type = CoreLookupType ("System.Runtime.CompilerServices.FixedBufferAttribute");
 		default_charset_type = CoreLookupType ("System.Runtime.InteropServices.DefaultCharSetAttribute");
+		internals_visible_attr_type = CoreLookupType ("System.Runtime.CompilerServices.InternalsVisibleToAttribute");
 		//
 		// When compiling corlib, store the "real" types here.
 		//
Index: ChangeLog
===================================================================
--- ChangeLog	(revisión: 47987)
+++ ChangeLog	(copia de trabajo)
@@ -1,3 +1,9 @@
+2005-08-03  Carlos Alberto Cortez <calberto@gmail.com>
+
+	* codegen.cs
+	(AssemblyClass.CheckAttributeValid): New method to check
+	validity in assembly attributes.
+	
 2005-08-03  Martin Baulig  <martin@ximian.com>
 
 	Make iterators in generic methods work; see gtest-191.cs.
Index: codegen.cs
===================================================================
--- codegen.cs	(revisión: 47987)
+++ codegen.cs	(copia de trabajo)
@@ -1186,6 +1186,42 @@
 			Report.Error (1548, "Error during assembly signing. " + text);
 		}
 
+		void CheckAttributeValidity (Attribute a)
+		{
+			Type t = a.Type;
+			if (t == TypeManager.internals_visible_attr_type) {
+				string [] args = a.GetString ().Trim ().Split (new char [] {','});
+
+				bool is_name_valid = true;
+				bool version = false, culture = false, key_token = false;
+				for (int i = 1; i < args.Length; i++) {
+					string [] values = args [i].Split (new char [] {'='});
+					if (values.Length < 2 || values [1] == String.Empty) {
+						is_name_valid = false;
+						break;
+					}
+
+					if (String.CompareOrdinal (values [0], "Version") == 0)
+						version = true;
+					else if (String.CompareOrdinal (values [0], "Culture") == 0)
+						culture = true;
+					else if (String.CompareOrdinal (values [0], "PublicKeyToken") == 0)
+						key_token = true;
+					// PublicKey is the only valid entry
+					else if (String.CompareOrdinal (values [0], "PublicKey") != 0) {
+						is_name_valid = false;
+						break;
+					}
+				}
+
+				// If the name is invalid, report CS1700
+				if (!is_name_valid || args [0] == "")
+					Report.Warning (1700, 3, a.Location, "Assembly reference '" + a.GetString () + "' is invalid and cannot be resolved");
+				else if (culture || key_token || version)
+					throw new Exception ("Friend assembly '" + a.GetString () + "' is invalid. InternalsVisibleTo cannot have version, culture or key token specified.");
+			}
+		}
+
 		public override void ApplyAttributeBuilder (Attribute a, CustomAttributeBuilder customBuilder)
 		{
 			if (a.Type.IsSubclassOf (TypeManager.security_attr_type) && a.CheckSecurityActionValidity (true)) {
@@ -1196,6 +1232,7 @@
 				return;
 			}
 
+			CheckAttributeValidity (a);
 			Builder.SetCustomAttribute (customBuilder);
 		}
 