Index: System.Threading/Timer.cs
===================================================================
--- System.Threading/Timer.cs	(revision 92431)
+++ System.Threading/Timer.cs	(working copy)
@@ -78,7 +78,7 @@
 					ArrayList expired = null;
 					long ticks = Ticks ();
 					foreach (DictionaryEntry entry in jobs) {
-						Timer t1 = entry.Value as Timer;
+						Timer t1 = (Timer)entry.Value;
 						if (t1.next_run <= ticks) {
 							ThreadPool.QueueUserWorkItem (new WaitCallback (t1.callback), t1.state);
 							if (t1.period_ms == -1 || ((t1.period_ms == 0 | t1.period_ms == Timeout.Infinite) && t1.due_time_ms != Timeout.Infinite)) {
Index: System.Threading/ChangeLog
===================================================================
--- System.Threading/ChangeLog	(revision 92431)
+++ System.Threading/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* Timer.cs (SchedulerThread): Replace "as" with explicit cast, the values in
+	"jobs" are always of type Timer.
+
 2008-01-06  Zoltan Varga  <vargaz@gmail.com>
 
 	* Thread.cs (set_CurrentCulture): If the culture is read-only, cache the result
Index: System/ChangeLog
===================================================================
--- System/ChangeLog	(revision 92431)
+++ System/ChangeLog	(working copy)
@@ -1,3 +1,12 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* Array.cs (Sort): Replace "as" with explicit cast,
+	as we already checked the type with "is". The same goes for
+	int_swapper, obj_swapper, double_swapper, and generic_swapper<T>,
+	as "this" will always have the right type.
+	
+	* String.cs (Equals): Replace "as" with explicit cast (cosmetic change). 
+
 2008-01-06  Zoltan Varga  <vargaz@gmail.com>
 
 	* AppDomain.cs: Move the assembly loading in ExecuteAssembly and 
Index: System/Array.cs
===================================================================
--- System/Array.cs	(revision 92431)
+++ System/Array.cs	(working copy)
@@ -1337,15 +1337,15 @@
 				else 
 					iswapper = get_swapper (items);
 				if (keys is double[]) {
-					combsort (keys as double[], index, length, iswapper);
+					combsort ((double[])keys, index, length, iswapper);
 					return;
 				}
 				if (keys is int[]) {
-					combsort (keys as int[], index, length, iswapper);
+					combsort ((int[])keys, index, length, iswapper);
 					return;
 				}
 				if (keys is char[]) {
-					combsort (keys as char[], index, length, iswapper);
+					combsort ((char[])keys, index, length, iswapper);
 					return;
 				}
 			}
@@ -1361,14 +1361,14 @@
 
 		/* note, these are instance methods */
 		void int_swapper (int i, int j) {
-			int[] array = this as int[];
+			int[] array = (int[])this;
 			int val = array [i];
 			array [i] = array [j];
 			array [j] = val;
 		}
 
 		void obj_swapper (int i, int j) {
-			object[] array = this as object[];
+			object[] array = (object[])this;
 			object val = array [i];
 			array [i] = array [j];
 			array [j] = val;
@@ -1381,7 +1381,7 @@
 		}
 
 		void double_swapper (int i, int j) {
-			double[] array = this as double[];
+			double[] array = (double[])this;
 			double val = array [i];
 			array [i] = array [j];
 			array [j] = val;
@@ -1389,7 +1389,7 @@
 
 #if NET_2_0
 		void generic_swapper<T> (int i, int j) {
-			T[] array = this as T[];
+			T[] array = (T[])this;
 			T val = array [i];
 			array [i] = array [j];
 			array [j] = val;
Index: System/String.cs
===================================================================
--- System/String.cs	(revision 92431)
+++ System/String.cs	(working copy)
@@ -64,7 +64,7 @@
 
 		public static unsafe bool Equals (string a, string b)
 		{
-			if ((a as object) == (b as object))
+			if (((object)a) == ((object)b))
 				return true;
 
 			if (a == null || b == null)
Index: Mono.Globalization.Unicode/create-tailorings.cs
===================================================================
--- Mono.Globalization.Unicode/create-tailorings.cs	(revision 92431)
+++ Mono.Globalization.Unicode/create-tailorings.cs	(working copy)
@@ -277,11 +277,9 @@
 
 		TailoringStore ProcessLdml (XmlDocument doc)
 		{
-			XmlElement langElem = doc.SelectSingleNode (
-				"/ldml/identity/language") as XmlElement;
+			XmlElement langElem = (XmlElement)doc.SelectSingleNode ("/ldml/identity/language");
 			string lang = langElem.GetAttribute ("type");
-			XmlElement terr = doc.SelectSingleNode (
-				"/ldml/identity/territory") as XmlElement;
+			XmlElement terr = (XmlElement)doc.SelectSingleNode ("/ldml/identity/territory");
 			string lcid = lang + (terr != null ?
 				"-" + terr.GetAttribute ("type") : null);
 			TailoringStore ts = null;
@@ -299,8 +297,8 @@
 				return ts;
 			}
 
-			XmlElement collation = doc.SelectSingleNode ("/ldml/collations/collation[@type='standard']") as XmlElement;
-			XmlElement settings = collation.SelectSingleNode ("settings") as XmlElement;
+			XmlElement collation = (XmlElement)doc.SelectSingleNode ("/ldml/collations/collation[@type='standard']");
+			XmlElement settings = (XmlElement)collation.SelectSingleNode ("settings");
 			if (settings != null)
 				ts.FrenchSort = settings.GetAttribute ("backwards") == "on";
 
@@ -326,7 +324,7 @@
 						Console.Error.WriteLine ("WARNING: {0} is not supported for now.", el.FirstChild.LocalName);
 						continue;
 					}
-					XmlElement cpElem = el.SelectSingleNode ("cp") as XmlElement;
+					XmlElement cpElem = (XmlElement)el.SelectSingleNode ("cp");
 					string v = "";
 					if (cpElem != null)
 						v = new string ((char) (int.Parse (
Index: Mono.Globalization.Unicode/ChangeLog
===================================================================
--- Mono.Globalization.Unicode/ChangeLog	(revision 92431)
+++ Mono.Globalization.Unicode/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* create-tailorings.cs, create-normalization-source.cs,
+	create-mscompat-collation-table.cs, MSCompatUnicodeTable.cs:
+	Replace "as" with explicit cast.
+
 2007-07-20  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* create-mscompat-collation-table.cs : I wonder how long its build
Index: Mono.Globalization.Unicode/create-normalization-source.cs
===================================================================
--- Mono.Globalization.Unicode/create-normalization-source.cs	(revision 92431)
+++ Mono.Globalization.Unicode/create-normalization-source.cs	(working copy)
@@ -125,9 +125,8 @@
 				helperIndexes [currentHead] = (short) m.MapIndex;
 			}
 
-			helperIndexes = CodePointIndexer.CompressArray (
-				helperIndexes, typeof (short), NUtil.Helper)
-				as short [];
+			helperIndexes = (short [])CodePointIndexer.CompressArray (
+				helperIndexes, typeof (short), NUtil.Helper);
 
 			COut.WriteLine ("static const guint16 helperIndex [] = {");
 			CSOut.WriteLine ("static short [] helperIndexArr = new short [] {");
Index: Mono.Globalization.Unicode/create-mscompat-collation-table.cs
===================================================================
--- Mono.Globalization.Unicode/create-mscompat-collation-table.cs	(revision 92431)
+++ Mono.Globalization.Unicode/create-mscompat-collation-table.cs	(working copy)
@@ -1767,7 +1767,7 @@
 			decompLength [0x2125] = 1;
 			decompType [0x2125] = DecompositionFont;
 
-			this.decompValues = decompValues.ToArray (typeof (int)) as int [];
+			this.decompValues = (int [])decompValues.ToArray (typeof (int));
 		}
 
 		void ModifyParsedValues ()
@@ -3523,7 +3523,7 @@
 			fillIndex [category] = alphaWeight;
 			AddLetterMap (c, category, 0);
 
-			ArrayList al = latinMap [c] as ArrayList;
+			ArrayList al = (ArrayList)latinMap [c];
 			if (al == null)
 				return;
 
@@ -4530,7 +4530,7 @@
 			ArrayList al = new ArrayList ();
 			foreach (ITailoringMap m in items)
 				al.AddRange (m.ToCharArray ());
-			return al.ToArray (typeof (char)) as char [];
+			return (char [])al.ToArray (typeof (char));
 		}
 
 		interface ITailoringMap
Index: Mono.Globalization.Unicode/MSCompatUnicodeTable.cs
===================================================================
--- Mono.Globalization.Unicode/MSCompatUnicodeTable.cs	(revision 92431)
+++ Mono.Globalization.Unicode/MSCompatUnicodeTable.cs	(working copy)
@@ -221,10 +221,8 @@
 			}
 			cmaps.Sort (ContractionComparer.Instance);
 			dmaps.Sort (Level2MapComparer.Instance);
-			contractions = cmaps.ToArray (typeof (Contraction))
-				as Contraction [];
-			diacriticals = dmaps.ToArray (typeof (Level2Map))
-				as Level2Map [];
+			contractions = (Contraction [])cmaps.ToArray (typeof (Contraction));
+			diacriticals = (Level2Map [])dmaps.ToArray (typeof (Level2Map));
 		}
 
 		static void SetCJKReferences (string name,
Index: System.Collections/ChangeLog
===================================================================
--- System.Collections/ChangeLog	(revision 92431)
+++ System.Collections/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* SortedList.cs (Clone): Remove unnecessary cast with "as".
+
+	* Comparer.cs (Compare): Eliminate "is" check.
+
 2007-11-06  Jb Evain  <jbevain@novell.com>
 
 	* Hashtable.cs: Don't compare user keys against the special removed
Index: System.Collections/SortedList.cs
===================================================================
--- System.Collections/SortedList.cs	(revision 92431)
+++ System.Collections/SortedList.cs	(working copy)
@@ -1140,7 +1140,7 @@
 			public override object Clone ()
 			{
 				lock (host.SyncRoot) {
-					return (host.Clone () as SortedList);
+					return host.Clone ();
 				}
 			}
 
Index: System.Collections/Comparer.cs
===================================================================
--- System.Collections/Comparer.cs	(revision 92431)
+++ System.Collections/Comparer.cs	(working copy)
@@ -87,10 +87,12 @@
 					return m_compareInfo.Compare (sa, sb);
 			}
 
-			if (a is IComparable)
-				return (a as IComparable).CompareTo (b);
-			else if (b is IComparable)
-				return -(b as IComparable).CompareTo (a);
+			IComparable ca = a as IComparable;
+			if (ca != null)
+				return ca.CompareTo (b);
+			IComparable cb = b as IComparable;
+			if (cb != null)
+				return -cb.CompareTo (a);
 
 			throw new ArgumentException (Locale.GetText ("Neither 'a' nor 'b' implements IComparable."));
 		}
Index: Mono.Xml/ChangeLog
===================================================================
--- Mono.Xml/ChangeLog	(revision 92431)
+++ Mono.Xml/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* MiniParser.cs (GetName, GetValue, get_Names, get_Values):
+	Replace "as" with explicit cast (the arrays "names" and "values"
+	only contain strings).
+	Do the same for Clear(), as "tagStack" only contains strings.
+
 2005-11-07  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* SecurityParser.cs : SecurityElement receives raw XML strings for
Index: Mono.Xml/MiniParser.cs
===================================================================
--- Mono.Xml/MiniParser.cs	(revision 92431)
+++ Mono.Xml/MiniParser.cs	(working copy)
@@ -153,7 +153,7 @@
 		public string GetName(int i) {
 			string res = null;
 			if (i >= 0 && i < this.Length) {
-				res = names[i] as string;
+				res = (string)names[i];
 			}
 			return res;
 		}
@@ -161,7 +161,7 @@
 		public string GetValue(int i) {
 			string res = null;
 			if (i >= 0 && i < this.Length) {
-				res = values[i] as string;
+				res = (string)values[i];
 			}
 			return res;
 		}
@@ -178,11 +178,11 @@
 		}
 
 		public string[] Names {
-			get {return names.ToArray(typeof(string)) as string[];}
+			get { return (string [])names.ToArray(typeof(string)); }
 		}
 
 		public string[] Values {
-			get {return values.ToArray(typeof(string)) as string[];}
+			get { return (string [])values.ToArray(typeof(string)); }
 		}
 
 		public void Clear() {
@@ -383,7 +383,7 @@
 					sbChars = new StringBuilder();
 					string endName = null;
 					if (tagStack.Count == 0 ||
-						elementName != (endName = tagStack.Pop() as string)) {
+						elementName != (endName = (string)tagStack.Pop())) {
 						if (endName == null) {
 							FatalErr("Tag stack underflow");
 						} else {
Index: System.Reflection.Emit/ModuleBuilder.cs
===================================================================
--- System.Reflection.Emit/ModuleBuilder.cs	(revision 92431)
+++ System.Reflection.Emit/ModuleBuilder.cs	(working copy)
@@ -386,7 +386,7 @@
 				modifiers = null;
 
 			if (!ignoreCase) {
-				result =  name_cache [className] as TypeBuilder;
+				result = (TypeBuilder)name_cache [className];
 			} else {
 				subt = className.IndexOf ('+');
 				if (subt < 0) {
@@ -406,7 +406,7 @@
 			if (result != null && (modifiers != null)) {
 				Type mt = create_modified_type (result, modifiers);
 				if (mt is TypeBuilder)
-					result = mt as TypeBuilder;
+					result = (TypeBuilder)mt;
 				else
 					return mt;
 			}
@@ -701,7 +701,7 @@
 			if (resources != null) {
 				for (int i = 0; i < resources.Length; ++i) {
 					IResourceWriter rwriter;
-					if (resource_writers != null && (rwriter = resource_writers [resources [i].name] as IResourceWriter) != null) {
+					if (resource_writers != null && (rwriter = (IResourceWriter)resource_writers [resources [i].name]) != null) {
 						ResourceWriter writer = (ResourceWriter)rwriter;
 						writer.Generate ();
 						MemoryStream mstream = (MemoryStream)writer.Stream;
Index: System.Reflection.Emit/ChangeLog
===================================================================
--- System.Reflection.Emit/ChangeLog	(revision 92431)
+++ System.Reflection.Emit/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* ModuleBuilder.cs (GetType): Replace "as" with explicit cast
+	("name_cache" only contains TypeBuilder objects).
+	(Save): Replace "as" with explicit cast ("resource_writers"
+	only contains IResourceWriter objects).
+
 2007-12-31  Gert Driesen  <drieseng@users.sourceforge.net>
 
 	* AssemblyBuilder.cs (UnprotectedGetName): Set the public key token
Index: System.Runtime.Remoting.Channels/ChannelServices.cs
===================================================================
--- System.Runtime.Remoting.Channels/ChannelServices.cs	(revision 92431)
+++ System.Runtime.Remoting.Channels/ChannelServices.cs	(working copy)
@@ -316,7 +316,7 @@
 			// Create server providers
 			for (int n=channel.ServerProviders.Count-1; n>=0; n--)
 			{
-				ProviderData prov = channel.ServerProviders[n] as ProviderData;
+				ProviderData prov = (ProviderData)channel.ServerProviders[n];
 				IServerChannelSinkProvider sinkp = (IServerChannelSinkProvider) CreateProvider (prov);
 				sinkp.Next = serverSinks;
 				serverSinks = sinkp;
@@ -325,7 +325,7 @@
 			// Create client providers
 			for (int n=channel.ClientProviders.Count-1; n>=0; n--)
 			{
-				ProviderData prov = channel.ClientProviders[n] as ProviderData;
+				ProviderData prov = (ProviderData)channel.ClientProviders[n];
 				IClientChannelSinkProvider sinkp = (IClientChannelSinkProvider) CreateProvider (prov);
 				sinkp.Next = clientSinks;
 				clientSinks = sinkp;
Index: System.Runtime.Remoting.Channels/BaseChannelObjectWithProperties.cs
===================================================================
--- System.Runtime.Remoting.Channels/BaseChannelObjectWithProperties.cs	(revision 92431)
+++ System.Runtime.Remoting.Channels/BaseChannelObjectWithProperties.cs	(working copy)
@@ -89,7 +89,7 @@
 
 		public virtual IDictionary Properties
 		{
-			get { return this as IDictionary; }
+			get { return this; }
 		}
 
 		public virtual object SyncRoot
Index: System.Runtime.Remoting.Channels/ChangeLog
===================================================================
--- System.Runtime.Remoting.Channels/ChangeLog	(revision 92431)
+++ System.Runtime.Remoting.Channels/ChangeLog	(working copy)
@@ -1,3 +1,11 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* ChannelServices.cs: Replace "as" with explicit cast (the accessed
+	arrays only contain ProviderData objects).
+
+	* BaseChannelObjectWithProperties.cs (get_Properties):
+	Remove unnecessary "as".
+
 2007-08-22  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* ChannelServices.cs : implement ensureSecurity support in
Index: System.Collections.ObjectModel/Collection.cs
===================================================================
--- System.Collections.ObjectModel/Collection.cs	(revision 92431)
+++ System.Collections.ObjectModel/Collection.cs	(working copy)
@@ -51,10 +51,8 @@
 		
 		public Collection ()
 		{
-			List <T> l = new List <T> ();
-			IList l2 = l as IList;
-			syncRoot = l2.SyncRoot;
-			list = l;
+			list = new List <T> ();
+			syncRoot = ((IList)list).SyncRoot;
 		}
 
 		public Collection (IList <T> list)
Index: System.Collections.ObjectModel/ChangeLog
===================================================================
--- System.Collections.ObjectModel/ChangeLog	(revision 92431)
+++ System.Collections.ObjectModel/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* Collection.cs (.ctor): Replace "as" with explicit cast, as List <T>
+	always implements IList.
+
 2006-08-08  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* ReadOnlyCollection.cs : added get_IList<T>.this(int).
Index: System.Text/EncoderExceptionFallback.cs
===================================================================
--- System.Text/EncoderExceptionFallback.cs	(revision 92431)
+++ System.Text/EncoderExceptionFallback.cs	(working copy)
@@ -49,7 +49,7 @@
 
 		public override bool Equals (object value)
 		{
-			return value as EncoderExceptionFallback != null;
+			return (value is EncoderExceptionFallback);
 		}
 
 		public override int GetHashCode ()
Index: System.Text/ChangeLog
===================================================================
--- System.Text/ChangeLog	(revision 92431)
+++ System.Text/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* Encoding.cs (GetEncoding): Replace "as" with explicit cast.
+
+	* EncoderExceptionFallback.cs (Equals),
+	DecoderExceptionFallback.cs (Equals): Reduce ".. as .. != null" to "is".
+	
 2007-12-27  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* DecoderFallback.cs, EncoderFallback.cs, Encoding.cs :
Index: System.Text/Encoding.cs
===================================================================
--- System.Text/Encoding.cs	(revision 92431)
+++ System.Text/Encoding.cs	(working copy)
@@ -533,7 +533,7 @@
 		if (decoderFallback == null)
 			throw new ArgumentNullException ("decoderFallback");
 
-		Encoding e = GetEncoding (codePage).Clone () as Encoding;
+		Encoding e = (Encoding)GetEncoding (codePage).Clone ();
 		e.is_readonly = false;
 		e.encoder_fallback = encoderFallback;
 		e.decoder_fallback = decoderFallback;
@@ -548,7 +548,7 @@
 		if (decoderFallback == null)
 			throw new ArgumentNullException ("decoderFallback");
 
-		Encoding e = GetEncoding (name).Clone () as Encoding;
+		Encoding e = (Encoding)GetEncoding (name).Clone ();
 		e.is_readonly = false;
 		e.encoder_fallback = encoderFallback;
 		e.decoder_fallback = decoderFallback;
Index: System.Text/DecoderExceptionFallback.cs
===================================================================
--- System.Text/DecoderExceptionFallback.cs	(revision 92431)
+++ System.Text/DecoderExceptionFallback.cs	(working copy)
@@ -49,7 +49,7 @@
 
 		public override bool Equals (object value)
 		{
-			return value as DecoderExceptionFallback != null;
+			return (value is DecoderExceptionFallback);
 		}
 
 		public override int GetHashCode ()
Index: System.Runtime.Remoting.Proxies/ChangeLog
===================================================================
--- System.Runtime.Remoting.Proxies/ChangeLog	(revision 92431)
+++ System.Runtime.Remoting.Proxies/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* RealProxy.cs (PrivateInvoke): Optimize by eliminating two "as" casts.
+
 2007-05-03  Dick Porter  <dick@ximian.com>
 
 	* ProxyAttribute.cs: 
Index: System.Runtime.Remoting.Proxies/RealProxy.cs
===================================================================
--- System.Runtime.Remoting.Proxies/RealProxy.cs	(revision 92431)
+++ System.Runtime.Remoting.Proxies/RealProxy.cs	(working copy)
@@ -162,7 +162,7 @@
 			MonoMethodMessage mMsg = (MonoMethodMessage) msg;
 			mMsg.LogicalCallContext = CallContext.CreateLogicalCallContext (true);
 			CallType call_type = mMsg.CallType;
-			bool is_remproxy = (rp as RemotingProxy) != null;
+			RemotingProxy remproxy = (rp as RemotingProxy);
 
 			IMethodReturnMessage res_msg = null;
 			
@@ -176,8 +176,8 @@
 			// Check for constructor msg
 			if (mMsg.MethodBase.IsConstructor) 
 			{
-				if (is_remproxy) 
-					res_msg = (IMethodReturnMessage) (rp as RemotingProxy).ActivateRemoteObject ((IMethodMessage) msg);
+				if (remproxy != null) 
+					res_msg = (IMethodReturnMessage)remproxy.ActivateRemoteObject ((IMethodMessage) msg);
 				else 
 					msg = new ConstructionCall (rp.GetProxiedType ());
 			}
@@ -190,12 +190,12 @@
 				// checking if it was a remoting or custom proxy, but in some
 				// cases the remoting proxy finish before the call returns
 				// causing this method to be called, therefore causing all kind of bugs.
-				if ((!is_remproxy) && call_type == CallType.BeginInvoke)
+				if ((remproxy == null) && call_type == CallType.BeginInvoke)
 				{
 					IMessage asyncMsg = null;
 
 					// allow calltype EndInvoke to finish
-					asyncMsg = mMsg.AsyncResult.SyncProcessMessage (res_msg as IMessage);
+					asyncMsg = mMsg.AsyncResult.SyncProcessMessage (res_msg);
 					res_msg = new ReturnMessage (asyncMsg, null, 0, null, res_msg as IMethodCallMessage);
 				}
 			}
Index: System.Runtime.Remoting.Lifetime/ClientSponsor.cs
===================================================================
--- System.Runtime.Remoting.Lifetime/ClientSponsor.cs	(revision 92431)
+++ System.Runtime.Remoting.Lifetime/ClientSponsor.cs	(working copy)
@@ -68,7 +68,7 @@
 		{
 			foreach (MarshalByRefObject obj in registered_objects.Values)
 			{
-				ILease lease = obj.GetLifetimeService () as ILease;
+				ILease lease = (ILease)obj.GetLifetimeService ();
 				lease.Unregister (this);
 			}
 			registered_objects.Clear ();
@@ -102,7 +102,7 @@
 		public void Unregister (MarshalByRefObject obj)
 		{
 			if (!registered_objects.ContainsKey (obj)) return;
-			ILease lease = obj.GetLifetimeService () as ILease;
+			ILease lease = (ILease)obj.GetLifetimeService ();
 			lease.Unregister (this);
 			registered_objects.Remove (obj);
 		}
Index: System.Runtime.Remoting.Lifetime/ChangeLog
===================================================================
--- System.Runtime.Remoting.Lifetime/ChangeLog	(revision 92431)
+++ System.Runtime.Remoting.Lifetime/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* ClientSponsor.cs (Close, Unregister): Replace "as" with explicit cast,
+	on the next line, we're calling a method on the casted object.
+
 2006-01-31  Lluis Sanchez Gual  <lluis@novell.com>
 
 	* Lease.cs: Fixed double check lock.
Index: System.Runtime.Remoting/RemotingConfiguration.cs
===================================================================
--- System.Runtime.Remoting/RemotingConfiguration.cs	(revision 92431)
+++ System.Runtime.Remoting/RemotingConfiguration.cs	(working copy)
@@ -223,7 +223,7 @@
 		{
 			lock (channelTemplates)
 			{
-				return activatedClientEntries [serviceType] as ActivatedClientTypeEntry;
+				return (ActivatedClientTypeEntry)activatedClientEntries [serviceType];
 			}
 		}
 
@@ -236,7 +236,7 @@
 		{
 			lock (channelTemplates)
 			{
-				return wellKnownClientEntries [serviceType] as WellKnownClientTypeEntry;
+				return (WellKnownClientTypeEntry)wellKnownClientEntries [serviceType];
 			}
 		}
 
Index: System.Runtime.Remoting/ChangeLog
===================================================================
--- System.Runtime.Remoting/ChangeLog	(revision 92431)
+++ System.Runtime.Remoting/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2008-01-08  Juraj Skripsky  <js@hotfeet.ch>
+
+	* RemotingConfiguration.cs, InternalRemotingServices.cs,
+	RemotingServices.cs: Replace "as" with explicit casts (the cast object
+	will always have the right type).
+
 2008-01-07  Sebastien Pouliot  <sebastien@ximian.com>
 
 	* Identity.cs: Fix Disposed setter to use value (not true). Found 
Index: System.Runtime.Remoting/InternalRemotingServices.cs
===================================================================
--- System.Runtime.Remoting/InternalRemotingServices.cs	(revision 92431)
+++ System.Runtime.Remoting/InternalRemotingServices.cs	(working copy)
@@ -60,7 +60,7 @@
 		public static SoapAttribute GetCachedSoapAttribute (object reflectionObject)
 		{			
 			lock (_soapAttributes.SyncRoot) {
-				SoapAttribute att = _soapAttributes [reflectionObject] as SoapAttribute;
+				SoapAttribute att = (SoapAttribute)_soapAttributes [reflectionObject];
 				if (att != null) return att;
 				
 				ICustomAttributeProvider ap = (ICustomAttributeProvider) reflectionObject;
Index: System.Runtime.Remoting/RemotingServices.cs
===================================================================
--- System.Runtime.Remoting/RemotingServices.cs	(revision 92431)
+++ System.Runtime.Remoting/RemotingServices.cs	(working copy)
@@ -220,7 +220,7 @@
 
 				RealProxy proxy = GetRealProxy(obj);
 				if (proxy.GetProxiedType().IsContextful && (proxy.ObjectIdentity is ServerIdentity))
-					identity = proxy.ObjectIdentity as ServerIdentity;
+					identity = (ServerIdentity)proxy.ObjectIdentity;
 				else
 					throw new ArgumentException ("The obj parameter is a proxy.");
 			}
