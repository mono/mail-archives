Index: configure.ac
===================================================================
--- configure.ac	(revision 155252)
+++ configure.ac	(working copy)
@@ -234,6 +234,7 @@
 perf/Makefile
 sdk/Makefile
 generators/Makefile
+xbuild/Makefile
 ])
 
 # general configuration info
Index: xbuild/Microsoft.Silverlight.Common.targets
===================================================================
--- xbuild/Microsoft.Silverlight.Common.targets	(revision 0)
+++ xbuild/Microsoft.Silverlight.Common.targets	(revision 0)
@@ -0,0 +1,141 @@
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+	<UsingTask TaskName="Moonlight.MSBuild.XamlG" AssemblyFile="Moonlight.MSBuild.dll"/>
+	<UsingTask TaskName="Moonlight.MSBuild.GetMoonlightFrameworkPath" AssemblyFile="Moonlight.MSBuild.dll"/>
+	<UsingTask TaskName="Moonlight.MSBuild.Respack" AssemblyFile="Moonlight.MSBuild.dll" />
+	<UsingTask TaskName="Moonlight.MSBuild.GenerateMoonlightManifest" AssemblyFile="Moonlight.MSBuild.dll"/>
+	<UsingTask TaskName="Moonlight.MSBuild.GenerateXap" AssemblyFile="Moonlight.MSBuild.dll" />
+	<UsingTask TaskName="Moonlight.MSBuild.CreateTestPage" AssemblyFile="Moonlight.MSBuild.dll" />
+
+	<PropertyGroup>
+		<PrepareResourcesDependsOn>
+			GenerateXamlG;
+			Respack;
+			$(PrepareResourcesDependsOn)
+		</PrepareResourcesDependsOn>
+
+		<PrepareForRunDependsOn>
+			GenerateMoonlightManifest;
+			GenerateXap;
+			CreateTestPage;
+			$(PrepareForRunDependsOn)
+		</PrepareForRunDependsOn>
+
+		<CscToolExe Condition="'$(OS)' == 'Windows_NT'">smcs.bat</CscToolExe>
+		<CscToolExe Condition="'$(OS)' != 'Windows_NT'">smcs</CscToolExe>
+
+		<XapFileName Condition="'$(XapFileName)' == ''">$(AssemblyName).xap</XapFileName>
+		<TestPageFileName Condition="'$(TestPageFileName)' == ''">TestPage.html</TestPageFileName>
+	</PropertyGroup>
+
+	<ItemGroup>
+		<MoonlightManifestFile Include="$(OutDir)AppManifest.xaml">
+			<TargetPath>AppManifest.xaml</TargetPath>
+		</MoonlightManifestFile>
+	</ItemGroup>
+
+	<!-- Override 'GetFrameworkPaths' -->
+	<Target Name="GetFrameworkPaths">
+		<Message Text="GetFrameworkPaths in silverlight!"/>
+		<GetMoonlightFrameworkPath>
+			<Output TaskParameter="FrameworkVersion20Path" ItemName="TargetFrameworkDirectories"/>
+			<Output TaskParameter="FrameworkVersion20Path" ItemName="_FrameworkPath"/>
+		</GetMoonlightFrameworkPath>
+
+		<!-- HACK: system.xml.linq is in 2.0-redist, should this be used for resolution? -->
+		<CreateProperty Value="$(AssemblySearchPaths);@(_FrameworkPath->'%(Identity)-redist')">
+			<Output TaskParameter="Value" PropertyName="AssemblySearchPaths"/>
+		</CreateProperty>
+	</Target>
+
+	<Target Name="Respack">
+		<Respack
+			Resources="@(Resource);@(Page);@(ApplicationDefinition)"
+			OutputFile="$(IntermediateOutputPath)$(AssemblyName).g.resources">
+			<Output TaskParameter="OutputFile" ItemName="FileWrites"/>
+			<Output TaskParameter="OutputFile" ItemName="ManifestResourceWithNoCulture"/>
+		</Respack>
+	</Target>
+
+	<Target Name="GenerateXamlG">
+		<CreateItem Include="@(Compile)" Condition="'%(Compile.Extension)' == '.xaml' and '%(Compile.Generator)' == 'MSBuild:MarkupCompilePass1'">
+			<Output TaskParameter="Include" ItemName="XamlFiles"/>
+		</CreateItem>
+		<CreateItem Include="@(ApplicationDefinition)" Condition="'%(Extension)' == '.xaml' and '%(Generator)' == 'MSBuild:MarkupCompilePass1'">
+			<Output TaskParameter="Include" ItemName="XamlFiles"/>
+		</CreateItem>
+		<CreateItem Include="@(Page)" Condition="'%(Extension)' == '.xaml' and '%(Generator)' == 'MSBuild:MarkupCompilePass1'">
+			<Output TaskParameter="Include" ItemName="XamlFiles"/>
+		</CreateItem>
+
+		<!-- FIXME: make this work for cs/vb/etc.. -->
+		<XamlG
+			Sources="@(XamlFiles)"
+			Language = "$(Language)"
+			AssemblyName = "$(AssemblyName)"
+			OutputFiles = "@(XamlFiles->'$(IntermediateOutputPath)%(Filename).g$(DefaultLanguageSourceExtension)')"
+		>
+			<Output TaskParameter="OutputFiles" ItemName="Compile"/>
+			<!-- FIXME: should this have only the files generated this time.. or all possible generated files? -->
+			<Output TaskParameter="OutputFiles" ItemName="FileWrites"/>
+		</XamlG>
+	</Target>
+
+	<Target Name="GenerateMoonlightManifest">
+		<GenerateMoonlightManifest
+			ManifestFile="@(MoonlightManifestFile->'%(Identity)')"
+			EntryPointAssembly="$(AssemblyName)$(TargetExt)"
+			References="@(ReferenceCopyLocalPaths)"
+			SilverlightManifestTemplate="$(SilverlightManifestTemplate)"
+			SilverlightAppEntry="$(SilverlightAppEntry)"
+
+			Condition = "'$(GenerateSilverlightManifest)' == 'true'"
+		>
+			<Output TaskParameter="ManifestFile" ItemName="FileWrites"/>
+		</GenerateMoonlightManifest>
+	</Target>
+
+	<PropertyGroup>
+		<GenerateXapDependsOn>
+			GenerateXamlG;
+			GenerateMoonlightManifest;
+			GetXapInputFiles
+		</GenerateXapDependsOn>
+	</PropertyGroup>
+	<Target Name="GenerateXap" DependsOnTargets="$(GenerateXapDependsOn)" Condition="'$(XapOutputs)' == 'true'">
+		<GenerateXap
+			InputFiles="@(XapInputFiles)"
+			LocalCopyReferences="@(ReferenceCopyLocalPaths)"
+			XapFilename="$(OutDir)$(XapFilename)"
+		>
+			<Output TaskParameter="XapFilename" ItemName="FileWrites"/>
+		</GenerateXap>
+	</Target>
+
+	<Target Name="CreateTestPage" Condition="'$(CreateTestPage)' == 'true' and '$(XapOutputs)' == 'true'">
+		<CreateTestPage
+			XapFileName="$(XapFileName)"
+			Title="$(AssemblyName)"
+			TestPageFilename="$(OutDir)$(TestPageFilename)">
+			<Output TaskParameter="TestPageFilename" ItemName="FileWrites"/>
+		</CreateTestPage>
+	</Target>
+
+	<Target Name="GetXapInputFiles">
+		<CreateItem Include="@(IntermediateAssembly)" AdditionalMetadata="TargetPath=$(AssemblyName)$(TargetExt)">
+			<Output TaskParameter="Include" ItemName="XapInputFiles"/>
+		</CreateItem>
+
+		<CreateItem Include="@(ContentWithTargetPath)">
+			<Output TaskParameter="Include" ItemName="XapInputFiles"/>
+		</CreateItem>
+
+		<CreateItem Include="@(MoonlightManifestFile)" Condition="'$(GenerateSilverlightManifest)' == 'true'">
+			<Output TaskParameter="Include" ItemName="XapInputFiles"/>
+		</CreateItem>
+
+		<CreateItem Include="$(IntermediateOutputPath)$(AssemblyName)$(TargetExt).mdb" AdditionalMetadata="TargetPath=$(AssemblyName)$(TargetExt).mdb"
+				Condition="Exists('$(IntermediateOutputPath)$(AssemblyName)$(TargetExt).mdb')">
+			<Output TaskParameter="Include" ItemName="XapInputFiles"/>
+		</CreateItem>
+	</Target>
+</Project>
Index: xbuild/PreviewTemplate.html
===================================================================
--- xbuild/PreviewTemplate.html	(revision 0)
+++ xbuild/PreviewTemplate.html	(revision 0)
@@ -0,0 +1,76 @@
+ï»¿<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" >
+<head>
+    <title>@TITLE@</title>
+
+    <style type="text/css">
+    html, body {
+	    height: 100%;
+	    overflow: auto;
+    }
+    body {
+	    padding: 0;
+	    margin: 0;
+    }
+    #silverlightControlHost {
+	    height: 100%;
+    }
+    </style>
+    
+    <script type="text/javascript">
+        function onSilverlightError(sender, args) {
+        
+            var appSource = "";
+            if (sender != null && sender != 0) {
+                appSource = sender.getHost().Source;
+            } 
+            var errorType = args.ErrorType;
+            var iErrorCode = args.ErrorCode;
+            
+            var errMsg = "Unhandled Error in Silverlight 2 Application " +  appSource + "\n" ;
+
+            errMsg += "Code: "+ iErrorCode + "    \n";
+            errMsg += "Category: " + errorType + "       \n";
+            errMsg += "Message: " + args.ErrorMessage + "     \n";
+
+            if (errorType == "ParserError")
+            {
+                errMsg += "File: " + args.xamlFile + "     \n";
+                errMsg += "Line: " + args.lineNumber + "     \n";
+                errMsg += "Position: " + args.charPosition + "     \n";
+            }
+            else if (errorType == "RuntimeError")
+            {           
+                if (args.lineNumber != 0)
+                {
+                    errMsg += "Line: " + args.lineNumber + "     \n";
+                    errMsg += "Position: " +  args.charPosition + "     \n";
+                }
+                errMsg += "MethodName: " + args.methodName + "     \n";
+            }
+
+            throw new Error(errMsg);
+        }
+    </script>
+</head>
+
+<body>
+    <!-- Runtime errors from Silverlight will be displayed here.
+	This will contain debugging information and should be removed or hidden when debugging is completed -->
+	<div id='errorLocation' style="font-size: small;color: Gray;"></div>
+
+    <div id="silverlightControlHost">
+		<object data="data:application/x-silverlight," type="application/x-silverlight-2" width="100%" height="100%">
+			<param name="source" value="@XAP_FILE@"/>
+			<param name="onerror" value="onSilverlightError" />
+			<param name="background" value="white" />
+			<param name="minRuntimeVersion" value="2.0.31005.0" />
+			<param name="autoUpgrade" value="true" />
+			<a href="http://go.microsoft.com/fwlink/?LinkID=124807" style="text-decoration: none;">
+     			<img src="http://go.microsoft.com/fwlink/?LinkId=108181" alt="Get Microsoft Silverlight" style="border-style: none"/>
+			</a>
+		</object>
+		<iframe style='visibility:hidden;height:0;width:0;border:0px'></iframe>
+    </div>
+</body>
+</html>
Index: xbuild/tasks/GetMoonlightFrameworkPath.cs
===================================================================
--- xbuild/tasks/GetMoonlightFrameworkPath.cs	(revision 0)
+++ xbuild/tasks/GetMoonlightFrameworkPath.cs	(revision 0)
@@ -0,0 +1,91 @@
+//
+// GetMoonlightFrameworkPath.cs: Task that gets path to framework.
+//
+// Author:
+//	Michael Hutchinson <mhutchinson@novell.com>
+//	Ankit Jain <jankit@novell.com>
+//
+// Copyright (c) 2009 Novell, Inc. (http://www.novell.com)
+// Copyright (c) 2010 Novell, Inc. (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+using SI = System.IO;
+
+using System;
+using System.Text;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+namespace Moonlight.MSBuild {
+	public class GetMoonlightFrameworkPath : Task {
+		
+		string	path;
+	
+		public override bool Execute ()
+		{
+			//FIXME: hardcoding for 2.0, whats the better way to do this? :/
+			// how is the version specified in the project file?
+			path = SI.Path.Combine (ToolLocationHelper.GetPathToDotNetFramework (TargetDotNetFrameworkVersion.Version20),
+					SI.Path.Combine ("..", SI.Path.Combine ("moonlight", "2.0")));
+			return true;
+		}
+
+		[Output]
+		public string Path {
+			get {
+				return path;
+			}
+			set {
+				path = value;
+			}
+		}
+
+		[Output]
+		public string FrameworkVersion20Path {
+			get {
+				return SI.Path.GetFullPath (
+						PathCombine (ToolLocationHelper.GetPathToDotNetFramework (TargetDotNetFrameworkVersion.Version20),
+						"..", "..", "moonlight", "2.0"));
+			}
+		}
+
+		[Output]
+		public string FrameworkVersion30Path {
+			get {
+				return SI.Path.Combine (ToolLocationHelper.GetPathToDotNetFramework (TargetDotNetFrameworkVersion.Version20),
+					SI.Path.Combine ("..", SI.Path.Combine ("moonlight", "3.0")));
+			}
+		}
+
+		static string PathCombine (string path1, params string[] parts)
+		{
+			StringBuilder sb = new StringBuilder ();
+			sb.Append (path1);
+			foreach (string part in parts)
+				sb.AppendFormat ("{0}{1}", SI.Path.DirectorySeparatorChar, part);
+
+			return sb.ToString ();
+		}
+
+
+	}
+}
Index: xbuild/tasks/CreateTestPage.cs
===================================================================
--- xbuild/tasks/CreateTestPage.cs	(revision 0)
+++ xbuild/tasks/CreateTestPage.cs	(revision 0)
@@ -0,0 +1,79 @@
+//
+// CreateTestPage.cs: Task that gets path to framework.
+//
+// Author:
+//	Michael Hutchinson <mhutchinson@novell.com>
+//	Ankit Jain <jankit@novell.com>
+//
+// Copyright (c) 2009 Novell, Inc. (http://www.novell.com)
+// Copyright (c) 2010 Novell, Inc. (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+using System;
+using System.IO;
+using System.Reflection;
+using System.Text;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+namespace Moonlight.MSBuild {
+	public class CreateTestPage : Task {
+		
+		public override bool Execute ()
+		{
+			Log.LogMessage (MessageImportance.Low, "Generating test page {0}", XapFilename);
+
+			var sb = new StringBuilder ();
+			using (var sr = new StreamReader (Assembly.GetExecutingAssembly ().GetManifestResourceStream ("PreviewTemplate.html")))
+				sb.Append (sr.ReadToEnd ());
+
+			sb.Replace ("@TITLE@", Title);
+			sb.Replace ("@XAP_FILE@", XapFilename);
+
+			try{
+				File.WriteAllText (TestPageFilename, sb.ToString ());
+			} catch (IOException e) {
+				Log.LogError (String.Format (
+						"Error generating test page file {0}: {1}", TestPageFilename, e.Message));
+				return false;
+			}
+
+			return true;
+		}
+
+		[Required]
+		public string XapFilename {
+			get; set;
+		}
+
+		[Required]
+		public string Title {
+			get; set;
+		}
+
+		[Required]
+		[Output]
+		public string TestPageFilename {
+			get; set;
+		}
+	}
+}
Index: xbuild/tasks/GenerateMoonlightManifest.cs
===================================================================
--- xbuild/tasks/GenerateMoonlightManifest.cs	(revision 0)
+++ xbuild/tasks/GenerateMoonlightManifest.cs	(revision 0)
@@ -0,0 +1,198 @@
+//
+// GenerateMoonlightManifest.cs: Task that can copy files
+//
+// Author:
+//	Michael Hutchinson <mhutchinson@novell.com>
+//	Ankit Jain <jankit@novell.com>
+//
+// Copyright (c) 2009 Novell, Inc. (http://www.novell.com)
+// Copyright (c) 2010 Novell, Inc. (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.CodeDom;
+using System.CodeDom.Compiler;
+using System.Xml;
+
+using Microsoft.CSharp;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+namespace Moonlight.MSBuild {
+	public class GenerateMoonlightManifest : Task {
+	
+		public override bool Execute ()
+		{
+			//FIXME: validate params here..
+
+			return GenerateManifest ();
+		}
+
+		bool GenerateManifest ()
+		{
+			const string depNS = "http://schemas.microsoft.com/client/2007/deployment";
+			
+
+			string template = null;
+			var manifest = ManifestFile.ItemSpec;
+			Log.LogMessage (MessageImportance.Normal, "Generating manifest file {0}", manifest);
+
+			if (SilverlightManifestTemplate != null)
+				template = String.IsNullOrEmpty (SilverlightManifestTemplate.ItemSpec) ?
+							null :
+							SilverlightManifestTemplate.GetMetadata ("FullPath");
+
+			XmlDocument doc = new XmlDocument ();
+			if (template != null) {
+				if (!File.Exists (template)) {
+					Log.LogError ("Could not find manifest template '" +  template + "'.");
+					return false;
+				}
+
+				try {
+					doc.Load (template);
+				} catch (XmlException ex) {
+					Log.LogError (null, null, null, template, ex.LineNumber, ex.LinePosition, 0, 0,
+							"Error loading manifest template '" + ex.Source);
+					return false;
+				} catch (Exception ex) {
+					Log.LogError ("Could not load manifest template '" +  template + "'.");
+					Log.LogMessage (MessageImportance.Low, "Could not load manifest template '" +  template + "': " + ex.ToString ());
+					return false;
+				}
+
+			} else {
+				doc.LoadXml (@"<Deployment xmlns=""http://schemas.microsoft.com/client/2007/deployment"" xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""></Deployment>");
+			}
+			
+			try {
+				XmlNode deploymentNode = doc.DocumentElement;
+				if (deploymentNode == null || deploymentNode.Name != "Deployment" || deploymentNode.NamespaceURI != depNS) {
+					Log.LogError ("Missing or invalid root <Deployment> element in manifest template '" +  template + "'.");
+					return false;
+				}
+				if (deploymentNode.Attributes["EntryPointAssembly"] == null)
+					deploymentNode.Attributes.Append (doc.CreateAttribute ("EntryPointAssembly")).Value =
+						EntryPointAssembly.GetMetadata ("Filename");
+
+				if (!String.IsNullOrEmpty (SilverlightAppEntry) && deploymentNode.Attributes["EntryPointType"] == null)
+					deploymentNode.Attributes.Append (doc.CreateAttribute ("EntryPointType")).Value = SilverlightAppEntry;
+
+				if (deploymentNode.Attributes["RuntimeVersion"] == null) {
+					string runtimeVersion = null;
+					//FIXME:
+					/*string fxVersion = MoonlightFrameworkBackend.GetFxVersion (proj.TargetFramework);
+					
+					if (proj.TargetRuntime is MonoDevelop.Core.Assemblies.MonoTargetRuntime) {
+						var package = proj.TargetRuntime.RuntimeAssemblyContext.GetPackage ("moonlight-web-" + fxVersion);
+						if (package != null && package.IsFrameworkPackage) {
+							runtimeVersion = package.Version;
+						} else {
+							LoggingService.LogWarning ("Moonlight core framework package not found, cannot determine " +
+								"runtime version string. Falling back to default value.");
+						}
+					}*/
+					
+					if (runtimeVersion == null) {
+						//FIXME how will we determine this for other runtimes?
+						runtimeVersion = "2.0.31005.0";
+					}
+					
+					deploymentNode.Attributes.Append (doc.CreateAttribute ("RuntimeVersion")).Value = runtimeVersion;
+				}
+
+				XmlNamespaceManager mgr = new XmlNamespaceManager (doc.NameTable);
+				mgr.AddNamespace ("dep", depNS);
+				XmlNode partsNode = deploymentNode.SelectSingleNode ("dep:Deployment.Parts", mgr);
+				if (partsNode == null)
+					partsNode = deploymentNode.AppendChild (doc.CreateElement ("Deployment.Parts", depNS));
+
+				AddAssemblyPart (doc, partsNode, EntryPointAssembly);
+
+				foreach (ITaskItem ref_item in References)
+					AddAssemblyPart (doc, partsNode, ref_item);
+			} catch (XmlException ex) {
+				Log.LogError (null, null, null, template, ex.LineNumber, ex.LinePosition, 0, 0,
+						"Error processing manifest template: '" + ex.Source);
+				return false;
+			}
+			
+			doc.Save (manifest);
+
+			return true;
+		}
+		
+		static void AddAssemblyPart (XmlDocument doc, XmlNode partsNode, ITaskItem filename)
+		{
+			XmlNode child = doc.CreateElement ("AssemblyPart", "http://schemas.microsoft.com/client/2007/deployment");
+			child.Attributes.Append (doc.CreateAttribute (
+						"Name", "http://schemas.microsoft.com/winfx/2006/xaml")).Value = filename.GetMetadata ("Filename");
+			child.Attributes.Append (doc.CreateAttribute ("Source")).Value = filename.ItemSpec;
+			partsNode.AppendChild (child);
+		}
+
+
+		[Required]
+		[Output]
+		public ITaskItem ManifestFile {
+			get; set;
+		}
+
+		[Required]
+		// with extension
+		public ITaskItem EntryPointAssembly {
+			get; set;
+		}
+
+		[Required]
+		public ITaskItem[] References {
+			get; set;
+		}
+
+		public ITaskItem SilverlightManifestTemplate {
+			get; set;
+		}
+
+		public string SilverlightAppEntry {
+			get; set;
+		}
+
+
+		bool HasFileChanged (string source, string dest)
+		{
+			if (!File.Exists (dest))
+				return true;
+
+			FileInfo sourceInfo = new FileInfo (source);
+			FileInfo destinationInfo = new FileInfo (dest);
+
+			return !(sourceInfo.Length == destinationInfo.Length &&
+					File.GetLastWriteTime(source) <= File.GetLastWriteTime (dest));
+		}
+
+	}
+	
+
+}
Index: xbuild/tasks/GenerateXap.cs
===================================================================
--- xbuild/tasks/GenerateXap.cs	(revision 0)
+++ xbuild/tasks/GenerateXap.cs	(revision 0)
@@ -0,0 +1,141 @@
+//
+// GenerateXap.cs: Task that can copy files
+//
+// Author:
+//	Michael Hutchinson <mhutchinson@novell.com>
+//	Ankit Jain <jankit@novell.com>
+//
+// Copyright (c) 2009 Novell, Inc. (http://www.novell.com)
+// Copyright (c) 2010 Novell, Inc. (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.CodeDom;
+using System.CodeDom.Compiler;
+using System.Xml;
+
+using Microsoft.CSharp;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+namespace Moonlight.MSBuild {
+	public class GenerateXap : Task {
+	
+		public override bool Execute ()
+		{
+			if (InputFiles.Length == 0)
+				return true;
+
+			return Zip ();
+		}
+
+		bool Zip ()
+		{
+			var xapName = XapFilename.ItemSpec;
+			if (File.Exists (xapName)) {
+				DateTime lastMod = File.GetLastWriteTime (xapName);
+				bool needsWrite = false;
+				foreach (ITaskItem file_item in InputFiles) {
+					if (File.GetLastWriteTime (file_item.ItemSpec) > lastMod) {
+						needsWrite = true;
+						break;
+					}
+				}
+				if (!needsWrite) {
+					Log.LogMessage (MessageImportance.Low, "Skipping xap file {0} generation, its up-to date");
+					return true;
+				}
+			}
+			
+			Log.LogMessage (MessageImportance.Normal, "Generating compressed xap file {0}", xapName);
+			try {
+				using (FileStream fs = new FileStream (xapName, FileMode.Create)) {
+					var zip_stream = new ICSharpCode.SharpZipLib.Zip.ZipOutputStream (fs);
+					zip_stream.SetLevel (9);
+
+					AddFilesToZip (InputFiles, zip_stream);
+					AddFilesToZip (LocalCopyReferences, zip_stream);
+					
+					zip_stream.Finish ();
+					zip_stream.Close ();
+				}
+			} catch (IOException ex) {
+				Log.LogError ("Error writing xap file.", ex);
+				Log.LogMessage (MessageImportance.Low, "Error writing xap file:" + ex.ToString ());
+				
+				try {
+					if (File.Exists (xapName))                                                               
+						File.Delete (xapName);
+				} catch {}
+				
+				return false;
+			}
+			
+			return true;
+		}
+		
+		
+		void AddFilesToZip (ITaskItem [] files, ICSharpCode.SharpZipLib.Zip.ZipOutputStream zipStream)
+		{
+			if (files == null)
+				return;
+
+			foreach (ITaskItem item in files) {
+				string target_path = item.GetMetadata ("TargetPath");
+				if (String.IsNullOrEmpty (target_path))
+					target_path = Path.GetFileName (item.ItemSpec);
+
+				zipStream.PutNextEntry (new ICSharpCode.SharpZipLib.Zip.ZipEntry (target_path));
+				using (FileStream inStream = File.OpenRead (item.ItemSpec)) {
+					int readCount;
+					byte[] buffer = new byte[4096];
+						
+					do {
+						readCount = inStream.Read (buffer, 0, buffer.Length);
+						zipStream.Write (buffer, 0, readCount);
+					} while (readCount > 0);
+				}
+			}
+		}
+
+		[Output]
+		[Required]
+		public ITaskItem XapFilename {
+			get; set;
+		}
+		
+		[Required]
+		public ITaskItem[] InputFiles {
+			get; set;
+		}
+
+		public ITaskItem[] LocalCopyReferences {
+			get; set;
+		}
+
+	}
+	
+
+}
Index: xbuild/tasks/ChangeLog
===================================================================
--- xbuild/tasks/ChangeLog	(revision 0)
+++ xbuild/tasks/ChangeLog	(revision 0)
@@ -0,0 +1,8 @@
+2010-04-13  Ankit Jain  <jankit@novell.com>
+
+	* CreateTestPage.cs:
+	* GenerateMoonlightManifest.cs:
+	* GenerateXap.cs:
+	* Respack.cs:
+	* XamlG.cs:
+	MSBuild tasks for building silverlight projects.
Index: xbuild/tasks/XamlG.cs
===================================================================
--- xbuild/tasks/XamlG.cs	(revision 0)
+++ xbuild/tasks/XamlG.cs	(revision 0)
@@ -0,0 +1,375 @@
+//
+// XamlG.cs: Task that can copy files
+//
+// Author:
+//	Michael Hutchinson <mhutchinson@novell.com>
+//	Ankit Jain <jankit@novell.com>
+//
+// Copyright (c) 2009 Novell, Inc. (http://www.novell.com)
+// Copyright (c) 2010 Novell, Inc. (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.CodeDom;
+using System.CodeDom.Compiler;
+using System.Xml;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+namespace Moonlight.MSBuild {
+	public class XamlG : Task {
+	
+		public override bool Execute ()
+		{
+			if (Sources.Length == 0)
+				return true;
+
+			if (OutputFiles == null || Sources.Length != OutputFiles.Length) {
+				Log.LogError ("Number of OutputFiles must match the number of Source files");
+				return false;
+			}
+
+			var codedom_provider = GetCodeDomProviderForLanguage (Language);
+			if (codedom_provider == null) {
+				Log.LogError ("Language {0} not supported for code generation.", Language);
+				return false;
+			}
+
+			for (int i = 0; i < Sources.Length; i ++) {
+				ITaskItem source_item = Sources [i];
+				ITaskItem dest_item = OutputFiles [i];
+				if (!File.Exists (dest_item.ItemSpec) ||
+					File.GetLastWriteTime (dest_item.ItemSpec) < File.GetLastWriteTime (source_item.ItemSpec)) {
+					Log.LogMessage (MessageImportance.Low, "Generating codebehind accessors for {0}...", source_item.ItemSpec);
+
+					string full_source_path = source_item.GetMetadata ("FullPath");
+					try {
+						if (!XamlGCompiler.GenerateFile (codedom_provider, AssemblyName, full_source_path, full_source_path, dest_item.ItemSpec, Log)) {
+							Log.LogError ("Error generating {0} from {1}", full_source_path, dest_item.ItemSpec);
+							return false;
+						}
+					} catch (Exception e) {
+						Log.LogError ("Error generating {0} from {1}: {2}", full_source_path, dest_item.ItemSpec, e.Message);
+						Log.LogMessage (MessageImportance.Low, "Error generating {0} from {1}: {2}",
+								full_source_path, dest_item.ItemSpec, e.ToString ());
+						return false;
+					}
+				}
+			}
+
+			return true;
+		}
+
+		CodeDomProvider GetCodeDomProviderForLanguage (string lang)
+		{
+			switch (lang.ToLower ()) {
+			case "c#": return new Microsoft.CSharp.CSharpCodeProvider ();
+			case "vb": return new Microsoft.VisualBasic.VBCodeProvider ();
+			}
+
+			return null;
+		}
+
+		[Required]
+		public ITaskItem [] Sources {
+			get; set;
+		}
+
+		[Required]
+		public string Language {
+			get; set;
+		}
+
+		[Required]
+		public string AssemblyName {
+			get; set;
+		}
+
+		[Output]
+		public ITaskItem [] OutputFiles {
+			get; set;
+		}
+
+		bool HasFileChanged (string source, string dest)
+		{
+			if (!File.Exists (dest))
+				return true;
+
+			FileInfo sourceInfo = new FileInfo (source);
+			FileInfo destinationInfo = new FileInfo (dest);
+
+			return !(sourceInfo.Length == destinationInfo.Length &&
+					File.GetLastWriteTime(source) <= File.GetLastWriteTime (dest));
+		}
+
+	}
+	
+	static class XamlGCompiler
+	{
+		private static bool sl2 = true;
+
+		public static bool GenerateFile (CodeDomProvider provider, string app_name,
+		                                       string xaml_file, string xaml_path_in_project, string out_file, TaskLoggingHelper log)
+		{
+			XmlDocument xmldoc = new XmlDocument ();
+			xmldoc.Load (xaml_file);
+			
+			XmlNamespaceManager nsmgr = new XmlNamespaceManager (xmldoc.NameTable);
+			nsmgr.AddNamespace("x", "http://schemas.microsoft.com/winfx/2006/xaml");
+
+			XmlNode root = xmldoc.SelectSingleNode ("/*", nsmgr);
+			if (root == null) {
+				log.LogError ("{0}: No root node found.", xaml_file);
+				return false;
+			}
+
+			XmlAttribute root_class = root.Attributes ["x:Class"];
+			if (root_class == null) {
+				File.WriteAllText (out_file, "");
+				return true;
+			}
+
+			bool is_application = root.LocalName == "Application";
+			string root_ns;
+			string root_type;
+			string root_asm;
+
+			ParseXmlns (root_class.Value, out root_type, out root_ns, out root_asm);
+
+			Hashtable names_and_types = GetNamesAndTypes (root, nsmgr);
+//			Hashtable keys_and_types = GetKeysAndTypes (root, nsmgr);
+
+			CodeCompileUnit ccu = new CodeCompileUnit ();
+			CodeNamespace decl_ns = new CodeNamespace (root_ns);
+			ccu.Namespaces.Add (decl_ns);
+
+			decl_ns.Imports.Add (new CodeNamespaceImport ("System"));
+			decl_ns.Imports.Add (new CodeNamespaceImport ("System.Windows"));
+			decl_ns.Imports.Add (new CodeNamespaceImport ("System.Windows.Controls"));
+			decl_ns.Imports.Add (new CodeNamespaceImport ("System.Windows.Documents"));
+			decl_ns.Imports.Add (new CodeNamespaceImport ("System.Windows.Input"));
+			decl_ns.Imports.Add (new CodeNamespaceImport ("System.Windows.Media"));
+			decl_ns.Imports.Add (new CodeNamespaceImport ("System.Windows.Media.Animation"));
+			decl_ns.Imports.Add (new CodeNamespaceImport ("System.Windows.Shapes"));
+			decl_ns.Imports.Add (new CodeNamespaceImport ("System.Windows.Controls.Primitives"));
+
+			CodeTypeDeclaration decl_type = new CodeTypeDeclaration (root_type);
+			decl_type.IsPartial = true;
+
+			decl_ns.Types.Add (decl_type);
+			
+			CodeMemberMethod initcomp = new CodeMemberMethod ();
+			initcomp.Name = "InitializeComponent";
+			decl_type.Members.Add (initcomp);
+
+			if (sl2) {
+				CodeMemberField field = new CodeMemberField ();
+				field.Name = "_contentLoaded";
+				field.Type = new CodeTypeReference (typeof (bool));
+
+				decl_type.Members.Add (field);
+
+				CodeConditionStatement is_content_loaded = new CodeConditionStatement (new CodeVariableReferenceExpression ("_contentLoaded"),
+						new CodeStatement [] { new CodeMethodReturnStatement () });
+				initcomp.Statements.Add (is_content_loaded);
+
+				CodeAssignStatement set_content_loaded = new CodeAssignStatement (new CodeVariableReferenceExpression ("_contentLoaded"),
+						new CodePrimitiveExpression (true));
+
+				initcomp.Statements.Add (set_content_loaded);
+
+				string component_path = String.Format ("/{0};component/{1}", app_name, xaml_path_in_project);
+				CodeMethodInvokeExpression load_component = new CodeMethodInvokeExpression (
+					new CodeTypeReferenceExpression ("System.Windows.Application"), "LoadComponent",
+					new CodeExpression [] { new CodeThisReferenceExpression (),
+								new CodeObjectCreateExpression (new CodeTypeReference ("System.Uri"), new CodeExpression [] {
+									new CodePrimitiveExpression (component_path),
+									new CodeFieldReferenceExpression (new CodeTypeReferenceExpression ("System.UriKind"), "Relative") })
+					});
+				initcomp.Statements.Add (load_component);
+			}
+
+			if (!is_application) {
+				foreach (DictionaryEntry entry  in names_and_types) {
+					string name = (string) entry.Key;
+					CodeTypeReference type = (CodeTypeReference) entry.Value;
+
+					CodeMemberField field = new CodeMemberField ();
+
+					if (sl2)
+						field.Attributes = MemberAttributes.Assembly;
+
+					field.Name = name;
+					field.Type = type;
+
+					decl_type.Members.Add (field);
+
+					CodeMethodInvokeExpression find_invoke = new CodeMethodInvokeExpression (
+						new CodeThisReferenceExpression(), "FindName", 
+						new CodeExpression[] { new CodePrimitiveExpression (name) } );
+
+					CodeCastExpression cast = new CodeCastExpression (type, find_invoke);
+
+					CodeAssignStatement assign = new CodeAssignStatement (
+						new CodeVariableReferenceExpression (name), cast);
+
+					initcomp.Statements.Add (assign);
+				}
+			}
+			
+
+			using (StreamWriter writer = new StreamWriter (out_file)) {
+				provider.GenerateCodeFromCompileUnit (ccu, writer, new CodeGeneratorOptions ());
+			}
+			
+			return true;
+		}
+
+		private static Hashtable GetNamesAndTypes (XmlNode root, XmlNamespaceManager nsmgr)
+		{
+			Hashtable res = new Hashtable ();
+
+			XmlNodeList names = root.SelectNodes ("//*[@x:Name]", nsmgr);
+			foreach (XmlNode node in names)	{
+
+				// Don't take the root canvas
+				if (node == root)
+					continue;
+
+				XmlAttribute attr = node.Attributes ["x:Name"];
+				string name = attr.Value;
+				string ns = GetNamespace (node);
+				string member_type = node.LocalName;
+
+				if (ns != null)
+					member_type = String.Concat (ns, ".", member_type);
+
+				CodeTypeReference type = new CodeTypeReference (member_type);
+				if (ns != null)
+					type.Options |= CodeTypeReferenceOptions.GlobalReference;
+
+				res [name] = type;
+			}
+
+			return res;
+		}
+
+		/*
+		private static Hashtable GetKeysAndTypes (XmlNode root, XmlNamespaceManager nsmgr)
+		{
+			Hashtable res = new Hashtable ();
+
+			XmlNodeList keys = root.SelectNodes ("//*[@x:Key]", nsmgr);
+			foreach (XmlNode node in keys)	{
+
+				// Don't take the root canvas
+				if (node == root)
+					continue;
+
+				XmlAttribute attr = node.Attributes ["x:Key"];
+				string key = attr.Value;
+				string ns = GetNamespace (node);
+				string member_type = node.LocalName;
+
+				if (ns != null)
+					member_type = String.Concat (ns, ".", member_type);
+
+				res [key] = member_type;
+			}
+
+			return res;
+		}
+		*/
+
+		internal static string GetNamespace (XmlNode node)
+		{
+			if (!IsCustom (node.NamespaceURI))
+				return null;
+
+			return ParseNamespaceFromXmlns (node.NamespaceURI);
+		}
+
+		private static bool IsCustom (string ns)
+		{
+			switch (ns) {
+			case "http://schemas.microsoft.com/winfx/2006/xaml":
+			case "http://schemas.microsoft.com/winfx/2006/xaml/presentation":
+			case "http://schemas.microsoft.com/client/2007":
+				return false;
+			}
+
+			return true;
+		}
+
+		private static string ParseNamespaceFromXmlns (string xmlns)
+		{
+			string type_name = null;
+			string ns = null;
+			string asm = null;
+
+			ParseXmlns (xmlns, out type_name, out ns, out asm);
+
+			return ns;
+		}
+
+//		private static string ParseTypeFromXmlns (string xmlns)
+//		{
+//			string type_name = null;
+//			string ns = null;
+//			string asm = null;
+//
+//			ParseXmlns (xmlns, out type_name, out ns, out asm);
+//
+//			return type_name;
+//		}
+
+		internal static void ParseXmlns (string xmlns, out string type_name, out string ns, out string asm)
+		{
+			type_name = null;
+			ns = null;
+			asm = null;
+
+			string [] decls = xmlns.Split (';');
+			foreach (string decl in decls) {
+				if (decl.StartsWith ("clr-namespace:")) {
+					ns = decl.Substring (14, decl.Length - 14);
+					continue;
+				}
+				if (decl.StartsWith ("assembly=")) {
+					asm = decl.Substring (9, decl.Length - 9);
+					continue;
+				}
+				int nsind = decl.LastIndexOf (".");
+				if (nsind > 0) {
+					ns = decl.Substring (0, nsind);
+					type_name = decl.Substring (nsind + 1, decl.Length - nsind - 1);
+				} else {
+					type_name = decl;
+				}
+			}
+		}
+	}
+
+}
Index: xbuild/tasks/Respack.cs
===================================================================
--- xbuild/tasks/Respack.cs	(revision 0)
+++ xbuild/tasks/Respack.cs	(revision 0)
@@ -0,0 +1,105 @@
+//
+// Respack.cs: Task for license compiler
+//
+// Author:
+//   Ankit Jain (jankit@novell.com)
+//
+// Copyright 2010 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHRespackL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DERespackINGS IN THE SOFTWARE.
+
+using System;
+using System.Diagnostics;
+using System.IO;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Tasks;
+using Microsoft.Build.Utilities;
+using Mono.XBuild.Utilities;
+
+namespace Moonlight.MSBuild {
+	public class Respack : ToolTask
+	{
+		public override bool Execute ()
+		{
+			if (!ValidateParameters ()) {
+				// not generating any resource file
+				OutputFile = null;
+				return true;
+			}
+
+			return base.Execute ();
+		}
+
+		void AddCommandLineCommands (CommandLineBuilderExtension commandLine)
+		{
+			if (Resources.Length == 0)
+				return;
+
+			commandLine.AppendFileNameIfNotNull (OutputFile);
+
+			commandLine.AppendFileNamesIfNotNull (Resources, " ");
+		}
+
+		protected override string GenerateCommandLineCommands ()
+		{
+			CommandLineBuilderExtension clbe = new CommandLineBuilderExtension ();
+			AddCommandLineCommands (clbe);
+			return clbe.ToString ();
+		}
+
+		protected override string GenerateFullPathToTool ()
+		{
+			return Path.Combine (ToolPath, ToolExe);
+		}
+
+		protected override bool ValidateParameters()
+		{
+			return Resources.Length > 0;
+		}
+
+		[Required]
+		[Output]
+		public ITaskItem OutputFile {
+			get; set;
+		}
+
+		[Required]
+		public ITaskItem[] Resources {
+			get; set;
+		}
+
+		protected override string ToolName {
+			get {
+				return RunningOnWindows ? "respack.bat" : "respack";
+			}
+		}
+
+                static bool RunningOnWindows {
+                        get {
+                                // Code from Mono.GetOptions/Options.cs
+                                // check for non-Unix platforms - see FAQ for more details
+                                // http://www.mono-project.com/FAQ:_Technical#How_to_detect_the_execution_platform_.3F
+                                int platform = (int) Environment.OSVersion.Platform;
+                                return ((platform != 4) && (platform != 128));
+                        }   
+
+                } 
+	}
+}
Index: xbuild/Microsoft.Silverlight.CSharp.targets
===================================================================
--- xbuild/Microsoft.Silverlight.CSharp.targets	(revision 0)
+++ xbuild/Microsoft.Silverlight.CSharp.targets	(revision 0)
@@ -0,0 +1,4 @@
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+	<Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+	<Import Project="Microsoft.Silverlight.Common.targets"/>
+</Project>
Index: xbuild/ChangeLog
===================================================================
--- xbuild/ChangeLog	(revision 0)
+++ xbuild/ChangeLog	(revision 0)
@@ -0,0 +1,12 @@
+2010-04-13  Ankit Jain  <jankit@novell.com>
+
+	* Microsoft.Silverlight.CSharp.targets:
+	* Microsoft.Silverlight.VisualBasic.targets:
+	* Microsoft.Silverlight.Common.targets:
+	MSBuild target files for building silverlight projects.
+
+	* PreviewTemplate.html: Used for generating the test
+	page. Taken from monodevelop.
+
+	* Makefile.am: Compile/install the tasks and targets.
+
Index: xbuild/Makefile.am
===================================================================
--- xbuild/Makefile.am	(revision 0)
+++ xbuild/Makefile.am	(revision 0)
@@ -0,0 +1,35 @@
+moondir = $(pkglibdir)
+
+thislib = Moonlight.MSBuild.dll
+
+moon_DATA = $(thislib)
+
+EXTRA_DIST = *.targets
+
+CLEANFILES = $(thislib) $(thislib).mdb
+
+SOURCES = $(srcdir)/tasks/CreateTestPage.cs \
+	  $(srcdir)/tasks/GenerateMoonlightManifest.cs \
+	  $(srcdir)/tasks/GenerateXap.cs \
+	  $(srcdir)/tasks/GetMoonlightFrameworkPath.cs \
+	  $(srcdir)/tasks/Respack.cs \
+	  $(srcdir)/tasks/XamlG.cs
+	
+REFERENCES = -r:Microsoft.Build.Engine.dll \
+	-r:Microsoft.Build.Framework.dll \
+	-r:Microsoft.Build.Utilities.dll \
+	-r:Microsoft.Build.Tasks.dll \
+	-r:ICSharpCode.SharpZipLib.dll
+
+Moonlight.MSBuild.dll: $(SOURCES)
+	gmcs -debug -t:library -out:$@ $(SOURCES) $(REFERENCES) -resource:PreviewTemplate.html
+
+EXTENSIONS_PATH=$(libdir)/mono/xbuild/Microsoft/Silverlight
+
+install-exec-local:
+	mkdir -p $(EXTENSIONS_PATH)/v2.0 $(EXTENSIONS_PATH)/v3.0
+	cp $(thislib) $(thislib).mdb $(EXTENSIONS_PATH)/v2.0
+	cp $(thislib) $(thislib).mdb $(EXTENSIONS_PATH)/v3.0
+	cp *.targets $(EXTENSIONS_PATH)/v2.0
+	cp *.targets $(EXTENSIONS_PATH)/v3.0
+	
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 155252)
+++ Makefile.am	(working copy)
@@ -49,7 +49,8 @@
 	$(PERF_SUBDIR) \
 	$(MONO_EXAMPLES) \
 	scripts \
-	sdk
+	sdk \
+	xbuild
 
 # until we start providing devel packages that install the headers, there's no need to install this .pc
 #pkgconfigdir = $(libdir)/pkgconfig