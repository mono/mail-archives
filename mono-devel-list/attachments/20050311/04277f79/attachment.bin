Index: mono/metadata/domain.c
===================================================================
--- mono/metadata/domain.c	(revision 41706)
+++ mono/metadata/domain.c	(working copy)
@@ -682,7 +682,7 @@
  *
  * Returns: the current domain.
  */
-inline MonoDomain *
+MonoDomain *
 mono_domain_get ()
 {
 	return GET_APPDOMAIN ();
@@ -694,7 +694,7 @@
  *
  * Sets the current domain to @domain.
  */
-inline void
+void
 mono_domain_set_internal (MonoDomain *domain)
 {
 	SET_APPDOMAIN (domain);
Index: mono/metadata/appdomain.c
===================================================================
--- mono/metadata/appdomain.c	(revision 41706)
+++ mono/metadata/appdomain.c	(working copy)
@@ -1373,7 +1373,7 @@
 #if 0
 	thread_handle = CreateThread (NULL, 0, unload_thread_main, &thread_data, 0, &tid);
 #else
-	thread_handle = CreateThread (NULL, 0, unload_thread_main, &thread_data, CREATE_SUSPENDED, &tid);
+	thread_handle = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)unload_thread_main, &thread_data, CREATE_SUSPENDED, &tid);
 	ResumeThread (thread_handle);
 #endif
 
Index: mono/metadata/appdomain.h
===================================================================
--- mono/metadata/appdomain.h	(revision 41706)
+++ mono/metadata/appdomain.h	(working copy)
@@ -16,6 +16,12 @@
 #include <mono/metadata/reflection.h>
 #include <mono/metadata/mempool.h>
 
+#ifdef _MSC_VER
+#define MONO_INLINE
+#else
+#define MONO_INLINE	inline
+#endif
+
 typedef void (*MonoThreadStartCB) (guint32 tid, gpointer stack_start,
 				   gpointer func);
 typedef void (*MonoThreadAttachCB) (guint32 tid, gpointer stack_start);
@@ -59,19 +65,19 @@
 MonoDomain *
 mono_domain_create         (void);
 
-inline MonoDomain *
+MONO_INLINE MonoDomain *
 mono_domain_get            (void);
 
-inline MonoDomain *
+MONO_INLINE MonoDomain *
 mono_domain_get_by_id      (gint32 domainid);
 
 gint32
 mono_domain_get_id         (MonoDomain *domain);
 
-inline gboolean
+MONO_INLINE gboolean
 mono_domain_set            (MonoDomain *domain, gboolean force);
 
-inline void
+MONO_INLINE void
 mono_domain_set_internal   (MonoDomain *domain);
 
 gboolean
@@ -101,10 +107,10 @@
 void
 mono_context_init 				   (MonoDomain *domain);
 
-inline void 
+MONO_INLINE void 
 mono_context_set				   (MonoAppContext *new_context);
 
-inline MonoAppContext * 
+MONO_INLINE MonoAppContext * 
 mono_context_get				   (void);
 
 MonoJitInfo *
Index: mono/metadata/assembly.c
===================================================================
--- mono/metadata/assembly.c	(revision 41706)
+++ mono/metadata/assembly.c	(working copy)
@@ -28,6 +28,7 @@
 #include <mono/utils/mono-logger.h>
 #ifdef PLATFORM_WIN32
 #include <mono/os/util.h>
+#include "msc.h"
 #endif
 
 /* AssemblyVersionMap: an assembly name and the assembly version set on which it is based */
Index: mono/metadata/threads.c
===================================================================
--- mono/metadata/threads.c	(revision 41706)
+++ mono/metadata/threads.c	(working copy)
@@ -225,7 +225,7 @@
 		mono_thread_cleanup (thread);
 }
 
-static guint32 start_wrapper(void *data)
+static guint32 WINAPI start_wrapper(void *data)
 {
 	struct StartInfo *start_info=(struct StartInfo *)data;
 	guint32 (*start_func)(void *);
@@ -362,7 +362,7 @@
 	/* Create suspended, so we can do some housekeeping before the thread
 	 * starts
 	 */
-	thread_handle = CreateThread(NULL, default_stacksize_for_thread (thread), start_wrapper, start_info,
+	thread_handle = CreateThread(NULL, default_stacksize_for_thread (thread), (LPTHREAD_START_ROUTINE)start_wrapper, start_info,
 				     CREATE_SUSPENDED, &tid);
 	THREAD_DEBUG (g_message (G_GNUC_PRETTY_FUNCTION ": Started thread ID %d (handle %p)",
 		  tid, thread_handle));
@@ -513,7 +513,7 @@
 			return(NULL);
 		}
 
-		thread=CreateThread(NULL, default_stacksize_for_thread (this), start_wrapper, start_info,
+		thread=CreateThread(NULL, default_stacksize_for_thread (this), (LPTHREAD_START_ROUTINE)start_wrapper, start_info,
 				    CREATE_SUSPENDED, &tid);
 		if(thread==NULL) {
 			g_warning(G_GNUC_PRETTY_FUNCTION
@@ -1319,7 +1319,7 @@
 int  
 mono_thread_get_abort_signal (void)
 {
-#ifdef __MINGW32__
+#if defined (__MINGW32__) || defined (_MSC_VER)
 	return -1;
 #else
 #ifndef	SIGRTMIN
@@ -1327,17 +1327,16 @@
 #else
 	return SIGRTMIN;
 #endif
-#endif /* __MINGW32__ */
+#endif /*defined (__MINGW32__) || defined (_MSC_VER) */
 }
 
-#ifdef __MINGW32__
-static CALLBACK void interruption_request_apc (ULONG_PTR param)
+#if defined (__MINGW32__) || defined (_MSC_VER)
+static void CALLBACK interruption_request_apc (ULONG_PTR param)
 {
 	MonoException* exc = mono_thread_request_interruption (FALSE);
 	if (exc) mono_raise_exception (exc);
-	return 0;
 }
-#endif /* __MINGW32__ */
+#endif /* defined (__MINGW32__) || defined (_MSC_VER) */
 
 /*
  * signal_thread_state_change
@@ -1354,8 +1353,8 @@
 			mono_raise_exception (exc);
 	}
 
-#ifdef __MINGW32__
-	QueueUserAPC (interruption_request_apc, thread->handle, NULL);
+#if defined (__MINGW32__) || defined (_MSC_VER)
+	QueueUserAPC ((PAPCFUNC)interruption_request_apc, thread->handle, NULL);
 #else
 	/* fixme: store the state somewhere */
 #ifdef PTHREAD_POINTER_ID
@@ -1363,7 +1362,7 @@
 #else
 	pthread_kill (thread->tid, mono_thread_get_abort_signal ());
 #endif
-#endif /* __MINGW32__ */
+#endif /* defined (__MINGW32__) || defined (__MSC_VER) */
 }
 
 void
@@ -2359,7 +2358,7 @@
 		
 		/* this will awake the thread if it is in WaitForSingleObject 
 	       or similar */
-		QueueUserAPC (dummy_apc, thread->handle, NULL);
+		QueueUserAPC ((PAPCFUNC)dummy_apc, thread->handle, NULL);
 		
 		return NULL;
 	}
Index: mono/metadata/sysmath.h
===================================================================
--- mono/metadata/sysmath.h	(revision 41706)
+++ mono/metadata/sysmath.h	(working copy)
@@ -13,6 +13,10 @@
 #include <config.h>
 #include <glib.h>
 
+#ifdef _MSC_VER
+#include "msc.h"
+#endif
+
 extern gdouble ves_icall_System_Math_Floor (gdouble x);
 extern gdouble ves_icall_System_Math_Round (gdouble x);
 extern gdouble ves_icall_System_Math_Round2 (gdouble value, gint32 digits);
Index: mono/metadata/rawbuffer.c
===================================================================
--- mono/metadata/rawbuffer.c	(revision 41706)
+++ mono/metadata/rawbuffer.c	(working copy)
@@ -14,6 +14,7 @@
 #include <unistd.h>
 #include <errno.h>
 #ifdef USE_WIN32_API
+#include <winsock2.h>
 #include <windows.h>
 #include <io.h>
 #else
Index: mono/metadata/mono-config.c
===================================================================
--- mono/metadata/mono-config.c	(revision 41706)
+++ mono/metadata/mono-config.c	(working copy)
@@ -10,6 +10,8 @@
 #include "config.h"
 #include <glib.h>
 #include <string.h>
+
+#include "mono/metadata/assembly.h"
 #include "mono/metadata/loader.h"
 #include "mono/metadata/mono-config.h"
 #include "mono/metadata/metadata-internals.h"
@@ -308,9 +310,11 @@
 void
 mono_config_parse (const char *filename) {
 	const char *home;
+	char *mono_cfg;
+#ifndef PLATFORM_WIN32
 	char *user_cfg;
-	char *mono_cfg;
-	
+#endif
+
 	if (filename) {
 		mono_config_parse_file (filename);
 		return;
Index: mono/metadata/icall.c
===================================================================
--- mono/metadata/icall.c	(revision 41706)
+++ mono/metadata/icall.c	(working copy)
@@ -5472,7 +5472,7 @@
 ves_icall_System_Diagnostics_DefaultTraceListener_WriteWindowsDebugString (MonoString *message)
 {
 #if defined (PLATFORM_WIN32)
-	static void (*output_debug) (gchar *);
+	static void (*output_debug) (gunichar2 *);
 	static gboolean tried_loading = FALSE;
 
 	MONO_ARCH_SAVE_REGS;
Index: mono/metadata/rand.c
===================================================================
--- mono/metadata/rand.c	(revision 41706)
+++ mono/metadata/rand.c	(working copy)
@@ -94,6 +94,7 @@
 
 #if defined (PLATFORM_WIN32)
 
+#include <windows.h>
 #include <WinCrypt.h>
 
 #ifndef PROV_INTEL_SEC
@@ -158,13 +159,14 @@
 	if (!CryptGenRandom (provider, len, buf)) {
 		CryptReleaseContext (provider, 0);
 		/* we may have lost our context with CryptoAPI, but all hope isn't lost yet! */
-		provider = ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngInitialize (NULL);
+		provider = (HCRYPTPROV) ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngInitialize (NULL);
 		if (!CryptGenRandom (provider, len, buf)) {
 			CryptReleaseContext (provider, 0);
 			provider = 0;
 			/* exception will be thrown in managed code */
 		}
-	} 
+	}
+	return (gpointer) provider;
 }
 
 void
Index: mono/os/gc_wrapper.h
===================================================================
--- mono/os/gc_wrapper.h	(revision 41706)
+++ mono/os/gc_wrapper.h	(working copy)
@@ -5,6 +5,10 @@
 
 #ifdef HAVE_BOEHM_GC
 
+#	ifdef _MSC_VER
+#		include <winsock2.h>
+#	endif
+
 	/* libgc specifies this on the command line,
 	 * so we must define it ourselfs
 	 */
Index: mono/io-layer/io-layer.h
===================================================================
--- mono/io-layer/io-layer.h	(revision 41706)
+++ mono/io-layer/io-layer.h	(working copy)
@@ -16,10 +16,12 @@
 #define UNICODE
 #define _UNICODE
 #define __USE_W32_SOCKETS
-#include <w32api.h>
+#include <winsock2.h>
 #include <windows.h>
+#include <WinBase.h>
 #include <ws2tcpip.h>
 #include <psapi.h>
+#include <shlobj.h>
 #else	/* EVERYONE ELSE */
 #include "mono/io-layer/wapi.h"
 #include "mono/io-layer/uglify.h"
Index: mono/mini/mini.h
===================================================================
--- mono/mini/mini.h	(revision 41706)
+++ mono/mini/mini.h	(working copy)
@@ -20,6 +20,10 @@
 #include "regalloc.h"
 #include "declsec.h"
 
+#ifdef _MSC_VER
+#include "mono/metadata/msc.h"
+#endif
+
 #define MONO_USE_AOT_COMPILER
 
 /* for 32 bit systems */
Index: mono/mini/aot.c
===================================================================
--- mono/mini/aot.c	(revision 41706)
+++ mono/mini/aot.c	(working copy)
@@ -16,8 +16,13 @@
 #ifndef PLATFORM_WIN32
 #include <sys/mman.h>
 #else
+#include <winsock2.h>
 #include <windows.h>
+#ifdef _MSC_VER
+#include <direct.h>
+#define mkdir(x)	_mkdir(x)
 #endif
+#endif
 
 #include <errno.h>
 #include <sys/stat.h>
Index: mono/mini/mini-exceptions.c
===================================================================
--- mono/mini/mini-exceptions.c	(revision 41706)
+++ mono/mini/mini-exceptions.c	(working copy)
@@ -279,11 +279,20 @@
 
 	MonoContext ctx, new_ctx;
 
+#ifdef _MSC_VER
+	unsigned int stackptr, retaddr;
+	__asm mov stackptr, ebp;
+	__asm mov eax, DWORD PTR [ebp + 4];
+	__asm mov retaddr, eax;
+	MONO_CONTEXT_SET_IP (&ctx, retaddr);
+	/* FIXME: NOT WORKING -- THIS IS __builtin_frame_address (0) NOT (1) */
+	MONO_CONTEXT_SET_BP (&ctx, stackptr);
+#else
 	mono_arch_flush_register_windows ();
 
 	MONO_CONTEXT_SET_IP (&ctx, __builtin_return_address (0));
 	MONO_CONTEXT_SET_BP (&ctx, __builtin_frame_address (1));
-
+#endif
 	while (MONO_CONTEXT_GET_BP (&ctx) < jit_tls->end_of_stack) {
 		
 		ji = mono_find_jit_info (domain, jit_tls, &rji, NULL, &ctx, &new_ctx, NULL, &lmf, &native_offset, &managed);
@@ -312,11 +321,18 @@
 	MonoLMF *lmf = jit_tls->lmf;
 	MonoJitInfo *ji, rji;
 	MonoContext ctx, new_ctx;
+	unsigned int stackptr;
 
 	mono_arch_flush_register_windows ();
 
+#ifdef _MSC_VER
+	__asm mov stackptr, ebp;
+#else
+	stackptr = (unsigned int) __builtin_frame_address (0);
+#endif
+
 	MONO_CONTEXT_SET_IP (&ctx, ves_icall_get_frame_info);
-	MONO_CONTEXT_SET_BP (&ctx, __builtin_frame_address (0));
+	MONO_CONTEXT_SET_BP (&ctx, stackptr);
 
 	skip++;
 
@@ -406,7 +422,16 @@
 	MonoFrameSecurityInfo si;
 	MonoContext ctx;
 
+#ifdef _MSC_VER
+	/* seems that MSC doesn't like having __asm in macros */
+	unsigned int stackptr;
+	mono_arch_flush_register_windows ();
+	__asm mov stackptr, ebp;
+	MONO_CONTEXT_SET_IP (&ctx, ves_icall_System_Security_SecurityFrame_GetSecurityFrame);
+	MONO_CONTEXT_SET_BP (&ctx, stackptr);
+#else
 	MONO_INIT_CONTEXT_FROM_FUNC (&ctx, ves_icall_System_Security_SecurityFrame_GetSecurityFrame);
+#endif
 
 	si.skips = skip;
 	si.frame = NULL;
@@ -483,7 +508,16 @@
 	MonoContext ctx;
 	MonoArray *stack;
 
+#ifdef _MSC_VER
+	/* seems that MSC doesn't like having __asm in macros */
+	unsigned int stackptr;
+	mono_arch_flush_register_windows ();
+	__asm mov stackptr, ebp;
+	MONO_CONTEXT_SET_IP (&ctx, ves_icall_System_Security_SecurityFrame_GetSecurityStack);
+	MONO_CONTEXT_SET_BP (&ctx, stackptr);
+#else
 	MONO_INIT_CONTEXT_FROM_FUNC (&ctx, ves_icall_System_Security_SecurityFrame_GetSecurityStack);
+#endif
 
 	ss.skips = skip;
 	ss.stack = NULL;
Index: mono/mini/mini-x86.c
===================================================================
--- mono/mini/mini-x86.c	(revision 41706)
+++ mono/mini/mini-x86.c	(working copy)
@@ -90,7 +90,12 @@
 
 #define FLOAT_PARAM_REGS 0
 
+#if _MSC_VER
+/* MCS requires a value enum value */
+static X86_Reg_No param_regs [] = { X86_NREG };
+#else
 static X86_Reg_No param_regs [] = { };
+#endif
 
 #ifdef PLATFORM_WIN32
 static X86_Reg_No return_regs [] = { X86_EAX, X86_EDX };
@@ -465,6 +470,7 @@
 cpuid (int id, int* p_eax, int* p_ebx, int* p_ecx, int* p_edx)
 {
 	int have_cpuid = 0;
+#ifndef _MSC_VER
 	__asm__  __volatile__ (
 		"pushfl\n"
 		"popl %%eax\n"
@@ -481,7 +487,21 @@
 		:
 		: "%eax", "%edx"
 	);
-
+#else
+	__asm {
+		pushfd
+		pop eax
+		mov edx, eax
+		xor eax, 0x200000
+		push eax
+		popfd
+		pushfd
+		pop eax
+		xor eax, edx
+		and eax, 0x200000
+		mov have_cpuid, eax
+	}
+#endif
 	if (have_cpuid) {
 		/* Have to use the code manager to get around WinXP DEP */
 		MonoCodeManager *codeman = mono_code_manager_new_dynamic ();
@@ -512,15 +532,18 @@
 void
 mono_arch_cpu_init (void)
 {
+	/* spec compliance requires running with double precision */
+#ifndef _MSC_VER
 	guint16 fpcw;
 
-	/* spec compliance requires running with double precision */
 	__asm__  __volatile__ ("fnstcw %0\n": "=m" (fpcw));
 	fpcw &= ~X86_FPCW_PRECC_MASK;
 	fpcw |= X86_FPCW_PREC_DOUBLE;
 	__asm__  __volatile__ ("fldcw %0\n": : "m" (fpcw));
 	__asm__  __volatile__ ("fnstcw %0\n": "=m" (fpcw));
-
+#else
+	_control87 (_PC_64, MCW_PC);
+#endif
 	mono_x86_tramp_init ();
 }
 
Index: mono/mini/mini-x86.h
===================================================================
--- mono/mini/mini-x86.h	(revision 41706)
+++ mono/mini/mini-x86.h	(working copy)
@@ -107,8 +107,13 @@
 	guint32     eip;
 };
 
+#ifndef _MSC_VER
 typedef struct MonoCompileArch {
 } MonoCompileArch;
+#else
+/* MCS doesn't like empty struct */
+typedef void* MonoCompileArch;
+#endif
 
 #if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
 # define SC_EAX sc_eax
