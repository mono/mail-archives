// variable length list processing
// 
// Compile with: mcs -debug+ vlist.cs
using System;
using System.Runtime.InteropServices;

[StructLayout (LayoutKind.Sequential)]
class Foo
{
	public int First;
	public int Second;
}

class FooList
{
	int count;
	Foo[] list;

	public FooList ()
	{
		this.count = 0;
		this.list = new Foo[count];
	}

	public int Count {
		get {return count;}
		set {
			if (count == value)
				return;
			Foo[] newList = new Foo[value];
			Array.Copy (list, newList, Math.Min (value, list.Length));
			for (int i = count; i < newList.Length; ++i)
				newList [i] = new Foo ();
			count = value;
			list = newList;
		}
	}

	public Foo[] List {
		get {return list;}
	}

	private struct FooListMarshal {
		public int Count;
	}

	public void GetFooList ()
	{
		IntPtr marshal = ToIntPtr ();
		try {
			GetFooList (marshal);
			FillFromIntPtr (marshal);
		}
		finally {
			Marshal.FreeHGlobal (marshal);
		}
	}

	public IntPtr ToIntPtr ()
	{
		int flmSize = Marshal.SizeOf (typeof(FooListMarshal)); 
		int fooSize = Marshal.SizeOf (typeof(Foo));
		int size = flmSize + this.count*fooSize;
		FooListMarshal flm = new FooListMarshal ();
		flm.Count = this.count;

		bool complete = false;
		IntPtr mem = Marshal.AllocHGlobal (size);
		try {
			Marshal.StructureToPtr (flm, mem, false);
			IntPtr arrayMem = (IntPtr) ((long) mem + flmSize);
			for (int i = 0; i < count; ++i) {
				IntPtr elemMem = (IntPtr) ((long) arrayMem + (i*fooSize));
				Marshal.StructureToPtr (list[i], elemMem, false);
			}
			complete = true;
			return mem;
		}
		finally {
			if (!complete)
				Marshal.FreeHGlobal (mem);
		}
	}

	private void FillFromIntPtr (IntPtr fooList)
	{
		FooListMarshal flm = (FooListMarshal) Marshal.PtrToStructure (fooList, typeof(FooListMarshal));

		int count = flm.Count;
		Foo[] list = new Foo [count];

		int fooSize = Marshal.SizeOf (typeof(Foo));
		IntPtr arrayMem = (IntPtr) ((long) fooList + Marshal.SizeOf (typeof(FooListMarshal)));

		for (int i = 0; i < count; ++i) {
			IntPtr elemMem = (IntPtr) ((long) arrayMem + (i*fooSize));
			list [i] = (Foo) Marshal.PtrToStructure (elemMem, typeof(Foo));
		}

		this.list = list;
		this.count = count;
	}

	public static FooList FromIntPtr (IntPtr fooList)
	{
		FooList fl = new FooList ();
		fl.FillFromIntPtr (fooList);
		return fl;
	}

	public static FooList AllocFooList ()
	{
		IntPtr list;
		AllocFooList (out list);
		try {
			return FromIntPtr (list);
		}
		finally {
			free (list);
		}
	}

	[DllImport ("vlist")]
	private static extern void GetFooList (IntPtr list);

	[DllImport ("vlist")]
	private static extern void AllocFooList (out IntPtr list);

	[DllImport ("msvcrt")]
	private static extern void free (IntPtr p);
}

class Test
{	
	public static void Main ()
	{
		Console.Write ("GetFooList: ");
		FooList list = new FooList ();
		list.Count = 6;
		list.GetFooList ();

		Console.WriteLine ("Managed Count: " + list.Count);
		foreach (Foo f in list.List) {
			Console.WriteLine (" Elem: {{{0}, {1}}}", f.First, f.Second);
		}

		Console.Write ("AllocFooList: ");
		PrintFooList (FooList.AllocFooList ());
	}

	private static void PrintFooList (FooList list)
	{
		Console.WriteLine ("Managed Count: " + list.Count);
		foreach (Foo f in list.List) {
			Console.WriteLine (" Elem: {{{0}, {1}}}", f.First, f.Second);
		}
	}
}

