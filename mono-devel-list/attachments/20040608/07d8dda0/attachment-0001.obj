Index: ChangeLog
===================================================================
RCS file: /cvs/public/mcs/class/corlib/Test/System.Reflection.Emit/ChangeLog,v
retrieving revision 1.32
diff -u -r1.32 ChangeLog
--- ChangeLog	28 Apr 2004 11:00:49 -0000	1.32
+++ ChangeLog	8 Jun 2004 19:27:43 -0000
@@ -1,3 +1,13 @@
+2004-06-08  Gert Driesen <drieseng@users.sourceforge.net>
+
+	* MethodRentalTest.cs: Fixed unit tests as a result of change
+	in MethodRental, tests now succeed on both Mono and MS.NET
+
+	* TypeBuilderTest.cs: Added tests for completed/created type
+
+	* EnumBuilderTest.cs: Added tests for EnumBuilder, ignored
+	some tests that do not succeed on Mono right now
+
 2004-04-28  Zoltan Varga  <vargaz@freemail.hu>
 
 	* MethodRentalTest.cs: New file.
Index: EnumBuilderTest.cs
===================================================================
RCS file: EnumBuilderTest.cs
diff -N EnumBuilderTest.cs
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ EnumBuilderTest.cs	8 Jun 2004 19:27:45 -0000
@@ -0,0 +1,378 @@
+//
+// EnumBuiderTest - NUnit Test Cases for the EnumBuider class
+//
+// Keerti Narayan (keertiln@rediffmail.com)
+// Gert Driesen (drieseng@users.sourceforge.net)
+//
+// (C) Ximian, Inc.  http://www.ximian.com
+//
+//
+
+using System;
+using System.IO;
+using System.Reflection;
+using System.Reflection.Emit;
+using System.Collections;
+using System.Threading;
+
+using NUnit.Framework;
+
+namespace MonoTest.System.Reflection.Emit {
+	[TestFixture]
+	public class EnumBuiderTest : Assertion {
+		private static string _assemblyName = "MonoTests.System.Reflection.Emit.EnumBuilder";
+		private static string _moduleName = "EmittedModule";
+		private static string _enumNamespace = "MyNameSpace";
+		private static string _enumName = "MyEnum";
+		private static Type _enumType = typeof(Int32);
+		private static string _fieldName = "MyField";
+		private static object _fieldValue = 1;
+
+		[Test]
+		public void TestEnumBuilder()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			VerifyType (enumBuilder);
+
+			AssertNotNull (enumBuilder.TypeToken);
+			AssertNotNull (enumBuilder.UnderlyingField);
+			AssertNull ("type.DeclaringType of toplevel type should be null", enumBuilder.DeclaringType);
+			AssertNull ("type.ReflectedType should be null", enumBuilder.ReflectedType);
+			AssertEquals (_enumType, enumBuilder.UnderlyingSystemType);
+			AssertEquals ("Comparing the IsSerializable field", false, enumBuilder.IsSerializable);
+		}
+
+		[Test]
+		[ExpectedException (typeof(NotSupportedException))]
+		public void TestHasElementTypeEnumBuilderIncomplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			bool hasElementType = enumBuilder.HasElementType;
+		}
+
+		[Test]
+		[ExpectedException (typeof(NotSupportedException))]
+		public void TestHasElementTypeEnumBuilderComplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			enumBuilder.CreateType ();
+			bool hasElementType = enumBuilder.HasElementType;
+		}
+
+		[Test]
+		[ExpectedException (typeof(InvalidOperationException))]
+		public void TestDefineLiteralTypeComplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			Type enumType = enumBuilder.CreateType ();
+			// you should not be able to define literal after type 
+			// has been created
+			FieldBuilder fieldBuilder = enumBuilder.DefineLiteral (_fieldName, _fieldValue);
+		}
+
+		[Test]
+		public void TestDefineLiteralTypeIncomplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			FieldBuilder fieldBuilder = enumBuilder.DefineLiteral (_fieldName, _fieldValue);
+			Type enumType = enumBuilder.CreateType ();
+
+			AssertEquals (enumType, fieldBuilder.DeclaringType);
+			AssertEquals (_enumType, fieldBuilder.FieldType);
+			AssertEquals (true, fieldBuilder.IsPublic);
+			AssertEquals (true, fieldBuilder.IsStatic);
+			AssertEquals (true, fieldBuilder.IsLiteral);
+			AssertEquals (_fieldName, fieldBuilder.Name);
+		}
+
+		[Ignore ("This seems to interrupt unit tests on Windows")]
+		[Test]
+		public void TestEnumType()
+		{
+			AssemblyBuilder assemblyBuilder = GenerateAssembly ();
+
+			ModuleBuilder modBuilder = GenerateModule (assemblyBuilder);
+			EnumBuilder enumBuilder = GenerateEnum (modBuilder);
+			enumBuilder.CreateType ();
+
+			Type enumType = assemblyBuilder.GetType (_enumNamespace + "." + _enumName, true);
+
+			VerifyType (enumType);
+		}
+
+		[Test]
+		[ExpectedException (typeof(NotSupportedException))]
+		public void TestEnumBuilderGUIDIncomplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			Guid guid =  enumBuilder.GUID;
+		}
+
+		[Ignore ("This seems to interrupt unit tests on Mono/Windows")]
+		[Test]
+		public void TestEnumBuilderGUIDComplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			enumBuilder.CreateType ();
+			Assert (enumBuilder.GUID != Guid.Empty);
+		}
+
+		[Ignore ("This seems to interrupt unit tests on Mono/Windows")]
+		[Test]
+		public void TestEnumTypeGUID ()
+		{
+			AssemblyBuilder assemblyBuilder = GenerateAssembly ();
+			ModuleBuilder modBuilder = GenerateModule (assemblyBuilder);
+			EnumBuilder enumBuilder = GenerateEnum (modBuilder);
+			enumBuilder.CreateType ();
+
+			Type enumType = assemblyBuilder.GetType (_enumNamespace + "." + _enumName, true);
+
+			Assert (enumType.GUID != Guid.Empty);
+			AssertNull ("type.DeclaringType of toplevel type should be null", enumType.DeclaringType);
+		}
+
+		[Ignore ("This seems to interrupt unit tests on Mono/Windows")]
+		[Test]
+		public void TestFieldProperties() {
+			AssemblyBuilder assemblyBuilder = GenerateAssembly ();
+			ModuleBuilder modBuilder = GenerateModule (assemblyBuilder);
+			EnumBuilder enumBuilder = GenerateEnum (modBuilder);
+			FieldBuilder fieldBuilder = GenerateField (enumBuilder);
+			enumBuilder.CreateType ();
+
+			Type enumType = assemblyBuilder.GetType (_enumNamespace + "." + _enumName, true);
+			FieldInfo fi = enumType.GetField (_fieldName);
+			Object o = fi.GetValue(enumType);
+
+			AssertEquals ("Checking the value of the Field to be 1", _fieldValue, fi.GetValue (enumType));
+			AssertEquals ("Checking if the field is a Literal", true, fi.IsLiteral);
+			AssertEquals ("Checking if the field is Public", true, fi.IsPublic);
+			AssertEquals ("Checking if the field is Static", true, fi.IsStatic);
+		}
+
+		[Test]
+		public void TestFindInterfaces ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+
+			Type[] interfaces = enumBuilder.FindInterfaces (
+				new TypeFilter (MyInterfaceFilter), 
+				"System.Collections.IEnumerable");
+			AssertEquals (0, interfaces.Length);
+		}
+
+		[Test]
+		[ExpectedException (typeof(NotSupportedException))]
+		public void TestFindMembersIncomplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			GenerateField (enumBuilder);
+
+			MemberInfo[] members = enumBuilder.FindMembers (
+				MemberTypes.All, BindingFlags.Static |
+				BindingFlags.Public, new MemberFilter (MemberNameFilter),
+				_fieldName);
+		}
+
+		[Ignore ("This seems to interrupt unit tests on Mono/Windows")]
+		[Test]
+		public void TestFindMembersComplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			GenerateField (enumBuilder);
+			enumBuilder.CreateType ();
+
+			MemberInfo[] members = enumBuilder.FindMembers (
+				MemberTypes.Field, BindingFlags.Static |
+				BindingFlags.Public, new MemberFilter (MemberNameFilter),
+				_fieldName);
+			AssertEquals (1, members.Length);
+
+			members = enumBuilder.FindMembers (
+				MemberTypes.Field, BindingFlags.Static |
+				BindingFlags.Public, new MemberFilter (MemberNameFilter),
+				"doesntmatter");
+			AssertEquals (0, members.Length);
+		}
+
+		[Test]
+		[ExpectedException (typeof(NotSupportedException))]
+		public void TestGetConstructorIncomplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			enumBuilder.GetConstructor (BindingFlags.Public, null,
+				CallingConventions.Any, Type.EmptyTypes, new ParameterModifier[0]);
+		}
+
+		[Ignore ("This seems to interrupt unit tests on Mono/Windows")]
+		[Test]
+		public void TestGetConstructorComplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			enumBuilder.CreateType ();
+			ConstructorInfo ctor = enumBuilder.GetConstructor (
+				BindingFlags.Public, null, CallingConventions.Any,
+				Type.EmptyTypes, new ParameterModifier[0]);
+			AssertNull (ctor);
+		}
+
+		[Test]
+		[ExpectedException (typeof(ArgumentNullException))]
+		public void TestGetConstructorNullTypes ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			enumBuilder.CreateType ();
+			ConstructorInfo ctor = enumBuilder.GetConstructor (
+				BindingFlags.Public, null, CallingConventions.Any,
+				null, new ParameterModifier[0]);
+		}
+
+		[Ignore ("This seems to interrupt unit tests on Mono/Windows")]
+		[Test]
+		[ExpectedException (typeof(ArgumentNullException))]
+		public void TestGetConstructorNullElementType ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			enumBuilder.CreateType ();
+			ConstructorInfo ctor = enumBuilder.GetConstructor (
+				BindingFlags.Public, null, CallingConventions.Any,
+				new Type[] { null }, new ParameterModifier[0]);
+		}
+
+		[Test]
+		[ExpectedException (typeof(NotSupportedException))]
+		public void TestGetConstructorsIncomplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+
+			ConstructorInfo[] ctors = enumBuilder.GetConstructors (
+				BindingFlags.Instance | BindingFlags.Public);
+			AssertEquals (0, ctors.Length);
+		}
+
+		[Ignore ("This seems to interrupt unit tests on Mono/Windows")]
+		[Test]
+		public void TestGetConstructorsComplete ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			enumBuilder.CreateType ();
+
+			ConstructorInfo[] ctors = enumBuilder.GetConstructors (
+				BindingFlags.Instance | BindingFlags.Public);
+			AssertEquals (0, ctors.Length);
+		}
+
+		private static void VerifyType (Type type)
+		{
+			AssertNotNull ("type.Assembly should not be null", type.Assembly);
+			AssertNotNull ("type.AssemblyQualifiedName should not be null", type.AssemblyQualifiedName);
+			AssertNotNull ("type.BaseType should not be null", type.BaseType);
+			AssertNotNull ("type.FullName should not be null", type.FullName);
+			AssertNotNull ("type.Module should not be null", type.Module);
+			AssertNotNull ("type.Name should not be null", type.Name);
+			AssertNotNull ("type.Namespace should not be null", type.Namespace);
+			AssertNotNull ("type.UnderlyingSystemType should not be null", type.UnderlyingSystemType);
+
+			AssertEquals (_assemblyName + ", Version=0.0.0.0", type.Assembly.FullName);
+			AssertEquals (_enumNamespace + "." + _enumName + ", " + _assemblyName 
+				+ ", Version=0.0.0.0", type.AssemblyQualifiedName);
+			AssertEquals (_moduleName, type.Module.Name);
+			AssertEquals (_enumNamespace, type.Namespace);
+			AssertEquals (_enumName, type.Name);
+			AssertEquals (typeof(Enum), type.BaseType);
+			AssertEquals (MemberTypes.TypeInfo, type.MemberType);
+			AssertEquals (typeof(int), Enum.GetUnderlyingType (type));
+
+			AssertEquals ("Comparing the IsArray field", false, type.IsArray);
+			AssertEquals ("Comparing the IsAutoClass field", false, type.IsAutoClass);
+			AssertEquals ("Comparing the IsAutoLayout field", true, type.IsAutoLayout);
+			AssertEquals ("Comparing the IsByRef field", false, type.IsByRef);
+			AssertEquals ("Comparing the IsClass field", false, type.IsClass);
+			AssertEquals ("Comparing the IsComObject field", false, type.IsCOMObject);
+			AssertEquals ("Comparing the IsContextful field", false, type.IsContextful);
+			AssertEquals ("Comparing the IsEnum field", true, type.IsEnum);
+			AssertEquals ("Comparing the IsExplicitLayout field", false, type.IsExplicitLayout);
+			AssertEquals ("Comparing the IsImport field", false, type.IsImport);
+			AssertEquals ("Comparing the IsInterface field", false, type.IsInterface);
+			AssertEquals ("Comparing the IsLayoutSequential field", false, type.IsLayoutSequential);
+			AssertEquals ("Comparing the IsMarshalByRef field", false, type.IsMarshalByRef);
+			AssertEquals ("Comparing the IsNestedAssembly field", false, type.IsNestedAssembly);
+			AssertEquals ("Comparing the IsNestedFamily field", false, type.IsNestedFamily);
+			AssertEquals ("Comparing the IsNestedPublic field", false, type.IsNestedPublic);
+			AssertEquals ("Comparing the IsNestedPrivate field", false, type.IsNestedPrivate);
+			AssertEquals ("Comparing the IsNotPublic field", false, type.IsNotPublic);
+			AssertEquals ("Comparing the IsPrimitive field", false, type.IsPrimitive);
+			AssertEquals ("Comparing the IsPointer field", false, type.IsPointer);
+			AssertEquals ("Comparing the IsPublic field", true, type.IsPublic);
+			AssertEquals ("Comparing the IsSealed field", true, type.IsSealed);
+			AssertEquals ("Comparing the IsUnicode field", false, type.IsUnicodeClass);
+			AssertEquals ("Comparing the requires special handling field", false, type.IsSpecialName);
+			AssertEquals ("Comparing the IsValueType field", true, type.IsValueType);
+		}
+
+		public static bool MyInterfaceFilter (Type t, object filterCriteria)
+		{
+			if (t.ToString () == filterCriteria.ToString ())
+				return true;
+			else
+				return false;
+		}
+
+		public static bool MemberNameFilter (MemberInfo m, object filterCriteria)
+		{
+			if (m.Name == filterCriteria.ToString ())
+				return true;
+			else
+				return false;
+		}
+
+		private static AssemblyName GetAssemblyName ()
+		{
+			AssemblyName assemblyName = new AssemblyName ();
+			assemblyName.Name = _assemblyName;
+			return assemblyName;
+		}
+
+		private static AssemblyBuilder GenerateAssembly ()
+		{
+			return AppDomain.CurrentDomain.DefineDynamicAssembly (
+				GetAssemblyName (), AssemblyBuilderAccess.RunAndSave);
+		}
+
+		private static ModuleBuilder GenerateModule ()
+		{
+			AssemblyBuilder assemblyBuilder = GenerateAssembly ();
+			return assemblyBuilder.DefineDynamicModule (_moduleName);
+		}
+
+		private static ModuleBuilder GenerateModule (AssemblyBuilder assemblyBuilder)
+		{
+			return assemblyBuilder.DefineDynamicModule (_moduleName);
+		}
+
+		private static EnumBuilder GenerateEnum ()
+		{
+			ModuleBuilder modBuilder = GenerateModule ();
+			return modBuilder.DefineEnum (_enumNamespace + "."
+				+ _enumName, TypeAttributes.Public, _enumType);
+		}
+
+		private static EnumBuilder GenerateEnum (ModuleBuilder modBuilder)
+		{
+			return modBuilder.DefineEnum (_enumNamespace + "."
+				+ _enumName, TypeAttributes.Public, _enumType);
+		}
+
+		private static FieldBuilder GenerateField ()
+		{
+			EnumBuilder enumBuilder = GenerateEnum ();
+			return enumBuilder.DefineLiteral (_fieldName, _fieldValue);
+		}
+
+		private static FieldBuilder GenerateField (EnumBuilder enumBuilder)
+		{
+			return enumBuilder.DefineLiteral (_fieldName, _fieldValue);
+		}
+	}
+}
Index: MethodRentalTest.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/Test/System.Reflection.Emit/MethodRentalTest.cs,v
retrieving revision 1.1
diff -u -r1.1 MethodRentalTest.cs
--- MethodRentalTest.cs	28 Apr 2004 11:00:49 -0000	1.1
+++ MethodRentalTest.cs	8 Jun 2004 19:27:45 -0000
@@ -52,15 +52,22 @@
 	}
 
 	[Test]
-	[ExpectedException (typeof (ArgumentNullException))]
-	public void SwapMethodBodyNullType () {
+	[ExpectedException (typeof (ArgumentException))]
+	public void SwapMethodBodyInvalidMethodSize () {
 		MethodRental.SwapMethodBody (null, 0, IntPtr.Zero, 0, 0);
-	}
-
+	}
+
+	[Test]
+	[ExpectedException (typeof (ArgumentNullException))]
+	public void SwapMethodBodyNullType ()
+	{
+		MethodRental.SwapMethodBody (null, 0, IntPtr.Zero, 1, 0);
+	}
+
 	[Test]
 	[ExpectedException (typeof (NotSupportedException))]
 	public void SwapMethodBodyUnfinishedType () {
-		MethodRental.SwapMethodBody (genClass, 0, IntPtr.Zero, 0, 0);
+		MethodRental.SwapMethodBody (genClass, 0, IntPtr.Zero, 1, 0);
 	}
 }
 }
Index: TypeBuilderTest.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/Test/System.Reflection.Emit/TypeBuilderTest.cs,v
retrieving revision 1.7
diff -u -r1.7 TypeBuilderTest.cs
--- TypeBuilderTest.cs	16 Feb 2004 13:48:55 -0000	1.7
+++ TypeBuilderTest.cs	8 Jun 2004 19:27:47 -0000
@@ -1,3 +1,4 @@
+
 //
 // TypeBuilderTest.cs - NUnit Test Cases for the TypeBuilder class
 //
@@ -45,7 +46,7 @@
 
 		assembly = 
 			Thread.GetDomain().DefineDynamicAssembly(
-				assemblyName, AssemblyBuilderAccess.Run);
+				assemblyName, AssemblyBuilderAccess.RunAndSave, "c:\\");
 
 		module = assembly.DefineDynamicModule("module1");
 	}
@@ -61,12 +62,14 @@
 		return String.Format ("{0}", (char)0);
 	}
 
+	[Test]
 	public void TestAssembly () {
 		TypeBuilder tb = module.DefineType (genTypeName (), TypeAttributes.Public);
 		AssertEquals ("Assembly works",
 					  tb.Assembly, assembly);
 	}
 
+	[Test]
 	public void TestAssemblyQualifiedName () {
 		TypeBuilder tb = module.DefineType ("A.B.C.D", TypeAttributes.Public);
 
@@ -74,6 +77,7 @@
 					  tb.AssemblyQualifiedName, "A.B.C.D, " + assembly.GetName ().FullName);
 	}
 
+	[Test]
 	public void TestAttributes () {
 		TypeAttributes attrs = TypeAttributes.Public | TypeAttributes.BeforeFieldInit;
 		TypeBuilder tb = module.DefineType (genTypeName (), attrs);
@@ -82,7 +86,8 @@
 					  tb.Attributes, attrs);
 	}
 
-	public void TestBaseType () {
+	[Test]
+	public void TestBaseTypeClass () {
 		TypeAttributes attrs = TypeAttributes.Public;
 		TypeBuilder tb = module.DefineType (genTypeName (), attrs);
 		AssertEquals ("BaseType defaults to Object",
@@ -91,16 +96,17 @@
 		TypeBuilder tb2 = module.DefineType (genTypeName (), attrs, tb);
 		AssertEquals ("BaseType works",
 					  tb2.BaseType, tb);
+	}
 
-		/* This does not run under mono
-		TypeBuilder tb3 = module.DefineType (genTypeName (),
-											 TypeAttributes.Interface |
-											 TypeAttributes.Abstract);
-		AssertEquals ("Interfaces default to no base type",
-					  null, tb3.BaseType);
-		*/
+	[Test]
+	[Ignore ("Interfaces should default to no base type.  Ignoring until bug is fixed.")]
+	public void TestBaseTypeInterface ()
+	{
+		TypeBuilder tb3 = module.DefineType (genTypeName (), TypeAttributes.Interface | TypeAttributes.Abstract);
+		AssertEquals ("Interfaces should default to no base type", null, tb3.BaseType);
 	}
 
+	[Test]
 	public void TestDeclaringType () {
 		TypeAttributes attrs = 0;
 		TypeBuilder tb = module.DefineType (genTypeName (), attrs);
@@ -115,6 +121,7 @@
 					  tb, tb3.DeclaringType.DeclaringType);
 	}
 
+	[Test]
 	public void TestFullName () {
 		string name = genTypeName ();
 		TypeAttributes attrs = 0;
@@ -134,16 +141,42 @@
 					  name + "+" + name2 + "+" + name3, tb3.FullName);
 	}
 
-	public void TestGUID () {
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGUIDIncomplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		try {
-			Guid g = tb.GUID;
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+		Guid g = tb.GUID;
+	}
+
+	[Test]
+	[Ignore ("Ignored until bug #59665 is fixed")]
+	public void TestGUIDComplete ()
+	{
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.CreateType ();
+		Assert(tb.GUID != Guid.Empty);
 	}
 
+	[Test]
+	[Ignore ("Ignored until bug #59665 is fixed")]
+	public void TestFixedGUIDComplete ()
+	{
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		Guid guid = Guid.NewGuid ();
+
+		ConstructorInfo guidCtor = typeof(GuidAttribute).GetConstructor(
+			new Type[] {typeof(string)});
+
+		CustomAttributeBuilder caBuilder = new CustomAttributeBuilder (guidCtor,
+			new object[] { guid.ToString("D") }, new FieldInfo[0], new object[0]);
+
+		tb.SetCustomAttribute (caBuilder);
+		tb.CreateType ();
+		AssertEquals (guid, tb.GUID);
+	}
+
+	[Test]
 	public void TestHasElementType () {
 		// According to the MSDN docs, this member works, but in reality, it
 		// returns a NotSupportedException
@@ -156,6 +189,7 @@
 		}
 	}
 
+	[Test]
 	public void TestIsAbstract () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("",
@@ -166,6 +200,7 @@
 					  true, tb2.IsAbstract);
 	}
 
+	[Test]
 	public void TestIsAnsiClass () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("",
@@ -176,6 +211,7 @@
 					  false, tb2.IsAnsiClass);
 	}
 
+	[Test]
 	public void TestIsArray () {
 		// How can a TypeBuilder be an array ?
 		string name = genTypeName ();
@@ -184,6 +220,7 @@
 					  false, tb.IsArray);
 	}
 
+	[Test]
 	public void TestIsAutoClass () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("",
@@ -192,8 +229,9 @@
 		TypeBuilder tb2 = module.DefineType (genTypeName (), TypeAttributes.AutoClass);
 		AssertEquals ("",
 					  true, tb2.IsAutoClass);
-	}	
+	}
 
+	[Test]
 	public void TestIsAutoLayout () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("AutoLayout defaults to true",
@@ -204,6 +242,7 @@
 					  false, tb2.IsAutoLayout);
 	}
 
+	[Test]
 	public void TestIsByRef () {
 		// How can a TypeBuilder be ByRef ?
 		TypeBuilder tb = module.DefineType (genTypeName ());
@@ -211,6 +250,7 @@
 					  false, tb.IsByRef);
 	}
 
+	[Test]
 	public void TestIsClass () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("Most types are classes",
@@ -229,189 +269,196 @@
 					  false, tb4.IsClass);
 	}
 
+	[Test]
 	public void TestIsCOMObject () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("Probably not",
-					  false, tb.IsCOMObject);
+		AssertEquals ("Probably not", false, tb.IsCOMObject);
+
+		tb = module.DefineType (genTypeName (), TypeAttributes.Import);
+		AssertEquals ("type with Import attribute is COM object",
+			true, tb.IsCOMObject);
 	}
 
+	[Test]
 	public void TestIsContextful () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("",
-					  false, tb.IsContextful);
+		AssertEquals (false, tb.IsContextful);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), 0, typeof (ContextBoundObject));
-		AssertEquals ("",
-					  true, tb2.IsContextful);
+		AssertEquals (true, tb2.IsContextful);
 	}
 
+	[Test]
 	public void TestIsEnum () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("",
-					  false, tb.IsEnum);
+		AssertEquals (false, tb.IsEnum);
 
 		// This returns true under both mono and MS .NET ???
 		TypeBuilder tb2 = module.DefineType (genTypeName (), 0, typeof (ValueType));
 		AssertEquals ("value types are not necessary enums",
-					  false, tb2.IsEnum);
+			false, tb2.IsEnum);
 
 		TypeBuilder tb3 = module.DefineType (genTypeName (), 0, typeof (Enum));
-		AssertEquals ("enums are enums",
-					  true, tb3.IsEnum);
+		AssertEquals ("enums are enums", true, tb3.IsEnum);
 	}
 
+	[Test]
 	public void TestIsExplicitLayout () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("ExplicitLayout defaults to false",
-					  false, tb.IsExplicitLayout);
+			false, tb.IsExplicitLayout);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), TypeAttributes.ExplicitLayout);
-		AssertEquals ("",
-					  true, tb2.IsExplicitLayout);
+		AssertEquals (true, tb2.IsExplicitLayout);
 	}
 
+	[Test]
 	public void TestIsImport () {
 		// How can this be true ?
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("",
-					  false, tb.IsImport);
+		AssertEquals (false, tb.IsImport);
 	}
 
+	[Test]
 	public void TestIsInterface () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("Most types are not interfaces",
-					  false, tb.IsInterface);
+			false, tb.IsInterface);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), TypeAttributes.Interface | TypeAttributes.Abstract);
 		AssertEquals ("Interfaces are interfaces",
-					  true, tb2.IsInterface);
+			true, tb2.IsInterface);
 
 		TypeBuilder tb3 = module.DefineType (genTypeName (), 0, typeof (ValueType));
 		AssertEquals ("value types are not interfaces",
-					  false, tb3.IsInterface);
+			false, tb3.IsInterface);
 	}
 
+	[Test]
 	public void TestIsLayoutSequential () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("SequentialLayout defaults to false",
-					  false, tb.IsLayoutSequential);
+			false, tb.IsLayoutSequential);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), TypeAttributes.SequentialLayout);
-		AssertEquals ("",
-					  true, tb2.IsLayoutSequential);
+		AssertEquals (true, tb2.IsLayoutSequential);
 	}
 
+	[Test]
 	public void TestIsMarshalByRef () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("",
-					  false, tb.IsMarshalByRef);
+		AssertEquals (false, tb.IsMarshalByRef);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), 0, typeof (MarshalByRefObject));
-		AssertEquals ("",
-					  true, tb2.IsMarshalByRef);
+		AssertEquals (true, tb2.IsMarshalByRef);
 
 		TypeBuilder tb3 = module.DefineType (genTypeName (), 0, typeof (ContextBoundObject));
-		AssertEquals ("",
-					  true, tb3.IsMarshalByRef);
+		AssertEquals (true, tb3.IsMarshalByRef);
 	}
 
 	// TODO: Visibility properties
 
+	[Test]
 	public void TestIsPointer () {
 		// How can this be true?
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("",
-					  false, tb.IsPointer);
+		AssertEquals (false, tb.IsPointer);
 	}
 
+	[Test]
 	public void TestIsPrimitive () {
 		TypeBuilder tb = module.DefineType ("int");
-		AssertEquals ("",
-					  false, tb.IsPrimitive);
+		AssertEquals (false, tb.IsPrimitive);
 	}
 
+	[Test]
 	public void IsSealed () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("Sealed defaults to false",
-					  false, tb.IsSealed);
+			false, tb.IsSealed);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), TypeAttributes.Sealed);
-		AssertEquals ("IsSealed works",
-					  true, tb2.IsSealed);
+		AssertEquals ("IsSealed works", true, tb2.IsSealed);
 	}
 
+	[Test]
 	public void IsSerializable () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("",
-					  false, tb.IsSerializable);
+		AssertEquals (false, tb.IsSerializable);
 
-		tb.SetCustomAttribute (new CustomAttributeBuilder (typeof (SerializableAttribute).GetConstructors (BindingFlags.Public)[0], null));
-		AssertEquals ("",
-					  true, tb.IsSerializable);
+		ConstructorInfo[] ctors = typeof (SerializableAttribute).GetConstructors (BindingFlags.Instance | BindingFlags.Public);
+		Assert ("SerializableAttribute should have more than 0 public instance ctors", 
+			ctors.Length > 0);
+
+		tb.SetCustomAttribute (new CustomAttributeBuilder (ctors[0], new object[0]));
+		Type createdType = tb.CreateType ();
+
+		assembly.Save ("TestAssembly.dll");
+		AssertEquals (true, createdType.IsSerializable);
 	}
 
+	[Test]
 	public void TestIsSpecialName () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("SpecialName defaults to false",
-					  false, tb.IsSpecialName);
+			false, tb.IsSpecialName);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), TypeAttributes.SpecialName);
 		AssertEquals ("IsSpecialName works",
-					  true, tb2.IsSpecialName);
+			true, tb2.IsSpecialName);
 	}
 
+	[Test]
 	public void TestIsUnicodeClass () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("",
-					  false, tb.IsUnicodeClass);
+		AssertEquals (false, tb.IsUnicodeClass);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), TypeAttributes.UnicodeClass);
-		AssertEquals ("",
-					  true, tb2.IsUnicodeClass);
+		AssertEquals (true, tb2.IsUnicodeClass);
 	}
 
+	[Test]
 	public void TestIsValueType () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("Most types are not value types",
-					  false, tb.IsValueType);
+			false, tb.IsValueType);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), TypeAttributes.Interface | TypeAttributes.Abstract);
 		AssertEquals ("Interfaces are not value types",
-					  false, tb2.IsValueType);
+			false, tb2.IsValueType);
 
 		TypeBuilder tb3 = module.DefineType (genTypeName (), 0, typeof (ValueType));
 		AssertEquals ("value types are value types",
-					  true, tb3.IsValueType);
+			true, tb3.IsValueType);
 
 		TypeBuilder tb4 = module.DefineType (genTypeName (), 0, typeof (Enum));
 		AssertEquals ("enums are value types",
-					  true, tb4.IsValueType);
+			true, tb4.IsValueType);
 	}
 
+	[Test]
 	public void TestMemberType () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		AssertEquals ("A type is a type",
-					  MemberTypes.TypeInfo, tb.MemberType);
+			MemberTypes.TypeInfo, tb.MemberType);
 	}
 
+	[Test]
 	public void TestModule () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("Module works",
-					  module, tb.Module);
+		AssertEquals ("Module works", module, tb.Module);
 	}
 
+	[Test]
 	public void TestName () {
 		TypeBuilder tb = module.DefineType ("A");
-		AssertEquals ("",
-					  "A", tb.Name);
+		AssertEquals ("A", tb.Name);
 
 		TypeBuilder tb2 = module.DefineType ("A.B.C.D.E");
-		AssertEquals ("",
-					  "E", tb2.Name);
+		AssertEquals ("E", tb2.Name);
 
 		TypeBuilder tb3 = tb2.DefineNestedType ("A");
-		AssertEquals ("",
-					  "A", tb3.Name);
+		AssertEquals ("A", tb3.Name);
 
 		/* Is .E a valid name ?
 		TypeBuilder tb4 = module.DefineType (".E");
@@ -420,18 +467,16 @@
 		*/
 	}
 
+	[Test]
 	public void TestNamespace () {
 		TypeBuilder tb = module.DefineType ("A");
-		AssertEquals ("",
-					  "", tb.Namespace);
+		AssertEquals ("", tb.Namespace);
 
 		TypeBuilder tb2 = module.DefineType ("A.B.C.D.E");
-		AssertEquals ("",
-					  "A.B.C.D", tb2.Namespace);
+		AssertEquals ("A.B.C.D", tb2.Namespace);
 
 		TypeBuilder tb3 = tb2.DefineNestedType ("A");
-		AssertEquals ("",
-					  "", tb3.Namespace);
+		AssertEquals ("", tb3.Namespace);
 
 		/* Is .E a valid name ?
 		TypeBuilder tb4 = module.DefineType (".E");
@@ -440,82 +485,98 @@
 		*/		
 	}
 
+	[Test]
 	public void TestPackingSize () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("",
-					  PackingSize.Unspecified, tb.PackingSize);
+		AssertEquals (PackingSize.Unspecified, tb.PackingSize);
 
 		TypeBuilder tb2 = module.DefineType (genTypeName (), 0, typeof (object),
-											 PackingSize.Size16, 16);
-		AssertEquals ("",
-					  PackingSize.Size16, tb2.PackingSize);
+			PackingSize.Size16, 16);
+		AssertEquals (PackingSize.Size16, tb2.PackingSize);
 	}
 
+	[Test]
 	public void TestReflectedType () {
 		// It is the same as DeclaringType, but why?
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		AssertEquals ("",
-					  null, tb.ReflectedType);
+		AssertEquals (null, tb.ReflectedType);
 
 		TypeBuilder tb2 = tb.DefineNestedType (genTypeName ());
-		AssertEquals ("",
-					  tb, tb2.ReflectedType);
+		AssertEquals (tb, tb2.ReflectedType);
+	}
+
+	[Test]
+	[ExpectedException (typeof(ArgumentNullException))]
+	public void TestSetParentNull ()
+	{
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.SetParent (null);
+	}
+
+	[Test]
+	public void TestSetParentIncomplete ()
+	{
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.SetParent (typeof(Attribute));
+		AssertEquals (typeof(Attribute), tb.BaseType);
 	}
 
+	[Test]
+	[ExpectedException (typeof(InvalidOperationException))]
+	public void TestSetParentComplete ()
+	{
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.CreateType ();
+		tb.SetParent (typeof(Attribute));
+	}
+
+	[Test]
 	public void TestSize () {
 		{
 			TypeBuilder tb = module.DefineType (genTypeName ());
-			AssertEquals ("",
-						  0, tb.Size);
+			AssertEquals (0, tb.Size);
 			tb.CreateType ();
-			AssertEquals ("",
-						  0, tb.Size);
+			AssertEquals (0, tb.Size);
 		}
 
 		{
 			TypeBuilder tb = module.DefineType (genTypeName (), 0, typeof (object),
-												PackingSize.Size16, 32);
-			AssertEquals ("",
-						  32, tb.Size);
+				PackingSize.Size16, 32);
+			AssertEquals (32, tb.Size);
 		}
 	}
 
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
 	public void TestTypeHandle () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		try {
-			RuntimeTypeHandle handle = tb.TypeHandle;
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+		RuntimeTypeHandle handle = tb.TypeHandle;
 	}
 
-	public void TestTypeInitializer () {
-		// According to the MSDN docs, this works, but it doesn't
-		/* TODO:
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestTypeInitializerIncomplete ()
+	{
 		TypeBuilder tb = module.DefineType (genTypeName ());
-		try {
-			ConstructorInfo cb = tb.TypeInitializer;
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
-		*/
+		ConstructorInfo cb = tb.TypeInitializer;
+	}
+
+	[Test]
+	public void TestTypeInitializerComplete ()
+	{
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.CreateType ();
+		ConstructorInfo cb = tb.TypeInitializer;
 	}
 
+	[Test]
 	public void TestTypeToken () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		TypeToken token = tb.TypeToken;
 	}
 
+	[Test]
 	public void TestUnderlyingSystemType () {
-		//
-		// For non-enum types, UnderlyingSystemType should return itself.
-		// But if I modify the code to do this, I get an exception in mcs.
-		// Reason: the enums created during corlib compilation do not seem
-		// to be an enum according to IsEnum.
-		//
-		/*
 		{
 			TypeBuilder tb = module.DefineType (genTypeName ());
 			AssertEquals ("For non-enums this equals itself",
@@ -523,15 +584,13 @@
 		}
 		{
 			TypeBuilder tb = module.DefineType (genTypeName (), TypeAttributes.Interface | TypeAttributes.Abstract);
-			AssertEquals ("",
-						  tb, tb.UnderlyingSystemType);
+			AssertEquals (tb, tb.UnderlyingSystemType);
 		}
 		{
 			TypeBuilder tb = module.DefineType (genTypeName (), 0, typeof (ValueType));
-			AssertEquals ("",
-						  tb, tb.UnderlyingSystemType);
+			AssertEquals (tb, tb.UnderlyingSystemType);
 		}
-		*/
+
 		{
 			TypeBuilder tb = module.DefineType (genTypeName (), 0, typeof (Enum));
 			try {
@@ -542,11 +601,11 @@
 			}
 
 			tb.DefineField ("val", typeof (int), 0);
-			AssertEquals ("",
-						  typeof (int), tb.UnderlyingSystemType);
+			AssertEquals (typeof (int), tb.UnderlyingSystemType);
 		}
 	}
 
+	[Test]
 	public void TestAddInterfaceImplementation () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		try {
@@ -572,6 +631,7 @@
 		}
 	}
 
+	[Test]
 	public void TestCreateType () {
 		// TODO: LOTS OF TEST SHOULD GO THERE
 		TypeBuilder tb = module.DefineType (genTypeName ());
@@ -586,6 +646,7 @@
 		}
 	}
 
+	[Test]
 	public void TestDefineConstructor () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 
@@ -602,11 +663,10 @@
 		}
 	}
 
+	[Test]
 	public void TestDefineDefaultConstructor () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
-
 		tb.DefineDefaultConstructor (0);
-
 		tb.CreateType ();
 
 		// Can not be called on a created type, altough the MSDN docs does not mention this
@@ -618,6 +678,7 @@
 		}
 	}
 
+	[Test]
 	public void TestDefineEvent () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 
@@ -653,6 +714,7 @@
 		}
 	}
 
+	[Test]
 	public void TestDefineField () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 
@@ -697,6 +759,7 @@
 		}
 	}
 
+	[Test]
 	public void TestDefineInitializedData () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 		
@@ -812,6 +875,7 @@
 		Marshal.FreeHGlobal (ptr);
 	}
 
+	[Test]
 	public void TestDefineMethod () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 
@@ -851,6 +915,7 @@
 
 	// TODO: DefineMethodOverride
 
+	[Test]
 	public void TestDefineNestedType () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 
@@ -932,6 +997,7 @@
 		// TODO:
 	}
 
+	[Test]
 	public void TestDefinePInvokeMethod () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 
@@ -963,6 +1029,7 @@
 		}
 	}
 
+	[Test]
 	public void TestDefineProperty () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
 
@@ -974,82 +1041,518 @@
 		}
 	}
 
-	/* IsDefined actually works under mono */
-	/*
-	public void TestIsDefined () {
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestIsDefinedIncomplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.IsDefined (typeof (int), true);
+	}
 
-		try {
-			tb.IsDefined (typeof (int), true);
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+	[Test]
+	public void TestIsDefinedComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		ConstructorInfo obsoleteCtor = typeof(ObsoleteAttribute).GetConstructor(
+			new Type[] {typeof(string)});
+
+		CustomAttributeBuilder caBuilder = new CustomAttributeBuilder (obsoleteCtor,
+			new object[] { "obsolete message" }, new FieldInfo[0], new object[0]);
+
+		tb.SetCustomAttribute (caBuilder);
+		tb.CreateType ();
+		AssertEquals (true, tb.IsDefined (typeof(ObsoleteAttribute), false));
 	}
-	*/
 
-	/* FIXME: This does not work under mono
-	public void TestGetEvents () {
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetCustomAttributesIncomplete ()
+	{
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetCustomAttributes (false);
+	}
 
-		try {
-			tb.GetEvents ();
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+	[Test]
+	public void TestGetCustomAttributesComplete ()
+	{
+		TypeBuilder tb = module.DefineType (genTypeName ());
 
-		try {
-			tb.GetEvents (BindingFlags.Public);
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+		ConstructorInfo guidCtor = typeof(GuidAttribute).GetConstructor (
+			new Type[] { typeof(string) });
+
+		CustomAttributeBuilder caBuilder = new CustomAttributeBuilder (guidCtor,
+			new object[] { Guid.NewGuid ().ToString ("D") }, new FieldInfo[0], new object[0]);
+
+		tb.SetCustomAttribute (caBuilder);
+		tb.CreateType ();
+
+		AssertEquals (1, tb.GetCustomAttributes (false).Length);
 	}
-	*/
 
-	public void TestGetEvent () {
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetCustomAttributesOfTypeIncomplete ()
+	{
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetCustomAttributes (typeof(ObsoleteAttribute), false);
+	}
 
-		try {
-			tb.GetEvent ("FOO", BindingFlags.Public);
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+	[Test]
+	public void TestGetCustomAttributesOfTypeComplete ()
+	{
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		ConstructorInfo guidCtor = typeof(GuidAttribute).GetConstructor (
+			new Type[] { typeof(string) });
+
+		CustomAttributeBuilder caBuilder = new CustomAttributeBuilder (guidCtor,
+			new object[] { Guid.NewGuid ().ToString ("D") }, new FieldInfo[0], new object[0]);
+
+		tb.SetCustomAttribute (caBuilder);
+		tb.CreateType ();
+
+		AssertEquals (1, tb.GetCustomAttributes (typeof(GuidAttribute), false).Length);
+		AssertEquals (0, tb.GetCustomAttributes (typeof(ObsoleteAttribute), false).Length);
 	}
 
-	public void TestGetMember () {
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetCustomAttributesOfNullTypeIncomplete ()
+	{
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetCustomAttributes (null, false);
+	}
 
-		try {
-			tb.GetMember ("FOO", MemberTypes.All, BindingFlags.Public);
-			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+	[Test]
+	[ExpectedException (typeof(ArgumentNullException))]
+	public void TestGetCustomAttributesOfNullTypeComplete ()
+	{
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.CreateType ();
+		tb.GetCustomAttributes (null, false);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetEventsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetEvents ();
+	}
+
+	[Test]
+	public void TestGetEventsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		MethodBuilder onclickMethod = tb.DefineMethod ("OnChange", MethodAttributes.Public, 
+			typeof(void), new Type[] { typeof(Object) });
+		onclickMethod.GetILGenerator ().Emit (OpCodes.Ret);
+
+		// create public event
+		EventBuilder eventbuilder = tb.DefineEvent ("Change", EventAttributes.None,
+			typeof(ResolveEventHandler));
+		eventbuilder.SetRaiseMethod (onclickMethod);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetEvents ().Length);
+		AssertEquals (tb.GetEvents ().Length, emittedType.GetEvents ().Length);
+	}
+
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetEventsFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetEvents (BindingFlags.Public);
+	}
+
+	[Test]
+	public void TestGetEventsFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		MethodBuilder onchangeMethod = tb.DefineMethod ("OnChange", MethodAttributes.Public,
+			typeof(void), new Type[] { typeof(Object) });
+		onchangeMethod.GetILGenerator ().Emit (OpCodes.Ret);
+
+		// create public event
+		EventBuilder changeEvent = tb.DefineEvent ("Change", EventAttributes.None,
+			typeof(ResolveEventHandler));
+		changeEvent.SetRaiseMethod (onchangeMethod);
+
+		// create non-public event
+		EventBuilder redoChangeEvent = tb.DefineEvent ("RedoChange", EventAttributes.None,
+			typeof(ResolveEventHandler));
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetEvents (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (1, tb.GetEvents (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (2, tb.GetEvents (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length);
+		AssertEquals (tb.GetEvents (BindingFlags.Instance | BindingFlags.Public).Length,
+			emittedType.GetEvents (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (tb.GetEvents (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetEvents (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (tb.GetEvents (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length,
+			emittedType.GetEvents (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetEventIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetEvent ("FOO");
+	}
+
+	[Test]
+	public void TestGetEventComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		MethodBuilder onclickMethod = tb.DefineMethod ("OnChange", MethodAttributes.Public,
+			typeof(void), new Type[] { typeof(Object) });
+		onclickMethod.GetILGenerator ().Emit (OpCodes.Ret);
+
+		EventBuilder eventbuilder = tb.DefineEvent ("Change", EventAttributes.None,
+			typeof(ResolveEventHandler));
+		eventbuilder.SetRaiseMethod (onclickMethod);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (tb.GetEvent ("Change"));
+		AssertEquals (tb.GetEvent ("Change"), emittedType.GetEvent ("Change"));
+		AssertNull (tb.GetEvent ("NotChange"));
+		AssertEquals (tb.GetEvent ("NotChange"), emittedType.GetEvent ("NotChange"));
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetEventFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetEvent ("FOO", BindingFlags.Public);
+	}
+
+	[Test]
+	public void TestGetEventFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+
+		MethodBuilder onclickMethod = tb.DefineMethod ("OnChange", MethodAttributes.Public,
+			typeof(void), new Type[] { typeof(Object) });
+		onclickMethod.GetILGenerator ().Emit (OpCodes.Ret);
+
+		EventBuilder eventbuilder = tb.DefineEvent ("Change", EventAttributes.None,
+			typeof(ResolveEventHandler));
+		eventbuilder.SetRaiseMethod (onclickMethod);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (tb.GetEvent ("Change", BindingFlags.Instance | BindingFlags.Public));
+		AssertEquals (tb.GetEvent ("Change", BindingFlags.Instance | BindingFlags.Public),
+			emittedType.GetEvent ("Change", BindingFlags.Instance | BindingFlags.Public));
+		AssertNull (tb.GetEvent ("Change", BindingFlags.Instance | BindingFlags.NonPublic));
+		AssertEquals (tb.GetEvent ("Change", BindingFlags.Instance | BindingFlags.NonPublic),
+			emittedType.GetEvent ("Change", BindingFlags.Instance | BindingFlags.NonPublic));
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetFieldsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetFields ();
+	}
+
+	[Test]
+	public void TestGetFieldsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("TestField", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetFields ().Length);
+		AssertEquals (tb.GetFields ().Length, emittedType.GetFields().Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetFieldsFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetFields (BindingFlags.Instance | BindingFlags.Public);
+	}
+
+	[Test]
+	public void TestGetFieldsFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("TestField", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetFields (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (tb.GetFields (BindingFlags.Instance | BindingFlags.Public).Length, 
+			emittedType.GetFields (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (0, tb.GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (tb.GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetFields (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetFieldIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetField ("test");
+	}
+
+	[Test]
+	public void TestGetFieldComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("TestField", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (tb.GetField ("TestField"));
+		AssertEquals (tb.GetField ("TestField"), emittedType.GetField ("TestField"));
+		AssertNull (tb.GetField ("TestOtherField"));
+		AssertEquals (tb.GetField ("TestOtherField"), 
+			emittedType.GetField ("TestOtherField"));
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetFieldFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetField ("test", BindingFlags.Public);
+	}
+
+	[Test]
+	public void TestGetFieldFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("TestField", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (tb.GetField ("TestField", BindingFlags.Instance | BindingFlags.Public));
+		AssertEquals (tb.GetField ("TestField", BindingFlags.Instance | BindingFlags.Public),
+			emittedType.GetField ("TestField", BindingFlags.Instance | BindingFlags.Public));
+		AssertNull (tb.GetField ("TestField", BindingFlags.Instance | BindingFlags.NonPublic));
+		AssertEquals (tb.GetField ("TestField", BindingFlags.Instance | BindingFlags.NonPublic),
+			emittedType.GetField ("TestField", BindingFlags.Instance | BindingFlags.NonPublic));
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetPropertiesIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetProperties ();
+	}
+
+	[Test]
+	public void TestGetPropertiesComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		DefineStringProperty (tb, "CustomerName", "customerName", MethodAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetProperties ().Length);
+		AssertEquals (tb.GetProperties ().Length, emittedType.GetProperties ().Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetPropertiesFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetProperties (BindingFlags.Public);
+	}
+
+	[Test]
+	public void TestGetPropertiesFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		DefineStringProperty (tb, "CustomerName", "customerName", MethodAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetProperties (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (tb.GetProperties (BindingFlags.Instance | BindingFlags.Public).Length,
+			emittedType.GetProperties (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (0, tb.GetProperties (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (tb.GetProperties (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetProperties (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetPropertyIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetProperty ("test");
 	}
 
-	public void TestGetMembers () {
+	[Test]
+	public void TestGetPropertyComplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		DefineStringProperty (tb, "CustomerName", "customerName", MethodAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (emittedType.GetProperty ("CustomerName"));
+		AssertNull (emittedType.GetProperty ("OtherCustomerName"));
 
 		try {
-			tb.GetMembers (BindingFlags.Public);
+			tb.GetProperty ("CustomerName");
 			Fail ();
-		}
-		catch (NotSupportedException) {
-		}
+		} catch (NotSupportedException) {}
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetPropertyFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetProperty ("test", BindingFlags.Public);
 	}
 
-	public void TestGetInterface () {
+	[Test]
+	public void TestGetPropertyFlagsComplete () {
 		TypeBuilder tb = module.DefineType (genTypeName ());
+		DefineStringProperty (tb, "CustomerName", "customerName", MethodAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertNotNull (emittedType.GetProperty ("CustomerName", BindingFlags.Instance | 
+			BindingFlags.Public));
+		AssertNull (emittedType.GetProperty ("CustomerName", BindingFlags.Instance |
+			BindingFlags.NonPublic));
 
 		try {
-			tb.GetInterface ("FOO", true);
+			tb.GetProperty ("CustomerName", BindingFlags.Instance | BindingFlags.Public);
 			Fail ();
 		}
-		catch (NotSupportedException) {
-		}
+		catch (NotSupportedException) { }
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMethodsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMethods ();
+	}
+
+	[Test]
+	public void TestGetMethodsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		MethodBuilder helloMethod = tb.DefineMethod ("HelloMethod", 
+			MethodAttributes.Public, typeof(string), new Type[0]);
+		ILGenerator helloMethodIL = helloMethod.GetILGenerator ();
+		helloMethodIL.Emit (OpCodes.Ldstr, "Hi! ");
+		helloMethodIL.Emit (OpCodes.Ldarg_1);
+		MethodInfo infoMethod = typeof(string).GetMethod ("Concat", 
+			new Type[] { typeof(string), typeof(string) });
+		helloMethodIL.Emit (OpCodes.Call, infoMethod);
+		helloMethodIL.Emit (OpCodes.Ret);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (typeof(object).GetMethods (BindingFlags.Public | BindingFlags.Instance).Length + 1, 
+			tb.GetMethods ().Length);
+		AssertEquals (tb.GetMethods ().Length, emittedType.GetMethods ().Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMethodsFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMethods (BindingFlags.Public);
+	}
+
+	[Test]
+	public void TestGetMethodsFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		MethodBuilder helloMethod = tb.DefineMethod ("HelloMethod",
+			MethodAttributes.Public, typeof(string), new Type[0]);
+		ILGenerator helloMethodIL = helloMethod.GetILGenerator ();
+		helloMethodIL.Emit (OpCodes.Ldstr, "Hi! ");
+		helloMethodIL.Emit (OpCodes.Ldarg_1);
+		MethodInfo infoMethod = typeof(string).GetMethod ("Concat", 
+			new Type[] { typeof(string), typeof(string) });
+		helloMethodIL.Emit (OpCodes.Call, infoMethod);
+		helloMethodIL.Emit (OpCodes.Ret);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetMethods (BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly).Length);
+		AssertEquals (tb.GetMethods (BindingFlags.Instance | BindingFlags.Public).Length,
+			emittedType.GetMethods (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (0, tb.GetMethods (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly).Length);
+		AssertEquals (tb.GetMethods (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetMethods (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMemberIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMember ("FOO", MemberTypes.All, BindingFlags.Public);
+	}
+
+	[Test]
+	public void TestGetMemberComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("FOO", typeof(int), FieldAttributes.Private);
+
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (1, tb.GetMember ("FOO", MemberTypes.Field, BindingFlags.Instance | BindingFlags.NonPublic).Length);
+		AssertEquals (0, tb.GetMember ("FOO", MemberTypes.Field, BindingFlags.Instance | BindingFlags.Public).Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMembersIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMembers ();
+	}
+
+	[Test]
+	public void TestGetMembersComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		Type emittedType = tb.CreateType ();
+
+		AssertEquals (tb.GetMembers ().Length, emittedType.GetMembers ().Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetMembersFlagsIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetMembers (BindingFlags.Public);
+	}
+
+	[Test]
+	public void TestGetMembersFlagsComplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.DefineField ("FOO", typeof(int), FieldAttributes.Public);
+
+		Type emittedType = tb.CreateType ();
+
+		Assert (tb.GetMembers (BindingFlags.Instance | BindingFlags.Public).Length != 0);
+		AssertEquals (tb.GetMembers (BindingFlags.Instance | BindingFlags.Public).Length,
+			emittedType.GetMembers (BindingFlags.Instance | BindingFlags.Public).Length);
+		AssertEquals (tb.GetMembers (BindingFlags.Instance | BindingFlags.NonPublic).Length,
+			emittedType.GetMembers (BindingFlags.Instance | BindingFlags.NonPublic).Length);
+	}
+
+	[Test]
+	[ExpectedException (typeof(NotSupportedException))]
+	public void TestGetInterfaceIncomplete () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		tb.GetInterface ("FOO", true);
+	}
+
+	[Test]
+	public void TestGetInterfaces () {
+		TypeBuilder tb = module.DefineType (genTypeName ());
+		Type[] interfaces = tb.GetInterfaces ();
+		AssertEquals (0, interfaces.Length);
+
+		TypeBuilder tbInterface = module.DefineType (genTypeName (), TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract);
+		Type emittedInterface = tbInterface.CreateType ();
+
+		tb = module.DefineType (genTypeName (), TypeAttributes.Public, typeof(object), new Type[] { emittedInterface });
+		interfaces = tb.GetInterfaces ();
+		AssertEquals (1, interfaces.Length);
 	}
 
 	[Test]
@@ -1100,7 +1603,7 @@
 		tb.AddDeclarativeSecurity (SecurityAction.Demand, set);
 	}
 
-	/* Test for dynamically generated enums */
+	[Test]
 	public void TestEnums () {
 		TypeAttributes typeAttrs = TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed;            
 		TypeBuilder enumToCreate = module.DefineType(genTypeName (), typeAttrs, 
@@ -1108,28 +1611,67 @@
 		enumToCreate.SetCustomAttribute (new CustomAttributeBuilder (typeof (FlagsAttribute).GetConstructors ()[0], new Type [0]));
 		// add value__ field, see DefineEnum method of ModuleBuilder
 		enumToCreate.DefineField("value__", typeof(Int32), 
-								 FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
-        
+			FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName);
+
 		// add enum entries
 		FieldBuilder fb = enumToCreate.DefineField("A", enumToCreate, 
-												   FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
+			FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
 		fb.SetConstant((Int32) 0);
-            
+
 		fb = enumToCreate.DefineField("B", enumToCreate, 
-									  FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
+			FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
 		fb.SetConstant((Int32) 1);
 
 		fb = enumToCreate.DefineField("C", enumToCreate, 
-									  FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
+			FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal);
 		fb.SetConstant((Int32) 2);
-            
+
 		Type enumType = enumToCreate.CreateType();
-            
+
 		object enumVal = Enum.ToObject(enumType, (Int32) 3);
 
 		AssertEquals ("B, C", enumVal.ToString ());
 		AssertEquals (3, (Int32)enumVal);
-	}            
+	}
+
+	private void DefineStringProperty (TypeBuilder tb, string propertyName, string fieldName, MethodAttributes methodAttribs) {
+		// define the field holding the property value
+		FieldBuilder fieldBuilder = tb.DefineField (fieldName,
+			typeof(string), FieldAttributes.Private);
+
+		PropertyBuilder propertyBuilder = tb.DefineProperty (
+			propertyName, PropertyAttributes.HasDefault, typeof(string),
+			new Type[] { typeof(string) });
+
+		// First, we'll define the behavior of the "get" property for CustomerName as a method.
+		MethodBuilder getMethodBuilder = tb.DefineMethod ("Get" + propertyName,
+								methodAttribs,
+								typeof(string),
+								new Type[] { });
+
+		ILGenerator getIL = getMethodBuilder.GetILGenerator ();
+
+		getIL.Emit (OpCodes.Ldarg_0);
+		getIL.Emit (OpCodes.Ldfld, fieldBuilder);
+		getIL.Emit (OpCodes.Ret);
+
+		// Now, we'll define the behavior of the "set" property for CustomerName.
+		MethodBuilder setMethodBuilder = tb.DefineMethod ("Set" + propertyName,
+								methodAttribs,
+								null,
+								new Type[] { typeof(string) });
+
+		ILGenerator setIL = setMethodBuilder.GetILGenerator ();
+
+		setIL.Emit (OpCodes.Ldarg_0);
+		setIL.Emit (OpCodes.Ldarg_1);
+		setIL.Emit (OpCodes.Stfld, fieldBuilder);
+		setIL.Emit (OpCodes.Ret);
+
+		// Last, we must map the two methods created above to our PropertyBuilder to 
+		// their corresponding behaviors, "get" and "set" respectively. 
+		propertyBuilder.SetGetMethod (getMethodBuilder);
+		propertyBuilder.SetSetMethod (setMethodBuilder);
+	}
 }
 }
-
