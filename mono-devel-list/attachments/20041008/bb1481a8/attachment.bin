#!/usr/bin/perl -W
#
# Value-type stubber
#
# Creates a new value type for a C typedef, such as off_t.
#
# Syntax: stub-vt.pl csharp-type underyling-type [list of coercible types]
#
# Example: stub-vt.pl off_t long int

use strict;

my $new_type = shift @ARGV;
my $impl_type = shift @ARGV;
my @to_types = @ARGV;

if (!defined ($new_type) || !defined ($impl_type)) {
	print "error: insufficient arguments\n";
	print "Syntax: $0 <new-type> <impl-type> [aliases]\n";
	exit 0;
}

my $cmd_line = "stub-vt.pl $new_type $impl_type " . join (" ", @to_types);

print <<EOF;
// 
// Generated file: DO NOT MODIFY!
//
// File generated by: $cmd_line
//

namespace Mono.Posix {

	public struct $new_type 
		: System.IFormattable, System.IConvertible, System.IComparable
#if NET_2_0
		, System.IComparable<$new_type>
#endif
	{
		private $impl_type value;

		public $new_type ($impl_type value)
		{
			this.value = value;
		}

		public $impl_type Value {
			get {return this.value;}
			set {this.value = value;}
		}

		//
		// Base class overrides
		// 

		public override bool Equals (object o)
		{
			if (!(o is $new_type))
				return false;
			return this.value.Equals (o);
		}

		public override int GetHashCode ()
		{
			return this.value.GetHashCode ();
		}

		public override string ToString ()
		{
			return this.value.ToString ();
		}

#if NET_2_0
		//
		// IComparable<$new_type> Methods
		//
		public int CompareTo ($new_type value)
		{
			return this.value.CompareTo (value.value);
		}

		public bool Equals ($new_type value)
		{
			return this.value.Equals (value.value);
		}
#endif

		//
		// IComparable Methods
		//
		public int CompareTo (object v)
		{
			if (v == null)
				return 1;
			if (!(v is $new_type))
				throw new System.ArgumentException (Locale.GetText ("Value is not a Mono.Posix.$new_type"));
			$new_type xv = ($new_type) v;
			return this.value.CompareTo (xv.value);
		}

		//
		// IFormattable Methods
		//
		public string ToString (System.IFormatProvider fp)
		{
			return this.value.ToString (fp);
		}

		public string ToString (string format)
		{
			return this.value.ToString (format);
		}

		public string ToString (string format, System.IFormatProvider fp)
		{
			return this.value.ToString (format, fp);
		}

		//
		// IConvertible Methods
		//
		public System.TypeCode GetTypeCode ()
		{
			return this.value.GetTypeCode ();
		}

		object System.IConvertible.ToType (System.Type conversionType, System.IFormatProvider provider)
		{
			System.IConvertible c = this.value;
			return c.ToType (conversionType, provider);
		}
EOF

my %methods = (
	ToBoolean   => "bool",
	ToByte      => "byte", 
	ToSByte     => "sbyte", 
	ToChar      => "char", 
	ToDateTime  => "System.DateTime", 
	ToDecimal   => "decimal", 
	ToSingle    => "float", 
	ToDouble    => "double", 
	ToInt16     => "short", 
	ToInt32     => "int", 
	ToInt64     => "long", 
	ToUInt16    => "ushort", 
	ToUInt32    => "uint", 
	ToUInt64    => "ulong"
);

for my $method (keys (%methods)) {
	my $rtype = $methods{$method};
	print <<EOF;

		$rtype System.IConvertible.$method (System.IFormatProvider provider)
		{
			return System.Convert.$method (this.value);
		}
EOF
}

print <<EOF;

		//
		// Implicit Operators
		//
		public static implicit operator $impl_type ($new_type v)
		{
			return v.Value;
		}
EOF

for my $type (@to_types) {
	print <<EOF;

		public static implicit operator $type ($new_type v)
		{
			return checked (($type) v.Value);
		}
EOF
}

print <<EOF;

		//
		// Explicit Operators
		//
		public static explicit operator $new_type ($impl_type v)
		{
			return new $new_type (v);
		}
EOF

for my $type (@to_types) {
	print <<EOF;

		public static explicit operator $new_type ($type v)
		{
			$impl_type x = checked (($impl_type) v);
			return new $new_type (x);
		}
EOF
}

print <<EOF;

		//
		// Operator Overloading
		//
		public static bool operator == ($new_type lhs, $new_type rhs)
		{
			return lhs.value == rhs.value;
		}

		public static bool operator != ($new_type lhs, $new_type rhs)
		{
			return lhs.value != rhs.value;
		}
	}
}

EOF

# vim: noexpandtab
