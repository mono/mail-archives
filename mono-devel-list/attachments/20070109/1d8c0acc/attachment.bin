Index: C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/TreeNode.cs
===================================================================
--- C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/TreeNode.cs	(revision 69123)
+++ C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/TreeNode.cs	(working copy)
@@ -54,6 +54,9 @@
 
 		internal IntPtr handle;
 		
+#if NET_2_0
+		private string name = string.Empty;
+#endif
 		#endregion	// Fields
 
 		#region Internal Constructors		
@@ -352,6 +355,18 @@
 			}
 		}
 
+#if NET_2_0
+		public string Name
+		{
+			get { return this.name; }
+			set
+			{
+				// Value should never be null as per spec
+				this.name = (value == null) ? string.Empty : value;
+			}
+		}
+#endif
+
 		public TreeNode NextNode {
 			get {
 				if (parent == null)
Index: C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/TreeNodeCollection.cs
===================================================================
--- C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/TreeNodeCollection.cs	(revision 69123)
+++ C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/TreeNodeCollection.cs	(working copy)
@@ -95,6 +95,20 @@
 			}
 		}
 
+		#if NET_2_0
+		public virtual TreeNode this[string key]
+		{
+			get
+			{
+				if(string.IsNullOrEmpty(key))
+						return null;
+
+				int index = IndexOfKey(key);
+				return (index == -1) ? null : this[index];
+			}
+		}
+		#endif
+
 		public virtual TreeNode Add (string text)
 		{
 			TreeNode res = new TreeNode (text);
@@ -442,6 +456,43 @@
 				return (res == 0 ? l.Index - r.Index : res);
 			}
 		}
+
+#if NET_2_0
+		public virtual int IndexOfKey(string key)
+		{
+			if (string.IsNullOrEmpty(key))
+				return -1;
+
+				// We do a case insensitive comparison to find the key
+			for (int i = 0; i < nodes.Count; i++)
+				if (string.Equals(nodes.Name, name, StringComparison.CurrentCultureIgnoreCase))
+					return i;
+
+			return -1;
+        }
+
+		public virtual bool ContainsKey(string name)
+		{
+			return (IndexOfKey(name) != -1);
+		}
+
+
+		public virtual void RemoveByKey(string key)
+		{
+			int index = -1;
+			for (int i = 0; i < nodes.Count; i++)
+			{
+				if (!string.Equals(nodes[i].Name,key, StringComparison.CurrentCultureIgnoreCase))
+					continue;
+
+				index = i;
+				break;
+			}
+
+			if (index != -1)
+				RemoveAt(index);
+		}
+#endif
 	}
 }
 
Index: C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/TreeView.cs
===================================================================
--- C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/TreeView.cs	(revision 69123)
+++ C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/TreeView.cs	(working copy)
@@ -549,6 +549,15 @@
 			return root_node.GetNodeCount (include_subtrees);
 		}
 
+		#if NET_2_0
+		public void Sort()
+		{
+			// Just call the pre-existing methods to sort the treeview.
+			// I assume it'll sort correctly.
+			this.Sorted = true;
+		}
+        #endif
+
 		public override string ToString () {
 			int count = Nodes.Count;
 			if (count <= 0)
Index: C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/ChangeLog
===================================================================
--- C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/ChangeLog	(revision 69123)
+++ C:/programming/mcs/class/Managed.Windows.Forms/System.Windows.Forms/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2007-1-09 Alan McGovern <alan.mcgovern@gmail.com>
+	* TreeNode.cs
+	* TreeView.cs
+	* TreeNodeCollection.cs
+	- Added some new .NET 2.0 methods
+
 2006-12-06  Jackson Harper  <jackson@ximian.com>
 
 	* TextControl.cs: Make this operation undoable.