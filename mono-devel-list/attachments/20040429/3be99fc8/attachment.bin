Index: mono/arch/alpha/alpha-codegen.h
===================================================================
RCS file: /cvs/public/mono/mono/arch/alpha/alpha-codegen.h,v
retrieving revision 1.2
diff -u -r1.2 alpha-codegen.h
--- mono/arch/alpha/alpha-codegen.h	1 Feb 2003 10:02:52 -0000	1.2
+++ mono/arch/alpha/alpha-codegen.h	24 Apr 2004 17:33:29 -0000
@@ -348,15 +348,15 @@
 
 
 /* integer */
-/*//#define alpha_sextl( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x00, Rsrc1, Rsrc2, Rdest )
+/* #define alpha_sextl( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x00, Rsrc1, Rsrc2, Rdest )
 //#define alpha_sextl_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x00, Rsrc1, lit, Rdest )
 */
 #define alpha_addl( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x00, Rsrc1, Rsrc2, Rdest )
 #define alpha_addl_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x00, Rsrc1, lit, Rdest )
 #define alpha_s4addl( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x02, Rsrc1, Rsrc2, Rdest )
 #define alpha_s4addl_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x02, Rsrc1, lit, Rdest )
-//#define alpha_negl( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x09, Rsrc1, Rsrc2, Rdest )
-//#define alpha_negl_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x09, Rsrc1, lit, Rdest )
+/* #define alpha_negl( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x09, Rsrc1, Rsrc2, Rdest ) */
+/* #define alpha_negl_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x09, Rsrc1, lit, Rdest ) */
 #define alpha_subl( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x09, Rsrc1, Rsrc2, Rdest )
 #define alpha_subl_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x09, Rsrc1, lit, Rdest )
 #define alpha_s4subl( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x0B, Rsrc1, Rsrc2, Rdest )
@@ -373,8 +373,8 @@
 #define alpha_addq_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x20, Rsrc1, lit, Rdest )
 #define alpha_s4addq( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x22, Rsrc1, Rsrc2, Rdest )
 #define alpha_s4addq_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x22, Rsrc1, lit, Rdest )
-//#define alpha_negq( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x29, Rsrc1, Rsrc2, Rdest )
-//#define alpha_negq_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x29, Rsrc1, lit, Rdest )
+/* #define alpha_negq( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x29, Rsrc1, Rsrc2, Rdest ) */
+/* #define alpha_negq_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x29, Rsrc1, lit, Rdest ) */
 #define alpha_subq( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x29, Rsrc1, Rsrc2, Rdest )
 #define alpha_subq_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x29, Rsrc1, lit, Rdest )
 #define alpha_s4subq( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x2B, Rsrc1, Rsrc2, Rdest )
@@ -389,16 +389,16 @@
 #define alpha_cmpule_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x3D, Rsrc1, lit, Rdest )
 #define alpha_addlv( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x40, Rsrc1, Rsrc2, Rdest )
 #define alpha_addlv_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x40, Rsrc1, lit, Rdest )
-//#define alpha_neglv( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x49, Rsrc1, Rsrc2, Rdest )
-//#define alpha_neglv_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x49, Rsrc1, lit, Rdest )
+/* #define alpha_neglv( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x49, Rsrc1, Rsrc2, Rdest ) */
+/* #define alpha_neglv_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x49, Rsrc1, lit, Rdest ) */
 #define alpha_sublv( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x49, Rsrc1, Rsrc2, Rdest )
 #define alpha_sublv_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x49, Rsrc1, lit, Rdest )
 #define alpha_cmplt( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x4D, Rsrc1, Rsrc2, Rdest )
 #define alpha_cmplt_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x4D, Rsrc1, lit, Rdest )
 #define alpha_addqv( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x60, Rsrc1, Rsrc2, Rdest )
 #define alpha_addqv_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x60, Rsrc1, lit, Rdest )
-//#define alpha_negqv( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x69, Rsrc1, Rsrc2, Rdest )
-//#define alpha_negqv_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x69, Rsrc1, lit, Rdest )
+/* #define alpha_negqv( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x69, Rsrc1, Rsrc2, Rdest ) */
+/* #define alpha_negqv_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x69, Rsrc1, lit, Rdest ) */
 #define alpha_subqv( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x69, Rsrc1, Rsrc2, Rdest )
 #define alpha_subqv_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x10, 0x69, Rsrc1, lit, Rdest )
 #define alpha_cmple( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x10, 0x6D, Rsrc1, Rsrc2, Rdest )
@@ -406,8 +406,8 @@
 
 #define alpha_and( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x00, Rsrc1, Rsrc2, Rdest )
 #define alpha_and_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x00, Rsrc1, lit, Rdest )
-//#define alpha_andnot( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x08, Rsrc1, Rsrc2, Rdest )
-//#define alpha_andnot_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x08, Rsrc1, lit, Rdest )
+/* #define alpha_andnot( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x08, Rsrc1, Rsrc2, Rdest ) */
+/* #define alpha_andnot_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x08, Rsrc1, lit, Rdest ) */
 #define alpha_bic( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x08, Rsrc1, Rsrc2, Rdest )
 #define alpha_bic_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x08, Rsrc1, lit, Rdest )
 #define alpha_cmovlbs( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x14, Rsrc1, Rsrc2, Rdest )
@@ -419,8 +419,8 @@
 #define alpha_mov1( ins, Rsrc, Rdest )		   alpha_encode_op( ins, 0x11, 0x20, alpha_zero, Rsrc, Rdest )
 #define alpha_mov2( ins, Rsrc1, Rsrc2, Rdest )    alpha_encode_op( ins, 0x11, 0x20,  Rsrc1, Rsrc2, Rdest )
 #define alpha_mov_( ins, lit, Rdest )              alpha_encode_op( ins, 0x11, 0x20, alpha_zero, lit, Rdest )
-//#define alpha_or( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x20, Rsrc1, Rsrc2, Rdest )
-//#define alpha_or_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x20, Rsrc1, lit, Rdest )
+/* #define alpha_or( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x20, Rsrc1, Rsrc2, Rdest ) */
+/* #define alpha_or_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x20, Rsrc1, lit, Rdest ) */
 #define alpha_bis( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x20, Rsrc1, Rsrc2, Rdest )
 #define alpha_bis_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x20, Rsrc1, lit, Rdest )
 #define alpha_cmoveq( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x24, Rsrc1, Rsrc2, Rdest )
@@ -439,15 +439,15 @@
 #define alpha_cmovge_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x46, Rsrc1, lit, Rdest )
 #define alpha_eqv( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x48, Rsrc1, Rsrc2, Rdest )
 #define alpha_eqv_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x48, Rsrc1, lit, Rdest )
-//#define alpha_xornot( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x48, Rsrc1, Rsrc2, Rdest )
-//#define alpha_xornot_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x48, Rsrc1, lit, Rdest )
+/* #define alpha_xornot( ins,  Rsrc1, Rsrc2, Rdest ) alpha_encode_op( ins, 0x11, 0x48, Rsrc1, Rsrc2, Rdest ) */
+/* #define alpha_xornot_( ins,  Rsrc1, lit, Rdest )  alpha_encode_opl( ins, 0x11, 0x48, Rsrc1, lit, Rdest ) */
 #define alpha_ev56b_amask( ins,  Rsrc2, Rdest )     alpha_encode_op( ins, 0x11, 0x61, alpha_zero, Rsrc2, Rdest )
 #define alpha_ev56b_amask_( ins,  lit, Rdest )      alpha_encode_opl( ins, 0x11, 0x61, alpha_zero, lit, Rdest )
 #define alpha_cmovle( ins,  Rsrc1, Rsrc2, Rdest )   alpha_encode_op( ins, 0x11, 0x64, Rsrc1, Rsrc2, Rdest )
 #define alpha_cmovle_( ins,  Rsrc1, lit, Rdest )    alpha_encode_opl( ins, 0x11, 0x64, Rsrc1, lit, Rdest )
 #define alpha_cmovgt( ins,  Rsrc1, Rsrc2, Rdest )   alpha_encode_op( ins, 0x11, 0x66, Rsrc1, Rsrc2, Rdest )
 #define alpha_cmovgt_( ins,  Rsrc1, lit, Rdest )    alpha_encode_opl( ins, 0x11, 0x66, Rsrc1, lit, Rdest )
-//#define alpha_implver_( ins,  Rsrc1, lit, Rdest )    alpha_encode_opl( ins, 0x11, 0x6C, Rsrc1, lit, Rdest )
+/* #define alpha_implver_( ins,  Rsrc1, lit, Rdest )    alpha_encode_opl( ins, 0x11, 0x6C, Rsrc1, lit, Rdest ) */
 #define alpha_cmovgt( ins,  Rsrc1, Rsrc2, Rdest )   alpha_encode_op( ins, 0x11, 0x66, Rsrc1, Rsrc2, Rdest )
 #define alpha_cmovgt_( ins,  Rsrc1, lit, Rdest )    alpha_encode_opl( ins, 0x11, 0x66, Rsrc1, lit, Rdest )
 
@@ -513,4 +513,4 @@
 #define alpha_itoft( ins, Rsrc, RFdest ) alpha_encode_fpop( ins, 0x14, 0x024, Rsrc, alpha_zero, RFdest ) 
 #define alpha_itof_qf( ins, Rsrc, RFdest ) alpha_encode_fpop( ins, 0x14, 0x024, Rsrc, alpha_zero, RFdest ) 
 
-#endif
\ No newline at end of file
+#endif
Index: mono/arch/alpha/test.c
===================================================================
RCS file: /cvs/public/mono/mono/arch/alpha/test.c,v
retrieving revision 1.2
diff -u -r1.2 test.c
--- mono/arch/alpha/test.c	1 Feb 2003 10:02:52 -0000	1.2
+++ mono/arch/alpha/test.c	24 Apr 2004 17:33:29 -0000
@@ -36,18 +36,18 @@
 
 
 
-//
+/*
 // Simple function which returns 10.
-//
+*/
 int testfunc()
 {
     return 10;
 }
 
-// Write it using the known asm bytecodes.
+/* Write it using the known asm bytecodes. */
 char * write_testfunc_1( char * p )
 {
-//
+/*
 //                               ldah     gp, 0(pv)
 //                               lda      gp, 0(gp)
 //00000001200004d0 <testfunc>:
@@ -62,6 +62,7 @@
 //   1200004f0:   08 00 fe a5     ldq     fp,8(sp)
 //   1200004f4:   10 00 de 23     lda     sp,16(sp)
 //   1200004f8:   01 80 fa 6b     ret
+*/
 
 int _func_code[] = {
     0x23defff0,
@@ -80,13 +81,13 @@
     return p + ( 4 * 11 );
 }
 
-// The same function encoded with alpha-codegen.h
+/* The same function encoded with alpha-codegen.h */
 char * write_testfunc_2( char * p )
 {    
-    alpha_ldah( p, alpha_gp, alpha_pv, 0 );  // start the gp load
-    alpha_lda( p, alpha_sp, alpha_sp, -16 ); // allocate the stack
-    alpha_lda( p, alpha_gp, alpha_gp, 0 );   // finish the gp load
-    alpha_stq( p, alpha_ra, alpha_sp, 0 );   // start param save.
+    alpha_ldah( p, alpha_gp, alpha_pv, 0 );  /* start the gp load */
+    alpha_lda( p, alpha_sp, alpha_sp, -16 ); /* allocate the stack */
+    alpha_lda( p, alpha_gp, alpha_gp, 0 );   /* finish the gp load */
+    alpha_stq( p, alpha_ra, alpha_sp, 0 );   /* start param save. */
     alpha_stq( p, alpha_fp, alpha_sp, 8 );
     alpha_mov1( p, alpha_sp, alpha_fp );
     alpha_lda( p, alpha_t0, alpha_zero, 10 );
@@ -127,8 +128,8 @@
 	int y = 0;
 	int z = 10;
 
-	// so, `test blah` gets you the byte-encoded function.
-	// and  `test` gets you the alpha-codegen.h encoded function.
+	/* so, `test blah` gets you the byte-encoded function. */
+	/* and  `test` gets you the alpha-codegen.h encoded function. */
 
 	if( argc > 1 )
 	{
@@ -139,9 +140,9 @@
 	    p = write_testfunc_2( p );
 	}
 
-	// output( code, p-code );
+	/* output( code, p-code ); */
 
-	// call the procedure.
+	/* call the procedure. */
 	x = (int(*)())code;
 
 	while( z-- > 0 )
Index: mono/arch/alpha/tramp.c
===================================================================
RCS file: /cvs/public/mono/mono/arch/alpha/tramp.c,v
retrieving revision 1.4
diff -u -r1.4 tramp.c
--- mono/arch/alpha/tramp.c	31 Oct 2003 13:03:36 -0000	1.4
+++ mono/arch/alpha/tramp.c	24 Apr 2004 17:33:29 -0000
@@ -114,10 +114,10 @@
 static inline guint8 *
 emit_prolog (guint8 *p, const gint SIZE, int hasthis )
 {
-	// 9 instructions.
+	/* 9 instructions. */
 	alpha_ldah( p, alpha_gp, alpha_pv, 0 );  
-	alpha_lda( p, alpha_sp, alpha_sp, -SIZE ); // grow stack down SIZE
-	alpha_lda( p, alpha_gp, alpha_gp, 0 );     // ldgp gp, 0(pv)
+	alpha_lda( p, alpha_sp, alpha_sp, -SIZE ); /* grow stack down SIZE */
+	alpha_lda( p, alpha_gp, alpha_gp, 0 );     /* ldgp gp, 0(pv) */
 	
 	/* TODO: we really don't need to store everything.
 	   alpha_a1: We have to store this in order to return the retval.
@@ -127,9 +127,9 @@
 	   alpha_a2: will be moved into alpha_a0... if hasthis is true.
 	*/
 	/* store parameters on stack.*/
-	alpha_stq( p, alpha_ra, alpha_sp, SIZE-24 ); // ra
-	alpha_stq( p, alpha_fp, alpha_sp, SIZE-16 ); // fp
-	alpha_stq( p, alpha_a1, alpha_sp, SIZE-8 );  // retval
+	alpha_stq( p, alpha_ra, alpha_sp, SIZE-24 ); /* ra */
+	alpha_stq( p, alpha_fp, alpha_sp, SIZE-16 ); /* fp */
+	alpha_stq( p, alpha_a1, alpha_sp, SIZE-8 );  /* retval */
 	
 	/* set the frame pointer */
 	alpha_mov1( p, alpha_sp, alpha_fp );
@@ -138,7 +138,7 @@
 	alpha_mov1( p, alpha_a0, alpha_pv );
 	alpha_mov1( p, alpha_a3, alpha_t0 );
 
-	// Move the this pointer into a0.	
+	/* Move the this pointer into a0. */
 	if( hasthis )
 	    alpha_mov1( p, alpha_a2, alpha_a0 );
 	return p;
@@ -147,13 +147,13 @@
 static inline guint8 *
 emit_call( guint8 *p , const gint SIZE )
 {
-	// 3 instructions
+	/* 3 instructions */
 	/* call func */
-	alpha_jsr( p, alpha_ra, alpha_pv, 0 );     // jsr ra, 0(pv)
+	alpha_jsr( p, alpha_ra, alpha_pv, 0 );     /* jsr ra, 0(pv) */
 
 	/* reload the gp */
 	alpha_ldah( p, alpha_gp, alpha_ra, 0 );  
-	alpha_lda( p, alpha_gp, alpha_gp, 0 );     // ldgp gp, 0(ra)
+	alpha_lda( p, alpha_gp, alpha_gp, 0 );     /* ldgp gp, 0(ra) */
 	
 	return p;
 }
@@ -161,13 +161,13 @@
 static inline guint8 *
 emit_store_return_default(guint8 *p, const gint SIZE )
 {
-	// 2 instructions.
+	/* 2 instructions. */
 	
 	/* TODO: This probably do different stuff based on the value.  
 	   you know, like stq/l/w. and s/f.
 	*/
-	alpha_ldq( p, alpha_t0, alpha_fp, SIZE-8 );  // load void * retval
-	alpha_stq( p, alpha_v0, alpha_t0, 0 );       // store the result to *retval.
+	alpha_ldq( p, alpha_t0, alpha_fp, SIZE-8 );  /* load void * retval */
+	alpha_stq( p, alpha_v0, alpha_t0, 0 );       /* store the result to *retval. */
 	return p;
 }
 
@@ -175,7 +175,7 @@
 static inline guint8 *
 emit_epilog (guint8 *p, const gint SIZE )
 {       
-	// 5 instructions.
+	/* 5 instructions. */
 	alpha_mov1( p, alpha_fp, alpha_sp );
 
 	/* restore fp, ra, sp */
@@ -195,19 +195,19 @@
 	alpharegs = AXP_GENERAL_REGS - (sig->hasthis?1:0);
 
 	*STACK        = AXP_MIN_STACK_SIZE;
-	*INSTRUCTIONS = 20;  // Base: 20 instructions.
+	*INSTRUCTIONS = 20;  /* Base: 20 instructions. */
 	
 	if( sig->param_count - alpharegs > 0 )
 	{
 		*STACK += ARG_SIZE * (sig->param_count - alpharegs );
-		// plus 3 (potential) for each stack parameter. 
+		/* plus 3 (potential) for each stack parameter.  */
 		*INSTRUCTIONS += ( sig->param_count - alpharegs ) * 3;
-		// plus 2 (potential) for each register parameter. 
+		/* plus 2 (potential) for each register parameter.  */
 		*INSTRUCTIONS += ( alpharegs * 2 );
 	}
 	else
 	{
-		// plus 2 (potential) for each register parameter. 
+		/* plus 2 (potential) for each register parameter.  */
 		*INSTRUCTIONS += ( sig->param_count * 2 );
 	}
 }
@@ -227,27 +227,27 @@
 	int simple_type;
 	int regbase;
 	
-	// Set up basic stuff.  like has this.	
+	/* Set up basic stuff.  like has this.	*/
 	hasthis = !!sig->hasthis;
 	alpharegs = AXP_GENERAL_REGS - hasthis;
 	regbase  = hasthis?alpha_a1:alpha_a0 ;
 	
-	// Make a ballpark estimate for now.
+	/* Make a ballpark estimate for now. */
 	calculate_size( sig, &BUFFER_SIZE, &STACK_SIZE );
 	
-	// convert to the correct number of bytes.
+	/* convert to the correct number of bytes. */
 	BUFFER_SIZE = BUFFER_SIZE * 4;
 
 	
-	// allocate.	
+	/* allocate. */
 	buffer = p = malloc(BUFFER_SIZE);
 	memset( buffer, 0, BUFFER_SIZE );
 	pos = 0;
 	
-	// Ok, start creating this thing.
+	/* Ok, start creating this thing. */
 	p = emit_prolog( p, STACK_SIZE, hasthis );
 
-	// copy everything into the correct register/stack space
+	/* copy everything into the correct register/stack space */
 	for (i = sig->param_count; --i >= 0; ) 
 	{
 		param = sig->params [i];
@@ -256,7 +256,7 @@
 		{
 			if( i > alpharegs )
 			{
-				// load into temp register, then store on the stack 
+				/* load into temp register, then store on the stack */
 				alpha_ldq( p, alpha_t1, alpha_t0, ARG_LOC( i ));
 				alpha_stl( p, alpha_t1, alpha_sp, pos );
 				pos += 8;
@@ -266,7 +266,7 @@
 			}
 			else
 			{
-				// load into register
+				/* load into register */
 				alpha_ldq( p, regbase + i, alpha_t0, ARG_LOC( i ) );
 			}
 		}
@@ -298,24 +298,24 @@
 			case MONO_TYPE_OBJECT:
 			case MONO_TYPE_STRING:
 			case MONO_TYPE_I8:
-				// 8 bytes
+				/* 8 bytes */
 				if( i > alpharegs )
 				{
-					// load into temp register, then store on the stack
+					/* load into temp register, then store on the stack */
 					alpha_ldq( p, alpha_t1, alpha_t0, ARG_LOC( i ) );
 					alpha_stq( p, alpha_t1, alpha_sp, pos );
 					pos += 8;
 				}
 				else
 				{
-					// load into register
+					/* load into register */
 					alpha_ldq( p, regbase + i, alpha_t0, ARG_LOC(i) );
 				}
 				break;
 			case MONO_TYPE_R4:
 			case MONO_TYPE_R8:
 				/*
-				// floating point... Maybe this does the correct thing.
+				// floating point... Maybe this does the correct thing. 
 				if( i > alpharegs )
 				{
 					alpha_ldq( p, alpha_t1, alpha_t0, ARG_LOC( i ) );
@@ -340,7 +340,7 @@
 		}
 	}
 	
-	// Now call the function and store the return parameter.
+	/* Now call the function and store the return parameter. */
 	p = emit_call( p, STACK_SIZE );
 	p = emit_store_return_default( p, STACK_SIZE );
 	p = emit_epilog( p, STACK_SIZE );
Index: mono/arch/amd64/amd64-codegen.h
===================================================================
RCS file: /cvs/public/mono/mono/arch/amd64/amd64-codegen.h,v
retrieving revision 1.3
diff -u -r1.3 amd64-codegen.h
--- mono/arch/amd64/amd64-codegen.h	16 Mar 2004 16:20:03 -0000	1.3
+++ mono/arch/amd64/amd64-codegen.h	24 Apr 2004 17:33:29 -0000
@@ -406,4 +406,4 @@
 		x86_membase_emit ((inst), (reg), (basereg), (disp));	\
 	} while (0)
 
-#endif // AMD64_H
+#endif /* AMD64_H */
Index: mono/arch/amd64/tramp.c
===================================================================
RCS file: /cvs/public/mono/mono/arch/amd64/tramp.c,v
retrieving revision 1.4
diff -u -r1.4 tramp.c
--- mono/arch/amd64/tramp.c	30 Mar 2004 01:18:10 -0000	1.4
+++ mono/arch/amd64/tramp.c	24 Apr 2004 17:33:29 -0000
@@ -39,7 +39,7 @@
 #define MAX_INT_ARG_REGS	6
 #define MAX_FLOAT_ARG_REGS	8
 
-// TODO get these right. They are upper bounds anyway, so it doesn't much matter.
+/* TODO get these right. They are upper bounds anyway, so it doesn't much matter. */
 #define PUSH_INT_STACK_ARG_SIZE		16
 #define MOVE_INT_REG_ARG_SIZE		16
 #define PUSH_FLOAT_STACK_ARG_SIZE	16
Index: mono/arch/amd64/x86-64-codegen.h
===================================================================
RCS file: /cvs/public/mono/mono/arch/amd64/x86-64-codegen.h,v
retrieving revision 1.1
diff -u -r1.1 x86-64-codegen.h
--- mono/arch/amd64/x86-64-codegen.h	27 Feb 2004 17:03:17 -0000	1.1
+++ mono/arch/amd64/x86-64-codegen.h	24 Apr 2004 17:33:29 -0000
@@ -406,4 +406,4 @@
 		x86_membase_emit ((inst), (reg), (basereg), (disp));	\
 	} while (0)
 
-#endif // AMD64_H
+#endif /* AMD64_H */
Index: mono/arch/hppa/tramp.c
===================================================================
RCS file: /cvs/public/mono/mono/arch/hppa/tramp.c,v
retrieving revision 1.4
diff -u -r1.4 tramp.c
--- mono/arch/hppa/tramp.c	30 Mar 2004 01:18:10 -0000	1.4
+++ mono/arch/hppa/tramp.c	24 Apr 2004 17:33:30 -0000
@@ -33,7 +33,7 @@
 #error "HPPA code only currently supports 64bit pointers"
 #endif
 
-// debugging flag which dumps code generated 
+/* debugging flag which dumps code generated  */
 static int debug_asm = 0;
 
 
@@ -65,7 +65,7 @@
 		offset += cache_line_size;
 	}
 	_asm("SYNC");
-	// sync needs at least 7 instructions after it... this is what is used for NOP
+	/* sync needs at least 7 instructions after it... this is what is used for NOP */
 	_asm("OR", 0, 0, 0);
 	_asm("OR", 0, 0, 0);
 	_asm("OR", 0, 0, 0);
@@ -118,7 +118,7 @@
 			sig->param_count, sig->hasthis, sig->explicit_this, string_ctor, sig->ret->type);
 	}
 
-	// everything takes 8 bytes unless it is a bigger struct
+	/* everything takes 8 bytes unless it is a bigger struct */
 	for (param = 0; param < sig->param_count; param++) {
 		if (sig->params[param]->byref)
 			frame_size += 8;
@@ -129,7 +129,7 @@
 				if (sig->params [param]->data.klass->enumtype) 
 					frame_size += 8;
 				else {
-					frame_size += 15; // large structs are 16 byte aligned
+					frame_size += 15; /* large structs are 16 byte aligned */
 					frame_size &= ~15;
 					frame_size += mono_class_native_size (sig->params [param]->data.klass, NULL);
 					frame_size += 7;
@@ -141,21 +141,21 @@
 				
 	if (sig->hasthis)
 		frame_size += 8;
-	// 16 byte alignment
+	/* 16 byte alignment */
 	if ((frame_size & 15) != 0)
 		frame_size += 8;
-	// minimum is 64 bytes
+	/* minimum is 64 bytes */
 	if (frame_size < 64)
 		frame_size = 64;
 
 	if (debug_asm)
 		fprintf(stderr, "outgoing frame size: %d\n", frame_size);
 
-	frame_size += 16; // for the frame marker (called routines stuff return address etc. here)
-	frame_size += 32; // spill area for r4, r5 and r27 (16 byte aligned)
+	frame_size += 16; /* for the frame marker (called routines stuff return address etc. here) */
+	frame_size += 32; /* spill area for r4, r5 and r27 (16 byte aligned) */
 
 	spill_offset = -frame_size;
-	parameter_offset = spill_offset + 32; // spill area size is really 24
+	parameter_offset = spill_offset + 32; /* spill area size is really 24 */
 	spill_offset += 8;
 
 	/* the rest executes twice - once to count instructions so we can
@@ -169,21 +169,21 @@
 	args_on_stack = 0;
 	parameter_slot = parameter_offset;
 
-	ADD_INST(code, pc, hppa_std(code, 2, -16, 30));  // STD	  %r2,-16(%r30)   
+	ADD_INST(code, pc, hppa_std(code, 2, -16, 30));  /* STD	  %r2,-16(%r30)    */
 	ADD_INST(code, pc, hppa_std_ma(code, 3, frame_size, 30));
 	ADD_INST(code, pc, hppa_std(code, 4, spill_offset, 30));
 	ADD_INST(code, pc, hppa_std(code, 5, spill_offset + 8, 30));
-	ADD_INST(code, pc, hppa_copy(code, 29, 3));	   // COPY	  %r29,%r3		  
+	ADD_INST(code, pc, hppa_copy(code, 29, 3));	   /* COPY	  %r29,%r3		   */
 	ADD_INST(code, pc, hppa_std(code, 27, spill_offset + 16, 30));
-	ADD_INST(code, pc, hppa_nop(code)); 		   // NOP			  
+	ADD_INST(code, pc, hppa_nop(code)); 		   /* NOP			  */
 
-	ADD_INST(code, pc, hppa_std(code, 26, -64, 29)); // STD	  %r26,-64(%r29)  callme
-	ADD_INST(code, pc, hppa_std(code, 25, -56, 29)); // STD	  %r25,-56(%r29)  retval
-	ADD_INST(code, pc, hppa_std(code, 24, -48, 29)); // STD	  %r24,-48(%r29)  this_obj
-	ADD_INST(code, pc, hppa_std(code, 23, -40, 29)); // STD	  %r23,-40(%r29)  arguments
+	ADD_INST(code, pc, hppa_std(code, 26, -64, 29)); /* STD	  %r26,-64(%r29)  callme */
+	ADD_INST(code, pc, hppa_std(code, 25, -56, 29)); /* STD	  %r25,-56(%r29)  retval */
+	ADD_INST(code, pc, hppa_std(code, 24, -48, 29)); /* STD	  %r24,-48(%r29)  this_obj */
+	ADD_INST(code, pc, hppa_std(code, 23, -40, 29)); /* STD	  %r23,-40(%r29)  arguments */
 
 	if (sig->param_count > 0)
-		ADD_INST(code, pc, hppa_copy(code, 23, 4));  // r4 is the current pointer to the stackval array of args
+		ADD_INST(code, pc, hppa_copy(code, 23, 4));  /* r4 is the current pointer to the stackval array of args */
 
 	if (sig->hasthis) {
 		if (sig->call_convention != MONO_CALL_THISCALL) {
@@ -293,8 +293,8 @@
 				goto typeswitch;
 			} else {
 				int size = mono_class_native_size (sig->params [param]->data.klass, NULL);
-				// assumes struct is 8 byte aligned whatever its size... (as interp.c guarantees at present)
-				// copies multiple of 8 bytes which may include some trailing garbage but should be safe
+				/* assumes struct is 8 byte aligned whatever its size... (as interp.c guarantees at present) */
+				/* copies multiple of 8 bytes which may include some trailing garbage but should be safe */
 				if (size <= 8) {
 					if (args_on_stack) {
 						ADD_INST(code, pc, hppa_ldd(code, arg_offset, 4, 5));
@@ -316,8 +316,8 @@
 						parameter_slot += 8;
 					}
 					ADD_INST(code, pc, hppa_ldd(code, arg_offset, 4, 5));
-					// might generate a lot of code for very large structs... should
-					// use a loop or routine call them
+					/* might generate a lot of code for very large structs... should */
+					/* use a loop or routine call them */
 					while (size > 0) {
 						if (args_on_stack) {
 							ADD_INST(code, pc, hppa_ldd(code, soffset, 5, 31));
@@ -347,7 +347,7 @@
 		}
 	}
 
-	// for large return structs just pass on the buffer given to us.
+	/* for large return structs just pass on the buffer given to us. */
 	if (sig->ret->type == MONO_TYPE_VALUETYPE && sig->ret->data.klass->enumtype == 0) {
 		int size = mono_class_native_size (sig->ret->data.klass, NULL);
 		if (size > 16) {
@@ -356,18 +356,18 @@
 		}
 	}
 
-	ADD_INST(code, pc, hppa_nop(code)); 		   // NOP			  
+	ADD_INST(code, pc, hppa_nop(code)); 		   /* NOP */
 	ADD_INST(code, pc, hppa_ldd(code, -64, 29, 5));
 	ADD_INST(code, pc, hppa_ldd(code, 24, 5, 27));
 	ADD_INST(code, pc, hppa_ldd(code, 16, 5, 5));
 	ADD_INST(code, pc, hppa_blve(code, 5));
 	ADD_INST(code, pc, hppa_ldo(code, parameter_offset + 64, 30, 29));
 	ADD_INST(code, pc, hppa_ldd(code, spill_offset + 16, 30, 27));
-	ADD_INST(code, pc, hppa_nop(code)); 		   // NOP			  
+	ADD_INST(code, pc, hppa_nop(code)); 		   /* NOP */
         
 	if (string_ctor) {
-		ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); // LDD	 -56(%r3),%r19	 
-		ADD_INST(code, pc, hppa_std(code, 28, 0, 19));  // STD	 %r28,0(%r19)	 
+		ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); /* LDD	 -56(%r3),%r19	  */
+		ADD_INST(code, pc, hppa_std(code, 28, 0, 19));  /* STD	 %r28,0(%r19)	  */
 	}
 	else if (sig->ret->type != MONO_TYPE_VOID) {
 		int type = sig->ret->type;
@@ -377,19 +377,19 @@
 		case MONO_TYPE_BOOLEAN:
 		case MONO_TYPE_I1:
 		case MONO_TYPE_U1:
-			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); // LDD	 -56(%r3),%r19	 
-			ADD_INST(code, pc, hppa_stb(code, 28, 0, 19));  // STB	 %r28,0(%r19)	 
+			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); /* LDD	 -56(%r3),%r19	 */
+			ADD_INST(code, pc, hppa_stb(code, 28, 0, 19));  /* STB	 %r28,0(%r19)	 */
 			break;
 		case MONO_TYPE_I4:
 		case MONO_TYPE_U4:
-			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); // LDD	 -56(%r3),%r19	 
-			ADD_INST(code, pc, hppa_stw(code, 28, 0, 19));  // STW	 %r28,0(%r19)	 
+			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); /* LDD	 -56(%r3),%r19	 */
+			ADD_INST(code, pc, hppa_stw(code, 28, 0, 19));  /* STW	 %r28,0(%r19)	 */
 			break;
 		case MONO_TYPE_CHAR:
 		case MONO_TYPE_I2:
 		case MONO_TYPE_U2:
-			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); // LDD	 -56(%r3),%r19	 
-			ADD_INST(code, pc, hppa_sth(code, 28, 0, 19));  // STH	 %r28,0(%r19)
+			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); /* LDD	 -56(%r3),%r19	 */
+			ADD_INST(code, pc, hppa_sth(code, 28, 0, 19));  /* STH	 %r28,0(%r19)    */
 			break;
 		case MONO_TYPE_I8:
 		case MONO_TYPE_U8:
@@ -400,16 +400,16 @@
 		case MONO_TYPE_CLASS:
 		case MONO_TYPE_SZARRAY:
 		case MONO_TYPE_PTR:
-			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); // LDD	 -56(%r3),%r19	 
-			ADD_INST(code, pc, hppa_std(code, 28, 0, 19));  // STD	 %r28,0(%r19)	 
+			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); /* LDD	 -56(%r3),%r19	 */
+			ADD_INST(code, pc, hppa_std(code, 28, 0, 19));  /* STD	 %r28,0(%r19)	 */
 			break;
 		case MONO_TYPE_R8:
-			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); // LDD	 -56(%r3),%r19	 
-			ADD_INST(code, pc, hppa_fstd(code, 4, 0, 19));  // FSTD	  %fr4,0(%r19)	  
+			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); /* LDD	 -56(%r3),%r19	 */
+			ADD_INST(code, pc, hppa_fstd(code, 4, 0, 19));  /* FSTD	  %fr4,0(%r19)	 */
 			break;
 		case MONO_TYPE_R4:
-			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); // LDD	 -56(%r3),%r19	 
-			ADD_INST(code, pc, hppa_fstw(code, 4, 0, 19));  // FSTW	  %fr4r,0(%r19)    
+			ADD_INST(code, pc, hppa_ldd(code, -56, 3, 19)); /* LDD	 -56(%r3),%r19	 */
+			ADD_INST(code, pc, hppa_fstw(code, 4, 0, 19));  /* FSTW	  %fr4r,0(%r19)  */
 			break;
 		case MONO_TYPE_VALUETYPE:
 			if (sig->ret->data.klass->enumtype) {
@@ -428,7 +428,7 @@
 						reg = 29;
 						off += 8;
 					}
-					// get rest of value right aligned in the register
+					/* get rest of value right aligned in the register */
 					ADD_INST(code, pc, hppa_extrdu(code, reg, 8 * size - 1, 8 * size, reg));
 					if ((size & 1) != 0) {
 						ADD_INST(code, pc, hppa_stb(code, reg, off + size - 1, 19));
@@ -471,7 +471,7 @@
 		disassemble(code_start, pc);
 	}
 
-        // must do this so we can actually execute the code we just put in memory
+        /* must do this so we can actually execute the code we just put in memory */
 	flush_cache(code_start, 4 * pc);
 
 	descriptor[0] = 0;
@@ -513,9 +513,9 @@
 			fprintf(stderr, "%d: %d\n", i, sig->params[i]->type);
 	}
 
-	// the extra stackval is for the return val if necessary
-	// the 64 is for outgoing parameters and the 16 is the frame marker.
-	// the other 16 is space for struct return vals < 16 bytes
+	/* the extra stackval is for the return val if necessary */
+	/* the 64 is for outgoing parameters and the 16 is the frame marker. */
+	/* the other 16 is space for struct return vals < 16 bytes */
         frame_size = sizeof(MonoInvocation) + (sig->param_count + 1) * sizeof(stackval) + 16 + 64 + 16;
 	frame_size += 15;
 	frame_size &= ~15;
@@ -556,14 +556,14 @@
 	ADD_INST(code, pc, hppa_std(code, 28, spill_offset + 16, 30));
 	ADD_INST(code, pc, hppa_nop(code));
 
-	ADD_INST(code, pc, hppa_std(code, 26, -64, 29)); // STD	  %r26,-64(%r29)
-	ADD_INST(code, pc, hppa_std(code, 25, -56, 29)); // STD	  %r25,-56(%r29)
-	ADD_INST(code, pc, hppa_std(code, 24, -48, 29)); // STD	  %r24,-48(%r29)
-	ADD_INST(code, pc, hppa_std(code, 23, -40, 29)); // STD	  %r23,-40(%r29)
-	ADD_INST(code, pc, hppa_std(code, 22, -32, 29)); // STD	  %r22,-32(%r29)
-	ADD_INST(code, pc, hppa_std(code, 21, -24, 29)); // STD	  %r21,-24(%r29)
-	ADD_INST(code, pc, hppa_std(code, 20, -16, 29)); // STD	  %r20,-16(%r29)
-	ADD_INST(code, pc, hppa_std(code, 19, -8, 29));  // STD	  %r19,-8(%r29)
+	ADD_INST(code, pc, hppa_std(code, 26, -64, 29)); /* STD	  %r26,-64(%r29) */
+	ADD_INST(code, pc, hppa_std(code, 25, -56, 29)); /* STD	  %r25,-56(%r29) */
+	ADD_INST(code, pc, hppa_std(code, 24, -48, 29)); /* STD	  %r24,-48(%r29) */
+	ADD_INST(code, pc, hppa_std(code, 23, -40, 29)); /* STD	  %r23,-40(%r29) */
+	ADD_INST(code, pc, hppa_std(code, 22, -32, 29)); /* STD	  %r22,-32(%r29) */
+	ADD_INST(code, pc, hppa_std(code, 21, -24, 29)); /* STD	  %r21,-24(%r29) */
+	ADD_INST(code, pc, hppa_std(code, 20, -16, 29)); /* STD	  %r20,-16(%r29) */
+	ADD_INST(code, pc, hppa_std(code, 19, -8, 29));  /* STD	  %r19,-8(%r29) */
 
 	ADD_INST(code, pc, hppa_std(code, 0, invoke_rec_offset + G_STRUCT_OFFSET (MonoInvocation, parent), 30));
 	ADD_INST(code, pc, hppa_std(code, 0, invoke_rec_offset + G_STRUCT_OFFSET (MonoInvocation, ex), 30));
@@ -590,8 +590,8 @@
 	for (i = 0; i < sig->param_count; ++i) {
 		if (data != NULL)
 			data[4 + i] = sig->params[i];
-		ADD_INST(code, pc, hppa_ldd(code, (4 + i) * 8, 27, 26)); // LDD	  x(%r27),%r26 == type
-		ADD_INST(code, pc, hppa_ldo(code, stack_val_pos, 30, 25)); // LDD 	x(%r30),%r25 == &stackval
+		ADD_INST(code, pc, hppa_ldd(code, (4 + i) * 8, 27, 26)); /* LDD	  x(%r27),%r26 == type */
+		ADD_INST(code, pc, hppa_ldo(code, stack_val_pos, 30, 25)); /* LDD 	x(%r30),%r25 == &stackval */
 		if (sig->params[i]->byref) {
 			ADD_INST(code, pc, hppa_ldo(code, arg_val_pos, 3, 24));
 		} else {
@@ -641,7 +641,7 @@
 					arg_val_pos += size;
 					arg_val_pos += 7;
 					arg_val_pos &= ~7;
-					arg_val_pos -=8 ; // as it is incremented later
+					arg_val_pos -=8 ; /* as it is incremented later */
 
 					ADD_INST(code, pc, hppa_ldo(code, vtoffsets[i], 30, 19));
 					ADD_INST(code, pc, hppa_std(code, 19, 0, 25));
@@ -653,13 +653,13 @@
 			}
 		}
 
-		ADD_INST(code, pc, hppa_ldo(code, sig->pinvoke, 0, 23)); // LDI sig->pinvoke,%r23
-		ADD_INST(code, pc, hppa_ldd(code, 16, 27, 19));	// LDD	   x(%r27),%r19 == stackval_from_data
-		ADD_INST(code, pc, hppa_ldd(code, 16, 19, 20));	// LDD	   16(%r19),%r20   
-		ADD_INST(code, pc, hppa_ldd(code, 24, 19, 27));	// LDD	   24(%r19),%r27   
-		ADD_INST(code, pc, hppa_blve(code, 20));		// BVE,L   (%r20),%r2	   
-		ADD_INST(code, pc, hppa_ldo(code, -16, 30, 29));	// LDO	   -16(%r30),%r29
-		ADD_INST(code, pc, hppa_ldd(code, spill_offset + 8, 30, 27));
+		ADD_INST(code, pc, hppa_ldo(code, sig->pinvoke, 0, 23)); /* LDI sig->pinvoke,%r23 */
+		ADD_INST(code, pc, hppa_ldd(code, 16, 27, 19));	/* LDD	   x(%r27),%r19 == stackval_from_data */
+		ADD_INST(code, pc, hppa_ldd(code, 16, 19, 20));	/* LDD	   16(%r19),%r20    */
+		ADD_INST(code, pc, hppa_ldd(code, 24, 19, 27));	/* LDD	   24(%r19),%r27    */
+		ADD_INST(code, pc, hppa_blve(code, 20));		/* BVE,L   (%r20),%r2	    */
+		ADD_INST(code, pc, hppa_ldo(code, -16, 30, 29));	/* LDO	   -16(%r30),%r29 */
+		ADD_INST(code, pc, hppa_ldd(code, spill_offset + 8, 30, 27)); 
 
 		stack_val_pos += sizeof (stackval);
 		arg_val_pos += 8;
@@ -673,23 +673,23 @@
 
 	if (sig->ret->type == MONO_TYPE_VALUETYPE && !sig->ret->data.klass->enumtype) {
 		int size = mono_class_native_size (sig->ret->data.klass, NULL);
-		// for large return structs pass on the pointer given us by our caller.
+		/* for large return structs pass on the pointer given us by our caller. */
 		if (size > 16)
 			ADD_INST(code, pc, hppa_ldd(code, spill_offset + 16, 30, 28));
-		else // use space left on stack for the return value
+		else /* use space left on stack for the return value */
 			ADD_INST(code, pc, hppa_ldo(code, stack_val_pos + sizeof(stackval), 30, 28));
 		ADD_INST(code, pc, hppa_std(code, 28, stack_val_pos, 30));
 	}
 
-	ADD_INST(code, pc, hppa_ldo(code, invoke_rec_offset, 30, 26)); // address of invocation
+	ADD_INST(code, pc, hppa_ldo(code, invoke_rec_offset, 30, 26)); /* address of invocation */
 
 	if (data != NULL)
 		data[1] = (void *)ves_exec_method;
-	ADD_INST(code, pc, hppa_ldd(code, 8, 27, 19));	// LDD	   8(%r27),%r19
-	ADD_INST(code, pc, hppa_ldd(code, 16, 19, 20));	// LDD	   16(%r19),%r20   
-	ADD_INST(code, pc, hppa_ldd(code, 24, 19, 27));	// LDD	   24(%r19),%r27   
-	ADD_INST(code, pc, hppa_blve(code, 20));		// BVE,L   (%r20),%r2	   
-	ADD_INST(code, pc, hppa_ldo(code, -16, 30, 29));	// LDO	   -16(%r30),%r29
+	ADD_INST(code, pc, hppa_ldd(code, 8, 27, 19));	/* LDD	   8(%r27),%r19 */
+	ADD_INST(code, pc, hppa_ldd(code, 16, 19, 20));	/* LDD	   16(%r19),%r20    */
+	ADD_INST(code, pc, hppa_ldd(code, 24, 19, 27));	/* LDD	   24(%r19),%r27    */
+	ADD_INST(code, pc, hppa_blve(code, 20));		/* BVE,L   (%r20),%r2	    */
+	ADD_INST(code, pc, hppa_ldo(code, -16, 30, 29));	/* LDO	   -16(%r30),%r29 */
 	ADD_INST(code, pc, hppa_ldd(code, spill_offset + 8, 30, 27));
 	if (sig->ret->byref) {
 		fprintf(stderr, "can'ty cope with ret byref\n");
@@ -707,7 +707,7 @@
 		case MONO_TYPE_U2:
 		case MONO_TYPE_I4:
 		case MONO_TYPE_U4:
-			ADD_INST(code, pc, hppa_ldw(code, stack_val_pos, 30, 28)); // LDW 	x(%r30),%r28
+			ADD_INST(code, pc, hppa_ldw(code, stack_val_pos, 30, 28)); /* LDW 	x(%r30),%r28 */
 			break;
 		case MONO_TYPE_I8:
 		case MONO_TYPE_U8:
@@ -718,10 +718,10 @@
 		case MONO_TYPE_CLASS:
 		case MONO_TYPE_SZARRAY:
 		case MONO_TYPE_PTR:
-			ADD_INST(code, pc, hppa_ldd(code, stack_val_pos, 30, 28)); // LDD 	x(%r30),%r28
+			ADD_INST(code, pc, hppa_ldd(code, stack_val_pos, 30, 28)); /* LDD 	x(%r30),%r28 */
 			break;
 		case MONO_TYPE_R8:
-			ADD_INST(code, pc, hppa_fldd(code, stack_val_pos, 30, 4)); // FLDD	 x(%r30),%fr4
+			ADD_INST(code, pc, hppa_fldd(code, stack_val_pos, 30, 4)); /* FLDD	 x(%r30),%fr4 */
 			break;
 		case MONO_TYPE_VALUETYPE:
 			if (sig->ret->data.klass->enumtype) {
@@ -769,7 +769,7 @@
 
 	ji = g_new0 (MonoJitInfo, 1);
 	ji->method = method;
-	ji->code_size = 4; // does this matter?
+	ji->code_size = 4; /* does this matter? */
 	ji->code_start = descriptor;
 
 	mono_jit_info_table_add (mono_root_domain, ji);
Index: mono/arch/x86/test.c
===================================================================
RCS file: /cvs/public/mono/mono/arch/x86/test.c,v
retrieving revision 1.8
diff -u -r1.8 test.c
--- mono/arch/x86/test.c	22 Apr 2002 07:32:11 -0000	1.8
+++ mono/arch/x86/test.c	24 Apr 2004 17:33:30 -0000
@@ -20,10 +20,10 @@
 	x86_cmpxchg_membase_reg (p, X86_EAX, 12, X86_EBP);
 
 	x86_xchg_reg_reg (p, X86_EAX, X86_EBP, 4);
-	x86_xchg_reg_reg (p, X86_EAX, X86_EBP, 1); // FIXME?
+	x86_xchg_reg_reg (p, X86_EAX, X86_EBP, 1); /* FIXME? */
 	x86_xchg_membase_reg (p, X86_EAX, 12, X86_EBP, 4);
 	x86_xchg_membase_reg (p, X86_EAX, 12, X86_EBP, 2);
-	x86_xchg_membase_reg (p, X86_EAX, 12, X86_EBX, 1); // FIXME?
+	x86_xchg_membase_reg (p, X86_EAX, 12, X86_EBX, 1); /* FIXME? */
 
 	x86_inc_reg (p, X86_EAX);
 	x86_inc_mem (p, mem_addr);
Index: mono/arch/x86/x86-codegen.h
===================================================================
RCS file: /cvs/public/mono/mono/arch/x86/x86-codegen.h,v
retrieving revision 1.39
diff -u -r1.39 x86-codegen.h
--- mono/arch/x86/x86-codegen.h	25 Jun 2003 13:18:00 -0000	1.39
+++ mono/arch/x86/x86-codegen.h	24 Apr 2004 17:33:30 -0000
@@ -1645,4 +1645,4 @@
 		x86_ret ((inst));	\
 	} while (0)
 
-#endif // X86_H
+#endif /* X86_H */
