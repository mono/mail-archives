Index: mono/mini/aot.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/aot.c,v
retrieving revision 1.33
diff -u -r1.33 aot.c
--- mono/mini/aot.c	8 Apr 2004 18:01:12 -0000	1.33
+++ mono/mini/aot.c	24 Apr 2004 17:33:43 -0000
@@ -465,7 +465,7 @@
 
 			ji->ip.i += last_offset;
 			last_offset = ji->ip.i;
-			//printf ("T: %d O: %d.\n", ji->type, ji->ip.i);
+			/* printf ("T: %d O: %d.\n", ji->type, ji->ip.i); */
 
 			data = *((gpointer **)info);
 
@@ -529,7 +529,7 @@
 			case MONO_PATCH_INFO_INTERNAL_METHOD:
 				ji->data.name = aot_module->icall_table [(guint32)data];
 				g_assert (ji->data.name);
-				//printf ("A: %s.\n", ji->data.name);
+				/* printf ("A: %s.\n", ji->data.name); */
 				break;
 			case MONO_PATCH_INFO_SWITCH:
 				ji->table_size = (int)data [0];
@@ -1003,7 +1003,7 @@
 		/* Used only in shared mode */
 		g_assert (!cfg->ldstr_list);
 
-	//printf ("M: %s (%s).\n", mono_method_full_name (method, TRUE), mname);
+	/* printf ("M: %s (%s).\n", mono_method_full_name (method, TRUE), mname); */
 
 	if (j) {
 		guint32 last_offset;
@@ -1019,7 +1019,7 @@
 				/* Nothing to do */
 				continue;
 
-			//printf ("T: %d O: %d.\n", patch_info->type, patch_info->ip.i);
+			/* printf ("T: %d O: %d.\n", patch_info->type, patch_info->ip.i); */
 			offset = patch_info->ip.i - last_offset;
 			last_offset = patch_info->ip.i;
 
@@ -1157,7 +1157,7 @@
 		    (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||
 		    (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) ||
 		    (method->flags & METHOD_ATTRIBUTE_ABSTRACT)) {
-			//printf ("Skip (impossible): %s\n", mono_method_full_name (method, TRUE));
+			/* printf ("Skip (impossible): %s\n", mono_method_full_name (method, TRUE)); */
 			continue;
 		}
 
@@ -1165,13 +1165,13 @@
 
 		/* fixme: we need to patch the IP for the LMF in that case */
 		if (method->save_lmf) {
-			//printf ("Skip (needs lmf):  %s\n", mono_method_full_name (method, TRUE));
+			/* printf ("Skip (needs lmf):  %s\n", mono_method_full_name (method, TRUE)); */
 			lmfcount++;
 			continue;
 		}
 
-		//printf ("START:           %s\n", mono_method_full_name (method, TRUE));
-		//mono_compile_method (method);
+		/* printf ("START:           %s\n", mono_method_full_name (method, TRUE)); */
+		/* mono_compile_method (method); */
 
 		cfg = mini_method_compile (method, opts, mono_root_domain, FALSE, 0);
 		g_assert (cfg);
@@ -1186,7 +1186,7 @@
 		for (patch_info = cfg->patch_info; patch_info; patch_info = patch_info->next) {
 			if (patch_info->type == MONO_PATCH_INFO_ABS) {
 				/* unable to handle this */
-				//printf ("Skip (abs addr):   %s %d\n", mono_method_full_name (method, TRUE), patch_info->type);
+				/* printf ("Skip (abs addr):   %s %d\n", mono_method_full_name (method, TRUE), patch_info->type); */
 				skip = TRUE;	
 				break;
 			}
@@ -1210,7 +1210,7 @@
 			     patch_info->type == MONO_PATCH_INFO_METHODCONST) &&
 			    patch_info->data.method->wrapper_type) {
 				/* unable to handle this */
-				//printf ("Skip (wrapper call):   %s %d -> %s\n", mono_method_full_name (method, TRUE), patch_info->type, mono_method_full_name (patch_info->data.method, TRUE));
+				/* printf ("Skip (wrapper call):   %s %d -> %s\n", mono_method_full_name (method, TRUE), patch_info->type, mono_method_full_name (patch_info->data.method, TRUE)); */
 				skip = TRUE;	
 				break;
 			}
@@ -1221,7 +1221,7 @@
 			continue;
 		}
 
-		//printf ("Compile:           %s\n", mono_method_full_name (method, TRUE));
+		/* printf ("Compile:           %s\n", mono_method_full_name (method, TRUE)); */
 
 		emitted [i] = TRUE;
 		emit_method (acfg, cfg);
@@ -1281,7 +1281,7 @@
 				if (emitted [(i * 32) + k])
 					w += (1 << k);
 			}
-			//printf ("EMITTED [%d] = %d.\n", i, b);
+			/* printf ("EMITTED [%d] = %d.\n", i, b); */
 			fprintf (tmpfp, "\t.long %d\n", w);
 		}
 	}
@@ -1321,7 +1321,7 @@
 	printf ("%d methods contain wrapper references (%d%%)\n", wrappercount, mcount ? (wrappercount*100)/mcount : 100);
 	printf ("%d methods contain lmf pointers (%d%%)\n", lmfcount, mcount ? (lmfcount*100)/mcount : 100);
 	printf ("%d methods have other problems (%d%%)\n", ocount, mcount ? (ocount*100)/mcount : 100);
-	//printf ("Retained input file.\n");
+	/* printf ("Retained input file.\n"); */
 	unlink (tmpfname);
 
 	return 0;
Index: mono/mini/cprop.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/cprop.c,v
retrieving revision 1.2
diff -u -r1.2 cprop.c
--- mono/mini/cprop.c	5 Aug 2003 10:32:07 -0000	1.2
+++ mono/mini/cprop.c	24 Apr 2004 17:33:43 -0000
@@ -23,11 +23,11 @@
 {
 	MiniACP *tmp = acp;
 
-	//g_print ("search reg %d '%c'\n", reg, type);
+	/* g_print ("search reg %d '%c'\n", reg, type); */
 	while (tmp) {
-	//	g_print ("considering dreg %d, sreg %d '%c'\n", tmp->dreg, tmp->sreg, tmp->type);
+	/*	g_print ("considering dreg %d, sreg %d '%c'\n", tmp->dreg, tmp->sreg, tmp->type); */
 		if (tmp->type == type && tmp->dreg == reg) {
-	//		g_print ("copy prop from %d to %d\n", tmp->sreg, tmp->dreg);
+	/*		g_print ("copy prop from %d to %d\n", tmp->sreg, tmp->dreg); */
 			return tmp->sreg;
 		}
 		tmp = tmp->next;
@@ -74,11 +74,11 @@
 	const char *spec;
 	MonoInst *ins = code;
 
-	//g_print ("starting BB\n");
+	/* g_print ("starting BB\n"); */
 
 	while (ins) {
 		spec = ins_spec [ins->opcode];
-		//print_ins (0, ins);
+		/* print_ins (0, ins); */
 
 		if (spec [MONO_INST_CLOB] != 's' && spec [MONO_INST_CLOB] != '1' && spec [MONO_INST_CLOB] != 'd' && spec [MONO_INST_CLOB] != 'a' && spec [MONO_INST_CLOB] != 'c') {
 			if (spec [MONO_INST_SRC1] == 'f') {
@@ -108,7 +108,7 @@
 		 * Later copy-propagate also immediate values and memory stores.
 		 */
 		if (ins->opcode == OP_MOVE && ins->sreg1 != ins->dreg) {
-	//		g_print ("added acp of %d <- %d '%c'\n", ins->dreg, ins->sreg1, spec [MONO_INST_SRC1]);
+	/*		g_print ("added acp of %d <- %d '%c'\n", ins->dreg, ins->sreg1, spec [MONO_INST_SRC1]); */
 			acp = add_acp (cfg, acp, ins->sreg1, ins->dreg, spec [MONO_INST_SRC1]);
 		}
 
Index: mono/mini/debug-mini.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/debug-mini.c,v
retrieving revision 1.15
diff -u -r1.15 debug-mini.c
--- mono/mini/debug-mini.c	11 Feb 2004 20:16:35 -0000	1.15
+++ mono/mini/debug-mini.c	24 Apr 2004 17:33:43 -0000
@@ -162,11 +162,11 @@
 			i ++;
 		else {
 			if (line_number > 0) {
-				//g_assert (addresses [i] - 1 >= address);
+				/* g_assert (addresses [i] - 1 >= address); */
 				
 				if (addresses [i] - 1 >= address) {
 					VALGRIND_ADD_LINE_INFO (jit->code_start + address, jit->code_start + addresses [i] - 1, filename, line_number);
-					//printf ("[%d-%d] -> %d.\n", address, addresses [i] - 1, line_number);
+					/* printf ("[%d-%d] -> %d.\n", address, addresses [i] - 1, line_number); */
 				}
 			}
 			address = addresses [i];
@@ -176,7 +176,7 @@
 
 	if (line_number > 0) {
 		VALGRIND_ADD_LINE_INFO (jit->code_start + address, jit->code_start + jit->code_size - 1, filename, line_number);
-		//printf ("[%d-%d] -> %d.\n", address, jit->code_size - 1, line_number);
+		/* printf ("[%d-%d] -> %d.\n", address, jit->code_size - 1, line_number); */
 	}
 
 	VALGRIND_ADD_SYMBOL (jit->code_start, jit->code_size, full_name);
@@ -263,7 +263,7 @@
 {
 	char *p = buf;
 
-	//printf ("ENCODE: %d 0x%x.\n", value, value);
+	/* printf ("ENCODE: %d 0x%x.\n", value, value); */
 
 	/* 
 	 * Same encoding as the one used in the metadata, extended to handle values
@@ -321,7 +321,7 @@
 	if (rptr)
 		*rptr = ptr;
 
-	//printf ("DECODE: %d.\n", len);
+	/* printf ("DECODE: %d.\n", len); */
 	return len;
 }
 
Index: mono/mini/dominators.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/dominators.c,v
retrieving revision 1.1
diff -u -r1.1 dominators.c
--- mono/mini/dominators.c	5 Apr 2003 19:21:32 -0000	1.1
+++ mono/mini/dominators.c	24 Apr 2004 17:33:44 -0000
@@ -12,7 +12,7 @@
 
 #include "mini.h"
 
-//#define DEBUG_DOMINATORS
+/* #define DEBUG_DOMINATORS */
 
 /* the simpler, dumber algorithm */
 static void
@@ -120,7 +120,7 @@
 				if (t == s)
 					continue;
 
-				//if (mono_bitset_test_fast (T [s], t))
+				/* if (mono_bitset_test_fast (T [s], t)) */
 				if (mono_bitset_test_fast (m->bblocks [s]->dominators, t))
 					mono_bitset_clear (temp, t);
 			}
@@ -137,7 +137,7 @@
 		s = mono_bitset_find_start (T [i]);
 		g_assert (s != -1);
 		/*fixme:mono_bitset_count does not really work */
-		//g_assert (mono_bitset_count (T [i]) == 1);
+		/* g_assert (mono_bitset_count (T [i]) == 1); */
 		t = mono_bitset_find_first (T [i], s);
 		g_assert (t == -1 || t >=  m->num_bblocks);
 		bb->idom = m->bblocks [s];
@@ -224,7 +224,7 @@
 		bb = postorder [i];
 		/* the local component */
 		for (j = 0; j < bb->out_count; ++j) {
-			//if (bb->out_bb [j] != bb->idom)
+			/* if (bb->out_bb [j] != bb->idom) */
 			if (bb->out_bb [j]->idom != bb)
 				mono_bitset_set (bb->dfrontier, bb->out_bb [j]->dfn);
 		}
@@ -235,7 +235,7 @@
 		if (bb->idom) {
 			z = bb->idom;
 			mono_bitset_foreach_bit (z->dfrontier, j, m->num_bblocks) {
-				//if (m->bblocks [j] != bb->idom)
+				/* if (m->bblocks [j] != bb->idom) */
 				if (m->bblocks [j]->idom != bb)
 					mono_bitset_set (bb->dfrontier, m->bblocks [j]->dfn);
 			}
@@ -404,7 +404,7 @@
 	return result;
 }
 
-//#define DEBUG_NATURAL_LOOPS
+/* #define DEBUG_NATURAL_LOOPS */
 
 /*
  * code to detect loops and loop nesting level
Index: mono/mini/driver.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/driver.c,v
retrieving revision 1.46
diff -u -r1.46 driver.c
--- mono/mini/driver.c	13 Apr 2004 20:15:05 -0000	1.46
+++ mono/mini/driver.c	24 Apr 2004 17:33:44 -0000
@@ -230,8 +230,9 @@
 #if 0
 static void
 domain_dump_native_code (MonoDomain *domain) {
-	// need to poke into the domain, move to metadata/domain.c
+	/* need to poke into the domain, move to metadata/domain.c
 	// need to empty jit_info_table and code_mp
+	*/
 }
 #endif
 
@@ -776,7 +777,7 @@
 		const guchar *error;
 
 		mono_config_parse (config_file);
-		//mono_set_rootdir ();
+		/* mono_set_rootdir (); */
 
 		error = mono_check_corlib_version ();
 		if (error) {
Index: mono/mini/exceptions-ppc.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/exceptions-ppc.c,v
retrieving revision 1.18
diff -u -r1.18 exceptions-ppc.c
--- mono/mini/exceptions-ppc.c	23 Apr 2004 17:42:29 -0000	1.18
+++ mono/mini/exceptions-ppc.c	24 Apr 2004 17:33:44 -0000
@@ -32,8 +32,8 @@
  * the original context from the signal handler.
  */
 typedef struct {
-	gulong sc_ir;          // pc 
-	gulong sc_sp;          // r1
+	gulong sc_ir;          /*  pc  */
+	gulong sc_sp;          /*  r1  */
 	gulong regs [19];
 	double fregs [20];
 } MonoContext;
@@ -438,12 +438,12 @@
 			    res->saved [X86_EBP] == 1 &&
 			    res->saved [X86_ESI] == 1 &&
 			    (ji = mono_jit_info_table_find (domain, frame->return_address))) {
-				//printf ("FRAME CFA %s\n", mono_method_full_name (ji->method, TRUE));
+				/* printf ("FRAME CFA %s\n", mono_method_full_name (ji->method, TRUE)); */
 				return ji;
 			}
 
 		} else {
-			//printf ("FRAME %p %p %p\n", frame, MONO_CONTEXT_GET_IP (new_ctx), mono_jit_info_table_find (domain, MONO_CONTEXT_GET_IP (new_ctx)));
+			/* printf ("FRAME %p %p %p\n", frame, MONO_CONTEXT_GET_IP (new_ctx), mono_jit_info_table_find (domain, MONO_CONTEXT_GET_IP (new_ctx))); */
 
 			MONO_CONTEXT_SET_IP (new_ctx, frame->return_address);
 			frame = frame->next;
@@ -460,8 +460,8 @@
 		}
 	}
 
-	//if (!lmf)
-	//g_assert_not_reached ();
+	/* if (!lmf) */
+	/*	g_assert_not_reached (); */
 
 	if (trace) {
 		g_free (*trace);
@@ -502,7 +502,7 @@
 
 	code = start;
 	restore_regs_from_context (ppc_r3, ppc_r4, ppc_r5);
-	//ppc_break (code);
+	/* ppc_break (code); */
 	/* jump to the saved IP */
 	ppc_mtctr (code, ppc_r4);
 	ppc_bcctr (code, PPC_BR_ALWAYS, 0);
@@ -538,7 +538,7 @@
 	ppc_mflr (code, ppc_r0);
 	ppc_stw (code, ppc_r0, PPC_RET_ADDR_OFFSET, ppc_sp);
 	alloc_size = 32 + PPC_MINIMAL_STACK_SIZE + (sizeof (gulong) * 19 + sizeof (gdouble) * 18);
-	// align to PPC_STACK_ALIGNMENT bytes
+	/* align to PPC_STACK_ALIGNMENT bytes */
 	if (alloc_size & (PPC_STACK_ALIGNMENT - 1))
 		alloc_size += PPC_STACK_ALIGNMENT - (alloc_size & (PPC_STACK_ALIGNMENT - 1));
 	g_assert ((alloc_size & (PPC_STACK_ALIGNMENT-1)) == 0);
@@ -620,7 +620,7 @@
 	ppc_mflr (code, ppc_r0);
 	ppc_stw (code, ppc_r0, PPC_RET_ADDR_OFFSET, ppc_sp);
 	alloc_size = 32 + PPC_MINIMAL_STACK_SIZE + (sizeof (gulong) * 19 + sizeof (gdouble) * 18);
-	// align to PPC_STACK_ALIGNMENT bytes
+	/* align to PPC_STACK_ALIGNMENT bytes */
 	if (alloc_size & (PPC_STACK_ALIGNMENT - 1)) {
 		alloc_size += PPC_STACK_ALIGNMENT - 1;
 		alloc_size &= ~(PPC_STACK_ALIGNMENT - 1);
@@ -628,7 +628,7 @@
 	/*g_print ("alloc size = %d\n", alloc_size);*/
 	g_assert ((alloc_size & (PPC_STACK_ALIGNMENT-1)) == 0);
 	ppc_stwu (code, ppc_sp, -alloc_size, ppc_sp);
-	//ppc_break (code);
+	/* ppc_break (code); */
 	if (by_name) {
 		ppc_mr (code, ppc_r5, ppc_r3);
 		ppc_load (code, ppc_r3, mono_defaults.corlib);
Index: mono/mini/exceptions-s390.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/exceptions-s390.c,v
retrieving revision 1.3
diff -u -r1.3 exceptions-s390.c
--- mono/mini/exceptions-s390.c	19 Apr 2004 19:05:05 -0000	1.3
+++ mono/mini/exceptions-s390.c	24 Apr 2004 17:33:44 -0000
@@ -325,14 +325,16 @@
 			    res->saved [X86_EBP] == 1 &&
 			    res->saved [X86_ESI] == 1 &&
 			    (ji = mono_jit_info_table_find (domain, frame->return_address))) {
-				//printf ("FRAME CFA %s\n", mono_method_full_name (ji->method, TRUE));
+				/* printf ("FRAME CFA %s\n", mono_method_full_name (ji->method, TRUE)); */
 				return ji;
 			}
 
 		} else {
-//			printf ("FRAME %p %p %p\n", 
-//				frame, MONO_CONTEXT_GET_IP (new_ctx), 
-//				mono_jit_info_table_find (domain, MONO_CONTEXT_GET_IP (new_ctx)));
+			/*
+			printf ("FRAME %p %p %p\n", 
+				frame, MONO_CONTEXT_GET_IP (new_ctx), 
+				mono_jit_info_table_find (domain, MONO_CONTEXT_GET_IP (new_ctx)));
+			*/
 
 			MONO_CONTEXT_SET_IP (new_ctx, frame->return_address);
 			frame = frame->next;
Index: mono/mini/exceptions-x86.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/exceptions-x86.c,v
retrieving revision 1.25
diff -u -r1.25 exceptions-x86.c
--- mono/mini/exceptions-x86.c	16 Apr 2004 09:51:05 -0000	1.25
+++ mono/mini/exceptions-x86.c	24 Apr 2004 17:33:45 -0000
@@ -429,12 +429,12 @@
 			    res->saved [X86_EBP] == 1 &&
 			    res->saved [X86_ESI] == 1 &&
 			    (ji = mono_jit_info_table_find (domain, frame->return_address))) {
-				//printf ("FRAME CFA %s\n", mono_method_full_name (ji->method, TRUE));
+				/* printf ("FRAME CFA %s\n", mono_method_full_name (ji->method, TRUE)); */
 				return ji;
 			}
 
 		} else {
-			//printf ("FRAME %p %p %p\n", frame, MONO_CONTEXT_GET_IP (new_ctx), mono_jit_info_table_find (domain, MONO_CONTEXT_GET_IP (new_ctx)));
+			/* printf ("FRAME %p %p %p\n", frame, MONO_CONTEXT_GET_IP (new_ctx), mono_jit_info_table_find (domain, MONO_CONTEXT_GET_IP (new_ctx))); */
 
 			MONO_CONTEXT_SET_IP (new_ctx, frame->return_address);
 			frame = frame->next;
@@ -451,8 +451,9 @@
 		}
 	}
 
-	//if (!lmf)
-	//g_assert_not_reached ();
+	/* if (!lmf)
+	g_assert_not_reached (); 
+	*/
 
 	if (trace) {
 		g_free (*trace);
@@ -1094,7 +1095,7 @@
 
 		if (ji != (gpointer)-1) {
 			frame_count ++;
-			//printf ("M: %s %p %p %d.\n", mono_method_full_name (ji->method, TRUE), jit_tls->end_of_stack, ctx->ebp, count);
+			/* printf ("M: %s %p %p %d.\n", mono_method_full_name (ji->method, TRUE), jit_tls->end_of_stack, ctx->ebp, count); */
 
 			if (test_only && ji->method->wrapper_type != MONO_WRAPPER_RUNTIME_INVOKE && mono_ex) {
 				char *tmp, *strace;
Index: mono/mini/graph.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/graph.c,v
retrieving revision 1.3
diff -u -r1.3 graph.c
--- mono/mini/graph.c	1 Sep 2003 14:56:19 -0000	1.3
+++ mono/mini/graph.c	24 Apr 2004 17:33:45 -0000
@@ -331,7 +331,7 @@
 
 	fclose (fp);
 
-	//com = g_strdup_printf ("dot %s -Tpng -o %s.png; eog %s.png", fn, fn, fn);
+	/* com = g_strdup_printf ("dot %s -Tpng -o %s.png; eog %s.png", fn, fn, fn); */
 	com = g_strdup_printf ("dot %s -Tps -o %s.ps;gv %s.ps", fn, fn, fn);
 	system (com);
 	g_free (com);
Index: mono/mini/inssel-ppc.brg
===================================================================
RCS file: /cvs/public/mono/mono/mini/inssel-ppc.brg,v
retrieving revision 1.9
diff -u -r1.9 inssel-ppc.brg
--- mono/mini/inssel-ppc.brg	18 Mar 2004 18:27:35 -0000	1.9
+++ mono/mini/inssel-ppc.brg	24 Apr 2004 17:33:45 -0000
@@ -242,7 +242,7 @@
 		MONO_EMIT_NEW_UNALU (s, OP_SETREG, start_reg + i, tmpr);
 		soffset += sizeof (gpointer);
 	}
-	//g_print ("vt size: %d at R%d + %d\n", tree->inst_imm, vt->inst_basereg, vt->inst_offset);
+	/* g_print ("vt size: %d at R%d + %d\n", tree->inst_imm, vt->inst_basereg, vt->inst_offset); */
 	if (ovf_size != 0) {
 		mini_emit_memcpy (s, s->frame_reg, tree->inst_imm + (soffset - vt->inst_offset), vt->inst_basereg, soffset, ovf_size * sizeof (gpointer), 0);
 	}
Index: mono/mini/inssel-sparc.brg
===================================================================
RCS file: /cvs/public/mono/mono/mini/inssel-sparc.brg,v
retrieving revision 1.12
diff -u -r1.12 inssel-sparc.brg
--- mono/mini/inssel-sparc.brg	2 Apr 2004 15:23:11 -0000	1.12
+++ mono/mini/inssel-sparc.brg	24 Apr 2004 17:33:45 -0000
@@ -338,14 +338,18 @@
 }
 
 stmt: CEE_ENDFINALLY {
-	//MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
-	//MONO_EMIT_NEW_LOAD_MEMBASE (s, sparc_o7, spvar->inst_basereg, spvar->inst_offset); 
+	/*
+	MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
+	MONO_EMIT_NEW_LOAD_MEMBASE (s, sparc_o7, spvar->inst_basereg, spvar->inst_offset); 
+	*/
 	mono_bblock_add_inst (s->cbb, tree);
 }
 
 stmt: OP_ENDFILTER (reg) {
-	//MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
-	//MONO_EMIT_NEW_LOAD_MEMBASE (s, sparc_o7, spvar->inst_basereg, spvar->inst_offset); 
+	/*
+	MonoInst *spvar = mono_find_spvar_for_region (s, s->cbb->region);
+	MONO_EMIT_NEW_LOAD_MEMBASE (s, sparc_o7, spvar->inst_basereg, spvar->inst_offset); 
+	*/
 	tree->sreg1 = state->left->reg1;
 	mono_bblock_add_inst (s->cbb, tree);
 }
Index: mono/mini/inssel-x86.brg
===================================================================
RCS file: /cvs/public/mono/mono/mini/inssel-x86.brg,v
retrieving revision 1.19
diff -u -r1.19 inssel-x86.brg
--- mono/mini/inssel-x86.brg	13 Apr 2004 20:15:05 -0000	1.19
+++ mono/mini/inssel-x86.brg	24 Apr 2004 17:33:45 -0000
@@ -320,7 +320,7 @@
 
 stmt: OP_OUTARG_VT (CEE_LDOBJ (base)) {
 	MonoInst *vt = state->left->left->tree;
-	//g_print ("vt size: %d at R%d + %d\n", tree->inst_imm, vt->inst_basereg, vt->inst_offset);
+	/* g_print ("vt size: %d at R%d + %d\n", tree->inst_imm, vt->inst_basereg, vt->inst_offset); */
 
 	if (!tree->inst_imm)
 		return;
Index: mono/mini/inssel.brg
===================================================================
RCS file: /cvs/public/mono/mono/mini/inssel.brg,v
retrieving revision 1.39
diff -u -r1.39 inssel.brg
--- mono/mini/inssel.brg	14 Apr 2004 10:31:49 -0000	1.39
+++ mono/mini/inssel.brg	24 Apr 2004 17:33:45 -0000
@@ -291,9 +291,11 @@
 	inst->inst_basereg = state->reg1;
 	inst->inst_offset = 0;
 	state->tree = inst;
-	//g_print ("mybase: (assigned R%d from R%d - R%d)\n", state->reg1, tree->dreg, state->reg2);
-	//tree->inst_offset = 0;
-	//tree->inst_basereg = state->reg1;
+	/*
+	g_print ("mybase: (assigned R%d from R%d - R%d)\n", state->reg1, tree->dreg, state->reg2);
+	tree->inst_offset = 0;
+	tree->inst_basereg = state->reg1;
+	*/
 }
 
 base: CEE_LDIND_I (OP_REGVAR) "0" {
@@ -1447,7 +1449,7 @@
 	/* FIXME: generics */
 	g_assert (klass->rank == 0);
 
-	// Check rank == 0
+	/* Check rank == 0 */
 	MONO_EMIT_NEW_BIALU_IMM (s, OP_COMPARE_IMM, -1, rank_reg, 0);
 	MONO_EMIT_NEW_COND_EXC (s, NE_UN, "InvalidCastException");
 
Index: mono/mini/jit-icalls.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/jit-icalls.c,v
retrieving revision 1.21
diff -u -r1.21 jit-icalls.c
--- mono/mini/jit-icalls.c	31 Mar 2004 02:12:49 -0000	1.21
+++ mono/mini/jit-icalls.c	24 Apr 2004 17:33:45 -0000
@@ -113,7 +113,7 @@
 
 	MONO_ARCH_SAVE_REGS;
 
-	// fixme: this is incredible slow
+	/* fixme: this is incredible slow */
 
 	if (ah && bh)
 		goto raise_exception;
@@ -384,7 +384,7 @@
 	
 	MONO_ARCH_SAVE_REGS;
 
-	//printf ("SFLDA0 %s.%s::%s %d\n", field->parent->name_space, field->parent->name, field->name, field->offset, field->parent->inited);
+	/* printf ("SFLDA0 %s.%s::%s %d\n", field->parent->name_space, field->parent->name, field->name, field->offset, field->parent->inited); */
 
 	mono_class_init (field->parent);
 
@@ -392,7 +392,7 @@
 	if (!vtable->initialized)
 		mono_runtime_class_init (vtable);
 
-	//printf ("SFLDA1 %p\n", (char*)vtable->data + field->offset);
+	/*  printf ("SFLDA1 %p\n", (char*)vtable->data + field->offset); */
 
 	if (domain->special_static_fields && (addr = g_hash_table_lookup (domain->special_static_fields, field)))
 		addr = mono_get_special_static_data (GPOINTER_TO_UINT (addr));
Index: mono/mini/linear-scan.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/linear-scan.c,v
retrieving revision 1.6
diff -u -r1.6 linear-scan.c
--- mono/mini/linear-scan.c	26 Feb 2004 13:58:52 -0000	1.6
+++ mono/mini/linear-scan.c	24 Apr 2004 17:33:45 -0000
@@ -63,7 +63,7 @@
 	return NULL;
 }
 
-//#define DEBUG_LSCAN
+/* #define DEBUG_LSCAN */
 
 void
 mono_linear_scan (MonoCompile *cfg, GList *vars, GList *regs, regmask_t *used_mask)
Index: mono/mini/liveness.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/liveness.c,v
retrieving revision 1.6
diff -u -r1.6 liveness.c
--- mono/mini/liveness.c	19 Apr 2004 10:38:25 -0000	1.6
+++ mono/mini/liveness.c	24 Apr 2004 17:33:46 -0000
@@ -10,7 +10,7 @@
 #include "mini.h"
 #include "inssel.h"
 
-//#define DEBUG_LIVENESS
+/* #define DEBUG_LIVENESS */
 
 extern guint8 mono_burg_arity [];
 
@@ -207,7 +207,7 @@
 		int tree_num;
 
 		for (tree_num = 0, inst = bb->code; inst; inst = inst->next, tree_num++) {
-			//mono_print_tree (inst); printf ("\n");
+		        /* mono_print_tree (inst); printf ("\n"); */
 			update_gen_kill_set (cfg, bb, inst, tree_num);
 		}
 
@@ -301,7 +301,7 @@
 		}
 	} while (changes);
 
-	//printf ("IT: %d %d %d.\n", iterations, in_iter, out_iter);
+	/* printf ("IT: %d %d %d.\n", iterations, in_iter, out_iter); */
 
 	mono_bitset_free (old_live_in_set);
 	mono_bitset_free (old_live_out_set);
Index: mono/mini/mini-ppc.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-ppc.c,v
retrieving revision 1.54
diff -u -r1.54 mini-ppc.c
--- mono/mini/mini-ppc.c	23 Apr 2004 21:54:31 -0000	1.54
+++ mono/mini/mini-ppc.c	24 Apr 2004 17:33:46 -0000
@@ -198,7 +198,7 @@
 }
 
 #define USE_EXTRA_TEMPS ((1<<30) | (1<<29))
-//#define USE_EXTRA_TEMPS 0
+/* #define USE_EXTRA_TEMPS 0 */
 
 GList *
 mono_arch_get_global_int_regs (MonoCompile *cfg)
@@ -230,7 +230,7 @@
 	return 3;
 }
 
-// code from ppc/tramp.c, try to keep in sync
+/* code from ppc/tramp.c, try to keep in sync */
 #define MIN_CACHE_LINE 8
 
 void
@@ -306,7 +306,7 @@
 	} else {
 		if (*gr >= 3 + PPC_NUM_REG_ARGS - 1) {
 #ifdef ALIGN_DOUBLES
-			//*stack_size += (*stack_size % 8);
+			/* *stack_size += (*stack_size % 8); */
 #endif
 			ainfo->offset = PPC_STACK_PARAM_OFFSET + *stack_size;
 			ainfo->reg = ppc_sp; /* in the caller */
@@ -611,8 +611,8 @@
 	 */
 	offset = PPC_MINIMAL_STACK_SIZE; /* linkage area */
 	/* align the offset to 16 bytes: not sure this is needed here  */
-	//offset += 16 - 1;
-	//offset &= ~(16 - 1);
+	/* offset += 16 - 1; */
+	/* offset &= ~(16 - 1); */
 
 	/* add parameter area size for called functions */
 	offset += m->param_area;
@@ -664,7 +664,7 @@
 		inst->opcode = OP_REGOFFSET;
 		inst->inst_basereg = frame_reg;
 		offset += size;
-		//g_print ("allocating local %d to %d\n", i, inst->inst_offset);
+		/* g_print ("allocating local %d to %d\n", i, inst->inst_offset); */
 	}
 
 	curinst = 0;
@@ -1049,7 +1049,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -1077,7 +1077,7 @@
 					ins->sreg1 = last_ins->dreg;
 				}
 
-				//g_assert_not_reached ();
+				/* g_assert_not_reached (); */
 
 #if 0
 			/* 
@@ -1091,10 +1091,10 @@
 						|| last_ins->opcode == OP_STORE_MEMBASE_IMM) &&
 				   ins->inst_basereg == last_ins->inst_destbasereg &&
 				   ins->inst_offset == last_ins->inst_offset) {
-				//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+				/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 				ins->opcode = OP_ICONST;
 				ins->inst_c0 = last_ins->inst_imm;
-				g_assert_not_reached (); // check this rule
+				g_assert_not_reached (); /* check this rule */
 #endif
 			}
 			break;
@@ -1108,7 +1108,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -1124,7 +1124,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -1270,7 +1270,7 @@
 
 #undef DEBUG
 #define DEBUG(a) if (cfg->verbose_level > 1) a
-//#define DEBUG(a)
+/* #define DEBUG(a) */
 #define reg_is_freeable(r) ((r) >= 3 && (r) <= 10)
 #define freg_is_freeable(r) ((r) >= 1 && (r) <= 14)
 
@@ -1847,7 +1847,7 @@
 						/* the register gets spilled after this inst */
 						spill = -val -1;
 					}
-					//g_assert (val == -1); /* source cannot be spilled */
+					/* g_assert (val == -1); /* source cannot be spilled */
 					val = mono_regstate_alloc_float (rs, src1_mask);
 					if (val < 0)
 						val = get_float_register_spilling (cfg, tmp, ins, src1_mask, ins->sreg1);
@@ -1883,10 +1883,10 @@
 					 */
 					mono_regstate_alloc_int (rs, 1 << ins->dreg);
 					val = rs->iassign [ins->sreg1] = ins->dreg;
-					//g_assert (val >= 0);
+					/* g_assert (val >= 0); */
 					DEBUG (g_print ("\tfast assigned sreg1 %s to R%d\n", mono_arch_regname (val), ins->sreg1));
 				} else {
-					//g_assert (val == -1); /* source cannot be spilled */
+					/* g_assert (val == -1); /* source cannot be spilled */
 					val = mono_regstate_alloc_int (rs, src1_mask);
 					if (val < 0)
 						val = get_register_spilling (cfg, tmp, ins, src1_mask, ins->sreg1);
@@ -1955,7 +1955,7 @@
 			for (j = 0; j < MONO_MAX_IREGS; ++j) {
 				s = 1 << j;
 				if ((clob_mask & s) && !(rs->ifree_mask & s) && j != ins->sreg1) {
-					//g_warning ("register %s busy at call site\n", mono_arch_regname (j));
+					/* g_warning ("register %s busy at call site\n", mono_arch_regname (j)); */
 				}
 			}
 		}
@@ -1968,7 +1968,7 @@
 			mono_regstate_free_int (rs, ins->sreg2);
 		}*/
 		
-		//DEBUG (print_ins (i, ins));
+		/* DEBUG (print_ins (i, ins)); */
 		tmp = tmp->next;
 	}
 }
@@ -2070,10 +2070,10 @@
 	ppc_lis (templ, ppc_r0, (guint32)(pdata->target) >> 16);
 	ppc_ori (templ, ppc_r0, ppc_r0, (guint32)(pdata->target) & 0xffff);
 
-	//g_print ("thunk nentries: %d\n", ((char*)endthunks - (char*)thunks)/16);
+	/* g_print ("thunk nentries: %d\n", ((char*)endthunks - (char*)thunks)/16); */
 	if ((pdata->found == 2) || (pdata->code >= code && pdata->code <= code + csize)) {
 		while (thunks < endthunks) {
-			//g_print ("looking for target: %p at %p (%08x-%08x)\n", pdata->target, thunks, thunks [0], thunks [1]);
+			/* g_print ("looking for target: %p at %p (%08x-%08x)\n", pdata->target, thunks, thunks [0], thunks [1]); */
 			if ((thunks [0] == load [0]) && (thunks [1] == load [1])) {
 				ppc_patch (pdata->code, (guchar*)thunks);
 				mono_arch_flush_icache (pdata->code, 4);
@@ -2097,7 +2097,7 @@
 			thunks += 4;
 			count++;
 		}
-		//g_print ("failed thunk lookup for %p from %p at %p (%d entries)\n", pdata->target, pdata->code, data, count);
+		/* g_print ("failed thunk lookup for %p from %p at %p (%d entries)\n", pdata->target, pdata->code, data, count); */
 	}
 	return 0;
 }
@@ -2134,7 +2134,7 @@
 	guint32 prim = ins >> 26;
 	guint32 ovf;
 
-	//g_print ("patching 0x%08x (0x%08x) to point to 0x%08x\n", code, ins, target);
+	/* g_print ("patching 0x%08x (0x%08x) to point to 0x%08x\n", code, ins, target); */
 	if (prim == 18) {
 		if (target >= 0){
 			if (target < 33554431){
@@ -2175,7 +2175,7 @@
 	}
 	
 #if OLD_REFERENCE_CODE
-		// absolute address
+		/* absolute address */
 		if (ins & 2) {
 			gint diff = (gint)target;
 			if ((diff < -33554432) || (diff > 33554431)) {
@@ -2214,7 +2214,7 @@
 #endif
 	
 	if (prim == 16) {
-		// absolute address
+		/* absolute address */
 		if (ins & 2) {
 			guint32 li = (guint32)target;
 			ins = (ins & 0xffff0000) | (ins & 3);
@@ -2223,7 +2223,7 @@
 				g_assert_not_reached ();
 			li &= 0xffff;
 			ins |= li;
-			// FIXME: assert the top bits of li are 0
+			/* FIXME: assert the top bits of li are 0 */
 		} else {
 			gint diff = target - code;
 			ins = (ins & 0xffff0000) | (ins & 3);
@@ -2237,7 +2237,7 @@
 	} else {
 		g_assert_not_reached ();
 	}
-//	g_print ("patched with 0x%08x\n", ins);
+/*	g_print ("patched with 0x%08x\n", ins); */
 }
 
 void
@@ -2262,14 +2262,15 @@
 	cpos = bb->max_offset;
 
 	if (cfg->prof_options & MONO_PROFILE_COVERAGE) {
-		//MonoCoverageInfo *cov = mono_get_coverage_info (cfg->method);
-		//g_assert (!mono_compile_aot);
-		//cpos += 6;
-		//if (bb->cil_code)
-		//	cov->data [bb->dfn].iloffset = bb->cil_code - cfg->cil_code;
+		/* MonoCoverageInfo *cov = mono_get_coverage_info (cfg->method);
+		   g_assert (!mono_compile_aot);
+		   cpos += 6;
+		   if (bb->cil_code)
+		   	cov->data [bb->dfn].iloffset = bb->cil_code - cfg->cil_code;
+		*/
 		/* this is not thread save, but good enough */
 		/* fixme: howto handle overflows? */
-		//x86_inc_mem (code, &cov->data [bb->dfn].count); 
+		/* x86_inc_mem (code, &cov->data [bb->dfn].count);  */
 	}
 
 	ins = bb->code;
@@ -2283,9 +2284,10 @@
 			cfg->native_code = g_realloc (cfg->native_code, cfg->code_size);
 			code = cfg->native_code + offset;
 		}
-	//	if (ins->cil_code)
-	//		g_print ("cil code\n");
-
+		/*
+		if (ins->cil_code)
+			g_print ("cil code\n");
+		*/
 		switch (ins->opcode) {
 		case OP_BIGMUL:
 			ppc_mullw (code, ppc_r4, ins->sreg1, ins->sreg2);
@@ -2328,12 +2330,12 @@
 		case CEE_LDIND_I4:
 		case CEE_LDIND_U4:
 			g_assert_not_reached ();
-			//x86_mov_reg_mem (code, ins->dreg, ins->inst_p0, 4);
+			/* x86_mov_reg_mem (code, ins->dreg, ins->inst_p0, 4); */
 			break;
 		case OP_LOADU4_MEM:
 			g_assert_not_reached ();
-			//x86_mov_reg_imm (code, ins->dreg, ins->inst_p0);
-			//x86_mov_reg_membase (code, ins->dreg, ins->dreg, 0, 4);
+			/* x86_mov_reg_imm (code, ins->dreg, ins->inst_p0); */
+			/* x86_mov_reg_membase (code, ins->dreg, ins->dreg, 0, 4); */
 			break;
 		case OP_LOAD_MEMBASE:
 		case OP_LOADI4_MEMBASE:
@@ -2440,7 +2442,7 @@
 			ppc_subfe (code, ins->dreg, ins->sreg2, ins->sreg1);
 			break;
 		case OP_SUB_IMM:
-			// we add the negated value
+			/* we add the negated value */
 			if (ppc_is_imm16 (-ins->inst_imm))
 				ppc_addi (code, ins->dreg, ins->sreg1, -ins->inst_imm);
 			else {
@@ -2549,22 +2551,22 @@
 			break;
 		case OP_SHL_IMM:
 			ppc_rlwinm (code, ins->dreg, ins->sreg1, (ins->inst_imm & 0x1f), 0, (31 - (ins->inst_imm & 0x1f)));
-			//ppc_load (code, ppc_r11, ins->inst_imm);
-			//ppc_slw (code, ins->sreg1, ins->dreg, ppc_r11);
+			/* ppc_load (code, ppc_r11, ins->inst_imm); */
+			/* ppc_slw (code, ins->sreg1, ins->dreg, ppc_r11); */
 			break;
 		case CEE_SHR:
 			ppc_sraw (code, ins->dreg, ins->sreg1, ins->sreg2);
 			break;
 		case OP_SHR_IMM:
-			// there is also ppc_srawi
-			//ppc_load (code, ppc_r11, ins->inst_imm);
-			//ppc_sraw (code, ins->dreg, ins->sreg1, ppc_r11);
+			/* there is also ppc_srawi */
+			/* ppc_load (code, ppc_r11, ins->inst_imm); */
+			/* ppc_sraw (code, ins->dreg, ins->sreg1, ppc_r11); */
 			ppc_srawi (code, ins->dreg, ins->sreg1, (ins->inst_imm & 0x1f));
 			break;
 		case OP_SHR_UN_IMM:
 			ppc_load (code, ppc_r11, ins->inst_imm);
 			ppc_srw (code, ins->dreg, ins->sreg1, ppc_r11);
-			//ppc_rlwinm (code, ins->dreg, ins->sreg1, (32 - (ins->inst_imm & 0xf)), (ins->inst_imm & 0xf), 31);
+			/* ppc_rlwinm (code, ins->dreg, ins->sreg1, (32 - (ins->inst_imm & 0xf)), (ins->inst_imm & 0xf), 31); */
 			break;
 		case CEE_SHR_UN:
 			ppc_srw (code, ins->dreg, ins->sreg1, ins->sreg2);
@@ -2704,7 +2706,7 @@
 			ppc_blr (code);
 			break;
 		case CEE_THROW: {
-			//ppc_break (code);
+			/* ppc_break (code); */
 			ppc_mr (code, ppc_r3, ins->sreg1);
 			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
 					     (gpointer)"mono_arch_throw_exception");
@@ -2735,13 +2737,15 @@
 			ins->inst_c0 = code - cfg->native_code;
 			break;
 		case CEE_BR:
-			//g_print ("target: %p, next: %p, curr: %p, last: %p\n", ins->inst_target_bb, bb->next_bb, ins, bb->last_ins);
-			//if ((ins->inst_target_bb == bb->next_bb) && ins == bb->last_ins)
-			//break;
+			/*
+			 g_print ("target: %p, next: %p, curr: %p, last: %p\n", ins->inst_target_bb, bb->next_bb, ins, bb->last_ins);
+			 if ((ins->inst_target_bb == bb->next_bb) && ins == bb->last_ins)
+			 break;
+			*/
 			if (ins->flags & MONO_INST_BRLABEL) {
 				/*if (ins->inst_i0->inst_c0) {
 					ppc_b (code, 0);
-					//x86_jump_code (code, cfg->native_code + ins->inst_i0->inst_c0);
+					/* x86_jump_code (code, cfg->native_code + ins->inst_i0->inst_c0); */
 				} else*/ {
 					mono_add_patch_info (cfg, offset, MONO_PATCH_INFO_LABEL, ins->inst_i0);
 					ppc_b (code, 0);
@@ -2749,7 +2753,7 @@
 			} else {
 				/*if (ins->inst_target_bb->native_offset) {
 					ppc_b (code, 0);
-					//x86_jump_code (code, cfg->native_code + ins->inst_target_bb->native_offset); 
+					/* x86_jump_code (code, cfg->native_code + ins->inst_target_bb->native_offset);  */
 				} else*/ {
 					mono_add_patch_info (cfg, offset, MONO_PATCH_INFO_BB, ins->inst_target_bb);
 					ppc_b (code, 0);
@@ -2852,7 +2856,7 @@
 		case CEE_CONV_R4: /* FIXME: change precision */
 		case CEE_CONV_R8: {
 			static const guint64 adjust_val = 0x4330000080000000UL;
-			// addis is special for ppc_r0
+			/* addis is special for ppc_r0 */
 			ppc_addis (code, ppc_r0, ppc_r0, 0x4330);
 			ppc_stw (code, ppc_r0, -8, ppc_sp);
 			ppc_xoris (code, ins->sreg1, ppc_r11, 0x8000);
@@ -3103,9 +3107,9 @@
 			gpointer *table = (gpointer *)patch_info->data.target;
 			int i;
 
-			// FIXME: inspect code to get the register
+			/* FIXME: inspect code to get the register */
 			ppc_load (ip, ppc_r11, patch_info->data.target);
-			//*((gconstpointer *)(ip + 2)) = patch_info->data.target;
+			/* *((gconstpointer *)(ip + 2)) = patch_info->data.target; */
 
 			for (i = 0; i < patch_info->table_size; i++) {
 				table [i] = (int)patch_info->data.table [i] + code;
@@ -3273,7 +3277,7 @@
 		}*/
 	}
 	alloc_size += pos;
-	// align to PPC_STACK_ALIGNMENT bytes
+	/* align to PPC_STACK_ALIGNMENT bytes */
 	if (alloc_size & (PPC_STACK_ALIGNMENT - 1)) {
 		alloc_size += PPC_STACK_ALIGNMENT - 1;
 		alloc_size &= ~(PPC_STACK_ALIGNMENT - 1);
Index: mono/mini/mini-s390.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-s390.c,v
retrieving revision 1.4
diff -u -r1.4 mini-s390.c
--- mono/mini/mini-s390.c	20 Apr 2004 18:44:13 -0000	1.4
+++ mono/mini/mini-s390.c	24 Apr 2004 17:33:47 -0000
@@ -1333,7 +1333,7 @@
 		inst->opcode 	   = OP_REGOFFSET;
 		inst->inst_basereg = frame_reg;
 		offset 		  += size;
-		//g_print ("allocating local %d to %d\n", i, inst->inst_offset);
+		/* g_print ("allocating local %d to %d\n", i, inst->inst_offset); */
 	}
 
 	curinst = 0;
@@ -1746,7 +1746,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -1774,7 +1774,7 @@
 					ins->sreg1 = last_ins->dreg;
 				}
 
-				//g_assert_not_reached ();
+				/* g_assert_not_reached (); */
 
 #if 0
 			/* 
@@ -1788,10 +1788,10 @@
 						|| last_ins->opcode == OP_STORE_MEMBASE_IMM) &&
 				   ins->inst_basereg == last_ins->inst_destbasereg &&
 				   ins->inst_offset == last_ins->inst_offset) {
-				//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+				/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 				ins->opcode = OP_ICONST;
 				ins->inst_c0 = last_ins->inst_imm;
-				g_assert_not_reached (); // check this rule
+				g_assert_not_reached (); /* check this rule */
 #endif
 			}
 			break;
@@ -1805,7 +1805,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -2634,7 +2634,7 @@
 						/* the register gets spilled after this inst */
 						spill = -val -1;
 					}
-					//g_assert (val == -1); /* source cannot be spilled */
+					/* g_assert (val == -1); /* source cannot be spilled */
 					val = mono_regstate_alloc_float (rs, src1_mask);
 					if (val < 0)
 						val = get_float_register_spilling (cfg, tmp, ins, src1_mask, ins->sreg1);
@@ -2670,10 +2670,10 @@
 					 */
 					mono_regstate_alloc_int (rs, 1 << ins->dreg);
 					val = rs->iassign [ins->sreg1] = ins->dreg;
-					//g_assert (val >= 0);
+					/* g_assert (val >= 0); */
 					DEBUG (g_print ("\tfast assigned sreg1 %s to R%d\n", mono_arch_regname (val), ins->sreg1));
 				} else {
-					//g_assert (val == -1); /* source cannot be spilled */
+					/* g_assert (val == -1); /* source cannot be spilled */
 					val = mono_regstate_alloc_int (rs, src1_mask);
 					if (val < 0)
 						val = get_register_spilling (cfg, tmp, ins, src1_mask, ins->sreg1);
@@ -2764,7 +2764,7 @@
 			for (j = 0; j < MONO_MAX_IREGS; ++j) {
 				s = 1 << j;
 				if ((clob_mask & s) && !(rs->ifree_mask & s) && j != ins->sreg1) {
-					//g_warning ("register %s busy at call site\n", mono_arch_regname (j));
+					/* g_warning ("register %s busy at call site\n", mono_arch_regname (j)); */
 				}
 			}
 		}
@@ -2777,7 +2777,7 @@
 			mono_regstate_free_int (rs, ins->sreg2);
 		}*/
 		
-		//DEBUG (print_ins (i, ins));
+		/* DEBUG (print_ins (i, ins)); */
 		tmp = tmp->next;
 	}
 }
@@ -2864,14 +2864,15 @@
 	cpos = bb->max_offset;
 
 	if (cfg->prof_options & MONO_PROFILE_COVERAGE) {
-		//MonoCoverageInfo *cov = mono_get_coverage_info (cfg->method);
-		//g_assert (!mono_compile_aot);
-		//cpos += 6;
-		//if (bb->cil_code)
-		//	cov->data [bb->dfn].iloffset = bb->cil_code - cfg->cil_code;
+		/* MonoCoverageInfo *cov = mono_get_coverage_info (cfg->method);
+		g_assert (!mono_compile_aot);
+		cpos += 6;
+		if (bb->cil_code)
+			cov->data [bb->dfn].iloffset = bb->cil_code - cfg->cil_code;
+		*/
 		/* this is not thread save, but good enough */
 		/* fixme: howto handle overflows? */
-		//x86_inc_mem (code, &cov->data [bb->dfn].count); 
+		/* x86_inc_mem (code, &cov->data [bb->dfn].count);  */
 	}
 
 	ins = bb->code;
@@ -3593,8 +3594,9 @@
 			s390_br  (code, s390_r14);
 			break;
 		case CEE_ENDFINALLY:
-//			s390_l   (code, STK_BASE, 0, STK_BASE, 0);
-//			s390_lm  (code, s390_r6, s390_r14, STK_BASE, S390_REG_SAVE_OFFSET);
+/*			s390_l   (code, STK_BASE, 0, STK_BASE, 0);
+			s390_lm  (code, s390_r6, s390_r14, STK_BASE, S390_REG_SAVE_OFFSET);
+*/
 			s390_l   (code, s390_r14, 0, ins->inst_left->inst_basereg, ins->inst_left->inst_offset);
 			s390_br  (code, s390_r14);
 			break;
Index: mono/mini/mini-sparc.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-sparc.c,v
retrieving revision 1.33
diff -u -r1.33 mini-sparc.c
--- mono/mini/mini-sparc.c	19 Apr 2004 19:05:05 -0000	1.33
+++ mono/mini/mini-sparc.c	24 Apr 2004 17:33:48 -0000
@@ -614,7 +614,7 @@
 		inst = m->varinfo [i];
 
 		if (inst->opcode == OP_REGVAR) {
-			//g_print ("allocating local %d to %s\n", i, mono_arch_regname (inst->dreg));
+			/* g_print ("allocating local %d to %s\n", i, mono_arch_regname (inst->dreg)); */
 			continue;
 		}
 
@@ -645,7 +645,7 @@
 		inst->inst_basereg = sparc_fp;
 		inst->inst_offset = -offset;
 
-		//g_print ("allocating local %d to [%s - %d]\n", i, mono_arch_regname (inst->inst_basereg), - inst->inst_offset);
+		/* g_print ("allocating local %d to [%s - %d]\n", i, mono_arch_regname (inst->inst_basereg), - inst->inst_offset); */
 	}
 
 	if (sig->call_convention == MONO_CALL_VARARG) {
@@ -1120,7 +1120,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -1148,7 +1148,7 @@
 					ins->sreg1 = last_ins->dreg;
 				}
 
-				//g_assert_not_reached ();
+				/* g_assert_not_reached (); */
 
 #if 0
 			/* 
@@ -1162,10 +1162,10 @@
 						|| last_ins->opcode == OP_STORE_MEMBASE_IMM) &&
 				   ins->inst_basereg == last_ins->inst_destbasereg &&
 				   ins->inst_offset == last_ins->inst_offset) {
-				//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+				/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 				ins->opcode = OP_ICONST;
 				ins->inst_c0 = last_ins->inst_imm;
-				g_assert_not_reached (); // check this rule
+				g_assert_not_reached (); /* check this rule */
 #endif
 			}
 			break;
@@ -1179,7 +1179,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -1195,7 +1195,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -1308,7 +1308,7 @@
 
 #undef DEBUG
 #define DEBUG(a) if (cfg->verbose_level > 1) a
-//#define DEBUG(a)
+/* #define DEBUG(a) */
 #define reg_is_freeable(r) ((1 << (r)) & ARCH_CALLER_REGS)
 #define freg_is_freeable(r) (((1) << (r)) & ARCH_CALLER_FREGS)
 
@@ -1957,7 +1957,7 @@
 						/* the register gets spilled after this inst */
 						spill = -val -1;
 					}
-					//g_assert (val == -1); /* source cannot be spilled */
+					/* g_assert (val == -1); /* source cannot be spilled */ 
 					src1_mask = cur_fregs;
 					val = mono_regstate_alloc_float (rs, src1_mask);
 					if (val < 0)
@@ -1994,10 +1994,10 @@
 					 */
 					mono_regstate_alloc_int (rs, 1 << ins->dreg);
 					val = rs->iassign [ins->sreg1] = ins->dreg;
-					//g_assert (val >= 0);
+					/* g_assert (val >= 0); */
 					DEBUG (g_print ("\tfast assigned sreg1 %s to R%d\n", mono_arch_regname (val), ins->sreg1));
 				} else {
-					//g_assert (val == -1); /* source cannot be spilled */
+					/* g_assert (val == -1); /* source cannot be spilled */
 					val = mono_regstate_alloc_int (rs, src1_mask);
 					if (val < 0)
 						val = get_register_spilling (cfg, tmp, ins, src1_mask, ins->sreg1);
@@ -2071,7 +2071,7 @@
 			for (j = 0; j < MONO_MAX_IREGS; ++j) {
 				s = 1 << j;
 				if ((clob_mask & s) && !(rs->ifree_mask & s) && j != ins->sreg1) {
-					//g_warning ("register %s busy at call site\n", mono_arch_regname (j));
+					/* g_warning ("register %s busy at call site\n", mono_arch_regname (j)); */
 				}
 			}
 		}
@@ -2084,7 +2084,7 @@
 			mono_regstate_free_int (rs, ins->sreg2);
 		}*/
 		
-		//DEBUG (print_ins (i, ins));
+		/* DEBUG (print_ins (i, ins)); */
 
 		tmp = tmp->next;
 	}
@@ -2099,7 +2099,7 @@
 	guint32 rd = (ins >> 25) & 0x1f;
 	gint32 disp = (target - code) >> 2;
 
-//	g_print ("patching 0x%08x (0x%08x) to point to 0x%08x\n", code, ins, target);
+/*	g_print ("patching 0x%08x (0x%08x) to point to 0x%08x\n", code, ins, target); *
 
 	if ((op == 0) && (op2 == 2)) {
 		if (!sparc_is_imm22 (disp))
@@ -2175,7 +2175,7 @@
 	else
 		NOT_IMPLEMENTED;
 
-//	g_print ("patched with 0x%08x\n", ins);
+	/* g_print ("patched with 0x%08x\n", ins); */
 }
 
 /*
@@ -2512,8 +2512,9 @@
 			code = (guint32*)(cfg->native_code + offset);
 		}
 		code_start = (guint8*)code;
-		//	if (ins->cil_code)
-		//		g_print ("cil code\n");
+		/* if (ins->cil_code)
+			g_print ("cil code\n");
+		*/
 
 		switch (ins->opcode) {
 		case OP_STOREI1_MEMBASE_IMM:
@@ -2636,7 +2637,7 @@
 			sparc_sub (code, FALSE, ins->sreg1, ins->sreg2, ins->dreg);
 			break;
 		case OP_SUB_IMM:
-			// we add the negated value
+			/* we add the negated value */
 			if (sparc_is_imm13 (- ins->inst_imm))
 				sparc_add_imm (code, FALSE, ins->sreg1, -ins->inst_imm, ins->dreg);
 			else {
@@ -3002,7 +3003,7 @@
 			ins->inst_c0 = (guint8*)code - cfg->native_code;
 			break;
 		case CEE_BR:
-			//g_print ("target: %p, next: %p, curr: %p, last: %p\n", ins->inst_target_bb, bb->next_bb, ins, bb->last_ins);
+			/* g_print ("target: %p, next: %p, curr: %p, last: %p\n", ins->inst_target_bb, bb->next_bb, ins, bb->last_ins); */
 			if ((ins->inst_target_bb == bb->next_bb) && ins == bb->last_ins)
 				break;
 			if (ins->flags & MONO_INST_BRLABEL) {
@@ -3035,7 +3036,7 @@
 		case OP_CLT_UN:
 		case OP_CGT:
 		case OP_CGT_UN:
-			//if (cfg->opt & MONO_OPT_CMOV) {
+			/* if (cfg->opt & MONO_OPT_CMOV) { */
 			if (0) {
 				sparc_clr_reg (code, ins->dreg);
 				sparc_movcc_imm (code, sparc_icc, opcode_to_sparc_cond (ins->opcode), 1, ins->dreg);
Index: mono/mini/mini-x86.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-x86.c,v
retrieving revision 1.87
diff -u -r1.87 mini-x86.c
--- mono/mini/mini-x86.c	19 Apr 2004 19:05:05 -0000	1.87
+++ mono/mini/mini-x86.c	24 Apr 2004 17:33:49 -0000
@@ -402,7 +402,7 @@
 		inst->opcode = OP_REGOFFSET;
 		inst->inst_basereg = X86_EBP;
 		inst->inst_offset = -offset;
-		//g_print ("allocating local %d to %d\n", i, -offset);
+		/* g_print ("allocating local %d to %d\n", i, -offset); */
 	}
 	offset += (MONO_ARCH_FRAME_ALIGNMENT - 1);
 	offset &= ~(MONO_ARCH_FRAME_ALIGNMENT - 1);
@@ -785,7 +785,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -813,7 +813,7 @@
 					ins->sreg1 = last_ins->dreg;
 				}
 
-				//g_assert_not_reached ();
+				/* g_assert_not_reached (); */
 
 #if 0
 			/* 
@@ -827,10 +827,10 @@
 						|| last_ins->opcode == OP_STORE_MEMBASE_IMM) &&
 				   ins->inst_basereg == last_ins->inst_destbasereg &&
 				   ins->inst_offset == last_ins->inst_offset) {
-				//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+				/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 				ins->opcode = OP_ICONST;
 				ins->inst_c0 = last_ins->inst_imm;
-				g_assert_not_reached (); // check this rule
+				g_assert_not_reached (); /* check this rule */
 #endif
 			}
 			break;
@@ -847,7 +847,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -866,7 +866,7 @@
 					ins = ins->next;				
 					continue;
 				} else {
-					//static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++);
+					/* static int c = 0; printf ("MATCHX %s %d\n", cfg->method->name,c++); */
 					ins->opcode = OP_MOVE;
 					ins->sreg1 = last_ins->sreg1;
 				}
@@ -911,7 +911,7 @@
 };
 
 #define DEBUG(a) if (cfg->verbose_level > 1) a
-//#define DEBUG(a)
+/* #define DEBUG(a) */
 
 /*
  * returns the offset used by spillvar. It allocates a new
@@ -1387,7 +1387,7 @@
 		ins = ins->next;
 	}
 
-	// todo: check if we have anything left on fp stack, in verify mode?
+	/* todo: check if we have anything left on fp stack, in verify mode? */
 	fspill = 0;
 
 	DEBUG (print_regtrack (reginfo, rs->next_vireg));
@@ -1457,7 +1457,7 @@
 					move->next = ins;
 					g_assert_not_reached ();
 					/* FIXME: where is move connected to the instruction list? */
-					//tmp->prev->data->next = move;
+					/* tmp->prev->data->next = move; */
 				}
 				if (need_ecx_spill && !(rs->ifree_mask & (1 << X86_ECX))) {
 					DEBUG (g_print ("\tforced spill of R%d\n", rs->isymbolic [X86_ECX]));
@@ -1510,7 +1510,7 @@
 					rs->ifree_mask &= ~ (1 << dest_reg);
 				}
 			} else {
-				//DEBUG (g_print ("dest reg in div assigned: %s\n", mono_arch_regname (val)));
+				/* DEBUG (g_print ("dest reg in div assigned: %s\n", mono_arch_regname (val))); */
 				if (val != dest_reg) { /* force a copy */
 					create_copy_ins (cfg, val, dest_reg, ins);
 					if (!(rs->ifree_mask & (1 << dest_reg)) && rs->isymbolic [dest_reg] >= MONO_MAX_IREGS) {
@@ -1686,10 +1686,10 @@
 					 */
 					mono_regstate_alloc_int (rs, 1 << ins->dreg);
 					val = rs->iassign [ins->sreg1] = ins->dreg;
-					//g_assert (val >= 0);
+					/* g_assert (val >= 0); */
 					DEBUG (g_print ("\tfast assigned sreg1 %s to R%d\n", mono_arch_regname (val), ins->sreg1));
 				} else {
-					//g_assert (val == -1); /* source cannot be spilled */
+					/* g_assert (val == -1); */ /* source cannot be spilled */
 					val = mono_regstate_alloc_int (rs, src1_mask);
 					if (val < 0)
 						val = get_register_spilling (cfg, tmp, ins, src1_mask, ins->sreg1);
@@ -1779,7 +1779,7 @@
 			for (j = 0; j < MONO_MAX_IREGS; ++j) {
 				s = 1 << j;
 				if ((clob_mask & s) && !(rs->ifree_mask & s) && j != ins->sreg1) {
-					//g_warning ("register %s busy at call site\n", mono_arch_regname (j));
+					/* g_warning ("register %s busy at call site\n", mono_arch_regname (j)); */
 				}
 			}
 		}
@@ -1792,7 +1792,7 @@
 			mono_regstate_free_int (rs, ins->sreg2);
 		}*/
 	
-		//DEBUG (print_ins (i, ins));
+		/* DEBUG (print_ins (i, ins)); */
 		/* this may result from a insert_before call */
 		if (!tmp->next)
 			bb->code = tmp->data;
@@ -1821,7 +1821,7 @@
 		 * x86_pop_reg (code, dreg_high);
 		 */
 	} else {
-		x86_push_reg (code, X86_EAX); // SP = SP - 4
+		x86_push_reg (code, X86_EAX); /* SP = SP - 4 */
 		x86_fist_pop_membase (code, X86_ESP, 0, FALSE);
 		x86_pop_reg (code, dreg);
 	}
@@ -1952,11 +1952,11 @@
 	 * bb->native offset as well or the code is effectively slowed down!
 	 */
 	/* align all blocks */
-//	if ((pad = (cfg->code_len & (align - 1)))) {
+/*	if ((pad = (cfg->code_len & (align - 1)))) { */
 	/* poor man loop start detection */
-//	if (bb->code && bb->in_count && bb->in_bb [0]->cil_code > bb->cil_code && (pad = (cfg->code_len & (align - 1)))) {
+/*	if (bb->code && bb->in_count && bb->in_bb [0]->cil_code > bb->cil_code && (pad = (cfg->code_len & (align - 1)))) { */
 	/* consider real loop detection and nesting level */
-//	if (bb->loop_blocks && bb->nesting < 3 && (pad = (cfg->code_len & (align - 1)))) {
+/*	if (bb->loop_blocks && bb->nesting < 3 && (pad = (cfg->code_len & (align - 1)))) { */
 	/* consider real loop detection */
 	if (bb->loop_blocks && (pad = (cfg->code_len & (align - 1)))) {
 		pad = align - pad;
@@ -2425,9 +2425,9 @@
 			ins->inst_c0 = code - cfg->native_code;
 			break;
 		case CEE_BR:
-			//g_print ("target: %p, next: %p, curr: %p, last: %p\n", ins->inst_target_bb, bb->next_bb, ins, bb->last_ins);
-			//if ((ins->inst_target_bb == bb->next_bb) && ins == bb->last_ins)
-			//break;
+			/* g_print ("target: %p, next: %p, curr: %p, last: %p\n", ins->inst_target_bb, bb->next_bb, ins, bb->last_ins);
+			if ((ins->inst_target_bb == bb->next_bb) && ins == bb->last_ins)
+			break; */
 			if (ins->flags & MONO_INST_BRLABEL) {
 				if (ins->inst_i0->inst_c0) {
 					x86_jump_code (code, cfg->native_code + ins->inst_i0->inst_c0);
Index: mono/mini/mini.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini.c,v
retrieving revision 1.222
diff -u -r1.222 mini.c
--- mono/mini/mini.c	22 Apr 2004 16:45:12 -0000	1.222
+++ mono/mini/mini.c	24 Apr 2004 17:33:51 -0000
@@ -811,8 +811,8 @@
 {
 	PrevStruct *p = data;
 	MonoBasicBlock *bb = val;
-	//printf ("FIDPREV %d %p  %p %p %p %p %d %d %d\n", bb->block_num, p->code, bb, p->best, bb->cil_code, p->best->cil_code,
-	//bb->method == p->best->method, bb->cil_code < p->code, bb->cil_code > p->best->cil_code);
+	/* printf ("FIDPREV %d %p  %p %p %p %p %d %d %d\n", bb->block_num, p->code, bb, p->best, bb->cil_code, p->best->cil_code,
+	   bb->method == p->best->method, bb->cil_code < p->code, bb->cil_code > p->best->cil_code); */
 
 	if (bb->cil_code && bb->cil_code < p->code && bb->cil_code > p->best->cil_code)
 		p->best = bb;
@@ -875,7 +875,7 @@
 	}
 	if (!second->code) {
 		g_warning ("bblock split failed in %s::%s\n", cfg->method->klass->name, cfg->method->name);
-		//G_BREAKPOINT ();
+		/* G_BREAKPOINT (); */
 	}
 }
 
@@ -1468,7 +1468,7 @@
 	MONO_INIT_VARINFO (cfg->vars [num], num);
 
 	cfg->num_varinfo++;
-	//g_print ("created temp %d of type %s\n", num, mono_type_get_name (type));
+	/* g_print ("created temp %d of type %s\n", num, mono_type_get_name (type)); */
 	return inst;
 }
 
@@ -1565,7 +1565,7 @@
 			prev->next = inst;
 		}
 		break;
-	//	g_warning ("handle conditional jump in add_ins_to_end ()\n");
+	/*	g_warning ("handle conditional jump in add_ins_to_end ()\n"); */
 	default:
 		MONO_ADD_INS (bb, inst);
 		break;
@@ -1646,17 +1646,17 @@
 	if (!bb->out_scount) {
 		int found = 0;
 		bb->out_scount = count;
-		//g_print ("bblock %d has out:", bb->block_num);
+		/* g_print ("bblock %d has out:", bb->block_num); */
 		for (i = 0; i < bb->out_count; ++i) {
 			outb = bb->out_bb [i];
-			//g_print (" %d", outb->block_num);
+			/* g_print (" %d", outb->block_num); */
 			if (outb->in_stack) {
 				found = 1;
 				bb->out_stack = outb->in_stack;
 				break;
 			}
 		}
-		//g_print ("\n");
+		/* g_print ("\n"); */
 		if (!found) {
 			bb->out_stack = mono_mempool_alloc (cfg->mempool, sizeof (MonoInst*) * count);
 			for (i = 0; i < count; ++i) {
@@ -2056,8 +2056,8 @@
 	int nargs;
 	MonoCallInst *call;
 
-	//g_print ("emulating: ");
-	//mono_print_tree_nl (tree);
+	/* g_print ("emulating: "); */
+	/* mono_print_tree_nl (tree); */
 	MONO_INST_NEW_CALL (cfg, call, ret_type_to_call_opcode (info->sig->ret, FALSE, FALSE));
 	ins = (MonoInst*)call;
 	
@@ -2313,7 +2313,7 @@
 		if (mono_class_needs_cctor_run (method->klass, NULL) && !((method->klass->flags & TYPE_ATTRIBUTE_BEFORE_FIELD_INIT)))
 			return FALSE;
 	}
-	//if (!MONO_TYPE_IS_VOID (signature->ret)) return FALSE;
+	/* if (!MONO_TYPE_IS_VOID (signature->ret)) return FALSE; */
 
 	/* also consider num_locals? */
 	if (getenv ("MONO_INLINELIMIT"))
@@ -2725,7 +2725,7 @@
 		}
 		/* handle exception clauses */
 		for (i = 0; i < header->num_clauses; ++i) {
-			//unsigned char *p = ip;
+			/* unsigned char *p = ip; */
 			MonoExceptionClause *clause = &header->clauses [i];
 			GET_BBLOCK (cfg, bbhash, tblock, ip + clause->try_offset);
 			tblock->real_offset = clause->try_offset;
@@ -3223,7 +3223,7 @@
 
 			CHECK_STACK (n);
 
-			//g_assert (!virtual || fsig->hasthis);
+			/* g_assert (!virtual || fsig->hasthis); */
 
 			sp -= n;
 
@@ -3460,7 +3460,7 @@
 					MonoInst *store;
 					CHECK_STACK (1);
 					--sp;
-					//g_assert (returnvar != -1);
+					/* g_assert (returnvar != -1); */
 					NEW_TEMPSTORE (cfg, store, return_var->inst_c0, *sp);
 					store->cil_code = sp [0]->cil_code;
 					if (store->opcode == CEE_STOBJ) {
@@ -4272,9 +4272,9 @@
 				CHECK_STACK (1);
 				--sp;
 			}
-			// FIXME: enable this test later.
-			//if (sp [0]->type != STACK_OBJ && sp [0]->type != STACK_MP)
-			//	goto unverified;
+			/* FIXME: enable this test later. */
+			/* if (sp [0]->type != STACK_OBJ && sp [0]->type != STACK_MP) */
+			/*	goto unverified; */
 			CHECK_OPSIZE (5);
 			token = read32 (ip + 1);
 			field = mono_field_from_token (image, token, &klass, generic_context);
@@ -4567,7 +4567,7 @@
 					load->flags |= ins_flag;
 					ins_flag = 0;
 					/* fixme: dont see the problem why this does not work */
-					//cfg->disable_aot = TRUE;
+					/* cfg->disable_aot = TRUE; */
 				}
 			}
 			ip += 5;
@@ -6142,7 +6142,7 @@
 	MonoJitICallInfo *info;
 	g_assert (jit_icall_hash_name);
 
-	//printf ("lookup addr %s %p\n", name, g_hash_table_lookup (jit_icall_hash_name, name));
+	/* printf ("lookup addr %s %p\n", name, g_hash_table_lookup (jit_icall_hash_name, name)); */
 	EnterCriticalSection (&trampoline_hash_mutex);
 	info = g_hash_table_lookup (jit_icall_hash_name, name);
 	LeaveCriticalSection (&trampoline_hash_mutex);
@@ -6489,7 +6489,7 @@
 void
 mono_destroy_compile (MonoCompile *cfg)
 {
-	//mono_mempool_stats (cfg->mempool);
+	/* mono_mempool_stats (cfg->mempool); */
 	g_hash_table_destroy (cfg->bb_hash);
 	if (cfg->rs)
 		mono_regstate_free (cfg->rs);
@@ -7000,7 +7000,7 @@
 							changed = TRUE;
 						}
 
-						//mono_print_bb_code (bb);
+						/* mono_print_bb_code (bb); */
 					}
 				}				
 			}
@@ -7171,14 +7171,14 @@
 	const guint16 *nts = mono_burg_nts [ern];
 	MBEmitFunc emit;
 
-	//g_print ("rule: %s\n", mono_burg_rule_string [ern]);
+	/* g_print ("rule: %s\n", mono_burg_rule_string [ern]); */
 	switch (goal) {
 	case MB_NTERM_reg:
-		//if (state->reg2)
-		//	state->reg1 = state->reg2; /* chain rule */
-		//else
+		/* if (state->reg2) */
+		/* 	state->reg1 = state->reg2; /* chain rule */
+		/* else */
 		state->reg1 = mono_regstate_next_int (cfg->rs);
-		//g_print ("alloc symbolic R%d (reg2: R%d) in block %d\n", state->reg1, state->reg2, cfg->cbb->block_num);
+		/* g_print ("alloc symbolic R%d (reg2: R%d) in block %d\n", state->reg1, state->reg2, cfg->cbb->block_num); */
 		break;
 	case MB_NTERM_lreg:
 		state->reg1 = mono_regstate_next_int (cfg->rs);
@@ -7204,7 +7204,7 @@
 		}
 	}
 
-//	g_print ("emit: %s (%p)\n", mono_burg_rule_string [ern], state);
+/* 	g_print ("emit: %s (%p)\n", mono_burg_rule_string [ern], state); */
 	if ((emit = mono_burg_func [ern]))
 		emit (state, state->tree, cfg);	
 }
@@ -7384,7 +7384,7 @@
 		case MONO_PATCH_INFO_ABS: {
 			MonoJitICallInfo *info = mono_find_jit_icall_by_addr (patch_info->data.target);
 			if (info) {
-				//printf ("TEST %s %p\n", info->name, patch_info->data.target);
+				/* printf ("TEST %s %p\n", info->name, patch_info->data.target); */
 				if ((cfg->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE) && 
 					strstr (cfg->method->name, info->name))
 					/*
@@ -7452,13 +7452,13 @@
 
 		if (cp->opcode == OP_ICONST) {
 			if (cfg->opt & MONO_OPT_CONSPROP) {
-				//{ static int c = 0; printf ("CCOPY %d %d %s\n", c++, cp->inst_c0, mono_method_full_name (cfg->method, TRUE)); }
+				/* { static int c = 0; printf ("CCOPY %d %d %s\n", c++, cp->inst_c0, mono_method_full_name (cfg->method, TRUE)); } */
 				*tree = *cp;
 			}
 		} else {
 			if (tree->inst_i0->inst_vtype->type == cp->inst_vtype->type) {
 				if (cfg->opt & MONO_OPT_COPYPROP) {
-					//{ static int c = 0; printf ("VCOPY %d\n", ++c); }
+					/* { static int c = 0; printf ("VCOPY %d\n", ++c); } */
 					tree->inst_i0 = cp;
 				} 
 			}
@@ -7584,13 +7584,13 @@
 
 			if (i1->opcode == OP_ICONST) {
 				acp [tree->inst_i0->inst_c0] = i1;
-				//printf ("DEF1 BB%d %d\n", bb->block_num,tree->inst_i0->inst_c0);
+				/* printf ("DEF1 BB%d %d\n", bb->block_num,tree->inst_i0->inst_c0); */
 			}
 			if (i1->ssa_op == MONO_SSA_LOAD && 
 			    (i1->inst_i0->opcode == OP_LOCAL || i1->inst_i0->opcode == OP_ARG) &&
 			    (i1->inst_i0->inst_c0 != tree->inst_i0->inst_c0)) {
 				acp [tree->inst_i0->inst_c0] = i1->inst_i0;
-				//printf ("DEF2 BB%d %d %d\n", bb->block_num,tree->inst_i0->inst_c0,i1->inst_i0->inst_c0);
+				/* printf ("DEF2 BB%d %d %d\n", bb->block_num,tree->inst_i0->inst_c0,i1->inst_i0->inst_c0); */
 			}
 		}
 
@@ -7719,7 +7719,7 @@
 	if (parts == 1)
 		return cfg;
 
-//#define DEBUGSSA "logic_run"
+/* #define DEBUGSSA "logic_run" */
 #define DEBUGSSA_CLASS "Tests"
 #ifdef DEBUGSSA
 
@@ -7757,7 +7757,7 @@
 	if (cfg->comp_done & MONO_COMP_SSA) {			
 		mono_ssa_deadce (cfg);
 
-		//mono_ssa_strength_reduction (cfg);
+		/* mono_ssa_strength_reduction (cfg); */
 
 		mono_ssa_remove (cfg);
 
@@ -7785,9 +7785,9 @@
 		}
 	}
 
-	//mono_print_code (cfg);
+	/* mono_print_code (cfg); */
 
-       //print_dfn (cfg);
+       /* print_dfn (cfg); */
 	
 	/* variables are allocated after decompose, since decompose could create temps */
 	mono_arch_allocate_vars (cfg);
@@ -7925,8 +7925,8 @@
 			nm = mono_marshal_get_native_wrapper (method);
 			return mono_compile_method (nm);
 
-			//if (mono_debug_format != MONO_DEBUG_FORMAT_NONE) 
-			//mono_debug_add_wrapper (method, nm);
+			/* if (mono_debug_format != MONO_DEBUG_FORMAT_NONE)  */
+			/* mono_debug_add_wrapper (method, nm); */
 #ifdef MONO_USE_EXC_TABLES
 		}
 #endif
@@ -7963,7 +7963,7 @@
 		/* We can't use a domain specific method in another domain */
 		if ((target_domain == mono_domain_get ()) || info->domain_neutral) {
 			code = info->code_start;
-//			printf("Discarding code for method %s\n", method->name);
+/*			printf("Discarding code for method %s\n", method->name);*/
 		}
 	}
 	
@@ -8344,8 +8344,8 @@
 	mono_register_jit_icall (mono_domain_get, "mono_domain_get", helper_sig_domain_get, TRUE);
 
 	/* fixme: we cant hanlde vararg methods this way, because the signature is not constant */
-	//mono_register_jit_icall (ves_array_element_address, "ves_array_element_address", NULL);
-	//mono_register_jit_icall (mono_array_new_va, "mono_array_new_va", NULL);
+	/* mono_register_jit_icall (ves_array_element_address, "ves_array_element_address", NULL); */
+	/* mono_register_jit_icall (mono_array_new_va, "mono_array_new_va", NULL); */
 
 	mono_register_jit_icall (mono_arch_get_throw_exception (), "mono_arch_throw_exception", helper_sig_void_obj, TRUE);
 	mono_register_jit_icall (mono_arch_get_throw_exception_by_name (), "mono_arch_throw_exception_by_name", 
Index: mono/mini/ssa.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/ssa.c,v
retrieving revision 1.6
diff -u -r1.6 ssa.c
--- mono/mini/ssa.c	3 Jan 2004 13:21:12 -0000	1.6
+++ mono/mini/ssa.c	24 Apr 2004 17:33:52 -0000
@@ -16,7 +16,7 @@
 #define USE_ORIGINAL_VARS
 #define CREATE_PRUNED_SSA
 
-//#define DEBUG_SSA 1
+/*#define DEBUG_SSA 1 */
 
 #define NEW_PHI(cfg,dest,val) do {	\
 		(dest) = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
@@ -108,7 +108,7 @@
 				/* uninitialized variable ? */
 				g_warning ("using uninitialized variables %d in BB%d (%s)", idx, bb->block_num,
 					   mono_method_full_name (cfg->method, TRUE));
-				//g_assert_not_reached ();
+				/* g_assert_not_reached (); */
 			}
 		}
 #ifdef DEBUG_SSA
@@ -269,7 +269,7 @@
 	g_assert (((MonoMethodNormal *)cfg->method)->header->num_clauses == 0);
 	g_assert (!cfg->disable_ssa);
 
-	//printf ("COMPUTS SSA %s %d\n", mono_method_full_name (cfg->method, TRUE), cfg->num_varinfo);
+	/* printf ("COMPUTS SSA %s %d\n", mono_method_full_name (cfg->method, TRUE), cfg->num_varinfo); */
 
 #ifdef CREATE_PRUNED_SSA
 	/* we need liveness for pruned SSA */
@@ -308,7 +308,7 @@
 				continue;
 
 			if ((cfg->comp_done & MONO_COMP_LIVENESS) && !mono_bitset_test_fast (bb->live_in_set, i)) {
-				//printf ("%d is not live in BB%d %s\n", i, bb->block_num, mono_method_full_name (cfg->method, TRUE));
+				/* printf ("%d is not live in BB%d %s\n", i, bb->block_num, mono_method_full_name (cfg->method, TRUE)); */
 				continue;
 			}
 
@@ -469,7 +469,7 @@
 					MonoMethodVar *mv = cfg->vars [idx];
 
 					if (mv->reg != -1 && mv->reg != mv->idx) {
-						//printf ("PHICOPY %d %d -> %d\n", idx, mv->reg, inst->inst_i0->inst_c0);
+					  /* printf ("PHICOPY %d %d -> %d\n", idx, mv->reg, inst->inst_i0->inst_c0); */
 						idx = mv->reg;
 					}
 
@@ -584,7 +584,7 @@
 	    (inst->inst_i0->opcode == OP_LOCAL /*|| inst->inst_i0->opcode == OP_ARG */)) {
 		idx = inst->inst_i0->inst_c0;
 		info = cfg->vars [idx];
-		//printf ("%d defined in BB%d %p\n", idx, bb->block_num, root);
+		/* printf ("%d defined in BB%d %p\n", idx, bb->block_num, root); */
 		if (info->def) {
 			g_warning ("more than one definition of variable %d in %s", idx,
 				   mono_method_full_name (cfg->method, TRUE));
@@ -601,7 +601,7 @@
 				MonoVarUsageInfo *ui = mono_mempool_alloc (cfg->mempool, sizeof (MonoVarUsageInfo));
 				idx = inst->inst_i1->inst_phi_args [i];	
 				info = cfg->vars [idx];
-				//printf ("FOUND %d\n", idx);
+				/* printf ("FOUND %d\n", idx); */
 				ui->bb = bb;
 				ui->inst = root;
 				info->uses = g_list_prepend (info->uses, ui);
@@ -614,13 +614,13 @@
 		MonoVarUsageInfo *ui = mono_mempool_alloc (cfg->mempool, sizeof (MonoVarUsageInfo));
 		idx = inst->inst_i0->inst_c0;	
 		info = cfg->vars [idx];
-		//printf ("FOUND %d\n", idx);
+		/* printf ("FOUND %d\n", idx); */
 		ui->bb = bb;
 		ui->inst = root;
 		info->uses = g_list_prepend (info->uses, ui);
 	} else {
 		if (arity) {
-			//if (inst->ssa_op != MONO_SSA_STORE)
+			/* if (inst->ssa_op != MONO_SSA_STORE) */
 			analyze_dev_use (cfg, bb, root, inst->inst_left);
 			if (arity > 1)
 				analyze_dev_use (cfg, bb, root, inst->inst_right);
@@ -653,13 +653,14 @@
 					MonoVarUsageInfo *vi = (MonoVarUsageInfo *)i1->uses->data;
 					u = vi->inst;
 
-					//printf ("VAR %d %s\n", i1->idx, mono_method_full_name (cfg->method, TRUE));
-					//mono_print_tree (inst); printf ("\n");
-					//mono_print_tree (u); printf ("\n");
+					/* printf ("VAR %d %s\n", i1->idx, mono_method_full_name (cfg->method, TRUE));
+					// mono_print_tree (inst); printf ("\n");
+					// mono_print_tree (u); printf ("\n");
+					*/
 
 					if (replace_usage_new (cfg, u, inst->inst_i0->inst_c0,  inst->inst_i1)) {
 														
-						//mono_print_tree (u); printf ("\n");
+						/* mono_print_tree (u); printf ("\n"); */
 							
 						inst->opcode = CEE_NOP;
 						inst->ssa_op = MONO_SSA_NOP;
@@ -671,7 +672,7 @@
 				    next->inst_i1->inst_i0->inst_c0 == inst->inst_i0->inst_c0 && g_list_length (i1->uses) == 1 &&
 				    inst->opcode == next->opcode && inst->inst_i0->type == next->inst_i0->type) {
 					i2 = cfg->vars [next->inst_i0->inst_c0];
-					//printf ("ELIM. COPY in BB%d %s\n", bb->block_num, mono_method_full_name (cfg->method, TRUE));
+					/* printf ("ELIM. COPY in BB%d %s\n", bb->block_num, mono_method_full_name (cfg->method, TRUE)); */
 					inst->inst_i0 = next->inst_i0;
 					i2->def = inst;
 					i1->def = NULL;
@@ -849,12 +850,12 @@
 	if (inst->ssa_op == MONO_SSA_STORE && 
 	    (inst->inst_i0->opcode == OP_LOCAL || inst->inst_i0->opcode == OP_ARG) &&
 	    inst->inst_i1->opcode == OP_PHI && (c0 = carray [inst->inst_i0->inst_c0])) {
-		//{static int cn = 0; printf ("PHICONST %d %d %s\n", cn++, c0->inst_c0, mono_method_full_name (cfg->method, TRUE));}
+		/* {static int cn = 0; printf ("PHICONST %d %d %s\n", cn++, c0->inst_c0, mono_method_full_name (cfg->method, TRUE));} */
 		*inst->inst_i1 = *c0;		
 	} else if (inst->ssa_op == MONO_SSA_LOAD && 
 	    (inst->inst_i0->opcode == OP_LOCAL || inst->inst_i0->opcode == OP_ARG) &&
 	    (c0 = carray [inst->inst_i0->inst_c0])) {
-		//{static int cn = 0; printf ("YCCOPY %d %d %s\n", cn++, c0->inst_c0, mono_method_full_name (cfg->method, TRUE));}
+		/* {static int cn = 0; printf ("YCCOPY %d %d %s\n", cn++, c0->inst_c0, mono_method_full_name (cfg->method, TRUE));} */
 		*inst = *c0;
 	} else {
 
@@ -875,19 +876,19 @@
 		/* hack for longs to optimize the simply cases */
 		if (v0->opcode == OP_I8CONST && v1->opcode == OP_I8CONST) {
 			if (simulate_long_compare (inst->opcode, v0->inst_l, v1->inst_l)) {
-				//unlink_target (bb, inst->inst_false_bb);
+				/* unlink_target (bb, inst->inst_false_bb); */
 				target = inst->inst_true_bb;
 			} else {
-				//unlink_target (bb, inst->inst_true_bb);
+				/* unlink_target (bb, inst->inst_true_bb); */
 				target = inst->inst_false_bb;
 			}			
 		} else if (evaluate_const_tree (cfg, v0, &a, carray) == 1 &&
 			   evaluate_const_tree (cfg, v1, &b, carray) == 1) {				
 			if (simulate_compare (inst->opcode, a, b)) {
-				//unlink_target (bb, inst->inst_false_bb);
+				/* unlink_target (bb, inst->inst_false_bb); */
 				target = inst->inst_true_bb;
 			} else {
-				//unlink_target (bb, inst->inst_true_bb);
+				/* unlink_target (bb, inst->inst_true_bb); */
 				target = inst->inst_false_bb;
 			}
 		}
@@ -915,7 +916,7 @@
 
 	info->cpstate = state;
 
-	//printf ("SETSTATE %d to %d\n", info->idx, info->cpstate);
+	/* printf ("SETSTATE %d to %d\n", info->idx, info->cpstate); */
 
 	if (state == 1)
 		carray [info->idx] = c0;
@@ -1013,7 +1014,7 @@
 					if (mv->cpstate == 0)
 						continue;
 
-					//g_assert (src->inst_i1->opcode == OP_ICONST);
+					/* g_assert (src->inst_i1->opcode == OP_ICONST); */
 					g_assert (carray [mv->idx]);
 
 					if (!c0) {
@@ -1050,7 +1051,7 @@
 	GList *bblock_list, *cvars;
 	GList *tmp;
 	int i;
-	//printf ("SIMPLE OPTS BB%d %s\n", bb->block_num, mono_method_full_name (cfg->method, TRUE));
+	/* printf ("SIMPLE OPTS BB%d %s\n", bb->block_num, mono_method_full_name (cfg->method, TRUE)); */
 
 	if (!(cfg->comp_done & MONO_COMP_SSA_DEF_USE))
 		mono_ssa_create_def_use (cfg);
@@ -1135,7 +1136,7 @@
 
 	g_assert (cfg->comp_done & MONO_COMP_SSA);
 
-	//printf ("DEADCE %s\n", mono_method_full_name (cfg->method, TRUE));
+	/* printf ("DEADCE %s\n", mono_method_full_name (cfg->method, TRUE)); */
 
 	/* fixme: we should update usage infos during cprop, instead of computing it again */
 	cfg->comp_done &=  ~MONO_COMP_SSA_DEF_USE;
@@ -1162,7 +1163,7 @@
 
 		if (!info->uses && info->def) {
 			MonoInst *i1;
-			//printf ("ELIMINATE %s: ", mono_method_full_name (cfg->method, TRUE)); mono_print_tree (info->def); printf ("\n");
+			/* printf ("ELIMINATE %s: ", mono_method_full_name (cfg->method, TRUE)); mono_print_tree (info->def); printf ("\n"); */
 
 			i1 = info->def->inst_i1;
 			if (i1->opcode == OP_PHI) {
Index: mono/mini/trace.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/trace.c,v
retrieving revision 1.4
diff -u -r1.4 trace.c
--- mono/mini/trace.c	23 Feb 2004 14:24:14 -0000	1.4
+++ mono/mini/trace.c	24 Apr 2004 17:33:52 -0000
@@ -520,6 +520,6 @@
 		printf ("(unknown return type %x)", method->signature->ret->type);
 	}
 
-	//printf (" ip: %p\n", __builtin_return_address (1));
+	/* printf (" ip: %p\n", __builtin_return_address (1)); */
 	printf ("\n");
 }
Index: mono/mini/tramp-ppc.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/tramp-ppc.c,v
retrieving revision 1.18
diff -u -r1.18 tramp-ppc.c
--- mono/mini/tramp-ppc.c	8 Apr 2004 18:15:31 -0000	1.18
+++ mono/mini/tramp-ppc.c	24 Apr 2004 17:33:52 -0000
@@ -597,8 +597,8 @@
 	use r11 to keep that value, for instance. However, the generic part of
 	the trampoline relies on r11 having the same value it had before coming
 	here, so we must save it before. */
-	//code = buf = g_malloc(METHOD_TRAMPOLINE_SIZE);
-	// FIXME: should pass the domain down tot his function
+	/* code = buf = g_malloc(METHOD_TRAMPOLINE_SIZE); */
+	/* FIXME: should pass the domain down tot his function */
 	mono_domain_lock (domain);
 	code = buf = mono_code_manager_reserve (domain->code_mp, METHOD_TRAMPOLINE_SIZE);
 	mono_domain_unlock (domain);
@@ -833,7 +833,7 @@
 	/* store trampoline address */
 	method->info = code;
 
-	//mono_jit_stats.method_trampolines++;
+	/* mono_jit_stats.method_trampolines++; */
 
 	return code;
 }
@@ -863,7 +863,7 @@
 	use r11 to keep that value, for instance. However, the generic part of
 	the trampoline relies on r11 having the same value it had before coming
 	here, so we must save it before. */
-	//code = buf = g_malloc(METHOD_TRAMPOLINE_SIZE);
+	/* code = buf = g_malloc(METHOD_TRAMPOLINE_SIZE); */
 	mono_domain_lock (vtable->domain);
 	code = buf = mono_code_manager_reserve (vtable->domain->code_mp, METHOD_TRAMPOLINE_SIZE);
 	mono_domain_unlock (vtable->domain);
Index: mono/mini/tramp-s390.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/tramp-s390.c,v
retrieving revision 1.2
diff -u -r1.2 tramp-s390.c
--- mono/mini/tramp-s390.c	19 Apr 2004 19:05:05 -0000	1.2
+++ mono/mini/tramp-s390.c	24 Apr 2004 17:33:52 -0000
@@ -114,8 +114,8 @@
 
 	start = addr;
 	if ((method->klass->valuetype)) {
-//	if ((method->klass->valuetype) && 
-//	    (method->flags & METHOD_ATTRIBUTE_VIRTUAL)) {
+/*	if ((method->klass->valuetype) &&  */
+/*	    (method->flags & METHOD_ATTRIBUTE_VIRTUAL)) { */
 		if ((!method->signature->ret->byref) && 
 		    (MONO_TYPE_ISSTRUCT (method->signature->ret)))
 			this_pos = s390_r3;
Index: mono/mini/tramp-sparc.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/tramp-sparc.c,v
retrieving revision 1.11
diff -u -r1.11 tramp-sparc.c
--- mono/mini/tramp-sparc.c	30 Mar 2004 17:19:19 -0000	1.11
+++ mono/mini/tramp-sparc.c	24 Apr 2004 17:33:52 -0000
@@ -322,10 +322,10 @@
 	guint8 *ptr, *buf;
 
 	ptr = buf = g_malloc0 (16);
-	//x86_breakpoint (buf);
+	/* x86_breakpoint (buf); */
 	if (notification_address)
 		*notification_address = buf;
-	//x86_ret (buf);
+	/* x86_ret (buf); */
 
 	return ptr;
 }
Index: mono/mini/tramp-x86.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/tramp-x86.c,v
retrieving revision 1.24
diff -u -r1.24 tramp-x86.c
--- mono/mini/tramp-x86.c	24 Feb 2004 18:17:20 -0000	1.24
+++ mono/mini/tramp-x86.c	24 Apr 2004 17:33:52 -0000
@@ -129,7 +129,7 @@
 
 #ifdef HAVE_VALGRIND_MEMCHECK_H
 					/* Tell valgrind to recompile the patched code */
-					//VALGRIND_DISCARD_TRANSLATIONS (code + 2, code + 6);
+					/* VALGRIND_DISCARD_TRANSLATIONS (code + 2, code + 6); */
 #endif
 				}
 			}
@@ -230,7 +230,7 @@
 			/* FIXME: the calltree skin trips on the self modifying code above */
 
 			/* Tell valgrind to recompile the patched code */
-			//VALGRIND_DISCARD_TRANSLATIONS (code, code + 8);
+			/* VALGRIND_DISCARD_TRANSLATIONS (code, code + 8); */
 #endif
 		}
 	}
