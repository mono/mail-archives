Index: ViMode.cs
===================================================================
--- ViMode.cs	(revision 151732)
+++ ViMode.cs	(working copy)
@@ -33,8 +33,63 @@
 
 namespace Mono.TextEditor.Vi
 {
+	public class ViMark
+	{
 	
+		public char MarkCharacter {get; set;}
+		public int LineNumber {get; set;}
+		
+		/// <summary>
+		/// Only way to construct a ViMark.
+		/// </summary>
+		/// <param name="markCharacter">
+		/// The <see cref="System.Char"/> with which the ViMark object needs to be
+		/// associated.
+		/// </param>
+		public ViMark (char markCharacter) {
+			MarkCharacter = MarkCharacter;
+		}
+		
+		public void SaveMark (TextEditorData data) {
+			LineNumber = data.IsSomethingSelected ? data.MainSelection.MinLine : data.Caret.Line;
+		}
+		
+		public void LoadMark (TextEditorData data) {
+			data.Caret.Line = LineNumber;
+		}
+		
+	}
 	
+	/// <summary>
+	/// Implements a Vi macro. Only the keys pressed need to be stored. Though this class
+	/// is not exactly required, it provides a possible place to extend the code.
+	/// </summary>
+	public class ViMacro {
+	
+		/// <summary>
+		/// One of these determines a complete set of arguments passed to HandleKeyPress. I am
+		/// still not sure about whether each of these fields is indepedent in itself or may 
+		/// be eliminated and re-constructed later.
+		/// </summary>
+		public struct KeySet {
+			public Gdk.Key Key { get; set;}
+			public uint UnicodeKey {get; set;}
+			public Gdk.ModifierType Modifiers {get; set;}
+		}
+		
+		/// <summary>
+		/// This <see cref="System.Collections.Queue"/> of KeySets determine the ultimate functionality
+		/// of the macro this ViMacro object represents.
+		/// </summary>
+		public Queue<KeySet> KeysPressed {get; set;}
+		public char MacroCharacter {get; set;}
+		
+		public ViMacro (char macroCharacter) {
+			MacroCharacter = MacroCharacter;
+		}
+	
+	}
+	
 	public class ViEditMode : EditMode
 	{
 		bool searchBackward;
@@ -43,7 +98,14 @@
 		State state;
 		const string substMatch = @"^:s(?<sep>.)(?<pattern>.+?)\k<sep>(?<replacement>.*?)(\k<sep>(?<trailer>i?))?$";
 		StringBuilder commandBuffer = new StringBuilder ();
+		Dictionary<char,ViMark> marks = new Dictionary<char, ViMark>();
+		Dictionary<char,ViMacro> macros = new Dictionary<char, ViMacro>();
 		
+		/// <summary>
+		/// The macro currently being implemented. Will be set to null and checked as a flag when required.
+		/// </summary>
+		ViMacro currentMacro;
+		
 		public virtual string Status { get; protected set; }
 		
 		protected virtual string RunExCommand (string command)
@@ -91,7 +153,7 @@
 					break;	
 				}
 				break;
-
+				
 			case '?':
 			case '/':
 				searchBackward = ('?' == command[0]);
@@ -102,7 +164,7 @@
 				}
 				return Search ();
 			}
-
+			
 			return "Command not recognised";
 		}
 		
@@ -164,7 +226,23 @@
 			if (key == Gdk.Key.Escape || 
 			    ((key == Gdk.Key.c || key == Gdk.Key.bracketleft) && (modifier & Gdk.ModifierType.ControlMask) != 0)) {
 				Reset (string.Empty);
+				if (currentMacro != null) {
+					// Reset current recording macro and also remove it from the
+					// macro pool
+					macros.Remove(currentMacro.MacroCharacter);
+					currentMacro = null;
+				}
 				return;
+			} else if (currentMacro != null && ((char)unicodeKey) == '@') {
+				// Another condition to terminate macro recording
+				// No need to remove it from the macro pool though.
+				currentMacro = null;
+			} else if (currentMacro != null) {
+				ViMacro.KeySet toAdd = new ViMacro.KeySet();
+				toAdd.Key = key;
+				toAdd.Modifiers = modifier;
+				toAdd.UnicodeKey = unicodeKey;
+				currentMacro.KeysPressed.Enqueue(toAdd);
 			}
 			
 			Action<TextEditorData> action = null;
@@ -349,6 +427,38 @@
 						Status = "z";
 						state = State.Fold;
 						return;
+						
+					case 'm':
+						Status = "m";
+						state = State.Mark;
+						return;
+						
+					case '`':
+						Status = "`";
+						state = State.GoToMark;
+						return;
+					
+					case 'q':
+						if (currentMacro == null) {
+							Status = "q";
+							state = State.NameMacro;
+							return;
+						} else {
+							currentMacro = null;
+							Reset("");
+							return;
+						}
+						break;
+						
+					case '@':
+						if (currentMacro == null) {
+							Status = "@";
+							state = State.PlayMacro;
+							return;
+						} else {
+							throw new Exception ("This should not be thrown");
+						}
+						
 					}
 					
 					
@@ -598,6 +708,66 @@
 				}
 				Reset ("Unknown command");
 				return;
+				
+			case State.Mark: {
+				char k = (char)unicodeKey;
+				ViMark mark = null;
+				if (!char.IsLetterOrDigit(k)) {
+					Reset ("Invalid Mark");
+					return;
+				}
+				if (marks.ContainsKey(k)) {
+					mark = marks [k];
+				} else {
+					mark = new ViMark(k);
+					marks [k] = mark;
+				}
+				RunAction(mark.SaveMark);
+				Reset("");
+				return;
+			}
+			
+			case State.NameMacro: {
+				char k = (char) unicodeKey;
+				if(!char.IsLetterOrDigit(k)) {
+					Reset("Invalid Macro Name");
+					return;
+				}
+				currentMacro = new ViMacro (k);
+				currentMacro.KeysPressed = new Queue<ViMacro.KeySet> ();
+				macros [k] = currentMacro;
+				Reset("");
+				return;
+			}
+			
+			case State.PlayMacro: {
+				char k = (char) unicodeKey;
+				if (macros.ContainsKey(k)) {
+					Reset ("");
+					ViMacro macroToPlay = macros [k];
+					while (macroToPlay.KeysPressed.Count != 0) {
+						ViMacro.KeySet keySet = macroToPlay.KeysPressed.Dequeue();
+						HandleKeypress(keySet.Key, keySet.UnicodeKey, keySet.Modifiers);
+					}
+					/* Once all the keys have been played back, quickly exit. */
+					return;
+				} else {
+					Reset ("Invalid Macro Name");
+					return;
+				}
+			}
+			
+			case State.GoToMark: {
+				char k = (char)unicodeKey;
+				if (marks.ContainsKey(k)) {
+					RunAction(marks [k].LoadMark);
+					Reset ("");
+				} else {
+					Reset ("Unknown Mark");
+				}
+				return;
+			}
+				
 			case State.Fold:
 				if (((modifier & (Gdk.ModifierType.ControlMask)) == 0)) {
 					switch ((char)unicodeKey) {
@@ -863,7 +1033,11 @@
 			Indent,
 			Unindent,
 			G,
-			Fold
+			Fold,
+			Mark,
+			GoToMark,
+			NameMacro,
+			PlayMacro
 		}
 	}
 }

