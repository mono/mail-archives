Index: mono/io-layer/Makefile.am
===================================================================
RCS file: /cvs/public/mono/mono/io-layer/Makefile.am,v
retrieving revision 1.22
diff -u -r1.22 Makefile.am
--- mono/io-layer/Makefile.am	13 Oct 2003 23:00:04 -0000	1.22
+++ mono/io-layer/Makefile.am	25 Oct 2003 12:57:51 -0000
@@ -93,8 +93,6 @@
 	timed-thread.h		\
 	types.h			\
 	uglify.h		\
-	unicode.c		\
-	unicode.h		\
 	versioninfo.h		\
 	wait.c			\
 	wait.h			\
Index: mono/io-layer/io.c
===================================================================
RCS file: /cvs/public/mono/mono/io-layer/io.c,v
retrieving revision 1.42
diff -u -r1.42 io.c
--- mono/io-layer/io.c	22 Sep 2003 00:57:18 -0000	1.42
+++ mono/io-layer/io.c	25 Oct 2003 12:57:52 -0000
@@ -20,11 +20,11 @@
 #include <utime.h>
 
 #include <mono/io-layer/wapi.h>
-#include <mono/io-layer/unicode.h>
 #include <mono/io-layer/wapi-private.h>
 #include <mono/io-layer/handles-private.h>
 #include <mono/io-layer/io-private.h>
 #include <mono/io-layer/timefuncs-private.h>
+#include <mono/utils/strenc.h>
 
 #undef DEBUG
 
@@ -1362,7 +1362,7 @@
 		return(INVALID_HANDLE_VALUE);
 	}
 
-	filename=_wapi_unicode_to_utf8(name);
+	filename=mono_unicode_to_external (name);
 	if(filename==NULL) {
 #ifdef DEBUG
 		g_message(G_GNUC_PRETTY_FUNCTION
@@ -1469,7 +1469,7 @@
 		return(FALSE);
 	}
 
-	filename=_wapi_unicode_to_utf8(name);
+	filename=mono_unicode_to_external(name);
 	if(filename==NULL) {
 #ifdef DEBUG
 		g_message(G_GNUC_PRETTY_FUNCTION
@@ -1507,7 +1507,7 @@
 	gchar *utf8_name, *utf8_dest_name;
 	int result;
 
-	utf8_name = _wapi_unicode_to_utf8 (name);
+	utf8_name = mono_unicode_to_external (name);
 	if (utf8_name == NULL) {
 #ifdef DEBUG
 		g_message (G_GNUC_PRETTY_FUNCTION ": unicode conversion returned NULL");
@@ -1516,7 +1516,7 @@
 		return FALSE;
 	}
 
-	utf8_dest_name = _wapi_unicode_to_utf8 (dest_name);
+	utf8_dest_name = mono_unicode_to_external (dest_name);
 	if (utf8_dest_name == NULL) {
 #ifdef DEBUG
 		g_message (G_GNUC_PRETTY_FUNCTION ": unicode conversion returned NULL");
@@ -2240,7 +2240,7 @@
 		return INVALID_HANDLE_VALUE;
 	}
 
-	utf8_pattern = _wapi_unicode_to_utf8 (pattern);
+	utf8_pattern = mono_unicode_to_external (pattern);
 	if (utf8_pattern == NULL) {
 #ifdef DEBUG
 		g_message (G_GNUC_PRETTY_FUNCTION ": unicode conversion returned NULL");
@@ -2357,12 +2357,9 @@
 	gboolean ok;
 	struct stat buf;
 	const gchar *filename;
-	gchar *utf8_filename;
-	
-	gchar *base_filename;
-	gunichar2 *utf16_basename;
+	gchar *utf8_filename, *utf8_basename, *utf16_basename;
 	time_t create_time;
-	int i;
+	gsize bytes;
 	
 	ok=_wapi_lookup_handle (handle, WAPI_HANDLE_FIND,
 				(gpointer *)&find_handle, NULL);
@@ -2402,24 +2399,15 @@
 		}
 	}
 	
-	/* Work around glib brain-damage, where it expects all filenames
-	 * to be validly utf8-encoded
-	 */
-	if(g_utf8_validate(filename, -1, NULL)) {
-		utf8_filename=g_strdup(filename);
-	} else {
-		utf8_filename=g_locale_to_utf8(filename, -1, NULL, NULL, NULL);
-	}
-
-	/* Final check... */
-	if(g_utf8_validate(utf8_filename, -1, NULL)==FALSE) {
-		/* glib can't cope with this filename, so just ignore it
-		 * instead of crashing.
+	utf8_filename=mono_utf8_from_external (filename);
+	if(utf8_filename==NULL) {
+		/* We couldn't turn this filename into utf8 (eg the
+		 * encoding of the name wasn't convertible), so just
+		 * ignore it.
 		 */
-		g_free(utf8_filename);
 		goto retry;
 	}
-
+	
 	/* fill data block */
 
 	if (buf.st_mtime < buf.st_ctime)
@@ -2445,19 +2433,24 @@
 	find_data->dwReserved0 = 0;
 	find_data->dwReserved1 = 0;
 
-	base_filename = g_path_get_basename (utf8_filename);
-	utf16_basename = g_utf8_to_utf16 (base_filename, MAX_PATH, NULL, NULL, NULL);
-
-	i = 0;
-	while (utf16_basename [i] != 0) {	/* copy basename */
-		find_data->cFileName [i] = utf16_basename [i];
-		++ i;
+	utf8_basename = g_path_get_basename (utf8_filename);
+	utf16_basename = g_convert (utf8_basename, -1, "UTF16LE", "UTF8",
+				    NULL, &bytes, NULL);
+	if(utf16_basename==NULL) {
+		goto retry;
 	}
 
-	find_data->cFileName[i] = 0;		/* null terminate */
+	memset (find_data->cFileName, '\0', (MAX_PATH*2));
+
+	/* Truncating a utf16 string like this might leave the last
+	 * char incomplete
+	 */
+	memcpy (find_data->cFileName, utf16_basename,
+		bytes<(MAX_PATH*2)-2?bytes:(MAX_PATH*2)-2);
+
 	find_data->cAlternateFileName [0] = 0;	/* not used */
 
-	g_free (base_filename);
+	g_free (utf8_basename);
 	g_free (utf8_filename);
 	g_free (utf16_basename);
 	return TRUE;
@@ -2506,7 +2499,7 @@
 	gchar *utf8_name;
 	int result;
 	
-	utf8_name = _wapi_unicode_to_utf8 (name);
+	utf8_name = mono_unicode_to_external (name);
 	if (utf8_name == NULL) {
 #ifdef DEBUG
 		g_message (G_GNUC_PRETTY_FUNCTION ": unicode conversion returned NULL");
@@ -2546,7 +2539,7 @@
 	gchar *utf8_name;
 	int result;
 
-	utf8_name = _wapi_unicode_to_utf8 (name);
+	utf8_name = mono_unicode_to_external (name);
 	if (utf8_name == NULL) {
 #ifdef DEBUG
 		g_message (G_GNUC_PRETTY_FUNCTION ": unicode conversion returned NULL");
@@ -2579,7 +2572,7 @@
 	struct stat buf;
 	int result;
 	
-	utf8_name = _wapi_unicode_to_utf8 (name);
+	utf8_name = mono_unicode_to_external (name);
 	if (utf8_name == NULL) {
 #ifdef DEBUG
 		g_message (G_GNUC_PRETTY_FUNCTION ": unicode conversion returned NULL");
@@ -2627,7 +2620,7 @@
 		return FALSE;
 	}
 
-	utf8_name = _wapi_unicode_to_utf8 (name);
+	utf8_name = mono_unicode_to_external (name);
 	if (utf8_name == NULL) {
 #ifdef DEBUG
 		g_message (G_GNUC_PRETTY_FUNCTION ": unicode conversion returned NULL");
@@ -2693,7 +2686,7 @@
 	 * not standard: 0x80000000, which means `set executable bit'
 	 */
 
-	utf8_name = _wapi_unicode_to_utf8 (name);
+	utf8_name = mono_unicode_to_external (name);
 	result = stat (utf8_name, &buf);
 	if (result != 0) {
 		g_free (utf8_name);
@@ -2741,49 +2734,33 @@
  */
 extern guint32 GetCurrentDirectory (guint32 length, gunichar2 *buffer)
 {
-	gchar *path, *utf8_path;
-	gunichar2 *utf16_path, *ptr;
-	glong count = 0;
+	gchar *path;
+	gunichar2 *utf16_path;
+	glong count;
+	gsize bytes;
 	
 	path = g_get_current_dir ();
 	if (path == NULL)
 		return 0;
 
-	/* No, g_get_current_dir () does not return utf8 strings */
-	if(g_utf8_validate(path, -1, NULL)) {
-		utf8_path=g_strdup(path);
-	} else {
-		utf8_path=g_locale_to_utf8(path, -1, NULL, NULL, NULL);
-	}
-
-	if(g_utf8_validate(utf8_path, -1, NULL)==FALSE) {
-		g_free(utf8_path);
-		return(0);
-	}
+	utf16_path=mono_unicode_from_external (path, &bytes);
 	
 	/* if buffer too small, return number of characters required.
 	 * this is plain dumb.
 	 */
 	
-	count = strlen (utf8_path) + 1;
+	count = (bytes/2)+1;
 	if (count > length) {
-		g_free(utf8_path);
+		g_free(path);
+		g_free (utf16_path);
+		
 		return (count);
 	}
-	
-	utf16_path = g_utf8_to_utf16 (utf8_path, -1, NULL, NULL, NULL);
-	if (utf16_path == NULL) {
-		g_free(utf8_path);
-		return (0);
-	}
 
-	ptr = utf16_path;
-	while (*ptr)
-		*buffer ++ = *ptr ++;
-	
-	*buffer = 0;
+	/* Add the terminator */
+	memset (buffer, '\0', bytes+2);
+	memcpy (buffer, utf16_path, bytes);
 	
-	g_free (utf8_path);
 	g_free (utf16_path);
 	g_free (path);
 
@@ -2803,7 +2780,7 @@
 	gchar *utf8_path;
 	gboolean result;
 
-	utf8_path = _wapi_unicode_to_utf8 (path);
+	utf8_path = mono_unicode_to_external (path);
 	if (chdir (utf8_path) != 0) {
 		_wapi_set_last_error_from_errno ();
 		result = FALSE;
@@ -2958,9 +2935,9 @@
 guint32 GetTempPath (guint32 len, gunichar2 *buf)
 {
 	gchar *tmpdir=g_strdup (g_get_tmp_dir ());
-	gchar *utf8_tmpdir;
 	gunichar2 *tmpdir16=NULL;
-	glong dirlen, bytes;
+	glong dirlen;
+	gsize bytes;
 	guint32 ret;
 	
 	if(tmpdir[strlen (tmpdir)]!='/') {
@@ -2968,33 +2945,13 @@
 		tmpdir=g_strdup_printf ("%s/", g_get_tmp_dir ());
 	}
 	
-	/* g_get_tmp_dir () doesn't return utf8 either */
-	if(g_utf8_validate(tmpdir, -1, NULL)) {
-		utf8_tmpdir=g_strdup(tmpdir);
-	} else {
-		utf8_tmpdir=g_locale_to_utf8(tmpdir, -1, NULL, NULL, NULL);
-	}
-
-	if(g_utf8_validate(utf8_tmpdir, -1, NULL)==FALSE) {
-		/* FIXME - set error code */
-#ifdef DEBUG
-		g_message (G_GNUC_PRETTY_FUNCTION ": UTF8 error");
-#endif
-
-		g_free(tmpdir);
-		g_free(utf8_tmpdir);
-		return(0);
-	}
-
-	tmpdir16=g_utf8_to_utf16 (utf8_tmpdir, -1, NULL, &dirlen, NULL);
+	tmpdir16=mono_unicode_from_external (tmpdir, &bytes);
 	if(tmpdir16==NULL) {
-		/* FIXME - set error code */
-#ifdef DEBUG
-		g_message (G_GNUC_PRETTY_FUNCTION ": Error");
-#endif
-
-		ret=0;
+		g_free (tmpdir);
+		return(0);
 	} else {
+		dirlen=(bytes/2);
+		
 		if(dirlen+1>len) {
 #ifdef DEBUG
 			g_message (G_GNUC_PRETTY_FUNCTION
@@ -3004,8 +2961,8 @@
 		
 			ret=dirlen+1;
 		} else {
-			/* Add the terminator and convert to bytes */
-			bytes=(dirlen+1)*2;
+			/* Add the terminator */
+			memset (buf, '\0', bytes+2);
 			memcpy (buf, tmpdir16, bytes);
 		
 			ret=dirlen;
@@ -3015,7 +2972,6 @@
 	if(tmpdir16!=NULL) {
 		g_free (tmpdir16);
 	}
-	g_free (utf8_tmpdir);
 	g_free (tmpdir);
 	
 	return(ret);
Index: mono/io-layer/processes.c
===================================================================
RCS file: /cvs/public/mono/mono/io-layer/processes.c,v
retrieving revision 1.17
diff -u -r1.17 processes.c
--- mono/io-layer/processes.c	29 Sep 2003 15:05:21 -0000	1.17
+++ mono/io-layer/processes.c	25 Oct 2003 12:57:53 -0000
@@ -22,7 +22,6 @@
 #include <unistd.h>
 
 #include <mono/io-layer/wapi.h>
-#include <mono/io-layer/unicode.h>
 #include <mono/io-layer/wapi-private.h>
 #include <mono/io-layer/handles-private.h>
 #include <mono/io-layer/misc-private.h>
@@ -125,7 +124,7 @@
 	 * so crap, with an API like this :-(
 	 */
 	if(appname!=NULL) {
-		cmd=_wapi_unicode_to_utf8 (appname);
+		cmd=g_utf16_to_utf8 (appname, -1, NULL, NULL, NULL);
 		if(cmd==NULL) {
 #ifdef DEBUG
 			g_message (G_GNUC_PRETTY_FUNCTION
@@ -145,7 +144,7 @@
 	}
 	
 	if(cmdline!=NULL) {
-		args=_wapi_unicode_to_utf8 (cmdline);
+		args=g_utf16_to_utf8 (cmdline, -1, NULL, NULL, NULL);
 		if(args==NULL) {
 #ifdef DEBUG
 			g_message (G_GNUC_PRETTY_FUNCTION
@@ -158,7 +157,7 @@
 	}
 
 	if(cwd!=NULL) {
-		dir=_wapi_unicode_to_utf8 (cwd);
+		dir=g_utf16_to_utf8 (cwd, -1, NULL, NULL, NULL);
 		if(dir==NULL) {
 #ifdef DEBUG
 			g_message (G_GNUC_PRETTY_FUNCTION
Index: mono/metadata/object.c
===================================================================
RCS file: /cvs/public/mono/mono/metadata/object.c,v
retrieving revision 1.186
diff -u -r1.186 object.c
--- mono/metadata/object.c	24 Oct 2003 14:59:58 -0000	1.186
+++ mono/metadata/object.c	25 Oct 2003 12:57:54 -0000
@@ -28,6 +28,7 @@
 #include <mono/metadata/environment.h>
 #include "mono/metadata/profiler-private.h"
 #include <mono/os/gc_wrapper.h>
+#include <mono/utils/strenc.h>
 
 /*
  * Enable experimental typed allocation using the GC_gcj_malloc function.
@@ -924,11 +925,11 @@
 		g_free (fullpath);
 		g_free (basename);
 	} else {
-		mono_array_set (main_args, gpointer, 0, mono_string_new (domain, argv [0]));
+		mono_array_set (main_args, gpointer, 0, mono_string_new (domain, mono_utf8_from_external (argv [0])));
 	}
 
 	for (i = 1; i < argc; ++i) {
-		MonoString *arg = mono_string_new (domain, argv [i]);
+		MonoString *arg = mono_string_new (domain, mono_utf8_from_external (argv [i]));
 		mono_array_set (main_args, gpointer, i, arg);
 	}
 	argc--;
@@ -936,7 +937,7 @@
 	if (method->signature->param_count) {
 		args = (MonoArray*)mono_array_new (domain, mono_defaults.string_class, argc);
 		for (i = 0; i < argc; ++i) {
-			MonoString *arg = mono_string_new (domain, argv [i]);
+			MonoString *arg = mono_string_new (domain, mono_utf8_from_external (argv [i]));
 			mono_array_set (args, gpointer, i, arg);
 		}
 	} else {
Index: mono/utils/Makefile.am
===================================================================
RCS file: /cvs/public/mono/mono/utils/Makefile.am,v
retrieving revision 1.10
diff -u -r1.10 Makefile.am
--- mono/utils/Makefile.am	10 Jun 2003 08:36:20 -0000	1.10
+++ mono/utils/Makefile.am	25 Oct 2003 12:57:55 -0000
@@ -9,7 +9,9 @@
 	mono-logger.c	\
 	monobitset.c	\
 	strtod.h	\
-	strtod.c
+	strtod.c	\
+	strenc.h	\
+	strenc.c
 
 libmonoutilsincludedir = $(includedir)/mono/utils
 
Index: mono/utils/strenc.c
===================================================================
RCS file: mono/utils/strenc.c
diff -N mono/utils/strenc.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ mono/utils/strenc.c	25 Oct 2003 12:57:55 -0000
@@ -0,0 +1,190 @@
+/*
+ * strenc.c: string encoding conversions
+ *
+ * Author:
+ *	Dick Porter (dick@ximian.com)
+ *
+ * (C) 2003 Ximian, Inc.
+ */
+
+#include <config.h>
+#include <glib.h>
+
+#include "strenc.h"
+
+#undef DEBUG
+
+/* Tries to turn a NULL-terminated string into UTF16LE.
+ *
+ * First, see if it's valid UTF8, in which case just turn it directly
+ * into UTF16LE.  Next, run through the colon-separated encodings in
+ * MONO_EXTERNAL_ENCODINGS and do an iconv conversion on each,
+ * returning the first successful conversion to utf16.  If no
+ * conversion succeeds, return NULL.
+ *
+ * Callers must free the returned string if not NULL. bytes holds the number
+ * of bytes in the returned string, not including the terminator.
+ */
+gunichar2 *mono_unicode_from_external (const gchar *in, gsize *bytes)
+{
+	gchar *res=NULL;
+	gchar **encodings;
+	const gchar *encoding_list;
+	int i;
+	
+	if(g_utf8_validate (in, -1, NULL)) {
+		/* Use g_convert not g_utf8_to_utf16 because we need
+		 * to specify LE
+		 */
+		res=g_convert (in, -1, "UTF16LE", "UTF8", NULL, bytes, NULL);
+		return((gunichar2 *)res);
+	}
+
+	encoding_list=g_getenv ("MONO_EXTERNAL_ENCODINGS");
+	if(encoding_list==NULL) {
+		return(NULL);
+	}
+	
+	encodings=g_strsplit (encoding_list, ":", 0);
+	for(i=0;encodings[i]!=NULL; i++) {
+#ifdef DEBUG
+		g_message (G_GNUC_PRETTY_FUNCTION ": Trying encoding [%s]",
+			   encodings[i]);
+#endif
+		
+		/* "default_locale" is a special case encoding */
+		if(!strcmp (encodings[i], "default_locale")) {
+			gchar *utf8=g_locale_to_utf8 (in, -1, NULL, NULL,
+						      NULL);
+			if(utf8!=NULL && g_utf8_validate (utf8, -1, NULL)) {
+				res=g_convert (utf8, -1, "UTF16LE",
+					       encodings[i], NULL, bytes,
+					       NULL);
+			}
+			g_free (utf8);
+		} else {
+			res=g_convert (in, -1, "UTF16LE", encodings[i], NULL,
+				       bytes, NULL);
+		}
+
+		if(res!=NULL) {
+			g_strfreev (encodings);
+			return((gunichar2 *)res);
+		}
+	}
+	
+	g_strfreev (encodings);
+	
+	return(NULL);
+}
+
+/* Tries to turn a NULL-terminated string into UTF8.
+ *
+ * First, see if it's valid UTF8, in which case there's nothing more
+ * to be done.  Next, run through the colon-separated encodings in
+ * MONO_EXTERNAL_ENCODINGS and do an iconv conversion on each,
+ * returning the first successful conversion to utf8.  If no
+ * conversion succeeds, return NULL.
+ *
+ * Callers must free the returned string if not NULL.
+ *
+ * This function is identical to mono_unicode_from_external, apart
+ * from returning utf8 not utf16; it's handy in a few places to work
+ * in utf8.
+ */
+gchar *mono_utf8_from_external (const gchar *in)
+{
+	gchar *res=NULL;
+	gchar **encodings;
+	const gchar *encoding_list;
+	int i;
+	
+	if(g_utf8_validate (in, -1, NULL)) {
+		return(g_strdup (in));
+	}
+
+	encoding_list=g_getenv ("MONO_EXTERNAL_ENCODINGS");
+	if(encoding_list==NULL) {
+		return(NULL);
+	}
+	
+	encodings=g_strsplit (encoding_list, ":", 0);
+	for(i=0;encodings[i]!=NULL; i++) {
+#ifdef DEBUG
+		g_message (G_GNUC_PRETTY_FUNCTION ": Trying encoding [%s]",
+			   encodings[i]);
+#endif
+		
+		/* "default_locale" is a special case encoding */
+		if(!strcmp (encodings[i], "default_locale")) {
+			res=g_locale_to_utf8 (in, -1, NULL, NULL, NULL);
+			if(res!=NULL && !g_utf8_validate (res, -1, NULL)) {
+				g_free (res);
+				res=NULL;
+			}
+		} else {
+			res=g_convert (in, -1, "UTF8", encodings[i], NULL,
+				       NULL, NULL);
+		}
+
+		if(res!=NULL) {
+			g_strfreev (encodings);
+			return(res);
+		}
+	}
+	
+	g_strfreev (encodings);
+	
+	return(NULL);
+}
+
+/* Turns NULL-terminated UTF16LE into either UTF8, or the first
+ * working item in MONO_EXTERNAL_ENCODINGS if set.  If no conversions
+ * work, then UTF8 is returned.
+ *
+ * Callers must free the returned string.
+ */
+gchar *mono_unicode_to_external (const gunichar2 *uni)
+{
+	gchar *utf8;
+	const gchar *encoding_list;
+	
+	/* Turn the unicode into utf8 to start with, because its
+	 * easier to work with gchar * than gunichar2 *
+	 */
+	utf8=g_utf16_to_utf8 (uni, -1, NULL, NULL, NULL);
+	g_assert (utf8!=NULL);
+	
+	encoding_list=g_getenv ("MONO_EXTERNAL_ENCODINGS");
+	if(encoding_list==NULL) {
+		/* Do UTF8 */
+		return(utf8);
+	} else {
+		gchar *res, **encodings;
+		int i;
+		
+		encodings=g_strsplit (encoding_list, ":", 0);
+		for(i=0; encodings[i]!=NULL; i++) {
+			if(!strcmp (encodings[i], "default_locale")) {
+				res=g_locale_from_utf8 (utf8, -1, NULL, NULL,
+							NULL);
+			} else {
+				res=g_convert (utf8, -1, encodings[i], "UTF8",
+					       NULL, NULL, NULL);
+			}
+
+			if(res!=NULL) {
+				g_free (utf8);
+				g_strfreev (encodings);
+				
+				return(res);
+			}
+		}
+	
+		g_strfreev (encodings);
+	}
+	
+	/* Nothing else worked, so just return the utf8 */
+	return(utf8);
+}
+
Index: mono/utils/strenc.h
===================================================================
RCS file: mono/utils/strenc.h
diff -N mono/utils/strenc.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ mono/utils/strenc.h	25 Oct 2003 12:57:55 -0000
@@ -0,0 +1,19 @@
+/*
+ * strenc.h: string encoding conversions
+ *
+ * Author:
+ *	Dick Porter (dick@ximian.com)
+ *
+ * (C) 2003 Ximian, Inc.
+ */
+
+#ifndef _MONO_STRENC_H_
+#define _MONO_STRENC_H_ 1
+
+#include <glib.h>
+
+extern gunichar2 *mono_unicode_from_external (const gchar *in, gsize *bytes);
+extern gchar *mono_utf8_from_external (const gchar *in);
+extern gchar *mono_unicode_to_external (const gunichar2 *uni);
+
+#endif /* _MONO_STRENC_H_ */
