Index: appdomain.c
===================================================================
--- appdomain.c	(revisión: 45717)
+++ appdomain.c	(copia de trabajo)
@@ -907,7 +907,7 @@
 	MonoDomain *domain = ad->data;
 	MonoImageOpenStatus status;
 	guint32 raw_assembly_len = mono_array_length (raw_assembly);
-	MonoImage *image = mono_image_open_from_data (mono_array_addr (raw_assembly, gchar, 0), raw_assembly_len, TRUE, NULL);
+	MonoImage *image = mono_image_open_from_data_full (mono_array_addr (raw_assembly, gchar, 0), raw_assembly_len, TRUE, NULL, refonly);
 
 	if (raw_symbol_store)
 		mono_raise_exception (mono_get_exception_not_implemented ("LoadAssemblyRaw: Raw Symbol Store not Implemented"));
Index: assembly.c
===================================================================
--- assembly.c	(revisión: 45717)
+++ assembly.c	(copia de trabajo)
@@ -787,7 +787,7 @@
  * returns NULL
  */
 static MonoImage *
-mono_assembly_open_from_bundle (const char *filename, MonoImageOpenStatus *status)
+mono_assembly_open_from_bundle (const char *filename, MonoImageOpenStatus *status, gboolean refonly)
 {
 	int i;
 	char *name = g_path_get_basename (filename);
@@ -800,7 +800,7 @@
 	EnterCriticalSection (&assemblies_mutex);
 	for (i = 0; !image && bundles [i]; ++i) {
 		if (strcmp (bundles [i]->name, name) == 0) {
-			image = mono_image_open_from_data ((char*)bundles [i]->data, bundles [i]->size, FALSE, status);
+			image = mono_image_open_from_data_full ((char*)bundles [i]->data, bundles [i]->size, FALSE, status, refonly);
 			break;
 		}
 	}
@@ -814,18 +814,18 @@
 }
 
 static MonoImage*
-do_mono_assembly_open (const char *filename, MonoImageOpenStatus *status)
+do_mono_assembly_open (const char *filename, MonoImageOpenStatus *status, gboolean refonly)
 {
 	MonoImage *image = NULL;
 
 	if (bundles != NULL){
-		image = mono_assembly_open_from_bundle (filename, status);
+		image = mono_assembly_open_from_bundle (filename, status, refonly);
 
 		if (image != NULL)
 			return image;
 	}
 	EnterCriticalSection (&assemblies_mutex);
-	image = mono_image_open (filename, status);
+	image = mono_image_open_full (filename, status, refonly);
 	LeaveCriticalSection (&assemblies_mutex);
 
 	return image;
@@ -876,7 +876,7 @@
 
 	mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_ASSEMBLY,
 			"Assembly Loader probing location: '%s'.", filename);
-	image = do_mono_assembly_open (fname, status);
+	image = do_mono_assembly_open (fname, status, refonly);
 
 	if (!image){
 		*status = MONO_IMAGE_ERROR_ERRNO;
Index: image.c
===================================================================
--- image.c	(revisión: 45717)
+++ image.c	(copia de trabajo)
@@ -34,6 +34,8 @@
  */
 static GHashTable *loaded_images_hash;
 static GHashTable *loaded_images_guid_hash;
+static GHashTable *loaded_images_refonly_hash;
+static GHashTable *loaded_images_refonly_guid_hash;
 
 static CRITICAL_SECTION images_mutex;
 
@@ -131,6 +133,8 @@
 
 	loaded_images_hash = g_hash_table_new (g_str_hash, g_str_equal);
 	loaded_images_guid_hash = g_hash_table_new (g_str_hash, g_str_equal);
+	loaded_images_refonly_hash = g_hash_table_new (g_str_hash, g_str_equal);
+	loaded_images_refonly_guid_hash = g_hash_table_new (g_str_hash, g_str_equal);
 }
 
 /**
@@ -466,7 +470,7 @@
 		mono_metadata_decode_row (t, i, cols, MONO_MODULEREF_SIZE);
 		name = mono_metadata_string_heap (image, cols [MONO_MODULEREF_NAME]);
 		module_ref = g_build_filename (base_dir, name, NULL);
-		image->modules [i] = mono_image_open (module_ref, status);
+		image->modules [i] = mono_image_open_full (module_ref, status, refonly, image->refonly);
 		if (image->modules [i]) {
 			/* g_print ("loaded module %s from %s (%p)\n", module_ref, image->name, image->assembly); */
 		}
@@ -551,11 +555,21 @@
 }
 
 static void
-build_guid_table (void)
+register_guid_refonly (gpointer key, gpointer value, gpointer user_data)
 {
-	g_hash_table_foreach (loaded_images_hash, register_guid, NULL);
+	MonoImage *image = (MonoImage*)value;
+
+	if (!g_hash_table_lookup (loaded_images_refonly_guid_hash, image))
+		g_hash_table_insert (loaded_images_refonly_guid_hash, image->guid, image);
 }
 
+static void
+build_guid_table (gboolean refonly)
+{
+	GHashTable *loaded_images = refonly ? loaded_images_refonly_hash : loaded_images_hash;
+	g_hash_table_foreach (loaded_images, refonly ? register_guid_refonly : register_guid, NULL);
+}
+
 void
 mono_image_init (MonoImage *image)
 {
@@ -761,7 +775,7 @@
 
 static MonoImage *
 do_mono_image_open (const char *fname, MonoImageOpenStatus *status,
-		    gboolean care_about_cli)
+		    gboolean care_about_cli, gboolean refonly)
 {
 	MonoCLIImageInfo *iinfo;
 	MonoImage *image;
@@ -788,39 +802,56 @@
 	iinfo = g_new0 (MonoCLIImageInfo, 1);
 	image->image_info = iinfo;
 	image->name = canonicalize_path (fname);
+	image->ref_only = refonly;
 
 	return do_mono_image_load (image, status, care_about_cli);
 }
 
 MonoImage *
-mono_image_loaded (const char *name)
+mono_image_loaded_full (const char *name, gboolean refonly)
 {
 	MonoImage *res;
+	GHashTable *loaded_images = refonly ? loaded_images_refonly_hash : loaded_images_hash;
         
 	EnterCriticalSection (&images_mutex);
-	res = g_hash_table_lookup (loaded_images_hash, name);
+	res = g_hash_table_lookup (loaded_images, name);
 	LeaveCriticalSection (&images_mutex);
 	return res;
 }
 
 MonoImage *
-mono_image_loaded_by_guid (const char *guid)
+mono_image_loaded (const char *name)
 {
+	return mono_image_loaded_full (name, FALSE);
+}
+
+MonoImage *
+mono_image_loaded_by_guid_full (const char *guid, gboolean refonly)
+{
 	MonoImage *res;
+	GHashTable *loaded_images = refonly ? loaded_images_refonly_guid_hash : loaded_images_guid_hash;
 
 	EnterCriticalSection (&images_mutex);
-	res = g_hash_table_lookup (loaded_images_guid_hash, guid);
+	res = g_hash_table_lookup (loaded_images, guid);
 	LeaveCriticalSection (&images_mutex);
 	return res;
 }
 
+MonoImage *
+mono_image_loaded_by_guid (const char *guid)
+{
+	return mono_image_loaded_by_guid_full (guid, FALSE);
+}
+
 static MonoImage *
 register_image (MonoImage *image)
 {
 	MonoImage *image2;
+	GHashTable *loaded_images;
 
 	EnterCriticalSection (&images_mutex);
-	image2 = g_hash_table_lookup (loaded_images_hash, image->name);
+	loaded_images = image->ref_only ? loaded_images_refonly_hash : loaded_images_hash;
+	image2 = g_hash_table_lookup (loaded_images, image->name);
 
 	if (image2) {
 		/* Somebody else beat us to it */
@@ -829,17 +860,17 @@
 		mono_image_close (image);
 		return image2;
 	}
-	g_hash_table_insert (loaded_images_hash, image->name, image);
-	if (image->assembly_name && (g_hash_table_lookup (loaded_images_hash, image->assembly_name) == NULL))
-		g_hash_table_insert (loaded_images_hash, (char *) image->assembly_name, image);	
-	g_hash_table_insert (loaded_images_guid_hash, image->guid, image);
+	g_hash_table_insert (loaded_images, image->name, image);
+	if (image->assembly_name && (g_hash_table_lookup (loaded_images, image->assembly_name) == NULL))
+		g_hash_table_insert (loaded_images, (char *) image->assembly_name, image);	
+	g_hash_table_insert (image->ref_only ? loaded_images_refonly_guid_hash : loaded_images_guid_hash, image->guid, image);
 	LeaveCriticalSection (&images_mutex);
 
 	return image;
 }
 
 MonoImage *
-mono_image_open_from_data (char *data, guint32 data_len, gboolean need_copy, MonoImageOpenStatus *status)
+mono_image_open_from_data_full (char *data, guint32 data_len, gboolean need_copy, MonoImageOpenStatus *status, gboolean refonly)
 {
 	MonoCLIImageInfo *iinfo;
 	MonoImage *image;
@@ -869,6 +900,7 @@
 	image->name = g_strdup_printf ("data-%p", datac);
 	iinfo = g_new0 (MonoCLIImageInfo, 1);
 	image->image_info = iinfo;
+	image->ref_only = refonly;
 
 	image = do_mono_image_load (image, status, TRUE);
 	if (image == NULL)
@@ -877,17 +909,15 @@
 	return register_image (image);
 }
 
-/**
- * mono_image_open:
- * @fname: filename that points to the module we want to open
- * @status: An error condition is returned in this field
- *
- * Returns: An open image of type %MonoImage or NULL on error.
- * if NULL, then check the value of @status for details on the error
- */
 MonoImage *
-mono_image_open (const char *fname, MonoImageOpenStatus *status)
+mono_image_open_from_data (char *data, guint32 data_len, gboolean need_copy, MonoImageOpenStatus *status)
 {
+	return mono_image_open_from_data_full (data, data_len, need_copy, status, FALSE);
+}
+
+MonoImage *
+mono_image_open_full (const char *fname, MonoImageOpenStatus *status, gboolean refonly)
+{
 	MonoImage *image;
 	char *absfname;
 	
@@ -902,7 +932,7 @@
 	 * the same image, we discard all but the first copy.
 	 */
 	EnterCriticalSection (&images_mutex);
-	image = g_hash_table_lookup (loaded_images_hash, absfname);
+	image = g_hash_table_lookup (refonly ? loaded_images_refonly_hash : loaded_images_hash, absfname);
 	g_free (absfname);
 	
 	if (image){
@@ -912,7 +942,7 @@
 	}
 	LeaveCriticalSection (&images_mutex);
 
-	image = do_mono_image_open (fname, status, TRUE);
+	image = do_mono_image_open (fname, status, TRUE, refonly);
 	if (image == NULL)
 		return NULL;
 
@@ -920,6 +950,20 @@
 }
 
 /**
+ * mono_image_open:
+ * @fname: filename that points to the module we want to open
+ * @status: An error condition is returned in this field
+ *
+ * Returns: An open image of type %MonoImage or NULL on error.
+ * if NULL, then check the value of @status for details on the error
+ */
+MonoImage *
+mono_image_open (const char *fname, MonoImageOpenStatus *status)
+{
+	return mono_image_open_full (fname, status, FALSE);
+}
+
+/**
  * mono_pe_file_open:
  * @fname: filename that points to the module we want to open
  * @status: An error condition is returned in this field
@@ -935,7 +979,7 @@
 {
 	g_return_val_if_fail (fname != NULL, NULL);
 	
-	return(do_mono_image_open (fname, status, FALSE));
+	return(do_mono_image_open (fname, status, FALSE, FALSE));
 }
 
 static void
@@ -991,6 +1035,7 @@
 mono_image_close (MonoImage *image)
 {
 	MonoImage *image2;
+	GHashTable *loaded_images, *loaded_images_guid;
 	int i;
 
 	g_return_if_fail (image != NULL);
@@ -1002,16 +1047,19 @@
 		LeaveCriticalSection (&images_mutex);
 		return;
 	}
-	image2 = g_hash_table_lookup (loaded_images_hash, image->name);
+
+	loaded_images = image->ref_only ? loaded_images_refonly_hash : loaded_images_hash;
+	loaded_images_guid = image->ref_only ? loaded_images_refonly_guid_hash : loaded_images_guid_hash;
+	image2 = g_hash_table_lookup (loaded_images, image->name);
 	if (image == image2) {
 		/* This is not true if we are called from mono_image_open () */
-		g_hash_table_remove (loaded_images_hash, image->name);
-		g_hash_table_remove (loaded_images_guid_hash, image->guid);
+		g_hash_table_remove (loaded_images, image->name);
+		g_hash_table_remove (loaded_images_guid, image->guid);
 		/* Multiple images might have the same guid */
-		build_guid_table ();
+		build_guid_table (image->ref_only);
 	}
-	if (image->assembly_name && (g_hash_table_lookup (loaded_images_hash, image->assembly_name) == image))
-		g_hash_table_remove (loaded_images_hash, (char *) image->assembly_name);	
+	if (image->assembly_name && (g_hash_table_lookup (loaded_images, image->assembly_name) == image))
+		g_hash_table_remove (loaded_images, (char *) image->assembly_name);	
 	LeaveCriticalSection (&images_mutex);
 
 	if (image->file_descr) {
Index: image.h
===================================================================
--- image.h	(revisión: 45717)
+++ image.h	(copia de trabajo)
@@ -37,12 +37,18 @@
 
 MonoImage    *mono_image_open     (const char *fname,
 				   MonoImageOpenStatus *status);
+MonoImage    *mono_image_open_full     (const char *fname,
+				   MonoImageOpenStatus *status, gboolean refonly);
 MonoImage    *mono_pe_file_open     (const char *fname,
 				     MonoImageOpenStatus *status);
 MonoImage    *mono_image_open_from_data (char *data, guint32 data_len, gboolean need_copy,
                                          MonoImageOpenStatus *status);
+MonoImage    *mono_image_open_from_data_full (char *data, guint32 data_len, gboolean need_copy,
+                                         MonoImageOpenStatus *status, gboolean refonly);
 MonoImage    *mono_image_loaded   (const char *name);
+MonoImage    *mono_image_loaded_full   (const char *name, gboolean refonly);
 MonoImage    *mono_image_loaded_by_guid (const char *guid);
+MonoImage    *mono_image_loaded_by_guid_full (const char *guid, gboolean refonly);
 void          mono_image_init     (MonoImage *image);
 void          mono_image_close    (MonoImage *image);
 void          mono_image_addref   (MonoImage *image);
Index: metadata-internals.h
===================================================================
--- metadata-internals.h	(revisión: 45717)
+++ metadata-internals.h	(copia de trabajo)
@@ -58,6 +58,9 @@
 	/* Whenever this is a dynamically emitted module */
 	guint8 dynamic;
 
+	/* Whenever this is a reflection only image */
+	guint8 ref_only;
+
 	char *name;
 	const char *assembly_name;
 	const char *module_name;
