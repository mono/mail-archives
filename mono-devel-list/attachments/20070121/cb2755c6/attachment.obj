Index: corlib_test.dll.sources
===================================================================
--- corlib_test.dll.sources	(revision 71410)
+++ corlib_test.dll.sources	(working copy)
@@ -123,6 +123,7 @@
 System.Reflection.Emit/TypeBuilderTest.cs
 System.Reflection/ModuleTest.cs
 System.Reflection/StrongNameKeyPairTest.cs
+System.Reflection/CustomAttributesTest.cs
 System/ResolveEventArgsTest.cs
 System.Resources/ResourceReaderTest.cs
 System.Resources/ResourceManagerTest.cs
Index: System.Reflection/MonoEvent.cs
===================================================================
--- System.Reflection/MonoEvent.cs	(revision 71410)
+++ System.Reflection/MonoEvent.cs	(working copy)
@@ -150,17 +150,17 @@
 
 		public override bool IsDefined (Type attributeType, bool inherit)
 		{
-			return MonoCustomAttrs.IsDefined (this, attributeType, inherit);
+			return MonoCustomAttrs.IsDefined (this, attributeType, false);
 		}
 
 		public override object[] GetCustomAttributes( bool inherit)
 		{
-			return MonoCustomAttrs.GetCustomAttributes (this, inherit);
+            return MonoCustomAttrs.GetCustomAttributes(this, false);
 		}
 
 		public override object[] GetCustomAttributes( Type attributeType, bool inherit)
 		{
-			return MonoCustomAttrs.GetCustomAttributes (this, attributeType, inherit);
+            return MonoCustomAttrs.GetCustomAttributes(this, attributeType, false);
 		}
 
 	}
Index: System.Reflection/MonoProperty.cs
===================================================================
--- System.Reflection/MonoProperty.cs	(revision 71410)
+++ System.Reflection/MonoProperty.cs	(working copy)
@@ -193,17 +193,17 @@
 		
 		public override bool IsDefined (Type attributeType, bool inherit)
 		{
-			return MonoCustomAttrs.IsDefined (this, attributeType, inherit);
+			return MonoCustomAttrs.IsDefined (this, attributeType, false);
 		}
 
 		public override object[] GetCustomAttributes (bool inherit)
 		{
-			return MonoCustomAttrs.GetCustomAttributes (this, inherit);
+            return MonoCustomAttrs.GetCustomAttributes(this, false);
 		}
 		
 		public override object[] GetCustomAttributes (Type attributeType, bool inherit)
 		{
-			return MonoCustomAttrs.GetCustomAttributes (this, attributeType, inherit);
+            return MonoCustomAttrs.GetCustomAttributes(this, attributeType, false);
 		}
 
 		public override object GetValue (object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture)
Index: System.Reflection/ParameterInfo.cs
===================================================================
--- System.Reflection/ParameterInfo.cs	(revision 71410)
+++ System.Reflection/ParameterInfo.cs	(working copy)
@@ -176,16 +176,16 @@
 
 		public virtual object[] GetCustomAttributes (bool inherit)
 		{
-			return MonoCustomAttrs.GetCustomAttributes (this, inherit);
+			return MonoCustomAttrs.GetCustomAttributes (this, false);
 		}
 
 		public virtual object[] GetCustomAttributes (Type attributeType, bool inherit)
 		{
-			return MonoCustomAttrs.GetCustomAttributes (this, attributeType, inherit);
+            return MonoCustomAttrs.GetCustomAttributes(this, attributeType, false);
 		}
 
 		public virtual bool IsDefined( Type attributeType, bool inherit) {
-			return MonoCustomAttrs.IsDefined (this, attributeType, inherit);
+            return MonoCustomAttrs.IsDefined(this, attributeType, false);
 		}
 
 		internal object[] GetPseudoCustomAttributes () {
Index: System/Attribute.cs
===================================================================
--- System/Attribute.cs	(revision 71410)
+++ System/Attribute.cs	(working copy)
@@ -139,7 +139,7 @@
 
 			// ParameterInfo inheritance hierarchies CAN NOT be searched for attributes, so the second
 			// parameter of GetCustomAttributes () is IGNORED.
-			object[] attributes = element.GetCustomAttributes (attributeType, inherit);
+            Attribute[] attributes = GetCustomAttributes(element, attributeType, inherit);
 
 			return FindAttribute (attributes);
 		}
@@ -151,7 +151,8 @@
 
 			// MemberInfo inheritance hierarchies can be searched for attributes, so the second
 			// parameter of GetCustomAttribute () is respected.
-			return MonoCustomAttrs.GetCustomAttribute (element, attributeType, inherit);
+            Attribute[] attributes = GetCustomAttributes(element, attributeType, inherit);
+            return FindAttribute(attributes);
 		}
 
 		public static Attribute[] GetCustomAttributes (Assembly element)
@@ -207,7 +208,7 @@
 			// element parameter is not allowed to be null
 			CheckParameters (element, attributeType);
 
-			return (Attribute []) element.GetCustomAttributes (attributeType, inherit);
+            return (Attribute[])MonoCustomAttrs.GetCustomAttributes(element, attributeType, inherit);
 		}
 
 		public static Attribute[] GetCustomAttributes (Module element, Type attributeType, bool inherit)
@@ -223,7 +224,9 @@
 			// element parameter is not allowed to be null
 			CheckParameters (element, attributeType);
 
-			return (Attribute []) element.GetCustomAttributes (attributeType, inherit);
+            if (element is MonoEvent || element is MonoProperty)
+                return (Attribute[])MonoCustomAttrs.GetCustomAttributes(element, attributeType, inherit);
+            return (Attribute[])element.GetCustomAttributes(attributeType, inherit);
 		}
 
 		public static Attribute[] GetCustomAttributes (Module element, bool inherit)
@@ -247,7 +250,7 @@
 			// element parameter is not allowed to be null
 			CheckParameters (element, typeof (Attribute));
 
-			return (Attribute []) element.GetCustomAttributes (inherit);
+            return (Attribute[])MonoCustomAttrs.GetCustomAttributes(element, inherit);            
 		}
 
 		public static Attribute[] GetCustomAttributes (ParameterInfo element, bool inherit)
@@ -255,7 +258,7 @@
 			// element parameter is not allowed to be null
 			CheckParameters (element, typeof (Attribute));
 
-			return (Attribute []) element.GetCustomAttributes (inherit);
+            return (Attribute[])MonoCustomAttrs.GetCustomAttributes(element, inherit);			
 		}
 
 		public override int GetHashCode ()
@@ -301,6 +304,9 @@
 				throw new NotSupportedException (Locale.GetText (
 					"Element is not a constructor, method, property, event, type or field."));
 
+            if (element.MemberType == MemberTypes.Event || element.MemberType == MemberTypes.Property)
+                return MonoCustomAttrs.IsDefined(element, attributeType, inherit);
+
 			return ((MemberInfo) element).IsDefined (attributeType, inherit);
 		}
 
@@ -321,13 +327,10 @@
 		// FIXME: MS apparently walks the inheritance way in some form.
 		public static bool IsDefined (ParameterInfo element, Type attributeType, bool inherit)
 		{
-			CheckParameters (element, attributeType);
+			CheckParameters (element, attributeType);			
 
-			if (element.IsDefined (attributeType, inherit))
-				return true;
-
 			// FIXME: MS walks up the inheritance chain in some crazy way
-			return IsDefined (element.Member, attributeType, inherit);
+            return MonoCustomAttrs.IsDefined(element, attributeType, inherit);			
 		}
 
 		public virtual bool Match (object obj)
Index: System/MonoCustomAttrs.cs
===================================================================
--- System/MonoCustomAttrs.cs	(revision 71410)
+++ System/MonoCustomAttrs.cs	(working copy)
@@ -300,8 +300,33 @@
 				MonoProperty prop = (MonoProperty) obj;
 				method = prop.GetGetMethod (true);
 				if (method == null)
-					method = prop.GetSetMethod (true);
-			}
+                    method = prop.GetSetMethod(true); Type baseDeclaringType = method.GetBaseDefinition().DeclaringType;
+                if (baseDeclaringType == prop.DeclaringType)
+                    return null;
+                return baseDeclaringType.GetProperty(prop.Name, prop.PropertyType);
+            }
+            if (obj is EventInfo)
+            {
+                EventInfo ev = (EventInfo)obj;
+                method = ev.GetAddMethod(true);
+                if (method == null)
+                    method = ev.GetRemoveMethod(true);
+                Type baseDeclaringType = method.GetBaseDefinition().DeclaringType;
+                if (baseDeclaringType == ev.DeclaringType)
+                    return null;
+                return baseDeclaringType.GetEvent(ev.Name);
+            }
+            if (obj is ParameterInfo)
+            {
+                ParameterInfo param = (ParameterInfo)obj;
+                if (param.Member.MemberType != MemberTypes.Method)
+                    return null;
+                MethodInfo currentMethod = (MethodInfo)param.Member;
+                MethodInfo baseDefinition = currentMethod.GetBaseDefinition();
+                if (currentMethod == baseDefinition)
+                    return null;
+                return baseDefinition.GetParameters()[param.Position];
+            }
 			else if (obj is MonoMethod)
 			{
 				method = (MethodInfo) obj;
Index: Test/System.Reflection/CustomAttributesTest.cs
===================================================================
--- Test/System.Reflection/CustomAttributesTest.cs	(revision 0)
+++ Test/System.Reflection/CustomAttributesTest.cs	(revision 0)
@@ -0,0 +1,157 @@
+using System;
+using System.Text;
+using NUnit.Framework;
+using System.Reflection;
+
+namespace MonoTests.System.Reflection
+{
+
+    [TestFixture]
+    public class CustomAttributesTest : Assertion
+    {
+        [Test]
+        public void testFieldCustomAttribute()
+        {
+            FieldInfo f = typeof(Derived).GetField("_field1");
+            object[] attributes = f.GetCustomAttributes(typeof(Inherit), true);
+            AssertEquals(attributes.Length, 1);
+            attributes = Attribute.GetCustomAttributes(f, typeof(Inherit), true);
+            AssertEquals(attributes.Length, 1);
+            Assert(f.IsDefined(typeof(Not_Inherit), false) == false);
+            Assert(Attribute.IsDefined(f, typeof(Not_Inherit), false) == false);
+            Assert(f.IsDefined(typeof(BaseOnly), true) == false);
+            Assert(Attribute.IsDefined(f, typeof(BaseOnly), true) == false);
+        }
+
+        [Test]
+        public void testEventCustomAttribute()
+        {
+            EventInfo myEvent = typeof(Derived).GetEvent("MyEvent");
+            object[] attributes = myEvent.GetCustomAttributes(typeof(Inherit), true);
+            AssertEquals(attributes.Length, 1);
+            attributes = Attribute.GetCustomAttributes(myEvent, typeof(Inherit), true);
+            AssertEquals(attributes.Length, 2);
+
+            Assert(myEvent.IsDefined(typeof(Not_Inherit), false) == false);
+            Assert(Attribute.IsDefined(myEvent, typeof(Not_Inherit), false) == false);
+            Assert(myEvent.IsDefined(typeof(BaseOnly), true) == false);
+            Assert(Attribute.IsDefined(myEvent, typeof(BaseOnly), true) == true);
+        }
+
+        [Test]
+        public void testPropertyCustomAttribute()
+        {
+            PropertyInfo prop = typeof(Derived).GetProperty("StringProp");
+            object[] attributes = prop.GetCustomAttributes(typeof(Inherit), true);
+            AssertEquals(attributes.Length, 1);
+            attributes = Attribute.GetCustomAttributes(prop, typeof(Inherit), true);
+            AssertEquals(attributes.Length, 2);
+
+            Assert(prop.IsDefined(typeof(Not_Inherit), false) == false);
+            Assert(Attribute.IsDefined(prop, typeof(Not_Inherit), false) == false);
+            Assert(prop.IsDefined(typeof(BaseOnly), true) == false);
+            Assert(Attribute.IsDefined(prop, typeof(BaseOnly), true) == true);
+        }
+
+        [Test]
+        public void testMethodParameterCustomAttribute()
+        {
+            MethodInfo method = typeof(Derived).GetMethod("foo");
+            ParameterInfo p = method.GetParameters()[0];
+            object[] attributes = p.GetCustomAttributes(typeof(Inherit), true);
+            AssertEquals(attributes.Length, 1);
+            attributes = Attribute.GetCustomAttributes(p, typeof(Inherit), true);
+            AssertEquals(attributes.Length, 2);
+
+            Assert(p.IsDefined(typeof(Not_Inherit), false) == false);
+            Assert(Attribute.IsDefined(p, typeof(Not_Inherit), false) == false);
+            Assert(p.IsDefined(typeof(BaseOnly), true) == false);
+            Assert(Attribute.IsDefined(p, typeof(BaseOnly), true) == true);
+        }
+
+        [Test]
+        public void testMethodCustomAttribute()
+        {
+            MethodInfo method = typeof(Derived).GetMethod("foo");
+            object[] attributes = method.GetCustomAttributes(typeof(Inherit), true);
+            AssertEquals(attributes.Length, 2);
+            attributes = Attribute.GetCustomAttributes(method, typeof(Inherit), true);
+            AssertEquals(attributes.Length, 2);
+
+            Assert(method.IsDefined(typeof(Not_Inherit), false) == false);
+            Assert(Attribute.IsDefined(method, typeof(Not_Inherit), false) == false);
+            Assert(method.IsDefined(typeof(BaseOnly), true) == true);
+            Assert(Attribute.IsDefined(method, typeof(BaseOnly), true) == true);
+        }
+    }
+
+    class Base
+    {
+        [BaseOnly]
+        [Not_Inherit]
+        [Inherit]
+        public int _field1;
+
+        [BaseOnly]
+        [Not_Inherit]
+        [Inherit]
+        virtual public event EventHandler MyEvent;
+
+        [BaseOnly]
+        [Not_Inherit]
+        [Inherit]
+        public virtual void foo([BaseOnly][Not_Inherit][Inherit]int param1)
+        {
+        }
+
+        [BaseOnly]
+        [Not_Inherit]
+        [Inherit]
+        public virtual String StringProp
+        {
+            get
+            {
+                return "BASE";
+            }
+        }
+
+    }
+
+    class Derived : Base
+    {
+        [Inherit]
+        public int _field1;
+
+        [Inherit]
+        override public event EventHandler MyEvent;
+
+        [Inherit]
+        public override void foo([Inherit]int param1)
+        {
+        }
+
+        [Inherit]
+        public override String StringProp
+        {
+            get
+            {
+                return "DERIVED";
+            }
+        }
+    }
+
+    [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)]
+    public class Inherit : Attribute
+    {
+    }
+
+    [AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = false)]
+    public class Not_Inherit : Attribute
+    {
+    }
+
+    [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = true)]
+    public class BaseOnly : Attribute
+    {
+    }
+}
