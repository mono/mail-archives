The call to `get_{hcp, comparer}' is not needed. The property is not virtual,
so we can just use the field reference. Avoiding the call is good for perf.

Index: Hashtable.cs
===================================================================
RCS file: /cvs/public/mcs/class/corlib/System.Collections/Hashtable.cs,v
retrieving revision 1.33
diff -u -r1.33 Hashtable.cs
--- Hashtable.cs	27 May 2004 14:46:50 -0000	1.33
+++ Hashtable.cs	3 Jun 2004 00:55:06 -0000
@@ -120,8 +120,8 @@
 			size = ToPrime (size);
 			this.SetTable (new Slot [size]);
 
-			this.hcp = hcp;
-			this.comparer = comparer;
+			this.hcpRef = hcp;
+			this.comparerRef = comparer;
 
 			this.inUse = 0;
 			this.modificationCount = 0;
@@ -414,7 +414,7 @@
 
 		public virtual object Clone ()
 		{
-			Hashtable ht = new Hashtable (Count, hcp, comparer);
+			Hashtable ht = new Hashtable (Count, hcpRef, comparerRef);
 			ht.inUse = 0;
 			ht.loadFactor = this.loadFactor;
 
@@ -473,9 +473,8 @@
 		/// <summary>Returns the hash code for the specified key.</summary>
 		protected virtual int GetHash (Object key)
 		{
-			IHashCodeProvider hcp = this.hcp;
-			return (hcp!= null)
-			        ? hcp.GetHashCode (key)
+			return (hcpRef != null)
+			        ? hcpRef.GetHashCode (key)
 			        : key.GetHashCode ();
 		}
 
@@ -485,9 +484,8 @@
 		/// </summary>
 		protected virtual bool KeyEquals (Object item, Object key)
 		{
-			IComparer c = this.comparer;
-			if (c!= null)
-				return (c.Compare (item, key) == 0);
+			if (comparerRef != null)
+				return comparerRef.Compare (item, key) == 0;
 			else
 				return item.Equals (key);
 		}
