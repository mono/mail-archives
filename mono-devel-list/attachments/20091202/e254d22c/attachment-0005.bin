Index: System/Attribute.cs
===================================================================
--- System/Attribute.cs	(revision 147238)
+++ System/Attribute.cs	(working copy)
@@ -29,6 +29,7 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 
+using System.Collections.Generic;
 using System.Reflection;
 using System.Runtime.InteropServices;
 
@@ -36,7 +37,6 @@
 {
 	[AttributeUsage (AttributeTargets.All)]
 	[Serializable]
-
 	[ComVisible (true)]
 	[ComDefaultInterface (typeof (_Attribute))]
 	[ClassInterfaceAttribute (ClassInterfaceType.None)]
@@ -131,9 +131,7 @@
 			// neither parameter is allowed to be null
 			CheckParameters (element, attributeType);
 
-			// ParameterInfo inheritance hierarchies CAN NOT be searched for attributes, so the second
-			// parameter of GetCustomAttributes () is IGNORED.
-			object[] attributes = element.GetCustomAttributes (attributeType, inherit);
+			object[] attributes = GetCustomAttributes (element, attributeType, inherit);
 
 			return FindAttribute (attributes);
 		}
@@ -201,6 +199,10 @@
 			// element parameter is not allowed to be null
 			CheckParameters (element, attributeType);
 
+			Attribute [] attributes;
+			if (inherit && TryGetParamCustomAttributes (element, attributeType, out attributes))
+				return attributes;
+
 			return (Attribute []) element.GetCustomAttributes (attributeType, inherit);
 		}
 
@@ -263,7 +265,7 @@
 			// element parameter is not allowed to be null
 			CheckParameters (element, typeof (Attribute));
 
-			return (Attribute []) element.GetCustomAttributes (inherit);
+			return GetCustomAttributes (element, typeof (Attribute), inherit);
 		}
 
 		public override int GetHashCode ()
@@ -331,7 +333,6 @@
 			return element.IsDefined (attributeType, inherit);
 		}
 
-		// FIXME: MS apparently walks the inheritance way in some form.
 		public static bool IsDefined (ParameterInfo element, Type attributeType, bool inherit)
 		{
 			CheckParameters (element, attributeType);
@@ -339,10 +340,76 @@
 			if (element.IsDefined (attributeType, inherit))
 				return true;
 
-			// FIXME: MS walks up the inheritance chain in some crazy way
-			return IsDefined (element.Member, attributeType, inherit);
+			if (inherit)
+				return IsDefinedOnParameter (element, attributeType);
+
+			return false;
 		}
 
+		static bool IsDefinedOnParameter (ParameterInfo parameter, Type attributeType)
+		{
+			var member = parameter.Member;
+			if (member.MemberType != MemberTypes.Method)
+				return false;
+
+			var method = ((MethodInfo) member).GetBaseMethod ();
+
+			while (true) {
+				var param = method.GetParameters () [parameter.Position];
+				if (param.IsDefined (attributeType, false))
+					return true;
+
+				var base_method = method.GetBaseMethod ();
+				if (base_method == method)
+					break;
+
+				method = base_method;
+			}
+
+			return false;
+		}
+
+		static bool TryGetParamCustomAttributes (ParameterInfo parameter, Type attributeType, out Attribute [] attributes)
+		{
+			attributes = null;
+
+			if (parameter.Member.MemberType != MemberTypes.Method)
+				return false;
+
+			var method = (MethodInfo) parameter.Member;
+			var definition = method.GetBaseDefinition ();
+
+			if (method == definition)
+				return false;
+
+			var types = new List<Type> ();
+			var custom_attributes = new List<Attribute> ();
+
+			while (true) {
+				var param = method.GetParameters () [parameter.Position];
+				var param_attributes = (Attribute []) param.GetCustomAttributes (attributeType, false);
+				foreach (var param_attribute in param_attributes) {
+					var param_type = param_attribute.GetType ();
+					if (types.Contains (param_type))
+						continue;
+
+					types.Add (param_type);
+					custom_attributes.Add (param_attribute);
+				}
+
+				var base_method = method.GetBaseMethod ();
+				if (base_method == method)
+					break;
+
+				method = base_method;
+			}
+
+			attributes = (Attribute []) Array.CreateInstance (attributeType, custom_attributes.Count);
+			custom_attributes.CopyTo (attributes, 0);
+
+			return true;
+		}
+
 		public virtual bool Match (object obj)
 		{
 			// default action is the same as Equals.
Index: System/Environment.cs
===================================================================
--- System/Environment.cs	(revision 147238)
+++ System/Environment.cs	(working copy)
@@ -54,7 +54,7 @@
 		 * Changes which are already detected at runtime, like the addition
 		 * of icalls, do not require an increment.
 		 */
-		private const int mono_corlib_version = 86;
+		private const int mono_corlib_version = 87;
 
 		[ComVisible (true)]
 		public enum SpecialFolder
Index: System.Reflection/MonoMethod.cs
===================================================================
--- System.Reflection/MonoMethod.cs	(revision 147238)
+++ System.Reflection/MonoMethod.cs	(working copy)
@@ -126,13 +126,18 @@
 		internal static extern string get_name (MethodBase method);
 
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]
-		internal static extern MonoMethod get_base_definition (MonoMethod method);
+		internal static extern MonoMethod get_base_method (MonoMethod method, bool definition);
 
 		public override MethodInfo GetBaseDefinition ()
 		{
-			return get_base_definition (this);
+			return get_base_method (this, true);
 		}
 
+		internal override MethodInfo GetBaseMethod ()
+		{
+			return get_base_method (this, false);
+		}
+
 		public override ParameterInfo ReturnParameter {
 			get {
 				return MonoMethodInfo.GetReturnParameterInfo (this);
Index: System.Reflection/MethodInfo.cs
===================================================================
--- System.Reflection/MethodInfo.cs	(revision 147238)
+++ System.Reflection/MethodInfo.cs	(working copy)
@@ -41,6 +41,11 @@
 
 		public abstract MethodInfo GetBaseDefinition();
 
+		internal virtual MethodInfo GetBaseMethod ()
+		{
+			return this;
+		}
+
 		protected MethodInfo() {
 		}
 