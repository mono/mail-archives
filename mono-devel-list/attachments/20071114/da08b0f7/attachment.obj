Index: mini/ChangeLog
===================================================================
--- mini/ChangeLog	(revision 88950)
+++ mini/ChangeLog	(working copy)
@@ -1,3 +1,37 @@
+2007-MM-DD  Yoichi NAKAYAMA  <nakayama@pixela.co.jp>
+
+	* inssel-mips.brg (OP_OUTARG_MEMBASE (CEE_LDIND_R4 (base))): Add missing
+	OP_LOADR4_MEMBASE emission.
+
+	* mini-codegen.c (mono_spillvar_offset_int): Remove assertion.
+	(mono_spillvar_offset_float): Ditto.
+
+	* mini-mips.c (mono_arch_emit_prolog): Ditto.
+
+	* inssel-long32-mips.brg: Fix wrong branching, reduce redundant code
+	emission.
+
+	* basic-long.cs: Add regression tests for them.
+
+	* mini-mips.c (add_float32_arg): Respect o32 calling convention in gr
+	use.
+	(mono_arch_allocate_vars): Fix representation of single-precision float
+	argument.
+	(mono_arch_output_basic_block): Ditto.
+
+	* inssel-mips.brg: Ditto, remove duplicate items.
+
+	* mini-mips.c (emit_load_volatile_arguments): New function to handle
+	arguments of tail calls as on other platforms.
+	(mono_arch_output_basic_block): Handle tail calls.
+
+	* inssel-mips.brg (OP_OUTARG_VT (CEE_LDOBJ (base))): Correct destination
+	register.
+
+	* objects.cs (test_5_pass_static_struct): Add test for it.
+
+	Contributed under MIT/X11 license.
+
 2007-11-05  Rodrigo Kumpera  <rkumpera@novell.com>
 
 	* mini.c (mono_spill_call): add support for soft-float.
Index: mini/objects.cs
===================================================================
--- mini/objects.cs	(revision 88950)
+++ mini/objects.cs	(working copy)
@@ -226,6 +226,14 @@
 		return 5;
 	}
 
+	static Simple s_v;
+	static int test_5_pass_static_struct () {
+		s_v = get_simple (1);
+		if (receive_simple (7, s_v, 9) != 0)
+			return 0;
+		return 5;
+	}
+
 	// Test alignment of small structs
 
 	static Small get_small (byte v) {
Index: mini/inssel-long32-mips.brg
===================================================================
--- mini/inssel-long32-mips.brg	(revision 88950)
+++ mini/inssel-long32-mips.brg	(working copy)
@@ -605,9 +605,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_true_bb);
 
-	/* if (rreg2 < lreg2) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> false */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_false_bb);
 
 	/* (lreg2 == rreg2), if (lreg1 <= rreg1) -> true  [or if (rreg1 < lreg1) -> false] */
 
@@ -628,9 +627,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_true_bb);
 
-	/* if (rreg2 < lreg2) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> false */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_false_bb);
 
 	/* (rreg2 == lreg2), if (lreg1 <= rreg1) -> true  [or if (rreg1 < lreg1) -> false] */
 
@@ -650,9 +648,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_true_bb);
 
-	/* if (rreg2 < lreg2) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> false */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_false_bb);
 
 	/* (lreg2 == rreg2), if (lreg1 <= rreg1) -> true  [or if (rreg1 < lreg1) -> false] */
 
@@ -673,9 +670,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_true_bb);
 
-	/* if (rreg2 < lreg2) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> false */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_false_bb);
 
 	/* (rreg2 == lreg2), if (rreg1 <= lreg1) -> true  [or if (rreg1 < lreg1) -> false] */
 
@@ -695,11 +691,11 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 != lreg2) -> false */
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, rreg2, lreg2, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
-	/* (rreg2 == lreg2), so if (lreg1 < rreg1) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg1, rreg1);
+	/* (lreg2 == rreg2), so if (lreg1 < rreg1) -> false */
+	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 	MONO_EMIT_NEW_BRANCH_BLOCK (s, OP_BR, tree->inst_true_bb);
 }
@@ -716,13 +712,13 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 != lreg2) -> false */
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, rreg2, lreg2, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
      	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
-	/* (rreg2 == lreg2), so if (lreg1 < rreg1) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg1, rreg1);
+	/* (lreg2 == rreg2), so if (lreg1 < rreg1) -> false */
+	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 	MONO_EMIT_NEW_BRANCH_BLOCK (s, OP_BR, tree->inst_true_bb);
 }
@@ -737,11 +733,11 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 != lreg2) -> false */
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, rreg2, lreg2, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
 	/* (rreg2 == lreg2), so if (lreg1 < rreg1) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg1, rreg1);
+	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 	MONO_EMIT_NEW_BRANCH_BLOCK (s, OP_BR, tree->inst_true_bb);
 }
@@ -758,13 +754,13 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 != lreg2) -> false */
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, rreg2, lreg2, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
      	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
-	/* (rreg2 == lreg2), so if (lreg1 < rreg1) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg1, rreg1);
+	/* (lreg2 == rreg2), so if (lreg1 < rreg1) -> false */
+	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 	MONO_EMIT_NEW_BRANCH_BLOCK (s, OP_BR, tree->inst_true_bb);
 }
@@ -779,9 +775,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_true_bb);
 
-	/* if (rreg2 < lreg2) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> false */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_false_bb);
 
 	/* (lreg2 == rreg2), if (lreg1 < rreg1) -> true */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
@@ -801,9 +796,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_true_bb);
 
-	/* if (rreg2 < lreg2) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> false */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_false_bb);
 
      	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
@@ -823,9 +817,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_true_bb);
 
-	/* if (rreg2 < lreg2) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> false */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_false_bb);
 
 	/* (lreg2 == rreg2), if (lreg1 < rreg1) -> true */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
@@ -845,9 +838,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_true_bb);
 
-	/* if (rreg2 < lreg2) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> false */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_false_bb);
 
      	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
@@ -867,9 +859,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 < lreg2) -> true */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
 	/* (rreg2 == lreg2), so if (lreg1 > rreg1) -> true */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg1, lreg1);
@@ -889,9 +880,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 < lreg2) -> true */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
      	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
@@ -911,9 +901,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 < lreg2) -> true */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
 	/* (rreg2 == lreg2), so if (lreg1 > rreg1) -> true */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg1, lreg1);
@@ -933,9 +922,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 < lreg2) -> true */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
      	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
Index: mini/mini-mips.c
===================================================================
--- mini/mini-mips.c	(revision 88950)
+++ mini/mini-mips.c	(working copy)
@@ -82,10 +82,6 @@
 	MonoInst *data;
 };
 
-#define ALWAYS_ON_STACK(s) s
-#define FP_ALSO_IN_REG(s) s
-#define ALIGN_DOUBLES
-
 enum {
 	RegTypeGeneral,
 	RegTypeBase,
@@ -106,8 +102,7 @@
 	int nargs;
 	int gr;
 	int fr;
-	int gr_passed;
-	int fr_passed;
+	gboolean gr_passed;
 	gboolean on_stack;
 	int stack_size;
 	guint32 stack_usage;
@@ -545,17 +540,12 @@
 }
 
 static void
-args_onto_stack (CallInfo *info, gboolean force)
+args_onto_stack (CallInfo *info)
 {
-	if (!info->on_stack) {
-		if ((info->gr > MIPS_LAST_ARG_REG) || (info->fr > (MIPS_LAST_FPARG_REG+1))) {
-			force = TRUE;
-		}
-		if (force) {
-			info->on_stack = TRUE;
-			info->stack_size = MIPS_STACK_PARAM_OFFSET;
-		}
-	}
+	g_assert(!info->on_stack);
+	g_assert(info->stack_size <= MIPS_STACK_PARAM_OFFSET);
+	info->on_stack = TRUE;
+	info->stack_size = MIPS_STACK_PARAM_OFFSET;
 }
 
 /*
@@ -565,75 +555,73 @@
 static void
 add_int32_arg (CallInfo *info, ArgInfo *ainfo) {
 	/* First, see if we need to drop onto the stack */
-	args_onto_stack (info, FALSE);
+	if (!info->on_stack && info->gr > MIPS_LAST_ARG_REG)
+		args_onto_stack (info);
 
 	/* Now, place the argument */
-	ainfo->offset = info->stack_size;
-	info->stack_size += 4;
 	if (info->on_stack) {
 		ainfo->regtype = RegTypeBase;
 		ainfo->reg = mips_sp; /* in the caller */
+		ainfo->offset = info->stack_size;
 	}
 	else {
+		ainfo->regtype = RegTypeGeneral;
 		ainfo->reg = info->gr;
 		info->gr += 1;
-		info->gr_passed += 1;
-		/* FP and GP slots do not overlap */
-		info->fr += 1;
+		info->gr_passed = TRUE;
 	}
+	info->stack_size += 4;
 }
 
 static void
 add_int64_arg (CallInfo *info, ArgInfo *ainfo) {
 	/* First, see if we need to drop onto the stack */
-	args_onto_stack (info, FALSE);
+	if (!info->on_stack && info->gr+1 > MIPS_LAST_ARG_REG)
+		args_onto_stack (info);
 
 	/* Now, place the argument */
-	if (info->stack_size & 0x7) {
-		ArgInfo dummy;
+	if (info->on_stack) {
+		g_assert(info->stack_size % 4 == 0);
+		info->stack_size += (info->stack_size % 8);
 
-		/* foo (int, long) -- need to align 2nd arg */
-		add_int32_arg (info, &dummy);
-		args_onto_stack (info, FALSE);
-	}
-	ainfo->offset = info->stack_size;
-	info->stack_size += 8;
-	if (info->on_stack) {
 		ainfo->regtype = RegTypeBase;
 		ainfo->reg = mips_sp; /* in the caller */
+		ainfo->offset = info->stack_size;
 	}
 	else {
+		// info->gr must be a0 or a2
+		info->gr += (info->gr - MIPS_FIRST_ARG_REG) % 2;
+		g_assert(info->gr <= MIPS_LAST_ARG_REG);
+
+		ainfo->regtype = RegTypeGeneral;
 		ainfo->reg = info->gr;
 		info->gr += 2;
-		info->gr_passed += 2;
-		/* FP and GP slots do not overlap */
-		info->fr += 2;
+		info->gr_passed = TRUE;
 	}
+	info->stack_size += 8;
 }
 
 static void
 add_float32_arg (CallInfo *info, ArgInfo *ainfo) {
 	/* First, see if we need to drop onto the stack */
-	args_onto_stack (info, FALSE);
+	if (!info->on_stack && info->gr > MIPS_LAST_ARG_REG)
+		args_onto_stack (info);
 
 	/* Now, place the argument */
-	ainfo->offset = info->stack_size;
 	if (info->on_stack) {
 		ainfo->regtype = RegTypeBase;
 		ainfo->reg = mips_sp; /* in the caller */
-		info->stack_size += 8;
+		ainfo->offset = info->stack_size;
 	}
 	else {
 		/* Only use FP regs for args if no int args passed yet */
-		if (!info->gr_passed) {
+		if (!info->gr_passed && info->fr <= MIPS_LAST_FPARG_REG) {
 			ainfo->regtype = RegTypeFP;
 			ainfo->reg = info->fr;
-			info->stack_size += 8;
 			/* Even though it's a single-precision float, it takes up two FP regs */
 			info->fr += 2;
-			info->fr_passed += 1;
 			/* FP and GP slots do not overlap */
-			info->gr += 2;
+			info->gr += 1;
 		}
 		else {
 			/* Passing single-precision float arg in a GP register
@@ -642,47 +630,50 @@
 			 */
 			ainfo->regtype = RegTypeGeneral;
 			ainfo->reg = info->gr;
-			info->stack_size += 4;
 
-			/* Even though it's a single-precision float, it takes up two FP regs */
-			info->fr += 1;
-			info->fr_passed += 1;
-			/* FP and GP slots do not overlap */
 			info->gr += 1;
+			info->gr_passed = TRUE;
 		}
 	}
+	info->stack_size += 4;
 }
 
 static void
 add_float64_arg (CallInfo *info, ArgInfo *ainfo) {
 	/* First, see if we need to drop onto the stack */
-	args_onto_stack (info, FALSE);
+	if (!info->on_stack && info->gr+1 > MIPS_LAST_ARG_REG)
+		args_onto_stack (info);
 
 	/* Now, place the argument */
-#ifdef ALIGN_DOUBLES
-	// info->stack_size += (info->stack_size % 8);
-#endif
-	ainfo->offset = info->stack_size;
-	info->stack_size += 8;
 	if (info->on_stack) {
+		g_assert(info->stack_size % 4 == 0);
+		info->stack_size += (info->stack_size % 8);
+
 		ainfo->regtype = RegTypeBase;
 		ainfo->reg = mips_sp; /* in the caller */
+		ainfo->offset = info->stack_size;
 	}
 	else {
 		/* Only use FP regs for args if no int args passed yet */
-		if (!info->gr_passed) {
+		if (!info->gr_passed && info->fr <= MIPS_LAST_FPARG_REG) {
 			ainfo->regtype = RegTypeFP;
 			ainfo->reg = info->fr;
+			info->fr += 2;
+			/* FP and GP slots do not overlap */
+			info->gr += 2;
 		}
 		else {
+			// info->gr must be a0 or a2
+			info->gr += (info->gr - MIPS_FIRST_ARG_REG) % 2;
+			g_assert(info->gr <= MIPS_LAST_ARG_REG);
+
 			ainfo->regtype = RegTypeGeneral;
 			ainfo->reg = info->gr;
+			info->gr += 2;
+			info->gr_passed = TRUE;
 		}
-		info->fr += 2;
-		info->fr_passed += 2;
-		/* FP and GP slots do not overlap */
-		info->gr += 2;
 	}
+	info->stack_size += 8;
 }
 
 static CallInfo*
@@ -715,7 +706,7 @@
 		if ((sig->call_convention == MONO_CALL_VARARG) && (i == sig->sentinelpos)) {
                         /* Prevent implicit arguments and sig_cookie from
 			   being passed in registers */
-			args_onto_stack (cinfo, TRUE);
+			args_onto_stack (cinfo);
                         /* Emit the signature cookie just before the implicit arguments */
 			add_int32_arg (cinfo, &cinfo->sig_cookie);
                 }
@@ -774,8 +765,8 @@
 			/* Fall through */
 		case MONO_TYPE_VALUETYPE: {
 			int j;
-			int align_size;
 			int nwords = 0;
+			int has_offset = FALSE;
 			ArgInfo dummy_arg;
 			gint size, alignment;
 			MonoClass *klass;
@@ -788,25 +779,33 @@
 			alignment = mono_class_min_align (klass);
 #if MIPS_PASS_STRUCTS_BY_VALUE
 			/* Need to do alignment if struct contains long or double */
-			if (cinfo->stack_size & (alignment - 1)) {
-				add_int32_arg (cinfo, &dummy_arg);
+			if (alignment > 4) {
+				if (cinfo->stack_size & (alignment - 1)) {
+					add_int32_arg (cinfo, &dummy_arg);
+				}
+				g_assert (!(cinfo->stack_size & (alignment - 1)));
 			}
-			g_assert (!(cinfo->stack_size & (alignment - 1)));
 
 #if 0
 			g_printf ("valuetype struct size=%d offset=%d align=%d\n",
 				  mono_class_native_size (sig->params [i]->data.klass, NULL),
 				  cinfo->stack_size, alignment);
 #endif
-			align_size = size;
-			align_size += (sizeof (gpointer) - 1);
-			align_size &= ~(sizeof (gpointer) - 1);
-			nwords = (align_size + sizeof (gpointer) -1 ) / sizeof (gpointer);
+			nwords = (size + sizeof (gpointer) -1 ) / sizeof (gpointer);
+			g_assert(cinfo->args [n].size == 0);
+			g_assert(cinfo->args [n].vtsize == 0);
 			for (j = 0; j < nwords; ++j) {
-				if (j == 0)
+				if (j == 0) {
 					add_int32_arg (cinfo, &cinfo->args [n]);
-				else
+					if (cinfo->on_stack)
+						has_offset = TRUE;
+				} else {
 					add_int32_arg (cinfo, &dummy_arg);
+					if (!has_offset && cinfo->on_stack) {
+						cinfo->args [n].offset = dummy_arg.offset;
+						has_offset = TRUE;
+					}
+				}
 				if (cinfo->on_stack)
 					cinfo->args [n].vtsize += 1;
 				else
@@ -828,20 +827,26 @@
 				int size = sizeof (MonoTypedRef);
 				int nwords = (size + sizeof (gpointer) -1 ) / sizeof (gpointer);
 				cinfo->args [n].regtype = RegTypeStructByVal;
-				if (cinfo->gr <= MIPS_LAST_ARG_REG) {
+				if (!cinfo->on_stack && cinfo->gr <= MIPS_LAST_ARG_REG) {
 					int rest = MIPS_LAST_ARG_REG - cinfo->gr + 1;
 					int n_in_regs = rest >= nwords? nwords: rest;
 					cinfo->args [n].size = n_in_regs;
 					cinfo->args [n].vtsize = nwords - n_in_regs;
 					cinfo->args [n].reg = cinfo->gr;
 					cinfo->gr += n_in_regs;
+					cinfo->gr_passed = TRUE;
 				} else {
 					cinfo->args [n].size = 0;
 					cinfo->args [n].vtsize = nwords;
 				}
-				cinfo->args [n].offset = MIPS_STACK_PARAM_OFFSET + cinfo->stack_size;
-				g_print ("offset for arg %d at %d\n", n, MIPS_STACK_PARAM_OFFSET + cinfo->stack_size);
-				cinfo->stack_size += nwords * sizeof (gpointer);
+				if (cinfo->args [n].vtsize > 0) {
+					if (!cinfo->on_stack)
+						args_onto_stack (cinfo);
+					g_assert(cinfo->on_stack);
+					cinfo->args [n].offset = cinfo->stack_size;
+					g_print ("offset for arg %d at %d\n", n, cinfo->args [n].offset);
+					cinfo->stack_size += cinfo->args [n].vtsize * sizeof (gpointer);
+				}
 			}
 #else
 			add_int32_arg (cinfo, &cinfo->args[n]);
@@ -852,16 +857,19 @@
 		}
 		case MONO_TYPE_U8:
 		case MONO_TYPE_I8:
+                        DEBUG(printf("8 bytes\n"));
 			cinfo->args [n].size = 8;
 			add_int64_arg (cinfo, &cinfo->args[n]);
 			n++;
 			break;
 		case MONO_TYPE_R4:
+                        DEBUG(printf("R4\n"));
 			cinfo->args [n].size = 4;
 			add_float32_arg (cinfo, &cinfo->args[n]);
 			n++;
 			break;
 		case MONO_TYPE_R8:
+                        DEBUG(printf("R8\n"));
 			cinfo->args [n].size = 8;
 			add_float64_arg (cinfo, &cinfo->args[n]);
 			n++;
@@ -919,7 +927,7 @@
 	}
 
 	/* align stack size to 16 */
-	cinfo->stack_size = (cinfo->stack_size + 15) & ~15;
+	cinfo->stack_size = (cinfo->stack_size + MIPS_STACK_ALIGNMENT - 1) & ~(MIPS_STACK_ALIGNMENT - 1);
 
 	cinfo->stack_usage = cinfo->stack_size;
 	return cinfo;
@@ -960,7 +968,8 @@
 	if (cfg->method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE)
 		cfg->param_area = MAX (cfg->param_area, sizeof (gpointer)*8);
 
-	cfg->param_area = MAX (cfg->param_area, 16);
+	/* a0-a3 always present */
+	cfg->param_area = MAX (cfg->param_area, MIPS_STACK_PARAM_OFFSET);
 
 	header = mono_method_get_header (cfg->method);
 
@@ -1117,12 +1126,6 @@
 			inst->opcode = OP_REGOFFSET;
 			size = mono_type_size (arg_type, &align);
 
-			/* Need to take references to R4 into account */
-			/* If it's a single-precision float, allocate 8 bytes of stack for it */
-			if ((arg_type->type == MONO_TYPE_R4) && !arg_type->byref) {
-				align = 8;
-				size = 8;
-			}
 			if (size < 4) {
 				size = 4;
 				align = 4;
@@ -1235,6 +1238,7 @@
 #endif
 			} else if (ainfo->regtype == RegTypeBase) {
 				MonoMIPSArgInfo *ai = mono_mempool_alloc0 (cfg->mempool, sizeof (MonoMIPSArgInfo));
+				g_assert(ainfo->reg == mips_sp);
 				arg->opcode = OP_OUTARG_MEMBASE;
 				ai->reg = ainfo->reg;
 				ai->size = ainfo->size;
@@ -1734,6 +1738,96 @@
 	return code;
 }
 
+/*
+ * emit_load_volatile_arguments:
+ *
+ *  Load volatile arguments from the stack to the original input registers.
+ * Required before a tail call.
+ */
+static guint8 *
+emit_load_volatile_arguments(MonoCompile *cfg, guint8 *code)
+{
+	MonoMethod *method = cfg->method;
+	MonoMethodSignature *sig;
+	MonoInst *inst;
+	CallInfo *cinfo;
+	int i;
+
+	sig = mono_method_signature (method);
+	cinfo = calculate_sizes (sig, sig->pinvoke);
+	if (cinfo->struct_ret) {
+		ArgInfo *ainfo = &cinfo->ret;
+		inst = cfg->ret;
+		mips_lw (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
+	}
+
+	for (i = 0; i < sig->param_count + sig->hasthis; ++i) {
+		ArgInfo *ainfo = cinfo->args + i;
+		inst = cfg->args [i];
+		if (inst->opcode == OP_REGVAR) {
+			if (ainfo->regtype == RegTypeGeneral)
+				mips_move (code, ainfo->reg, inst->dreg);
+			else if (ainfo->regtype == RegTypeFP)
+				g_assert_not_reached();
+			else if (ainfo->regtype == RegTypeBase) {
+				/* do nothing */
+			} else
+				g_assert_not_reached ();
+		} else {
+			if (ainfo->regtype == RegTypeGeneral) {
+				g_assert (mips_is_imm16 (inst->inst_offset));
+				switch (ainfo->size) {
+				case 1:
+					mips_lb (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
+					break;
+				case 2:
+					mips_lh (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
+					break;
+				case 0: /* XXX */
+				case 4:
+					mips_lw (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
+					break;
+				case 8:
+					mips_lw (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
+					mips_lw (code, ainfo->reg + 1, inst->inst_basereg, inst->inst_offset + 4);
+					break;
+				default:
+					g_assert_not_reached ();
+					break;
+				}
+			} else if (ainfo->regtype == RegTypeBase) {
+				/* do nothing */
+			} else if (ainfo->regtype == RegTypeFP) {
+				g_assert (mips_is_imm16 (inst->inst_offset));
+				if (ainfo->size == 8)
+					mips_ldc1 (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
+				else if (ainfo->size == 4)
+					mips_lwc1 (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
+				else
+					g_assert_not_reached ();
+			} else if (ainfo->regtype == RegTypeStructByVal) {
+				int i;
+				int doffset = inst->inst_offset;
+
+				g_assert (mips_is_imm16 (inst->inst_offset));
+				g_assert (mips_is_imm16 (inst->inst_offset + ainfo->size * sizeof (gpointer)));
+				for (i = 0; i < ainfo->size; ++i) {
+					mips_lw (code, ainfo->reg + i, inst->inst_basereg, doffset);
+					doffset += sizeof (gpointer);
+				}
+			} else if (ainfo->regtype == RegTypeStructByAddr) {
+				g_assert (mips_is_imm16 (inst->inst_offset));
+				mips_lw (code, ainfo->reg, inst->inst_basereg, inst->inst_offset);
+			} else
+				g_assert_not_reached ();
+		}
+	}
+
+	g_free (cinfo);
+
+	return code;
+}
+
 void
 mono_arch_output_basic_block (MonoCompile *cfg, MonoBasicBlock *bb)
 {
@@ -2295,6 +2389,8 @@
 			mips_cvtds (code, ins->dreg, ins->dreg);
 			break;
 		case OP_JMP:
+			code = emit_load_volatile_arguments(cfg, code);
+
 			/*
 			 * Pop our stack, then jump to specified method (tail-call)
 			 * Keep in sync with mono_arch_emit_epilog
@@ -2342,13 +2438,13 @@
 		case OP_VCALL_MEMBASE:
 		case OP_VOIDCALL_MEMBASE:
 		case OP_CALL_MEMBASE:
+			call = (MonoCallInst*)ins;
 			switch (ins->opcode) {
 			case OP_FCALL:
 			case OP_LCALL:
 			case OP_VCALL:
 			case OP_VOIDCALL:
 			case CEE_CALL:
-				call = (MonoCallInst*)ins;
 				if (ins->flags & MONO_INST_HAS_METHOD)
 					mono_add_patch_info (cfg, offset, MONO_PATCH_INFO_METHOD, call->method);
 				else
@@ -2373,6 +2469,11 @@
 			}
 			mips_jalr (code, mips_t9, mips_ra);
 			mips_nop (code);
+			if ((ins->opcode == OP_FCALL ||
+			     ins->opcode == OP_FCALL_REG) &&
+			    call->signature->ret->type == MONO_TYPE_R4) {
+				mips_cvtds (code, mips_f0, mips_f0);
+			}
 			break;
 		case OP_OUTARG:
 			g_assert_not_reached ();
@@ -3136,7 +3237,7 @@
 /*
  * Stack frame layout:
  * 
- *   ------------------- sp + cfg->stack_usage + MIPS_STACK_PARAM_OFFSET + cfg->param_area
+ *   ------------------- sp + cfg->stack_usage + cfg->param_area
  *      param area		incoming
  *   ------------------- sp + cfg->stack_usage + MIPS_STACK_PARAM_OFFSET
  *      a0-a3			incoming
@@ -3152,7 +3253,7 @@
  *   	locals
  *   ------------------- sp + cfg->param_area
  *   	param area		outgoing
- *   ------------------- sp + 16
+ *   ------------------- sp + MIPS_STACK_PARAM_OFFSET
  *   	a0-a3			outgoing
  *   ------------------- sp
  *   	red zone
@@ -3186,9 +3287,6 @@
 	cfg->code_size = 768 + sig->param_count * 20;
 	code = cfg->native_code = g_malloc (cfg->code_size);
 
-	alloc_size = cfg->stack_offset;
-	g_assert ((alloc_size & (MIPS_STACK_ALIGNMENT-1)) == 0);
-
 	/* re-align cfg->stack_offset if needed (due to var spilling in mini-codegen.c) */
 	cfg->stack_offset = (cfg->stack_offset + MIPS_STACK_ALIGNMENT - 1) & ~(MIPS_STACK_ALIGNMENT - 1);
 
@@ -3295,6 +3393,7 @@
 			mips_sw (code, ainfo->reg, mips_at, 0);
 		}
 	}
+	/* Keep this in sync with emit_load_volatile_arguments */
 	for (i = 0; i < sig->param_count + sig->hasthis; ++i) {
 		ArgInfo *ainfo = cinfo->args + i;
 		inst = cfg->args [pos];
@@ -3477,10 +3576,9 @@
 	int offset;
 	MonoMethod *method = cfg->method;
 	int rtype = mono_type_get_underlying_type (mono_method_signature (method)->ret)->type;
-	int save_offset = 16;
+	int save_offset = MIPS_STACK_PARAM_OFFSET;
 
-	save_offset += 15;
-	save_offset &= ~15;
+	g_assert ((save_offset & (MIPS_STACK_ALIGNMENT-1)) == 0);
 	
 	offset = code - cfg->native_code;
 	/* we need about 16 instructions */
Index: mini/inssel-mips.brg
===================================================================
--- mini/inssel-mips.brg	(revision 88950)
+++ mini/inssel-mips.brg	(working copy)
@@ -349,7 +349,11 @@
 }
 
 stmt: OP_SETRET (freg) {
-	tree->opcode = OP_FMOVE;
+	if (mono_method_signature (s->method)->ret->type == MONO_TYPE_R4) {
+		tree->opcode = OP_MIPS_CVTSD;
+	} else {
+		tree->opcode = OP_FMOVE;
+	}
 	tree->sreg1 = state->left->reg1;
 	tree->dreg = mips_f0;
 	mono_bblock_add_inst (s->cbb, tree);
@@ -468,17 +472,7 @@
 	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
 }
 
-stmt: OP_OUTARG (CEE_LDIND_REF (OP_REGVAR)) {
-	MonoCallInst *call = tree->inst_call;
 
-	tree->opcode = OP_SETREG;
-	tree->sreg1 = state->left->left->tree->dreg;
-	tree->dreg = mono_regstate_next_int (s->rs);
-	mono_bblock_add_inst (s->cbb, tree);
-	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, FALSE);
-}
-
-
 #
 # FP calculation being passed in GP registers
 # Need to get FP bit pattern out in GP regs w/o conversion
@@ -517,9 +511,9 @@
 #
 stmt: OP_OUTARG_MEMBASE (CEE_LDIND_R4 (base)) {
 	MonoMIPSArgInfo *ai = tree->backend.data;
-	MonoCallInst *call = tree->inst_call;
-	int opcode = (tree->backend.arg_info & 0xff00) == 0x0400? OP_STORER4_MEMBASE_REG: OP_STORER8_MEMBASE_REG;
+	int opcode = ai->size == 4? OP_STORER4_MEMBASE_REG: OP_STORER8_MEMBASE_REG;
 
+	MONO_EMIT_NEW_LOAD_MEMBASE_OP(s, OP_LOADR4_MEMBASE, state->left->reg1, state->left->left->tree->inst_basereg, state->left->left->tree->inst_offset);
 	MONO_EMIT_NEW_STORE_MEMBASE (s, opcode, mips_sp, ai->offset, state->left->reg1);
 }
 
@@ -577,13 +571,6 @@
 #	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3, TRUE);
 #}
 
-stmt: OP_OUTARG_MEMBASE (CEE_LDIND_R4 (base)) {
-	MonoMIPSArgInfo *ai = tree->backend.data;
-	int opcode = (tree->backend.arg_info & 0xff00) == 0x0400? OP_STORER4_MEMBASE_REG: OP_STORER8_MEMBASE_REG;
-
-	MONO_EMIT_NEW_STORE_MEMBASE (s, opcode, mips_sp, ai->offset, state->left->reg1);
-}
-
 #
 # single-precision floating point constant in a gp register.
 #
@@ -624,11 +611,10 @@
 		MONO_EMIT_NEW_LOAD_MEMBASE (s, dreg, vt->inst_basereg, soffset);
 		mono_call_inst_add_outarg_reg (s, call, dreg, start_reg + i, FALSE);
 		soffset += sizeof (gpointer);
-		doffset += sizeof (gpointer);
 	}
 	//g_printf ("vt size: %d at R%d + %d\n", ai->offset, vt->inst_basereg, vt->inst_offset);
 	if (ovf_size != 0) {
-		mini_emit_memcpy (s, vt->inst_basereg, doffset, vt->inst_basereg, soffset, ovf_size * sizeof (gpointer), 0);
+		mini_emit_memcpy (s, mips_sp, doffset, vt->inst_basereg, soffset, ovf_size * sizeof (gpointer), 0);
 	}
 }
 
Index: mini/basic-long.cs
===================================================================
--- mini/basic-long.cs	(revision 88950)
+++ mini/basic-long.cs	(working copy)
@@ -103,6 +103,8 @@
 		long a = 0xffffffffff;
 		if (a == 0xfffffffffe)
 			return 1;
+		if (a == 0xfeffffffff)
+			return 2;
 		return 0;
 	}
 
@@ -110,6 +112,20 @@
 		long a = 0xffffffffff;
 		if (a > 0xffffffffff)
 			return 1;
+
+		if (a > 0x1ffffffffff)
+			return 2;
+
+		if (a > 0xff00000000) {} else
+			return 3;
+
+		if (a > 0xfeffffffff) {} else
+			return 4;
+
+		a = 0xff00000000;
+		if (a > 0xffffffffff)
+			return 5;
+
 		return 0;
 	}
 
@@ -117,6 +133,20 @@
 		ulong a = 0xffffffffff;
 		if (a > 0xffffffffff)
 			return 1;
+
+		if (a > 0x1ffffffffff)
+			return 2;
+
+		if (a > 0xff00000000) {} else
+			return 3;
+
+		if (a > 0xfeffffffff) {} else
+			return 4;
+
+		a = 0xff00000000;
+		if (a > 0xffffffffff)
+			return 5;
+
 		return 0;
 	}
 
@@ -124,6 +154,20 @@
 		long a = 0xffffffffff;
 		if (a < 0xffffffffff)
 			return 1;
+
+		if (a < 0x1ffffffffff) {} else
+			return 2;
+
+		if (a < 0xff00000000)
+			return 3;
+
+		if (a < 0xfeffffffff)
+			return 4;
+
+		a = 0xff00000000;
+		if (a < 0xffffffffff) {} else
+			return 5;
+
 		return 0;
 	}
 
@@ -131,6 +175,20 @@
 		ulong a = 0xffffffffff;
 		if (a < 0xffffffffff)
 			return 1;
+
+		if (a < 0x1ffffffffff) {} else
+			return 2;
+
+		if (a < 0xff00000000)
+			return 3;
+
+		if (a < 0xfeffffffff)
+			return 4;
+
+		a = 0xff00000000;
+		if (a < 0xffffffffff) {} else
+			return 5;
+
 		return 0;
 	}
 
@@ -138,6 +196,20 @@
 		long a = 0xfffffffffe;
 		if (a >= 0xffffffffff)
 			return 1;
+
+		if (a >= 0x1fffffffffe)
+			return 2;
+
+		if (a >= 0xff00000000) {} else
+			return 3;
+
+		if (a >= 0xfefffffffe) {} else
+			return 4;
+
+		a = 0xff00000000;
+		if (a >= 0xffffffffff)
+			return 5;
+
 		return 0;
 	}
 
@@ -145,6 +217,20 @@
 		ulong a = 0xfffffffffe;
 		if (a >= 0xffffffffff)
 			return 1;
+
+		if (a >= 0x1fffffffffe)
+			return 2;
+
+		if (a >= 0xff00000000) {} else
+			return 3;
+
+		if (a >= 0xfefffffffe) {} else
+			return 4;
+
+		a = 0xff00000000;
+		if (a >= 0xffffffffff)
+			return 5;
+
 		return 0;
 	}
 
@@ -152,9 +238,44 @@
 		long a = 0xffffffffff;
 		if (a <= 0xfffffffffe)
 			return 1;
+
+		if (a <= 0x1ffffffffff) {} else
+			return 2;
+
+		if (a <= 0xff00000000)
+			return 3;
+
+		if (a <= 0xfeffffffff)
+			return 4;
+
+		a = 0xff00000000;
+		if (a <= 0xffffffffff) {} else
+			return 5;
+
 		return 0;
 	}
 
+	public static int test_0_bgt_un () {
+		ulong a = 0xffffffffff;
+		if (a <= 0xfffffffffe)
+			return 1;
+
+		if (a <= 0x1ffffffffff) {} else
+			return 2;
+
+		if (a <= 0xff00000000)
+			return 3;
+
+		if (a <= 0xfeffffffff)
+			return 4;
+
+		a = 0xff00000000;
+		if (a <= 0xffffffffff) {} else
+			return 5;
+
+		return 0;
+	}
+
 	public static int test_0_conv_to_i4 () {
 		long a = 0;
 
Index: mini/mini-codegen.c
===================================================================
--- mini/mini-codegen.c	(revision 88950)
+++ mini/mini-codegen.c	(working copy)
@@ -220,9 +220,6 @@
 {
 	MonoSpillInfo *info;
 
-#if defined (__mips__)
-	g_assert_not_reached();
-#endif
 	if (G_UNLIKELY (spillvar >= cfg->spill_info_len)) {
 		resize_spill_info (cfg, FALSE);
 		g_assert (spillvar < cfg->spill_info_len);
@@ -255,9 +252,6 @@
 {
 	MonoSpillInfo *info;
 
-#if defined (__mips__)
-	g_assert_not_reached();
-#endif
 	if (G_UNLIKELY (spillvar >= cfg->spill_info_float_len)) {
 		resize_spill_info (cfg, TRUE);
 		g_assert (spillvar < cfg->spill_info_float_len);
Index: utils/mono-membar.h
===================================================================
--- utils/mono-membar.h	(revision 88702)
+++ utils/mono-membar.h	(working copy)
@@ -135,6 +135,21 @@
 {
 	mono_memory_barrier ();
 }
+#elif defined(__mips__)
+static inline void mono_memory_barrier (void)
+{
+        __asm__ __volatile__ ("" : : : "memory");
+}
+
+static inline void mono_memory_read_barrier (void)
+{
+        mono_memory_barrier ();
+}
+
+static inline void mono_memory_write_barrier (void)
+{
+        mono_memory_barrier ();
+}
 #endif
 
 #endif	/* _MONO_UTILS_MONO_MEMBAR_H_ */
Index: utils/ChangeLog
===================================================================
--- utils/ChangeLog	(revision 88702)
+++ utils/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2007-MM-DD  Yoichi NAKAYAMA  <nakayama@pixela.co.jp>
+
+	* mono-membar.h: Memory barrier for mips.
+
+	Contributed under MIT/X11 license.
+
 2007-10-11  Zoltan Varga  <vargaz@freemail.hu>
 
 	* mono-mmap.c (mono_vfree): Fix call to VirtualFree (). Fixes #332165.
