Index: mono-1.2.6/mono/mini/inssel-float.brg
===================================================================
--- inssel-float.brg.orig
+++ inssel-float.brg
@@ -228,6 +228,26 @@
 }
 
 #
+# DM7025 - long - float conversion
+#
+
+lreg: OP_FCONV_TO_I8 (freg) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
+}
+
+freg: OP_LCONV_TO_R8 (lreg) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
+}
+
+freg: OP_LCONV_TO_R4 (lreg) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
+}
+
+freg: OP_FREM (freg, freg) {
+	MONO_EMIT_UNALU (s, tree, tree->opcode, state->reg1, state->left->reg1);
+}
+
+#
 # control flow
 #
 
Index: mono-1.2.6/mono/mini/inssel-long32-mips.brg
===================================================================
--- inssel-long32-mips.brg.orig
+++ inssel-long32-mips.brg
@@ -695,11 +695,11 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 != lreg2) -> false */
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, rreg2, lreg2, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
-	/* (rreg2 == lreg2), so if (lreg1 < rreg1) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg1, rreg1);
+	/* (lreg2 == rreg2), so if (lreg1 < rreg1) -> false */
+	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 	MONO_EMIT_NEW_BRANCH_BLOCK (s, OP_BR, tree->inst_true_bb);
 }
@@ -710,19 +710,19 @@
 	int rreg1 = mono_regstate_next_int (s->rs);
 	int rreg2 = mono_regstate_next_int (s->rs);
 
-     	MONO_EMIT_NEW_ICONST (s, rreg2, state->left->right->tree->inst_ms_word);
+	MONO_EMIT_NEW_ICONST (s, rreg2, state->left->right->tree->inst_ms_word);
 
 	/* if (lreg2 < rreg2) -> false */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 != lreg2) -> false */
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, rreg2, lreg2, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
-     	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
+	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
-	/* (rreg2 == lreg2), so if (lreg1 < rreg1) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg1, rreg1);
+	/* (lreg2 == rreg2), so if (lreg1 < rreg1) -> false */
+	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 	MONO_EMIT_NEW_BRANCH_BLOCK (s, OP_BR, tree->inst_true_bb);
 }
@@ -737,11 +737,11 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 != lreg2) -> false */
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, rreg2, lreg2, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
 	/* (rreg2 == lreg2), so if (lreg1 < rreg1) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg1, rreg1);
+	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 	MONO_EMIT_NEW_BRANCH_BLOCK (s, OP_BR, tree->inst_true_bb);
 }
@@ -752,19 +752,19 @@
 	int rreg1 = mono_regstate_next_int (s->rs);
 	int rreg2 = mono_regstate_next_int (s->rs);
 
-     	MONO_EMIT_NEW_ICONST (s, rreg2, state->left->right->tree->inst_ms_word);
+	MONO_EMIT_NEW_ICONST (s, rreg2, state->left->right->tree->inst_ms_word);
 
 	/* if (lreg2 < rreg2) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
+	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 != lreg2) -> false */
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, rreg2, lreg2, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
-     	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
+	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
-	/* (rreg2 == lreg2), so if (lreg1 < rreg1) -> false */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg1, rreg1);
+	/* (lreg2 == rreg2), so if (lreg1 < rreg1) -> false */
+	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg1, rreg1);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 	MONO_EMIT_NEW_BRANCH_BLOCK (s, OP_BR, tree->inst_true_bb);
 }
@@ -867,9 +867,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 < lreg2) -> true */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
 	/* (rreg2 == lreg2), so if (lreg1 > rreg1) -> true */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg1, lreg1);
@@ -883,17 +882,16 @@
 	int rreg1 = mono_regstate_next_int (s->rs);
 	int rreg2 = mono_regstate_next_int (s->rs);
 
-     	MONO_EMIT_NEW_ICONST (s, rreg2, state->left->right->tree->inst_ms_word);
+	MONO_EMIT_NEW_ICONST (s, rreg2, state->left->right->tree->inst_ms_word);
 
 	/* if (lreg2 < rreg2) -> false */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 < lreg2) -> true */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLT, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
-     	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
+	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
 	/* (rreg2 == lreg2), so if (lreg1 > rreg1) -> true */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg1, lreg1);
@@ -911,9 +909,8 @@
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 < lreg2) -> true */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
 	/* (rreg2 == lreg2), so if (lreg1 > rreg1) -> true */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg1, lreg1);
@@ -927,17 +924,16 @@
 	int rreg1 = mono_regstate_next_int (s->rs);
 	int rreg2 = mono_regstate_next_int (s->rs);
 
-     	MONO_EMIT_NEW_ICONST (s, rreg2, state->left->right->tree->inst_ms_word);
+	MONO_EMIT_NEW_ICONST (s, rreg2, state->left->right->tree->inst_ms_word);
 
 	/* if (lreg2 < rreg2) -> false */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, lreg2, rreg2);
 	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
 
-	/* if (rreg2 < lreg2) -> true */
-	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg2, lreg2);
-	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, mips_at, mips_zero, tree->inst_false_bb);
+	/* if (lreg2 != rreg2) -> true */
+	MONO_EMIT_NEW_COMPARE_BRANCH_BLOCK (s, OP_MIPS_BNE, lreg2, rreg2, tree->inst_true_bb);
 
-     	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
+	MONO_EMIT_NEW_ICONST (s, rreg1, state->left->right->tree->inst_ls_word);
 
 	/* (rreg2 == lreg2), so if (lreg1 > rreg1) -> true */
 	MONO_EMIT_NEW_BIALU (s, OP_MIPS_SLTU, mips_at, rreg1, lreg1);

Index: mono-1.2.6/mono/mini/inssel-mips.brg
===================================================================
--- inssel-mips.brg.orig
+++ inssel-mips.brg
@@ -439,11 +439,11 @@
 	MonoCallInst *call = tree->inst_call;
 	int tdreg = mono_regstate_next_int (s->rs);
 
-	MONO_EMIT_NEW_UNALU (s, OP_SETREG, tdreg, state->left->reg2);
+	MONO_EMIT_NEW_UNALU (s, OP_SETREG, tdreg, state->left->reg1);
 	mono_call_inst_add_outarg_reg (s, call, tdreg, tree->backend.reg3, FALSE);
 	tree->opcode = OP_SETREG;
 	tree->dreg = mono_regstate_next_int (s->rs);
-	tree->sreg1 = state->left->reg1;
+	tree->sreg1 = state->left->reg2;
 	mono_bblock_add_inst (s->cbb, tree);
 	mono_call_inst_add_outarg_reg (s, call, tree->dreg, tree->backend.reg3 + 1, FALSE);
 }
Index: mono-1.2.6/mono/mini/jit-icalls.c
===================================================================
--- jit-icalls.c.orig
+++ jit-icalls.c
@@ -68,7 +68,15 @@
 mono_llmult (gint64 a, gint64 b)
 {
 	/* no need, no exceptions: MONO_ARCH_SAVE_REGS;*/
-	return a * b;
+
+	guint32 tmp;
+	guint64 res = a * b;
+
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
+	return res;
 }
 
 guint64  
@@ -308,6 +316,10 @@
 	if ((res >> 32))
 		mono_raise_exception (mono_get_exception_overflow ());
 
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
 	return res;
 }
 #endif
@@ -333,7 +345,17 @@
 	else if (b == -1 && a == (-9223372036854775807LL - 1LL))
 		mono_raise_exception (mono_get_exception_arithmetic ());
 #endif
-	return a / b;
+
+	guint64 res;
+
+	res = a / b;
+
+	guint32 tmp;
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
+	return res;
 }
 
 gint64 
@@ -341,13 +363,24 @@
 {
 	MONO_ARCH_SAVE_REGS;
 
+	guint32 tmp;
+
 #ifdef MONO_ARCH_NEED_DIV_CHECK
 	if (!b)
 		mono_raise_exception (mono_get_exception_divide_by_zero ());
 	else if (b == -1 && a == (-9223372036854775807LL - 1LL))
 		mono_raise_exception (mono_get_exception_arithmetic ());
 #endif
-	return a % b;
+
+	guint64 res;
+
+	res = a % b;
+
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
+	return res;
 }
 
 guint64 
@@ -355,11 +388,22 @@
 {
 	MONO_ARCH_SAVE_REGS;
 
+	guint32 tmp;
+
 #ifdef MONO_ARCH_NEED_DIV_CHECK
 	if (!b)
 		mono_raise_exception (mono_get_exception_divide_by_zero ());
 #endif
-	return a / b;
+
+	guint64 res;
+
+	res = a / b;
+
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
+	return res;
 }
 
 guint64 
@@ -367,11 +411,22 @@
 {
 	MONO_ARCH_SAVE_REGS;
 
+	guint32 tmp;
+
 #ifdef MONO_ARCH_NEED_DIV_CHECK
 	if (!b)
 		mono_raise_exception (mono_get_exception_divide_by_zero ());
 #endif
-	return a % b;
+
+	guint64 res;
+
+	res = a % b;
+
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
+	return res;
 }
 
 #endif
@@ -383,11 +438,17 @@
 {
 	guint64 res;
 
+	guint32 tmp;
+
 	/* no need, no exceptions: MONO_ARCH_SAVE_REGS;*/
 	res = a << shamt;
 
 	/*printf ("TESTL %lld << %d = %lld\n", a, shamt, res);*/
 
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
 	return res;
 }
 
@@ -396,11 +457,17 @@
 {
 	guint64 res;
 
+	guint32 tmp;
+
 	/* no need, no exceptions: MONO_ARCH_SAVE_REGS;*/
 	res = a >> shamt;
 
 	/*printf ("TESTR %lld >> %d = %lld\n", a, shamt, res);*/
 
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
 	return res;
 }
 
@@ -409,11 +476,17 @@
 {
 	gint64 res;
 
+	guint32 tmp;
+
 	/* no need, no exceptions: MONO_ARCH_SAVE_REGS;*/
 	res = a >> shamt;
 
 	/*printf ("TESTR %lld >> %d = %lld\n", a, shamt, res);*/
 
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
 	return res;
 }

Index: mono-1.2.6/mono/mini/mini-codegen.c
===================================================================
--- mini-codegen.c.orig
+++ mini-codegen.c
@@ -220,9 +220,9 @@
 {
 	MonoSpillInfo *info;
 
-#if defined (__mips__)
-	g_assert_not_reached();
-#endif
+//#if defined (__mips__)
+//	g_assert_not_reached();
+//#endif
 	if (G_UNLIKELY (spillvar >= cfg->spill_info_len)) {
 		resize_spill_info (cfg, FALSE);
 		g_assert (spillvar < cfg->spill_info_len);
@@ -255,9 +255,9 @@
 {
 	MonoSpillInfo *info;
 
-#if defined (__mips__)
-	g_assert_not_reached();
-#endif
+//#if defined (__mips__)
+//	g_assert_not_reached();
+//#endif
 	if (G_UNLIKELY (spillvar >= cfg->spill_info_float_len)) {
 		resize_spill_info (cfg, TRUE);
 		g_assert (spillvar < cfg->spill_info_float_len);
Index: mono-1.2.6/mono/mini/mini-mips.c
===================================================================
--- mini-mips.c.orig
+++ mini-mips.c
@@ -2779,11 +2779,11 @@
 		case OP_FCONV_TO_U:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
 			break;
-		case OP_FCONV_TO_I8:
+		/*case OP_FCONV_TO_I8:
 		case OP_FCONV_TO_U8:
 			g_assert_not_reached ();
-			/* Implemented as helper calls */
-			break;
+			/* Implemented as helper calls * /
+			break;*/
 		case OP_LCONV_TO_R_UN:
 			g_assert_not_reached ();
 			/* Implemented as helper calls */
@@ -2810,10 +2810,10 @@
 		case OP_FNEG:
 			mips_fnegd (code, ins->dreg, ins->sreg1);
 			break;		
-		case OP_FREM:
-			/* emulated */
+		/*case OP_FREM:
+			/ * emulated * /
 			g_assert_not_reached ();
-			break;
+			break;*/
 		case OP_FCOMPARE:
 			g_assert_not_reached();
 			break;
@@ -2966,6 +2966,29 @@
 #endif
 			break;
 		}
+		case OP_FCONV_TO_I8:
+			mips_truncwd (code, mips_ftemp, ins->sreg1);
+			mips_mfc1 (code, ins->dreg, mips_ftemp);
+			mips_move (code, ins->dreg+1, mips_zero);
+			mips_nop (code);
+			break;
+		case OP_LCONV_TO_R8:
+			// works only for int
+			mips_mtc1 (code, mips_ftemp, ins->sreg1);
+			mips_cvtdw (code, ins->dreg, mips_ftemp);
+			mips_nop (code);
+			break;
+		case OP_LCONV_TO_R4:
+			// works only for int
+			mips_mtc1 (code, mips_ftemp, ins->sreg1);
+			mips_cvtsw (code, ins->dreg, mips_ftemp);
+			mips_cvtds (code, ins->dreg, ins->dreg);
+			mips_nop (code);
+			break;
+		case OP_FREM:
+			// not implemented
+			mips_nop (code);
+			break;
 		default:
 			g_warning ("unknown opcode %s in %s()\n", mono_inst_name (ins->opcode), __FUNCTION__);
 			g_assert_not_reached ();
@@ -3186,8 +3209,8 @@
 	cfg->code_size = 768 + sig->param_count * 20;
 	code = cfg->native_code = g_malloc (cfg->code_size);
 
-	alloc_size = cfg->stack_offset;
-	g_assert ((alloc_size & (MIPS_STACK_ALIGNMENT-1)) == 0);
+//	alloc_size = cfg->stack_offset;
+//	g_assert ((alloc_size & (MIPS_STACK_ALIGNMENT-1)) == 0);
 
 	/* re-align cfg->stack_offset if needed (due to var spilling in mini-codegen.c) */
 	cfg->stack_offset = (cfg->stack_offset + MIPS_STACK_ALIGNMENT - 1) & ~(MIPS_STACK_ALIGNMENT - 1);
Index: mono-1.2.6/mono/mini/mini-mips.h
===================================================================
--- mini-mips.h.orig
+++ mini-mips.h
@@ -136,11 +136,11 @@
 	guint		spillvar_offset_float;
 } MonoCompileArch;
 
-#define MONO_ARCH_EMULATE_FCONV_TO_I8 1
-#define MONO_ARCH_EMULATE_LCONV_TO_R8 1
-#define MONO_ARCH_EMULATE_LCONV_TO_R4 1
+// define MONO_ARCH_EMULATE_FCONV_TO_I8 1
+// define MONO_ARCH_EMULATE_LCONV_TO_R8 1
+// define MONO_ARCH_EMULATE_LCONV_TO_R4 1
 #define MONO_ARCH_EMULATE_LCONV_TO_R8_UN 1
-#define MONO_ARCH_EMULATE_FREM 1
+// define MONO_ARCH_EMULATE_FREM 1
 #define MONO_ARCH_BIGMUL_INTRINS 1
 
 #define MIPS_RET_ADDR_OFFSET	(-4)
Index: mono-1.2.6/mono/metadata/file-io.c
===================================================================
--- file-io.c.orig
+++ file-io.c
@@ -686,7 +686,14 @@
 		*error=GetLastError ();
 	}
 	
-	return offset | ((gint64)offset_hi << 32);
+	gint64 res = offset | ((gint64)offset_hi << 32);
+	
+	guint32 tmp;
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+	
+	return res;					
 }
 
 MonoBoolean
@@ -721,7 +728,14 @@
 		*error=GetLastError ();
 	}
 	
-	return length | ((gint64)length_hi << 32);
+	gint64 res = length | ((gint64)length_hi << 32);
+
+	guint32 tmp;
+	tmp = *(guint32 *) &res;
+	*(guint32 *) &res = *(((guint32 *) &res)+1);
+	*(((guint32 *) &res)+1) = tmp;
+
+	return res;
 }
 
 MonoBoolean

Index: mono-1.2.6/mono/metadata/icall.c
===================================================================
--- icall.c.orig
+++ icall.c
@@ -5453,6 +5453,12 @@
 
 	if (gettimeofday (&tv, NULL) == 0) {
 		res = (((gint64)tv.tv_sec + EPOCH_ADJUST)* 1000000 + tv.tv_usec)*10;
+
+		guint32 tmp;
+		tmp = *(guint32 *) &res;
+		*(guint32 *) &res = *(((guint32 *) &res)+1);
+		*(((guint32 *) &res)+1) = tmp;
+
 		return res;
 	}
 	/* fixme: raise exception */
Index: mono-1.2.6/mcs/class/System/System.Net/WebHeaderCollection.cs
===================================================================
--- WebHeaderCollection.cs.orig
+++ WebHeaderCollection.cs
@@ -679,7 +679,12 @@
 					return false;
 			}
 			
-			return name.IndexOfAny (tspecials) == -1;
+			bool res = true;
+			if (name.IndexOfAny (tspecials) != -1)
+			    res = false;
+			return res;
+
+			//return name.IndexOfAny (tspecials) == -1;
 		}
 
 		private static char [] tspecials = 
Index: mono-1.2.6/mcs/class/corlib/System/Array.cs
===================================================================
--- Array.cs.orig
+++ Array.cs
@@ -199,17 +199,20 @@
 
 		internal struct InternalEnumerator<T> : IEnumerator<T>
 		{
-			const int NOT_STARTED = -2;
+			int NOT_STARTED;
 			
 			// this MUST be -1, because we depend on it in move next.
 			// we just decr the size, so, 0 - 1 == FINISHED
-			const int FINISHED = -1;
+			int FINISHED;
 			
 			Array array;
 			int idx;
 
 			internal InternalEnumerator (Array array)
 			{
+				NOT_STARTED = -2;
+				FINISHED = -1;
+			
 				this.array = array;
 				idx = NOT_STARTED;
 			}
Index: mono-1.2.6/mcs/class/corlib/System.Collections.Generic/List.cs
===================================================================
--- List.cs.orig
+++ List.cs
@@ -167,10 +167,17 @@
 			_size = 0;
 			_version++;
 		}
-		
+
 		public bool Contains (T item)
 		{
-			return Array.IndexOf<T>(_items, item, 0, _size) != -1;
+			
+			int i = Array.IndexOf<T>(_items, item, 0, _size);
+			bool res = true;
+			if (i == -1) {
+			    res = false;
+			}
+			return res;
+			//return Array.IndexOf<T>(_items, item, 0, _size) != -1;
 		}
 		
 		public List <TOutput> ConvertAll <TOutput> (Converter <T, TOutput> converter)
@@ -730,11 +737,11 @@
 				
 		[Serializable]
 		public struct Enumerator : IEnumerator <T>, IDisposable {
-			const int NOT_STARTED = -2;
+			int NOT_STARTED;
 			
 			// this MUST be -1, because we depend on it in move next.
 			// we just decr the size, so, 0 - 1 == FINISHED
-			const int FINISHED = -1;
+			int FINISHED;
 			
 			List <T> l;
 			int idx;
@@ -742,6 +749,8 @@
 			
 			internal Enumerator (List <T> l)
 			{
+				NOT_STARTED = -2;
+				FINISHED = -1;
 				this.l = l;
 				idx = NOT_STARTED;
 				ver = l._version;
