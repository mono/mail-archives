diff --git a/mono/mini/decompose.c b/mono/mini/decompose.c
index ddb2ff0..68cc9d6 100644
--- a/mono/mini/decompose.c
+++ b/mono/mini/decompose.c
@@ -1128,17 +1128,19 @@ mono_decompose_vtype_opts (MonoCompile *cfg)
 						memcpy (call2, call, sizeof (MonoCallInst));
 						switch (ins->opcode) {
 						case OP_VCALL:
-							call2->inst.opcode = OP_CALL;
+							call2->inst.opcode = OP_VOIDCALL;
 							break;
 						case OP_VCALL_REG:
-							call2->inst.opcode = OP_CALL_REG;
+							call2->inst.opcode = OP_VOIDCALL_REG;
 							break;
 						case OP_VCALL_MEMBASE:
-							call2->inst.opcode = OP_CALL_MEMBASE;
+							call2->inst.opcode = OP_VOIDCALL_MEMBASE;
 							break;
 						}
-						call2->inst.dreg = alloc_preg (cfg);
+						call2->inst.dreg = -1;
 						MONO_ADD_INS (cfg->cbb, ((MonoInst*)call2));
+						int dreg = 0;
+						int dreg2 = 2;
 
 						/* Compute the vtype location */
 						dest_var = get_vreg_to_inst (cfg, call->inst.dreg);
@@ -1153,41 +1155,25 @@ mono_decompose_vtype_opts (MonoCompile *cfg)
 							size = mono_type_size (dest_var->inst_vtype, NULL);
 						switch (size) {
 						case 1:
-							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI1_MEMBASE_REG, dest->dreg, 0, call2->inst.dreg);
+							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI1_MEMBASE_REG, dest->dreg, 0, dreg);
 							break;
 						case 2:
-							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI2_MEMBASE_REG, dest->dreg, 0, call2->inst.dreg);
+							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI2_MEMBASE_REG, dest->dreg, 0, dreg);
 							break;
 						case 4:
-							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, dest->dreg, 0, call2->inst.dreg);
+							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, dest->dreg, 0, dreg);
 							break;
 						case 8:
 #if SIZEOF_REGISTER == 4
-							/*
-							FIXME It would be nice to fix the operding of OP_CALL to make it possible to use numbering voodoo
-							FIXME It would be even nicer to be able to leverage the long decompose stuff.
-							*/
-							switch (call2->inst.opcode) {
-							case OP_CALL:
-								call2->inst.opcode = OP_LCALL;
-								break;
-							case OP_CALL_REG:
-								call2->inst.opcode = OP_LCALL_REG;
-								break;
-							case OP_CALL_MEMBASE:
-								call2->inst.opcode = OP_LCALL_MEMBASE;
-								break;
-							}
-							call2->inst.dreg = alloc_lreg (cfg);
-							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, dest->dreg, MINI_MS_WORD_OFFSET, call2->inst.dreg + 2);
-							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, dest->dreg, MINI_LS_WORD_OFFSET, call2->inst.dreg + 1);
+							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, dest->dreg, 0, dreg);
+							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI4_MEMBASE_REG, dest->dreg, 4, dreg2);
 #else
-							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI8_MEMBASE_REG, dest->dreg, 0, call2->inst.dreg);
+							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STOREI8_MEMBASE_REG, dest->dreg, 0, dreg);
 #endif
 							break;
 						default:
 							/* This assumes the vtype is sizeof (gpointer) long */
-							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, dest->dreg, 0, call2->inst.dreg);
+							MONO_EMIT_NEW_STORE_MEMBASE (cfg, OP_STORE_MEMBASE_REG, dest->dreg, 0, dreg);
 							break;
 						}
 					} else {
diff --git a/mono/mini/mini-x86.c b/mono/mini/mini-x86.c
index e226cf4..474e8f0 100644
--- a/mono/mini/mini-x86.c
+++ b/mono/mini/mini-x86.c
@@ -46,6 +46,8 @@ static gboolean is_win32 = TRUE;
 static gboolean is_win32 = FALSE;
 #endif
 
+#define DEBUG_STACK_ALIGNMENT 1
+
 /* This mutex protects architecture specific caches */
 #define mono_mini_arch_lock() EnterCriticalSection (&mini_arch_mutex)
 #define mono_mini_arch_unlock() LeaveCriticalSection (&mini_arch_mutex)
@@ -238,7 +240,6 @@ add_valuetype (MonoGenericSharingContext *gsctx, MonoMethodSignature *sig, ArgIn
 #ifdef SMALL_STRUCTS_IN_REGS
 	if (sig->pinvoke && is_return) {
 		MonoMarshalType *info;
-
 		/*
 		 * the exact rules are not very well documented, the code below seems to work with the 
 		 * code generated by gcc 3.3.3 -mno-cygwin.
@@ -1236,23 +1237,9 @@ mono_arch_emit_call (MonoCompile *cfg, MonoCallInst *call)
 		MonoInst *vtarg;
 
 		if (cinfo->ret.storage == ArgValuetypeInReg) {
-			if (cinfo->ret.pair_storage [0] == ArgInIReg && cinfo->ret.pair_storage [1] == ArgNone) {
-				/*
-				 * Tell the JIT to use a more efficient calling convention: call using
-				 * OP_CALL, compute the result location after the call, and save the 
-				 * result there.
-				 */
-				call->vret_in_reg = TRUE;
-			} else {
-				/*
-				 * The valuetype is in EAX:EDX after the call, needs to be copied to
-				 * the stack. Save the address here, so the call instruction can
-				 * access it.
-				 */
-				MONO_INST_NEW (cfg, vtarg, OP_X86_PUSH);
-				vtarg->sreg1 = call->vret_var->dreg;
-				MONO_ADD_INS (cfg->cbb, vtarg);
-			}
+			call->vret_in_reg = TRUE;
+			if (call->vret_var)
+				NULLIFY_INS (call->vret_var);
 		}
 	}
 