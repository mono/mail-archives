Index: System.Threading/ThreadPool.cs
===================================================================
--- System.Threading/ThreadPool.cs	(revision 44492)
+++ System.Threading/ThreadPool.cs	(working copy)
@@ -32,17 +32,21 @@
 using System.Collections;
 using System.Globalization;
 using System.Runtime.CompilerServices;
+using System.Runtime.Remoting.Messaging;
 using System.Security.Permissions;
 
 namespace System.Threading {
 
+#if NET_2_0
+	public static class ThreadPool {
+#else
 	public sealed class ThreadPool {
 
 		private ThreadPool ()
 		{
 			/* nothing to do */
 		}
-
+#endif
 		public static bool BindHandle (IntPtr osHandle)
 		{
 			return true;
@@ -132,10 +136,12 @@
 		[SecurityPermission (SecurityAction.Demand, ControlEvidence=true, ControlPolicy=true)]
 		public static bool UnsafeQueueUserWorkItem (WaitCallback callback, object state)
 		{
+			// no stack propagation here (that's why it's unsafe and requires extra security permissions)
 			IAsyncResult ar = callback.BeginInvoke (state, null, null);
-			if (ar == null)
-				return false;
-			return true;
+			AsyncResult result = (ar as AsyncResult);
+			if (result != null)
+				result.Unsafe ();
+			return (ar != null);
 		}
 		
 		[MonoTODO]
Index: System.Threading/Thread.cs
===================================================================
--- System.Threading/Thread.cs	(revision 44492)
+++ System.Threading/Thread.cs	(working copy)
@@ -86,6 +86,7 @@
 		private int serialized_culture_info_len;
 		private IntPtr serialized_ui_culture_info;
 		private int serialized_ui_culture_info_len;
+		private ExecutionContext _ec;
 		/* 
 		 * These fields are used to avoid having to increment corlib versions
 		 * when a new field is added to the unmanaged MonoThread structure.
@@ -97,7 +98,6 @@
 		private IntPtr unused5;
 		private IntPtr unused6;
 		private IntPtr unused7;
-		private IntPtr unused8;
 		#endregion
 
 		[ThreadStatic] 
@@ -109,8 +109,6 @@
 		
 		private IPrincipal _principal;
 
-		private ExecutionContext _ec;
-		
 		public static Context CurrentContext {
 			[SecurityPermission (SecurityAction.LinkDemand, Infrastructure=true)]
 			get {
@@ -629,6 +627,17 @@
 		}
 
 		public void Start() {
+			// propagate informations from the original thread to the new thread
+#if NET_2_0
+			if (!ExecutionContext.IsFlowSuppressed ())
+				_ec = ExecutionContext.Capture ();
+#else
+			// before 2.0 this was only used for security (mostly CAS) so we
+			// do this only if the security manager is active
+			if (SecurityManager.SecurityEnabled)
+				_ec = ExecutionContext.Capture ();
+#endif
+
 			// Thread_internal creates and starts the new thread, 
 			if (Thread_internal(threadstart) == (IntPtr) 0)
 				throw new SystemException ("Thread creation failed.");
Index: System.Runtime.Remoting.Messaging/AsyncResult.cs
===================================================================
--- System.Runtime.Remoting.Messaging/AsyncResult.cs	(revision 44492)
+++ System.Runtime.Remoting.Messaging/AsyncResult.cs	(working copy)
@@ -8,11 +8,8 @@
 //   Duncan Mak (duncan@ximian.com)
 //
 // (C) 2001 Ximian, Inc.  http://www.ximian.com
+// Copyright (C) 2004-2005 Novell, Inc (http://www.novell.com)
 //
-
-//
-// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
-//
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
 // "Software"), to deal in the Software without restriction, including
@@ -49,6 +46,10 @@
 	bool completed;
 	bool endinvoke_called;
 	object async_callback;
+	ExecutionContext current;
+	ExecutionContext original;
+
+	// not part of MonoAsyncResult...
 	MonoMethodMessage call_message;
 	IMessageCtrl message_ctrl;
 	IMessage reply_message;
@@ -160,5 +161,11 @@
 		get { return call_message; }
 		set { call_message = value; }
 	}
+
+	internal void Unsafe ()
+	{
+		current = null;
+		original = null;
+	}
 }
 }
