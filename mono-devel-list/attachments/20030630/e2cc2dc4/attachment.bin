using System;
using System.Threading;

public class FractalTest
{
    public static void Main (string[] args)
    {
        const int targetCount = 6000000;
        Display display = new Display();

        Console.WriteLine( display.elapsedTime );

        display.Start();
        do
        {
            Thread.Sleep(500);
            Console.WriteLine( display.Count );
        } while ( display.Count < targetCount  );
        display.Stop();
        Console.WriteLine( "Elapsed time: {0}", display.elapsedTime.ToString() );
        Console.WriteLine( "Rate: {0}", display.Count / display.elapsedTime.TotalSeconds );

    }
}


public class Display: IQuantumFractal
{


    //Engine controller variables
    int[] topDensity = new int[0];
    int[] bottomDensity = new int[0];
    int resolution = 400;
    int scale = 1;
    double centerX = 0;
    double centerY = 0;
    int i = 0;
    bool Grayscale = true;
    bool Intense = false;


    DateTime startTime;
    DateTime endTime;
    public TimeSpan elapsedTime;


    //The engine
    QuantumFractals qf;
    Thread engine;

    public Display ()
    {
        qf = new QuantumFractals (this);
    }


    public int Count
    {
        get { return i; }
    }


    //This is where the controller receives data from the engine
    public void UpdateData (double[] d)
    {
        i++; //Keep track of the number of points

        //Set the density arrays to match the resolution
        if (resolution * resolution != topDensity.Length) {
            topDensity = new int[resolution * resolution];
            bottomDensity = new int[resolution * resolution];
        }

        //setup the sphere
        int res = resolution;
        int res2 = res / 2;
        int x = res / 2 + (int)(res2 * scale * (d[0] - centerX));
        int y = res / 2 + (int)(res2 * scale * (d[1] - centerY));
        double z = d[2];

        if ((x < res) && (x >= 0) && (y >= 0) && (y < res)) {

            if (z >= 0)
                topDensity[y * resolution + x]++;
            else
                bottomDensity[y * resolution + x]++;

        }

        //Convert the density into a color
        int top = topDensity[y * resolution + x];
        //int bot = bottomDensity[y * resolution + x];
        top = Math.Min (top, 255);
        //bot = Math.Min (bot, 255);

        //Log color system not working well :(
        if (Intense) {
            top = (int)(Math.Log (top + 1));
            //bot = (int)(Math.Log (bot + 1));
        }

        int topdepth = RGB (top,top,top);
        //int botdepth = RGB (bot,bot,bot);

        //Finally draw the pixel
        SetPixel (x, y, topdepth);
        //SetPixel (x, y, botdepth);
    }

    //Calls the drawable
    public void SetPixel (int x, int y, int depth)
    {
        //Console.WriteLine("PaintPixel( {0}, {1}, {2} )", x, y, depth );
        //buffer.PaintPixel (x, y, depth);
    }

    //Convert the color into a depth
    public int RGB (int r, int g, int b)
    {
        if (!Grayscale) {

            r = Intensity (r < 128 ? 128 - r : 0);
            g = Intensity (128 - Math.Abs (g - 128));
            b = Intensity (b < 128 ? 0 : b - 128);

        } else {

            r = Intensity (r);
            g = Intensity (g);
            b = Intensity (b);

        }
            //Console.WriteLine ("{0} {1} {2}", r,g,b);
        return 256 * 256 * r + 256 * g + b;
    }

    //This provides more detail
    private int Intensity(int val)
    {
        int ret;

        double bases = 64;
        double scale = 256.0 / (256.0 - bases);
        ret = (int)(bases + ((double)val) / scale);

        //if gray then black, if color then white
        if (val == 0 && Grayscale)
            ret = 0;
        else if (val == 0)
            ret = 255;
        return ret;
    }



    //Start the engine
    public void Start ()
    {
        startTime = DateTime.Now;
        engine = new Thread(new ThreadStart(qf.Start));
        engine.Start ();
    }

    //Stop the engine
    public void Stop ()
    {
        if (engine != null)
            if (engine.IsAlive)
                engine.Abort ();

        endTime = DateTime.Now;

        elapsedTime = endTime - startTime;
    }


    //Reset the drawable
    private void ResetBuffer ()
    {
        i = 0;
        topDensity = new int[0];
        bottomDensity = new int[0];
    }
 }



public interface IQuantumFractal
{

    void UpdateData (Double [] data);
}



//Polytope types
public enum Shapes {
    TETRAHEDRON = 0,
    CUBE = 1,
    OCTAHEDRON = 2,
    ICOSAHEDRON = 3,
    DODECAHEDRON = 4,
    DOUBLE_TETRAHEDRON = 5,
    ICOSIDODECAHEDRON = 6
}

public class QuantumFractals
{

    private int t = 0;
    private double[] p; //Detector probabilities
    private double[] fp; //Fractal point
    private double[][] n; //Detector points
    private double[] counter; //Detect counter
    private double alpha = 0.61803398874989288039384209090709; //Initialize to 1/phi

    private Random random;
    private Shapes polytope;
    private IQuantumFractal consumer;

    public QuantumFractals (IQuantumFractal consumer)
    {
        this.consumer = consumer;
        SetPolytope (0);
        Init ();
    }

    public double Alpha
    {
        get { return alpha; }
        set { alpha = value; }
    }

    private void Init ()
    {
        random = new Random ();

        //Default values
        t = 0;

        counter = new double[n.Length]; //Detect counter
        fp = new double[3]; //Fractal point
        p = new double[n.Length];

        //Initial state
        fp[0] = random.NextDouble () -0.5;
        fp[1] = random.NextDouble () -0.5;
        fp[2] = random.NextDouble () -0.5;

        double sum = Math.Sqrt (Product (fp, fp));

        fp[0] = fp[0] / sum;
        fp[1] = fp[1] / sum;
        fp[2] = fp[2] / sum;
    }

    //Main fractal generator loop
    public void Start ()
    {
        Init ();

        //double n1 = (1.0) / n.Length as double;
        double n1 = (1.0) / n.Length;

        double alpha12 = 2 * alpha / (n.Length * (1 + alpha * alpha));

        do {
            //Increase t
            t++;

            //Calculate detector click probabilities
            for (int i = 0; i < p.Length; i++)
                p[i] = n1 + alpha12 * Product (n[i], fp);

            //Get next random number
            double r = random.NextDouble ();

            //Check which detector that clicked
            double ptmp = 0;
            double[] detector = null;

            for (int i = 0; i < p.Length; i++) {

                ptmp += p[i];

                if (r <= ptmp) {
                    //We found which detector clicked
                    detector = n[i];
                    counter[i]++;
                    break;
                }
            }

            if (detector == null)
                detector = n[p.Length - 1];

            //Project
            double sc = Product (fp, detector);

            for (int j = 0; j < 3; j++)
                fp[j]= (1 - alpha * alpha) * fp[j] + 2 * alpha * (1 + alpha * sc) * detector[j];

            //Normalize
            double norm = Math.Sqrt (Product (fp, fp));

            for (int j=0; j<3; j++)
                fp[j] /= norm;

            consumer.UpdateData (fp);

        } while (true);
    }


    //Calculate the scalar product of two vectors
    private double Product (double[] v1, double[] v2)
    {
        double sc = 0;
            for(int i=0; i < v1.Length; i++)
            sc += v1[i] * v2[i];
        return sc;
    }


    public void SetPolytope (int type)
    {
        polytope = (Shapes)type;

        switch (type) {

            case 0: {

                n = new double[4][];
                n[0] =    new double[] {0,0,1.0};
                n[1] =    new double[] {0.9428090415820634,0,-0.3333333333333333};
                n[2] =    new double[] {-0.4714045207910317,0.816496580927726,-0.3333333333333333};
                n[3] =    new double[] {-0.4714045207910317, -0.816496580927726, -0.3333333333333333};

                break;
            }


        }
    }
}

