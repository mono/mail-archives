? mono-streq-native-code.patch
? benchmark/t
? benchmark/tt
? metadata/t
? mini/.hidden
? mini/cmov.patch
? mini/curpatch.patch
? mini/min-max.patch
? mini/roarr.patch
? mini/t
? mini/t.cs
? mini/tt.cs
Index: arch/ChangeLog
===================================================================
RCS file: /cvs/public/mono/mono/arch/ChangeLog,v
retrieving revision 1.99
diff -u -r1.99 ChangeLog
--- arch/ChangeLog	8 May 2004 01:03:25 -0000	1.99
+++ arch/ChangeLog	21 May 2004 21:26:00 -0000
@@ -1,3 +1,9 @@
+2004-05-21 Ben Maurer  <bmaurer@users.sourceforge.net>
+
+	* x86/x86-codegen.h (x86_alu_reg_memindex): <alu op> reg, [base+index+disp]
+	(x86_padding): Make this work for any number of bytes
+	(x86_align): Align code to a specific number of bytes.
+
 2004-05-07  Bernie Solomon  <bernard@ugsolutions.com>
 
 	* ppc/ppc-codegen.h: remove GCC-ism in ppc_emit32
Index: arch/x86/x86-codegen.h
===================================================================
RCS file: /cvs/public/mono/mono/arch/x86/x86-codegen.h,v
retrieving revision 1.39
diff -u -r1.39 x86-codegen.h
--- arch/x86/x86-codegen.h	25 Jun 2003 13:18:00 -0000	1.39
+++ arch/x86/x86-codegen.h	21 May 2004 21:26:00 -0000
@@ -574,6 +574,12 @@
 		x86_membase_emit ((inst), (reg), (basereg), (disp));	\
 	} while (0)
 
+#define x86_alu_reg_memindex(inst,opc,reg,basereg,disp,indexreg,shift)	\
+	do {	\
+		*(inst)++ = (((unsigned char)(opc)) << 3) + 3;	\
+		x86_memindex_emit ((inst), (reg), (basereg), (disp), (indexreg), (shift)); \
+	} while (0)
+
 #define x86_test_reg_imm(inst,reg,imm)	\
 	do {	\
 		if ((reg) == X86_EAX) {	\
@@ -1600,7 +1606,9 @@
 
 #define x86_padding(inst,size)	\
 	do {	\
-		switch ((size)) {	\
+	int _size = (size); \
+	while (_size) { \
+		switch (_size) {	\
 		case 1: x86_nop ((inst)); break;	\
 		case 2: *(inst)++ = 0x8b;	\
 			*(inst)++ = 0xc0; break;	\
@@ -1616,13 +1624,16 @@
 			*(inst)++ = 0x00; *(inst)++ = 0x00;	\
 			*(inst)++ = 0x00; *(inst)++ = 0x00;	\
 			break;	\
-		case 7: *(inst)++ = 0x8d; *(inst)++ = 0xa4;	\
+		default: *(inst)++ = 0x8d; *(inst)++ = 0xa4;	\
 			*(inst)++ = 0x24; *(inst)++ = 0x00;	\
 			*(inst)++ = 0x00; *(inst)++ = 0x00;	\
 			*(inst)++ = 0x00; break;	\
-		default: assert (0);	\
 		}	\
+		_size -= MIN (_size, 7); \
+	} \
 	} while (0)
+
+#define x86_align(inst,mod) x86_padding (inst, (mod) - ((int)(inst) % (mod)))
 
 #define x86_prolog(inst,frame_size,reg_mask)	\
 	do {	\
Index: mini/ChangeLog
===================================================================
RCS file: /cvs/public/mono/mono/mini/ChangeLog,v
retrieving revision 1.535
diff -u -r1.535 ChangeLog
--- mini/ChangeLog	21 May 2004 17:22:56 -0000	1.535
+++ mini/ChangeLog	21 May 2004 21:26:02 -0000
@@ -1,3 +1,13 @@
+2004-05-21 Ben Maurer  <bmaurer@users.sourceforge.net>
+
+	* mini.h (mono_arch_precomp_method): new method
+	Each arch can provide precompiled code for a specific method
+	by returning a MonoJitInfo* for that method from this.
+	* mini-*.c: Implement stubs for the above method.
+	* mini.c: Call this new method.
+	* mini-x86.c (get_streq_precomp): Return a MonoJitInfo* for
+	String.Equals.
+
 2004-05-21  Zoltan Varga  <vargaz@freemail.hu>
 
 	* mini-sparc.c exceptions-sparc.c: Applied patch from Mark Crichton
Index: mini/mini-ppc.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-ppc.c,v
retrieving revision 1.64
diff -u -r1.64 mini-ppc.c
--- mini/mini-ppc.c	11 May 2004 13:51:39 -0000	1.64
+++ mini/mini-ppc.c	21 May 2004 21:26:04 -0000
@@ -3741,3 +3741,9 @@
 {
 	return 0;
 }
+
+MonoJitInfo *
+mono_arch_precomp_method (MonoMethod *method)
+{
+	return NULL;
+}
Index: mini/mini-s390.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-s390.c,v
retrieving revision 1.5
diff -u -r1.5 mini-s390.c
--- mini/mini-s390.c	7 May 2004 19:53:40 -0000	1.5
+++ mini/mini-s390.c	21 May 2004 21:26:04 -0000
@@ -4721,3 +4721,9 @@
 }
 
 /*========================= End of Function ========================*/
+
+MonoJitInfo *
+mono_arch_precomp_method (MonoMethod *method)
+{
+	return NULL;
+}
Index: mini/mini-sparc.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-sparc.c,v
retrieving revision 1.36
diff -u -r1.36 mini-sparc.c
--- mini/mini-sparc.c	7 May 2004 13:29:50 -0000	1.36
+++ mini/mini-sparc.c	21 May 2004 21:26:05 -0000
@@ -3919,3 +3919,9 @@
 {
 	return 0;
 }
+
+MonoJitInfo *
+mono_arch_precomp_method (MonoMethod *method)
+{
+	return NULL;
+}
Index: mini/mini-x86.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini-x86.c,v
retrieving revision 1.94
diff -u -r1.94 mini-x86.c
--- mini/mini-x86.c	13 May 2004 13:52:01 -0000	1.94
+++ mini/mini-x86.c	21 May 2004 21:26:05 -0000
@@ -3742,3 +3742,141 @@
 {
 	return 0;
 }
+
+static MonoJitInfo *
+get_streq_precomp (MonoMethod *method)
+{
+	static MonoJitInfo jinfo = {0, };
+	static guint8 start [128];
+	guint8 *patch [10];
+	guint8 *code = start, *patch_ret_true, *patch_ret_false;
+	guint8 *patch_loop_test, *patch_loop_begin, *patch_leave;
+	
+	if (jinfo.code_start)
+		return & jinfo;
+	
+	mono_domain_lock (mono_root_domain);
+	
+	jinfo.method = method;
+	jinfo.code_start = start;
+	jinfo.domain_neutral = TRUE;
+	jinfo.used_regs = X86_EBX;
+	
+	x86_push_reg (code, X86_EBP);
+	x86_mov_reg_reg (code, X86_EBP, X86_ESP, 4);
+	x86_push_reg (code, X86_EBX);
+	
+	/* eax = a; edx = b */
+	x86_mov_reg_membase (code, X86_EAX, X86_EBP, 8, 4);
+	x86_mov_reg_membase (code, X86_EDX, X86_EBP, 12, 4);
+	
+	/* if (a == b) return true; */
+	x86_alu_reg_reg (code, X86_CMP, X86_EAX, X86_EDX);
+	patch [0] = code;
+	x86_branch8 (code, X86_CC_EQ, 0, FALSE);
+	
+	/* if (!a) return false; */
+	x86_test_reg_reg (code, X86_EAX, X86_EAX);
+	patch [1] = code;
+	x86_branch8 (code, X86_CC_Z, 0, FALSE);
+	
+	/* if (!b) return false; */
+	x86_test_reg_reg (code, X86_EDX, X86_EDX);
+	patch [2] = code;
+	x86_branch8 (code, X86_CC_Z, 0, FALSE);
+	
+	/* ecx = a.Length */
+	x86_mov_reg_membase (code, X86_ECX, X86_EAX, G_STRUCT_OFFSET (MonoString, length), 4);
+	
+	/* if (b.Length != ecx) return false */
+	x86_alu_reg_membase (code, X86_CMP, X86_ECX, X86_EDX, G_STRUCT_OFFSET (MonoString, length));
+	patch [3] = code;
+	x86_branch8 (code, X86_CC_NE, 0, FALSE);
+	
+	
+	/* if (ecx & 1) (test last char); ecx >>= 1 */
+	x86_shift_reg_imm (code, X86_SHR, X86_ECX, 1);
+	patch [4] = code;
+	x86_branch8 (code, X86_CC_NC, 0, FALSE);
+	
+	/* if (a [len - 1] != b [len - 1]) return false; */
+	x86_mov_reg_memindex (code, X86_EBX, X86_EAX, G_STRUCT_OFFSET (MonoString, chars), X86_ECX, 2, 2);
+	x86_prefix (code, X86_OPERAND_PREFIX);
+	x86_alu_reg_memindex (code, X86_CMP, X86_EBX, X86_EDX, G_STRUCT_OFFSET (MonoString, chars), X86_ECX, 2);
+	patch [5] = code;
+	x86_branch8 (code, X86_CC_NE, 0, FALSE);
+	
+	patch [6] = code;
+	x86_jump8 (code, 0);
+	
+	x86_align (code, 16);
+	patch_loop_begin = code;
+	
+	/* if (a [ecx] != b [ecx]) return false; */
+	x86_mov_reg_memindex (code, X86_EBX, X86_EAX, G_STRUCT_OFFSET (MonoString, chars), X86_ECX, 2, 4);
+	x86_alu_reg_memindex (code, X86_CMP, X86_EBX, X86_EDX, G_STRUCT_OFFSET (MonoString, chars), X86_ECX, 2);
+	patch [7] = code;
+	x86_branch8 (code, X86_CC_NE, 0, FALSE);
+	
+	patch_loop_test = code;
+	
+	x86_dec_reg (code, X86_ECX);
+	patch [8] = code;
+	x86_branch8 (code, X86_CC_GEZ, 0, FALSE);
+	
+	patch_ret_true = code;
+	
+	x86_mov_reg_imm (code, X86_EAX, 1);
+	patch [9] = code;
+	x86_jump8 (code, 0);
+	
+	patch_ret_false = code;
+	
+	x86_clear_reg (code, X86_EAX);
+	
+	patch_leave = code;
+	
+	x86_lea_membase (code, X86_ESP, X86_EBP, -4);
+	x86_pop_reg (code, X86_EBX);
+	x86_leave (code);
+	x86_ret (code);
+	
+	x86_patch (patch [0], patch_ret_true);
+	x86_patch (patch [1], patch_ret_false);
+	x86_patch (patch [2], patch_ret_false);
+	x86_patch (patch [3], patch_ret_false);
+	x86_patch (patch [4], patch_loop_test);
+	x86_patch (patch [5], patch_ret_false);
+	x86_patch (patch [6], patch_loop_test);
+	x86_patch (patch [7], patch_ret_false);
+	x86_patch (patch [8], patch_loop_begin);
+	x86_patch (patch [9], patch_leave);
+	
+	jinfo.code_size = code - start;
+	
+	g_assert (jinfo.code_size < sizeof (start));
+	
+	if (0) {
+		char *id =  mono_method_full_name (method, FALSE);
+		mono_disassemble_code (start, jinfo.code_size, id + 3);
+		g_free (id);
+	}
+	
+	mono_jit_info_table_add (mono_root_domain, & jinfo);
+	mono_domain_unlock (mono_root_domain);
+	
+	return & jinfo;
+}
+
+
+MonoJitInfo *
+mono_arch_precomp_method (MonoMethod *method)
+{
+	if (method->klass == mono_defaults.string_class) {
+		if (!strcmp (method->name, "Equals") && method->signature->param_count == 2 && method->signature->params [0]->type == MONO_TYPE_STRING) {
+			return get_streq_precomp (method);
+		}
+	}
+	
+	return NULL;
+}
Index: mini/mini.c
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini.c,v
retrieving revision 1.236
diff -u -r1.236 mini.c
--- mini/mini.c	14 May 2004 22:05:06 -0000	1.236
+++ mini/mini.c	21 May 2004 21:26:07 -0000
@@ -8101,6 +8101,11 @@
 		target_domain = mono_root_domain;
 	else 
 		target_domain = domain;
+	
+	if (default_opt & MONO_OPT_INTRINS && (info = mono_arch_precomp_method (method))) {
+		mono_jit_stats.methods_lookups++;
+		return info->code_start;
+	}
 
 	mono_domain_lock (target_domain);
 
Index: mini/mini.h
===================================================================
RCS file: /cvs/public/mono/mono/mini/mini.h,v
retrieving revision 1.67
diff -u -r1.67 mini.h
--- mini/mini.h	14 May 2004 10:30:10 -0000	1.67
+++ mini/mini.h	21 May 2004 21:26:07 -0000
@@ -729,6 +729,7 @@
 gpointer  mono_arch_get_throw_exception_by_name (void);
 gpointer  mono_arch_create_jit_trampoline       (MonoMethod *method);
 MonoJitInfo *mono_arch_create_jump_trampoline      (MonoMethod *method);
+MonoJitInfo *mono_arch_precomp_method		(MonoMethod *method);
 gpointer  mono_arch_create_class_init_trampoline(MonoVTable *vtable);
 GList    *mono_arch_get_allocatable_int_vars    (MonoCompile *cfg);
 GList    *mono_arch_get_global_int_regs         (MonoCompile *cfg);
