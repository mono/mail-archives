Index: System.Web/HttpContext.cs
===================================================================
--- System.Web/HttpContext.cs	(revision 70421)
+++ System.Web/HttpContext.cs	(working copy)
@@ -43,8 +43,10 @@
 using System.Web.Util;
 #if NET_2_0
 using System.Collections.Generic;
+using System.IO;
 using System.Reflection;
 using System.Resources;
+using System.Web.Compilation;
 using System.Web.Profile;
 using CustomErrorMode = System.Web.Configuration.CustomErrorsMode;
 #endif
@@ -71,6 +73,7 @@
 		int timeout_possible;
 		DateTime time_stamp = DateTime.UtcNow;
 #if NET_2_0
+		internal static Assembly AppGlobalResourcesAssembly;
 		ProfileBase profile = null;
 		LinkedList<IHttpHandler> handlers;
 #endif
@@ -280,7 +283,7 @@
 			}
 		}
 
-#if NET_2_0
+#if NET_2_0		
 		internal void PushHandler (IHttpHandler handler)
 		{
 			if (handler == null)
@@ -390,79 +393,48 @@
 		}
 
 #if NET_2_0
-		internal static Type GetGLResourceType (string typeName)
+		static object GetResourceObject (string classKey, string resourceKey, CultureInfo culture, Assembly assembly)
 		{
-			Type type = null;
-			Assembly [] assemblies = AppDomain.CurrentDomain.GetAssemblies ();
-
-			foreach (Assembly ass in assemblies) {
-				type = ass.GetType (typeName);
-				if (type == null)
-					continue;
-
-				return type;
-			}
-
-			throw new MissingManifestResourceException (String.Format ("Missing resource class {0}", typeName));
-		}
-
-		internal static object GetGLResourceObject (Type type, string resourceKey)
-		{
-			object ret = null;
+			ResourceManager rm;
 			try {
-				PropertyInfo pi = type.GetProperty (resourceKey,
-								    BindingFlags.GetProperty |
-								    BindingFlags.Public |
-								    BindingFlags.Static);
-				if (pi == null)
-					return null;
-				ret = pi.GetValue (null, null);
-			} catch {
+				rm = new ResourceManager (classKey, assembly);
+				return rm.GetObject (resourceKey, culture);
+			} catch (MissingManifestResourceException) {
+				throw;
+			} catch (Exception ex) {
+				throw new HttpException ("Failed to retrieve the specified global resource object.", ex);
 			}
-			
-			return ret;
 		}
-
-		internal static void SetGLResourceObjectCulture (Type type, CultureInfo ci)
-		{
-			try {
-				PropertyInfo pi = type.GetProperty ("Culture",
-								    BindingFlags.SetProperty |
-								    BindingFlags.Public |
-								    BindingFlags.Static);
-				if (pi == null)
-					return; // internal error actually...
-				pi.SetValue (null, ci, null);
-			} catch {
-			}
-		}
 		
 		public static object GetGlobalResourceObject (string classKey, string resourceKey)
 		{
-			string className = String.Format ("System.Resources.{0}", classKey);
-			Type type = GetGLResourceType (className);
-			SetGLResourceObjectCulture (type, null);
-			return GetGLResourceObject (type, resourceKey);
+			return GetGlobalResourceObject (classKey, resourceKey, Thread.CurrentThread.CurrentUICulture);
 		}
 
 		public static object GetGlobalResourceObject (string classKey, string resourceKey, CultureInfo culture)
 		{
-			string className = String.Format ("System.Resources.{0}", classKey);
-			Type type = GetGLResourceType (className);
-			SetGLResourceObjectCulture (type, culture);
-			return GetGLResourceObject (type, resourceKey);
+			HttpContext context = HttpContext.Current;
+			if (AppGlobalResourcesAssembly == null)
+				throw new MissingManifestResourceException ();
+			return GetResourceObject (classKey, resourceKey, culture, AppGlobalResourcesAssembly);
 		}
 
-		[MonoTODO ("Not implemented")]
 		public static object GetLocalResourceObject (string virtualPath, string resourceKey)
 		{
-			throw new NotImplementedException ();
+			return GetLocalResourceObject (virtualPath, resourceKey, Thread.CurrentThread.CurrentUICulture);
 		}
 
-		[MonoTODO ("Not implemented")]
 		public static object GetLocalResourceObject (string virtualPath, string resourceKey, CultureInfo culture)
 		{
-			throw new NotImplementedException ();
+			if (!VirtualPathUtility.IsAbsolute (virtualPath))
+				throw new ArgumentException ("The specified virtualPath was not rooted.");
+			
+			string path = Path.GetDirectoryName (virtualPath);
+			Assembly asm = AppResourcesCompiler.GetCachedLocalResourcesAssembly (path);
+			if (asm == null)
+				throw new MissingManifestResourceException ("A resource object was not found at the specified virtualPath.");
+			path = Path.GetFileName (virtualPath);
+			return GetResourceObject (path, resourceKey, culture, asm);
 		}
 
 		public object GetSection (string name)
Index: System.Web/HttpRuntime.cs
===================================================================
--- System.Web/HttpRuntime.cs	(revision 70421)
+++ System.Web/HttpRuntime.cs	(working copy)
@@ -264,8 +264,8 @@
 				//
 				// Compile the local resources, if any
 				//
-				AppLocalResourcesCompiler alrc = new AppLocalResourcesCompiler();
-				alrc.Compile();
+				AppResourcesCompiler ac = new AppResourcesCompiler (context, false);
+				ac.Compile ();
 #endif
 				
 				//
Index: System.Web/HttpApplicationFactory.cs
===================================================================
--- System.Web/HttpApplicationFactory.cs	(revision 70421)
+++ System.Web/HttpApplicationFactory.cs	(working copy)
@@ -390,8 +390,8 @@
 #endif
 		
 #if NET_2_0 && !TARGET_J2EE
-				AppGlobalResourcesCompiler agrc = new AppGlobalResourcesCompiler();
-				agrc.Compile();
+				AppResourcesCompiler ac = new AppResourcesCompiler (context, true);
+				ac.Compile ();
 				
 				// Todo: Process App_WebResources here
 				
Index: System.Web.dll.sources
===================================================================
--- System.Web.dll.sources	(revision 70421)
+++ System.Web.dll.sources	(working copy)
@@ -18,8 +18,9 @@
 System.Web.Compilation/AppSettingsExpressionBuilder.cs
 System.Web.Compilation/AspComponentFoundry.cs
 System.Web.Compilation/AppCodeCompiler.cs
+System.Web.Compilation/AppResourceFileInfo.cs
+System.Web.Compilation/AppResourceFilesCollection.cs
 System.Web.Compilation/AppResourcesCompiler.cs
-System.Web.Compilation/AppResourceFilesCompiler.cs
 System.Web.Compilation/AspGenerator.cs
 System.Web.Compilation/AspParser.cs
 System.Web.Compilation/AspTokenizer.cs
Index: System.Web.Compilation/AppResourcesCompiler.cs
===================================================================
--- System.Web.Compilation/AppResourcesCompiler.cs	(revision 70421)
+++ System.Web.Compilation/AppResourcesCompiler.cs	(working copy)
@@ -1,5 +1,5 @@
 //
-// System.Web.Compilation.AppResourcesCompiler: Support for compilation of .resx files into a satellite assembly
+// System.Web.Compilation.AppResourceFilesCollection
 //
 // Authors:
 //   Marek Habersack (grendello@gmail.com)
@@ -31,138 +31,556 @@
 using System;
 using System.CodeDom;
 using System.CodeDom.Compiler;
+using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
 using System.IO;
+using System.Reflection;
+using System.Resources;
 using System.Web;
+using System.Web.Caching;
 using System.Web.Configuration;
+using System.Web.Util;
 
-namespace System.Web.Compilation
+namespace System.Web.Compilation 
 {
-	internal abstract class AppResourcesCompiler: AppResourceFilesCompiler
+	internal class AppResourcesCompiler
 	{
-		protected string resourceDirName = null;
-    
-		public AppResourcesCompiler ()
-			: base ()
-		{}
-    
-		public AppResourcesCompiler (string [] filePaths)
-			: base (filePaths)
-		{}
+		const string cachePrefix = "@@LocalResourcesAssemblies";
+		
+		bool isGlobal;
+		HttpContext context;
+		AppResourceFilesCollection files;
+		string tempDirectory;
+		
+		string TempDirectory {
+			get {
+				if (tempDirectory != null)
+					return tempDirectory;
+				return (tempDirectory = AppDomain.CurrentDomain.SetupInformation.DynamicBase);
+			}
+		}
+		
+		public AppResourcesCompiler (HttpContext context, bool isGlobal)
+		{
+			this.context = context;
+			this.isGlobal = isGlobal;
+			this.files = new AppResourceFilesCollection (context, isGlobal);
+		}
 
-		public AppResourcesCompiler (string [] filePaths, FcCodeGenerator fg)
-			: base (filePaths, fg)
-		{}
-    
-		public string DynamicDirectory {
-			get { return AppDomain.CurrentDomain.DynamicDirectory; }
+		
+		public void Compile ()
+		{
+			files.Collect ();
+			if (!files.HasFiles)
+				return;
+			if (isGlobal)
+				CompileGlobal ();
+			else
+				CompileLocal ();
 		}
 
-		public string ResourceDirectory {
-			get {
-				if (resourceDirName == null)
-					return null;
-				string dir = Path.Combine (TopPath, resourceDirName);
-				if (!Directory.Exists (dir))
-					return null;
-				return dir;
+		void CompileGlobal ()
+		{
+			string assemblyPath = FileUtils.CreateTemporaryFile (TempDirectory,
+									     "App_GlobalResources",
+									     "dll",
+									     OnCreateRandomFile) as string;
+			if (assemblyPath == null)
+				throw new ApplicationException ("Failed to create global resources assembly");
+			
+			CompilationSection config = WebConfigurationManager.GetSection ("system.web/compilation") as CompilationSection;
+			if (config == null || !CodeDomProvider.IsDefinedLanguage (config.DefaultLanguage))
+				throw new ApplicationException ("Could not get the default compiler.");
+			CompilerInfo ci = CodeDomProvider.GetCompilerInfo (config.DefaultLanguage);
+			if (ci == null || !ci.IsCodeDomProviderTypeValid)
+				throw new ApplicationException ("Failed to obtain the default compiler information.");
+
+			CompilerParameters cp = ci.CreateDefaultCompilerParameters ();
+			cp.OutputAssembly = assemblyPath;
+			cp.GenerateExecutable = false;
+			cp.TreatWarningsAsErrors = true;
+			cp.IncludeDebugInformation = config.Debug;
+			
+			List <string>[] fileGroups = GroupGlobalFiles (cp);
+			if (fileGroups == null || fileGroups.Length == 0)
+				return;
+
+			CodeCompileUnit unit = new CodeCompileUnit ();
+			CodeNamespace ns = new CodeNamespace (null);
+			ns.Imports.Add (new CodeNamespaceImport ("System"));
+			ns.Imports.Add (new CodeNamespaceImport ("System.Globalization"));
+			ns.Imports.Add (new CodeNamespaceImport ("System.Reflection"));
+			ns.Imports.Add (new CodeNamespaceImport ("System.Resources"));
+			unit.Namespaces.Add (ns);
+
+			CodeDomProvider provider;
+			provider = ci.CreateProvider ();
+			if (provider == null)
+				throw new ApplicationException ("Failed to instantiate the default compiler.");
+			
+			Dictionary <string,bool> assemblies = new Dictionary<string,bool> ();
+			foreach (List<string> ls in fileGroups)
+				DomFromResource (ls [0], unit, assemblies, provider);
+			foreach (KeyValuePair<string,bool> de in assemblies)
+				unit.ReferencedAssemblies.Add (de.Key);
+			
+			AssemblyBuilder abuilder = new AssemblyBuilder (provider);
+			abuilder.AddCodeCompileUnit (unit);
+
+			CompilerResults results = abuilder.BuildAssembly (cp);
+			if (results.Errors.Count == 0) {
+				BuildManager.TopLevelAssemblies.Add (results.CompiledAssembly);
+				HttpContext.AppGlobalResourcesAssembly = results.CompiledAssembly;
+			} else {
+				if (context.IsCustomErrorEnabled)
+					throw new ApplicationException ("An error occurred while compiling global resources.");
+				throw new CompilationException (null, results.Errors, null);
 			}
 		}
-    
-		public bool CompilationPossible {
-			get { return (ResourceDirectory != null); }
+
+		void CompileLocal ()
+		{
+			string path = Path.GetDirectoryName (VirtualPathUtility.ToAbsolute (context.Request.CurrentExecutionFilePath));
+			
+			if (String.IsNullOrEmpty (path))
+				throw new ApplicationException ("Unable to determine the request virtual path.");
+
+			Assembly cached = GetCachedLocalResourcesAssembly (path);
+			if (cached != null)
+				return;
+			
+			string prefix;
+			if (path == "/")
+				prefix = "App_LocalResources.root";
+			else
+				prefix = "App_LocalResources" + path.Replace ('/', '.');
+			
+			string assemblyPath = FileUtils.CreateTemporaryFile (TempDirectory,
+									     prefix,
+									     "dll",
+									     OnCreateRandomFile) as string;
+			if (assemblyPath == null)
+				throw new ApplicationException ("Failed to create global resources assembly");
+			
+			CompilationSection config = WebConfigurationManager.GetSection ("system.web/compilation") as CompilationSection;
+			if (config == null || !CodeDomProvider.IsDefinedLanguage (config.DefaultLanguage))
+				throw new ApplicationException ("Could not get the default compiler.");
+			CompilerInfo ci = CodeDomProvider.GetCompilerInfo (config.DefaultLanguage);
+			if (ci == null || !ci.IsCodeDomProviderTypeValid)
+				throw new ApplicationException ("Failed to obtain the default compiler information.");
+
+			CompilerParameters cp = ci.CreateDefaultCompilerParameters ();
+			cp.OutputAssembly = assemblyPath;
+			cp.GenerateExecutable = false;
+			cp.TreatWarningsAsErrors = true;
+			cp.IncludeDebugInformation = config.Debug;
+
+			List<AppResourceFileInfo> files = this.files.Files;
+			foreach (AppResourceFileInfo arfi in files)
+				GetResourceFile (arfi, cp);
+
+			CodeDomProvider provider;
+			provider = ci.CreateProvider ();
+			if (provider == null)
+				throw new ApplicationException ("Failed to instantiate the default compiler.");
+			
+			AssemblyBuilder abuilder = new AssemblyBuilder (provider);
+			CompilerResults results = abuilder.BuildAssembly (cp);
+			if (results.Errors.Count == 0) {
+				AddAssemblyToCache (path, results.CompiledAssembly);
+			} else {
+				if (context.IsCustomErrorEnabled)
+					throw new ApplicationException ("An error occurred while compiling global resources.");
+				throw new CompilationException (null, results.Errors, null);
+			}
 		}
 
-		public abstract string TopPath {
-			get;
-		}
-    
-		virtual public CompilerResults Compile ()
+		internal static Assembly GetCachedLocalResourcesAssembly (string path)
 		{
-			string dir = ResourceDirectory;
-      
-			if (dir == null)
-				return null;
+			Dictionary <string, Assembly> cache;
 
-			DirectoryInfo di = new DirectoryInfo (dir);
-			if (di == null)
+			cache = HttpRuntime.Cache[cachePrefix] as Dictionary <string, Assembly>;
+			if (cache == null || !cache.ContainsKey (path))
 				return null;
+			return cache [path];
+		}
 
-			FileInfo[] fileinfos = di.GetFiles ("*.resx");
-			if (fileinfos != null && fileinfos.Length > 0) {
-				List<string> al = new List<string> (fileinfos.Length);
-				foreach (FileInfo fi in fileinfos)
-					al.Add (fi.FullName);
-				filePaths = al.ToArray ();
-			} else
-				return null;
+		void AddAssemblyToCache (string path, Assembly asm)
+		{
+			Cache runtimeCache = HttpRuntime.Cache;
+			Dictionary <string, Assembly> cache;
 			
-			CodeCompileUnit unit = FilesToDom ();
-			if (unit == null || resourceFiles == null)
-				return null;
+			cache = runtimeCache[cachePrefix] as Dictionary <string, Assembly>;
+			if (cache == null)
+				cache = new Dictionary <string, Assembly> ();
+			cache [path] = asm;
+			runtimeCache.Insert (cachePrefix, cache);
+		}
+		
+		uint CountChars (char c, string s)
+		{
+			uint ret = 0;
+			foreach (char ch in s) {
+				if (ch == c)
+					ret++;
+			}
+			return ret;
+		}
 
-			CompilerParameters cp = new CompilerParameters ();
-			foreach (string rf in resourceFiles)
-				cp.EmbeddedResources.Add (rf);
-			cp.IncludeDebugInformation = false;
-			cp.GenerateExecutable = false;
-			cp.TreatWarningsAsErrors = false;
-			cp.OutputAssembly = GenRandomFileName (TempDir, "dll");
+		bool IsFileCultureValid (string fileName)
+                {
+                    string tmp = Path.GetFileNameWithoutExtension (fileName);
+                    tmp = Path.GetExtension (tmp);
+                    if (tmp != null && tmp.Length > 0) {
+                              tmp = tmp.Substring (1);
+                            try {
+                                CultureInfo.GetCultureInfo (tmp);
+                                return true;
+                            } catch {
+                                return false;
+                            }
+                    } 
+                    return false;
+                }
+
+		string GetResourceFile (AppResourceFileInfo arfi, CompilerParameters cp)
+		{
+			string resfile;
+			if (arfi.Kind == AppResourceFileKind.ResX)
+				resfile = CompileResource (arfi);
+			else
+				resfile = arfi.Info.FullName;
+			if (!String.IsNullOrEmpty (resfile))
+				cp.EmbeddedResources.Add (resfile);
+			return resfile;
+		}
+		
+		List <string>[] GroupGlobalFiles (CompilerParameters cp)
+		{
+			List<AppResourceFileInfo> files = this.files.Files;
+			List<List<string>> groups = new List<List<string>> ();
+			AppResourcesLengthComparer<List<string>> lcList = new AppResourcesLengthComparer<List<string>> ();
 			
-			CodeDomProvider provider = GetCodeProvider ();
-			StringWriter sw = new StringWriter ();
-			provider.GenerateCodeFromCompileUnit (unit, sw, new CodeGeneratorOptions ());
-			CompilerResults ret = provider.CompileAssemblyFromDom (cp, unit);      
+			string tmp, s, basename;
+			uint basedots, filedots;
+			AppResourceFileInfo defaultFile;
 			
-			if (ret.Errors.Count != 0) {
-				Console.WriteLine ("Failed to compile {0}/*.resx. Errors:", ResourceDirectory);
-				foreach (CompilerError ce in ret.Errors)
-					Console.WriteLine("{5} {0} ({1} {2}:{3}): {4}", ce.ErrorNumber,
-							  ce.FileName, ce.Line, ce.Column, ce.ErrorText,
-							  ce.IsWarning ? "warning" : "error");
+			foreach (AppResourceFileInfo arfi in files) {
+				if (arfi.Kind != AppResourceFileKind.ResX && arfi.Kind != AppResourceFileKind.Resource)
+					continue;
+
+				s = arfi.Info.FullName;
+				basename = Path.GetFileNameWithoutExtension (s);
+				basedots = CountChars ('.', basename);
+				defaultFile = null;
+				
+				// If there are any files that start with this baseName, we have a default file
+				foreach (AppResourceFileInfo fi in files) {
+					if (fi.Seen)
+						continue;
+					
+					string s2 = fi.Info.FullName;
+					if (s2 == null || s == s2)
+						continue;
+					tmp = Path.GetFileNameWithoutExtension (s2);
+					filedots = CountChars ('.', tmp);
+
+					if (filedots == basedots + 1 && tmp.StartsWith (basename)) {
+						if (IsFileCultureValid (s2)) {
+							// A valid translated file for this name
+							defaultFile = arfi;
+							break;
+						} else {
+							// This file shares the base name, but the culture is invalid - we must
+							// ignore it since the name of the generated strongly typed class for this
+							// resource will clash with the one generated from the default file with
+							// the given basename.
+							fi.Seen = true;
+						}
+					}
+				}
+				if (defaultFile != null) {
+					List<string> al = new List<string> ();
+					al.Add (GetResourceFile (arfi, cp));
+					arfi.Seen = true;
+					groups.Add (al);
+					
+				}
+			}
+			groups.Sort (lcList);
+
+			string tmp2;
+			// Now find their translated counterparts
+			foreach (List<string> al in groups) {
+				s = al [0];
+				tmp = Path.GetFileNameWithoutExtension (s);
+				foreach (AppResourceFileInfo arfi in files) {
+					if (arfi.Seen)
+						continue;
+					
+					s = arfi.Info.FullName;
+					if (s == null)
+						continue;
+					tmp2 = arfi.Info.Name;
+					if (tmp2.StartsWith (tmp)) {
+						al.Add (GetResourceFile (arfi, cp));
+						arfi.Seen = true;
+					}
+				}
+			}
+
+			// Anything that's left here might be orphans or lone default files.
+			// For those files we check the part following the last dot
+			// before the .resx/.resource extensions and test whether it's a registered
+			// culture or not. If it is not a culture, then we have a
+			// default file that doesn't have any translations. Otherwise,
+			// the file is ignored (it's the same thing MS.NET does)
+			string fullName;
+			foreach (AppResourceFileInfo arfi in files) {
+				if (arfi.Seen)
+					continue;
+
+				if (IsFileCultureValid (arfi.Info.FullName))
+					continue; // Culture found, we reject the file
+
+				// A single default file, create a group
+				List<string> al = new List<string> ();
+				al.Add (GetResourceFile (arfi, cp));
+				groups.Add (al);
+			}
+			groups.Sort (lcList);
+			return groups.ToArray ();
+		}
+
+		// CodeDOM generation
+		void DomFromResource (string resfile, CodeCompileUnit unit, Dictionary <string,bool> assemblies,
+				      CodeDomProvider provider)
+		{
+			string fname, nsname, classname;
+
+			fname = Path.GetFileNameWithoutExtension (resfile);
+			nsname = Path.GetFileNameWithoutExtension (fname);
+			classname = Path.GetExtension (fname);
+			if (classname == null || classname.Length == 0) {
+				classname = nsname;
+				nsname = "Resources";
 			} else {
-				WebConfigurationManager.ExtraAssemblies.Add(ret.PathToAssembly);
-				BuildManager.TopLevelAssemblies.Add (ret.CompiledAssembly);
-				BuildManager.HaveResources = true;
+				nsname = String.Format ("Resources.{0}", nsname);
+				classname = classname.Substring(1);
 			}
+
+			if (!provider.IsValidIdentifier (nsname) || !provider.IsValidIdentifier (classname))
+				throw new ApplicationException ("Invalid resource file name.");
 			
-			return ret;
+			CodeNamespace ns = new CodeNamespace (nsname);
+			CodeTypeDeclaration cls = new CodeTypeDeclaration (classname);
+			cls.IsClass = true;
+			cls.TypeAttributes = TypeAttributes.Public | TypeAttributes.Sealed;
+
+			CodeMemberField cmf = new CodeMemberField (typeof(CultureInfo), "culture");
+			cmf.InitExpression = new CodePrimitiveExpression (null);
+			cmf.Attributes = MemberAttributes.Private | MemberAttributes.Final | MemberAttributes.Static;
+			cls.Members.Add (cmf);
+
+			cmf = new CodeMemberField (typeof(ResourceManager), "resourceManager");
+			cmf.InitExpression = new CodePrimitiveExpression (null);
+			cmf.Attributes = MemberAttributes.Private | MemberAttributes.Final | MemberAttributes.Static;
+			cls.Members.Add (cmf);
+			
+			// Property: ResourceManager
+			CodeMemberProperty cmp = new CodeMemberProperty ();
+			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static;
+			cmp.Name = "ResourceManager";
+			cmp.HasGet = true;
+			cmp.Type = new CodeTypeReference (typeof(ResourceManager));
+			CodePropertyResourceManagerGet (cmp.GetStatements, resfile, classname);
+			cls.Members.Add (cmp);
+
+			// Property: Culture
+			cmp = new CodeMemberProperty ();
+			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
+			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static;
+			cmp.Name = "Culture";
+			cmp.HasGet = true;
+			cmp.HasSet = true;
+			cmp.Type = new CodeTypeReference (typeof(CultureInfo));
+			CodePropertyGenericGet (cmp.GetStatements, "culture", classname);
+			CodePropertyGenericSet (cmp.SetStatements, "culture", classname);
+			cls.Members.Add (cmp);
+
+			// Add the resource properties
+			Dictionary<string,bool> imports = new Dictionary<string,bool> ();
+			try {
+				ResourceReader res = new ResourceReader (resfile);
+				foreach (DictionaryEntry de in res) {
+					Type type = de.Value.GetType ();
+
+					if (!imports.ContainsKey (type.Namespace))
+						imports [type.Namespace] = true;
+
+					string asname = new AssemblyName (type.Assembly.FullName).Name;
+					if (!assemblies.ContainsKey (asname))
+						assemblies [asname] = true;
+					
+					cmp = new CodeMemberProperty ();
+					cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static;
+					cmp.Name = SanitizeResourceName ((string)de.Key);
+					cmp.HasGet = true;
+					CodePropertyResourceGet (cmp.GetStatements, (string)de.Key, type, classname);
+					cmp.Type = new CodeTypeReference (type);
+					cls.Members.Add (cmp);
+				}
+			} catch (Exception ex) {
+				throw new ApplicationException ("Failed to comipile global resources.", ex);
+			}
+			foreach (KeyValuePair<string,bool> de in imports)
+				ns.Imports.Add (new CodeNamespaceImport(de.Key));
+			
+			ns.Types.Add (cls);
+			unit.Namespaces.Add (ns);
 		}
-	}
 
-	internal sealed class AppGlobalResourcesCompiler: AppResourcesCompiler
-	{
-		public AppGlobalResourcesCompiler ()
-			: base ()
+		string SanitizeResourceName (string name)
 		{
-			this.resourceDirName = "App_GlobalResources";
+			return name.Replace (' ', '_').Replace ('-', '_').Replace ('.', '_');
 		}
-    
-		public override string TopPath {
-			get { return HttpRuntime.AppDomainAppPath; }
+		
+		CodeObjectCreateExpression NewResourceManager (string name, string typename)
+		{
+			CodeExpression resname = new CodePrimitiveExpression (name);
+			CodePropertyReferenceExpression asm = new CodePropertyReferenceExpression (
+				new CodeTypeOfExpression (new CodeTypeReference (typename)),
+				"Assembly");
+			
+			return new CodeObjectCreateExpression ("System.Resources.ResourceManager",
+							       new CodeExpression [] {resname, asm});
 		}
-	}
+		
+		void CodePropertyResourceManagerGet (CodeStatementCollection csc, string resfile, string typename)
+		{
+			string name = Path.GetFileNameWithoutExtension (resfile);
+			CodeStatement st;
+			CodeExpression exp;
 
-	//FIXME: it seems that local resources are NOT strongly typed
-	// see http://msdn2.microsoft.com/en-us/library/ms227427.aspx
-	//
-	// Local resources should probably be only put in a satellite assembly and referenced
-	// from there.
-	internal sealed class AppLocalResourcesCompiler: AppResourcesCompiler
-	{
-		public AppLocalResourcesCompiler ()
-			: base ()
+			exp = new CodeFieldReferenceExpression (new CodeTypeReferenceExpression (typename), "resourceManager");
+			st = new CodeConditionStatement (
+				new CodeBinaryOperatorExpression (
+					exp,
+					CodeBinaryOperatorType.IdentityInequality,
+					new CodePrimitiveExpression (null)),
+				new CodeStatement [] { new CodeMethodReturnStatement (exp) });
+			csc.Add (st);
+
+			st = new CodeAssignStatement (exp, NewResourceManager (name, typename));
+			csc.Add (st);
+			csc.Add (new CodeMethodReturnStatement (exp));
+		}
+
+		void CodePropertyResourceGet (CodeStatementCollection csc, string resname, Type restype, string typename)
 		{
-			this.resourceDirName = "App_LocalResources";
+			CodeStatement st = new CodeVariableDeclarationStatement (
+				typeof (ResourceManager),
+				"rm",
+				new CodePropertyReferenceExpression (
+					new CodeTypeReferenceExpression (typename), "ResourceManager"));
+			csc.Add (st);
+
+			st = new CodeConditionStatement (
+				new CodeBinaryOperatorExpression (
+					new CodeVariableReferenceExpression ("rm"),
+					CodeBinaryOperatorType.IdentityEquality,
+					new CodePrimitiveExpression (null)),
+				new CodeStatement [] { new CodeMethodReturnStatement (new CodePrimitiveExpression (null)) });
+			csc.Add (st);
+
+			bool gotstr = (restype == typeof (string));
+			CodeExpression exp = new CodeMethodInvokeExpression (
+				new CodeVariableReferenceExpression ("rm"),
+				gotstr ? "GetString" : "GetObject",
+				new CodeExpression [] { new CodePrimitiveExpression (resname),
+							new CodeFieldReferenceExpression (
+								new CodeTypeReferenceExpression (typename), "culture") });
+			st = new CodeVariableDeclarationStatement (
+				restype,
+				"obj",
+				gotstr ? exp : new CodeCastExpression (restype, exp));
+			csc.Add (st);
+			csc.Add (new CodeMethodReturnStatement (new CodeVariableReferenceExpression ("obj")));
 		}
+		
+		void CodePropertyGenericGet (CodeStatementCollection csc, string field, string typename)
+		{
+			csc.Add(new CodeMethodReturnStatement (
+					new CodeFieldReferenceExpression (
+						new CodeTypeReferenceExpression (typename), field)));
+		}
 
-		public override string TopPath {
-			get {
-				return Path.GetDirectoryName (
-					HttpContext.Current.Request.MapPath (
-						HttpContext.Current.Request.CurrentExecutionFilePath));
+		void CodePropertyGenericSet (CodeStatementCollection csc, string field, string typename)
+		{
+			csc.Add(new CodeAssignStatement (
+					new CodeFieldReferenceExpression (new CodeTypeReferenceExpression (typename), field),
+					new CodeVariableReferenceExpression ("value")));
+		}
+		
+		string CompileResource (AppResourceFileInfo arfi)
+		{
+			string path = arfi.Info.FullName;
+			string resource = Path.Combine (TempDirectory,
+							Path.GetFileNameWithoutExtension (path) + ".resources");
+			FileStream source = null, destination = null;
+			IResourceReader reader = null;
+			ResourceWriter writer = null;
+
+			try {
+				source = new FileStream (path, FileMode.Open, FileAccess.Read);
+				destination = new FileStream (resource, FileMode.Create, FileAccess.Write);
+				reader = GetReaderForKind (arfi.Kind, source);
+				writer = new ResourceWriter (destination);
+				foreach (DictionaryEntry de in reader) {
+					object val = de.Value;
+					if (val is string)
+						writer.AddResource ((string)de.Key, (string)val);
+					else
+						writer.AddResource ((string)de.Key, val);
+				}
+			} catch (Exception ex) {
+				throw new HttpException ("Failed to compile resource file", ex);
+			} finally {
+				if (reader != null)
+					reader.Dispose ();
+				else if (source != null)
+					source.Dispose ();
+				if (writer != null)
+					writer.Dispose ();
+				else if (destination != null)
+					destination.Dispose ();
 			}
+			
+			return resource;
 		}
-	}
-}
+
+		IResourceReader GetReaderForKind (AppResourceFileKind kind, Stream stream)
+		{
+			switch (kind) {
+				case AppResourceFileKind.ResX:
+					return new ResXResourceReader (stream);
+
+				case AppResourceFileKind.Resource:
+					return new ResourceReader (stream);
+
+				default:
+					return null;
+			}
+		}
+		
+							       
+		object OnCreateRandomFile (string path)
+		{
+			FileStream f = new FileStream (path, FileMode.CreateNew);
+			f.Close ();
+			return path;
+		}
+	};
+};
 #endif
Index: System.Web.Compilation/AppResourceFilesCompiler.cs
===================================================================
--- System.Web.Compilation/AppResourceFilesCompiler.cs	(revision 70421)
+++ System.Web.Compilation/AppResourceFilesCompiler.cs	(working copy)
@@ -1,607 +0,0 @@
-//
-// System.Web.Compilation.AppResourceFilesCompiler: A compiler for application resource files
-//
-// Authors:
-//   Marek Habersack (grendello@gmail.com)
-//
-// (C) 2006 Marek Habersack
-//
-
-//
-// Permission is hereby granted, free of charge, to any person obtaining
-// a copy of this software and associated documentation files (the
-// "Software"), to deal in the Software without restriction, including
-// without limitation the rights to use, copy, modify, merge, publish,
-// distribute, sublicense, and/or sell copies of the Software, and to
-// permit persons to whom the Software is furnished to do so, subject to
-// the following conditions:
-// 
-// The above copyright notice and this permission notice shall be
-// included in all copies or substantial portions of the Software.
-// 
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-//
-#if NET_2_0
-using System;
-using System.CodeDom;
-using System.CodeDom.Compiler;
-using System.Collections;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Reflection;
-using System.Resources;
-using System.Web.Util;
-
-using Microsoft.CSharp;
-//using Microsoft.VisualBasic;
-//using Microsoft.JScript;
-
-namespace System.Web.Compilation
-{
-	class LengthComparer<T>: Comparer<T>
-	{
-		private int CompareStrings (string a, string b)
-		{
-			if (a == null || b == null)
-				return 0;
-			return (int)b.Length - (int)a.Length;
-		}
-
-		public override int Compare (T _a, T _b) 
-		{
-			string a = null, b = null;
-			if (_a is string && _b is string) {
-				a = _a as string;
-				b = _b as string;
-			} else if (_a is List<string> && _b is List<string>) {
-				List<string> tmp = _a as List<string>;
-				a = tmp [0];
-				tmp = _b as List<string>;
-				b = tmp [0];
-			} else
-				return 0;
-			return CompareStrings (a, b);
-		}
-	}
-	
-	internal class AppResourceFilesCompiler
-	{
-		public enum FcCodeGenerator
-		{
-			Typed,
-			CSharp,
-			VBasic,
-			JScript
-		};
-		
-		protected string []	  filePaths = null;
-		protected FcCodeGenerator codeGenerator = FcCodeGenerator.CSharp;
-		protected string          codeGenType = null;
-		protected List<string> [] resxFiles = null;
-		protected List<string>    resourceFiles = null;
-		protected Dictionary<string,bool?> assemblies = null;
-		protected string          tempdirectory = null;
-		protected Random          rnd = null;
-		
-		public FcCodeGenerator CodeGen {
-			get { return codeGenerator; }
-			set { codeGenerator = value; }
-		}
-
-		virtual public string TempDir {
-			get {
-				if (tempdirectory != null)
-					return tempdirectory;
-				return (tempdirectory = GenTempDir (Path.GetTempPath ()));
-			}
-			set { tempdirectory = value; }
-		}
-		
-		public string Source {
-			get { return FilesToString (); }
-		}
-
-		public CodeCompileUnit CompileUnit {
-			get { return FilesToDom (); }
-		}
-
-		protected AppResourceFilesCompiler ()
-		{
-			filePaths = new string [] {};
-		}
-		
-		public AppResourceFilesCompiler (string filePath)
-		{
-			DoInit (filePath, FcCodeGenerator.CSharp);
-		}
-		
-		public AppResourceFilesCompiler (string filePath, FcCodeGenerator cg)
-		{
-			DoInit (filePath, cg);
-		}
-
-		public AppResourceFilesCompiler (string[] filePaths)
-		{
-			DoInit (filePaths, FcCodeGenerator.CSharp);
-		}
-		
-		public AppResourceFilesCompiler (string[] filePaths, FcCodeGenerator cg)
-		{
-			DoInit (filePaths, cg);
-		}
-
-		public AppResourceFilesCompiler (string filePath, string genType)
-		{
-			DoInit (filePath, genType);
-		}
-
-		public AppResourceFilesCompiler (string[] filePaths, string genType)
-		{
-			DoInit (filePaths, genType);
-		}
-
-		private void DoInit (string filePath, string genType)
-		{
-			this.codeGenType = genType;
-			DoInit (filePath, FcCodeGenerator.Typed);
-		}
-
-		private void DoInit (string [] filePaths, string genType)
-		{
-			this.codeGenType = genType;
-			DoInit (filePaths, FcCodeGenerator.Typed);
-		}
-		
-		private void DoInit (string filePath, FcCodeGenerator cg)
-		{
-			this.codeGenerator = cg;
-			if (filePath != null)
-				this.filePaths = new string [] { filePath };
-		}
-
-		private void DoInit (string [] filePaths, FcCodeGenerator cg)
-		{
-			this.codeGenerator = cg;
-			if (filePaths != null)
-				this.filePaths = (string [])filePaths.Clone ();
-		}
-
-		protected CodeDomProvider GetCodeProvider ()
-		{
-			switch (codeGenerator) {
-			default:
-				goto case FcCodeGenerator.CSharp;
-					
-			case FcCodeGenerator.CSharp:
-				return new CSharpCodeProvider ();
-
-//                         case FcCodeGenerator.VBasic:
-//                                 return new VBCodeProvider ();
-
-//                         case FcCodeGenerator.JScript:
-//                                 return new JScriptCodeProvider ();
-
-			case FcCodeGenerator.Typed:
-				return null;
-			}
-		}
-		
-		protected string FilesToString ()
-		{
-			CodeCompileUnit unit = FilesToDom ();
-			CodeDomProvider provider = GetCodeProvider ();
-			StringWriter writer = new StringWriter ();
-			CodeGeneratorOptions opts = new CodeGeneratorOptions ();
-
-			opts.BlankLinesBetweenMembers = false;
-			provider.GenerateCodeFromCompileUnit (unit, writer, opts);
-			
-			string ret = writer.ToString ();
-			writer.Close ();
-			return ret;
-		}
-		
-		protected CodeCompileUnit FilesToDom ()
-		{
-			CollectFiles ();
-			if (resxFiles == null || resxFiles.Length == 0)
-				return null;
-			
-			string destdir = TempDir;
-
-			string s, resfile;
-			resourceFiles = new List<string> (resxFiles.Length);
-			CodeCompileUnit ret = new CodeCompileUnit ();
-			foreach (List<string> al in resxFiles) {
-				if (al == null)
-					continue;
-				for (int i = 0; i < al.Count; i++) {
-					s = al [i];
-					if (s == null)
-						continue;
-					resfile = CompileFile (destdir, s);
-					resourceFiles.Add (resfile);				 
-					if (i > 0 || resfile == null)
-						continue;
-					
-					// Default file. Generate the class
-					DomFromResource (resfile, ret);
-				}
-			}
-			if (assemblies != null)
-				foreach (KeyValuePair<string,bool?> de in assemblies)
-					ret.ReferencedAssemblies.Add (de.Key);
-			
-			return ret;
-		}
-
-		private void DomFromResource (string resfile, CodeCompileUnit unit)
-		{
-			string fname, nsname, classname;
-
-			fname = Path.GetFileNameWithoutExtension (resfile);
-			nsname = Path.GetFileNameWithoutExtension (fname);
-			classname = Path.GetExtension (fname);
-			if (classname == null || classname.Length == 0) {
-				classname = nsname;
-				nsname = "Resources";
-			} else {
-				nsname = String.Format ("Resources.{0}", nsname);
-				classname = classname.Substring(1);
-			}		 
-
-			Dictionary<string,bool> imports = new Dictionary<string,bool> ();
-			if (assemblies == null)
-				assemblies = new Dictionary<string,bool?> ();
-			CodeNamespace ns = new CodeNamespace (nsname);
-			imports ["System"] = true;
-			imports ["System.Globalization"] = true;
-			imports ["System.Reflection"] = true;
-			imports ["System.Resources"] = true;
-
-			CodeTypeDeclaration cls = new CodeTypeDeclaration (classname);
-			cls.IsClass = true;
-			cls.TypeAttributes = TypeAttributes.Public | TypeAttributes.Sealed;
-
-			CodeMemberField cmf = new CodeMemberField (typeof(CultureInfo), "culture");
-			cmf.InitExpression = new CodePrimitiveExpression (null);
-			cmf.Attributes = MemberAttributes.Private | MemberAttributes.Final | MemberAttributes.Static;
-			cls.Members.Add (cmf);
-
-			cmf = new CodeMemberField (typeof(ResourceManager), "resourceManager");
-			cmf.InitExpression = new CodePrimitiveExpression (null);
-			cmf.Attributes = MemberAttributes.Private | MemberAttributes.Final | MemberAttributes.Static;
-			cls.Members.Add (cmf);
-			
-			// Property: ResourceManager
-			CodeMemberProperty cmp = new CodeMemberProperty ();
-			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static;
-			cmp.Name = "ResourceManager";
-			cmp.HasGet = true;
-			cmp.Type = new CodeTypeReference (typeof(ResourceManager));
-			CodePropertyResourceManagerGet (cmp.GetStatements, resfile, classname);
-			cls.Members.Add (cmp);
-
-			// Property: Culture
-			cmp = new CodeMemberProperty ();
-			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
-			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static;
-			cmp.Name = "Culture";
-			cmp.HasGet = true;
-			cmp.HasSet = true;
-			cmp.Type = new CodeTypeReference (typeof(CultureInfo));
-			CodePropertyGenericGet (cmp.GetStatements, "culture", classname);
-			CodePropertyGenericSet (cmp.SetStatements, "culture", classname);
-			cls.Members.Add (cmp);
-
-			// Add the resource properties
-			try {
-				ResourceReader res = new ResourceReader (resfile);
-				foreach (DictionaryEntry de in res) {
-					Type type = de.Value.GetType ();
-
-					if (!imports.ContainsKey (type.Namespace))
-						imports [type.Namespace] = true;
-
-					string asname = new AssemblyName (type.Assembly.FullName).Name;
-					if (!assemblies.ContainsKey (asname))
-						assemblies [asname] = true;
-					
-					cmp = new CodeMemberProperty ();
-					cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static;
-					cmp.Name = SanitizeResourceName ((string)de.Key);
-					cmp.HasGet = true;
-					CodePropertyResourceGet (cmp.GetStatements, (string)de.Key, type, classname);
-					cmp.Type = new CodeTypeReference (type);
-					cls.Members.Add (cmp);
-				}
-			} catch (Exception ex) {
-			}
-			foreach (KeyValuePair<string,bool> de in imports)
-				ns.Imports.Add (new CodeNamespaceImport(de.Key));
-			
-			ns.Types.Add (cls);
-			unit.Namespaces.Add (ns);
-		}
-
-		private string SanitizeResourceName (string name)
-		{
-			return name.Replace (' ', '_').Replace ('-', '_').Replace ('.', '_');
-		}
-		
-		private CodeObjectCreateExpression NewResourceManager (string name, string typename)
-		{
-			CodeExpression resname = new CodePrimitiveExpression (name);
-			CodePropertyReferenceExpression asm = new CodePropertyReferenceExpression (
-				new CodeTypeOfExpression (new CodeTypeReference (typename)),
-				"Assembly");
-			
-			return new CodeObjectCreateExpression ("System.Resources.ResourceManager",
-							       new CodeExpression [] {resname, asm});
-		}
-		
-		private void CodePropertyResourceManagerGet (CodeStatementCollection csc, string resfile, string typename)
-		{
-			string name = Path.GetFileNameWithoutExtension (resfile);
-			CodeStatement st;
-			CodeExpression exp;
-
-			exp = new CodeFieldReferenceExpression (new CodeTypeReferenceExpression (typename), "resourceManager");
-			st = new CodeConditionStatement (
-				new CodeBinaryOperatorExpression (
-					exp,
-					CodeBinaryOperatorType.IdentityInequality,
-					new CodePrimitiveExpression (null)),
-				new CodeStatement [] { new CodeMethodReturnStatement (exp) });
-			csc.Add (st);
-
-			st = new CodeAssignStatement (exp, NewResourceManager (name, typename));
-			csc.Add (st);
-			csc.Add (new CodeMethodReturnStatement (exp));
-		}
-
-		private void CodePropertyResourceGet (CodeStatementCollection csc, string resname, Type restype, string typename)
-		{
-			CodeStatement st = new CodeVariableDeclarationStatement (
-				typeof (ResourceManager),
-				"rm",
-				new CodePropertyReferenceExpression (
-					new CodeTypeReferenceExpression (typename), "ResourceManager"));
-			csc.Add (st);
-
-			st = new CodeConditionStatement (
-				new CodeBinaryOperatorExpression (
-					new CodeVariableReferenceExpression ("rm"),
-					CodeBinaryOperatorType.IdentityEquality,
-					new CodePrimitiveExpression (null)),
-				new CodeStatement [] { new CodeMethodReturnStatement (new CodePrimitiveExpression (null)) });
-			csc.Add (st);
-
-			bool gotstr = (restype == typeof (string));
-			CodeExpression exp = new CodeMethodInvokeExpression (
-				new CodeVariableReferenceExpression ("rm"),
-				gotstr ? "GetString" : "GetObject",
-				new CodeExpression [] { new CodePrimitiveExpression (resname),
-							new CodeFieldReferenceExpression (
-								new CodeTypeReferenceExpression (typename), "culture") });
-			st = new CodeVariableDeclarationStatement (
-				restype,
-				"obj",
-				gotstr ? exp : new CodeCastExpression (restype, exp));
-			csc.Add (st);
-			csc.Add (new CodeMethodReturnStatement (new CodeVariableReferenceExpression ("obj")));
-		}
-		
-		private void CodePropertyGenericGet (CodeStatementCollection csc, string field, string typename)
-		{
-			csc.Add(new CodeMethodReturnStatement (
-					new CodeFieldReferenceExpression (
-						new CodeTypeReferenceExpression (typename), field)));
-		}
-
-		private void CodePropertyGenericSet (CodeStatementCollection csc, string field, string typename)
-		{
-			csc.Add(new CodeAssignStatement (
-					new CodeFieldReferenceExpression (new CodeTypeReferenceExpression (typename), field),
-					new CodeVariableReferenceExpression ("value")));
-		}
-		
-		private uint CountChars (char c, string s)
-		{
-			uint ret = 0;
-			foreach (char ch in s) {
-				if (ch == c)
-					ret++;
-			}
-			return ret;
-		}
-		
-		private void CollectFiles ()
-		{
-			List<string> files = new List<string> (filePaths);
-			List<List<string>> groups = new List<List<string>> ();
-			LengthComparer<string> lcString = new LengthComparer<string> ();
-			LengthComparer<List<string>> lcList = new LengthComparer<List<string>> ();
-			
-			files.Sort (lcString);
-			Array.Sort (filePaths, lcString);
-
-			string tmp;
-			foreach (string s in filePaths) {
-				tmp = Path.GetExtension (s);
-				if (tmp == null)
-					continue;
-				tmp = tmp.ToLower ();
-				if (tmp != ".resx")
-					continue;
-
-				string basename = Path.GetFileNameWithoutExtension (s);
-				uint basedots = CountChars ('.', basename);
-				uint filedots;
-				bool gotdefault = false;
-
-				// If there are any files that start with this baseName, we have a default file
-				for (int i = 0; i < files.Count; i++) {
-					string s2 = files [i];
-					if (s2 == null || s == s2)
-						continue;
-					tmp = Path.GetFileNameWithoutExtension (s2);
-					filedots = CountChars ('.', tmp);
-
-					if (filedots == basedots + 1 && tmp.StartsWith (basename)) {
-						gotdefault = true;
-						break;
-					}
-				}
-				if (gotdefault) {
-					List<string> al = new List<string> ();
-					al.Add (s);
-					int	idx = files.IndexOf (s);
-					if (idx != -1)
-						files [idx] = null;
-					groups.Add (al);
-				}
-			}
-			groups.Sort (lcList);
-
-			string tmp2;
-			// Now find their translated counterparts
-			foreach (List<string> al in groups) {
-				string s = al [0];
-				tmp = Path.GetFileNameWithoutExtension (s);
-				for (int i = 0; i < files.Count; i++) {
-					s = files [i];
-					if (s == null)
-						continue;
-					tmp2 = Path.GetFileName (s);
-					if (tmp2.StartsWith (tmp)) {
-						al.Add (s);
-						files [i] = null;
-					}
-				}
-			}
-
-			// Anything that's left here might be orphans or lone default files.
-			// For those files we check the part following the last dot
-			// before the .resx extension and test whether it's a registered
-			// culture or not. If it is not a culture, then we have a
-			// default file that doesn't have any translations. Otherwise,
-			// the file is ignored (it's the same thing MS.NET does)
-			CultureInfo ci;
-			foreach (string s in files) {
-				if (s == null)
-					continue;
-				
-				tmp = Path.GetFileNameWithoutExtension (s);
-				tmp = Path.GetExtension (tmp);
-				if (tmp == null || tmp.Length == 0)
-					continue;
-				tmp = tmp.Substring (1);
-				try {
-					ci = CultureInfo.GetCultureInfo (tmp);
-					continue; // Culture found, we reject the file
-				} catch {
-				}
-
-				// A single default file, create a group
-				List<string> al = new List<string> ();
-				al.Add (s);
-				groups.Add (al);
-			}
-			groups.Sort (lcList);
-			resxFiles = groups.ToArray ();
-		}		 
-
-		private IResourceReader GetReader (Stream stream, string path)
-		{
-			string ext = Path.GetExtension (path);
-			if (ext == null)
-				throw new Exception ("Unknown resource type.");
-			switch (ext.ToLower ()) {
-			case ".resx":
-				return new ResXResourceReader (stream);
-
-			default:
-				throw new Exception ("Unknown resource type.");
-			}
-		}
-		
-		private string CompileFile (string destdir, string path)
-		{
-			string resfile = String.Format ("{1}{0}{2}.resources",
-							Path.DirectorySeparatorChar,
-							destdir,
-							Path.GetFileNameWithoutExtension (path));
-
-			FileStream source = null, dest = null;
-			IResourceReader reader = null;
-			ResourceWriter writer = null;
-			
-			try {
-				source = new FileStream (path, FileMode.Open, FileAccess.Read);
-				dest = new FileStream (resfile, FileMode.Create, FileAccess.Write);
-				reader = GetReader (source, path);
-				writer = new ResourceWriter (dest);
-				foreach (DictionaryEntry de in reader) {
-					object val = de.Value;
-					if (val is string)
-						writer.AddResource ((string)de.Key, (string)val);
-					else
-						writer.AddResource ((string)de.Key, val);
-				}
-			} catch (Exception ex) {
-				Console.WriteLine ("Resource compiler error: {0}", ex.Message);
-				Exception inner = ex.InnerException;
-				if (inner != null)
-					Console.WriteLine ("Inner exception: {0}", inner.Message);
-				return null;
-			} finally {
-				if (reader != null)
-					reader.Close ();
-				else if (source != null)
-					source.Close ();
-				if (writer != null)
-					writer.Close ();
-				else if (dest != null)
-					dest.Close ();
-			}
-			return resfile;
-		}
-
-		object OnCreateRandomFile (string path)
-		{
-			FileStream f = new FileStream (path, FileMode.CreateNew);
-			f.Close ();
-			return path;
-		}
-		
-		protected string GenRandomFileName (string basepath)
-		{
-			return GenRandomFileName (basepath, null);
-		}
-		
-		protected string GenRandomFileName (string basepath, string ext)
-		{
-			return (string)FileUtils.CreateTemporaryFile (basepath, ext, OnCreateRandomFile);
-		}
-
-		object OnCreateRandomDir (string path)
-		{
-			DirectoryInfo di = Directory.CreateDirectory (path);
-			return di.FullName;
-		}
-		
-		protected string GenTempDir (string basepath)
-		{
-			return (string)FileUtils.CreateTemporaryFile (basepath, OnCreateRandomDir);
-		}
-	}
-}
-#endif
Index: System.Web.Compilation/AppResourceFileInfo.cs
===================================================================
--- System.Web.Compilation/AppResourceFileInfo.cs	(revision 0)
+++ System.Web.Compilation/AppResourceFileInfo.cs	(revision 0)
@@ -0,0 +1,53 @@
+//
+// System.Web.Compilation.AppResourceFileInfo
+//
+// Authors:
+//   Marek Habersack (grendello@gmail.com)
+//
+// (C) 2006 Marek Habersack
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+#if NET_2_0
+using System.IO;
+
+namespace System.Web.Compilation 
+{
+	internal class AppResourceFileInfo
+	{
+		public readonly bool Embeddable;
+		public readonly bool Compilable;
+		public readonly FileInfo Info;
+		public readonly AppResourceFileKind Kind;
+		public bool Seen;
+		
+		public AppResourceFileInfo (FileInfo info, AppResourceFileKind kind)
+		{
+			this.Embeddable = (kind == AppResourceFileKind.Resource || kind == AppResourceFileKind.Binary);
+			this.Compilable = (kind == AppResourceFileKind.ResX);
+			this.Info = info;
+			this.Kind = kind;
+			this.Seen = false;
+		}
+	};
+};
+#endif
\ No newline at end of file
Index: System.Web.Compilation/TemplateControlCompiler.cs
===================================================================
--- System.Web.Compilation/TemplateControlCompiler.cs	(revision 70421)
+++ System.Web.Compilation/TemplateControlCompiler.cs	(working copy)
@@ -659,11 +659,6 @@
 				new CodeTypeReferenceExpression (typeof(Convert)),
 				"ToString");
 			convert.Parameters.Add (eb.GetCodeExpression (null, fields, ctx));
-			convert.Parameters.Add (
-				new CodePropertyReferenceExpression (
-					new CodeTypeReferenceExpression (typeof(Globalization.CultureInfo)),
-					"CurrentCulture"));
-			
 			assign.Right = convert;
 			
 			method.Statements.Add (assign);
@@ -688,7 +683,7 @@
 			} else // should never happen
 				return;
 
-			// __ctrl.Text = System.Convert.ToString(this.GetLocalResourceObject("ButtonResource1.Text"), System.Globalization.CultureInfo.CurrentCulture);
+			// __ctrl.Text = System.Convert.ToString(this.GetLocalResourceObject("ButtonResource1.Text"));
 			object obj = HttpContext.GetLocalResourceObject (HttpContext.Current.Request.FilePath,
 									 resname);
 			if (obj == null)
@@ -706,10 +701,6 @@
 				new CodeTypeReferenceExpression (typeof(System.Convert)),
 				"ToString");
 			convert.Parameters.Add (getlro);
-			convert.Parameters.Add (
-				new CodePropertyReferenceExpression (
-					new CodeTypeReferenceExpression (typeof(Globalization.CultureInfo)),
-					"CurrentCulture"));
 			assign.Right = convert;
 			
 // 			assign.Left = new CodeVariableReferenceExpression (varname);
Index: System.Web.Compilation/AppResourceFilesCollection.cs
===================================================================
--- System.Web.Compilation/AppResourceFilesCollection.cs	(revision 0)
+++ System.Web.Compilation/AppResourceFilesCollection.cs	(revision 0)
@@ -0,0 +1,170 @@
+//
+// System.Web.Compilation.AppResourceFilesCollection
+//
+// Authors:
+//   Marek Habersack (grendello@gmail.com)
+//
+// (C) 2006 Marek Habersack
+//
+
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+#if NET_2_0
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.IO;
+
+namespace System.Web.Compilation 
+{
+	internal enum AppResourceFileKind
+	{
+		NotResource,
+		ResX,
+		Resource,
+		Binary
+	};
+
+	internal class AppResourcesLengthComparer<T>: IComparer<T>
+	{
+		private int CompareStrings (string a, string b)
+		{
+			if (a == null || b == null)
+				return 0;
+			return (int)b.Length - (int)a.Length;
+		}
+
+		int IComparer<T>.Compare (T _a, T _b) 
+		{
+			string a = null, b = null;
+			if (_a is string && _b is string) {
+				a = _a as string;
+				b = _b as string;
+			} else if (_a is List<string> && _b is List<string>) {
+				List<string> tmp = _a as List<string>;
+				a = tmp [0];
+				tmp = _b as List<string>;
+				b = tmp [0];
+			} else if (_a is AppResourceFileInfo && _b is AppResourceFileInfo) {
+				AppResourceFileInfo tmp = _a as AppResourceFileInfo;
+				a = tmp.Info.Name;
+				tmp = _b as AppResourceFileInfo;
+				b = tmp.Info.Name;
+			} else
+				return 0;
+			return CompareStrings (a, b);
+		}
+	}
+	
+	internal class AppResourceFilesCollection
+	{
+		List <AppResourceFileInfo> files;
+		HttpContext context;
+		bool isGlobal;
+		string sourceDir;
+
+		public string SourceDir {
+			get { return sourceDir; }
+		}
+		
+		public bool HasFiles {
+			get {
+				if (String.IsNullOrEmpty (sourceDir))
+					return false;
+				return files.Count > 0;
+			}
+		}
+
+		public List <AppResourceFileInfo> Files {
+			get { return files; }
+		}
+		
+		public AppResourceFilesCollection (HttpContext context, bool isGlobal)
+		{
+			if (context == null)
+				throw new ArgumentNullException ("context");
+			
+			this.context = context;
+			this.isGlobal = isGlobal;
+			this.files = new List <AppResourceFileInfo> ();
+
+			string resourcePath;
+			if (isGlobal)
+				resourcePath = Path.Combine (HttpRuntime.AppDomainAppPath, "App_GlobalResources");
+			else {
+				HttpRequest request = context.Request;
+				resourcePath = Path.Combine (
+					Path.GetDirectoryName (request.MapPath (request.CurrentExecutionFilePath)),
+					"App_LocalResources");
+			}
+			if (Directory.Exists (resourcePath))
+				sourceDir = resourcePath;
+		}
+
+		public void Collect ()
+		{
+			if (String.IsNullOrEmpty (sourceDir))
+			    return;
+			DirectoryInfo di = new DirectoryInfo (sourceDir);
+			FileInfo[] infos = di.GetFiles ();
+			if (infos.Length == 0)
+				return;
+
+			string extension;
+			AppResourceFileInfo arfi;
+			AppResourceFileKind kind;
+			
+			foreach (FileInfo fi in infos) {
+				extension = fi.Extension;
+				if (Acceptable (extension, out kind))
+					arfi = new AppResourceFileInfo (fi, kind);
+				else
+					continue;
+
+				files.Add (arfi);
+			}
+
+			if (isGlobal && files.Count == 0)
+				return;
+			AppResourcesLengthComparer<AppResourceFileInfo> lcFiles = new AppResourcesLengthComparer<AppResourceFileInfo> ();
+			files.Sort (lcFiles);
+		}
+
+		bool Acceptable (string extension, out AppResourceFileKind kind)
+		{
+			switch (extension.ToLower (CultureInfo.InvariantCulture))
+			{
+				default:
+					kind = AppResourceFileKind.NotResource;
+					return false;
+
+				case ".resx":
+					kind = AppResourceFileKind.ResX;
+					return true;
+
+				case ".resource":
+					kind = AppResourceFileKind.Resource;
+					return true;
+			}
+		}
+	};
+};
+#endif
