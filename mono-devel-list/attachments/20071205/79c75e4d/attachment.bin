Index: mono-dbg.c
===================================================================
--- mono-dbg.c	(revision 0)
+++ mono-dbg.c	(revision 0)
@@ -0,0 +1,210 @@
+
+#include "mono-dbg-internals.h"
+
+/**
+ * mono_dbg_target_new:
+ * @process_id: pid for unix systems or process id on windows
+ * @flags: flags (currently none)
+ *
+ * Create and initialize the structure needed to be able to debug
+ * the process identified by @process_id.
+ *
+ * Returns: a pointer to the target structure or #NULL on error.
+ */
+MonoDbgTarget*
+mono_dbg_target_new (void *process_id, MonoDbgTargetFlags flags)
+{
+	MonoDbgTarget* target = malloc (sizeof (MonoDbgTarget));
+	target->flags = flags;
+#ifdef PLATFORM_WIN32
+	target->process_id = process_id;
+	target->thread_id = NULL; /* FIXME */
+#else
+	target->process_id = (pid_t)process_id;
+	target->thread_id = target->process_id;
+#endif
+
+	return target;
+}
+
+/**
+ * mono_dbg_target_free:
+ * @target: a target structure pointer returned from mono_dbg_target_new ()
+ *
+ * Free all the resources associated with debugging the given target process.
+ */
+void
+mono_dbg_target_free (MonoDbgTarget *target)
+{
+	free (target);
+}
+
+/**
+ * mono_dbg_target_attach:
+ * @target:
+ *
+ * Start debugging the process specified by @target. On successfull
+ * return the process will be stopped.
+ *
+ * Returns: 0 on success.
+ */
+int
+mono_dbg_target_attach (MonoDbgTarget *target)
+{
+#ifdef PLATFORM_WIN32
+	return -1;
+#else
+	int status;
+	pid_t pid;
+	int result = ptrace (PTRACE_ATTACH, target->process_id, NULL, NULL);
+	if (result < 0) {
+		return result;
+	}
+	/* wait for the target to stop */
+	pid = wait (&status);
+	return 0;
+#endif
+}
+
+/**
+ * mono_dbg_target_detach:
+ * @target:
+ *
+ * Stop debugging the current process.
+ *
+ * Returns: 0 on success.
+ */
+int
+mono_dbg_target_detach (MonoDbgTarget *target)
+{
+#ifdef PLATFORM_WIN32
+	return -1;
+#else
+	int result = ptrace (PTRACE_DETACH, target->process_id, NULL, NULL);
+	return result;
+#endif
+}
+
+/**
+ * mono_dbg_target_continue:
+ * @target:
+ *
+ * Cause the target process to continue execution.
+ *
+ * Returns: 0 on success.
+ */
+int
+mono_dbg_target_continue (MonoDbgTarget *target)
+{
+#ifdef PLATFORM_WIN32
+	return -1;
+#else
+	int result = ptrace (PTRACE_CONT, target->process_id, NULL, NULL);
+	return result;
+#endif
+}
+
+/**
+ * mono_dbg_target_stop:
+ * @target:
+ *
+ * Cause the target process to stop execution.
+ *
+ * Returns: 0 on success.
+ */
+int
+mono_dbg_target_stop (MonoDbgTarget *target)
+{
+#ifdef PLATFORM_WIN32
+	return -1;
+#else
+	int status;
+	kill (target->process_id, SIGINT);
+	wait (&status);
+	return 0;
+#endif
+}
+
+/**
+ * mono_dbg_target_kill:
+ * @target:
+ *
+ * Terminate the target process.
+ *
+ * Returns: 0 on success.
+ */
+int
+mono_dbg_target_kill (MonoDbgTarget *target)
+{
+#ifdef PLATFORM_WIN32
+	return -1;
+#else
+	int result = ptrace (PTRACE_KILL, target->process_id, NULL, NULL);
+	return result;
+#endif
+}
+
+/**
+ * mono_dbg_target_read:
+ * @target:
+ * @address: memory address in the target process
+ * @out_data: pointer to the memory location where the read word is stored
+ *
+ * Read a pointer-sized word from the target process at address @address.
+ * @address should be pointer-size aligned.
+ * The data is written through the pointer @out_data.
+ *
+ * Returns: 0 on success.
+ */
+int
+mono_dbg_target_read (MonoDbgTarget *target, void *address, void **out_data)
+{
+#ifdef PLATFORM_WIN32
+	return -1;
+#else
+	long data = ptrace (PTRACE_PEEKDATA, target->process_id, address, NULL);
+	if (errno)
+		return -1;
+	*out_data = (void*)data;
+	return 0;
+#endif
+}
+
+/**
+ * mono_dbg_target_write:
+ * @target:
+ * @address: memory address in the target process
+ * @data: data to be written
+ *
+ * Write a pointer-sized word @data to the target process at address @address.
+ * @address should be pointer-size aligned.
+ *
+ * Returns: 0 on success.
+ */
+int
+mono_dbg_target_write (MonoDbgTarget *target, void *address, void *data)
+{
+#ifdef PLATFORM_WIN32
+	return -1;
+#else
+	int result = ptrace (PTRACE_POKEDATA, target->process_id, address, data);
+	return result;
+#endif
+}
+
+#ifdef MONO_DBG_NO_CONTEXT
+
+int
+mono_dbg_target_get_context (MonoDbgTarget *target, void *thread_id, MonoDbgContexttFlags flags, MonoDbgContext *context)
+{
+	return 1;
+}
+
+int
+mono_dbg_target_set_context (MonoDbgTarget *target, void *thread_id, MonoDbgContexttFlags flags, MonoDbgContext *context)
+{
+	return 1;
+}
+
+#endif
+
Index: mono-dbg-internals.h
===================================================================
--- mono-dbg-internals.h	(revision 0)
+++ mono-dbg-internals.h	(revision 0)
@@ -0,0 +1,31 @@
+
+#ifndef __MONO_DBG_INTERNALS_H__
+#define __MONO_DBG_INTERNALS_H__
+
+#include "config.h"
+#include <stdlib.h>
+#include <errno.h>
+#ifdef PLATFORM_WIN32
+#include <windows.h>
+#else
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/ptrace.h>
+#include <sys/user.h>
+#endif
+#include "mono-dbg.h"
+
+struct _MonoDbgTarget {
+#ifdef PLATFORM_WIN32
+	DWORD process_id;
+	CONTEXT context;
+#else
+	pid_t process_id;
+	pid_t thread_id;
+	struct user_regs_struct uregs;
+#endif
+	MonoDbgTargetFlags flags;
+};
+
+#endif /* __MONO_DBG_INTERNALS_H__ */
+
Index: mono-dbg.h
===================================================================
--- mono-dbg.h	(revision 0)
+++ mono-dbg.h	(revision 0)
@@ -0,0 +1,38 @@
+#ifndef __MONO_DBG_H__
+#define __MONO_DBG_H__
+
+#include "mono-dbg-arch.h"
+
+typedef struct _MonoDbgTarget MonoDbgTarget;
+typedef struct _MonoDbgContext MonoDbgContext;
+
+typedef enum {
+	MONO_DBG_TARGET_NO_FLAGS = 0
+} MonoDbgTargetFlags;
+
+typedef enum {
+	MONO_DBG_CONTEXT_GENERAL = 1 << 0,
+	MONO_DBG_CONTEXT_FP      = 1 << 1,
+	MONO_DBG_CONTEXT_EXT_FP  = 1 << 2,
+	MONO_DBG_CONTEXT_ALL     = 7
+} MonoDbgContexttFlags;
+
+MonoDbgTarget *mono_dbg_target_new     (void *process_id, MonoDbgTargetFlags flags);
+void           mono_dbg_target_free    (MonoDbgTarget *target);
+
+/* execution control */
+int mono_dbg_target_attach    (MonoDbgTarget *target);
+int mono_dbg_target_detach    (MonoDbgTarget *target);
+int mono_dbg_target_continue  (MonoDbgTarget *target);
+int mono_dbg_target_stop      (MonoDbgTarget *target);
+int mono_dbg_target_kill      (MonoDbgTarget *target);
+
+/* Target access functions: return 0 on success */
+int mono_dbg_target_read  (MonoDbgTarget *target, void *address, void **out_data);
+int mono_dbg_target_write (MonoDbgTarget *target, void *address, void *data);
+
+int mono_dbg_target_get_context (MonoDbgTarget *target, void *thread_id, MonoDbgContexttFlags flags, MonoDbgContext *context);
+int mono_dbg_target_set_context (MonoDbgTarget *target, void *thread_id, MonoDbgContexttFlags flags, MonoDbgContext *context);
+
+#endif /* __MONO_DBG_H__*/
+
Index: mono-dbg-arch.h
===================================================================
--- mono-dbg-arch.h	(revision 0)
+++ mono-dbg-arch.h	(revision 0)
@@ -0,0 +1,50 @@
+#ifndef __MONO_DBG_X86_H__
+#define __MONO_DBG_X86_H__
+
+#ifdef __i386__
+
+struct _MonoDbgContext {
+	unsigned long gregs [8];
+	unsigned long eflags;
+	unsigned long eip;
+	/* add segment regs? */
+	unsigned int fpdata [20];
+	/* add fp status/flags */
+	unsigned int xmmregs [32];
+};
+
+#elif defined(__x86_64__)
+
+struct _MonoDbgContext {
+	unsigned long gregs [16]; /* FIXME: win64 compat */
+	unsigned long eflags;
+	unsigned long eip;
+	/* add segment regs? */
+	unsigned int fpdata [20];
+	/* add fp status/flags */
+	unsigned int xmmregs [64];
+};
+
+#elif defined(__ppc__) || defined(__powerpc__)
+
+struct _MonoDbgContext {
+	unsigned long gregs [32];
+	unsigned long eflags;
+	unsigned long eip;
+	unsigned long ctr;
+	double fpdata [32];
+	/* add fp status/flags */
+};
+
+#else
+
+#define MONO_DBG_NO_CONTEXT 1
+
+struct _MonoDbgContext {
+	unsigned long dummy;
+};
+
+#endif
+
+#endif /* __MONO_DBG_X86_H__ */
+
Index: mono-dbg-x86.c
===================================================================
--- mono-dbg-x86.c	(revision 0)
+++ mono-dbg-x86.c	(revision 0)
@@ -0,0 +1,76 @@
+
+#include "mono-dbg-internals.h"
+
+#ifdef __i386__
+
+#include "mono/arch/x86/x86-codegen.h"
+
+#ifdef PLATFORM_WIN32
+int
+mono_dbg_target_get_context (MonoDbgTarget *target, void *thread_id, MonoDbgContexttFlags flags, MonoDbgContext *context)
+{
+	return -1;
+}
+
+int
+mono_dbg_target_set_context (MonoDbgTarget *target, void *thread_id, MonoDbgContexttFlags flags, MonoDbgContext *context)
+{
+	return -1;
+}
+
+#else
+
+int
+mono_dbg_target_get_context (MonoDbgTarget *target, void *thread_id, MonoDbgContexttFlags flags, MonoDbgContext *context)
+{
+	int result;
+	if (flags & MONO_DBG_CONTEXT_GENERAL) {
+		result = ptrace (PTRACE_GETREGS, thread_id? (pid_t)thread_id: target->process_id, 0, &target->uregs);
+		if (result)
+			return result;
+		context->gregs [X86_EAX] = target->uregs.eax;
+		context->gregs [X86_ECX] = target->uregs.ecx;
+		context->gregs [X86_EDX] = target->uregs.edx;
+		context->gregs [X86_EBX] = target->uregs.ebx;
+		context->gregs [X86_ESP] = target->uregs.esp;
+		context->gregs [X86_EBP] = target->uregs.ebp;
+		context->gregs [X86_ESI] = target->uregs.esi;
+		context->gregs [X86_EDI] = target->uregs.edi;
+		context->eflags = target->uregs.eflags;
+		context->eip = target->uregs.eip;
+	}
+	/* FIXME: fp registers... */
+	return 0;
+}
+
+int
+mono_dbg_target_set_context (MonoDbgTarget *target, void *thread_id, MonoDbgContexttFlags flags, MonoDbgContext *context)
+{
+	int result;
+	/* FIXME: make sure set and get context calls for different threads are not interleaved */
+	if (flags & MONO_DBG_CONTEXT_GENERAL) {
+		result = ptrace (PTRACE_GETREGS, thread_id? (pid_t)thread_id: target->process_id, 0, &target->uregs);
+		if (result)
+			return result;
+		target->uregs.eax = context->gregs [X86_EAX];
+		target->uregs.ecx = context->gregs [X86_ECX];
+		target->uregs.edx = context->gregs [X86_EDX];
+		target->uregs.ebx = context->gregs [X86_EBX];
+		target->uregs.esp = context->gregs [X86_ESP];
+		target->uregs.ebp = context->gregs [X86_EBP];
+		target->uregs.esi = context->gregs [X86_ESI];
+		target->uregs.edi = context->gregs [X86_EDI];
+		target->uregs.eflags = context->eflags;
+		target->uregs.eip = context->eip;
+		result = ptrace (PTRACE_SETREGS, thread_id? (pid_t)thread_id: target->process_id, 0, &target->uregs);
+		if (result)
+			return result;
+	}
+	/* FIXME: fp registers... */
+	return 0;
+}
+
+#endif /* PLATFORM_WIN32 */
+
+#endif
+
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 90752)
+++ Makefile.am	(working copy)
@@ -76,12 +76,15 @@
 bin_PROGRAMS = mono
 endif
 
-noinst_PROGRAMS = genmdesc
+noinst_PROGRAMS = genmdesc mono-dbg-test
 
-lib_LTLIBRARIES = libmono.la
+lib_LTLIBRARIES = libmono.la libmono-dbg.la
 noinst_LTLIBRARIES = libmono-static.la
 endif
 
+mono_dbg_test_SOURCES = mono-dbg-test.c
+mono_dbg_test_LDADD = libmono-dbg.la
+
 mono_SOURCES = \
 	main.c
 
@@ -376,6 +379,13 @@
 libmono_la_LIBADD = \
 	$(libs)
 
+libmono_dbg_la_SOURCES = mono-dbg.c mono-dbg-internals.h	\
+	mono-dbg-x86.c
+
+libmono_dbginclude_HEADERS = mono-dbg.h mono-dbg-arch.h
+
+libmono_dbgincludedir = $(includedir)/mono-$(API_VER)/mono/dbg
+
 %.exe: %.2.cs TestDriver.dll generics-variant-types.dll
 	$(GMCS) -out:$@ $< -r:TestDriver.dll -r:generics-variant-types.dll
 
Index: mono-dbg-test.c
===================================================================
--- mono-dbg-test.c	(revision 0)
+++ mono-dbg-test.c	(revision 0)
@@ -0,0 +1,65 @@
+#include "mono-dbg.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+static FILE* mypipe;
+static MonoDbgTarget* dtarget;
+
+static void
+print_regs (MonoDbgContext *context)
+{
+	int i;
+	printf ("registers:\n");
+	for (i = 0; i < 8; ++i) {
+		printf ("0x%08x\t%d\n", context->gregs [i], context->gregs [i]);
+	}
+	printf ("eip: 0x%08x, eflags: 0x%08x\n", context->eip, context->eflags);
+}
+
+static int
+start_proc (void)
+{
+	MonoDbgContext context;
+	char buf [128];
+	int pid;
+	mypipe = popen ("./dbg-test", "r");
+	if (!mypipe) {
+		perror ("fopen");
+		return 1;
+	}
+	if (!fgets (buf, sizeof (buf), mypipe))
+		return 2;
+	printf ("got buffer: %s\n", buf);
+	pid = atoi (buf);
+	if (!pid)
+		return 3;
+	dtarget = mono_dbg_target_new ((void*)pid, 0);
+	if (mono_dbg_target_attach (dtarget))
+		return 4;
+	if (mono_dbg_target_get_context (dtarget, 0, 0, &context)) {
+		mono_dbg_target_detach (dtarget);
+		return 5;
+	}
+	print_regs (&context);
+	mono_dbg_target_continue (dtarget);
+	sleep (1);
+	if (mono_dbg_target_stop (dtarget))
+		return 6;
+	if (mono_dbg_target_get_context (dtarget, 0, 0, &context)) {
+		mono_dbg_target_detach (dtarget);
+		return 7;
+	}
+	print_regs (&context);
+	mono_dbg_target_continue (dtarget);
+	mono_dbg_target_detach (dtarget);
+	fclose (mypipe);
+	return 0;
+}
+
+int
+main (int argc, char *argv[])
+{
+	return start_proc ();
+}
+
