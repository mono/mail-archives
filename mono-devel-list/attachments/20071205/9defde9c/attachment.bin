Index: DriveInfo.cs
===================================================================
--- DriveInfo.cs	(revision 90716)
+++ DriveInfo.cs	(working copy)
@@ -27,6 +27,7 @@
 using System.Text;
 using System.Runtime.Serialization;
 using System.Runtime.InteropServices;
+using Mono.Unix.Native;
 
 namespace System.IO {
 	[SerializableAttribute] 
@@ -36,6 +37,9 @@
 		DriveType drive_type;
 		string drive_format;
 		string path;
+		long availFree;
+		long totalFree;
+		long totalSize;
 
 		DriveInfo (_DriveType _drive_type, string path, string fstype)
 		{
@@ -57,6 +61,9 @@
 					this.drive_format = d.drive_format;
 					this.path = d.path;
 					this._drive_type = d._drive_type;
+					this.availFree = d.availFree;
+					this.totalFree = d.totalFree;
+					this.totalSize = d.totalSize;
 					return;
 				}
 			}
@@ -69,28 +76,25 @@
 			Windows,
 		}
 		
-		[MonoTODO("Always returns infinite")]
 		public long AvailableFreeSpace {
 			get {
-				if (DriveType == DriveType.CDRom || DriveType == DriveType.Ram || DriveType == DriveType.Unknown)
-					return 0;
-				return Int64.MaxValue;
+				//if (DriveType == DriveType.CDRom || DriveType == DriveType.Ram || DriveType == DriveType.Unknown)
+				//	return 0;
+				return availFree;
 			}
 		}
 
-		[MonoTODO("Always returns infinite")]
 		public long TotalFreeSpace {
 			get {
-				if (DriveType == DriveType.CDRom || DriveType == DriveType.Ram || DriveType == DriveType.Unknown)
-					return 0;
-				return Int64.MaxValue;
+				//if (DriveType == DriveType.CDRom || DriveType == DriveType.Ram || DriveType == DriveType.Unknown)
+				//	return 0;
+				return totalFree;
 			}
 		}
 
-		[MonoTODO("Always returns infinite")]
 		public long TotalSize {
 			get {
-				return Int64.MaxValue;
+				return totalSize;
 			}
 		}
 
@@ -199,6 +203,7 @@
 				string line;
 				
 				while ((line = mounts.ReadLine ()) != null){
+					// Skip the virtual, kernel-defined "root"
 					if (line.StartsWith ("rootfs"))
 						continue;
 					int p;
@@ -216,7 +221,20 @@
 					if (p == -1)
 						continue;
 					string fstype = rest.Substring (0, p);
-					drives.Add (new DriveInfo (_DriveType.Linux, path, fstype));
+					
+					// Identified a valid drive. Now call the kernel to get info about it
+					DriveInfo instance = new DriveInfo (_DriveType.Linux, path, fstype);
+					Statvfs statBuf = new Statvfs ();
+					int err = Syscall.statvfs (path, out statBuf);
+					if (0 == err) {
+						//Console.WriteLine(path);
+						//foreach (System.Reflection.FieldInfo field in typeof(Statvfs).GetFields ())
+						//	Console.WriteLine ("{0}:\t{1}", field.Name, field.GetValue (statBuf));
+						instance.totalSize = (long) (statBuf.f_blocks * statBuf.f_frsize);
+						instance.totalFree = (long) (statBuf.f_bfree * statBuf.f_frsize);
+						instance.availFree = (long) (statBuf.f_bavail * statBuf.f_frsize);
+						drives.Add (instance);
+					}
 				}
 
 				return (DriveInfo []) drives.ToArray (typeof (DriveInfo));
@@ -228,10 +246,10 @@
 			DriveInfo [] di = null;
 
 			try {
-				using (StreamReader linux_ostype = TryOpen ("/proc/sys/kernel/ostype")){
-					Console.WriteLine ("here {0}", linux_ostype);
-					if (linux_ostype != null){
-						string line = linux_ostype.ReadLine ();
+				using (StreamReader detect_ostype = TryOpen ("/proc/sys/kernel/ostype")){
+					Console.WriteLine ("here {0}", detect_ostype);
+					if (detect_ostype != null){
+						string line = detect_ostype.ReadLine ();
 
 						Console.WriteLine ("L: {0}", line);
 						if (line == "Linux")
@@ -260,8 +278,12 @@
 		[MonoTODO("Currently only implemented on Mono/Linux")]
 		public static DriveInfo[] GetDrives ()
 		{
-			int platform = (int) Environment.Platform;
+			int platform = (int) Environment.OSVersion.Platform;
 
+			// This ugly hack is required because the Unix platform enum value was not defined in .NET 1.0, so Mono
+			// assigned it a value presumably non-conflicting valule of 128, but then in .NET 2.0 Microsoft decided to
+			// include it and defined it as the next available enum value, that is, 4. So we check for both values, which
+			// should work for both versions 1 and 2+, without the need of an even uglier #if
 			if (platform == 4 || platform == 128)
 				return UnixGetDrives ();
 			else
