Index: ScriptElementAttribute.cs
===================================================================
--- ScriptElementAttribute.cs	(revision 0)
+++ ScriptElementAttribute.cs	(revision 0)
@@ -0,0 +1,56 @@
+ï»¿//
+// ScriptElementAttribute.cs
+//
+// Author:
+//   R. Tyler Ballance <tyler@monkeypox.org>
+//
+//   NOTE: This code was passed to me from James Newton-King, not 
+//   certain where he got it, but I'll reassign copyright as is 
+//   necessary
+//
+// (C) 2007 R. Tyler Ballance
+//
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace System.Web.Script.Serialization
+{
+	[AttributeUsage (AttributeTargets.Property | AttributeTargets.Field)]
+    public sealed class ScriptElementAttribute : Attribute
+    {
+        private string elementName;
+
+        public string ElementName
+        {
+            get { return elementName; }
+            set { elementName = value; }
+        }
+
+        public ScriptElementAttribute(string name)
+        {
+            elementName = name;
+        }
+    } 
+}
Index: JSON/ReflectionUtils.cs
===================================================================
--- JSON/ReflectionUtils.cs	(revision 85204)
+++ JSON/ReflectionUtils.cs	(working copy)
@@ -279,5 +279,80 @@
 			for (int i = 0; i < members.Length; i++)
 				yield return members [i];
 		}
+
+        public static T GetAttribute<T>(ICustomAttributeProvider attributeProvider) where T : Attribute
+        {
+            return GetAttribute<T>(attributeProvider, false, true);
+        }
+
+        public static T GetAttribute<T>(ICustomAttributeProvider attributeProvider, bool errorOnMultiple) where T : Attribute
+        {
+            return GetAttribute<T>(attributeProvider, errorOnMultiple, true);
+        }
+
+        public static T GetAttribute<T>(ICustomAttributeProvider attributeProvider, bool errorOnMultiple, bool inherit) where T : Attribute
+        {
+            T[] attributes = GetAttributes<T>(attributeProvider, inherit);
+
+            if (CollectionUtils.IsNullOrEmpty<T>(attributes))
+                return null;
+            else if (attributes.Length == 1)
+                return attributes[0];
+            else
+                throw new AmbiguousMatchException(string.Format("Multiple attributes of type '{0}' found.", typeof(T).Name));
+        }
+
+        public static T[] GetAttributes<T>(ICustomAttributeProvider attributeProvider, bool inherit) where T : Attribute
+        {
+            return (T[])attributeProvider.GetCustomAttributes(typeof(T), inherit);
+        }
+
+        /// <summary>
+        /// Tests whether the list's items are their unitialized value.
+        /// </summary>
+        /// <param name="list">The list.</param>
+        /// <returns>Whether the list's items are their unitialized value</returns>
+        public static bool ItemsUnitializedValue<T>(IList<T> list)
+        {
+            if (list == null)
+                throw new ArgumentNullException("values");
+
+            Type elementType = GetTypedListItemType(list.GetType());
+
+            if (elementType.IsValueType)
+            {
+                object unitializedValue = GetTypeUnitializedValue(elementType);
+
+                for (int i = 0; i < list.Count; i++)
+                {
+                    if (!list[i].Equals(unitializedValue))
+                        return false;
+                }
+            }
+            else if (elementType.IsClass)
+            {
+                for (int i = 0; i < list.Count; i++)
+                {
+                    if (list[i] != null)
+                        return false;
+                }
+            }
+            else
+            {
+                throw new ArgumentException("Type is neither a ValueType or a Class", "valueType");
+            }
+
+            return true;
+        }
+
+        public static object GetTypeUnitializedValue(Type type)
+        {
+            if (type.IsValueType)
+                return Activator.CreateInstance(type);
+            else if (type.IsClass)
+                return null;
+            else
+                throw new ArgumentException("Type is neither a ValueType or a Class", "type");
+        }
     }
 }
Index: JSON/CollectionUtils.cs
===================================================================
--- JSON/CollectionUtils.cs	(revision 0)
+++ JSON/CollectionUtils.cs	(revision 0)
@@ -0,0 +1,76 @@
+#region License
+// Copyright 2006 James Newton-King
+// http://www.newtonsoft.com
+//
+// This work is licensed under the Creative Commons Attribution 2.5 License
+// http://creativecommons.org/licenses/by/2.5/
+//
+// You are free:
+//    * to copy, distribute, display, and perform the work
+//    * to make derivative works
+//    * to make commercial use of the work
+//
+// Under the following conditions:
+//    * You must attribute the work in the manner specified by the author or licensor:
+//          - If you find this component useful a link to http://www.newtonsoft.com would be appreciated.
+//    * For any reuse or distribution, you must make clear to others the license terms of this work.
+//    * Any of these conditions can be waived if you get permission from the copyright holder.
+#endregion
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Collections;
+
+namespace Newtonsoft.Json.Utilities
+{
+    internal static class CollectionUtils
+    {
+        /// <summary>
+        /// Determines whether the collection is null or empty.
+        /// </summary>
+        /// <param name="collection">The collection.</param>
+        /// <returns>
+        /// 	<c>true</c> if the collection is null or empty; otherwise, <c>false</c>.
+        /// </returns>
+        public static bool IsNullOrEmpty(ICollection collection)
+        {
+            if (collection != null)
+            {
+                return (collection.Count == 0);
+            }
+            return true;
+        }
+
+        /// <summary>
+        /// Determines whether the collection is null or empty.
+        /// </summary>
+        /// <param name="collection">The collection.</param>
+        /// <returns>
+        /// 	<c>true</c> if the collection is null or empty; otherwise, <c>false</c>.
+        /// </returns>
+        public static bool IsNullOrEmpty<T>(ICollection<T> collection)
+        {
+            if (collection != null)
+            {
+                return (collection.Count == 0);
+            }
+            return true;
+        }
+
+        /// <summary>
+        /// Determines whether the collection is null, empty or its contents are uninitialized values.
+        /// </summary>
+        /// <param name="collection">The collection.</param>
+        /// <returns>
+        /// 	<c>true</c> if the collection is null or empty or its contents are uninitialized values; otherwise, <c>false</c>.
+        /// </returns>
+        public static bool IsNullOrEmptyOrDefault<T>(IList<T> list)
+        {
+            if (IsNullOrEmpty<T>(list))
+                return true;
+
+            return ReflectionUtils.ItemsUnitializedValue<T>(list);
+        }
+    }
+}

Property changes on: JSON/CollectionUtils.cs
___________________________________________________________________
Name: svn:executable
   + *

Index: JSON/JsonSerializer.cs
===================================================================
--- JSON/JsonSerializer.cs	(revision 85204)
+++ JSON/JsonSerializer.cs	(working copy)
@@ -78,9 +78,15 @@
 
 			protected override IEnumerator<KeyValuePair<string, object>> GetEnumerator () {
 				foreach (MemberInfo member in ReflectionUtils.GetFieldsAndProperties (_source.GetType (), BindingFlags.Public | BindingFlags.Instance)) {
-					if (ReflectionUtils.CanReadMemberValue (member) && !member.IsDefined (typeof (ScriptIgnoreAttribute), true))
-						if (!ReflectionUtils.IsIndexedProperty (member))
-							yield return new KeyValuePair<string, object> (member.Name, ReflectionUtils.GetMemberValue (member, _source));
+					if (ReflectionUtils.CanReadMemberValue (member) && !member.IsDefined (typeof (ScriptIgnoreAttribute), true)) {
+						if (!ReflectionUtils.IsIndexedProperty (member)) {
+                            string name = member.Name;
+                            if (member.IsDefined(typeof(ScriptElementAttribute), true)) {
+                                name = ReflectionUtils.GetAttribute<ScriptElementAttribute>(member).ElementName;
+                            }   
+							yield return new KeyValuePair<string, object> (name, ReflectionUtils.GetMemberValue (member, _source));
+                        } 
+                    } 
 				}
 			}
 		}
