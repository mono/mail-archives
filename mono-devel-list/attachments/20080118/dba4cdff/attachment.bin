Index: Test/System.Collections.ObjectModel/ChangeLog
===================================================================
--- Test/System.Collections.ObjectModel/ChangeLog	(revision 93146)
+++ Test/System.Collections.ObjectModel/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2008-01-18  Juraj Skripsky  <js@hotfeet.ch>
+
+	* ReadOnlyCollectionTest.cs: Add test to verify that ReadOnlyCollection
+	is indeed only a simple wrapper for a given IList.
+	Add tests for ICollection.IsSynchronized, ICollection.SyncRoot,
+	IList.IsFixedSize and IList.IsReadOnly.
+
 2008-01-13  Gert Driesen  <drieseng@users.sourceforge.net>
 
 	* CollectionTest.cs: Added test for ICollection.CopyTo.
Index: Test/System.Collections.ObjectModel/ReadOnlyCollectionTest.cs
===================================================================
--- Test/System.Collections.ObjectModel/ReadOnlyCollectionTest.cs	(revision 93146)
+++ Test/System.Collections.ObjectModel/ReadOnlyCollectionTest.cs	(working copy)
@@ -38,6 +38,13 @@
 
 namespace MonoTests.System.Collections.ObjectModel
 {
+	class SyncPretendingList<T> : List<T>, ICollection
+	{
+		bool ICollection.IsSynchronized {
+			get { return true; }
+		}
+	}
+
 	[TestFixture]
 	public class ReadOnlyCollectionTest
 	{
@@ -52,8 +59,43 @@
 			Assert.AreEqual (10, r [0], "#1");
 			Assert.AreEqual (7, r [1], "#2");
 		}
+		
+		[Test]
+		public void IsSimpleWrapper ()
+		{
+			Collection <int> c = new Collection <int> ();
+			c.Add (1);
+			
+			ReadOnlyCollection <int> r = new ReadOnlyCollection <int> (c);
+			Assert.AreEqual (1, r.Count, "#1");			
 
+			c.Remove (1);
+			Assert.AreEqual (0, r.Count, "#2");			
+		}
+		
 		[Test]
+		public void IList_Properties ()
+		{
+			List <int> l = new List <int> ();
+			ReadOnlyCollection <int> r = new ReadOnlyCollection <int> (l);
+
+			Assert.IsTrue (((IList)r).IsReadOnly, "#1");
+			Assert.IsTrue (((IList)r).IsFixedSize, "#2");
+		}
+		
+		[Test]
+		public void ICollection_Properties ()
+		{
+			List <int> l = new SyncPretendingList <int> ();
+			ReadOnlyCollection <int> r = new ReadOnlyCollection <int> (l);
+
+			Assert.IsFalse (((ICollection)r).IsSynchronized, "#1");
+			// LAMESPEC: According to the docs, (r == r.SyncRoot) should be true 
+			Assert.IsFalse (Object.ReferenceEquals (r, ((ICollection)r).SyncRoot), "#2");
+			Assert.IsFalse (Object.ReferenceEquals (l, ((ICollection)r).SyncRoot), "#3");
+		}
+
+		[Test]
 		public void Constructor0_List_Null ()
 		{
 			try {
Index: System.Collections.ObjectModel/ChangeLog
===================================================================
--- System.Collections.ObjectModel/ChangeLog	(revision 93146)
+++ System.Collections.ObjectModel/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2008-01-18  Juraj Skripsky  <js@hotfeet.ch>
+
+	* ReadOnlyCollection.cs: Fix the getters for ICollection.IsSynchronized,
+	ICollection.SyncRoot and IList.IsFixedSize to match MS.NET.
+
 2008-01-13  Juraj Skripsky  <js@hotfeet.ch>
 
 	* Collection.cs, ReadonlyCollection.cs (ICollection.CopyTo):
Index: System.Collections.ObjectModel/ReadOnlyCollection.cs
===================================================================
--- System.Collections.ObjectModel/ReadOnlyCollection.cs	(revision 93146)
+++ System.Collections.ObjectModel/ReadOnlyCollection.cs	(working copy)
@@ -53,8 +53,6 @@
 			if (list == null)
 				throw new ArgumentNullException ("list");
 			this.list = list;
-			ICollection c = list as ICollection;
-			syncRoot = (c != null) ? c.SyncRoot : new object ();
 		}
 
 		void ICollection<T>.Add (T item)
@@ -174,15 +172,16 @@
 		}
 
 		bool ICollection.IsSynchronized {
-			get { return Collection <T>.IsSynchronized (list); }
+			get { return false; }
 		}
 		
+		// LAMESPEC: According to the docs, this should return "this".
 		object ICollection.SyncRoot {
-			get { return syncRoot; }
+			get { return syncRoot ?? syncRoot = new object(); }
 		}
 
 		bool IList.IsFixedSize {
-			get { return Collection <T>.IsFixedSize (list); }
+			get { return true; }
 		}
 		
 		bool IList.IsReadOnly {
