<tt>
&lt;div&nbsp;dir=&quot;ltr&quot;&gt;Hey&nbsp;Mark,&lt;br&gt;&lt;br&gt;&lt;div&nbsp;class=&quot;gmail_quote&quot;&gt;2008/9/25&nbsp;Mark&nbsp;Probst&nbsp;&lt;span&nbsp;dir=&quot;ltr&quot;&gt;&amp;lt;&lt;a&nbsp;href=&quot;mailto:mark.probst@gmail.com&quot;&gt;mark.probst@gmail.com&lt;/a&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;blockquote&nbsp;class=&quot;gmail_quote&quot;&nbsp;style=&quot;border-left:&nbsp;1px&nbsp;solid&nbsp;rgb(204,&nbsp;204,&nbsp;204);&nbsp;margin:&nbsp;0pt&nbsp;0pt&nbsp;0pt&nbsp;0.8ex;&nbsp;padding-left:&nbsp;1ex;&quot;&gt;<br>
Hey&nbsp;everybody,&lt;br&gt;<br>
&lt;br&gt;<br>
This&nbsp;is&nbsp;my&nbsp;second&nbsp;attempt&nbsp;at&nbsp;implementing&nbsp;fast&nbsp;virtual&nbsp;generic&nbsp;method&lt;br&gt;<br>
calls.&nbsp;&amp;nbsp;The&nbsp;implementation&nbsp;is&nbsp;very&nbsp;close&nbsp;to&nbsp;Paolo&amp;#39;s&nbsp;proposal&nbsp;here:&lt;br&gt;<br>
&lt;br&gt;<br>
&nbsp;&amp;nbsp;&lt;a&nbsp;href=&quot;https://bugzilla.novell.com/show_bug.cgi?id=324481&quot;&nbsp;target=&quot;_blank&quot;&gt;https://bugzilla.novell.com/show_bug.cgi?id=324481&lt;/a&gt;&lt;br&gt;<br>
&lt;br&gt;<br>
The&nbsp;main&nbsp;difference&nbsp;is&nbsp;that&nbsp;I&nbsp;don&amp;#39;t&nbsp;hash&nbsp;the&nbsp;methods&nbsp;into&nbsp;slots&nbsp;but&nbsp;use&lt;br&gt;<br>
the&nbsp;(until&nbsp;now&nbsp;unused)&nbsp;&amp;quot;normal&amp;quot;&nbsp;vtable&nbsp;slots&nbsp;for&nbsp;the&nbsp;thunks.&nbsp;&amp;nbsp;This&nbsp;is&lt;br&gt;<br>
necessary&nbsp;because&nbsp;with&nbsp;generic&nbsp;code&nbsp;sharing&nbsp;the&nbsp;method&nbsp;signature&nbsp;is&nbsp;not&lt;br&gt;<br>
known&nbsp;statically.&lt;br&gt;<br>
&lt;/blockquote&gt;&lt;div&gt;&lt;br&gt;Makes&nbsp;sense,&nbsp;the&nbsp;space&nbsp;is&nbsp;already&nbsp;these.&nbsp;Does&nbsp;it&nbsp;handle&nbsp;dispatching&nbsp;of&nbsp;&lt;br&gt;interface&nbsp;generic&nbsp;methods?&nbsp;The&nbsp;code&nbsp;in&nbsp;method-to-ir.c&nbsp;suggests&nbsp;not.&lt;br&gt;&lt;br&gt;&amp;nbsp;&lt;br&gt;&lt;/div&gt;&lt;blockquote&nbsp;class=&quot;gmail_quote&quot;&nbsp;style=&quot;border-left:&nbsp;1px&nbsp;solid&nbsp;rgb(204,&nbsp;204,&nbsp;204);&nbsp;margin:&nbsp;0pt&nbsp;0pt&nbsp;0pt&nbsp;0.8ex;&nbsp;padding-left:&nbsp;1ex;&quot;&gt;<br>
&lt;br&gt;<br>
A&nbsp;big&nbsp;problem&nbsp;with&nbsp;this&nbsp;implementation&nbsp;is&nbsp;the&nbsp;memory&nbsp;management&nbsp;of&nbsp;the&lt;br&gt;<br>
thunks.&nbsp;&amp;nbsp;Since&nbsp;thunks&nbsp;become&nbsp;obsolete&nbsp;when&nbsp;new&nbsp;method&nbsp;instantiations&nbsp;are&lt;br&gt;<br>
added&nbsp;we&nbsp;have&nbsp;to&nbsp;reclaim&nbsp;their&nbsp;memory.&nbsp;&amp;nbsp;We&nbsp;can&nbsp;only&nbsp;do&nbsp;this&nbsp;safely&nbsp;if&nbsp;we&lt;br&gt;<br>
know&nbsp;that&nbsp;no&nbsp;thread&nbsp;is&nbsp;still&nbsp;executing&nbsp;the&nbsp;thunk&nbsp;code.&nbsp;&amp;nbsp;The&nbsp;current&lt;br&gt;<br>
solution&nbsp;is&nbsp;a&nbsp;hack:&nbsp;Freed&nbsp;thunks&nbsp;are&nbsp;queued&nbsp;until&nbsp;there&nbsp;are&nbsp;50&nbsp;of&nbsp;them,&lt;br&gt;<br>
at&nbsp;which&nbsp;point&nbsp;for&nbsp;each&nbsp;new&nbsp;freed&nbsp;thunk&nbsp;we&nbsp;reclaim&nbsp;the&nbsp;oldest&nbsp;one&nbsp;in&nbsp;the&lt;br&gt;<br>
queue.&nbsp;&amp;nbsp;The&nbsp;other&nbsp;problem&nbsp;with&nbsp;this&nbsp;approach&nbsp;is&nbsp;that&nbsp;if&nbsp;there&nbsp;are&nbsp;only&nbsp;a&lt;br&gt;<br>
few&nbsp;thunks&nbsp;which&nbsp;grow&nbsp;and&nbsp;grow&nbsp;we&nbsp;won&amp;#39;t&nbsp;be&nbsp;able&nbsp;to&nbsp;reuse&nbsp;the&nbsp;freed&nbsp;small&lt;br&gt;<br>
pieces,&nbsp;i.e.&nbsp;a&nbsp;program&nbsp;can&nbsp;easily&nbsp;make&nbsp;us&nbsp;use&nbsp;an&nbsp;arbitrary&nbsp;amount&nbsp;of&lt;br&gt;<br>
memory&nbsp;by&nbsp;having&nbsp;a&nbsp;single&nbsp;virtual&nbsp;generic&nbsp;method&nbsp;which&nbsp;is&nbsp;instantiated&lt;br&gt;<br>
with&nbsp;a&nbsp;large&nbsp;number&nbsp;of&nbsp;different&nbsp;type&nbsp;arguments&nbsp;(easy&nbsp;to&nbsp;do&lt;br&gt;<br>
recursively).&lt;br&gt;<br>
&lt;br&gt;<br>
One&nbsp;solution&nbsp;I&nbsp;have&nbsp;to&nbsp;the&nbsp;latter&nbsp;issue&nbsp;is&nbsp;by&nbsp;splitting&nbsp;the&nbsp;thunks&nbsp;into&lt;br&gt;<br>
small&nbsp;fixed-size&nbsp;code&nbsp;pieces,&nbsp;in&nbsp;the&nbsp;simplest&nbsp;case&nbsp;one&nbsp;piece&nbsp;per&lt;br&gt;<br>
decision-tree&nbsp;node.&nbsp;&amp;nbsp;Not&nbsp;difficult&nbsp;to&nbsp;implement.&nbsp;&amp;nbsp;Another&nbsp;solution&nbsp;would&lt;br&gt;<br>
be&nbsp;to&nbsp;have&nbsp;a&nbsp;code&nbsp;manager&nbsp;which&nbsp;permits&nbsp;freeing&nbsp;items&nbsp;:-)&lt;br&gt;<br>
&lt;br&gt;<br>
The&nbsp;patch&nbsp;currently&nbsp;only&nbsp;supports&nbsp;x86.&lt;br&gt;<br>
&lt;font&nbsp;color=&quot;#888888&quot;&gt;&lt;/font&gt;&lt;/blockquote&gt;&lt;div&gt;&lt;br&gt;&lt;br&gt;Since&nbsp;you&nbsp;have&nbsp;a&nbsp;hashtable&nbsp;with&nbsp;the&nbsp;expansions,&nbsp;what&nbsp;about&nbsp;introducing&nbsp;a&nbsp;limit&lt;br&gt;on&nbsp;the&nbsp;number&nbsp;of&nbsp;trunks&nbsp;per&nbsp;method,&nbsp;this&nbsp;change&nbsp;should&nbsp;not&nbsp;be&nbsp;hard.&lt;br&gt;&lt;br&gt;Have&nbsp;you&nbsp;thought&nbsp;about&nbsp;using&nbsp;something&nbsp;else&nbsp;than&nbsp;a&nbsp;MonoMethod&nbsp;as&nbsp;key?&nbsp;We&nbsp;could,&lt;br&gt;<br>
for&nbsp;example,&nbsp;use&nbsp;the&nbsp;following&nbsp;scheme:&lt;br&gt;&lt;br&gt;Right&nbsp;now&nbsp;it&amp;#39;s&nbsp;only&nbsp;possible&nbsp;to&nbsp;share&nbsp;if&nbsp;all&nbsp;instantiations&nbsp;are&nbsp;reference&nbsp;types.&nbsp;I&nbsp;guess&nbsp;we&lt;br&gt;can&nbsp;determine&nbsp;if&nbsp;the&nbsp;method&nbsp;is&nbsp;shareable&nbsp;on&nbsp;first&nbsp;compilation,&nbsp;which&nbsp;is&nbsp;before&nbsp;any&nbsp;trunk&nbsp;code&lt;br&gt;<br>
is&nbsp;generated.&lt;br&gt;&lt;br&gt;Given&nbsp;that&nbsp;we&nbsp;know&nbsp;this,&nbsp;we&nbsp;could&nbsp;store&nbsp;in&nbsp;the&nbsp;upper&nbsp;bit&nbsp;of&nbsp;the&nbsp;tokens&nbsp;used&nbsp;for&nbsp;resolving&nbsp;the&nbsp;trunk&lt;br&gt;if&nbsp;they&nbsp;refer&nbsp;to&nbsp;a&nbsp;sharable&nbsp;instantiation.&nbsp;Then&nbsp;on&nbsp;trunk&nbsp;code,&nbsp;if&nbsp;the&nbsp;method&nbsp;is&nbsp;sharable&lt;br&gt;we&nbsp;check&nbsp;this&nbsp;bit&nbsp;and&nbsp;avoid&nbsp;generating&nbsp;tons&nbsp;of&nbsp;trunks.&lt;br&gt;<br>
&lt;br&gt;But&nbsp;even&nbsp;with&nbsp;that&nbsp;we&nbsp;would&nbsp;still&nbsp;need&nbsp;to&nbsp;generate&nbsp;trunks.&nbsp;If&nbsp;we&nbsp;generate&nbsp;then&nbsp;partially,&nbsp;as&nbsp;you&nbsp;suggest,&lt;br&gt;for&nbsp;each&nbsp;decision&nbsp;node,&nbsp;I&nbsp;can&amp;#39;t&nbsp;think&nbsp;how&nbsp;the&nbsp;current&nbsp;scheme&nbsp;would&nbsp;allow&nbsp;for&nbsp;making&nbsp;it&nbsp;balanced.&lt;br&gt;&lt;br&gt;<br>
I&nbsp;guess&nbsp;it&nbsp;would&nbsp;be&nbsp;doable&nbsp;if&nbsp;we&nbsp;stored&nbsp;the&nbsp;keys&nbsp;in&nbsp;an&nbsp;array&nbsp;not&nbsp;part&nbsp;of&nbsp;the&nbsp;code,&nbsp;as&nbsp;sorting&nbsp;it&nbsp;would&nbsp;not&lt;br&gt;mean&nbsp;doing&nbsp;a&nbsp;lot&nbsp;of&nbsp;code&nbsp;modification,&nbsp;so&nbsp;no&nbsp;icache&nbsp;flushes&nbsp;unless&nbsp;we&nbsp;wanted&nbsp;to&nbsp;link&nbsp;a&nbsp;new&nbsp;trunk&nbsp;block&lt;br&gt;in&nbsp;the&nbsp;tree&nbsp;and&nbsp;each&nbsp;trunk&nbsp;block&nbsp;could&nbsp;be&nbsp;a&nbsp;15&nbsp;entries&nbsp;decision&nbsp;tree.&lt;br&gt;<br>
&lt;br&gt;&lt;br&gt;Cheers,&lt;br&gt;Rodrigo&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;<br>

</tt>
