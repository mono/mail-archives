Index: src/mod_mono.c
===================================================================
--- src/mod_mono.c	(revision 40927)
+++ src/mod_mono.c	(working copy)
@@ -229,6 +229,12 @@
 	ap_rwrite (byteArray, size, r);
 }
 
+static void
+request_send_response_string (request_rec *r, char *byteArray)
+{
+	request_send_response_from_memory (r, byteArray, strlen(byteArray) );
+}
+
 /* Not connection because actual port will vary depending on Apache configuration */
 static int
 request_get_server_port (request_rec *r)
@@ -1147,19 +1153,14 @@
 }
 
 static apr_status_t
-terminate_xsp (void *data)
+terminate_and_restart_xsp (module_cfg *config, int restart)
 {
-	server_rec *server = (server_rec *) data;
-	module_cfg *config;
 	apr_socket_t *sock;
 	apr_status_t rv;
 	char *termstr = "";
 	xsp_data *xsp;
 	int i;
 
-	DEBUG_PRINT (0, "Terminate XSP");
-
-	config = ap_get_module_config (server->module_config, &mono_module);
 	for (i = 0; i < config->nservers; i++) {
 		xsp = &config->servers [i];
 		if (xsp->run_xsp && !strcasecmp (xsp->run_xsp, "false"))
@@ -1175,6 +1176,11 @@
 
 		if (xsp->listen_port == NULL && xsp->filename != NULL)
 			remove (xsp->filename); /* Don't bother checking error */
+		
+		if (restart) {
+			apr_sleep (apr_time_from_sec (1)); // make sure the server really quit
+			fork_mod_mono_server (pconf, xsp);
+		}
 	}
 
 	apr_sleep (apr_time_from_sec (1));
@@ -1183,6 +1189,60 @@
 	return APR_SUCCESS;
 }
 
+static apr_status_t
+terminate_xsp (void *data)
+{
+	server_rec *server;
+	module_cfg *config;
+
+	DEBUG_PRINT (0, "Terminate XSP");
+	server = (server_rec *) data;
+	config = ap_get_module_config (server->module_config, &mono_module);
+
+	terminate_and_restart_xsp(config, 0);
+}
+
+static int
+mono_control_panel_handler (request_rec *r)
+{
+	module_cfg *config;
+	apr_uri_t uri;
+
+	if (strcmp (r->handler, "mono-ctrl"))
+		return DECLINED;
+
+	DEBUG_PRINT (1, "control panel handler: %s", r->handler);
+
+	config = ap_get_module_config (r->server->module_config, &mono_module);
+	
+	set_response_header(r, "Content-Type", "text/html");
+
+	request_send_response_string(r, "<html><body>\n");
+	request_send_response_string(r, "<h1>Mod_Mono Control Panel</h1>\n");
+	
+	uri = r->parsed_uri;
+	if (!uri.query || !strcmp (uri.query, "")) {
+		// No query string -> Emit links for configuration commands.
+		request_send_response_string(r, "<li><a href=\"?restart\">Restart mod-mono-server Processes</a></li>\n");
+	} else {
+		if (!strcmp (uri.query, "restart")) {
+			// Restart the mod-mono-server processes
+			terminate_and_restart_xsp(config, 1);
+			request_send_response_string(r, "<p>mod-mono-server processes restarted.</p>\n");
+		} else {
+			// Invalid command.
+			request_send_response_string(r, "<p>Invalid query string command.</p>\n");
+		}
+	
+		request_send_response_string(r, "<p><a href=\"?\">Return to Control Panel</a></p>\n");
+	}
+	
+	request_send_response_string(r, "</body></html>\n");
+
+	DEBUG_PRINT (2, "Done.");
+	return OK;
+}
+
 #ifdef APACHE13
 static void
 mono_init_handler (server_rec *s, pool *p)
@@ -1250,6 +1310,7 @@
 #ifdef APACHE13
 static const handler_rec mono_handlers [] = {
 	{ "mono", mono_handler },
+	{ "mono-ctrl", mono_control_panel_handler },
 	{ NULL, NULL }
 };
 #else
@@ -1257,6 +1318,7 @@
 mono_register_hooks (apr_pool_t * p)
 {
 	ap_hook_handler (mono_handler, NULL, NULL, APR_HOOK_FIRST);
+	ap_hook_handler (mono_control_panel_handler, NULL, NULL, APR_HOOK_FIRST);
 	ap_hook_post_config (mono_init_handler, NULL, NULL, APR_HOOK_MIDDLE);
 	ap_hook_child_init (mono_child_init, NULL, NULL, APR_HOOK_MIDDLE);
 }
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 40927)
+++ ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2005-02-20 Joshua Tauberer <tauberer@for.net>
+
+	* src/mod_mono.c: Created a simplistic control panel handler
+	for requests handled with the mono-ctrl handler.  It supports
+	restarting any running mod-mono-server processes.
+
 2005-02-16 Gonzalo Paniagua Javier <gonzalo@ximian.com>
 
 	* src/mod_mono.c: prevent execution of 'init' twice (parent and child)
