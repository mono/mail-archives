Index: reflection.h
===================================================================
--- reflection.h	(revisión: 40470)
+++ reflection.h	(copia de trabajo)
@@ -63,10 +63,12 @@
 MonoObject* mono_get_dbnull_object (MonoDomain *domain);
 
 MonoArray*  mono_reflection_get_custom_attrs (MonoObject *obj);
+MonoArray*  mono_reflection_get_custom_attrs_data (MonoObject *obj);
 MonoArray*  mono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *porpValues, MonoArray *fields, MonoArray* fieldValues);
 
 MonoCustomAttrInfo* mono_reflection_get_custom_attrs_info (MonoObject *obj);
 MonoArray*  mono_custom_attrs_construct (MonoCustomAttrInfo *cinfo);
+MonoArray*  mono_custom_attrs_data_construct (MonoCustomAttrInfo *cinfo);
 MonoCustomAttrInfo* mono_custom_attrs_from_index    (MonoImage *image, guint32 idx);
 MonoCustomAttrInfo* mono_custom_attrs_from_method   (MonoMethod *method);
 MonoCustomAttrInfo* mono_custom_attrs_from_class    (MonoClass *klass);
Index: appdomain.c
===================================================================
--- appdomain.c	(revisión: 40470)
+++ appdomain.c	(copia de trabajo)
@@ -83,8 +83,10 @@
 	mono_thread_pool_init ();
 	mono_marshal_init ();
 
-	mono_install_assembly_preload_hook (mono_domain_assembly_preload, NULL);
-	mono_install_assembly_search_hook (mono_domain_assembly_search, NULL);
+	mono_install_assembly_preload_hook (mono_domain_assembly_preload, GUINT_TO_POINTER (FALSE));
+	mono_install_assembly_refonly_preload_hook (mono_domain_assembly_preload, GUINT_TO_POINTER (TRUE));
+	mono_install_assembly_search_hook (mono_domain_assembly_search, GUINT_TO_POINTER (FALSE));
+	mono_install_assembly_refonly_search_hook (mono_domain_assembly_search, GUINT_TO_POINTER (TRUE));
 	mono_install_assembly_load_hook (mono_domain_fire_assembly_load, NULL);
 	mono_install_lookup_dynamic_token (mono_reflection_lookup_dynamic_token);
 
@@ -441,7 +443,7 @@
 }
 
 MonoArray *
-ves_icall_System_AppDomain_GetAssemblies (MonoAppDomain *ad)
+ves_icall_System_AppDomain_GetAssemblies (MonoAppDomain *ad, MonoBoolean refonly)
 {
 	MonoDomain *domain = ad->data; 
 	MonoAssembly* ass;
@@ -461,6 +463,8 @@
 	mono_domain_lock (domain);
 	for (tmp = domain->domain_assemblies; tmp; tmp = tmp->next) {
 		ass = tmp->data;
+		if (refonly && !ass->ref_only)
+			continue;
 		if (!ass->corlib_internal)
 			count++;
 	}
@@ -468,6 +472,8 @@
 	i = 0;
 	for (tmp = domain->domain_assemblies; tmp; tmp = tmp->next) {
 		ass = tmp->data;
+		if (refonly && !ass->ref_only)
+			continue;
 		if (ass->corlib_internal)
 			continue;
 		mono_array_set (res, gpointer, i, mono_assembly_get_object (domain, ass));
@@ -479,11 +485,12 @@
 }
 
 static MonoReflectionAssembly *
-try_assembly_resolve (MonoDomain *domain, MonoString *fname)
+try_assembly_resolve (MonoDomain *domain, MonoString *fname, gboolean refonly)
 {
 	MonoClass *klass;
 	MonoMethod *method;
-	void *params [1];
+	MonoBoolean isrefonly;
+	gpointer params [2];
 
 	g_assert (domain != NULL && fname != NULL);
 
@@ -496,7 +503,9 @@
 		return NULL;
 	}
 
-	*params = fname;
+	isrefonly = refonly ? 1 : 0;
+	params [0] = fname;
+	params [1] = &isrefonly;
 	return (MonoReflectionAssembly *) mono_runtime_invoke (method, domain->domain, params, NULL);
 }
 
@@ -737,21 +746,21 @@
 
 static gboolean
 try_load_from (MonoAssembly **assembly, const gchar *path1, const gchar *path2,
-					const gchar *path3, const gchar *path4)
+					const gchar *path3, const gchar *path4, gboolean refonly)
 {
 	gchar *fullpath;
 
 	*assembly = NULL;
 	fullpath = g_build_filename (path1, path2, path3, path4, NULL);
 	if (g_file_test (fullpath, G_FILE_TEST_IS_REGULAR))
-		*assembly = mono_assembly_open (fullpath, NULL);
+		*assembly = mono_assembly_open_full (fullpath, NULL, refonly);
 
 	g_free (fullpath);
 	return (*assembly != NULL);
 }
 
 static MonoAssembly *
-real_load (gchar **search_path, const gchar *culture, const gchar *name)
+real_load (gchar **search_path, const gchar *culture, const gchar *name, gboolean refonly)
 {
 	MonoAssembly *result = NULL;
 	gchar **path;
@@ -775,22 +784,22 @@
 		/* See test cases in bug #58992 and bug #57710 */
 		/* 1st try: [culture]/[name].dll (culture may be empty) */
 		strcpy (filename + len - 4, ".dll");
-		if (try_load_from (&result, *path, local_culture, "", filename))
+		if (try_load_from (&result, *path, local_culture, "", filename, refonly))
 			break;
 
 		/* 2nd try: [culture]/[name].exe (culture may be empty) */
 		strcpy (filename + len - 4, ".exe");
-		if (try_load_from (&result, *path, local_culture, "", filename))
+		if (try_load_from (&result, *path, local_culture, "", filename, refonly))
 			break;
 
 		/* 3rd try: [culture]/[name]/[name].dll (culture may be empty) */
 		strcpy (filename + len - 4, ".dll");
-		if (try_load_from (&result, *path, local_culture, name, filename))
+		if (try_load_from (&result, *path, local_culture, name, filename, refonly))
 			break;
 
 		/* 4th try: [culture]/[name]/[name].exe (culture may be empty) */
 		strcpy (filename + len - 4, ".exe");
-		if (try_load_from (&result, *path, local_culture, name, filename))
+		if (try_load_from (&result, *path, local_culture, name, filename, refonly))
 			break;
 	}
 
@@ -809,15 +818,16 @@
 {
 	MonoDomain *domain = mono_domain_get ();
 	MonoAssembly *result = NULL;
+	gboolean refonly = GPOINTER_TO_UINT (user_data);
 
 	set_domain_search_path (domain);
 
 	if (domain->search_path && domain->search_path [0] != NULL) {
-		result = real_load (domain->search_path, aname->culture, aname->name);
+		result = real_load (domain->search_path, aname->culture, aname->name, refonly);
 	}
 
 	if (result == NULL && assemblies_path && assemblies_path [0] != NULL) {
-		result = real_load (assemblies_path, aname->culture, aname->name);
+		result = real_load (assemblies_path, aname->culture, aname->name, refonly);
 	}
 
 	return result;
@@ -833,12 +843,13 @@
 	MonoDomain *domain = mono_domain_get ();
 	GSList *tmp;
 	MonoAssembly *ass;
+	gboolean refonly = GPOINTER_TO_UINT (user_data);
 
 	mono_domain_lock (domain);
 	for (tmp = domain->domain_assemblies; tmp; tmp = tmp->next) {
 		ass = tmp->data;
 		/* Dynamic assemblies can't match here in MS.NET */
-		if (ass->dynamic || !mono_assembly_names_equal (aname, &ass->aname))
+		if (ass->dynamic || refonly != ass->ref_only || !mono_assembly_names_equal (aname, &ass->aname))
 			continue;
 
 		mono_domain_unlock (domain);
@@ -850,7 +861,7 @@
 }
 
 MonoReflectionAssembly *
-ves_icall_System_Reflection_Assembly_LoadFrom (MonoString *fname)
+ves_icall_System_Reflection_Assembly_LoadFrom (MonoString *fname, MonoBoolean refOnly)
 {
 	MonoDomain *domain = mono_domain_get ();
 	char *name, *filename;
@@ -866,7 +877,7 @@
 		
 	name = filename = mono_string_to_utf8 (fname);
 
-	ass = mono_assembly_open (filename, &status);
+	ass = mono_assembly_open_full (filename, &status, refOnly);
 	
 	g_free (name);
 
@@ -970,7 +981,8 @@
 MonoReflectionAssembly *
 ves_icall_System_AppDomain_LoadAssemblyRaw (MonoAppDomain *ad, 
 											MonoArray *raw_assembly,
-											MonoArray *raw_symbol_store, MonoObject *evidence)
+											MonoArray *raw_symbol_store, MonoObject *evidence,
+											MonoBoolean refonly)
 {
 	MonoAssembly *ass;
 	MonoReflectionAssembly *refass = NULL;
@@ -987,7 +999,7 @@
 		return NULL;
 	}
 
-	ass = mono_assembly_load_from (image, "", &status);
+	ass = mono_assembly_load_from_full (image, "", &status, refonly);
 
 	if (!ass) {
 		mono_image_close (image);
@@ -1001,7 +1013,7 @@
 }
 
 MonoReflectionAssembly *
-ves_icall_System_AppDomain_LoadAssembly (MonoAppDomain *ad,  MonoString *assRef, MonoObject *evidence)
+ves_icall_System_AppDomain_LoadAssembly (MonoAppDomain *ad,  MonoString *assRef, MonoObject *evidence, MonoBoolean refOnly)
 {
 	MonoDomain *domain = ad->data; 
 	MonoImageOpenStatus status = MONO_IMAGE_OK;
@@ -1022,10 +1034,10 @@
 		mono_raise_exception (exc);
 	}
 
-	ass = mono_assembly_load (&aname, NULL, &status);
+	ass = mono_assembly_load_full (&aname, NULL, &status, refOnly);
 	free_assembly_name (&aname);
 
-	if (!ass && (refass = try_assembly_resolve (domain, assRef)) == NULL){
+	if (!ass && (refass = try_assembly_resolve (domain, assRef, refOnly)) == NULL){
 		/* FIXME: it doesn't make much sense since we really don't have a filename ... */
 		MonoException *exc = mono_get_exception_file_not_found (assRef);
 		mono_raise_exception (exc);
Index: assembly.c
===================================================================
--- assembly.c	(revisión: 40470)
+++ assembly.c	(copia de trabajo)
@@ -107,9 +107,15 @@
 /* A hastable of thread->assembly list mappings */
 static GHashTable *assemblies_loading;
 
+/* A hashtable of reflection only load thread->assemblies mappings */
+static GHashTable *assemblies_refonly_loading;
+
 /* If defined, points to the bundled assembly information */
 const MonoBundledAssembly **bundles;
 
+/* Reflection only private hook functions */
+static MonoAssembly* mono_assembly_refonly_invoke_search_hook (MonoAssemblyName *aname);
+
 static gchar*
 encode_public_tok (const guchar *token, gint32 len)
 {
@@ -202,13 +208,13 @@
 }
 
 static MonoAssembly*
-search_loaded (MonoAssemblyName* aname)
+search_loaded (MonoAssemblyName* aname, gboolean refonly)
 {
 	GList *tmp;
 	MonoAssembly *ass;
 	GList *loading;
 
-	ass = mono_assembly_invoke_search_hook (aname);
+	ass = refonly ? mono_assembly_refonly_invoke_search_hook (aname) : mono_assembly_invoke_search_hook (aname);
 	if (ass)
 		return ass;
 	
@@ -216,7 +222,7 @@
 	 * The assembly might be under load by this thread. In this case, it is
 	 * safe to return an incomplete instance to prevent loops.
 	 */
-	loading = g_hash_table_lookup (assemblies_loading, GetCurrentThread ());
+	loading = g_hash_table_lookup (refonly ? assemblies_refonly_loading : assemblies_loading, GetCurrentThread ());
 	for (tmp = loading; tmp; tmp = tmp->next) {
 		ass = tmp->data;
 		if (!mono_assembly_names_equal (aname, &ass->aname))
@@ -229,7 +235,7 @@
 }
 
 static MonoAssembly *
-load_in_path (const char *basename, const char** search_path, MonoImageOpenStatus *status)
+load_in_path (const char *basename, const char** search_path, MonoImageOpenStatus *status, MonoBoolean refonly)
 {
 	int i;
 	char *fullpath;
@@ -237,7 +243,7 @@
 
 	for (i = 0; search_path [i]; ++i) {
 		fullpath = g_build_filename (search_path [i], basename, NULL);
-		result = mono_assembly_open (fullpath, status);
+		result = mono_assembly_open_full (fullpath, status, refonly);
 		g_free (fullpath);
 		if (result)
 			return result;
@@ -288,6 +294,7 @@
 	InitializeCriticalSection (&assemblies_mutex);
 
 	assemblies_loading = g_hash_table_new (NULL, NULL);
+	assemblies_refonly_loading = g_hash_table_new (NULL, NULL);
 }
 
 gboolean
@@ -463,7 +470,20 @@
 		memset (aname.public_key_token, 0, MONO_PUBLIC_KEY_TOKEN_LENGTH);
 	}
 
-	reference = mono_assembly_load (&aname, image->assembly->basedir, &status);
+	if (image->assembly->ref_only) {
+		/* We use the loaded corlib */
+		if (!strcmp (aname.name, "mscorlib"))
+			reference = mono_assembly_load_full (&aname, image->assembly->basedir, &status, FALSE);
+		else
+			reference = mono_assembly_loaded_full (&aname, TRUE);
+		/*
+		 * Here we must advice that the error was due to
+		 * a non loaded reference using the ReflectionOnly api
+		*/
+		if (!reference)
+			reference = (gpointer)-1;
+	} else
+		reference = mono_assembly_load (&aname, image->assembly->basedir, &status);
 
 	if (reference == NULL){
 		char *extra_msg = g_strdup ("");
@@ -566,6 +586,7 @@
 };
 
 AssemblySearchHook *assembly_search_hook = NULL;
+static AssemblySearchHook *assembly_refonly_search_hook = NULL;
 
 MonoAssembly*
 mono_assembly_invoke_search_hook (MonoAssemblyName *aname)
@@ -581,6 +602,20 @@
 	return NULL;
 }
 
+static MonoAssembly*
+mono_assembly_refonly_invoke_search_hook (MonoAssemblyName *aname)
+{
+	AssemblySearchHook *hook;
+
+	for (hook = assembly_refonly_search_hook; hook; hook = hook->next) {
+		MonoAssembly *ass = hook->func (aname, hook->user_data);
+		if (ass)
+			return ass;
+	}
+
+	return NULL;
+}
+
 void          
 mono_install_assembly_search_hook (MonoAssemblySearchFunc func, gpointer user_data)
 {
@@ -595,6 +630,20 @@
 	assembly_search_hook = hook;
 }	
 
+void
+mono_install_assembly_refonly_search_hook (MonoAssemblySearchFunc func, gpointer user_data)
+{
+	AssemblySearchHook *hook;
+
+	g_return_if_fail (func != NULL);
+
+	hook = g_new0 (AssemblySearchHook, 1);
+	hook->func = func;
+	hook->user_data = user_data;
+	hook->next = assembly_refonly_search_hook;
+	assembly_refonly_search_hook = hook;
+}
+
 typedef struct AssemblyPreLoadHook AssemblyPreLoadHook;
 struct AssemblyPreLoadHook {
 	AssemblyPreLoadHook *next;
@@ -603,6 +652,7 @@
 };
 
 static AssemblyPreLoadHook *assembly_preload_hook = NULL;
+AssemblyPreLoadHook *assembly_refonly_preload_hook = NULL;
 
 static MonoAssembly *
 invoke_assembly_preload_hook (MonoAssemblyName *aname, gchar **assemblies_path)
@@ -619,6 +669,21 @@
 	return NULL;
 }
 
+static MonoAssembly *
+invoke_assembly_refonly_preload_hook (MonoAssemblyName *aname, gchar **assemblies_path)
+{
+	AssemblyPreLoadHook *hook;
+	MonoAssembly *assembly;
+
+	for (hook = assembly_refonly_preload_hook; hook; hook = hook->next) {
+		assembly = hook->func (aname, assemblies_path, hook->user_data);
+		if (assembly != NULL)
+			return assembly;
+	}
+
+	return NULL;
+}
+
 void
 mono_install_assembly_preload_hook (MonoAssemblyPreLoadFunc func, gpointer user_data)
 {
@@ -633,6 +698,20 @@
 	assembly_preload_hook = hook;
 }
 
+void
+mono_install_assembly_refonly_preload_hook (MonoAssemblyPreLoadFunc func, gpointer user_data)
+{
+	AssemblyPreLoadHook *hook;
+	
+	g_return_if_fail (func != NULL);
+
+	hook = g_new0 (AssemblyPreLoadHook, 1);
+	hook->func = func;
+	hook->user_data = user_data;
+	hook->next = assembly_refonly_preload_hook;
+	assembly_refonly_preload_hook = hook;
+}
+
 static gchar *
 absolute_dir (const gchar *filename)
 {
@@ -742,19 +821,8 @@
 	return image;
 }
 
-/**
- * mono_assembly_open:
- * @filename: Opens the assembly pointed out by this name
- * @status: where a status code can be returned
- *
- * mono_assembly_open opens the PE-image pointed by @filename, and
- * loads any external assemblies referenced by it.
- *
- * NOTE: we could do lazy loading of the assemblies.  Or maybe not worth
- * it. 
- */
 MonoAssembly *
-mono_assembly_open (const char *filename, MonoImageOpenStatus *status)
+mono_assembly_open_full (const char *filename, MonoImageOpenStatus *status, gboolean refonly)
 {
 	MonoImage *image;
 	MonoAssembly *ass;
@@ -806,12 +874,13 @@
 		return NULL;
 	}
 
-	ass = mono_assembly_load_from (image, fname, status);
+	ass = mono_assembly_load_from_full (image, fname, status, refonly);
 
 	if (ass) {
 		mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_ASSEMBLY,
 				"Assembly Loader loaded assembly from location: '%s'.", filename);
-		mono_config_for_assembly (ass->image);
+		if (!refonly)
+			mono_config_for_assembly (ass->image);
 	}
 
 	g_free (fname);
@@ -819,13 +888,31 @@
 	return ass;
 }
 
+/**
+ * mono_assembly_open:
+ * @filename: Opens the assembly pointed out by this name
+ * @status: where a status code can be returned
+ *
+ * mono_assembly_open opens the PE-image pointed by @filename, and
+ * loads any external assemblies referenced by it.
+ *
+ * NOTE: we could do lazy loading of the assemblies.  Or maybe not worth
+ * it. 
+ */
 MonoAssembly *
-mono_assembly_load_from (MonoImage *image, const char*fname, 
-			 MonoImageOpenStatus *status)
+mono_assembly_open (const char *filename, MonoImageOpenStatus *status)
 {
+	return mono_assembly_open_full (filename, status, FALSE);
+}
+
+MonoAssembly *
+mono_assembly_load_from_full (MonoImage *image, const char*fname, 
+			 MonoImageOpenStatus *status, gboolean refonly)
+{
 	MonoAssembly *ass, *ass2;
 	char *base_dir;
 	GList *loading;
+	GHashTable *ass_loading;
 
 #if defined (PLATFORM_WIN32)
 	{
@@ -858,6 +945,7 @@
 	 */
 	ass = g_new0 (MonoAssembly, 1);
 	ass->basedir = base_dir;
+	ass->ref_only = refonly;
 	ass->image = image;
 	ass->ref_count = 1;
 
@@ -867,9 +955,10 @@
 	 * Atomically search the loaded list and add ourselves to it if necessary.
 	 */
 	EnterCriticalSection (&assemblies_mutex);
-	if (ass->aname.name)
+	if (ass->aname.name) {
 		/* avoid loading the same assembly twice for now... */
-		if ((ass2 = search_loaded (&ass->aname))) {
+		ass2 = search_loaded (&ass->aname, refonly);
+		if (ass2) {
 			g_free (ass);
 			g_free (base_dir);
 			mono_image_close (image);
@@ -877,9 +966,11 @@
 			LeaveCriticalSection (&assemblies_mutex);
 			return ass2;
 		}
-	loading = g_hash_table_lookup (assemblies_loading, GetCurrentThread ());
+	}
+	ass_loading = refonly ? assemblies_refonly_loading : assemblies_loading;
+	loading = g_hash_table_lookup (ass_loading, GetCurrentThread ());
 	loading = g_list_prepend (loading, ass);
-	g_hash_table_insert (assemblies_loading, GetCurrentThread (), loading);
+	g_hash_table_insert (ass_loading, GetCurrentThread (), loading);
 	LeaveCriticalSection (&assemblies_mutex);
 
 	image->assembly = ass;
@@ -888,13 +979,13 @@
 
 	EnterCriticalSection (&assemblies_mutex);
 
-	loading = g_hash_table_lookup (assemblies_loading, GetCurrentThread ());
+	loading = g_hash_table_lookup (ass_loading, GetCurrentThread ());
 	loading = g_list_remove (loading, ass);
 	if (loading == NULL)
 		/* Prevent memory leaks */
-		g_hash_table_remove (assemblies_loading, GetCurrentThread ());
+		g_hash_table_remove (ass_loading, GetCurrentThread ());
 	else
-		g_hash_table_insert (assemblies_loading, GetCurrentThread (), loading);
+		g_hash_table_insert (ass_loading, GetCurrentThread (), loading);
 	if (*status != MONO_IMAGE_OK) {
 		LeaveCriticalSection (&assemblies_mutex);
 		mono_assembly_close (ass);
@@ -902,7 +993,7 @@
 	}
 
 	if (ass->aname.name) {
-		ass2 = search_loaded (&ass->aname);
+		ass2 = search_loaded (&ass->aname, refonly);
 		if (ass2) {
 			/* Somebody else has loaded the assembly before us */
 			LeaveCriticalSection (&assemblies_mutex);
@@ -919,6 +1010,13 @@
 	return ass;
 }
 
+MonoAssembly *
+mono_assembly_load_from (MonoImage *image, const char *fname,
+			 MonoImageOpenStatus *status)
+{
+	return mono_assembly_load_from_full (image, fname, status, FALSE);
+}
+
 static MonoAssembly*
 probe_for_partial_name (const char *basepath, const char *fullname, MonoImageOpenStatus *status)
 {
@@ -1001,7 +1099,7 @@
  * @aname: The assembly name object
  */
 static MonoAssembly*
-mono_assembly_load_from_gac (MonoAssemblyName *aname,  gchar *filename, MonoImageOpenStatus *status)
+mono_assembly_load_from_gac (MonoAssemblyName *aname,  gchar *filename, MonoImageOpenStatus *status, MonoBoolean refonly)
 {
 	MonoAssembly *result = NULL;
 	gchar *name, *version, *culture, *fullpath, *subpath;
@@ -1040,7 +1138,7 @@
 		paths = extra_gac_paths;
 		while (!result && *paths) {
 			fullpath = g_build_path (G_DIR_SEPARATOR_S, *paths, "lib", "mono", "gac", subpath, NULL);
-			result = mono_assembly_open (fullpath, status);
+			result = mono_assembly_open_full (fullpath, status, refonly);
 			g_free (fullpath);
 			paths++;
 		}
@@ -1054,7 +1152,7 @@
 
 	fullpath = g_build_path (G_DIR_SEPARATOR_S, mono_assembly_getrootdir (),
 			"mono", "gac", subpath, NULL);
-	result = mono_assembly_open (fullpath, status);
+	result = mono_assembly_open_full (fullpath, status, refonly);
 	g_free (fullpath);
 
 	if (result)
@@ -1065,21 +1163,20 @@
 	return result;
 }
 
-	
 MonoAssembly*
-mono_assembly_load (MonoAssemblyName *aname, const char *basedir, MonoImageOpenStatus *status)
+mono_assembly_load_full (MonoAssemblyName *aname, const char *basedir, MonoImageOpenStatus *status, gboolean refonly)
 {
 	MonoAssembly *result;
 	char *fullpath, *filename;
 	MonoAssemblyName maped_aname;
 
 	aname = mono_assembly_remap_version (aname, &maped_aname);
-
-	result = mono_assembly_loaded (aname);
+	
+	result = mono_assembly_loaded_full (aname, refonly);
 	if (result)
 		return result;
 
-	result = invoke_assembly_preload_hook (aname, assemblies_path);
+	result = refonly ? invoke_assembly_refonly_preload_hook (aname, assemblies_path) : invoke_assembly_preload_hook (aname, assemblies_path);
 	if (result) {
 		result->in_gac = FALSE;
 		return result;
@@ -1095,11 +1192,11 @@
 		}
 		/* g_print ("corlib load\n"); */
 		if (assemblies_path) {
-			corlib = load_in_path ("mscorlib.dll", (const char**)assemblies_path, status);
+			corlib = load_in_path ("mscorlib.dll", (const char**)assemblies_path, status, FALSE);
 			if (corlib)
 				return corlib;
 		}
-		corlib = load_in_path ("mscorlib.dll", default_path, status);
+		corlib = load_in_path ("mscorlib.dll", default_path, status, FALSE);
 
 		if (corlib)
 			return corlib;
@@ -1108,13 +1205,13 @@
 		
 		corlib_file = g_build_filename ("mono", mono_get_runtime_info ()->framework_version, "mscorlib.dll", NULL);
 		if (assemblies_path) {
-			corlib = load_in_path (corlib_file, (const char**)assemblies_path, status);
+			corlib = load_in_path (corlib_file, (const char**)assemblies_path, status, FALSE);
 			if (corlib) {
 				g_free (corlib_file);
 				return corlib;
 			}
 		}
-		corlib = load_in_path (corlib_file, default_path, status);
+		corlib = load_in_path (corlib_file, default_path, status, FALSE);
 		g_free (corlib_file);
 	
 		return corlib;
@@ -1125,7 +1222,7 @@
 	else
 		filename = g_strconcat (aname->name, ".dll", NULL);
 
-	result = mono_assembly_load_from_gac (aname, filename, status);
+	result = mono_assembly_load_from_gac (aname, filename, status, refonly);
 	if (result) {
 		g_free (filename);
 		return result;
@@ -1133,7 +1230,7 @@
 
 	if (basedir) {
 		fullpath = g_build_filename (basedir, filename, NULL);
-		result = mono_assembly_open (fullpath, status);
+		result = mono_assembly_open_full (fullpath, status, refonly);
 		g_free (fullpath);
 		if (result) {
 			result->in_gac = FALSE;
@@ -1142,7 +1239,7 @@
 		}
 	}
 
-	result = load_in_path (filename, default_path, status);
+	result = load_in_path (filename, default_path, status, refonly);
 	if (result)
 		result->in_gac = FALSE;
 	g_free (filename);
@@ -1150,20 +1247,32 @@
 }
 
 MonoAssembly*
-mono_assembly_loaded (MonoAssemblyName *aname)
+mono_assembly_load (MonoAssemblyName *aname, const char *basedir, MonoImageOpenStatus *status)
 {
+	return mono_assembly_load_full (aname, basedir, status, FALSE);
+}
+	
+MonoAssembly*
+mono_assembly_loaded_full (MonoAssemblyName *aname, gboolean refonly)
+{
 	MonoAssembly *res;
 	MonoAssemblyName maped_aname;
 
 	aname = mono_assembly_remap_version (aname, &maped_aname);
 
 	EnterCriticalSection (&assemblies_mutex);
-	res = search_loaded (aname);
+	res = search_loaded (aname, refonly);
 	LeaveCriticalSection (&assemblies_mutex);
 
 	return res;
 }
 
+MonoAssembly*
+mono_assembly_loaded (MonoAssemblyName *aname)
+{
+	return mono_assembly_loaded_full (aname, FALSE);
+}
+
 void
 mono_assembly_close (MonoAssembly *assembly)
 {
Index: assembly.h
===================================================================
--- assembly.h	(revisión: 40470)
+++ assembly.h	(copia de trabajo)
@@ -8,15 +8,26 @@
 void          mono_assemblies_init     (void);
 MonoAssembly *mono_assembly_open       (const char *filename,
 				       	MonoImageOpenStatus *status);
+MonoAssembly *mono_assembly_open_full (const char *filename,
+				       	MonoImageOpenStatus *status,
+					gboolean refonly);
 MonoAssembly* mono_assembly_load       (MonoAssemblyName *aname, 
                                        	const char       *basedir, 
 				     	MonoImageOpenStatus *status);
+MonoAssembly* mono_assembly_load_full (MonoAssemblyName *aname, 
+                                       	const char       *basedir, 
+				     	MonoImageOpenStatus *status,
+					gboolean refonly);
 MonoAssembly* mono_assembly_load_from  (MonoImage *image, const char *fname,
 					MonoImageOpenStatus *status);
+MonoAssembly* mono_assembly_load_from_full  (MonoImage *image, const char *fname,
+					MonoImageOpenStatus *status,
+					gboolean refonly);
 
 MonoAssembly* mono_assembly_load_with_partial_name (const char *name, MonoImageOpenStatus *status);
 
 MonoAssembly* mono_assembly_loaded     (MonoAssemblyName *aname);
+MonoAssembly* mono_assembly_loaded_full (MonoAssemblyName *aname, gboolean refonly);
 void          mono_assembly_load_reference (MonoImage *image, int index);
 void          mono_assembly_load_references (MonoImage *image, MonoImageOpenStatus *status);
 MonoImage*    mono_assembly_load_module (MonoAssembly *assembly, guint32 idx);
@@ -40,6 +51,7 @@
  */
 typedef MonoAssembly *(*MonoAssemblySearchFunc)         (MonoAssemblyName *aname, gpointer user_data);
 void          mono_install_assembly_search_hook (MonoAssemblySearchFunc func, gpointer user_data);
+void 	      mono_install_assembly_refonly_search_hook (MonoAssemblySearchFunc func, gpointer user_data);
 
 MonoAssembly* mono_assembly_invoke_search_hook (MonoAssemblyName *aname);
 
@@ -52,6 +64,8 @@
 
 void          mono_install_assembly_preload_hook (MonoAssemblyPreLoadFunc func,
 						  gpointer user_data);
+void          mono_install_assembly_refonly_preload_hook (MonoAssemblyPreLoadFunc func,
+						  gpointer user_data);
 
 void          mono_assembly_invoke_load_hook (MonoAssembly *ass);
 
Index: metadata-internals.h
===================================================================
--- metadata-internals.h	(revisión: 40470)
+++ metadata-internals.h	(copia de trabajo)
@@ -15,6 +15,7 @@
 	guint8 in_gac;
 	guint8 dynamic;
 	guint8 corlib_internal;
+	gboolean ref_only;
 	/* security manager flags (one bit is for lazy initialization) */
 	guint32 ecma:2;		/* Has the ECMA key */
 	guint32 aptc:2;		/* Has the [AllowPartiallyTrustedCallers] attributes */
Index: domain-internals.h
===================================================================
--- domain-internals.h	(revisión: 40470)
+++ domain-internals.h	(copia de trabajo)
@@ -163,7 +163,8 @@
 ves_icall_System_AppDomain_LoadAssemblyRaw         (MonoAppDomain *ad,
     						    MonoArray *raw_assembly, 
 						    MonoArray *raw_symbol_store,
-						    MonoObject *evidence);
+						    MonoObject *evidence,
+						    MonoBoolean refonly);
 
 void
 ves_icall_System_AppDomain_SetData                 (MonoAppDomain *ad, 
@@ -177,15 +178,18 @@
 ves_icall_System_AppDomain_getFriendlyName         (MonoAppDomain *ad);
 
 MonoArray *
-ves_icall_System_AppDomain_GetAssemblies           (MonoAppDomain *ad);
+ves_icall_System_AppDomain_GetAssemblies           (MonoAppDomain *ad,
+						    MonoBoolean refonly);
 
 MonoReflectionAssembly *
-ves_icall_System_Reflection_Assembly_LoadFrom      (MonoString *fname);
+ves_icall_System_Reflection_Assembly_LoadFrom      (MonoString *fname,
+						    MonoBoolean refonly);
 
 MonoReflectionAssembly *
 ves_icall_System_AppDomain_LoadAssembly            (MonoAppDomain *ad, 
 						    MonoString *assRef,
-						    MonoObject    *evidence);
+						    MonoObject    *evidence,
+						    MonoBoolean refonly);
 
 gboolean
 ves_icall_System_AppDomain_InternalIsFinalizingForUnload (gint32 domain_id);
Index: exception.c
===================================================================
--- exception.c	(revisión: 40470)
+++ exception.c	(copia de trabajo)
@@ -219,6 +219,13 @@
 }
 
 MonoException *
+mono_get_exception_invalid_operation (const guchar *msg)
+{
+	return mono_exception_from_name_msg (mono_get_corlib (), "System",
+					"InvalidOperationException", msg);
+}
+
+MonoException *
 mono_get_exception_index_out_of_range ()
 {
 	return mono_exception_from_name (mono_get_corlib (), "System",
Index: exception.h
===================================================================
--- exception.h	(revisión: 40470)
+++ exception.h	(copia de trabajo)
@@ -59,6 +59,9 @@
 mono_get_exception_invalid_cast        (void);
 
 MonoException *
+mono_get_exception_invalid_operation (const guchar *msg);
+
+MonoException *
 mono_get_exception_index_out_of_range  (void);
 
 MonoException *
Index: icall.c
===================================================================
--- icall.c	(revisión: 40470)
+++ icall.c	(copia de trabajo)
@@ -1304,6 +1304,10 @@
 
 	MONO_ARCH_SAVE_REGS;
 
+	if (field->klass->image->assembly->ref_only)
+		mono_raise_exception (mono_get_exception_invalid_operation (
+					"It is illegal to get the value on a field on a type loaded using the ReflectionOnly methods."));
+	
 	mono_class_init (field->klass);
 
 	switch (cf->type->type) {
@@ -1375,6 +1379,10 @@
 
 	MONO_ARCH_SAVE_REGS;
 
+	if (field->klass->image->assembly->ref_only)
+		mono_raise_exception (mono_get_exception_invalid_operation (
+					"It is illegal to set the value on a field on a type loaded using the ReflectionOnly methods."));
+
 	v = (gchar *) value;
 	if (!cf->type->byref) {
 		switch (cf->type->type) {
@@ -2353,6 +2361,9 @@
 	if ((m->klass->flags & TYPE_ATTRIBUTE_ABSTRACT) && !strcmp (m->name, ".ctor"))
 		mono_raise_exception (mono_exception_from_name_msg (mono_defaults.corlib, "System", "MethodAccessException", "Cannot invoke constructor of an abstract class."));
 
+	if (m->klass->image->assembly->ref_only)
+		mono_raise_exception (mono_get_exception_invalid_operation ("It is illegal to invoke a method on a type loaded using the ReflectionOnly api."));
+	
 	if (m->klass->rank && !strcmp (m->name, ".ctor")) {
 		int i;
 		guint32 *lengths;
@@ -3360,6 +3371,14 @@
 	return res;
 }
 
+static MonoBoolean
+ves_icall_System_Reflection_Assembly_get_ReflectionOnly (MonoReflectionAssembly *assembly)
+{
+	MONO_ARCH_SAVE_REGS;
+
+	return assembly->assembly->ref_only;
+}
+
 static MonoString *
 ves_icall_System_Reflection_Assembly_InternalImageRuntimeVersion (MonoReflectionAssembly *assembly)
 {
@@ -6011,6 +6030,7 @@
 };
 
 static const IcallEntry customattrs_icalls [] = {
+	{"GetCustomAttributesDataInternal", mono_reflection_get_custom_attrs_data},
 	{"GetCustomAttributesInternal", mono_reflection_get_custom_attrs},
 	{"IsDefinedInternal", custom_attrs_defined_internal}
 };
@@ -6095,6 +6115,7 @@
 	{"get_EntryPoint", ves_icall_System_Reflection_Assembly_get_EntryPoint},
 	{"get_ManifestModule", ves_icall_System_Reflection_Assembly_get_ManifestModule},
 	{"get_MetadataToken", mono_reflection_get_token},
+	{"get_ReflectionOnly", ves_icall_System_Reflection_Assembly_get_ReflectionOnly},
 	{"get_code_base", ves_icall_System_Reflection_Assembly_get_code_base},
 	{"get_global_assembly_cache", ves_icall_System_Reflection_Assembly_get_global_assembly_cache},
 	{"get_location", ves_icall_System_Reflection_Assembly_get_location},
Index: reflection.c
===================================================================
--- reflection.c	(revisión: 40470)
+++ reflection.c	(copia de trabajo)
@@ -6432,6 +6432,50 @@
 	return NULL;
 }
 
+static MonoObject*
+create_cattr_typed_arg (MonoType *t, void *val)
+{
+	static MonoClass *klass;
+	static MonoMethod *ctor;
+	MonoObject *retval;
+	void *params [2], *unboxed;
+
+	if (!klass) {
+		klass = mono_class_from_name (mono_defaults.corlib, "System.Reflection", "CustomAttributeTypedArgument");
+		ctor = mono_class_get_method_from_name (klass, ".ctor", 2);
+	}
+	
+	params [0] = mono_type_get_object (mono_domain_get (), t);
+	params [1] = val;
+	retval = mono_object_new (mono_domain_get (), klass);
+	unboxed = mono_object_unbox (retval);
+	mono_runtime_invoke (ctor, unboxed, params, NULL);
+
+	return retval;
+}
+
+static MonoObject*
+create_cattr_named_arg (void *minfo, void *typedarg)
+{
+	static MonoClass *klass;
+	static MonoMethod *ctor;
+	MonoObject *retval;
+	void *unboxed, *params [2];
+
+	if (!klass) {
+		klass = mono_class_from_name (mono_defaults.corlib, "System.Reflection", "CustomAttributeNamedArgument");
+		ctor = mono_class_get_method_from_name (klass, ".ctor", 2);
+	}
+
+	params [0] = minfo;
+	params [1] = typedarg;
+	retval = mono_object_new (mono_domain_get (), klass);
+	unboxed = mono_object_unbox (retval);
+	mono_runtime_invoke (ctor, unboxed, params, NULL);
+
+	return retval;
+}
+
 static gboolean
 type_is_reference (MonoType *type)
 {
@@ -6595,6 +6639,113 @@
 	return attr;
 }
 
+static MonoObject*
+create_custom_attr_data (MonoImage *image, MonoMethod *method, const char *data, guint32 len)
+{
+	MonoArray *typedargs, *namedargs;
+	MonoClass *klass, *attrklass;
+	MonoMethod *ctor;
+	MonoObject *attr;
+	const char *p = data;
+	const char *named;
+	guint32 i, j, num_named;
+	void *params [3], **ctorparams;
+
+	klass = mono_class_from_name (mono_defaults.corlib, "System.Reflection", "CustomAttributeData");
+	ctor = mono_class_get_method_from_name (klass, ".ctor", 3);
+	
+	if (len == 0) {
+		/* This is for Attributes with no parameters */
+		attr = mono_object_new (mono_domain_get (), klass);
+		params [0] = mono_method_get_object (mono_domain_get (), method, NULL);
+		params [1] = params [2] = NULL;
+		mono_runtime_invoke (method, attr, params, NULL);
+		return attr;
+	}
+
+	if (len < 2 || read16 (p) != 0x0001) /* Prolog */
+		return NULL;
+
+	ctorparams = g_new (void*, mono_method_signature (method)->param_count);
+	typedargs = mono_array_new (mono_domain_get (), mono_get_object_class (), mono_method_signature (method)->param_count);
+	
+	/* skip prolog */
+	p += 2;
+	for (i = 0; i < mono_method_signature (method)->param_count; ++i) {
+		void *val;
+
+		ctorparams [i] = load_cattr_value (image, mono_method_signature (method)->params [i], p, &p);
+		val = type_is_reference (mono_method_signature (method)->params [i]) ? 
+			ctorparams [i] : mono_value_box (mono_domain_get (), mono_class_from_mono_type (mono_method_signature (method)->params [i]), ctorparams [i]);
+		mono_array_set (typedargs, void*, i, create_cattr_typed_arg (mono_method_signature (method)->params [i], val));
+	}
+
+	named = p;
+	free_param_data (method->signature, ctorparams);
+	g_free (ctorparams);
+	num_named = read16 (named);
+	namedargs = mono_array_new (mono_domain_get (), mono_get_object_class (), num_named);
+	named += 2;
+	attrklass = method->klass;
+	for (j = 0; j < num_named; j++) {
+		gint name_len;
+		char *name, named_type, data_type;
+		named_type = *named++;
+		data_type = *named++; /* type of data */
+		if (data_type == 0x55) {
+			gint type_len;
+			char *type_name;
+			type_len = mono_metadata_decode_blob_size (named, &named);
+			type_name = g_malloc (type_len + 1);
+			memcpy (type_name, named, type_len);
+			type_name [type_len] = 0;
+			named += type_len;
+			/* FIXME: lookup the type and check type consistency */
+		} else if (data_type == MONO_TYPE_SZARRAY && (named_type == 0x54 || named_type == 0x53)) {
+			/* this seems to be the type of the element of the array */
+			/* g_print ("skipping 0x%02x after prop\n", *named); */
+			named++;
+		}
+		name_len = mono_metadata_decode_blob_size (named, &named);
+		name = g_malloc (name_len + 1);
+		memcpy (name, named, name_len);
+		name [name_len] = 0;
+		named += name_len;
+		if (named_type == 0x53) {
+			MonoClassField *field = mono_class_get_field_from_name (attrklass, name);
+			void *obj, *minfo, *typedarg, *val = load_cattr_value (image, field->type, named, &named);
+			
+			obj = type_is_reference (field->type) ? val : mono_value_box (mono_domain_get (), mono_class_from_mono_type (field->type), val);
+			minfo = mono_field_get_object (mono_domain_get (), NULL, field);
+			typedarg = create_cattr_typed_arg (field->type, obj);
+			mono_array_set (namedargs, void*, j, create_cattr_named_arg (minfo, typedarg));
+			if (!type_is_reference (field->type))
+				g_free (val);
+		} else if (named_type == 0x54) {
+			MonoType *prop_type;
+			void *val, *obj, *minfo, *typedarg;
+			MonoProperty *prop = mono_class_get_property_from_name (attrklass, name);
+
+			prop_type = prop->get? mono_method_signature (prop->get)->ret :
+			     mono_method_signature (prop->set)->params [mono_method_signature (prop->set)->param_count - 1];
+			val = load_cattr_value (image, prop_type, named, &named);
+			obj = type_is_reference (prop_type) ? val : mono_value_box (mono_domain_get (), mono_class_from_mono_type (prop_type), val);
+			minfo =  mono_property_get_object (mono_domain_get (), NULL, prop);
+			typedarg = create_cattr_typed_arg (prop_type, obj);
+			mono_array_set (namedargs, void*, j, create_cattr_named_arg (minfo, typedarg));
+			if (!type_is_reference (prop_type))
+				g_free (val);
+		}
+		g_free (name);
+	}
+	attr = mono_object_new (mono_domain_get (), klass);
+	params [0] = mono_method_get_object (mono_domain_get (), method, NULL);
+	params [1] = typedargs;
+	params [2] = namedargs;
+	mono_runtime_invoke (ctor, attr, params, NULL);
+	return attr;
+}
+
 MonoArray*
 mono_custom_attrs_construct (MonoCustomAttrInfo *cinfo)
 {
@@ -6612,6 +6763,23 @@
 	return result;
 }
 
+MonoArray*
+mono_custom_attrs_data_construct (MonoCustomAttrInfo *cinfo)
+{
+	MonoArray *result;
+	MonoClass *klass;
+	MonoObject *attr;
+	int i;
+
+	klass = mono_class_from_name (mono_defaults.corlib, "System.Reflection", "CustomAttributeData");
+	result = mono_array_new (mono_domain_get (), klass, cinfo->num_attrs);
+	for (i = 0; i < cinfo->num_attrs; ++i) {
+		attr = create_custom_attr_data (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);
+		mono_array_set (result, gpointer, i, attr);
+	}
+	return result;
+}
+
 MonoCustomAttrInfo*
 mono_custom_attrs_from_index (MonoImage *image, guint32 idx)
 {
@@ -6912,6 +7080,34 @@
 	return result;
 }
 
+/*
+ * mono_reflection_get_custom_attrs_data:
+ * @obj: a reflection obj handle
+ *
+ * Returns an array of System.Reflection.CustomAttributeData,
+ * which include information about attributes reflected on
+ * types loaded using the Reflection Only methods
+ */
+MonoArray*
+mono_reflection_get_custom_attrs_data (MonoObject *obj)
+{
+	MonoArray *result;
+	MonoCustomAttrInfo *cinfo;
+
+	cinfo = mono_reflection_get_custom_attrs_info (obj);
+	if (cinfo) {
+		result = mono_custom_attrs_data_construct (cinfo);
+		if (!cinfo->cached)
+			mono_custom_attrs_free (cinfo);
+	} else {
+		MonoClass *klass;
+		klass = mono_class_from_name (mono_defaults.corlib, "System.Reflection", "CustomAttributeData");
+		result = mono_array_new (mono_domain_get (), klass, 0);
+	}
+
+	return result;
+}
+
 static MonoMethodSignature*
 parameters_to_signature (MonoArray *parameters) {
 	MonoMethodSignature *sig;
