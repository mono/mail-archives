Index: Assembly.cs
===================================================================
--- Assembly.cs	(revisión: 40470)
+++ Assembly.cs	(copia de trabajo)
@@ -361,11 +361,16 @@
 		}
 		
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		public extern static Assembly LoadFrom (String assemblyFile);
+		private extern static Assembly LoadFrom (String assemblyFile, bool refonly);
 
+		public static Assembly LoadFrom (String assemblyFile)
+		{
+			return LoadFrom (assemblyFile, false);
+		}
+
 		public static Assembly LoadFrom (String assemblyFile, Evidence securityEvidence)
 		{
-			Assembly a = LoadFrom (assemblyFile);
+			Assembly a = LoadFrom (assemblyFile, false);
 			if ((a != null) && (securityEvidence != null)) {
 				// merge evidence (i.e. replace defaults with provided evidences)
 				a.Evidence.Merge (securityEvidence);
@@ -437,20 +442,25 @@
 		}
 
 #if NET_2_0
-		[MonoTODO]
 		public static Assembly ReflectionOnlyLoad (byte[] rawAssembly)
 		{
-			throw new NotImplementedException ();
+			if (rawAssembly == null)
+				throw new ArgumentNullException ("rawAssembly");
+			
+			return AppDomain.CurrentDomain.LoadAssemblyRaw (rawAssembly, null, null, true);
 		}
 
-		[MonoTODO]
-		public static Assembly ReflectionOnlyLoad (string assemblyString) {
-			throw new NotImplementedException ();
+		public static Assembly ReflectionOnlyLoad (string assemblyName) 
+		{
+			if (assemblyName == null)
+				throw new ArgumentNullException ("assemblyName");
+			
+			return AppDomain.CurrentDomain.LoadAssembly (assemblyName, null, true);
 		}
 
-		[MonoTODO]
-		public static Assembly ReflectionOnlyLoadFrom (string assemblyFile) {
-			throw new NotImplementedException ();
+		public static Assembly ReflectionOnlyLoadFrom (string assemblyFile) 
+		{
+			return LoadFrom (assemblyFile, true);
 		}
 #endif
 
@@ -525,7 +535,11 @@
 			if (t == null)
 				return null;
 
-			return Activator.CreateInstance (t);
+			try {
+				return Activator.CreateInstance (t);
+			} catch (InvalidOperationException) {
+				throw new ArgumentException ("It is illegal to invoke a method on a Type loaded via ReflectionOnly methods.");
+			}
 		}
 
 		public Object CreateInstance (String typeName, Boolean ignoreCase,
@@ -537,7 +551,11 @@
 			if (t == null)
 				return null;
 
-			return Activator.CreateInstance (t, bindingAttr, binder, args, culture, activationAttributes);
+			try {
+				return Activator.CreateInstance (t, bindingAttr, binder, args, culture, activationAttributes);
+			} catch (InvalidOperationException) {
+				throw new ArgumentException ("It is illegal to invoke a method on a Type loaded via ReflectionOnly methods.");
+			}
 		}
 
 		public Module[] GetLoadedModules ()
@@ -705,10 +723,10 @@
 			}
 		}
 
-		[MonoTODO ("see ReflectionOnlyLoad")]
 		[ComVisible (false)]
-		public virtual bool ReflectionOnly {
-			get { return false; }
+		public virtual extern bool ReflectionOnly {
+			[MethodImplAttribute (MethodImplOptions.InternalCall)]
+			get;
 		}
 #endif
 
Index: CustomAttributeNamedArgument.cs
===================================================================
--- CustomAttributeNamedArgument.cs	(revisión: 40470)
+++ CustomAttributeNamedArgument.cs	(copia de trabajo)
@@ -3,6 +3,7 @@
 //
 // Author:
 //   Zoltan Varga (vargaz@gmail.com)
+//   Carlos Alberto Cortez (calberto.cortez@gmail.com)
 //
 // Copyright (C) 2004 Novell, Inc (http://www.novell.com)
 //
@@ -33,20 +34,31 @@
 namespace System.Reflection {
 
 	public struct CustomAttributeNamedArgument {
+		CustomAttributeTypedArgument typedArgument;
+		MemberInfo memberInfo;
 
-		[MonoTODO]
+		internal CustomAttributeNamedArgument (MemberInfo memberInfo, object typedArgument)
+		{
+			this.memberInfo = memberInfo;
+			this.typedArgument = (CustomAttributeTypedArgument) typedArgument;
+		}
+
 		public MemberInfo MemberInfo {
 			get {
-				throw new NotImplementedException ();
+				return memberInfo;
 			}
 		}
 
-		[MonoTODO]
 		public CustomAttributeTypedArgument TypedValue {
 			get {
-				throw new NotImplementedException ();
+				return typedArgument;
 			}
 		}
+
+		public override string ToString ()
+		{
+			return memberInfo.Name + " = " + typedArgument.ToString ();
+		}
 	}
 
 }
Index: CustomAttributeData.cs
===================================================================
--- CustomAttributeData.cs	(revisión: 40470)
+++ CustomAttributeData.cs	(copia de trabajo)
@@ -3,6 +3,7 @@
 //
 // Author:
 //   Zoltan Varga (vargaz@gmail.com)
+//   Carlos Alberto Cortez (calberto.cortez@gmail.com)
 //
 // Copyright (C) 2004 Novell, Inc (http://www.novell.com)
 //
@@ -32,57 +33,95 @@
 using System.Collections.Generic;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
+using System.Text;
 
 namespace System.Reflection {
 
 	public sealed class CustomAttributeData {
+		ConstructorInfo ctorInfo;
+		List<CustomAttributeTypedArgument> ctorArgs;
+		List<CustomAttributeNamedArgument> namedArgs;
 
-		[MonoTODO]
+		internal CustomAttributeData (ConstructorInfo ctorInfo, object [] ctorArgs, object [] namedArgs)
+		{
+			this.ctorInfo = ctorInfo;
+			
+			this.ctorArgs = new List<CustomAttributeTypedArgument> (ctorArgs != null ? ctorArgs.Length : 0);
+			foreach (object obj in ctorArgs) {
+				CustomAttributeTypedArgument carg = (CustomAttributeTypedArgument) obj;
+				this.ctorArgs.Add (carg);
+			}
+			
+			this.namedArgs = new List<CustomAttributeNamedArgument> (namedArgs != null ? namedArgs.Length : 0);
+			foreach (object obj in namedArgs) {
+				CustomAttributeNamedArgument narg = (CustomAttributeNamedArgument) obj;
+				this.namedArgs.Add (narg);
+			}
+		}
+
 		public ConstructorInfo Constructor {
 			get {
-				throw new NotImplementedException ();
+				return ctorInfo;
 			}
 		}
 
-		[MonoTODO]
 		[CLSCompliant (false)]
 		public IList<CustomAttributeTypedArgument> ConstructorArguments {
 			get {
-				throw new NotImplementedException ();
+				return ctorArgs;
 			}
 		}
 
-		[MonoTODO]
 		[CLSCompliant (false)]
 		public IList<CustomAttributeNamedArgument> NamedArguments {
 			get {
-				throw new NotImplementedException ();
+				return namedArgs;
 			}
 		}
 
-		[MonoTODO]
 		[CLSCompliant (false)]
-		public static IList<CustomAttributeData> GetCustomAttributes (Assembly yarget) {
-			throw new NotImplementedException ();
+		public static IList<CustomAttributeData> GetCustomAttributes (Assembly target) {
+			return MonoCustomAttrs.GetCustomAttributesData (target);
 		}
 
-		[MonoTODO]
 		[CLSCompliant (false)]
 		public static IList<CustomAttributeData> GetCustomAttributes (MemberInfo target) {
-			throw new NotImplementedException ();
+			return MonoCustomAttrs.GetCustomAttributesData (target);
 		}
 
-		[MonoTODO]
 		[CLSCompliant (false)]
 		public static IList<CustomAttributeData> GetCustomAttributes (Module target) {
-			throw new NotImplementedException ();
+			return MonoCustomAttrs.GetCustomAttributesData (target);
 		}
 
-		[MonoTODO]
 		[CLSCompliant (false)]
 		public static IList<CustomAttributeData> GetCustomAttributes (ParameterInfo target) {
-			throw new NotImplementedException ();
+			return MonoCustomAttrs.GetCustomAttributesData (target);
 		}
+
+		public override string ToString ()
+		{
+			StringBuilder sb = new StringBuilder ();
+
+			sb.Append ("[" + ctorInfo.DeclaringType.Name + " (");
+			for (int i = 0; i < ctorArgs.Count; i++) {
+				sb.Append (ctorArgs [i].ToString ());
+				if (i + 1 < ctorArgs.Count)
+					sb.Append (", ");
+			}
+
+			if (namedArgs.Count > 0)
+				sb.Append (", ");
+			
+			for (int j = 0; j < namedArgs.Count; j++) {
+				sb.Append (namedArgs [j].ToString ());
+				if (j + 1 < namedArgs.Count)
+					sb.Append (", ");
+			}
+			sb.AppendFormat (")]");
+
+			return sb.ToString ();
+		}
 	}
 
 }
Index: MonoMethod.cs
===================================================================
--- MonoMethod.cs	(revisión: 40470)
+++ MonoMethod.cs	(copia de trabajo)
@@ -118,6 +118,8 @@
 				throw new ArgumentException ("parameters");
 			try {
 				return InternalInvoke (obj, parameters);
+			} catch (InvalidOperationException) {
+				throw;
 			} catch (TargetException) {
 				throw;
 			} catch (Exception e) {
@@ -316,6 +318,8 @@
 				throw new ArgumentException ("parameters");
 			try {
 				return InternalInvoke (obj, parameters);
+			} catch (InvalidOperationException) {
+				throw;
 			} catch (TargetException) {
 				throw;
 			} catch (Exception e) {
Index: CustomAttributeTypedArgument.cs
===================================================================
--- CustomAttributeTypedArgument.cs	(revisión: 40470)
+++ CustomAttributeTypedArgument.cs	(copia de trabajo)
@@ -3,6 +3,7 @@
 //
 // Author:
 //   Zoltan Varga (vargaz@gmail.com)
+//   Carlos Alberto Cortez (calberto.cortez@gmail.com)
 //
 // Copyright (C) 2004 Novell, Inc (http://www.novell.com)
 //
@@ -33,20 +34,37 @@
 namespace System.Reflection {
 
 	public struct CustomAttributeTypedArgument {
+		Type argumentType;
+		object value;
 
-		[MonoTODO]
+		internal CustomAttributeTypedArgument (Type argumentType, object value)
+		{
+			this.argumentType = argumentType;
+			this.value = value;
+		}
+
 		public Type ArgumentType {
 			get {
-				throw new NotImplementedException ();
+				return argumentType;
 			}
 		}
 
-		[MonoTODO]
 		public object Value {
 			get {
-				throw new NotImplementedException ();
+				return value;
 			}
 		}
+
+		public override string ToString ()
+		{
+			string val = value.ToString ();
+			if (argumentType == typeof (string))
+				return "\"" + val + "\"";
+			if (argumentType == typeof (Type)) 
+				return "typeof (" + val + ")";
+
+			return val;
+		}
 	}
 
 }
