Index: Makefile.am
===================================================================
--- Makefile.am	(revision 87092)
+++ Makefile.am	(working copy)
@@ -6,11 +6,13 @@
 
 if JIT_SUPPORTED
 
-lib_LTLIBRARIES = libmono-profiler-cov.la libmono-profiler-aot.la
+lib_LTLIBRARIES = libmono-profiler-cov.la libmono-profiler-aot.la libmono-profiler-logging.la
 endif
 
 libmono_profiler_cov_la_SOURCES = mono-cov.c
 libmono_profiler_cov_la_LIBADD = $(top_builddir)/mono/mini/libmono.la
 libmono_profiler_aot_la_SOURCES = mono-profiler-aot.c
 libmono_profiler_aot_la_LIBADD = $(top_builddir)/mono/mini/libmono.la
+libmono_profiler_logging_la_SOURCES = mono-profiler-logging.c
+libmono_profiler_logging_la_LIBADD = $(top_builddir)/mono/mini/libmono.la
 
Index: decode-profiler-log.pl
===================================================================
--- decode-profiler-log.pl	(revision 0)
+++ decode-profiler-log.pl	(revision 0)
@@ -0,0 +1,566 @@
+#!/usr/bin/perl
+
+$managed_stat_hits = 0;
+$unmanaged_stat_hits = 0;
+
+
+
+$LOG_DECODED_EVENTS = 0;
+$event_counter = 0;
+
+$log_file_name = @ARGV[0];
+$log_file_name ne '' || die "No log file\n";
+open LOG, "<$log_file_name";
+
+$start_counter = 0;
+$start_time = 0;
+$end_counter = 0;
+$end_time = 0;
+$time_per_tick = 0;
+$runtime_file = "";
+$log_version = 0;
+
+$classes_by_id = {};
+$methods_by_id = {};
+
+# Contains one list for each thread id.
+# Each list containes references to hashes with the entries 'method' and
+#'start', where 'method' points to an entry in 'methods_by_id' ant 'start'
+# is the counter value at the call.
+# We use this to keep track of time attribution in calls.
+$stacks_by_thread_id = {};
+$current_stack;
+sub get_stack_by_thread_id {
+	my ($thread_id) = @_;
+	
+	my $result;
+	
+	if (exists ($stacks_by_thread_id->{$thread_id})) {
+		$result = $stacks_by_thread_id->{$thread_id};
+	} else {
+		$result = [];
+		$stacks_by_thread_id->{$thread_id} = $result;
+	}
+	
+	$result;
+}
+sub make_stack_current_by_thread_id {
+	my ($thread_id) = @_;
+	$current_stack = get_stack_by_thread_id ($thread_id);
+}
+sub push_in_current_stack {
+	my ($method_info) = @_;
+	push @{$current_stack}, $method_info;
+}
+sub pop_from_current_stack {
+	pop @{$current_stack};
+}
+
+
+
+
+
+sub print_sublist {
+	my ($list, $item, $length) = @_;
+	
+	foreach my $i (0 .. $length) {
+		my $element = $list->[$i];
+		my $name = $element->{'name'};
+		my $value = $element->{$item};
+		print "  $value $name\n";
+	}
+}
+
+sub print_summary {
+	foreach my $method (values %{$methods_by_id}) {
+		$method->{'total_time'} = $method->{'total_ticks'} * $time_per_tick / 1000000;
+		$method->{'effective_time'} = ($method->{'total_ticks'} - $method->{'called_ticks'}) * $time_per_tick / 1000000;
+		$method->{'jit_time'} = $method->{'jit_time'} * $time_per_tick / 1000000;
+	}
+	
+	my @methods_by_total_time = sort {$b->{'total_time'} <=> $a->{'total_time'}} values %{$methods_by_id};
+	print "Methods by total time\n";
+	print_sublist (\@methods_by_total_time, 'total_time', 25);
+	
+	my @methods_by_effective_time = sort {$b->{'effective_time'} <=> $a->{'effective_time'}} values %{$methods_by_id};
+	print "Methods by effective time\n";
+	print_sublist (\@methods_by_effective_time, 'effective_time', 25);
+	
+	my @methods_by_jit_time = sort {$b->{'jit_time'} <=> $a->{'jit_time'}} values %{$methods_by_id};
+	print "Methods by jit time\n";
+	print_sublist (\@methods_by_jit_time, 'jit_time', 25);
+	
+	my @methods_by_statistical_hits = sort {$b->{'statistical_hits'} <=> $a->{'statistical_hits'}} values %{$methods_by_id};
+	print "Methods by statistical hits\n";
+	print_sublist (\@methods_by_statistical_hits, 'statistical_hits', 25);
+	
+	my @classes_by_allocations = sort {$b->{'allocations'} <=> $a->{'allocations'}} values %{$classes_by_id};
+	print "Classes by allocations\n";
+	print_sublist (\@classes_by_allocations, 'allocations', 25);
+}
+
+
+
+
+
+$file_offset = 0;
+
+
+sub read_raw_byte {
+	my $byte;
+	if (read (LOG, $byte, 1) == 1) {
+		$file_offset ++;
+		$byte;
+	} else {
+		die "Unexpexted read error (offset $file_offset)\n";
+	}
+}
+
+sub read_byte {
+	my $byte = read_raw_byte ();
+	unpack ("C", $byte);
+}
+
+sub read_integer {
+	my $value = read_byte ();
+	my $result = ($value & 0x7f);
+	my $factor = 128;
+	
+	#print "    read_integer WORKS ON $result\n";
+	
+	while (($value & 0x80) == 0) {
+		$value = read_byte ();
+		$result += (($value & 0x7f) * $factor);
+		$factor *= 128;
+		
+		#print "    read_integer WORKS ON $result\n";
+	}
+	
+	#print "    read_integer GOT $result\n";
+	
+	$result;
+}
+
+sub read_string {
+	my $char = read_raw_byte ();
+	
+	my $result = "";
+	while ($char ne "\0") {
+		$result .= $char;
+		$char = read_raw_byte ();
+	}
+	
+	$result;
+}
+
+sub read_intro_block {
+	$log_version = read_integer ();	
+	$runtime_file = read_string ();
+	$start_counter = read_integer ();	
+	$start_time = read_integer ();	
+	
+	my $time = $start_time / 1000000;
+	
+	if ($LOG_DECODED_EVENTS) {
+		print "INTRO BLOCK version $log_version, file $runtime_file (counter $start_counter, time $time)\n";
+	}
+}
+
+sub read_clock_block {
+	my $counter = read_integer () - $start_counter;
+	my $time = (read_integer () - $start_time) / 1000000;
+	
+	if ($LOG_DECODED_EVENTS) {
+		print "CLOCK BLOCK (counter $counter, time $time)\n";
+	}
+}
+
+sub read_end_block {
+	my $final_version = read_integer ();	
+	$end_counter = read_integer ();	
+	$end_time = read_integer ();
+	$time_per_tick = ($end_time - $start_time) / ($end_counter - $start_counter);
+	
+	my $time = $end_time / 1000000;
+	
+	if ($LOG_DECODED_EVENTS) {
+		print "END BLOCK version $final_version (counter $end_counter, time $time)\n";
+	}
+	
+	close LOG;
+	
+	#process data here
+	print_summary ();
+	
+	exit (0);
+}
+
+$LOADED_EVENT_MODULE =     1;
+$LOADED_EVENT_ASSEMBLY =   2;
+$LOADED_EVENT_APPDOMAIN =  4;
+$LOADED_EVENT_SUCCESS =    8;
+$LOADED_EVENT_FAILURE =   16;
+
+sub load_code_to_string {
+	my ($code) = @_[0];
+	my $result = "";
+	if ($code & $LOADED_EVENT_MODULE)    {$result .= "MODULE"}
+	if ($code & $LOADED_EVENT_ASSEMBLY)  {$result .= "ASSEMBLY"}
+	if ($code & $LOADED_EVENT_APPDOMAIN) {$result .= "APPDOMAIN"}
+	if ($code & $LOADED_EVENT_SUCCESS)   {$result .= ":SUCCESS"}
+	if ($code & $LOADED_EVENT_FAILURE)   {$result .= ":FAILURE"}
+	$result;
+}
+
+sub read_element_load_block {
+	my $kind = read_byte ();
+	my $start = read_integer () - $start_counter;
+	my $end = read_integer () - $start_counter;
+	my $thread_id = read_integer ();
+	my $name = read_string ();
+	my $kind_name = load_code_to_string ($kind);
+	
+	if ($LOG_DECODED_EVENTS) {
+		print "LOAD BLOCK $kind_name \"$name\" (start $start, end $end) [TID:$thread_id]\n";
+	}
+}
+
+sub read_element_unload_block {
+	my $kind = read_byte ();
+	my $start = read_integer () - $start_counter;
+	my $end = read_integer () - $start_counter;
+	my $thread_id = read_integer ();
+	my $name = read_string ();
+	my $kind_name = load_code_to_string ($kind);
+	
+	if ($LOG_DECODED_EVENTS) {
+		print "UNLOAD BLOCK $kind_name \"$name\" (start $start, end $end) [TID:$thread_id]\n";
+	}
+}
+
+sub read_mapping_block {
+	my $start = read_integer () - $start_counter;
+	my $thread_id = read_integer ();
+	
+	if ($LOG_DECODED_EVENTS) {
+		print "MAPPING BLOCK START (start $start) [TID:$thread_id]\n";
+	}
+	
+	my $id = read_integer ();
+	while ($id != 0) {
+		my $name = read_string ();
+		$classes_by_id->{$id} = {
+			'name' => $name,
+			'allocations' => 0,
+		};
+		if ($LOG_DECODED_EVENTS) {
+			print "MAPPING CLASS ($id => $name)\n";
+		}
+		$id = read_integer ();
+	}
+	
+	$id = read_integer ();
+	while ($id != 0) {
+		my $class_id = read_integer ();
+		my $name = read_string ();
+		$methods_by_id->{$id} = {
+			'name' => $name,
+			'class' => $classes_by_id->{$class_id},
+			'jit_ticks' => 0,
+			'total_ticks' => 0,
+			'called_ticks' => 0,
+			'statistical_hits' => 0,
+		};
+		if ($LOG_DECODED_EVENTS) {
+			print "MAPPING METHOD ($id => $name) (class was $class_id)\n";
+		}
+		$id = read_integer ();
+	}
+	
+	my $end = read_integer () - $start_counter;
+	if ($LOG_DECODED_EVENTS) {
+		print "MAPPING BLOCK END (start $start) [TID:$thread_id]\n";
+	}
+}
+
+$EVENT_METHOD_CALL = 0;
+$EVENT_METHOD_JIT = 1;
+$EVENT_METHOD_FREED = 2;
+$method_event_code_map = {
+	$EVENT_METHOD_CALL => 'CALL',
+	$EVENT_METHOD_JIT => 'JIT',
+	$EVENT_METHOD_FREED => 'FREED',
+};
+
+$EVENT_CLASS_LOAD = 0;
+$EVENT_CLASS_UNLOAD = 1;
+$EVENT_CLASS_ALLOCATION = 2;
+$EVENT_CLASS_EXCEPTION = 3;
+$class_event_code_map = {
+	$EVENT_CLASS_LOAD => 'LOAD',
+	$EVENT_CLASS_UNLOAD => 'UNLOAD',
+	$EVENT_CLASS_ALLOCATION => 'ALLOCATION',
+	$EVENT_CLASS_EXCEPTION => 'EXCEPTION',
+};
+
+$EVENT_RESULT_SUCCESS = 0;
+$EVENT_RESULT_FAILURE = 4;
+$EVENT_RESULT_MASK = $EVENT_RESULT_FAILURE;
+$event_result_map = {
+	$EVENT_RESULT_SUCCESS => 'SUCCESS',
+	$EVENT_RESULT_FAILURE => 'FAILURE',
+};
+
+$EVENT_THREAD = 1;
+$EVENT_GC_COLLECTION = 2;
+$EVENT_GC_MARK = 3;
+$EVENT_GC_SWEEP = 4;
+$EVENT_GC_RESIZE = 5;
+$event_code_map = {
+	$EVENT_THREAD => 'THREAD',
+	$EVENT_GC_COLLECTION => 'GC_COLLECTION',
+	$EVENT_GC_MARK => 'GC_MARK',
+	$EVENT_GC_SWEEP => 'GC_SWEEP',
+	$EVENT_GC_RESIZE => 'GC_RESIZE',
+};
+
+
+$EVENT_KIND_START = 0;
+$EVENT_KIND_END = 1;
+$event_kind_map = {
+	$EVENT_KIND_START => 'START',
+	$EVENT_KIND_END => 'END',
+};
+
+sub mark_event {
+	$event_counter ++;
+	print "[EVENT:$event_counter]";
+}
+
+sub process_event {
+	my ($code, $primary_value, $secondary_value, $base_counter) = @_;
+	
+	my $is_method = ($code >> 5) & 1;
+	my $is_class = ($code >> 4) & 1;
+	my $kind = ($code >> 3) & 1;
+	
+	if ($is_method) {
+		my $event = $code & ($EVENT_RESULT_MASK - 1);
+		my $result = $code & $EVENT_RESULT_MASK;
+		my $method = $methods_by_id->{$primary_value};
+		my $class = $method->{'class'};
+		
+		if ($event == $EVENT_METHOD_CALL) {
+			$base_counter += $secondary_value;
+			
+			if ($kind == $EVENT_KIND_START) {
+				push_in_current_stack ({
+					'method' => $method,
+					'start' => $base_counter,
+				});
+			} else {
+				my $stack_head = pop_from_current_stack ();
+				$stack_head->{'method'} == $method || die "Mismatched call-return sequence\n";
+				my $ticks = $base_counter - $stack_head->{'start'};
+				$method->{'total_ticks'} += $ticks;
+				if (@{$current_stack} > 0) {
+					$current_stack->[$#{@{$current_stack}}]->{'called_ticks'} += $ticks;
+				}
+			}
+		} elsif ($event == $EVENT_METHOD_JIT) {
+			$base_counter += $secondary_value;
+			
+			if ($kind == $EVENT_KIND_START) {
+				$method->{'jit_ticks'} = $base_counter;
+			} else {
+				$method->{'jit_ticks'} = $base_counter - $method->{'jit_ticks'};
+			}
+		} elsif ($event == $EVENT_METHOD_FREED) {
+			$base_counter += $secondary_value;
+		} else {
+			die "Unknown code $code\n";
+		}
+		
+		if ($LOG_DECODED_EVENTS) {
+			my $counter = $base_counter - $start_counter;
+			my $event_name = $method_event_code_map->{$event};
+			my $kind_name = $event_kind_map->{$kind};
+			my $result_name = $event_result_map->{$result};
+			my $method_name = $method->{'name'} . ':' . $class->{'name'};
+			mark_event ();
+			print "METHOD EVENT $event_name:$kind_name:$result_name ($counter) \"$method_name\" {$code:$primary_value:$secondary_value}\n";
+		}
+	} elsif ($is_class) {
+		my $event = $code & ($EVENT_RESULT_MASK - 1);
+		my $result = $code & $EVENT_RESULT_MASK;
+		my $class = $classes_by_id->{$primary_value};
+		my $value = 0;
+		
+		if ($event == $EVENT_CLASS_LOAD) {
+			$base_counter += $secondary_value;
+			$value = $base_counter - $start_counter;
+		} elsif ($event == $EVENT_CLASS_UNLOAD) {
+			$base_counter += $secondary_value;
+			$value = $base_counter - $start_counter;
+		} elsif ($event == $EVENT_CLASS_ALLOCATION) {
+			$value = $secondary_value;
+			
+			$class->{'allocations'} += $value;
+		} elsif ($event == $EVENT_CLASS_EXCEPTION) {
+			$base_counter += $secondary_value;
+			$value = $base_counter - $start_counter;
+		} else {
+			die "Unknown code $code\n";
+		}
+		
+		if ($LOG_DECODED_EVENTS) {
+			my $event_name = $class_event_code_map->{$event};
+			my $kind_name = $event_kind_map->{$kind};
+			my $result_name = $event_result_map->{$result};
+			my $class_name = $class->{'name'};
+			mark_event ();
+			print "CLASS EVENT $event_name:$kind_name:$result_name ($value) \"$class_name\" {$code:$primary_value:$secondary_value}\n";
+		}
+	} else {
+		my $event = ($code) & 7;
+		my $value = 0;
+		
+		if ($event == $EVENT_THREAD) {
+			$base_counter += $secondary_value;
+			$value = $base_counter - $start_counter;
+		} elsif ($event == $EVENT_GC_COLLECTION) {
+			$base_counter += $secondary_value;
+			$value = $base_counter - $start_counter;
+		} elsif ($event == $EVENT_GC_MARK) {
+			$base_counter += $secondary_value;
+			$value = $base_counter - $start_counter;
+		} elsif ($event == $EVENT_GC_SWEEP) {
+			$base_counter += $secondary_value;
+			$value = $base_counter - $start_counter;
+		} elsif ($event == $EVENT_GC_RESIZE) {
+			$base_counter += $secondary_value;
+			$value = $base_counter - $start_counter;
+		} else {
+			die "Unknown code $code\n";
+		}
+		
+		if ($LOG_DECODED_EVENTS) {
+			my $event_name = $event_code_map->{$event};
+			my $kind_name = $event_kind_map->{$kind};
+			mark_event ();
+			print "EVENT $event_name:$kind_name ($primary_value, $value) {$code:$primary_value:$secondary_value}\n";
+		}
+	}
+	
+	$base_counter;
+}
+
+sub read_event_block {
+	my $start = read_integer () - $start_counter;
+	my $thread_id = read_integer ();
+	my $base_counter = read_integer ();
+	
+	make_stack_current_by_thread_id ($thread_id);
+	
+	if ($LOG_DECODED_EVENTS) {
+		print "EVENT BLOCK START (start $start, base $base_counter) [TID:$thread_id]\n";
+	}
+	
+	my $code = read_byte ();
+	while ($code != 0) {
+		my $primary_value = read_integer ();
+		my $secondary_value = read_integer ();
+		$base_counter = process_event ($code, $primary_value, $secondary_value, $base_counter);
+		$code = read_byte ();
+	}
+	
+	my $end = read_integer () - $start_counter;
+	if ($LOG_DECODED_EVENTS) {
+		print "EVENT BLOCK END (end $end) [TID:$thread_id]\n";
+	}
+}
+
+sub read_statistical_block {
+	my $start = read_integer () - $start_counter;
+	
+	my $managed_stat_hits_start = $managed_stat_hits;
+	my $unmanaged_stat_hits_start = $unmanaged_stat_hits;
+	
+	my $method_id = read_integer ();
+	while ($method_id != 0) {
+		my $method = $methods_by_id->{$method_id};
+		$method->{'statistical_hits'} ++;
+		$method_id = read_integer ();
+		
+		$managed_stat_hits ++;
+	}
+	
+	my $function_id = read_integer ();
+	while ($function_id != 0) {
+		#my $function = $functions_by_id->{$function_id};
+		#$function->{'statistical_hits'} ++;
+		$function_id = read_integer ();
+		
+		$unmanaged_stat_hits ++;
+	}
+	
+	my $end = read_integer () - $start_counter;
+	if ($LOG_DECODED_EVENTS) {
+		print "STATISTICAL BLOCK END (end $end)\n";
+	}
+	
+	print "STATISTICAL BLOCK: managed from $managed_stat_hits_start to $managed_stat_hits, unmanaged from $unmanaged_stat_hits_start to $unmanaged_stat_hits\n";
+}
+
+$FILE_BLOCK_KIND_INTRO = 1;
+$FILE_BLOCK_KIND_CLOCK = 2;
+$FILE_BLOCK_KIND_LOADED = 3;
+$FILE_BLOCK_KIND_UNLOADED = 4;
+$FILE_BLOCK_KIND_MAPPING = 5;
+$FILE_BLOCK_KIND_EVENTS = 6;
+$FILE_BLOCK_KIND_STATISTICAL = 7;
+$FILE_BLOCK_KIND_END = 8;
+
+$block_code_map = {
+	$FILE_BLOCK_KIND_INTRO => 'INTRO',
+	$FILE_BLOCK_KIND_CLOCK => 'CLOCK',
+	$FILE_BLOCK_KIND_LOADED => 'LOADED',
+	$FILE_BLOCK_KIND_UNLOADED => 'UNLOADED',
+	$FILE_BLOCK_KIND_MAPPING => 'MAPPING',
+	$FILE_BLOCK_KIND_EVENTS => 'EVENTS',
+	$FILE_BLOCK_KIND_STATISTICAL => 'STATISTICAL',
+	$FILE_BLOCK_KIND_END => 'END',
+};
+
+sub read_block {
+	my $code = read_byte ();
+	
+	print "Found $block_code_map->{$code} block at offset $file_offset, reading...\n";
+	
+	if ($code == $FILE_BLOCK_KIND_INTRO) {
+		read_intro_block ();
+	} elsif ($code == $FILE_BLOCK_KIND_CLOCK) {
+		read_clock_block ();
+	} elsif ($code == $FILE_BLOCK_KIND_LOADED) {
+		read_element_load_block ();
+	} elsif ($code == $FILE_BLOCK_KIND_UNLOADED) {
+		read_element_unload_block ();
+	} elsif ($code == $FILE_BLOCK_KIND_MAPPING) {
+		read_mapping_block ();
+	} elsif ($code == $FILE_BLOCK_KIND_EVENTS) {
+		read_event_block ();
+	} elsif ($code == $FILE_BLOCK_KIND_STATISTICAL) {
+		read_statistical_block ();
+	} elsif ($code == $FILE_BLOCK_KIND_END) {
+		read_end_block ();
+	} else {
+		die "Bad block code $code\n";
+	}
+}
+
+
+while (1) {
+	read_block ();
+}
+
+close LOG;

Property changes on: decode-profiler-log.pl
___________________________________________________________________
Name: svn:executable
   + *

Index: mono-profiler-logging.c
===================================================================
--- mono-profiler-logging.c	(revision 0)
+++ mono-profiler-logging.c	(revision 0)
@@ -0,0 +1,1418 @@
+#include <mono/metadata/profiler.h>
+#include <mono/metadata/class.h>
+#include <mono/metadata/assembly.h>
+#include <mono/metadata/loader.h>
+#include <mono/metadata/threads.h>
+#include <mono/metadata/debug-helpers.h>
+#include <mono/io-layer/atomic.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <glib.h>
+
+
+
+#ifdef HAVE_KW_THREAD
+static __thread MonoProfiler * tls_profiler_per_thread_data;
+#define LOOKUP_PROFILER_THREAD_DATA() ((ProfilerPerThreadData*) tls_profiler_per_thread_data)
+#define SET_PROFILER_THREAD_DATA(x) tls_profiler_per_thread_data = (x)
+#define ALLOCATE_PROFILER_THREAD_DATA() /* nop */
+#define FREE_PROFILER_THREAD_DATA() /* nop */
+#endif
+
+#if 1
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <semaphore.h>
+
+#define MUTEX_TYPE pthread_mutex_t
+#define INITIALIZE_PROFILER_MUTEX() pthread_mutex_init (&(profiler->mutex), NULL)
+#define DELETE_PROFILER_MUTEX() pthread_mutex_destroy (&(profiler->mutex))
+#define LOCK_PROFILER() pthread_mutex_lock (&(profiler->mutex))
+#define UNLOCK_PROFILER() pthread_mutex_unlock (&(profiler->mutex))
+
+#define THREAD_TYPE pthread_t
+#define CREATE_WRITER_THREAD(f) pthread_create (&(profiler->statistical_data_writer_thread), NULL, ((void*(*)(void*))f), NULL)
+#define EXIT_THREAD() pthread_exit (NULL);
+#define WAIT_WRITER_THREAD() pthread_join (profiler->statistical_data_writer_thread, NULL)
+#define CURRENT_THREAD_ID() (gsize) pthread_self ()
+
+#ifndef HAVE_KW_THREAD
+static pthread_key_t pthread_profiler_key;
+static pthread_once_t profiler_pthread_once = PTHREAD_ONCE_INIT;
+static void
+make_pthread_profiler_key (void) {
+    (void) pthread_key_create (&pthread_profiler_key, NULL);
+}
+#define LOOKUP_PROFILER_THREAD_DATA() ((ProfilerPerThreadData*) pthread_getspecific (pthread_profiler_key))
+#define SET_PROFILER_THREAD_DATA(x) (void) pthread_setspecific (pthread_profiler_key, (x))
+#define ALLOCATE_PROFILER_THREAD_DATA() (void) pthread_once (&profiler_pthread_once, make_pthread_profiler_key)
+#define FREE_PROFILER_THREAD_DATA() (void) pthread_key_delete (pthread_profiler_key)
+#endif
+
+#define EVENT_TYPE sem_t
+#define WRITER_EVENT_INIT() (void) sem_init (&(profiler->statistical_data_writer_event), 0, 0)
+#define WRITER_EVENT_DESTROY() (void) sem_destroy (&(profiler->statistical_data_writer_event))
+#define WRITER_EVENT_WAIT() (void) sem_wait (&(profiler->statistical_data_writer_event))
+#define WRITER_EVENT_RAISE() (void) sem_post (&(profiler->statistical_data_writer_event))
+
+#else
+
+#include <windows.h>
+
+#define MUTEX_TYPE CRITICAL_SECTION
+#define INITIALIZE_PROFILER_MUTEX() InitializeCriticalSection (&(profiler->mutex))
+#define DELETE_PROFILER_MUTEX() DeleteCriticalSection (&(profiler->mutex))
+#define LOCK_PROFILER() EnterCriticalSection (&(profiler->mutex))
+#define UNLOCK_PROFILER() LeaveCriticalSection (&(profiler->mutex))
+
+#define THREAD_TYPE HANDLE
+#define CREATE_WRITER_THREAD(f) CreateThread (NULL, (1*1024*1024), (f), NULL, 0, NULL);
+#define EXIT_THREAD() ExitThread (0);
+#define WAIT_WRITER_THREAD() WaitForSingleObject (profiler->statistical_data_writer_thread, INFINITE)
+#define CURRENT_THREAD_ID() (gsize) GetCurrentThreadId ()
+
+#ifndef HAVE_KW_THREAD
+static guint32 profiler_thread_id = -1;
+#define LOOKUP_PROFILER_THREAD_DATA() ((ProfilerPerThreadData*)TlsGetValue (profiler_thread_id))
+#define SET_PROFILER_THREAD_DATA(x) TlsSetValue (profiler_thread_id, (x));
+#define ALLOCATE_PROFILER_THREAD_DATA() profiler_thread_id = TlsAlloc ()
+#define FREE_PROFILER_THREAD_DATA() TlsFree (profiler_thread_id)
+#endif
+
+#define EVENT_TYPE HANDLE
+#define WRITER_EVENT_INIT() profiler->statistical_data_writer_event = CreateEvent (NULL, FALSE, FALSE, NULL)
+#define WRITER_EVENT_DESTROY() CloseHandle (profiler->statistical_data_writer_event)
+#define WRITER_EVENT_WAIT() WaitForSingleObject (profiler->statistical_data_writer_event, INFINITE)
+#define WRITER_EVENT_RAISE() SetEvent (profiler->statistical_data_writer_event)
+
+#endif
+
+
+#define GET_PROFILER_THREAD_DATA(data) do {\
+	ProfilerPerThreadData *_result = LOOKUP_PROFILER_THREAD_DATA ();\
+	if (!_result) {\
+		_result = profiler_per_thread_data_new (profiler->per_thread_buffer_size);\
+		LOCK_PROFILER ();\
+		_result->next = profiler->per_thread_data;\
+		profiler->per_thread_data = _result;\
+		UNLOCK_PROFILER ();\
+		SET_PROFILER_THREAD_DATA (_result);\
+	}\
+	data = _result;\
+} while (0)
+
+
+
+#define DEBUG_LOGGING_PROFILER 0
+//if (DEBUG_LOGGING_PROFILER)
+#if (1)
+#define LOG_WRITER_THREAD(m) printf ("WRITER-THREAD-LOG %s\n", m)
+#else
+#define LOG_WRITER_THREAD(m)
+#endif
+
+#if DEBUG_LOGGING_PROFILER
+static int event_counter = 0;
+#define EVENT_MARK() printf ("[EVENT:%d]", ++ event_counter)
+#endif
+
+typedef enum {
+	MONO_PROFILER_FILE_BLOCK_KIND_INTRO = 1,
+	MONO_PROFILER_FILE_BLOCK_KIND_CLOCK = 2,
+	MONO_PROFILER_FILE_BLOCK_KIND_LOADED = 3,
+	MONO_PROFILER_FILE_BLOCK_KIND_UNLOADED = 4,
+	MONO_PROFILER_FILE_BLOCK_KIND_MAPPING = 5,
+	MONO_PROFILER_FILE_BLOCK_KIND_EVENTS = 6,
+	MONO_PROFILER_FILE_BLOCK_KIND_STATISTICAL = 7,
+	MONO_PROFILER_FILE_BLOCK_KIND_END = 8
+} MonoProfilerFileBlockKind;
+
+#define MONO_PROFILER_LOADED_EVENT_MODULE     1
+#define MONO_PROFILER_LOADED_EVENT_ASSEMBLY   2
+#define MONO_PROFILER_LOADED_EVENT_APPDOMAIN  4
+#define MONO_PROFILER_LOADED_EVENT_SUCCESS    8
+#define MONO_PROFILER_LOADED_EVENT_FAILURE   16
+
+
+typedef struct _ProfilerEventData {
+	union {
+		gpointer address;
+		gsize number;
+	} data;
+	unsigned int is_method:1;
+	unsigned int is_class:1;
+	unsigned int code:3;
+	unsigned int kind:1;
+	unsigned int value:26;
+} ProfilerEventData;
+
+#define EXTENDED_EVENT_VALUE_SHIFT (26)
+#define MAX_EVENT_VALUE ((1<<EXTENDED_EVENT_VALUE_SHIFT)-1)
+#define MAX_EXTENDED_EVENT_VALUE ((((guint64))MAX_EVENT_VALUE<<32)|((guint64)0xffffffff))
+
+typedef enum {
+	MONO_PROFILER_EVENT_METHOD_CALL = 0,
+	MONO_PROFILER_EVENT_METHOD_JIT = 1,
+	MONO_PROFILER_EVENT_METHOD_FREED = 2
+} MonoProfilerMethodEvents;
+typedef enum {
+	MONO_PROFILER_EVENT_CLASS_LOAD = 0,
+	MONO_PROFILER_EVENT_CLASS_UNLOAD = 1,
+	MONO_PROFILER_EVENT_CLASS_ALLOCATION = 2,
+	MONO_PROFILER_EVENT_CLASS_EXCEPTION = 3
+} MonoProfilerClassEvents;
+typedef enum {
+	MONO_PROFILER_EVENT_RESULT_SUCCESS = 0,
+	MONO_PROFILER_EVENT_RESULT_FAILURE = 4
+} MonoProfilerEventResult;
+#define MONO_PROFILER_EVENT_RESULT_MASK MONO_PROFILER_EVENT_RESULT_FAILURE
+typedef enum {
+	MONO_PROFILER_EVENT_THREAD = 1,
+	MONO_PROFILER_EVENT_GC_COLLECTION = 2,
+	MONO_PROFILER_EVENT_GC_MARK = 3,
+	MONO_PROFILER_EVENT_GC_SWEEP = 4,
+	MONO_PROFILER_EVENT_GC_RESIZE = 5
+} MonoProfilerEvents;
+typedef enum {
+	MONO_PROFILER_EVENT_KIND_START = 0,
+	MONO_PROFILER_EVENT_KIND_END = 1
+} MonoProfilerEventKind;
+
+#define MONO_PROFILER_EVENT_GET_FULL_CODE(e)\
+	(((e)->is_method<<5)|\
+	((e)->is_class<<4)|\
+	((e)->kind<<3)|\
+	((e)->code))
+
+#define MONO_PROFILER_GET_CURRENT_TIME(t) {\
+	struct timeval current_time;\
+	gettimeofday (&current_time, NULL);\
+	(t) = (((guint64)current_time.tv_sec) * 1000000) + current_time.tv_usec;\
+} while (0)
+#define MONO_PROFILER_GET_CURRENT_COUNTER(c) MONO_PROFILER_GET_CURRENT_TIME ((c));
+
+
+typedef struct _IdMappingElement {
+	char *name;
+	gpointer item;
+	guint32 id;
+	struct _IdMappingElement *next_unwritten;
+} IdMappingElement;
+
+typedef struct _IdMapping {
+	GHashTable *table;
+	IdMappingElement *unwritten;
+	guint32 next_id;
+} IdMapping;
+
+
+static IdMappingElement*
+id_mapping_element_get (IdMapping *map, gconstpointer item) {
+	return g_hash_table_lookup (map->table, item);
+}
+
+static IdMappingElement*
+id_mapping_element_new (IdMapping *map, gpointer item, char *name) {
+	IdMappingElement *element = g_new (IdMappingElement, 1);
+	element->name = name;
+	element->item = item;
+	element->next_unwritten = map->unwritten;
+	map->unwritten = element;
+	element->id = map->next_id;
+	map->next_id ++;
+	g_hash_table_insert (map->table, item, element);
+	
+	return element;
+}
+
+static void
+id_mapping_element_destroy (gpointer element) {
+	if (((IdMappingElement*)element)->name)
+		g_free (((IdMappingElement*)element)->name);
+	g_free (element);
+}
+
+#if 0
+static void
+id_mapping_element_remove (IdMapping *map, gpointer item) {
+	g_hash_table_remove (map->table, item);
+}
+#endif
+
+static IdMapping*
+id_mapping_new (void) {
+	IdMapping *result = g_new (IdMapping, 1);
+	//result->table = g_hash_table_new_full (mono_aligned_addr_hash, NULL, NULL, id_mapping_element_destroy);
+	result->table = g_hash_table_new_full (g_direct_hash, NULL, NULL, id_mapping_element_destroy);
+	result->unwritten = NULL;
+	result->next_id = 1;
+	return result;
+}
+
+static void
+id_mapping_destroy (IdMapping *map) {
+	g_hash_table_destroy (map->table);
+	g_free (map);
+}
+
+
+typedef struct _LoadedElement {
+	char *name;
+	guint64 load_start_counter;
+	guint64 load_end_counter;
+	guint64 unload_start_counter;
+	guint64 unload_end_counter;
+	guint8 loaded;
+	guint8 load_written;
+	guint8 unloaded;
+	guint8 unload_written;
+} LoadedElement;
+
+static LoadedElement*
+loaded_element_load_start (GHashTable *table, gpointer item) {
+	LoadedElement *element = g_new0 (LoadedElement, 1);
+	MONO_PROFILER_GET_CURRENT_COUNTER (element->load_start_counter);
+	g_hash_table_insert (table, item, element);
+	return element;
+}
+
+static LoadedElement*
+loaded_element_load_end (GHashTable *table, gpointer item, char *name) {
+	LoadedElement *element = g_hash_table_lookup (table, item);
+	g_assert (element != NULL);
+	MONO_PROFILER_GET_CURRENT_COUNTER (element->load_end_counter);
+	element->name = name;
+	element->loaded = TRUE;
+	return element;
+}
+
+static LoadedElement*
+loaded_element_unload_start (GHashTable *table, gpointer item) {
+	LoadedElement *element = g_hash_table_lookup (table, item);
+	g_assert (element != NULL);
+	MONO_PROFILER_GET_CURRENT_COUNTER (element->unload_start_counter);
+	return element;
+}
+
+static LoadedElement*
+loaded_element_unload_end (GHashTable *table, gpointer item) {
+	LoadedElement *element = g_hash_table_lookup (table, item);
+	g_assert (element != NULL);
+	MONO_PROFILER_GET_CURRENT_COUNTER (element->unload_end_counter);
+	element->unloaded = TRUE;
+	return element;
+}
+
+
+static void
+loaded_element_destroy (gpointer element) {
+	if (((LoadedElement*)element)->name)
+		g_free (((LoadedElement*)element)->name);
+	g_free (element);
+}
+
+typedef struct _ProfilerPerThreadData {
+	ProfilerEventData *events;
+	ProfilerEventData *next_free_event;
+	ProfilerEventData *end_event;
+	ProfilerEventData *first_unwritten_event;
+	guint64 start_event_counter;
+	guint64 last_event_counter;
+	gsize thread_id;
+	
+	struct _ProfilerPerThreadData* next;
+} ProfilerPerThreadData;
+
+typedef struct _ProfilerStatisticalData {
+	gpointer *addresses;
+	int next_free_index;
+	int end_index;
+	int first_unwritten_index;
+} ProfilerStatisticalData;
+
+
+struct _MonoProfiler {
+	MUTEX_TYPE mutex;
+	
+	MonoProfileFlags flags;
+	char *file_name;
+	FILE *file;
+	
+	guint64 start_time;
+	guint64 start_counter;
+	guint64 end_time;
+	guint64 end_counter;
+	
+	IdMapping *methods;
+	IdMapping *classes;
+	
+	GHashTable *loaded_assemblies;
+	GHashTable *loaded_modules;
+	GHashTable *loaded_appdomains;
+	
+	guint32 per_thread_buffer_size;
+	guint32 statistical_buffer_size;
+	ProfilerPerThreadData* per_thread_data;
+	ProfilerStatisticalData *statistical_data;
+	ProfilerStatisticalData *statistical_data_ready;
+	ProfilerStatisticalData *statistical_data_second_buffer;
+	guint32 *statistical_hits_managed_ids;
+	guint32 *statistical_hits_unmanaged_ids;
+	THREAD_TYPE statistical_data_writer_thread;
+	EVENT_TYPE statistical_data_writer_event;
+	gboolean statistical_data_writer_terminate;
+};
+static MonoProfiler *profiler;
+
+static ProfilerPerThreadData*
+profiler_per_thread_data_new (guint32 buffer_size)
+{
+	ProfilerPerThreadData *data = g_new (ProfilerPerThreadData, 1);
+
+	data->events = g_new0 (ProfilerEventData, buffer_size);
+	data->next_free_event = data->events;
+	data->end_event = data->events + (buffer_size - 1);
+	data->first_unwritten_event = data->events;
+	MONO_PROFILER_GET_CURRENT_COUNTER (data->start_event_counter);
+	data->last_event_counter = data->start_event_counter;
+	data->thread_id = CURRENT_THREAD_ID ();
+	
+	return data;
+}
+
+static void
+profiler_per_thread_data_destroy (ProfilerPerThreadData *data) {
+	g_free (data->events);
+	g_free (data);
+}
+
+static ProfilerStatisticalData*
+profiler_statistical_data_new (guint32 buffer_size)
+{
+	ProfilerStatisticalData *data = g_new (ProfilerStatisticalData, 1);
+
+	data->addresses = g_new0 (gpointer, buffer_size);
+	data->next_free_index = 0;
+	data->end_index = buffer_size;
+	data->first_unwritten_index = 0;
+	
+	return data;
+}
+
+static void
+profiler_statistical_data_destroy (ProfilerStatisticalData *data) {
+	g_free (data->addresses);
+	g_free (data);
+}
+
+#if 1
+#define OPEN_FILE() profiler->file = fopen (profiler->file_name, "wb");
+#define WRITE_BYTE(b) putc ((b),profiler->file)
+#define FLUSH_FILE() fflush (profiler->file)
+#define CLOSE_FILE() fclose (profiler->file);
+#else
+#define OPEN_FILE() profiler->file = GUINT_TO_POINTER ( open (profiler->file_name, O_WRONLY|O_CREAT|O_TRUNC));
+#define WRITE_BYTE(b) do {\
+	guint8 byte = (b);\
+	write (GPOINTER_TO_UINT (profiler->file), &byte, 1);\
+} while (0)
+#define FLUSH_FILE()
+#define CLOSE_FILE() close (GPOINTER_TO_UINT (profiler->file));
+#endif
+
+#define SEVEN_BITS_MASK (0x7f)
+#define EIGHT_BIT_MASK (0x80)
+
+static void
+write_uint32 (guint32 value) {
+	while (value > SEVEN_BITS_MASK) {
+		WRITE_BYTE (value & SEVEN_BITS_MASK);
+		value >>= 7;
+	}
+	WRITE_BYTE (value | EIGHT_BIT_MASK);
+}
+static void
+write_uint64 (guint64 value) {
+	while (value > SEVEN_BITS_MASK) {
+		WRITE_BYTE (value & SEVEN_BITS_MASK);
+		value >>= 7;
+	}
+	WRITE_BYTE (value | EIGHT_BIT_MASK);
+}
+static void
+write_string (const char *string) {
+	while (*string != 0) {
+		WRITE_BYTE (*string);
+		string ++;
+	}
+	WRITE_BYTE (0);
+}
+
+static void
+write_element_load_block (LoadedElement *element, guint8 kind, gsize thread_id) {
+	WRITE_BYTE (MONO_PROFILER_FILE_BLOCK_KIND_LOADED);
+	WRITE_BYTE (kind);
+	write_uint64 (element->load_start_counter);
+	write_uint64 (element->load_end_counter);
+	write_uint64 (thread_id);
+	write_string (element->name);
+	element->load_written = TRUE;
+}
+
+static void
+write_element_unload_block (LoadedElement *element, guint8 kind, gsize thread_id) {
+	WRITE_BYTE (MONO_PROFILER_FILE_BLOCK_KIND_UNLOADED);
+	WRITE_BYTE (kind);
+	write_uint64 (element->unload_start_counter);
+	write_uint64 (element->unload_end_counter);
+	write_uint64 (thread_id);
+	write_string (element->name);
+	element->unload_written = TRUE;
+}
+
+static void
+write_mapping_block (gsize thread_id) {
+	guint64 counter;
+	IdMappingElement *current_element;
+	
+	if ((profiler->classes->unwritten == NULL) && (profiler->methods->unwritten == NULL))
+		return;
+	
+	WRITE_BYTE (MONO_PROFILER_FILE_BLOCK_KIND_MAPPING);
+	MONO_PROFILER_GET_CURRENT_COUNTER (counter);
+	write_uint64 (counter);
+	write_uint64 (thread_id);
+	
+	for (current_element = profiler->classes->unwritten; current_element != NULL; current_element = current_element->next_unwritten) {
+		write_uint32 (current_element->id);
+		write_string (current_element->name);
+#if (DEBUG_LOGGING_PROFILER)
+		printf ("mapping CLASS (%d => %s)\n", current_element->id, current_element->name);
+#endif
+		g_free (current_element->name);
+		current_element->name = NULL;
+	}
+	write_uint32 (0);
+	profiler->classes->unwritten = NULL;
+	
+	for (current_element = profiler->methods->unwritten; current_element != NULL; current_element = current_element->next_unwritten) {
+		MonoMethod *method = current_element->item;
+		MonoClass *klass = mono_method_get_class (method);
+		IdMappingElement *class_element = id_mapping_element_get (profiler->classes, klass);
+		g_assert (class_element != NULL);
+		write_uint32 (current_element->id);
+		write_uint32 (class_element->id);
+		write_string (current_element->name);
+#if (DEBUG_LOGGING_PROFILER)
+		printf ("mapping METHOD ([%d]%d => %s)\n", class_element->id, current_element->id, current_element->name);
+#endif
+		g_free (current_element->name);
+		current_element->name = NULL;
+	}
+	write_uint32 (0);
+	profiler->methods->unwritten = NULL;
+	
+	MONO_PROFILER_GET_CURRENT_COUNTER (counter);
+	write_uint64 (counter);
+}
+
+static guint64
+get_extended_event_value (ProfilerEventData *event, ProfilerEventData *next) {
+	guint64 result = next->data.number;
+	result |= (((guint64) event->value) << 32);
+	return result;
+}
+
+static ProfilerEventData*
+write_event (ProfilerEventData *event) {
+	ProfilerEventData *next = event + 1;
+	
+	guint8 event_code = MONO_PROFILER_EVENT_GET_FULL_CODE (event);
+	guint64 event_data;
+#if (DEBUG_LOGGING_PROFILER)
+	guint64 event_value;
+#endif
+
+	WRITE_BYTE (event_code);
+	if (event->is_method) {
+		IdMappingElement *element = g_hash_table_lookup (profiler->methods->table, event->data.address);
+		g_assert (element != NULL);
+		event_data = element->id;
+	} else if (event->is_class) {
+		IdMappingElement *element = g_hash_table_lookup (profiler->classes->table, event->data.address);
+		g_assert (element != NULL);
+		event_data = element->id;
+	} else {
+		event_data = event->data.number;
+	}
+	
+	write_uint64 (event_data);
+	if (event->value <= MAX_EVENT_VALUE) {
+		write_uint32 (event->value);
+#if (DEBUG_LOGGING_PROFILER)
+		event_value = event->value;
+#endif
+	} else {
+		write_uint64 (get_extended_event_value (event, next));
+#if (DEBUG_LOGGING_PROFILER)
+		event_value = get_extended_event_value (event, next);
+#endif
+		next ++;
+	}
+	
+#if (DEBUG_LOGGING_PROFILER)
+	EVENT_MARK ();
+	printf ("writing EVENT[%p] is_method:%d, is_class:%d, kind:%d, code:%d (%d:%ld:%ld)\n", event,
+			event->is_method, event->is_class, event->kind, event->code,
+			event_code, event_data, event_value);
+#endif
+	return next;
+}
+
+static void
+write_thread_data_block (ProfilerPerThreadData *data, ProfilerEventData *force_end) {
+	ProfilerEventData *start = data->first_unwritten_event;
+	ProfilerEventData *end = (force_end != NULL) ? force_end : (data->next_free_event);
+	guint64 counter;
+	
+	if (start == end)
+		return;
+	
+	WRITE_BYTE (MONO_PROFILER_FILE_BLOCK_KIND_EVENTS);
+	MONO_PROFILER_GET_CURRENT_COUNTER (counter);
+	write_uint64 (counter);
+	write_uint64 (data->thread_id);
+	
+	write_uint64 (data->start_event_counter);
+	
+	while (start < end) {
+		start = write_event (start);
+	}
+	WRITE_BYTE (0);
+	data->first_unwritten_event = end;
+	
+	MONO_PROFILER_GET_CURRENT_COUNTER (counter);
+	write_uint64 (counter);
+}
+
+
+
+static void
+write_statistical_data_block (ProfilerStatisticalData *data) {
+	int start_index = data->first_unwritten_index;
+	int end_index = data->next_free_index;
+	int managed_index = 0;
+	int unmanaged_index = 0;
+	int index;
+	guint64 counter;
+	
+	if (end_index > data->end_index)
+		end_index = data->end_index;
+	
+	if (start_index == end_index)
+		return;
+	
+	for (index = start_index; index < end_index; index ++) {
+		gpointer address = data->addresses [index];
+		//MonoJitInfo *ji = mono_jit_info_table_find (mono_domain_get (), (char*) address);
+		MonoJitInfo *ji = NULL;
+		
+		if (ji != NULL) {
+			MonoMethod *method = mono_jit_info_get_method (ji);
+			IdMappingElement *element = g_hash_table_lookup (profiler->methods->table, method);
+			
+			if (element == NULL) {
+				IdMappingElement *class_element;
+				
+				char *signature = mono_signature_get_desc (mono_method_signature (method), TRUE);
+				char *name = g_strdup_printf ("%s (%s)", mono_method_get_name (method), signature);
+				g_free (signature);
+				element = id_mapping_element_new (profiler->methods, method, name);
+#if (DEBUG_LOGGING_PROFILER)
+				printf ("Created new METHOD mapping element from statistical hit \"%s\" (%p)[%d]\n", name, method, profiler->methods->next_id - 1);
+#endif
+				class_element = g_hash_table_lookup (profiler->classes->table, mono_method_get_class (method));
+				if (class_element == NULL) {
+					MonoClass *klass = mono_method_get_class (method);
+					char *name = g_strdup_printf ("%s.%s", mono_class_get_namespace (klass), mono_class_get_name (klass));
+					id_mapping_element_new (profiler->classes, klass, name);
+#if (DEBUG_LOGGING_PROFILER)
+					printf ("Created new CLASS mapping element from statistical hit \"%s\" (%p)[%d]\n", name, method->klass, profiler->classes->next_id - 1);
+#endif
+				}
+			}
+			
+			profiler->statistical_hits_managed_ids [managed_index] = element->id;
+			managed_index ++;
+		} else {
+			//FIXME: For now we don't handled unmanaged function ids...
+			profiler->statistical_hits_unmanaged_ids [unmanaged_index] = 1;
+			unmanaged_index ++;
+		}
+	}
+	
+	write_mapping_block (0);
+	
+	WRITE_BYTE (MONO_PROFILER_FILE_BLOCK_KIND_STATISTICAL);
+	MONO_PROFILER_GET_CURRENT_COUNTER (counter);
+	write_uint64 (counter);
+	
+	for (index = 0; index < managed_index; index ++) {
+		write_uint32 (profiler->statistical_hits_managed_ids [index]);
+	}
+	write_uint32 (0);
+	for (index = 0; index < unmanaged_index; index ++) {
+		write_uint32 (profiler->statistical_hits_unmanaged_ids [index]);
+	}
+	write_uint32 (0);
+	
+	data->first_unwritten_index = end_index;
+	
+	MONO_PROFILER_GET_CURRENT_COUNTER (counter);
+	write_uint64 (counter);
+}
+
+static void
+write_clock_block (void) {
+	guint64 counter;
+	guint64 time;
+	
+	MONO_PROFILER_GET_CURRENT_COUNTER (counter);
+	MONO_PROFILER_GET_CURRENT_TIME (time);
+	
+	WRITE_BYTE (MONO_PROFILER_FILE_BLOCK_KIND_CLOCK);
+	write_uint64 (counter);
+	write_uint64 (time);
+}
+
+static void
+write_intro_block (void) {
+	WRITE_BYTE (MONO_PROFILER_FILE_BLOCK_KIND_INTRO);
+	write_uint32 (1);
+	write_string ("mono");
+	write_uint64 (profiler->start_counter);
+	write_uint64 (profiler->start_time);
+}
+
+static void
+write_end_block (void) {
+	WRITE_BYTE (MONO_PROFILER_FILE_BLOCK_KIND_END);
+	write_uint32 (1);
+	write_uint64 (profiler->end_counter);
+	write_uint64 (profiler->end_time);
+}
+
+
+static ProfilerEventData*
+update_mapping (ProfilerPerThreadData *data) {
+	ProfilerEventData *start = data->first_unwritten_event;
+	ProfilerEventData *end = data->next_free_event;
+	
+	while (start < end) {
+		if (start->is_class) {
+			IdMappingElement *element = g_hash_table_lookup (profiler->classes->table, start->data.address);
+			if (element == NULL) {
+				MonoClass *klass = start->data.address;
+				char *name = g_strdup_printf ("%s.%s", mono_class_get_namespace (klass), mono_class_get_name (klass));
+				id_mapping_element_new (profiler->classes, klass, name);
+#if (DEBUG_LOGGING_PROFILER)
+				printf ("Created new CLASS mapping element \"%s\" (%p)[%d]\n", name, klass, profiler->classes->next_id - 1);
+#endif
+			}
+		} if (start->is_method) {
+			IdMappingElement *element = g_hash_table_lookup (profiler->methods->table, start->data.address);
+			if (element == NULL) {
+				MonoMethod *method = start->data.address;
+				char *signature = mono_signature_get_desc (mono_method_signature (method), TRUE);
+				char *name = g_strdup_printf ("%s (%s)", mono_method_get_name (method), signature);
+				g_free (signature);
+				id_mapping_element_new (profiler->methods, method, name);
+#if (DEBUG_LOGGING_PROFILER)
+				printf ("Created new METHOD mapping element \"%s\" (%p)[%d]\n", name, method, profiler->methods->next_id - 1);
+#endif
+			}
+		}
+		
+		start ++;
+	}
+	
+	return end;
+}
+
+static void
+flush_event_data (ProfilerPerThreadData *data) {
+	ProfilerEventData *end;
+	
+	LOCK_PROFILER ();
+	write_clock_block ();
+	
+	end = update_mapping (data);
+	
+	write_mapping_block (data->thread_id);
+	write_thread_data_block (data, end);
+	
+	data->next_free_event = data->events;
+	data->first_unwritten_event = data->events;
+	MONO_PROFILER_GET_CURRENT_COUNTER (data->start_event_counter);
+	data->last_event_counter = data->start_event_counter;
+	
+	write_clock_block ();
+	FLUSH_FILE ();
+	UNLOCK_PROFILER ();
+}
+
+#define GET_NEXT_FREE_EVENT(d,e) {\
+	if ((d)->next_free_event >= (d)->end_event) {\
+		flush_event_data (d);\
+	}\
+	(e) = (d)->next_free_event;\
+	(d)->next_free_event ++;\
+} while (0)
+
+static void
+flush_everything (void) {
+	ProfilerPerThreadData *data = profiler->per_thread_data;
+	
+	while (data != NULL) {
+		ProfilerEventData *end = update_mapping (data);
+		write_mapping_block (data->thread_id);
+		write_thread_data_block (data, end);
+		
+		data = data->next;
+	}
+	write_statistical_data_block (profiler->statistical_data);
+}
+
+#define RESULT_TO_LOAD_CODE(r) (((r)==MONO_PROFILE_OK)?MONO_PROFILER_LOADED_EVENT_SUCCESS:MONO_PROFILER_LOADED_EVENT_FAILURE)
+static void
+appdomain_start_load (MonoProfiler *profiler, MonoDomain *domain) {
+	LOCK_PROFILER ();
+	loaded_element_load_start (profiler->loaded_appdomains, domain);
+	UNLOCK_PROFILER ();
+}
+
+static void
+appdomain_end_load (MonoProfiler *profiler, MonoDomain *domain, int result) {
+	char *name;
+	LoadedElement *element;
+	
+	name = g_strdup_printf ("%d", mono_domain_get_id (domain));
+	LOCK_PROFILER ();
+	element = loaded_element_load_end (profiler->loaded_appdomains, domain, name);
+	write_element_load_block (element, MONO_PROFILER_LOADED_EVENT_APPDOMAIN | RESULT_TO_LOAD_CODE (result), CURRENT_THREAD_ID ());
+	UNLOCK_PROFILER ();
+}
+
+static void
+appdomain_start_unload (MonoProfiler *profiler, MonoDomain *domain) {
+	LOCK_PROFILER ();
+	loaded_element_unload_start (profiler->loaded_appdomains, domain);
+	flush_everything ();
+	UNLOCK_PROFILER ();
+}
+
+static void
+appdomain_end_unload (MonoProfiler *profiler, MonoDomain *domain) {
+	LoadedElement *element;
+	
+	LOCK_PROFILER ();
+	element = loaded_element_unload_end (profiler->loaded_appdomains, domain);
+	write_element_unload_block (element, MONO_PROFILER_LOADED_EVENT_APPDOMAIN, CURRENT_THREAD_ID ());
+	UNLOCK_PROFILER ();
+}
+
+static void
+module_start_load (MonoProfiler *profiler, MonoImage *module) {
+	LOCK_PROFILER ();
+	loaded_element_load_start (profiler->loaded_modules, module);
+	UNLOCK_PROFILER ();
+}
+
+static void
+module_end_load (MonoProfiler *profiler, MonoImage *module, int result) {
+	char *name;
+	MonoAssemblyName aname;
+	LoadedElement *element;
+	
+	mono_assembly_fill_assembly_name (module, &aname);
+	name = mono_stringify_assembly_name (&aname);
+	LOCK_PROFILER ();
+	element = loaded_element_load_end (profiler->loaded_modules, module, name);
+	write_element_load_block (element, MONO_PROFILER_LOADED_EVENT_MODULE | RESULT_TO_LOAD_CODE (result), CURRENT_THREAD_ID ());
+	UNLOCK_PROFILER ();
+}
+
+static void
+module_start_unload (MonoProfiler *profiler, MonoImage *module) {
+	LOCK_PROFILER ();
+	loaded_element_unload_start (profiler->loaded_modules, module);
+	flush_everything ();
+	UNLOCK_PROFILER ();
+}
+
+static void
+module_end_unload (MonoProfiler *profiler, MonoImage *module) {
+	LoadedElement *element;
+	
+	LOCK_PROFILER ();
+	element = loaded_element_unload_end (profiler->loaded_modules, module);
+	write_element_unload_block (element, MONO_PROFILER_LOADED_EVENT_MODULE, CURRENT_THREAD_ID ());
+	UNLOCK_PROFILER ();
+}
+
+static void
+assembly_start_load (MonoProfiler *profiler, MonoAssembly *assembly) {
+	LOCK_PROFILER ();
+	loaded_element_load_start (profiler->loaded_assemblies, assembly);
+	UNLOCK_PROFILER ();
+}
+
+static void
+assembly_end_load (MonoProfiler *profiler, MonoAssembly *assembly, int result) {
+	char *name;
+	MonoAssemblyName aname;
+	LoadedElement *element;
+	
+	mono_assembly_fill_assembly_name (mono_assembly_get_image (assembly), &aname);
+	name = mono_stringify_assembly_name (&aname);
+	LOCK_PROFILER ();
+	element = loaded_element_load_end (profiler->loaded_assemblies, assembly, name);
+	write_element_load_block (element, MONO_PROFILER_LOADED_EVENT_ASSEMBLY | RESULT_TO_LOAD_CODE (result), CURRENT_THREAD_ID ());
+	UNLOCK_PROFILER ();
+}
+
+static void
+assembly_start_unload (MonoProfiler *profiler, MonoAssembly *assembly) {
+	LOCK_PROFILER ();
+	loaded_element_unload_start (profiler->loaded_assemblies, assembly);
+	flush_everything ();
+	UNLOCK_PROFILER ();
+}
+static void
+assembly_end_unload (MonoProfiler *profiler, MonoAssembly *assembly) {
+	LoadedElement *element;
+	
+	LOCK_PROFILER ();
+	element = loaded_element_unload_end (profiler->loaded_assemblies, assembly);
+	write_element_unload_block (element, MONO_PROFILER_LOADED_EVENT_ASSEMBLY, CURRENT_THREAD_ID ());
+	UNLOCK_PROFILER ();
+}
+
+#if (DEBUG_LOGGING_PROFILER)		
+static const char*
+class_event_code_to_string (MonoProfilerClassEvents code) {
+	switch (code) {
+	case MONO_PROFILER_EVENT_CLASS_LOAD: return "LOAD";
+	case MONO_PROFILER_EVENT_CLASS_UNLOAD: return "UNLOAD";
+	case MONO_PROFILER_EVENT_CLASS_ALLOCATION: return "ALLOCATION";
+	case MONO_PROFILER_EVENT_CLASS_EXCEPTION: return "EXCEPTION";
+	default: g_assert_not_reached (); return "";
+	}
+}
+static const char*
+method_event_code_to_string (MonoProfilerClassEvents code) {
+	switch (code) {
+	case MONO_PROFILER_EVENT_METHOD_CALL: return "CALL";
+	case MONO_PROFILER_EVENT_METHOD_JIT: return "JIT";
+	case MONO_PROFILER_EVENT_METHOD_STATISTICAL_HIT: G_BREAKPOINT(); return "STATISTICAL_HIT";
+	case MONO_PROFILER_EVENT_METHOD_FREED: return "FREED";
+	default: g_assert_not_reached (); return "";
+	}
+}
+static const char*
+number_event_code_to_string (MonoProfilerEvents code) {
+	switch (code) {
+	case MONO_PROFILER_EVENT_STATISTICAL_UNMANAGED: return "STATISTICAL_UNMANAGED";
+	case MONO_PROFILER_EVENT_THREAD: return "HREAD";
+	case MONO_PROFILER_EVENT_GC_COLLECTION: return "GC_COLLECTION";
+	case MONO_PROFILER_EVENT_GC_MARK: return "GC_MARK";
+	case MONO_PROFILER_EVENT_GC_SWEEP: return "GC_SWEEP";
+	case MONO_PROFILER_EVENT_GC_RESIZE: return "GC_RESIZE";
+	default: g_assert_not_reached (); return "";
+	}
+}
+static const char*
+event_result_to_string (MonoProfilerEventResult code) {
+	switch (code) {
+	case MONO_PROFILER_EVENT_RESULT_SUCCESS: return "SUCCESS";
+	case MONO_PROFILER_EVENT_RESULT_FAILURE: return "FAILURE";
+	default: g_assert_not_reached (); return "";
+	}
+}
+static const char*
+event_kind_to_string (MonoProfilerEventKind code) {
+	switch (code) {
+	case MONO_PROFILER_EVENT_KIND_START: return "START";
+	case MONO_PROFILER_EVENT_KIND_END: return "END";
+	default: g_assert_not_reached (); return "";
+	}
+}
+static void
+print_event_data (ProfilerEventData *event, guint64 value) {
+	if (event->is_class) {
+		printf ("CLASS[%p] event [%p] %s:%s:%s[%d-%d-%d-%d:%d] %ld (%s.%s)\n",
+				event->data.address,
+				event,
+				class_event_code_to_string (event->code & ~MONO_PROFILER_EVENT_RESULT_MASK),
+				event_result_to_string (event->code & MONO_PROFILER_EVENT_RESULT_MASK),
+				event_kind_to_string (event->kind),
+				event->is_method,
+				event->is_class,
+				event->kind,
+				event->code,
+				MONO_PROFILER_EVENT_GET_FULL_CODE (event),
+				value,
+				mono_class_get_namespace ((MonoClass*) event->data.address),
+				mono_class_get_name ((MonoClass*) event->data.address));
+	} else if (event->is_method) {
+		printf ("METHOD[%p] event [%p] %s:%s:%s[%d-%d-%d-%d:%d] %ld (%s.%s:%s (?))\n",
+				event->data.address,
+				event,
+				method_event_code_to_string (event->code & ~MONO_PROFILER_EVENT_RESULT_MASK),
+				event_result_to_string (event->code & MONO_PROFILER_EVENT_RESULT_MASK),
+				event_kind_to_string (event->kind),
+				event->is_method,
+				event->is_class,
+				event->kind,
+				event->code,
+				MONO_PROFILER_EVENT_GET_FULL_CODE (event),
+				value,
+				mono_class_get_namespace (mono_method_get_class ((MonoMethod*) event->data.address)),
+				mono_class_get_name (mono_method_get_class ((MonoMethod*) event->data.address)),
+				mono_method_get_name ((MonoMethod*) event->data.address));
+	} else {
+		printf ("NUMBER[%ld] event [%p] %s:%s[%d-%d-%d-%d:%d] %ld\n",
+				(guint64) event->data.number,
+				event,
+				number_event_code_to_string (event->code),
+				event_kind_to_string (event->kind),
+				event->is_method,
+				event->is_class,
+				event->kind,
+				event->code,
+				MONO_PROFILER_EVENT_GET_FULL_CODE (event),
+				value);
+	}
+}
+#define LOG_EVENT(ev,val) print_event_data ((ev),(val))
+#else
+#define LOG_EVENT(ev,val)
+#endif
+
+#define RESULT_TO_EVENT_CODE(r) (((r)==MONO_PROFILE_OK)?MONO_PROFILER_EVENT_RESULT_SUCCESS:MONO_PROFILER_EVENT_RESULT_FAILURE)
+
+#define STORE_EVENT_ITEM_COUNTER(profiler,i,is_m,is_c,c,k) do {\
+	ProfilerPerThreadData *data;\
+	ProfilerEventData *event;\
+	guint64 counter;\
+	guint64 delta;\
+	GET_PROFILER_THREAD_DATA (data);\
+	GET_NEXT_FREE_EVENT (data, event);\
+	MONO_PROFILER_GET_CURRENT_COUNTER (counter);\
+	event->data.address = (i);\
+	event->is_method = (is_m);\
+	event->is_class = (is_c);\
+	event->code = (c);\
+	event->kind = (k);\
+	delta = counter - data->last_event_counter;\
+	if (delta < MAX_EVENT_VALUE) {\
+		event->value = delta;\
+	} else {\
+		ProfilerEventData *extension = data->next_free_event;\
+		data->next_free_event ++;\
+		event->value = delta >> 32;\
+		extension->data.number = delta & 0xffffffff;\
+	}\
+	data->last_event_counter = counter;\
+	LOG_EVENT (event, delta);\
+} while (0);
+#define STORE_EVENT_ITEM_VALUE(p,i,is_m,is_c,c,k,v) do {\
+	ProfilerPerThreadData *data;\
+	ProfilerEventData *event;\
+	GET_PROFILER_THREAD_DATA (data);\
+	GET_NEXT_FREE_EVENT (data, event);\
+	event->data.address = (i);\
+	event->is_method = (is_m);\
+	event->is_class = (is_c);\
+	event->code = (c);\
+	event->kind = (k);\
+	if ((v) < MAX_EVENT_VALUE) {\
+		event->value = (v);\
+	} else {\
+		ProfilerEventData *extension = data->next_free_event;\
+		data->next_free_event ++;\
+		event->value = (v) >> 32;\
+		extension->data.number = (v) & 0xffffffff;\
+	}\
+	LOG_EVENT (event, (v));\
+}while (0);
+#define STORE_EVENT_NUMBER_COUNTER(p,n,is_m,is_c,c,k) do {\
+	ProfilerPerThreadData *data;\
+	ProfilerEventData *event;\
+	guint64 counter;\
+	guint64 delta;\
+	GET_PROFILER_THREAD_DATA (data);\
+	GET_NEXT_FREE_EVENT (data, event);\
+	MONO_PROFILER_GET_CURRENT_COUNTER (counter);\
+	event->data.number = (n);\
+	event->is_method = (is_m);\
+	event->is_class = (is_c);\
+	event->code = (c);\
+	event->kind = (k);\
+	delta = counter - data->last_event_counter;\
+	if (delta < MAX_EVENT_VALUE) {\
+		event->value = delta;\
+	} else {\
+		ProfilerEventData *extension = data->next_free_event;\
+		data->next_free_event ++;\
+		event->value = delta >> 32;\
+		extension->data.number = delta & 0xffffffff;\
+	}\
+	data->last_event_counter = counter;\
+	LOG_EVENT (event, delta);\
+}while (0);
+#define STORE_EVENT_NUMBER_VALUE(p,n,is_m,is_c,c,k,v) do {\
+	ProfilerPerThreadData *data;\
+	ProfilerEventData *event;\
+	GET_PROFILER_THREAD_DATA (data);\
+	GET_NEXT_FREE_EVENT (data, event);\
+	event->data.number = (n);\
+	event->is_method = (is_m);\
+	event->is_class = (is_c);\
+	event->code = (c);\
+	event->kind = (k);\
+	if ((v) < MAX_EVENT_VALUE) {\
+		event->value = (v);\
+	} else {\
+		ProfilerEventData *extension = data->next_free_event;\
+		data->next_free_event ++;\
+		event->value = (v) >> 32;\
+		extension->data.number = (v) & 0xffffffff;\
+	}\
+	LOG_EVENT (event, (v));\
+}while (0);
+
+
+static void
+class_start_load (MonoProfiler *profiler, MonoClass *klass) {
+	STORE_EVENT_ITEM_COUNTER (profiler, klass, 0, 1, MONO_PROFILER_EVENT_CLASS_LOAD, MONO_PROFILER_EVENT_KIND_START);
+}
+static void
+class_end_load (MonoProfiler *profiler, MonoClass *klass, int result) {
+	STORE_EVENT_ITEM_COUNTER (profiler, klass, 0, 1, MONO_PROFILER_EVENT_CLASS_LOAD | RESULT_TO_EVENT_CODE (result), MONO_PROFILER_EVENT_KIND_END);
+}
+static void
+class_start_unload (MonoProfiler *profiler, MonoClass *klass) {
+	STORE_EVENT_ITEM_COUNTER (profiler, klass, 0, 1, MONO_PROFILER_EVENT_CLASS_UNLOAD, MONO_PROFILER_EVENT_KIND_START);
+}
+static void
+class_end_unload (MonoProfiler *profiler, MonoClass *klass) {
+	STORE_EVENT_ITEM_COUNTER (profiler, klass, 0, 1, MONO_PROFILER_EVENT_CLASS_UNLOAD, MONO_PROFILER_EVENT_KIND_END);
+}
+
+static void
+method_start_jit (MonoProfiler *profiler, MonoMethod *method) {
+	STORE_EVENT_ITEM_COUNTER (profiler, method, 1, 0, MONO_PROFILER_EVENT_METHOD_JIT, MONO_PROFILER_EVENT_KIND_START);
+}
+static void
+method_end_jit (MonoProfiler *profiler, MonoMethod *method, int result) {
+	STORE_EVENT_ITEM_COUNTER (profiler, method, 1, 0, MONO_PROFILER_EVENT_METHOD_JIT | RESULT_TO_EVENT_CODE (result), MONO_PROFILER_EVENT_KIND_END);
+}
+
+static void
+method_enter (MonoProfiler *profiler, MonoMethod *method) {
+	STORE_EVENT_ITEM_COUNTER (profiler, method, 1, 0, MONO_PROFILER_EVENT_METHOD_CALL, MONO_PROFILER_EVENT_KIND_START);
+}
+static void
+method_leave (MonoProfiler *profiler, MonoMethod *method) {
+	STORE_EVENT_ITEM_COUNTER (profiler, method, 1, 0, MONO_PROFILER_EVENT_METHOD_CALL, MONO_PROFILER_EVENT_KIND_END);
+}
+
+static void
+method_free (MonoProfiler *profiler, MonoMethod *method) {
+	STORE_EVENT_ITEM_COUNTER (profiler, method, 1, 0, MONO_PROFILER_EVENT_METHOD_FREED, 0);
+}
+
+static void
+thread_start (MonoProfiler *profiler, gsize tid) {
+	STORE_EVENT_NUMBER_COUNTER (profiler, tid, 0, 0, MONO_PROFILER_EVENT_THREAD, MONO_PROFILER_EVENT_KIND_START);
+}
+static void
+thread_end (MonoProfiler *profiler, gsize tid) {
+	STORE_EVENT_NUMBER_COUNTER (profiler, tid, 0, 0, MONO_PROFILER_EVENT_THREAD, MONO_PROFILER_EVENT_KIND_END);
+}
+
+static void
+object_allocated (MonoProfiler *profiler, MonoObject *obj, MonoClass *klass) {
+	STORE_EVENT_ITEM_VALUE (profiler, klass, 0, 1, MONO_PROFILER_EVENT_CLASS_ALLOCATION, 0, (guint64) mono_object_get_size (obj));
+}
+
+
+	int next_free_index;
+	int end_index;
+	int first_unwritten_index;
+
+static void
+statistical_hit (MonoProfiler *profiler, guchar *ip, void *context) {
+	ProfilerStatisticalData *data;
+	int index;
+	
+	do {
+		data = profiler->statistical_data;
+		index = InterlockedIncrement (&data->next_free_index);
+		
+		if (index <= data->end_index) {
+			data->addresses [index - 1] = (gpointer) ip;
+		} else {
+			/* Check if we are the one that must swap the buffers */
+			if (index == data->end_index + 1) {
+				ProfilerStatisticalData *new_data;
+
+				/* In the *impossible* case that the writer thread has not finished yet, */
+				/* loop waiting for it and meanwhile lose all statistical events... */
+				do {
+					/* First, wait that it consumed the ready buffer */
+					while (profiler->statistical_data_ready != NULL);
+					/* Then, wait that it produced the free buffer */
+					new_data = profiler->statistical_data_second_buffer;
+				} while (new_data == NULL);
+
+				profiler->statistical_data_ready = data;
+				profiler->statistical_data = new_data;
+				profiler->statistical_data_second_buffer = NULL;
+				WRITER_EVENT_RAISE ();
+			}
+			
+			/* Loop again, hoping to acquire a free slot this time */
+			data = NULL;
+		}
+	} while (data == NULL);
+}
+
+static MonoProfilerEvents
+gc_event_code_from_profiler_event (MonoGCEvent event) {
+	switch (event) {
+	case MONO_GC_EVENT_START:
+	case MONO_GC_EVENT_END:
+		return MONO_PROFILER_EVENT_GC_COLLECTION;
+	case MONO_GC_EVENT_MARK_START:
+	case MONO_GC_EVENT_MARK_END:
+		return MONO_PROFILER_EVENT_GC_MARK;
+	case MONO_GC_EVENT_RECLAIM_START:
+	case MONO_GC_EVENT_RECLAIM_END:
+		return MONO_PROFILER_EVENT_GC_SWEEP;
+	default:
+		g_assert_not_reached ();
+		return 0;
+	}
+}
+
+static MonoProfilerEventKind
+gc_event_kind_from_profiler_event (MonoGCEvent event) {
+	switch (event) {
+	case MONO_GC_EVENT_START:
+	case MONO_GC_EVENT_MARK_START:
+	case MONO_GC_EVENT_RECLAIM_START:
+		return MONO_PROFILER_EVENT_KIND_START;
+	case MONO_GC_EVENT_END:
+	case MONO_GC_EVENT_MARK_END:
+	case MONO_GC_EVENT_RECLAIM_END:
+		return MONO_PROFILER_EVENT_KIND_END;
+	default:
+		g_assert_not_reached ();
+		return 0;
+	}
+}
+
+static void
+gc_event (MonoProfiler *profiler, MonoGCEvent ev, int generation) {
+	STORE_EVENT_NUMBER_COUNTER (profiler, generation, 0, 0, gc_event_code_from_profiler_event (ev), gc_event_kind_from_profiler_event (ev));
+}
+
+static void
+gc_resize (MonoProfiler *profiler, gint64 new_size) {
+	STORE_EVENT_NUMBER_COUNTER (profiler, new_size, 0, 0, MONO_PROFILER_EVENT_GC_RESIZE, 0);
+}
+
+/* called at the end of the program */
+static void
+profiler_shutdown (MonoProfiler *prof)
+{
+	ProfilerPerThreadData* current_thread_data;
+	
+	mono_profiler_set_events (0);
+	
+	LOG_WRITER_THREAD ("profiler_shutdown: asking stats thread to exit");
+	profiler->statistical_data_writer_terminate = TRUE;
+	WRITER_EVENT_RAISE ();
+	LOG_WRITER_THREAD ("profiler_shutdown: waiting for stats thread to exit");
+	WAIT_WRITER_THREAD ();
+	LOG_WRITER_THREAD ("profiler_shutdown: stats thread should be dead now");
+	WRITER_EVENT_DESTROY ();
+	
+	LOCK_PROFILER ();
+	
+	MONO_PROFILER_GET_CURRENT_TIME (profiler->end_time);
+	MONO_PROFILER_GET_CURRENT_COUNTER (profiler->end_counter);
+	
+	flush_everything ();
+	write_clock_block ();
+	write_end_block ();
+	FLUSH_FILE ();
+	CLOSE_FILE();
+	UNLOCK_PROFILER ();
+	g_free (profiler->file_name);
+	
+	id_mapping_destroy (profiler->methods);
+	id_mapping_destroy (profiler->classes);
+	g_hash_table_destroy (profiler->loaded_assemblies);
+	g_hash_table_destroy (profiler->loaded_modules);
+	g_hash_table_destroy (profiler->loaded_appdomains);
+	
+	FREE_PROFILER_THREAD_DATA ();
+	
+	for (current_thread_data = profiler->per_thread_data; current_thread_data != NULL; current_thread_data = current_thread_data->next) {
+		profiler_per_thread_data_destroy (current_thread_data);
+	}
+	if (profiler->statistical_data != NULL) {
+		profiler_statistical_data_destroy (profiler->statistical_data);
+	}
+	if (profiler->statistical_data_ready != NULL) {
+		profiler_statistical_data_destroy (profiler->statistical_data_ready);
+	}
+	if (profiler->statistical_data_second_buffer != NULL) {
+		profiler_statistical_data_destroy (profiler->statistical_data_second_buffer);
+	}
+	if (profiler->statistical_hits_managed_ids != NULL) {
+		g_free (profiler->statistical_hits_managed_ids);
+	}
+	if (profiler->statistical_hits_unmanaged_ids != NULL) {
+		g_free (profiler->statistical_hits_unmanaged_ids);
+	}
+	
+	DELETE_PROFILER_MUTEX ();
+	
+	g_free (profiler);
+	profiler = NULL;
+}
+
+static void
+setup_user_options (const char *arguments) {
+	profiler->per_thread_buffer_size = 10000;
+	profiler->statistical_buffer_size = 10000;
+	
+	profiler->flags = MONO_PROFILE_APPDOMAIN_EVENTS|
+			MONO_PROFILE_ASSEMBLY_EVENTS|
+			MONO_PROFILE_MODULE_EVENTS|
+			MONO_PROFILE_CLASS_EVENTS|
+			MONO_PROFILE_JIT_COMPILATION|
+			MONO_PROFILE_ALLOCATIONS|
+			MONO_PROFILE_GC|
+			MONO_PROFILE_THREADS|
+			MONO_PROFILE_ENTER_LEAVE|
+			MONO_PROFILE_STATISTICAL|
+			MONO_PROFILE_METHOD_EVENTS;
+	
+	//profiler->flags = MONO_PROFILE_STATISTICAL;
+	//profiler->flags = 0;
+	
+	profiler->file_name = g_strdup ("profiler-log.prof");
+}
+
+
+static guint32
+statistical_data_writer_thread (gpointer nothing) {
+	for (;;) {
+		ProfilerStatisticalData *data;
+		
+		LOG_WRITER_THREAD ("statistical_data_writer_thread: going to sleep");
+		WRITER_EVENT_WAIT ();
+		LOG_WRITER_THREAD ("statistical_data_writer_thread: just woke up");
+		
+		data = profiler->statistical_data_ready;
+		
+		if (data != NULL) {
+			LOG_WRITER_THREAD ("statistical_data_writer_thread: acquiring lock and writing data");
+			LOCK_PROFILER ();
+			profiler->statistical_data_ready = NULL;
+			write_statistical_data_block (data);
+			data->next_free_index = 0;
+			data->first_unwritten_index = 0;
+			profiler->statistical_data_second_buffer = data;
+			UNLOCK_PROFILER ();
+			LOG_WRITER_THREAD ("statistical_data_writer_thread: wrote data and released lock");
+		}
+		
+		if (profiler->statistical_data_writer_terminate) {
+		LOG_WRITER_THREAD ("statistical_data_writer_thread: exiting thread");
+			EXIT_THREAD ();
+		}
+	}
+	return 0;
+}
+
+void
+mono_profiler_startup (const char *desc);
+
+/* the entry point (mono_profiler_load?) */
+void
+mono_profiler_startup (const char *desc)
+{
+	profiler = g_new0 (MonoProfiler, 1);
+	
+	setup_user_options ((desc != NULL) ? desc : "");
+	
+	INITIALIZE_PROFILER_MUTEX ();
+	MONO_PROFILER_GET_CURRENT_TIME (profiler->start_time);
+	MONO_PROFILER_GET_CURRENT_COUNTER (profiler->start_counter);
+	
+	profiler->methods = id_mapping_new ();
+	profiler->classes = id_mapping_new ();
+	profiler->loaded_assemblies = g_hash_table_new_full (g_direct_hash, NULL, NULL, loaded_element_destroy);
+	profiler->loaded_modules = g_hash_table_new_full (g_direct_hash, NULL, NULL, loaded_element_destroy);
+	profiler->loaded_appdomains = g_hash_table_new_full (g_direct_hash, NULL, NULL, loaded_element_destroy);
+	
+	profiler->statistical_data = profiler_statistical_data_new (profiler->statistical_buffer_size);
+	profiler->statistical_data_second_buffer = profiler_statistical_data_new (profiler->statistical_buffer_size);
+	profiler->statistical_hits_managed_ids = g_new (guint32, profiler->statistical_buffer_size);
+	profiler->statistical_hits_unmanaged_ids = g_new (guint32, profiler->statistical_buffer_size);
+	
+	WRITER_EVENT_INIT ();
+	LOG_WRITER_THREAD ("mono_profiler_startup: creating stats thread");
+	CREATE_WRITER_THREAD (statistical_data_writer_thread);
+	LOG_WRITER_THREAD ("mono_profiler_startup: created stats thread");
+
+	ALLOCATE_PROFILER_THREAD_DATA ();
+	
+	OPEN_FILE ();
+	
+	write_intro_block ();
+	write_clock_block ();
+	FLUSH_FILE ();
+	
+	mono_profiler_install (profiler, profiler_shutdown);
+	
+	mono_profiler_install_appdomain (appdomain_start_load, appdomain_end_load,
+			appdomain_start_unload, appdomain_end_unload);
+	mono_profiler_install_assembly (assembly_start_load, assembly_end_load,
+			assembly_start_unload, assembly_end_unload);
+	mono_profiler_install_module (module_start_load, module_end_load,
+			module_start_unload, module_end_unload);
+	mono_profiler_install_class (class_start_load, class_end_load,
+			class_start_unload, class_end_unload);
+	mono_profiler_install_jit_compile (method_start_jit, method_end_jit);
+	mono_profiler_install_enter_leave (method_enter, method_leave);
+	mono_profiler_install_method_free (method_free);
+	mono_profiler_install_thread (thread_start, thread_end);
+	mono_profiler_install_allocation (object_allocated);
+	mono_profiler_install_statistical (statistical_hit);
+	mono_profiler_install_gc (gc_event, gc_resize);
+	
+	mono_profiler_set_events (profiler->flags);
+}
+
