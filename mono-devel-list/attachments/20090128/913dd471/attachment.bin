Index: mono/mini/mini-darwin.c
===================================================================
--- mono/mini/mini-darwin.c	(revision 0)
+++ mono/mini/mini-darwin.c	(revision 0)
@@ -0,0 +1,195 @@
+/*
+ * mini-darwin.c: Darwin/MacOS support for Mono.
+ *
+ * Authors:
+ *   Mono Team (mono-list@lists.ximian.com)
+ *
+ * Copyright 2001-2003 Ximian, Inc.
+ * Copyright 2003-2008 Ximian, Inc.
+ *
+ * See LICENSE for licensing information.
+ */
+#include <config.h>
+#include <signal.h>
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <math.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
+#include <mono/metadata/assembly.h>
+#include <mono/metadata/loader.h>
+#include <mono/metadata/tabledefs.h>
+#include <mono/metadata/class.h>
+#include <mono/metadata/object.h>
+#include <mono/metadata/tokentype.h>
+#include <mono/metadata/tabledefs.h>
+#include <mono/metadata/threads.h>
+#include <mono/metadata/appdomain.h>
+#include <mono/metadata/debug-helpers.h>
+#include <mono/io-layer/io-layer.h>
+#include "mono/metadata/profiler.h"
+#include <mono/metadata/profiler-private.h>
+#include <mono/metadata/mono-config.h>
+#include <mono/metadata/environment.h>
+#include <mono/metadata/mono-debug.h>
+#include <mono/metadata/gc-internal.h>
+#include <mono/metadata/threads-types.h>
+#include <mono/metadata/verify.h>
+#include <mono/metadata/verify-internals.h>
+#include <mono/metadata/mempool-internals.h>
+#include <mono/metadata/attach.h>
+#include <mono/utils/mono-math.h>
+#include <mono/utils/mono-compiler.h>
+#include <mono/utils/mono-counters.h>
+#include <mono/utils/mono-logger.h>
+#include <mono/utils/mono-mmap.h>
+#include <mono/utils/dtrace.h>
+
+#include "mini.h"
+#include <string.h>
+#include <ctype.h>
+#include "trace.h"
+#include "version.h"
+
+#include "jit-icalls.h"
+
+/* MacOS includes */
+#include <mach/mach.h>
+#include <mach/mach_error.h>
+#include <mach/exception.h>
+#include <mach/task.h>
+#include <pthread.h>
+
+/*
+ * This code disables the CrashReporter of MacOS X by installing
+ * a dummy Mach exception handler.
+ */
+
+/*
+ * http://darwinsource.opendarwin.org/10.4.3/xnu-792.6.22/osfmk/man/exc_server.html
+ */
+extern boolean_t exc_server (mach_msg_header_t *request_msg, mach_msg_header_t *reply_msg);
+
+/*
+ * The exception message
+ */
+typedef struct {
+	mach_msg_base_t msg;  /* common mach message header */
+	char payload [1024];  /* opaque */
+} mach_exception_msg_t;
+
+/* The exception port */
+static mach_port_t mach_exception_port = VM_MAP_NULL;
+
+/*
+ * Implicitly called by exc_server. Must be public.
+ *
+ * http://darwinsource.opendarwin.org/10.4.3/xnu-792.6.22/osfmk/man/catch_exception_raise.html
+ */
+kern_return_t
+catch_exception_raise (
+	mach_port_t exception_port,
+	mach_port_t thread,
+	mach_port_t task,
+	exception_type_t exception,
+	exception_data_t code,
+	mach_msg_type_number_t code_count)
+{
+	/* consume the exception */
+	return KERN_FAILURE;
+}
+
+/*
+ * Exception thread handler.
+ */
+static
+void *
+mach_exception_thread (void *arg)
+{
+	for (;;) {
+		mach_exception_msg_t request;
+		mach_exception_msg_t reply;
+		mach_msg_return_t result;
+
+		/* receive from "mach_exception_port" */
+		result = mach_msg (&request.msg.header,
+				   MACH_RCV_MSG | MACH_RCV_LARGE,
+				   0,
+				   sizeof (request),
+				   mach_exception_port,
+				   MACH_MSG_TIMEOUT_NONE,
+				   MACH_PORT_NULL);
+
+		g_assert (result == MACH_MSG_SUCCESS);
+
+		/* dispatch to catch_exception_raise () */
+		exc_server (&request.msg.header, &reply.msg.header);
+
+		/* send back to sender */
+		result = mach_msg (&reply.msg.header,
+				   MACH_SEND_MSG,
+				   reply.msg.header.msgh_size,
+				   0,
+				   MACH_PORT_NULL,
+				   MACH_MSG_TIMEOUT_NONE,
+				   MACH_PORT_NULL);
+
+		g_assert (result == MACH_MSG_SUCCESS);
+	}
+	return NULL;
+}
+
+static void
+macosx_register_exception_handler ()
+{
+	mach_port_t task;
+	pthread_attr_t attr;
+	pthread_t thread;
+
+	if (mach_exception_port != VM_MAP_NULL)
+		return;
+
+	task = mach_task_self ();
+
+	/* create the "mach_exception_port" with send & receive rights */
+	g_assert (mach_port_allocate (task, MACH_PORT_RIGHT_RECEIVE,
+				      &mach_exception_port) == KERN_SUCCESS);
+	g_assert (mach_port_insert_right (task, mach_exception_port, mach_exception_port,
+					  MACH_MSG_TYPE_MAKE_SEND) == KERN_SUCCESS);
+
+	/* create the exception handler thread */
+	g_assert (!pthread_attr_init (&attr));
+	g_assert (!pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED));
+	g_assert (!pthread_create (&thread, &attr, mach_exception_thread, NULL));
+	pthread_attr_destroy (&attr);
+
+	/*
+	 * register "mach_exception_port" as a receiver for the
+	 * EXC_BAD_ACCESS exception
+	 *
+	 * http://darwinsource.opendarwin.org/10.4.3/xnu-792.6.22/osfmk/man/task_set_exception_ports.html
+	 */
+	g_assert (task_set_exception_ports (task, EXC_MASK_BAD_ACCESS,
+					    mach_exception_port,
+					    EXCEPTION_DEFAULT,
+					    MACHINE_THREAD_STATE) == KERN_SUCCESS);
+}
+
+void
+mono_runtime_install_handlers (void)
+{
+#if !defined(__arm__)
+	macosx_register_exception_handler ();
+#endif
+	mono_runtime_posix_install_handlers ();
+}

Property changes on: mono/mini/mini-darwin.c
___________________________________________________________________
Added: svn:eol-style
   + native

Index: mono/mini/mini.c
===================================================================
--- mono/mini/mini.c	(revision 124731)
+++ mono/mini/mini.c	(working copy)
@@ -21,14 +21,6 @@
 #include <sys/time.h>
 #endif
 
-#ifdef PLATFORM_MACOSX
-#include <mach/mach.h>
-#include <mach/mach_error.h>
-#include <mach/exception.h>
-#include <mach/task.h>
-#include <pthread.h>
-#endif
-
 #ifdef HAVE_VALGRIND_MEMCHECK_H
 #include <valgrind/memcheck.h>
 #endif
@@ -72,7 +64,6 @@
 
 #include "debug-mini.h"
 
-static void setup_stat_profiler (void);
 static gpointer mono_jit_compile_method_with_opt (MonoMethod *method, guint32 opt);
 static gpointer mono_jit_compile_method (MonoMethod *method);
 
@@ -2215,7 +2206,7 @@
 	if (thread)
 		thread->jit_data = jit_tls;
 	if (mono_profiler_get_events () & MONO_PROFILE_STATISTICAL)
-		setup_stat_profiler ();
+		mono_runtime_setup_stat_profiler ();
 }
 
 static void
@@ -4255,39 +4246,8 @@
 	return runtime_invoke (obj, params, exc, compiled_method);
 }
 
-#ifdef MONO_GET_CONTEXT
-#define GET_CONTEXT MONO_GET_CONTEXT
-#endif
-
-#ifndef GET_CONTEXT
-#ifdef PLATFORM_WIN32
-#define GET_CONTEXT \
-	struct sigcontext *ctx = (struct sigcontext*)_dummy;
-#else
-#ifdef MONO_ARCH_USE_SIGACTION
-#define GET_CONTEXT \
-    void *ctx = context;
-#elif defined(__sparc__)
-#define GET_CONTEXT \
-    void *ctx = sigctx;
-#else
-#define GET_CONTEXT \
-	void **_p = (void **)&_dummy; \
-	struct sigcontext *ctx = (struct sigcontext *)++_p;
-#endif
-#endif
-#endif
-
-#ifdef MONO_ARCH_USE_SIGACTION
-#define SIG_HANDLER_SIGNATURE(ftn) ftn (int _dummy, siginfo_t *info, void *context)
-#elif defined(__sparc__)
-#define SIG_HANDLER_SIGNATURE(ftn) ftn (int _dummy, void *sigctx)
-#else
-#define SIG_HANDLER_SIGNATURE(ftn) ftn (int _dummy)
-#endif
-
-static void
-SIG_HANDLER_SIGNATURE (sigfpe_signal_handler)
+void
+SIG_HANDLER_SIGNATURE (mono_sigfpe_signal_handler)
 {
 	MonoException *exc = NULL;
 #ifndef MONO_ARCH_USE_SIGACTION
@@ -4307,8 +4267,8 @@
 	mono_arch_handle_exception (ctx, exc, FALSE);
 }
 
-static void
-SIG_HANDLER_SIGNATURE (sigill_signal_handler)
+void
+SIG_HANDLER_SIGNATURE (mono_sigill_signal_handler)
 {
 	MonoException *exc;
 	GET_CONTEXT;
@@ -4318,8 +4278,8 @@
 	mono_arch_handle_exception (ctx, exc, FALSE);
 }
 
-static void
-SIG_HANDLER_SIGNATURE (sigsegv_signal_handler)
+void
+SIG_HANDLER_SIGNATURE (mono_sigsegv_signal_handler)
 {
 #ifndef MONO_ARCH_SIGSEGV_ON_ALTSTACK
 	MonoException *exc = NULL;
@@ -4366,545 +4326,17 @@
 #endif
 }
 
-#ifndef PLATFORM_WIN32
-
-static void
-SIG_HANDLER_SIGNATURE (sigabrt_signal_handler)
+void
+SIG_HANDLER_SIGNATURE (mono_sigint_signal_handler)
 {
-	MonoJitInfo *ji;
-	GET_CONTEXT;
-
-	ji = mono_jit_info_table_find (mono_domain_get (), mono_arch_ip_from_context(ctx));
-	if (!ji) {
-		mono_handle_native_sigsegv (SIGABRT, ctx);
-	}
-}
-
-static void
-SIG_HANDLER_SIGNATURE (sigusr1_signal_handler)
-{
-	gboolean running_managed;
 	MonoException *exc;
-	MonoThread *thread = mono_thread_current ();
-	MonoDomain *domain = mono_domain_get ();
-	void *ji;
-	
 	GET_CONTEXT;
 
-	if (!thread || !domain)
-		/* The thread might not have started up yet */
-		/* FIXME: Specify the synchronization with start_wrapper () in threads.c */
-		return;
-
-	if (thread->thread_dump_requested) {
-		thread->thread_dump_requested = FALSE;
-
-		mono_print_thread_dump (ctx);
-	}
-
-	/*
-	 * FIXME:
-	 * This is an async signal, so the code below must not call anything which
-	 * is not async safe. That includes the pthread locking functions. If we
-	 * know that we interrupted managed code, then locking is safe.
-	 */
-	ji = mono_jit_info_table_find (mono_domain_get (), mono_arch_ip_from_context(ctx));
-	running_managed = ji != NULL;
-	
-	exc = mono_thread_request_interruption (running_managed); 
-	if (!exc) return;
-
-	mono_arch_handle_exception (ctx, exc, FALSE);
-}
-
-#if defined(__i386__) || defined(__x86_64__)
-#define FULL_STAT_PROFILER_BACKTRACE 1
-#define CURRENT_FRAME_GET_BASE_POINTER(f) (* (gpointer*)(f))
-#define CURRENT_FRAME_GET_RETURN_ADDRESS(f) (* (((gpointer*)(f)) + 1))
-#if MONO_ARCH_STACK_GROWS_UP
-#define IS_BEFORE_ON_STACK <
-#define IS_AFTER_ON_STACK >
-#else
-#define IS_BEFORE_ON_STACK >
-#define IS_AFTER_ON_STACK <
-#endif
-#else
-#define FULL_STAT_PROFILER_BACKTRACE 0
-#endif
-
-#if defined(__ia64__) || defined(__sparc__) || defined(sparc) || defined(__s390__) || defined(s390)
-
-static void
-SIG_HANDLER_SIGNATURE (sigprof_signal_handler)
-{
-	NOT_IMPLEMENTED;
-}
-
-#else
-
-static void
-SIG_HANDLER_SIGNATURE (sigprof_signal_handler)
-{
-	int call_chain_depth = mono_profiler_stat_get_call_chain_depth ();
-	GET_CONTEXT;
-	
-	if (call_chain_depth == 0) {
-		mono_profiler_stat_hit (mono_arch_ip_from_context (ctx), ctx);
-	} else {
-		MonoJitTlsData *jit_tls = TlsGetValue (mono_jit_tls_id);
-		int current_frame_index = 1;
-		MonoContext mono_context;
-#if FULL_STAT_PROFILER_BACKTRACE
-		guchar *current_frame;
-		guchar *stack_bottom;
-		guchar *stack_top;
-#else
-		MonoDomain *domain;
-#endif
-		guchar *ips [call_chain_depth + 1];
-
-		mono_arch_sigctx_to_monoctx (ctx, &mono_context);
-		ips [0] = MONO_CONTEXT_GET_IP (&mono_context);
-		
-		if (jit_tls != NULL) {
-#if FULL_STAT_PROFILER_BACKTRACE
-			stack_bottom = jit_tls->end_of_stack;
-			stack_top = MONO_CONTEXT_GET_SP (&mono_context);
-			current_frame = MONO_CONTEXT_GET_BP (&mono_context);
-			
-			while ((current_frame_index <= call_chain_depth) &&
-					(stack_bottom IS_BEFORE_ON_STACK (guchar*) current_frame) &&
-					((guchar*) current_frame IS_BEFORE_ON_STACK stack_top)) {
-				ips [current_frame_index] = CURRENT_FRAME_GET_RETURN_ADDRESS (current_frame);
-				current_frame_index ++;
-				stack_top = current_frame;
-				current_frame = CURRENT_FRAME_GET_BASE_POINTER (current_frame);
-			}
-#else
-			domain = mono_domain_get ();
-			if (domain != NULL) {
-				MonoLMF *lmf = NULL;
-				MonoJitInfo *ji;
-				MonoJitInfo res;
-				MonoContext new_mono_context;
-				int native_offset;
-				ji = mono_find_jit_info (domain, jit_tls, &res, NULL, &mono_context,
-						&new_mono_context, NULL, &lmf, &native_offset, NULL);
-				while ((ji != NULL) && (current_frame_index <= call_chain_depth)) {
-					ips [current_frame_index] = MONO_CONTEXT_GET_IP (&new_mono_context);
-					current_frame_index ++;
-					mono_context = new_mono_context;
-					ji = mono_find_jit_info (domain, jit_tls, &res, NULL, &mono_context,
-							&new_mono_context, NULL, &lmf, &native_offset, NULL);
-				}
-			}
-#endif
-		}
-		
-		
-		mono_profiler_stat_call_chain (current_frame_index, & ips [0], ctx);
-	}
-}
-
-#endif
-
-static void
-SIG_HANDLER_SIGNATURE (sigquit_signal_handler)
-{
-	gboolean res;
-
-	GET_CONTEXT;
-
-	/* We use this signal to start the attach agent too */
-	res = mono_attach_start ();
-	if (res)
-		return;
-
-	printf ("Full thread dump:\n");
-
-	mono_threads_request_thread_dump ();
-
-	/*
-	 * print_thread_dump () skips the current thread, since sending a signal
-	 * to it would invoke the signal handler below the sigquit signal handler,
-	 * and signal handlers don't create an lmf, so the stack walk could not
-	 * be performed.
-	 */
-	mono_print_thread_dump (ctx);
-}
-
-static void
-SIG_HANDLER_SIGNATURE (sigusr2_signal_handler)
-{
-	gboolean enabled = mono_trace_is_enabled ();
-
-	mono_trace_enable (!enabled);
-}
-
-#endif
-
-static void
-SIG_HANDLER_SIGNATURE (sigint_signal_handler)
-{
-	MonoException *exc;
-	GET_CONTEXT;
-
 	exc = mono_get_exception_execution_engine ("Interrupted (SIGINT).");
 	
 	mono_arch_handle_exception (ctx, exc, FALSE);
 }
 
-#ifdef PLATFORM_MACOSX
-
-/*
- * This code disables the CrashReporter of MacOS X by installing
- * a dummy Mach exception handler.
- */
-
-/*
- * http://darwinsource.opendarwin.org/10.4.3/xnu-792.6.22/osfmk/man/exc_server.html
- */
-extern
-boolean_t
-exc_server (mach_msg_header_t *request_msg,
-	    mach_msg_header_t *reply_msg);
-
-/*
- * The exception message
- */
-typedef struct {
-	mach_msg_base_t msg;  /* common mach message header */
-	char payload [1024];  /* opaque */
-} mach_exception_msg_t;
-
-/* The exception port */
-static mach_port_t mach_exception_port = VM_MAP_NULL;
-
-/*
- * Implicitly called by exc_server. Must be public.
- *
- * http://darwinsource.opendarwin.org/10.4.3/xnu-792.6.22/osfmk/man/catch_exception_raise.html
- */
-kern_return_t
-catch_exception_raise (
-	mach_port_t exception_port,
-	mach_port_t thread,
-	mach_port_t task,
-	exception_type_t exception,
-	exception_data_t code,
-	mach_msg_type_number_t code_count)
-{
-	/* consume the exception */
-	return KERN_FAILURE;
-}
-
-/*
- * Exception thread handler.
- */
-static
-void *
-mach_exception_thread (void *arg)
-{
-	for (;;) {
-		mach_exception_msg_t request;
-		mach_exception_msg_t reply;
-		mach_msg_return_t result;
-
-		/* receive from "mach_exception_port" */
-		result = mach_msg (&request.msg.header,
-				   MACH_RCV_MSG | MACH_RCV_LARGE,
-				   0,
-				   sizeof (request),
-				   mach_exception_port,
-				   MACH_MSG_TIMEOUT_NONE,
-				   MACH_PORT_NULL);
-
-		g_assert (result == MACH_MSG_SUCCESS);
-
-		/* dispatch to catch_exception_raise () */
-		exc_server (&request.msg.header, &reply.msg.header);
-
-		/* send back to sender */
-		result = mach_msg (&reply.msg.header,
-				   MACH_SEND_MSG,
-				   reply.msg.header.msgh_size,
-				   0,
-				   MACH_PORT_NULL,
-				   MACH_MSG_TIMEOUT_NONE,
-				   MACH_PORT_NULL);
-
-		g_assert (result == MACH_MSG_SUCCESS);
-	}
-	return NULL;
-}
-
-static void
-macosx_register_exception_handler ()
-{
-	mach_port_t task;
-	pthread_attr_t attr;
-	pthread_t thread;
-
-	if (mach_exception_port != VM_MAP_NULL)
-		return;
-
-	task = mach_task_self ();
-
-	/* create the "mach_exception_port" with send & receive rights */
-	g_assert (mach_port_allocate (task, MACH_PORT_RIGHT_RECEIVE,
-				      &mach_exception_port) == KERN_SUCCESS);
-	g_assert (mach_port_insert_right (task, mach_exception_port, mach_exception_port,
-					  MACH_MSG_TYPE_MAKE_SEND) == KERN_SUCCESS);
-
-	/* create the exception handler thread */
-	g_assert (!pthread_attr_init (&attr));
-	g_assert (!pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED));
-	g_assert (!pthread_create (&thread, &attr, mach_exception_thread, NULL));
-	pthread_attr_destroy (&attr);
-
-	/*
-	 * register "mach_exception_port" as a receiver for the
-	 * EXC_BAD_ACCESS exception
-	 *
-	 * http://darwinsource.opendarwin.org/10.4.3/xnu-792.6.22/osfmk/man/task_set_exception_ports.html
-	 */
-	g_assert (task_set_exception_ports (task, EXC_MASK_BAD_ACCESS,
-					    mach_exception_port,
-					    EXCEPTION_DEFAULT,
-					    MACHINE_THREAD_STATE) == KERN_SUCCESS);
-}
-#endif
-
-#ifndef PLATFORM_WIN32
-static void
-add_signal_handler (int signo, gpointer handler)
-{
-	struct sigaction sa;
-
-#ifdef MONO_ARCH_USE_SIGACTION
-	sa.sa_sigaction = handler;
-	sigemptyset (&sa.sa_mask);
-	sa.sa_flags = SA_SIGINFO;
-#ifdef MONO_ARCH_SIGSEGV_ON_ALTSTACK
-	if (signo == SIGSEGV)
-		sa.sa_flags |= SA_ONSTACK;
-#endif
-#else
-	sa.sa_handler = handler;
-	sigemptyset (&sa.sa_mask);
-	sa.sa_flags = 0;
-#endif
-	g_assert (sigaction (signo, &sa, NULL) != -1);
-}
-
-static void
-remove_signal_handler (int signo)
-{
-	struct sigaction sa;
-
-	sa.sa_handler = SIG_DFL;
-	sigemptyset (&sa.sa_mask);
-	sa.sa_flags = 0;
-
-	sigaction (signo, &sa, NULL);
-}
-#endif
-
-static void
-mono_runtime_install_handlers (void)
-{
-#ifdef PLATFORM_WIN32
-	win32_seh_init();
-	win32_seh_set_handler(SIGFPE, sigfpe_signal_handler);
-	win32_seh_set_handler(SIGILL, sigill_signal_handler);
-	win32_seh_set_handler(SIGSEGV, sigsegv_signal_handler);
-	if (debug_options.handle_sigint)
-		win32_seh_set_handler(SIGINT, sigint_signal_handler);
-
-#else /* !PLATFORM_WIN32 */
-
-	sigset_t signal_set;
-
-#if defined(PLATFORM_MACOSX) && !defined(__arm__)
-	macosx_register_exception_handler ();
-#endif
-
-	if (debug_options.handle_sigint)
-		add_signal_handler (SIGINT, sigint_signal_handler);
-
-	add_signal_handler (SIGFPE, sigfpe_signal_handler);
-	add_signal_handler (SIGQUIT, sigquit_signal_handler);
-	add_signal_handler (SIGILL, sigill_signal_handler);
-	add_signal_handler (SIGBUS, sigsegv_signal_handler);
-	if (mono_jit_trace_calls != NULL)
-		add_signal_handler (SIGUSR2, sigusr2_signal_handler);
-
-	add_signal_handler (mono_thread_get_abort_signal (), sigusr1_signal_handler);
-	/* it seems to have become a common bug for some programs that run as parents
-	 * of many processes to block signal delivery for real time signals.
-	 * We try to detect and work around their breakage here.
-	 */
-	sigemptyset (&signal_set);
-	sigaddset (&signal_set, mono_thread_get_abort_signal ());
-	sigprocmask (SIG_UNBLOCK, &signal_set, NULL);
-
-	signal (SIGPIPE, SIG_IGN);
-
-	add_signal_handler (SIGABRT, sigabrt_signal_handler);
-
-	/* catch SIGSEGV */
-	add_signal_handler (SIGSEGV, sigsegv_signal_handler);
-#endif /* PLATFORM_WIN32 */
-}
-
-static void
-mono_runtime_cleanup_handlers (void)
-{
-#ifdef PLATFORM_WIN32
-	win32_seh_cleanup();
-#else
-	if (debug_options.handle_sigint)
-		remove_signal_handler (SIGINT);
-
-	remove_signal_handler (SIGFPE);
-	remove_signal_handler (SIGQUIT);
-	remove_signal_handler (SIGILL);
-	remove_signal_handler (SIGBUS);
-	if (mono_jit_trace_calls != NULL)
-		remove_signal_handler (SIGUSR2);
-
-	remove_signal_handler (mono_thread_get_abort_signal ());
-
-	remove_signal_handler (SIGABRT);
-
-	remove_signal_handler (SIGSEGV);
-#endif /* PLATFORM_WIN32 */
-}
-
-
-#ifdef HAVE_LINUX_RTC_H
-#include <linux/rtc.h>
-#include <sys/ioctl.h>
-#include <fcntl.h>
-static int rtc_fd = -1;
-
-static int
-enable_rtc_timer (gboolean enable)
-{
-	int flags;
-	flags = fcntl (rtc_fd, F_GETFL);
-	if (flags < 0) {
-		perror ("getflags");
-		return 0;
-	}
-	if (enable)
-		flags |= FASYNC;
-	else
-		flags &= ~FASYNC;
-	if (fcntl (rtc_fd, F_SETFL, flags) == -1) {
-		perror ("setflags");
-		return 0;
-	}
-	return 1;
-}
-#endif
-
-#ifdef PLATFORM_WIN32
-static HANDLE win32_main_thread;
-static MMRESULT win32_timer;
-
-static void CALLBACK
-win32_time_proc (UINT uID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2)
-{
-	CONTEXT context;
-
-	context.ContextFlags = CONTEXT_CONTROL;
-	if (GetThreadContext (win32_main_thread, &context)) {
-#ifdef _WIN64
-		mono_profiler_stat_hit ((guchar *) context.Rip, &context);
-#else
-		mono_profiler_stat_hit ((guchar *) context.Eip, &context);
-#endif
-	}
-}
-#endif
-
-static void
-setup_stat_profiler (void)
-{
-#ifdef ITIMER_PROF
-	struct itimerval itval;
-	static int inited = 0;
-#ifdef HAVE_LINUX_RTC_H
-	const char *rtc_freq;
-	if (!inited && (rtc_freq = g_getenv ("MONO_RTC"))) {
-		int freq = 0;
-		inited = 1;
-		if (*rtc_freq)
-			freq = atoi (rtc_freq);
-		if (!freq)
-			freq = 1024;
-		rtc_fd = open ("/dev/rtc", O_RDONLY);
-		if (rtc_fd == -1) {
-			perror ("open /dev/rtc");
-			return;
-		}
-		add_signal_handler (SIGPROF, sigprof_signal_handler);
-		if (ioctl (rtc_fd, RTC_IRQP_SET, freq) == -1) {
-			perror ("set rtc freq");
-			return;
-		}
-		if (ioctl (rtc_fd, RTC_PIE_ON, 0) == -1) {
-			perror ("start rtc");
-			return;
-		}
-		if (fcntl (rtc_fd, F_SETSIG, SIGPROF) == -1) {
-			perror ("setsig");
-			return;
-		}
-		if (fcntl (rtc_fd, F_SETOWN, getpid ()) == -1) {
-			perror ("setown");
-			return;
-		}
-		enable_rtc_timer (TRUE);
-		return;
-	}
-	if (rtc_fd >= 0)
-		return;
-#endif
-
-	itval.it_interval.tv_usec = 999;
-	itval.it_interval.tv_sec = 0;
-	itval.it_value = itval.it_interval;
-	setitimer (ITIMER_PROF, &itval, NULL);
-	if (inited)
-		return;
-	inited = 1;
-	add_signal_handler (SIGPROF, sigprof_signal_handler);
-#elif defined (PLATFORM_WIN32)
-	static int inited = 0;
-	TIMECAPS timecaps;
-
-	if (inited)
-		return;
-
-	inited = 1;
-	if (timeGetDevCaps (&timecaps, sizeof (timecaps)) != TIMERR_NOERROR)
-		return;
-
-	if ((win32_main_thread = OpenThread (READ_CONTROL | THREAD_GET_CONTEXT, FALSE, GetCurrentThreadId ())) == NULL)
-		return;
-
-	if (timeBeginPeriod (1) != TIMERR_NOERROR)
-		return;
-
-	if ((win32_timer = timeSetEvent (1, 0, win32_time_proc, 0, TIME_PERIODIC)) == 0) {
-		timeEndPeriod (1);
-		return;
-	}
-#endif
-}
-
 /* mono_jit_create_remoting_trampoline:
  * @method: pointer to the method info
  *
@@ -5471,11 +4903,8 @@
 void
 mini_cleanup (MonoDomain *domain)
 {
-#ifdef HAVE_LINUX_RTC_H
-	if (rtc_fd >= 0)
-		enable_rtc_timer (FALSE);
-#endif
-
+	mono_runtime_shutdown_stat_profiler ();
+	
 #ifndef DISABLE_COM
 	cominterop_release_all_rcws ();
 #endif
Index: mono/mini/mini.h
===================================================================
--- mono/mini/mini.h	(revision 124731)
+++ mono/mini/mini.h	(working copy)
@@ -1639,11 +1639,60 @@
 };
 
 const char *mono_arch_xregname (int reg) MONO_INTERNAL;
-void mono_simd_simplify_indirection (MonoCompile *cfg) MONO_INTERNAL;
-MonoInst* mono_emit_simd_intrinsics (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **args) MONO_INTERNAL;
-guint32   mono_arch_cpu_enumerate_simd_versions (void) MONO_INTERNAL;
-void mono_simd_intrinsics_init (void) MONO_INTERNAL;
+void        mono_simd_simplify_indirection (MonoCompile *cfg) MONO_INTERNAL;
+MonoInst*   mono_emit_simd_intrinsics (MonoCompile *cfg, MonoMethod *cmethod, MonoMethodSignature *fsig, MonoInst **args) MONO_INTERNAL;
+guint32     mono_arch_cpu_enumerate_simd_versions (void) MONO_INTERNAL;
+void        mono_simd_intrinsics_init (void) MONO_INTERNAL;
 
+/*
+ * Per-OS implementation functions.
+ */
+void mono_runtime_install_handlers (void) MONO_INTERNAL;
+void mono_runtime_cleanup_handlers (void) MONO_INTERNAL;
+void mono_runtime_setup_stat_profiler (void) MONO_INTERNAL;
+void mono_runtime_shutdown_stat_profiler (void) MONO_INTERNAL;
+void mono_runtime_posix_install_handlers (void) MONO_INTERNAL;
+
+/*
+ * Signal handling
+ */
+#ifdef MONO_GET_CONTEXT
+#define GET_CONTEXT MONO_GET_CONTEXT
+#endif
+
+#ifndef GET_CONTEXT
+#ifdef PLATFORM_WIN32
+#define GET_CONTEXT \
+	struct sigcontext *ctx = (struct sigcontext*)_dummy;
+#else
+#ifdef MONO_ARCH_USE_SIGACTION
+#define GET_CONTEXT \
+    void *ctx = context;
+#elif defined(__sparc__)
+#define GET_CONTEXT \
+    void *ctx = sigctx;
+#else
+#define GET_CONTEXT \
+	void **_p = (void **)&_dummy; \
+	struct sigcontext *ctx = (struct sigcontext *)++_p;
+#endif
+#endif
+#endif
+
+#ifdef MONO_ARCH_USE_SIGACTION
+#define SIG_HANDLER_SIGNATURE(ftn) ftn (int _dummy, siginfo_t *info, void *context)
+#elif defined(__sparc__)
+#define SIG_HANDLER_SIGNATURE(ftn) ftn (int _dummy, void *sigctx)
+#else
+#define SIG_HANDLER_SIGNATURE(ftn) ftn (int _dummy)
+#endif
+
+void SIG_HANDLER_SIGNATURE (mono_sigfpe_signal_handler)  MONO_INTERNAL;
+void SIG_HANDLER_SIGNATURE (mono_sigill_signal_handler)  MONO_INTERNAL;
+void SIG_HANDLER_SIGNATURE (mono_sigsegv_signal_handler) MONO_INTERNAL;
+void SIG_HANDLER_SIGNATURE (mono_sigint_signal_handler)  MONO_INTERNAL;
+
+
 /* for MONO_WRAPPER_UNKNOWN subtypes */
 enum {
 	MONO_AOT_WRAPPER_MONO_ENTER,
Index: mono/mini/mini-exceptions.c
===================================================================
--- mono/mini/mini-exceptions.c	(revision 124731)
+++ mono/mini/mini-exceptions.c	(working copy)
@@ -3,8 +3,10 @@
  *
  * Authors:
  *   Dietmar Maurer (dietmar@ximian.com)
+ *   Mono Team (mono-list@lists.ximian.com)
  *
- * (C) 2001 Ximian, Inc.
+ * Copyright 2001-2003 Ximian, Inc.
+ * Copyright 2003-2008 Ximian, Inc.
  */
 
 #include <config.h>
Index: mono/mini/Makefile.am
===================================================================
--- mono/mini/Makefile.am	(revision 124731)
+++ mono/mini/Makefile.am	(working copy)
@@ -211,6 +211,15 @@
 	exceptions-hppa.c	\
 	tramp-hppa.c
 
+darwin_sources = \
+	mini-darwin.c
+
+windows_sources = \
+	mini-windows.c
+
+posix_sources = \
+	mini-posix.c
+
 common_sources = \
 	mini.c		\
 	ir-emit.h	\
@@ -245,8 +254,8 @@
 	aot-compiler.c		\
 	aot-runtime.c		\
 	graph.c		\
+	mini-codegen.c		\
 	mini-exceptions.c	\
-	mini-codegen.c		\
 	mini-trampolines.c  \
 	declsec.c	\
 	declsec.h	\
@@ -373,8 +382,20 @@
 arch_define=__hppa__
 endif
 
-libmono_la_SOURCES = $(common_sources) $(arch_sources)
+if PLATFORM_WIN32
+os_sources = $(windows_sources)
+endif
 
+if PLATFORM_SIGPOSIX
+os_sources = $(posix_sources)
+endif
+
+if PLATFORM_DARWIN
+os_sources = $(darwin_sources) $(posix_sources)
+endif
+
+libmono_la_SOURCES = $(common_sources) $(arch_sources) $(os_sources)
+
 libmono_static_la_SOURCES = $(libmono_la_SOURCES)
 nodist_libmono_static_la_SOURCES = $(nodist_libmono_la_SOURCES)
 libmono_static_la_LDFLAGS = -static
@@ -521,7 +542,10 @@
 	$(s390x_sources) cpu-s390x.md \
 	$(ia64_sources) cpu-ia64.md \
 	$(alpha_sources) cpu-alpha.md \
-	$(hppa_sources) cpu-hppa.md
+	$(hppa_sources) cpu-hppa.md 	\
+	$(windows_sources)		\
+	$(darwin_sources)		\
+	$(posix_sources)
 
 version.h: Makefile
 	if test -d $(top_srcdir)/.git/svn; then svn_info='git svn info'; fi; \
Index: mono/mini/mini-windows.c
===================================================================
--- mono/mini/mini-windows.c	(revision 0)
+++ mono/mini/mini-windows.c	(revision 0)
@@ -0,0 +1,116 @@
+/*
+ * mini-posix.c: POSIX signal handling support for Mono.
+ *
+ * Authors:
+ *   Mono Team (mono-list@lists.ximian.com)
+ *
+ * Copyright 2001-2003 Ximian, Inc.
+ * Copyright 2003-2008 Ximian, Inc.
+ *
+ * See LICENSE for licensing information.
+ */
+#include <config.h>
+#include <signal.h>
+#include <math.h>
+
+#include <mono/metadata/assembly.h>
+#include <mono/metadata/loader.h>
+#include <mono/metadata/tabledefs.h>
+#include <mono/metadata/class.h>
+#include <mono/metadata/object.h>
+#include <mono/metadata/tokentype.h>
+#include <mono/metadata/tabledefs.h>
+#include <mono/metadata/threads.h>
+#include <mono/metadata/appdomain.h>
+#include <mono/metadata/debug-helpers.h>
+#include <mono/io-layer/io-layer.h>
+#include "mono/metadata/profiler.h"
+#include <mono/metadata/profiler-private.h>
+#include <mono/metadata/mono-config.h>
+#include <mono/metadata/environment.h>
+#include <mono/metadata/mono-debug.h>
+#include <mono/metadata/gc-internal.h>
+#include <mono/metadata/threads-types.h>
+#include <mono/metadata/verify.h>
+#include <mono/metadata/verify-internals.h>
+#include <mono/metadata/mempool-internals.h>
+#include <mono/metadata/attach.h>
+#include <mono/utils/mono-math.h>
+#include <mono/utils/mono-compiler.h>
+#include <mono/utils/mono-counters.h>
+#include <mono/utils/mono-logger.h>
+#include <mono/utils/mono-mmap.h>
+#include <mono/utils/dtrace.h>
+
+#include "mini.h"
+#include <string.h>
+#include <ctype.h>
+#include "trace.h"
+#include "version.h"
+
+#include "jit-icalls.h"
+
+void
+mono_runtime_install_handlers (void)
+{
+	win32_seh_init();
+	win32_seh_set_handler(SIGFPE, mono_sigfpe_signal_handler);
+	win32_seh_set_handler(SIGILL, mono_sigill_signal_handler);
+	win32_seh_set_handler(SIGSEGV, mono_sigsegv_signal_handler);
+	if (mini_get_debug_options ()->handle_sigint)
+		win32_seh_set_handler(SIGINT, mono_sigint_signal_handler);
+}
+
+void
+mono_runtime_cleanup_handlers (void)
+{
+	win32_seh_cleanup();
+}
+
+static HANDLE win32_main_thread;
+static MMRESULT win32_timer;
+
+static void CALLBACK
+win32_time_proc (UINT uID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2)
+{
+	CONTEXT context;
+
+	context.ContextFlags = CONTEXT_CONTROL;
+	if (GetThreadContext (win32_main_thread, &context)) {
+#ifdef _WIN64
+		mono_profiler_stat_hit ((guchar *) context.Rip, &context);
+#else
+		mono_profiler_stat_hit ((guchar *) context.Eip, &context);
+#endif
+	}
+}
+
+void
+mono_runtime_setup_stat_profiler (void)
+{
+	static int inited = 0;
+	TIMECAPS timecaps;
+
+	if (inited)
+		return;
+
+	inited = 1;
+	if (timeGetDevCaps (&timecaps, sizeof (timecaps)) != TIMERR_NOERROR)
+		return;
+
+	if ((win32_main_thread = OpenThread (READ_CONTROL | THREAD_GET_CONTEXT, FALSE, GetCurrentThreadId ())) == NULL)
+		return;
+
+	if (timeBeginPeriod (1) != TIMERR_NOERROR)
+		return;
+
+	if ((win32_timer = timeSetEvent (1, 0, win32_time_proc, 0, TIME_PERIODIC)) == 0) {
+		timeEndPeriod (1);
+		return;
+	}
+}
+
+void
+mono_runtime_shutdown_stat_profiler (void)
+{
+}

Property changes on: mono/mini/mini-windows.c
___________________________________________________________________
Added: svn:eol-style
   + native

Index: mono/mini/mini-posix.c
===================================================================
--- mono/mini/mini-posix.c	(revision 0)
+++ mono/mini/mini-posix.c	(revision 0)
@@ -0,0 +1,418 @@
+/*
+ * mini-posix.c: POSIX signal handling support for Mono.
+ *
+ * Authors:
+ *   Mono Team (mono-list@lists.ximian.com)
+ *
+ * Copyright 2001-2003 Ximian, Inc.
+ * Copyright 2003-2008 Ximian, Inc.
+ *
+ * See LICENSE for licensing information.
+ */
+#include <config.h>
+#include <signal.h>
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <math.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+#include <mono/metadata/assembly.h>
+#include <mono/metadata/loader.h>
+#include <mono/metadata/tabledefs.h>
+#include <mono/metadata/class.h>
+#include <mono/metadata/object.h>
+#include <mono/metadata/tokentype.h>
+#include <mono/metadata/tabledefs.h>
+#include <mono/metadata/threads.h>
+#include <mono/metadata/appdomain.h>
+#include <mono/metadata/debug-helpers.h>
+#include <mono/io-layer/io-layer.h>
+#include "mono/metadata/profiler.h"
+#include <mono/metadata/profiler-private.h>
+#include <mono/metadata/mono-config.h>
+#include <mono/metadata/environment.h>
+#include <mono/metadata/mono-debug.h>
+#include <mono/metadata/gc-internal.h>
+#include <mono/metadata/threads-types.h>
+#include <mono/metadata/verify.h>
+#include <mono/metadata/verify-internals.h>
+#include <mono/metadata/mempool-internals.h>
+#include <mono/metadata/attach.h>
+#include <mono/utils/mono-math.h>
+#include <mono/utils/mono-compiler.h>
+#include <mono/utils/mono-counters.h>
+#include <mono/utils/mono-logger.h>
+#include <mono/utils/mono-mmap.h>
+#include <mono/utils/dtrace.h>
+
+#include "mini.h"
+#include <string.h>
+#include <ctype.h>
+#include "trace.h"
+#include "version.h"
+
+#include "jit-icalls.h"
+
+static void
+SIG_HANDLER_SIGNATURE (sigabrt_signal_handler)
+{
+	MonoJitInfo *ji;
+	GET_CONTEXT;
+
+	ji = mono_jit_info_table_find (mono_domain_get (), mono_arch_ip_from_context(ctx));
+	if (!ji) {
+		mono_handle_native_sigsegv (SIGABRT, ctx);
+	}
+}
+
+static void
+SIG_HANDLER_SIGNATURE (sigusr1_signal_handler)
+{
+	gboolean running_managed;
+	MonoException *exc;
+	MonoThread *thread = mono_thread_current ();
+	MonoDomain *domain = mono_domain_get ();
+	void *ji;
+	
+	GET_CONTEXT;
+
+	if (!thread || !domain)
+		/* The thread might not have started up yet */
+		/* FIXME: Specify the synchronization with start_wrapper () in threads.c */
+		return;
+
+	if (thread->thread_dump_requested) {
+		thread->thread_dump_requested = FALSE;
+
+		mono_print_thread_dump (ctx);
+	}
+
+	/*
+	 * FIXME:
+	 * This is an async signal, so the code below must not call anything which
+	 * is not async safe. That includes the pthread locking functions. If we
+	 * know that we interrupted managed code, then locking is safe.
+	 */
+	ji = mono_jit_info_table_find (mono_domain_get (), mono_arch_ip_from_context(ctx));
+	running_managed = ji != NULL;
+	
+	exc = mono_thread_request_interruption (running_managed); 
+	if (!exc) return;
+
+	mono_arch_handle_exception (ctx, exc, FALSE);
+}
+
+#if defined(__i386__) || defined(__x86_64__)
+#define FULL_STAT_PROFILER_BACKTRACE 1
+#define CURRENT_FRAME_GET_BASE_POINTER(f) (* (gpointer*)(f))
+#define CURRENT_FRAME_GET_RETURN_ADDRESS(f) (* (((gpointer*)(f)) + 1))
+#if MONO_ARCH_STACK_GROWS_UP
+#define IS_BEFORE_ON_STACK <
+#define IS_AFTER_ON_STACK >
+#else
+#define IS_BEFORE_ON_STACK >
+#define IS_AFTER_ON_STACK <
+#endif
+#else
+#define FULL_STAT_PROFILER_BACKTRACE 0
+#endif
+
+#if defined(__ia64__) || defined(__sparc__) || defined(sparc) || defined(__s390__) || defined(s390)
+
+static void
+SIG_HANDLER_SIGNATURE (sigprof_signal_handler)
+{
+	NOT_IMPLEMENTED;
+}
+
+#else
+
+static void
+SIG_HANDLER_SIGNATURE (sigprof_signal_handler)
+{
+	int call_chain_depth = mono_profiler_stat_get_call_chain_depth ();
+	GET_CONTEXT;
+	
+	if (call_chain_depth == 0) {
+		mono_profiler_stat_hit (mono_arch_ip_from_context (ctx), ctx);
+	} else {
+		MonoJitTlsData *jit_tls = TlsGetValue (mono_jit_tls_id);
+		int current_frame_index = 1;
+		MonoContext mono_context;
+#if FULL_STAT_PROFILER_BACKTRACE
+		guchar *current_frame;
+		guchar *stack_bottom;
+		guchar *stack_top;
+#else
+		MonoDomain *domain;
+#endif
+		guchar *ips [call_chain_depth + 1];
+
+		mono_arch_sigctx_to_monoctx (ctx, &mono_context);
+		ips [0] = MONO_CONTEXT_GET_IP (&mono_context);
+		
+		if (jit_tls != NULL) {
+#if FULL_STAT_PROFILER_BACKTRACE
+			stack_bottom = jit_tls->end_of_stack;
+			stack_top = MONO_CONTEXT_GET_SP (&mono_context);
+			current_frame = MONO_CONTEXT_GET_BP (&mono_context);
+			
+			while ((current_frame_index <= call_chain_depth) &&
+					(stack_bottom IS_BEFORE_ON_STACK (guchar*) current_frame) &&
+					((guchar*) current_frame IS_BEFORE_ON_STACK stack_top)) {
+				ips [current_frame_index] = CURRENT_FRAME_GET_RETURN_ADDRESS (current_frame);
+				current_frame_index ++;
+				stack_top = current_frame;
+				current_frame = CURRENT_FRAME_GET_BASE_POINTER (current_frame);
+			}
+#else
+			domain = mono_domain_get ();
+			if (domain != NULL) {
+				MonoLMF *lmf = NULL;
+				MonoJitInfo *ji;
+				MonoJitInfo res;
+				MonoContext new_mono_context;
+				int native_offset;
+				ji = mono_find_jit_info (domain, jit_tls, &res, NULL, &mono_context,
+						&new_mono_context, NULL, &lmf, &native_offset, NULL);
+				while ((ji != NULL) && (current_frame_index <= call_chain_depth)) {
+					ips [current_frame_index] = MONO_CONTEXT_GET_IP (&new_mono_context);
+					current_frame_index ++;
+					mono_context = new_mono_context;
+					ji = mono_find_jit_info (domain, jit_tls, &res, NULL, &mono_context,
+							&new_mono_context, NULL, &lmf, &native_offset, NULL);
+				}
+			}
+#endif
+		}
+		
+		
+		mono_profiler_stat_call_chain (current_frame_index, & ips [0], ctx);
+	}
+}
+
+#endif
+
+static void
+SIG_HANDLER_SIGNATURE (sigquit_signal_handler)
+{
+	gboolean res;
+
+	GET_CONTEXT;
+
+	/* We use this signal to start the attach agent too */
+	res = mono_attach_start ();
+	if (res)
+		return;
+
+	printf ("Full thread dump:\n");
+
+	mono_threads_request_thread_dump ();
+
+	/*
+	 * print_thread_dump () skips the current thread, since sending a signal
+	 * to it would invoke the signal handler below the sigquit signal handler,
+	 * and signal handlers don't create an lmf, so the stack walk could not
+	 * be performed.
+	 */
+	mono_print_thread_dump (ctx);
+}
+
+static void
+SIG_HANDLER_SIGNATURE (sigusr2_signal_handler)
+{
+	gboolean enabled = mono_trace_is_enabled ();
+
+	mono_trace_enable (!enabled);
+}
+
+static void
+add_signal_handler (int signo, gpointer handler)
+{
+	struct sigaction sa;
+
+#ifdef MONO_ARCH_USE_SIGACTION
+	sa.sa_sigaction = handler;
+	sigemptyset (&sa.sa_mask);
+	sa.sa_flags = SA_SIGINFO;
+#ifdef MONO_ARCH_SIGSEGV_ON_ALTSTACK
+	if (signo == SIGSEGV)
+		sa.sa_flags |= SA_ONSTACK;
+#endif
+#else
+	sa.sa_handler = handler;
+	sigemptyset (&sa.sa_mask);
+	sa.sa_flags = 0;
+#endif
+	g_assert (sigaction (signo, &sa, NULL) != -1);
+}
+
+static void
+remove_signal_handler (int signo)
+{
+	struct sigaction sa;
+
+	sa.sa_handler = SIG_DFL;
+	sigemptyset (&sa.sa_mask);
+	sa.sa_flags = 0;
+
+	sigaction (signo, &sa, NULL);
+}
+
+void
+mono_runtime_posix_install_handlers (void)
+{
+
+	sigset_t signal_set;
+
+	if (mini_get_debug_options ()->handle_sigint)
+		add_signal_handler (SIGINT, mono_sigint_signal_handler);
+
+	add_signal_handler (SIGFPE, mono_sigfpe_signal_handler);
+	add_signal_handler (SIGQUIT, sigquit_signal_handler);
+	add_signal_handler (SIGILL, mono_sigill_signal_handler);
+	add_signal_handler (SIGBUS, mono_sigsegv_signal_handler);
+	if (mono_jit_trace_calls != NULL)
+		add_signal_handler (SIGUSR2, sigusr2_signal_handler);
+
+	add_signal_handler (mono_thread_get_abort_signal (), sigusr1_signal_handler);
+	/* it seems to have become a common bug for some programs that run as parents
+	 * of many processes to block signal delivery for real time signals.
+	 * We try to detect and work around their breakage here.
+	 */
+	sigemptyset (&signal_set);
+	sigaddset (&signal_set, mono_thread_get_abort_signal ());
+	sigprocmask (SIG_UNBLOCK, &signal_set, NULL);
+
+	signal (SIGPIPE, SIG_IGN);
+
+	add_signal_handler (SIGABRT, sigabrt_signal_handler);
+
+	/* catch SIGSEGV */
+	add_signal_handler (SIGSEGV, mono_sigsegv_signal_handler);
+}
+
+#ifndef PLATFORM_MACOSX
+void
+mono_runtime_install_handlers (void)
+{
+	mono_runtime_posix_install_handlers ();
+}
+#endif
+
+void
+mono_runtime_cleanup_handlers (void)
+{
+	if (mini_get_debug_options ()->handle_sigint)
+		remove_signal_handler (SIGINT);
+
+	remove_signal_handler (SIGFPE);
+	remove_signal_handler (SIGQUIT);
+	remove_signal_handler (SIGILL);
+	remove_signal_handler (SIGBUS);
+	if (mono_jit_trace_calls != NULL)
+		remove_signal_handler (SIGUSR2);
+
+	remove_signal_handler (mono_thread_get_abort_signal ());
+
+	remove_signal_handler (SIGABRT);
+
+	remove_signal_handler (SIGSEGV);
+}
+
+#ifdef HAVE_LINUX_RTC_H
+#include <linux/rtc.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+static int rtc_fd = -1;
+
+static int
+enable_rtc_timer (gboolean enable)
+{
+	int flags;
+	flags = fcntl (rtc_fd, F_GETFL);
+	if (flags < 0) {
+		perror ("getflags");
+		return 0;
+	}
+	if (enable)
+		flags |= FASYNC;
+	else
+		flags &= ~FASYNC;
+	if (fcntl (rtc_fd, F_SETFL, flags) == -1) {
+		perror ("setflags");
+		return 0;
+	}
+	return 1;
+}
+#endif
+
+void
+mono_runtime_shutdown_stat_profiler (void)
+{
+#ifdef HAVE_LINUX_RTC_H
+	if (rtc_fd >= 0)
+		enable_rtc_timer (FALSE);
+#endif
+}
+
+void
+mono_runtime_setup_stat_profiler (void)
+{
+#ifdef ITIMER_PROF
+	struct itimerval itval;
+	static int inited = 0;
+#ifdef HAVE_LINUX_RTC_H
+	const char *rtc_freq;
+	if (!inited && (rtc_freq = g_getenv ("MONO_RTC"))) {
+		int freq = 0;
+		inited = 1;
+		if (*rtc_freq)
+			freq = atoi (rtc_freq);
+		if (!freq)
+			freq = 1024;
+		rtc_fd = open ("/dev/rtc", O_RDONLY);
+		if (rtc_fd == -1) {
+			perror ("open /dev/rtc");
+			return;
+		}
+		add_signal_handler (SIGPROF, sigprof_signal_handler);
+		if (ioctl (rtc_fd, RTC_IRQP_SET, freq) == -1) {
+			perror ("set rtc freq");
+			return;
+		}
+		if (ioctl (rtc_fd, RTC_PIE_ON, 0) == -1) {
+			perror ("start rtc");
+			return;
+		}
+		if (fcntl (rtc_fd, F_SETSIG, SIGPROF) == -1) {
+			perror ("setsig");
+			return;
+		}
+		if (fcntl (rtc_fd, F_SETOWN, getpid ()) == -1) {
+			perror ("setown");
+			return;
+		}
+		enable_rtc_timer (TRUE);
+		return;
+	}
+	if (rtc_fd >= 0)
+		return;
+#endif
+
+	itval.it_interval.tv_usec = 999;
+	itval.it_interval.tv_sec = 0;
+	itval.it_value = itval.it_interval;
+	setitimer (ITIMER_PROF, &itval, NULL);
+	if (inited)
+		return;
+	inited = 1;
+	add_signal_handler (SIGPROF, sigprof_signal_handler);
+#endif
+}

Property changes on: mono/mini/mini-posix.c
___________________________________________________________________
Added: svn:eol-style
   + native

Index: configure.in
===================================================================
--- configure.in	(revision 124731)
+++ configure.in	(working copy)
@@ -97,6 +97,7 @@
 		libdl="-ldl"
 		libgc_threads=pthreads
 		with_sigaltstack=no
+		use_sigposix=yes
 		;;
 	*-*-*freebsd*)
 		platform_win32=no
@@ -125,6 +126,7 @@
 # but NOT library support)
 #
 		with_tls=pthread
+		use_sigposix=yes
 		;;
 	*-*-*openbsd*)
 		platform_win32=no
@@ -136,6 +138,7 @@
 		AC_DEFINE(PTHREAD_POINTER_ID)
 		libdl=
 		libgc_threads=pthreads
+		use_sigposix=yes
 		;;
 	*-*-linux*)
 		platform_win32=no
@@ -145,9 +148,10 @@
 		libdl="-ldl"
 		libgc_threads=pthreads
 		AOT_SUPPORTED="yes"
+		use_sigposix=yes
 		;;
 	*-*-hpux*)
-        platform_win32=no
+	        platform_win32=no
 		CPPFLAGS="$CPPFLAGS -DGC_HPUX_THREADS -D_HPUX_SOURCE -D_XOPEN_SOURCE_EXTENDED -D_REENTRANT"
 		# +ESdbgasm only valid on bundled cc on RISC
 		# silently ignored for ia64
@@ -163,6 +167,7 @@
 		libmono_ldflags="-lpthread"
 		libgc_threads=pthreads
 		need_link_unlink=yes
+		use_sigposix=yes
 		;;
 	*-*-solaris*)
 		platform_win32=no
@@ -173,6 +178,7 @@
 		# This doesn't seem to work on solaris/x86, but the configure test runs
 		with_tls=pthread
 		has_dtrace=yes
+		use_sigposix=yes
 		;;
 	*-*-darwin*)
 		platform_win32=no
@@ -207,6 +213,8 @@
 
 AM_CONDITIONAL(PLATFORM_WIN32, test x$platform_win32 = xyes)
 AM_CONDITIONAL(PLATFORM_LINUX, echo x$target_os | grep -q linux)
+AM_CONDITIONAL(PLATFORM_DARWIN, test x$platform_darwin = xyes)
+AM_CONDITIONAL(PLATFORM_SIGPOSIX, test x$use_sigposix = xyes)
 
 AC_CHECK_TOOL(CC, gcc, gcc)
 AC_PROG_CC
