? FlagsTest.cs
? changes
? changes2
? class.cs.new
? class.cs.tmp
? expression.cs.tmp
? properties-access.tar.bz2
Index: class.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/class.cs,v
retrieving revision 1.519
diff -u -r1.519 class.cs
--- class.cs	13 Oct 2004 09:06:16 -0000	1.519
+++ class.cs	16 Oct 2004 02:41:59 -0000
@@ -5276,15 +5276,23 @@
 		//
 		// Null if the accessor is empty, or a Block if not
 		//
+		public const int AllowedModifiers = 
+			Modifiers.PUBLIC |
+			Modifiers.PROTECTED |
+			Modifiers.INTERNAL |
+			Modifiers.PRIVATE;
+		
 		public Block Block;
 		public Attributes Attributes;
 		public Location Location;
+		public int ModFlags;
 		
-		public Accessor (Block b, Attributes attrs, Location loc)
+		public Accessor (Block b, int mod, Attributes attrs, Location loc)
 		{
 			Block = b;
 			Attributes = attrs;
 			Location = loc;
+			ModFlags = Modifiers.Check (AllowedModifiers, mod, 0, loc);
 		}
 	}
 
@@ -5466,7 +5474,9 @@
 
 			public override MethodBuilder Define(TypeContainer container)
 			{
-				method_data = new MethodData (method, method.ParameterInfo, method.ModFlags, method.flags, this);
+				DefineModifiers ();
+				
+				method_data = new MethodData (method, method.ParameterInfo, ModFlags, flags, this);
 
 				if (!method_data.Define (container))
 					return null;
@@ -5533,7 +5543,10 @@
 			{
 				if (container.EmitContext == null)
 					throw new InternalErrorException ("SetMethod.Define called too early");
-				method_data = new MethodData (method, GetParameterInfo (container.EmitContext), method.ModFlags, method.flags, this);
+					
+				DefineModifiers ();
+				
+				method_data = new MethodData (method, GetParameterInfo (container.EmitContext), ModFlags, flags, this);
 
 				if (!method_data.Define (container))
 					return null;
@@ -5570,6 +5583,7 @@
 		public abstract class PropertyMethod: AbstractPropertyEventMethod
 		{
 			protected readonly MethodCore method;
+			protected MethodAttributes flags;
 
 			public PropertyMethod (MethodCore method, string prefix)
 				: base (method, prefix)
@@ -5582,6 +5596,9 @@
 				: base (method, accessor, prefix)
 			{
 				this.method = method;
+				
+				if (accessor.ModFlags != 0)
+					CheckModifiers (accessor.ModFlags);
 			}
 
 			public override AttributeTargets AttributeTargets {
@@ -5627,6 +5644,44 @@
 			{
 				return String.Concat (tc.Name, '.', method.Name);
 			}
+			
+			void CheckModifiers (int modflags)
+                        {
+                                int flags = 0;
+                                int mflags = method.ModFlags & Modifiers.Accessibility;
+
+                                if ((mflags & Modifiers.PUBLIC) != 0) {
+                                        flags |= Modifiers.PROTECTED | Modifiers.INTERNAL | Modifiers.PRIVATE;
+                                }
+                                else if ((mflags & Modifiers.PROTECTED) != 0) {
+                                        if ((mflags & Modifiers.INTERNAL) != 0)
+                                                flags |= Modifiers.PROTECTED | Modifiers.INTERNAL | Modifiers.PRIVATE;
+
+                                        flags |= Modifiers.PRIVATE;
+                                }
+                                else if ((mflags & Modifiers.INTERNAL) != 0)
+                                        flags |= Modifiers.PRIVATE;
+
+                                if ((mflags == modflags) || (modflags & (~flags)) != 0)
+                                        Report.Error (273, Location, "Accessibility modifier must be more restrictive than the property or indexer.");
+
+                                ModFlags = modflags;
+                        }
+
+                        protected void DefineModifiers ()
+                        {
+                                if (ModFlags == 0) {
+                                        ModFlags = method.ModFlags;
+                                        flags = method.flags;
+                                        return;
+                                }
+
+                                ModFlags |= (method.ModFlags & (~Modifiers.Accessibility));
+                                flags = Modifiers.MethodAttr (ModFlags);
+                                flags |= (method.flags & (~MethodAttributes.MemberAccessMask));
+
+                        }
+
 		}
 
 
@@ -5806,15 +5861,37 @@
 				is_iface, name, Parameters.EmptyReadOnlyParameters, attrs,
 				loc)
 		{
-			if (get_block == null)
+			bool error274 = false, error276 = false;
+			
+			if (get_block == null) 
 				Get = new GetMethod (this);
-			else
+			else {
 				Get = new GetMethod (this, get_block);
+				
+				if (set_block == null ) {
+					if ((get_block.ModFlags & Modifiers.Accessibility) != 0 && (mod & Modifiers.OVERRIDE) == 0)
+						error276 = true;
+				} else if (get_block.ModFlags != 0 && set_block.ModFlags != 0)
+					error274 = true;
+			}
 
-			if (set_block == null)
+			if (set_block == null) 
 				Set = new SetMethod (this);
-			else
+			else {
 				Set = new SetMethod (this, set_block);
+				
+				if (get_block == null ) {
+					if ((set_block.ModFlags & Modifiers.Accessibility) != 0 && (mod & Modifiers.OVERRIDE) == 0)
+						error276 = true;
+				} else if (get_block.ModFlags != 0 && set_block.ModFlags != 0)
+					error274 = true;
+			}
+			
+			if (error274)
+				Report.Error (274, loc, "Cannot specify accessibility modifiers for both accessors of the property or indexer.");
+			else if (error276)
+				Report.Error (276, loc, 
+					"Accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor.");
 		}
 
 		public override bool Define ()
@@ -6525,15 +6602,37 @@
 				is_iface ? AllowedInterfaceModifiers : AllowedModifiers,
 				is_iface, name, parameters, attrs, loc)
 		{
-			if (get_block == null)
+			bool error274 = false, error276 = false;
+			
+			if (get_block == null) 
 				Get = new GetIndexerMethod (this);
-			else
+			else {
 				Get = new GetIndexerMethod (this, get_block);
+				
+				if (set_block == null ) {
+					if ((get_block.ModFlags & Modifiers.Accessibility) != 0 && (mod & Modifiers.OVERRIDE) == 0)
+						error276 = true;
+				} else if (get_block.ModFlags != 0 && set_block.ModFlags != 0)
+					error274 = true;
+			}
 
-			if (set_block == null)
+			if (set_block == null) 
 				Set = new SetIndexerMethod (this);
-			else
+			else {
 				Set = new SetIndexerMethod (this, parameters, set_block);
+				
+				if (get_block == null ) {
+					if ((set_block.ModFlags & Modifiers.Accessibility) != 0 && (mod & Modifiers.OVERRIDE) == 0)
+						error276 = true;
+				} else if (get_block.ModFlags != 0 && set_block.ModFlags != 0)
+					error274 = true;
+			}
+			
+			if (error274)
+				Report.Error (274, loc, "Cannot specify accessibility modifiers for both accessors of the property or indexer.");
+			else if (error276)
+				Report.Error (276, loc, 
+					"Accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor.");
 		}
 		       
 		public override bool Define ()
Index: cs-parser.jay
===================================================================
RCS file: /cvs/public/mcs/mcs/cs-parser.jay,v
retrieving revision 1.334
diff -u -r1.334 cs-parser.jay
--- cs-parser.jay	12 Oct 2004 23:00:29 -0000	1.334
+++ cs-parser.jay	16 Oct 2004 02:42:00 -0000
@@ -1204,7 +1204,7 @@
 	;
 
 get_accessor_declaration
-	: opt_attributes GET
+	: opt_attributes opt_modifiers GET
 	  {
 		// If this is not the case, then current_local_parameters has already
 		// been set in indexer_declaration
@@ -1216,14 +1216,14 @@
 	  }
           accessor_body
 	  {
-		$$ = new Accessor ((Block) $4, (Attributes) $1, lexer.Location);
+		$$ = new Accessor ((Block) $5, (int) $2, (Attributes) $1, lexer.Location);
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 	  }
 	;
 
 set_accessor_declaration
-	: opt_attributes SET 
+	: opt_attributes opt_modifiers SET 
 	  {
 		Parameter [] args;
 		Parameter implicit_value_parameter = new Parameter (
@@ -1253,7 +1253,7 @@
 	  }
 	  accessor_body
 	  {
-		$$ = new Accessor ((Block) $4, (Attributes) $1, lexer.Location);
+		$$ = new Accessor ((Block) $5, (int) $2, (Attributes) $1, lexer.Location);
 		current_local_parameters = null;
 		lexer.PropertyParsing = true;
 	  }
@@ -1812,7 +1812,7 @@
 	  }
           block
 	  {
-		$$ = new Accessor ((Block) $4, (Attributes) $1, lexer.Location);
+		$$ = new Accessor ((Block) $4, (int) 0, (Attributes) $1, lexer.Location);
 		lexer.EventParsing = true;
 	  }
 	| opt_attributes ADD error {
@@ -1836,7 +1836,7 @@
 	  }
           block
 	  {
-		$$ = new Accessor ((Block) $4, (Attributes) $1, lexer.Location);
+		$$ = new Accessor ((Block) $4, (int) 0, (Attributes) $1, lexer.Location);
 		lexer.EventParsing = true;
 	  }
 	| opt_attributes REMOVE error {
@@ -4119,9 +4119,9 @@
                                       Attributes get_attrs, Attributes set_attrs, Location get_loc, Location set_loc)
         {
 		if (has_get)
-			Get = new Accessor (null, get_attrs, get_loc);
+			Get = new Accessor (null, 0, get_attrs, get_loc);
 		if (has_set)
-			Set = new Accessor (null, set_attrs, set_loc);
+			Set = new Accessor (null, 0, set_attrs, set_loc);
         }
 }
 
Index: ecore.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/ecore.cs,v
retrieving revision 1.312
diff -u -r1.312 ecore.cs
--- ecore.cs	11 Oct 2004 20:28:02 -0000	1.312
+++ ecore.cs	16 Oct 2004 02:42:00 -0000
@@ -3088,11 +3088,6 @@
 		{
 			FindAccessors (ec.ContainerType);
 
-			if (setter != null && !IsAccessorAccessible (ec.ContainerType, setter) ||
-				getter != null && !IsAccessorAccessible (ec.ContainerType, getter)) {
-				Report.Error (122, loc, "'{0}' is inaccessible due to its protection level", PropertyInfo.Name);
-			}
-
 			is_static = getter != null ? getter.IsStatic : setter.IsStatic;
 		}
 
@@ -3155,6 +3150,11 @@
 				return null;
 			} 
 
+			if (!IsAccessorAccessible (ec.ContainerType, getter)) {
+				Report.Error (122, loc, "'{0}.get' is inaccessible due to its protection level", PropertyInfo.Name);
+				return null;
+			}
+			
 			if (!InstanceResolve (ec))
 				return null;
 
@@ -3197,6 +3197,11 @@
 				return null;
 			}
 
+			if (!IsAccessorAccessible (ec.ContainerType, setter)) {
+				Report.Error (122, loc, "'{0}.set' is inaccessible due to its protection level", PropertyInfo.Name);
+				return null;
+			}
+			
 			if (!InstanceResolve (ec))
 				return null;
 			
Index: iterators.cs
===================================================================
RCS file: /cvs/public/mcs/mcs/iterators.cs,v
retrieving revision 1.37
diff -u -r1.37 iterators.cs
--- iterators.cs	13 Sep 2004 14:38:16 -0000	1.37
+++ iterators.cs	16 Oct 2004 02:42:00 -0000
@@ -591,7 +591,7 @@
 					new FieldExpression (current_field), Location),
 				Location));
 
-			Accessor getter = new Accessor (get_block, null, Location);
+			Accessor getter = new Accessor (get_block, 0, null, Location);
 
 			Property current = new Property (
 				this, iterator_type_expr, 0,
