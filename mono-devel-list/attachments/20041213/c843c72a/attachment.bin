Index: ChangeLog
===================================================================
--- ChangeLog	(revision 37698)
+++ ChangeLog	(working copy)
@@ -1,3 +1,11 @@
+2004-12-09  Dan Winship  <danw@novell.com>
+
+	* outline.cs (OutlineType, OutlineOperator, OperatorFromName):
+	Show overloaded operators and type conversions.
+	(FormatType): fix the logic here so that, eg "System.Int32"
+	becomes "int" rather than "Int32" when looking at a type in the
+	System namespace.
+
 2004-12-03  Atsushi Enomoto  <atsushi@ximian.com>
 
 	* monop.cs : csc build fix. See bug #70185 for details.
Index: outline.cs
===================================================================
--- outline.cs	(revision 37698)
+++ outline.cs	(working copy)
@@ -126,6 +126,21 @@
 		
 		first = true;
 		
+		foreach (MemberInfo mi in t.GetMembers (flags)) {
+			if (!(mi is MethodInfo) || !(mi.Name.StartsWith ("op_")))
+				continue;
+
+			if (first)
+				o.WriteLine ();
+			first = false;
+			
+			OutlineOperator ((MethodInfo)mi);
+			
+			o.WriteLine ();
+		}
+
+		first = true;
+		
 		foreach (PropertyInfo pi in Comparer.Sort (t.GetProperties (flags))) {
 			
 			if (first)
@@ -252,6 +267,24 @@
 		o.Write (");");
 	}
 	
+	void OutlineOperator (MethodInfo mi)
+	{
+		o.Write (GetMethodVisibility (mi));
+		o.Write (GetMethodModifiers  (mi));
+		if (mi.Name == "op_Explicit" || mi.Name == "op_Implicit") {
+			o.Write (mi.Name.Substring (3).ToLower ());
+			o.Write (" operator ");
+			o.Write (FormatType (mi.ReturnType));
+		} else {
+			o.Write (FormatType (mi.ReturnType));
+			o.Write (" operator ");
+			o.Write (OperatorFromName (mi.Name));
+		}
+		o.Write (" (");
+		OutlineParams (mi.GetParameters ());
+		o.Write (");");
+	}
+	
 	void OutlineParams (ParameterInfo [] pi)
 	{
 		int i = 0;
@@ -358,11 +391,11 @@
 	{
 		string type = t.FullName;
 		
-		if (t.Namespace == this.t.Namespace)
-			return t.Name;
-		
-		if (!type.StartsWith ("System."))
+		if (!type.StartsWith ("System.")) {
+			if (t.Namespace == this.t.Namespace)
+				return t.Name;
 			return type;
+		}
 		
 		if (t.HasElementType) {
 			Type et = t.GetElementType ();
@@ -401,6 +434,37 @@
 		
 		return type;
 	}
+
+	string OperatorFromName (string name)
+	{
+		switch (name) {
+		case "op_UnaryPlus": return "+";
+		case "op_UnaryNegation": return "-";
+		case "op_LogicalNot": return "!";
+		case "op_OnesComplement": return "~";
+		case "op_Increment": return "++";
+		case "op_Decrement": return "--";
+		case "op_True": return "true";
+		case "op_False": return "false";
+		case "op_Addition": return "+";
+		case "op_Subtraction": return "-";
+		case "op_Multiply": return "*";
+		case "op_Division": return "/";
+		case "op_Modulus": return "%";
+		case "op_BitwiseAnd": return "&";
+		case "op_BitwiseOr": return "|";
+		case "op_ExclusiveOr": return "^";
+		case "op_LeftShift": return "<<";
+		case "op_RightShift": return ">>";
+		case "op_Equality": return "==";
+		case "op_Inequality": return "!=";
+		case "op_GreaterThan": return ">";
+		case "op_LessThan": return "<";
+		case "op_GreaterThanOrEqual": return ">=";
+		case "op_LessThanOrEqual": return "<=";
+		default: return name;
+		}
+	}
 }
 
 public class Comparer : IComparer  {
