Index: mono/mono/metadata/class.c
===================================================================
--- mono/mono/metadata/class.c	(revision 70918)
+++ mono/mono/metadata/class.c	(working copy)
@@ -2743,6 +2743,7 @@
 	if (!MONO_CLASS_IS_INTERFACE (class)) {
 		/* Imported COM Objects always derive from __ComObject. */
 		if (MONO_CLASS_IS_IMPORT (class)) {
+			mono_init_com_types ();
 			if (parent == mono_defaults.object_class)
 				parent = mono_defaults.com_object_class;
 		}
Index: mono/mono/metadata/domain.c
===================================================================
--- mono/mono/metadata/domain.c	(revision 70918)
+++ mono/mono/metadata/domain.c	(working copy)
@@ -811,18 +811,16 @@
 	mono_defaults.internals_visible_class = mono_class_from_name (
 	        mono_defaults.corlib, "System.Runtime.CompilerServices", "InternalsVisibleToAttribute");
 
-	mono_defaults.variant_class = mono_class_from_name (
-	        mono_defaults.corlib, "System", "Variant");
-
-	mono_defaults.com_object_class = mono_class_from_name (
-	        mono_defaults.corlib, "System", "__ComObject");
-
-	mono_defaults.com_interop_proxy_class = mono_class_from_name (
-	        mono_defaults.corlib, "Mono.Interop", "ComInteropProxy");
-
 	mono_defaults.safehandle_class = mono_class_from_name (
 		mono_defaults.corlib, "System.Runtime.InteropServices", "SafeHandle");
 
+	/* these are initialized lazily when COM features are used */
+	mono_defaults.variant_class = NULL;
+	mono_defaults.com_object_class = NULL;
+	mono_defaults.com_interop_proxy_class = NULL;
+	mono_defaults.iunknown_class = NULL;
+	mono_defaults.idispatch_class = NULL;
+
 	/*
 	 * Note that mono_defaults.generic_*_class is only non-NULL if we're
 	 * using the 2.0 corlib.
@@ -889,6 +887,46 @@
 }
 
 /**
+ * mono_init_com_types:
+ *
+ * Initializes all types needed for COM Interop in mono_defaults structure. 
+ */
+void 
+mono_init_com_types (void)
+{
+	static gboolean initialized = FALSE;
+
+	if (initialized)
+		return;
+	
+	/* FIXME: do I need some threading protection here */
+
+	g_assert (mono_defaults.corlib);
+
+	mono_defaults.variant_class = mono_class_from_name (
+	        mono_defaults.corlib, "System", "Variant");
+	g_assert (mono_defaults.variant_class != 0);
+
+	mono_defaults.com_object_class = mono_class_from_name (
+	        mono_defaults.corlib, "System", "__ComObject");
+	g_assert (mono_defaults.com_object_class != 0);
+
+	mono_defaults.com_interop_proxy_class = mono_class_from_name (
+	        mono_defaults.corlib, "Mono.Interop", "ComInteropProxy");
+	g_assert (mono_defaults.com_interop_proxy_class != 0);
+
+	mono_defaults.iunknown_class = mono_class_from_name (
+	        mono_defaults.corlib, "Mono.Interop", "IUnknown");
+	g_assert (mono_defaults.iunknown_class != 0);
+
+	mono_defaults.idispatch_class = mono_class_from_name (
+	        mono_defaults.corlib, "Mono.Interop", "IDispatch");
+	g_assert (mono_defaults.idispatch_class != 0);
+
+	initialized = TRUE;
+}
+
+/**
  * mono_cleanup:
  *
  * Cleans up all metadata modules. 
Index: mono/mono/metadata/ChangeLog
===================================================================
--- mono/mono/metadata/ChangeLog	(revision 70918)
+++ mono/mono/metadata/ChangeLog	(working copy)
@@ -1,3 +1,14 @@
+2007-01-12  Jonathan Chambers  <joncham@gmail.com>
+
+	* domain.c, domain-internals.h (mono_init_com_types): Add
+	mono_init_com_types function for lazy COM initialization.
+	* class-internals.h: Added iunknown_class and idispatch_class
+	to MonoDefaults struct.
+	* class.c, object.c, marshal.c: Support lazy COM initialization
+	and rename COM wrappers to something that makes sense.
+	* mini.c: Rename COM wrappers to something that makes sense.
+	* wrapper-types.h: Rename COM wrappers to something that makes sense.
+
 2007-01-12  Raja R Harinath  <rharinath@novell.com>
 
 	* class-internals.h (_MonoGenericParam.method): Move ...
Index: mono/mono/metadata/object.c
===================================================================
--- mono/mono/metadata/object.c	(revision 70918)
+++ mono/mono/metadata/object.c	(working copy)
@@ -1493,7 +1493,7 @@
 		MonoClass *klass;
 		type = ((MonoReflectionType *)rp->class_to_proxy)->type;
 		klass = mono_class_from_mono_type (type);
-		if ((klass->is_com_object || klass == mono_defaults.com_object_class) && !mono_class_vtable (mono_domain_get (), klass)->remote)
+		if ((klass->is_com_object || (mono_defaults.com_object_class && klass == mono_defaults.com_object_class)) && !mono_class_vtable (mono_domain_get (), klass)->remote)
 			remote_class->default_vtable = mono_class_proxy_vtable (domain, remote_class, MONO_REMOTING_TARGET_COMINTEROP);
 		else
 			remote_class->default_vtable = mono_class_proxy_vtable (domain, remote_class, MONO_REMOTING_TARGET_UNKNOWN);
Index: mono/mono/metadata/class-internals.h
===================================================================
--- mono/mono/metadata/class-internals.h	(revision 70918)
+++ mono/mono/metadata/class-internals.h	(working copy)
@@ -686,6 +686,8 @@
 	MonoClass *variant_class;
 	MonoClass *com_object_class;
 	MonoClass *com_interop_proxy_class;
+	MonoClass *iunknown_class;
+	MonoClass *idispatch_class;
 	MonoClass *safehandle_class;
 } MonoDefaults;
 
Index: mono/mono/metadata/domain-internals.h
===================================================================
--- mono/mono/metadata/domain-internals.h	(revision 70918)
+++ mono/mono/metadata/domain-internals.h	(working copy)
@@ -161,6 +161,9 @@
 #define mono_domain_assemblies_unlock(domain) LeaveCriticalSection(&(domain)->assemblies_lock)
 
 void 
+mono_init_com_types (void) MONO_INTERNAL;
+
+void 
 mono_cleanup (void) MONO_INTERNAL;
 
 void
Index: mono/mono/metadata/marshal.c
===================================================================
--- mono/mono/metadata/marshal.c	(revision 70918)
+++ mono/mono/metadata/marshal.c	(working copy)
@@ -293,6 +293,9 @@
 {
 	MonoClass *klass = NULL;
 	MonoRealProxy* real_proxy = NULL;
+
+	mono_init_com_types ();
+
 	if (!obj)
 		return FALSE;
 	klass = mono_object_class (obj);
@@ -1823,8 +1826,12 @@
 		static MonoMethod* get_transparent_proxy = NULL;
 		int real_proxy;
 		guint32 pos_failed = 0;
-		MonoClass *klass = mono_class_from_mono_type (type);
+		MonoClass *klass = NULL;
+		
+		mono_init_com_types ();
 
+		klass = mono_class_from_mono_type (type);
+
 		mono_mb_emit_ldloc (mb, 1);
 		mono_mb_emit_byte (mb, CEE_LDNULL);
 		mono_mb_emit_byte (mb, CEE_STIND_REF);
@@ -2146,6 +2153,8 @@
 		guint32 pos_failed = 0, pos_rcw = 0;
 		char * msg;
 
+		mono_init_com_types ();
+
 		mono_mb_emit_ldloc (mb, 1);
 		//mono_mb_emit_ldloc (mb, 0);
 		mono_mb_emit_ptr (mb, 0);
@@ -2392,6 +2401,7 @@
 				break;
 			}
 			case MONO_TYPE_OBJECT: {
+				mono_init_com_types ();
 				if (to_object) {
 					static MonoMethod *variant_clear = NULL;
 					static MonoMethod *get_object_for_native_variant = NULL;
@@ -3162,7 +3172,7 @@
 	sig = mono_method_signature (method);
 
 	// create unmanaged wrapper
-	mb_native = mono_mb_new (method->klass, method->name, MONO_WRAPPER_MANAGED_TO_NATIVE);
+	mb_native = mono_mb_new (method->klass, method->name, MONO_WRAPPER_RCW);
 	sig_native = signature_cominterop (method->klass->image, sig);
 
 	mspecs = g_new (MonoMarshalSpec*, sig_native->param_count+1);
@@ -3221,8 +3231,10 @@
 	if ((res = mono_marshal_find_in_cache (cache, method)))
 		return res;
 
+	mono_init_com_types ();
+
 	sig = mono_method_signature (method);
-	mb = mono_mb_new (method->klass, method->name, MONO_WRAPPER_COMINTEROP);
+	mb = mono_mb_new (method->klass, method->name, MONO_WRAPPER_RCW_ADJUST);
 
 	/* if method klass is import, that means method
 	 * is really a com call. let interop system emit it.
@@ -3331,13 +3343,15 @@
 	if ((res = mono_marshal_find_in_cache (cache, method)))
 		return res;
 
+	mono_init_com_types ();
+
 	sig = signature_no_pinvoke (method);
 
 	/* we cant remote methods without this pointer */
 	if (!sig->hasthis)
 		return method;
 
-	mb = mono_mb_new (method->klass, method->name, MONO_WRAPPER_COMINTEROP_INVOKE);
+	mb = mono_mb_new (method->klass, method->name, MONO_WRAPPER_RCW_INVOKE);
 
 	/* get real proxy object, which is a ComInteropProxy in this case*/
 	temp_obj = mono_mb_add_local (mb, &mono_defaults.object_class->byval_arg);
@@ -3403,7 +3417,7 @@
 		return method;
 
 	/* this seems to be the best plase to put this, as all remoting invokes seem to get filtered through here */
-	if ((method->klass->is_com_object || method->klass == mono_defaults.com_object_class) && !mono_class_vtable (mono_domain_get (), method->klass)->remote)
+	if ((method->klass->is_com_object || (mono_defaults.com_object_class && method->klass == mono_defaults.com_object_class)) && !mono_class_vtable (mono_domain_get (), method->klass)->remote)
 		return cominterop_get_invoke(method);
 
 	sig = signature_no_pinvoke (method);
@@ -6621,6 +6635,8 @@
 	MonoMethodBuilder *mb = m->mb;
 	MonoClass *klass = t->data.klass;
 
+	mono_init_com_types ();
+
 	switch (action) {
 	case MARSHAL_ACTION_CONV_IN: {
 		*conv_arg_type = &mono_defaults.int_class->byval_arg;
@@ -6792,6 +6808,8 @@
 	static MonoMethod *get_object_for_native_variant = NULL;
 	static MonoMethod *get_native_variant_for_object = NULL;
 	
+	mono_init_com_types ();
+
 	if (!get_object_for_native_variant)
 		get_object_for_native_variant = mono_class_get_method_from_name (mono_defaults.marshal_class, "GetObjectForNativeVariant", 1);
 	g_assert (get_object_for_native_variant);
Index: mono/mono/metadata/wrapper-types.h
===================================================================
--- mono/mono/metadata/wrapper-types.h	(revision 70918)
+++ mono/mono/metadata/wrapper-types.h	(working copy)
@@ -24,5 +24,8 @@
 WRAPPER(LDFLDA, "ldflda")
 WRAPPER(WRITE_BARRIER, "write-barrier")
 WRAPPER(UNKNOWN, "unknown")
-WRAPPER(COMINTEROP_INVOKE, "cominterop-invoke")
-WRAPPER(COMINTEROP, "cominterop")
+WRAPPER(RCW, "runtime-callable-wrapper")
+WRAPPER(RCW_ADJUST, "runtime-callable-wrapper-adjust")
+WRAPPER(RCW_INVOKE, "runtime-callable-wrapper-invoke")
+WRAPPER(CCW, "com-callable-wrapper")
+WRAPPER(CCW_ADJUST, "com-callable-wrapper-adjust")
Index: mono/mono/mini/mini.c
===================================================================
--- mono/mono/mini/mini.c	(revision 70918)
+++ mono/mono/mini/mini.c	(working copy)
@@ -3810,8 +3810,9 @@
 	dont_verify |= method->wrapper_type == MONO_WRAPPER_XDOMAIN_INVOKE;
 	dont_verify |= method->wrapper_type == MONO_WRAPPER_XDOMAIN_DISPATCH;
 	dont_verify |= method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE; /* bug #77896 */
-	dont_verify |= method->wrapper_type == MONO_WRAPPER_COMINTEROP;
-	dont_verify |= method->wrapper_type == MONO_WRAPPER_COMINTEROP_INVOKE;
+	dont_verify |= method->wrapper_type == MONO_WRAPPER_RCW_ADJUST;
+	dont_verify |= method->wrapper_type == MONO_WRAPPER_RCW_INVOKE;
+	dont_verify |= method->wrapper_type == MONO_WRAPPER_RCW;
 
 	/* still some type unsafety issues in marshal wrappers... (unknown is PtrToStructure) */
 	dont_verify_stloc = method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE;