Index: security-core-clr.c
===================================================================
--- security-core-clr.c	(revision 130114)
+++ security-core-clr.c	(working copy)
@@ -113,6 +113,30 @@
 	return m;
 }
 
+/*
+ * check_field_access:
+ *
+ *	Return TRUE if the caller method can access the specified field, FALSE otherwise.
+ */
+static gboolean
+check_field_access (MonoMethod *caller, MonoClassField *field)
+{
+	MonoClass *klass = (mono_field_get_flags (field) & FIELD_ATTRIBUTE_STATIC) ? NULL : mono_field_get_parent (field);
+	return mono_method_can_access_field_full (caller, field, klass);
+}
+
+/*
+ * check_method_access:
+ *
+ *	Return TRUE if the caller method can access the specified callee method, FALSE otherwise.
+ */
+static gboolean
+check_method_access (MonoMethod *caller, MonoMethod *callee)
+{
+	MonoClass *klass = (callee->flags & METHOD_ATTRIBUTE_STATIC) ? NULL : callee->klass;
+	return mono_method_can_access_method_full (caller, callee, klass);
+}
+
 void
 mono_security_core_clr_ensure_reflection_access_field (MonoClassField *field)
 {
@@ -148,6 +172,41 @@
 		mono_raise_exception (mono_get_exception_method_access ());
 }
 
+/*
+ * mono_security_core_clr_ensure_dynamic_method_resolved_object:
+ *
+ *	Called from mono_reflection_create_dynamic_method (reflection.c) to add some extra checks required for CoreCLR.
+ *	Dynamic methods needs to check to see if the objects being used (e.g. methods, fields) comes from platform code
+ *	and do an accessibility check in this case. Otherwise (i.e. user/application code) can be used without this extra
+ *	accessbility check.
+ */
+MonoException*
+mono_security_core_clr_ensure_dynamic_method_resolved_object (gpointer ref, MonoClass *handle_class)
+{
+	/* XXX find/create test cases for other handle_class XXX */
+	if (handle_class == mono_defaults.fieldhandle_class) {
+		MonoClassField *field = (MonoClassField*) ref;
+		MonoClass *klass = mono_field_get_parent (field);
+		/* fields coming from platform code have extra protection (accessibility check) */
+		if (mono_security_core_clr_is_platform_image (klass->image)) {
+			MonoMethod *caller = get_reflection_caller ();
+			/* XXX Critical code probably can do this / need some test cases (safer off otherwise) XXX */
+			if (!check_field_access (caller, field))
+				return mono_get_exception_field_access ();
+		}
+	} else if (handle_class == mono_defaults.methodhandle_class) {
+		MonoMethod *method = (MonoMethod*) ref;
+		/* methods coming from platform code have extra protection (accessibility check) */
+		if (mono_security_core_clr_is_platform_image (method->klass->image)) {
+			MonoMethod *caller = get_reflection_caller ();
+			/* XXX Critical code probably can do this / need some test cases (safer off otherwise) XXX */
+			if (!check_method_access (caller, method))
+				return mono_get_exception_method_access ();
+		}
+	}
+	return NULL;
+}
+
 static MonoSecurityCoreCLRLevel
 mono_security_core_clr_level_from_cinfo (MonoCustomAttrInfo *cinfo, MonoImage *image)
 {
Index: security-core-clr.h
===================================================================
--- security-core-clr.h	(revision 130114)
+++ security-core-clr.h	(working copy)
@@ -24,6 +24,7 @@
 
 extern void mono_security_core_clr_ensure_reflection_access_field (MonoClassField *field) MONO_INTERNAL;
 extern void mono_security_core_clr_ensure_reflection_access_method (MonoMethod *method) MONO_INTERNAL;
+extern MonoException* mono_security_core_clr_ensure_dynamic_method_resolved_object (gpointer ref, MonoClass *handle_class) MONO_INTERNAL;
 
 extern MonoSecurityCoreCLRLevel mono_security_core_clr_class_level (MonoClass *class) MONO_INTERNAL;
 extern MonoSecurityCoreCLRLevel mono_security_core_clr_method_level (MonoMethod *method, gboolean with_class_level) MONO_INTERNAL;
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 130114)
+++ ChangeLog	(working copy)
@@ -1,3 +1,11 @@
+2009-03-24  Sebastien Pouliot  <sebastien@ximian.com> 
+
+	* reflection.c (mono_reflection_create_dynamic_method): when 
+	coreclr is enabled make sure that every resolved object are
+	checked (e.g. field and method access).
+	* security-core-clr.c|h: Add function to check objects resolved
+	when a dynamic method is created.
+
 2009-03-23  Zoltan Varga  <vargaz@gmail.com>
 
 	* marshal.c (mono_delegate_to_ftnptr): For delegates wrapping pinvoke
Index: reflection.c
===================================================================
--- reflection.c	(revision 130114)
+++ reflection.c	(working copy)
@@ -36,6 +36,7 @@
 #include "mono-endian.h"
 #include <mono/metadata/gc-internal.h>
 #include <mono/metadata/mempool-internals.h>
+#include <mono/metadata/security-core-clr.h>
 
 #if HAVE_SGEN_GC
 static void* reflection_info_desc = NULL;
@@ -10514,10 +10515,16 @@
 			}
 			handle_class = mono_defaults.methodhandle_class;
 		} else {
+			MonoException *ex = NULL;
 			ref = resolve_object (mb->module->image, obj, &handle_class, NULL);
-			if (!ref) {
+			if (!ref)
+				ex = mono_get_exception_type_load (NULL, NULL);
+			else if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)
+				ex = mono_security_core_clr_ensure_dynamic_method_resolved_object (ref, handle_class);
+
+			if (ex) {
 				g_free (rmb.refs);
-				mono_raise_exception (mono_get_exception_type_load (NULL, NULL));
+				mono_raise_exception (ex);
 				return;
 			}
 		}
