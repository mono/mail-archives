diff -Nurd mono-cvs/mcs/class/System/list.unix mono-ipv6/mcs/class/System/list.unix
--- mono-cvs/mcs/class/System/list.unix	2003-06-23 18:31:40.000000000 +0200
+++ mono-ipv6/mcs/class/System/list.unix	2003-06-30 22:18:36.000000000 +0200
@@ -396,6 +396,7 @@
 System.Net.Configuration/ConnectionManagementHandler.cs
 System.Net.Configuration/DefaultProxyHandler.cs
 System.Net.Configuration/NetAuthenticationModuleHandler.cs
+System.Net.Configuration/NetConfigurationHandler.cs
 System.Net.Configuration/WebRequestModuleHandler.cs
 System.Net/CookieCollection.cs
 System.Net/CookieContainer.cs
@@ -427,6 +428,7 @@
 System.Net/IWebProxy.cs
 System.Net/IWebRequestCreate.cs
 System.Net/MonoHttpDate.cs
+System.Net/NetConfig.cs
 System.Net/NetworkAccess.cs
 System.Net/NetworkCredential.cs
 System.Net/ProtocolViolationException.cs
@@ -439,6 +441,7 @@
 System.Net.Sockets/AddressFamily.cs
 System.Net.Sockets/LingerOption.cs
 System.Net.Sockets/MulticastOption.cs
+System.Net.Sockets/IPv6MulticastOption.cs
 System.Net.Sockets/NetworkStream.cs
 System.Net.Sockets/ProtocolFamily.cs
 System.Net.Sockets/ProtocolType.cs
diff -Nurd mono-cvs/mcs/class/System/System.Net/Dns.cs mono-ipv6/mcs/class/System/System.Net/Dns.cs
--- mono-cvs/mcs/class/System/System.Net/Dns.cs	2003-05-23 13:07:21.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net/Dns.cs	2003-06-30 22:18:36.000000000 +0200
@@ -16,7 +16,11 @@
 namespace System.Net {
         public sealed class Dns {
 
-		private Dns () {}
+			private Dns () {}
+			static Dns ()
+			{
+				System.Net.Sockets.Socket.CheckProtocolSupport();
+			}
 
                 private delegate IPHostEntry GetHostByNameCallback (string hostName);
                 private delegate IPHostEntry ResolveCallback (string hostName);
@@ -68,16 +72,23 @@
 		
                 private static IPHostEntry hostent_to_IPHostEntry(string h_name, string[] h_aliases, string[] h_addrlist) {
                         IPHostEntry he = new IPHostEntry();
-                        IPAddress[] addrlist = new IPAddress[h_addrlist.Length];
-                        
-                        he.HostName=h_name;
+						ArrayList addrlist = new ArrayList();
+
+						he.HostName=h_name;
                         he.Aliases=h_aliases;
                         for(int i=0; i<h_addrlist.Length; i++) {
-                                addrlist[i]=IPAddress.Parse(h_addrlist[i]);
+							IPAddress newAddress = IPAddress.Parse(h_addrlist[i]);
+
+							if( (Socket.SupportsIPv6 && newAddress.AddressFamily == AddressFamily.InterNetworkV6) ||
+								(Socket.SupportsIPv4 && newAddress.AddressFamily == AddressFamily.InterNetwork) )
+                                addrlist.Add(newAddress);
                         }
-                        he.AddressList=addrlist;
 
-                        return(he);
+						if(addrlist.Count == 0)
+							throw new SocketException(11001);
+
+                        he.AddressList = addrlist.ToArray(typeof(IPAddress)) as IPAddress[];
+                        return he;
                 }
 
                 public static IPHostEntry GetHostByAddress(IPAddress address) {
@@ -96,6 +107,10 @@
 						if (address.Equals ("0.0.0.0"))
 							return GetHostByAddress ("127.0.0.1");
 
+						/// Must check the IP format, might send an exception if 
+						/// invalid string.
+						IPAddress.Parse(address);
+
                         string h_name;
                         string[] h_aliases, h_addrlist;
                         
@@ -135,8 +150,8 @@
                         
                         bool ret = GetHostName_internal(out hostName);
                         
-			if (ret == false)
-                                throw new SocketException(11001);
+						if (ret == false)
+							throw new SocketException(11001);
 
                         return hostName;
                 }
@@ -153,7 +168,18 @@
                         if (hostName == null)
                                 throw new ArgumentNullException();
 
-			return GetHostByName (hostName);
+					IPHostEntry ret;
+
+					try {
+						ret =  GetHostByAddress(hostName);
+					}
+					catch{}
+
+					if(ret == null) {
+						ret =  GetHostByName(hostName);
+					}
+
+					return ret;
                 }
         }
 }
diff -Nurd mono-cvs/mcs/class/System/System.Net/IPAddress.cs mono-ipv6/mcs/class/System/System.Net/IPAddress.cs
--- mono-cvs/mcs/class/System/System.Net/IPAddress.cs	2002-05-09 12:43:34.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net/IPAddress.cs	2003-06-30 22:18:36.000000000 +0200
@@ -25,12 +25,19 @@
 		// Don't change the name of this field without also
 		// changing socket-io.c in the runtime
 		private long address;
+		private AddressFamily _family = AddressFamily.InterNetwork;
+		private ushort[] _numbers = new ushort[8];	/// ip6 Stored in network order (as ip4)
+		private long _scopeId = 0;
 
 		public static readonly IPAddress Any = new IPAddress(0);
 		public static readonly IPAddress Broadcast = IPAddress.Parse ("255.255.255.255");
 		public static readonly IPAddress Loopback = IPAddress.Parse ("127.0.0.1");
 		public static readonly IPAddress None = IPAddress.Parse ("255.255.255.255");
 
+		public static readonly IPAddress IPv6Any = IPAddress.Parse ("::");
+		public static readonly IPAddress IPv6Loopback = IPAddress.Parse ("::1");
+		public static readonly IPAddress IPv6None = IPAddress.Parse ("::");
+
 		private static short SwapShort (short number)
 		{
 			return (short) ( ((number >> 8) & 0xFF) + ((number << 8) & 0xFF00) );
@@ -106,14 +113,50 @@
 		/// </summary>
 		public IPAddress (long addr)
 		{
-			Address = addr;
+			address = addr;
+		}
+
+		public IPAddress(byte[] address) : this(address, 0)
+		{
+		}
+
+		public IPAddress(byte[] address, long scopeId)
+		{
+			if(address.Length != 16)
+				throw new ArgumentException("address");
+
+			Buffer.BlockCopy(address, 0, _numbers, 0, 16);
+			_family = AddressFamily.InterNetworkV6;
+			_scopeId = scopeId;
+		}
+
+		internal IPAddress(ushort[] address, long scopeId)
+		{
+			_numbers = address;
+
+			for(int i=0; i<8; i++)
+				_numbers[i] = (ushort)HostToNetworkOrder((short)_numbers[i]);
+
+			_family = AddressFamily.InterNetworkV6;
+			_scopeId = scopeId;
 		}
 
 		public static IPAddress Parse (string ip)
 		{
+			IPAddress ret;
+
 			if (ip == null)
-				throw new ArgumentNullException ("null ip string");
+				throw new ArgumentNullException ("Value cannot be null.");
 				
+			if( (ret = ParseIPV4(ip)) == null)
+				if( (ret = ParseIPV6(ip)) == null)
+					throw new FormatException("An invalid IP address was specified.");
+
+			return ret;
+		}
+
+		private static IPAddress ParseIPV4 (string ip)
+		{
 			if (ip.Length == 0 || ip [0] == ' ')
 				return new IPAddress (0);
 				
@@ -121,14 +164,15 @@
 			if (pos != -1)
 				ip = ip.Substring (0, pos);				
 			else if (ip [ip.Length - 1] == '.')
-				throw new FormatException ("An invalid IP address was specified");
+				return null;
 
 			string [] ips = ip.Split (new char [] {'.'});
 			if (ips.Length > 4)
-				throw new FormatException ("An invalid IP address was specified");
+				return null;
 			
 			// Make the number in network order
-			try {
+			try 
+			{
 				long a = 0;
 				byte val = 0;
 				for (int i = 0; i < ips.Length; i++) {
@@ -153,12 +197,28 @@
 
 				return (new IPAddress (a));
 			} catch (Exception) {
-				throw new FormatException ("An invalid IP address was specified");
-			}
+				return null;
+			}
 		}
 		
+		private static IPAddress ParseIPV6 (string ip)
+		{
+			try 
+			{
+				IPv6Address newIPv6Address = IPv6Address.Parse(ip);
+				return new IPAddress(newIPv6Address.Address, newIPv6Address.ScopeId);
+			}
+			catch(Exception e) {
+				return null;
+			}
+		}
+
+		[Obsolete]
 		public long Address {
 			get {
+				if(_family != AddressFamily.InterNetwork)
+					throw new Exception("The attempted operation is not supported for the type of object referenced");
+
 				return address;
 			}
 			set {
@@ -168,13 +228,48 @@
 						"the address must be between 0 and 0xFFFFFFFF");
 				*/
 
+				if(_family != AddressFamily.InterNetwork)
+					throw new Exception("The attempted operation is not supported for the type of object referenced");
+
 				address = value;
 			}
 		}
 
+		public long ScopeId {
+			get {
+				if(_family != AddressFamily.InterNetworkV6)
+					throw new Exception("The attempted operation is not supported for the type of object referenced");
+
+				return _scopeId;
+			}
+			set {
+				if(_family != AddressFamily.InterNetworkV6)
+					throw new Exception("The attempted operation is not supported for the type of object referenced");
+
+				_scopeId = value;
+			}
+		}
+
+		public byte[] GetAddressBytes() {
+
+			if(_family == AddressFamily.InterNetworkV6)
+			{
+				byte[] addressBytes = new byte[16];
+				Buffer.BlockCopy(_numbers, 0, addressBytes, 0, 16);
+				return addressBytes;
+			}
+			else
+			{
+				return new byte[4] { (byte)(address & 0xFF),
+									   (byte)((address >> 8) & 0xFF),
+									   (byte)((address >> 16) & 0xFF),
+									   (byte)(address >> 24) }; 
+			}
+		}
+
 		public AddressFamily AddressFamily {
 			get {
-				return(AddressFamily.InterNetwork);
+				return _family;
 			}
 		}
 		
@@ -188,7 +283,16 @@
 		/// <returns></returns>
 		public static bool IsLoopback (IPAddress addr)
 		{
-			return (addr.address & 0xFF) == 127;
+			if(addr._family == AddressFamily.InterNetwork)
+				return (addr.address & 0xFF) == 127;
+			else {
+				for(int i=0; i<6; i++) {
+					if(addr._numbers[i] != 0)
+						return false;
+				}
+
+				return NetworkToHostOrder((short)addr._numbers[7]) == 1;
+			}
 		}
 
 		/// <summary>
@@ -197,7 +301,17 @@
 		/// </summary>
 		public override string ToString ()
 		{
-			return ToString (address);
+			if(_family == AddressFamily.InterNetwork)
+				return ToString (address);
+			else
+			{
+				ushort[] numbers = _numbers.Clone() as ushort[];
+
+				for(int i=0; i<numbers.Length; i++)
+					numbers[i] = (ushort)NetworkToHostOrder((short)numbers[i]);
+
+				return new IPv6Address(numbers).ToString();
+			}
 		}
 
 		/// <summary>
@@ -218,14 +332,41 @@
 		public override bool Equals (object other)
 		{
 			if (other is System.Net.IPAddress){
-				return Address == ((System.Net.IPAddress) other).Address;
+				IPAddress otherAddr = other as IPAddress;
+
+				if(AddressFamily != otherAddr.AddressFamily)
+					return false;
+
+				if(AddressFamily == AddressFamily.InterNetwork)
+					return Address == otherAddr.Address;
+				else
+				{
+					ushort[] vals = otherAddr._numbers;
+
+					for(int i=0; i<8; i++)
+						if(_numbers[i] != vals[i])
+							return false;
+
+					return true;
+				}
 			}
 			return false;
 		}
 
 		public override int GetHashCode ()
 		{
-			return (int)Address;
+			if(_family == AddressFamily.InterNetwork)
+				return (int)Address;
+			else
+				return Hash (((((int) _numbers[0]) << 16) + _numbers [1]), 
+					((((int) _numbers [2]) << 16) + _numbers [3]),
+					((((int) _numbers [4]) << 16) + _numbers [5]),
+					((((int) _numbers [6]) << 16) + _numbers [7]));
 		}
+
+		private static int Hash (int i, int j, int k, int l) 
+		{
+			return i ^ (j << 13 | j >> 19) ^ (k << 26 | k >> 6) ^ (l << 7 | l >> 25);
+		}
 	}
 }
diff -Nurd mono-cvs/mcs/class/System/System.Net/IPEndPoint.cs mono-ipv6/mcs/class/System/System.Net/IPEndPoint.cs
--- mono-cvs/mcs/class/System/System.Net/IPEndPoint.cs	2002-05-19 00:10:39.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net/IPEndPoint.cs	2003-06-30 22:18:37.000000000 +0200
@@ -43,7 +43,7 @@
 
 		public override AddressFamily AddressFamily {
 			get {
-				return AddressFamily.InterNetwork;
+				return address.AddressFamily;
 			}
 		}
 
@@ -74,38 +74,88 @@
 				// port and address
 				return(null);
 			}
+
 			AddressFamily family=(AddressFamily)sockaddr[0];
-			if(family!=AddressFamily.InterNetwork) {
-				return(null);
+			int port;
+
+			IPEndPoint ipe = null;
+			switch(family)
+			{
+				case AddressFamily.InterNetwork:
+					port = (((int)sockaddr[2])<<8) + (int)sockaddr[3];
+					long address=(((long)sockaddr[7])<<24) +
+						(((long)sockaddr[6])<<16) +
+						(((long)sockaddr[5])<<8) +
+						(long)sockaddr[4];
+
+					ipe = new IPEndPoint(address, port);
+					break;
+				case AddressFamily.InterNetworkV6:
+					port	= (((int)sockaddr[2])<<8) + (int)sockaddr[3];
+
+					/// maybe flowid ?
+					int unknown	= (int)sockaddr[4] +
+						(((int)sockaddr[5])<<8) +
+						(((int)sockaddr[6])<<16) +
+						(((int)sockaddr[7])<<24);
+
+					int scopeId	= (int)sockaddr[24] +
+						(((int)sockaddr[25])<<8) +
+						(((int)sockaddr[26])<<16) +
+						(((int)sockaddr[27])<<24);
+
+					ushort[] addressData = new ushort[8];
+					for(int i=0; i<8; i++)
+						addressData[i] = (ushort)((sockaddr[8+i*2] << 8) + sockaddr[8+i*2+1]);
+
+					ipe = new IPEndPoint (new IPAddress(addressData, scopeId), port);
+					break;
+				default:
+					return null;
 			}
-			
-			int port=(((int)sockaddr[2])<<8) + (int)sockaddr[3];
-			long address=(((long)sockaddr[7])<<24) +
-				(((long)sockaddr[6])<<16) +
-				(((long)sockaddr[5])<<8) +
-				(long)sockaddr[4];
 
-			IPEndPoint ipe = new IPEndPoint(address, port);
-			
 			return(ipe);
 		}
 
 		public override SocketAddress Serialize() {
-			// .net produces a 16 byte buffer, even though
-			// only 8 bytes are used. I guess its just a
-			// holdover from struct sockaddr padding.
-			SocketAddress sockaddr = new SocketAddress(AddressFamily.InterNetwork, 16);
+			SocketAddress sockaddr;
 
-			// bytes 2 and 3 store the port, the rest
-			// stores the address
-			sockaddr [2] = (byte) ((port>>8) & 0xff);
-			sockaddr [3] = (byte) (port & 0xff);
+			switch (address.AddressFamily)
+			{
+				case AddressFamily.InterNetwork:
+					// .net produces a 16 byte buffer, even though
+					// only 8 bytes are used. I guess its just a
+					// holdover from struct sockaddr padding.
+					sockaddr = new SocketAddress(AddressFamily.InterNetwork, 16);
+
+					// bytes 2 and 3 store the port, the rest
+					// stores the address
+					sockaddr [2] = (byte) ((port>>8) & 0xff);
+					sockaddr [3] = (byte) (port & 0xff);
+
+					sockaddr [4] = (byte) (address.Address & 0xff);
+					sockaddr [5] = (byte) ((address.Address >> 8) & 0xff);
+					sockaddr [6] = (byte) ((address.Address >> 16) & 0xff);
+					sockaddr [7] = (byte) ((address.Address >> 24) & 0xff);
+					break;
+
+				case AddressFamily.InterNetworkV6:
+					sockaddr = new SocketAddress(AddressFamily.InterNetworkV6, 28);
+
+					sockaddr [2] = (byte) ((port>>8) & 0xff);
+					sockaddr [3] = (byte) (port & 0xff);
+
+					byte[] addressBytes = address.GetAddressBytes();
+					for(int i=0; i<16; i++)
+						sockaddr[8+i] = addressBytes[i];
+					
+					sockaddr [24] = (byte) (address.ScopeId & 0xff);
+					sockaddr [25] = (byte) ((address.ScopeId >> 8) & 0xff);
+					sockaddr [26] = (byte) ((address.ScopeId >> 16) & 0xff);
+					sockaddr [27] = (byte) ((address.ScopeId >> 24) & 0xff);
+					break;
+			}
 
-			sockaddr [4] = (byte) (address.Address & 0xff);
-			sockaddr [5] = (byte) ((address.Address >> 8) & 0xff);
-			sockaddr [6] = (byte) ((address.Address >> 16) & 0xff);
-			sockaddr [7] = (byte) ((address.Address >> 24) & 0xff);
-			
 			return(sockaddr);
 		}
 
diff -Nurd mono-cvs/mcs/class/System/System.Net/IPv6Address.cs mono-ipv6/mcs/class/System/System.Net/IPv6Address.cs
--- mono-cvs/mcs/class/System/System.Net/IPv6Address.cs	2002-05-05 08:51:38.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net/IPv6Address.cs	2003-06-30 22:18:37.000000000 +0200
@@ -27,6 +27,7 @@
 	public class IPv6Address {
 		private ushort [] address;
 		private int prefixLength;
+		private long scopeId = 0;
 
 		public static readonly IPv6Address Loopback = IPv6Address.Parse ("::1");
 		public static readonly IPv6Address Unspecified = IPv6Address.Parse ("::");
@@ -49,6 +50,11 @@
 			if (prefixLength < 0 || prefixLength > 128)
 				throw new ArgumentException ("prefixLength");
 			this.prefixLength = prefixLength;
+		}	
+	
+		public IPv6Address (ushort [] addr, int prefixLength, int scopeId) : this (addr, prefixLength)
+		{
+            this.scopeId = scopeId;
 		}		
 		
 		public static IPv6Address Parse (string ipString)
@@ -65,6 +71,7 @@
 				throw new FormatException ("Not a valid IPv6 address");
 
 			int prefixLen = 0;
+			int scopeId = 0;
 			int pos = ipString.LastIndexOf ('/');
 			if (pos != -1) {
 				string prefix = ipString.Substring (pos + 1);
@@ -74,8 +81,20 @@
 					prefixLen = -1;
 				}
 				if (prefixLen < 0 || prefixLen > 128)
-					throw new FormatException ("Not a valid prefix length");;
+					throw new FormatException ("Not a valid prefix length");
 				ipString = ipString.Substring (0, pos);
+			} else {
+				pos = ipString.LastIndexOf ('%');
+				if (pos != -1) {
+					string prefix = ipString.Substring (pos + 1);
+					try  {
+						scopeId = Int32.Parse (prefix);
+					} 
+					catch (Exception) {
+						scopeId = 0;
+					}
+					ipString = ipString.Substring (0, pos);
+				}			
 			}
 			
 			ushort [] addr = new ushort [8];			
@@ -164,7 +183,7 @@
 					throw new FormatException ("Not a valid IPv6 address");
 			}
 			
-			return new IPv6Address (addr, prefixLen);
+			return new IPv6Address (addr, prefixLen, scopeId);
 		}
 		
 		public ushort [] Address {
@@ -175,6 +194,15 @@
 			get { return this.prefixLength; }
 		}
 		
+		public long ScopeId {
+			get {
+				return scopeId;
+			}
+			set {
+				scopeId = value;
+			}
+		}
+
 		public ushort this [int index] {
 			get { return address [index]; }
 		}		
@@ -204,8 +232,8 @@
 		{
 			for (int i = 0; i < 6; i++) 
 				if (address [i] != 0)
-					return false;			
-			return true;
+					return false;
+			return ( (IPAddress.NetworkToHostOrder(address[7]) << 16) | IPAddress.NetworkToHostOrder(address[6])) > 1;
 		}
 		
 		public bool IsIPv4Mapped ()
@@ -222,10 +250,69 @@
 		/// </summary>
 		public override string ToString ()
 		{
+			bool bZeroUsed = false;
 			StringBuilder s = new StringBuilder ();
-			for (int i = 0; i < 7; i++)
-				s.Append (String.Format ("{0:X4}", address [i])).Append (':');
-			s.Append (String.Format ("{0:X4}", address [7]));
+
+
+			if(IsIPv4Compatible() || IsIPv4Mapped())
+			{
+				s.Append("::");
+
+				if(IsIPv4Mapped())
+					s.Append("ffff:");
+
+                s.Append(new IPAddress( IPAddress.NetworkToHostOrder(address[6]<<16) + IPAddress.NetworkToHostOrder(address[7])).ToString());
+
+				return s.ToString ();
+			}
+			else
+			{
+        	                int bestChStart = -1; // Best chain start
+                	        int bestChLen = 0; // Best chain length
+                        	int currChLen = 0; // Current chain length
+
+	                        // Looks for the longest zero chain
+        	                for (int i=0; i<8; i++)
+                	        {
+                        	        if (address[i] != 0)
+                             	   	{
+                                	        if ((currChLen > bestChLen) 
+							&& (currChLen > 1))
+                                        	{
+                                                	bestChLen = currChLen;
+                                                	bestChStart = i - currChLen;
+                                        	}
+                                        	currChLen = 0;
+                                	}
+                                	else
+                        			currChLen++;
+                        	}
+                        	if ((currChLen > bestChLen) 
+					&& (currChLen > 1))
+                        	{
+                                	bestChLen = currChLen;
+                                	bestChStart = 8 - currChLen;
+                        	}
+
+                        	// makes the string
+                       		if (bestChStart == 0)
+                                	s.Append(":");
+                        	for (int i=0; i<8; i++)
+                        	{
+                                	if (i == bestChStart)
+                                	{
+                                        	s.Append (":");
+                                        	i += (bestChLen - 1);
+                                        	continue;
+                                	}
+                                	s.AppendFormat("{0:x}", address [i]);
+                                	if (i < 7) s.Append (':');
+                        	}
+
+
+			}
+
+
 			return s.ToString ();
 		}
 
diff -Nurd mono-cvs/mcs/class/System/System.Net/NetConfig.cs mono-ipv6/mcs/class/System/System.Net/NetConfig.cs
--- mono-cvs/mcs/class/System/System.Net/NetConfig.cs	1970-01-01 01:00:00.000000000 +0100
+++ mono-ipv6/mcs/class/System/System.Net/NetConfig.cs	2003-06-30 22:20:01.000000000 +0200
@@ -0,0 +1,26 @@
+// System.Net.NetConfig.cs
+//
+// Authors:
+//    Jerome Laban (jlaban@wanadoo.fr)
+//
+//
+
+using System;
+
+namespace System.Net
+{
+	class NetConfig : ICloneable
+	{
+		internal bool ipv6Enabled = false;
+
+		internal NetConfig()
+		{
+			
+		}
+
+        internal object Clone()
+		{
+			return MemberwiseClone();
+		}
+	}
+}
\ No newline at end of file
diff -Nurd mono-cvs/mcs/class/System/System.Net/ServicePoint.cs mono-ipv6/mcs/class/System/System.Net/ServicePoint.cs
--- mono-cvs/mcs/class/System/System.Net/ServicePoint.cs	2003-06-08 15:47:28.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net/ServicePoint.cs	2003-06-30 22:18:37.000000000 +0200
@@ -130,45 +130,29 @@
 				return groups;
 			}
 		}
-		
-		internal IPEndPoint GetEndPoint ()
-		{
-			if (host == null)
-				host = Dns.GetHostByName (uri.Host);
-
-			return new IPEndPoint (host.AddressList [0], uri.Port);
-		}
 
-		internal IPAddress GetIPAddress ()
+		internal IPHostEntry HostEntry
 		{
-			if (host == null) {
-				try {
-					host = Dns.GetHostByName (uri.Host);
-				} catch {
-					return null;
+			get {
+				if (host == null) 
+				{
+					try 
+					{
+						string uriHost = uri.Host;
+						if (uri.HostNameType == UriHostNameType.IPv6) {
+							// Remove square brackets
+							uriHost = uriHost.Substring(1,uriHost.Length-2);
+						}
+						host = Dns.GetHostByName (uriHost);
+					} 
+					catch 
+					{
+						return null;
+					}
 				}
-			}
-
-			return host.AddressList [0];
-		}
 
-		internal WebExceptionStatus Connect (Socket sock)
-		{
-			IPEndPoint ep = null;
-			try {
-				ep = GetEndPoint ();
-			} catch (SocketException e) {
-				return (usesProxy) ? WebExceptionStatus.ProxyNameResolutionFailure :
-						     WebExceptionStatus.NameResolutionFailure;
-			}
-
-			try {
-				sock.Connect (ep);
-			} catch (SocketException e2) {
-				return WebExceptionStatus.ConnectFailure;
+				return host;
 			}
-
-			return WebExceptionStatus.Success;
 		}
 
 		internal WebConnectionGroup GetConnectionGroup (string name)
@@ -180,7 +164,7 @@
 			if (group != null)
 				return group;
 
-			group = new WebConnectionGroup (this, name, GetIPAddress ());
+			group = new WebConnectionGroup (this, name);
 			Groups [name] = group;
 			return group;
 		}
diff -Nurd mono-cvs/mcs/class/System/System.Net/WebConnection.cs mono-ipv6/mcs/class/System/System.Net/WebConnection.cs
--- mono-cvs/mcs/class/System/System.Net/WebConnection.cs	2003-06-29 19:35:14.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net/WebConnection.cs	2003-06-30 22:18:37.000000000 +0200
@@ -68,11 +68,32 @@
 				if (socket != null && socket.Connected && status == WebExceptionStatus.Success)
 					return;
 
+				if (socket != null) {
+					socket.Close();
+					socket = null;
+				}
 				
-				if (socket == null)
-					socket = new Socket (AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.IP);
+				IPHostEntry hostEntry = sPoint.HostEntry;
+
+				if(hostEntry == null) {
+					status = sPoint.UsesProxy ? WebExceptionStatus.ProxyNameResolutionFailure :
+						WebExceptionStatus.NameResolutionFailure;
+				}
+				else {
+					foreach(IPAddress address in hostEntry.AddressList) {
+						socket = new Socket (address.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
+
+						try {
+							socket.Connect (new IPEndPoint(address, sPoint.Address.Port));
+							status = WebExceptionStatus.Success;
+						} 
+						catch (SocketException e2) {
+							socket.Close();
+							status = WebExceptionStatus.ConnectFailure;
+						}
+					}
+				}
 
-				status = sPoint.Connect (socket);
 				chunkStream = null;
 			}
 		}
diff -Nurd mono-cvs/mcs/class/System/System.Net/WebConnectionGroup.cs mono-ipv6/mcs/class/System/System.Net/WebConnectionGroup.cs
--- mono-cvs/mcs/class/System/System.Net/WebConnectionGroup.cs	2003-06-06 08:57:36.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net/WebConnectionGroup.cs	2003-06-30 22:18:37.000000000 +0200
@@ -16,14 +16,12 @@
 	{
 		ServicePoint sPoint;
 		string name;
-		IPAddress address;
 		ArrayList connections;
 
-		public WebConnectionGroup (ServicePoint sPoint, string name, IPAddress address)
+		public WebConnectionGroup (ServicePoint sPoint, string name)
 		{
 			this.sPoint = sPoint;
 			this.name = name;
-			this.address = address;
 			connections = new ArrayList (1);
 		}
 
diff -Nurd mono-cvs/mcs/class/System/System.Net.Configuration/NetConfigurationHandler.cs mono-ipv6/mcs/class/System/System.Net.Configuration/NetConfigurationHandler.cs
--- mono-cvs/mcs/class/System/System.Net.Configuration/NetConfigurationHandler.cs	1970-01-01 01:00:00.000000000 +0100
+++ mono-ipv6/mcs/class/System/System.Net.Configuration/NetConfigurationHandler.cs	2003-06-30 22:20:29.000000000 +0200
@@ -0,0 +1,32 @@
+//
+// System.Net.Configuration.NetConfigurationHandler.cs
+//
+// Authors:
+//	Jerome Laban (jlaban@wanadoo.fr)
+//
+// (C) 2003 Ximian, Inc (http://www.ximian.com)
+//
+
+using System.Collections;
+using System.Configuration;
+using System.Xml;
+
+namespace System.Net.Configuration
+{
+	class NetConfigurationHandler : IConfigurationSectionHandler
+	{
+		public virtual object Create (object parent, object configContext, XmlNode section)
+		{
+			NetConfig config = new NetConfig();
+
+			XmlNode node = section.SelectSingleNode("ipv6");
+			if(node != null) {
+				XmlAttribute attrib = node.Attributes["enabled"];
+				if(attrib != null)
+					config.ipv6Enabled = String.Compare (attrib.Value, "true", true) == 0;
+			}
+
+			return config;
+		}
+	}
+}
\ No newline at end of file
diff -Nurd mono-cvs/mcs/class/System/System.Net.Sockets/IPv6MulticastOption.cs mono-ipv6/mcs/class/System/System.Net.Sockets/IPv6MulticastOption.cs
--- mono-cvs/mcs/class/System/System.Net.Sockets/IPv6MulticastOption.cs	1970-01-01 01:00:00.000000000 +0100
+++ mono-ipv6/mcs/class/System/System.Net.Sockets/IPv6MulticastOption.cs	2003-06-30 22:27:17.000000000 +0200
@@ -0,0 +1,52 @@
+//
+// System.Net.Sockets.MulticastOption.cs
+//
+// Author:
+//   Andrew Sutton
+//
+// (C) Andrew Sutton
+//
+
+using System;
+using System.Net;
+
+namespace System.Net.Sockets
+{
+	// <remarks>
+	//   Encapsulates a multicast option
+	// </remarks>
+	public class IPv6MulticastOption
+	{
+		// Don't change the names of these fields without also
+		// changing socket-io.c in the runtime
+		private IPAddress group;
+		private long ifIndex;
+
+		public IPv6MulticastOption (IPAddress group)
+			: this (group, 0)
+		{
+
+		}
+
+		public IPv6MulticastOption (IPAddress group, long ifIndex)
+		{
+			if (group == null)
+				throw new ArgumentNullException ("grp");
+
+			this.group = group;
+			this.ifIndex = ifIndex;
+		}
+
+		public IPAddress Group
+		{
+			get { return group; }
+			set { group = value; }
+		}
+
+		public long InterfaceIndex
+		{
+			get { return ifIndex; }
+			set { ifIndex = value; }
+		}
+	}
+}
diff -Nurd mono-cvs/mcs/class/System/System.Net.Sockets/ProtocolType.cs mono-ipv6/mcs/class/System/System.Net.Sockets/ProtocolType.cs
--- mono-cvs/mcs/class/System/System.Net.Sockets/ProtocolType.cs	2001-09-07 17:27:34.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net.Sockets/ProtocolType.cs	2003-06-30 22:18:37.000000000 +0200
@@ -51,6 +51,10 @@
 
 		/// <summary>
 		/// </summary>
+		IPv6 = 41,
+
+		/// <summary>
+		/// </summary>
 		ND = 77,
 
 		/// <summary>
diff -Nurd mono-cvs/mcs/class/System/System.Net.Sockets/Socket.cs mono-ipv6/mcs/class/System/System.Net.Sockets/Socket.cs
--- mono-cvs/mcs/class/System/System.Net.Sockets/Socket.cs	2003-05-16 14:03:57.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net.Sockets/Socket.cs	2003-06-30 22:18:37.000000000 +0200
@@ -258,6 +258,12 @@
 		private SocketType socket_type;
 		private ProtocolType protocol_type;
 		private bool blocking=true;
+
+		/*
+		 *	These two fields are looked up by name by the runtime, don't change
+		 *  their name without also updating the runtime code.
+		 */
+		private static int ipv4Supported = -1, ipv6Supported = -1;
 
 		/* When true, the socket was connected at the time of
 		 * the last IO operation
@@ -463,7 +469,7 @@
 				
 				sa=LocalEndPoint_internal(socket);
 
-				if(sa.Family==AddressFamily.InterNetwork) {
+				if(sa.Family==AddressFamily.InterNetwork || sa.Family==AddressFamily.InterNetworkV6) {
 					// Stupidly, EndPoint.Create() is an
 					// instance method
 					return new IPEndPoint(0, 0).Create(sa);
@@ -493,7 +499,7 @@
 				
 				sa=RemoteEndPoint_internal(socket);
 
-				if(sa.Family==AddressFamily.InterNetwork) {
+				if(sa.Family==AddressFamily.InterNetwork || sa.Family==AddressFamily.InterNetworkV6 ) {
 					// Stupidly, EndPoint.Create() is an
 					// instance method
 					return new IPEndPoint(0, 0).Create(sa);
@@ -512,6 +518,52 @@
 			}
 		}
 
+		public static bool SupportsIPv4 {
+			get {
+				CheckProtocolSupport();
+				return ipv4Supported == 1;
+			}
+		}
+
+		public static bool SupportsIPv6 {
+			get {
+				CheckProtocolSupport();
+				return ipv6Supported == 1;
+			}
+		}
+
+		internal static void CheckProtocolSupport()
+		{
+			if(ipv4Supported == -1) {
+				try  {
+					Socket tmp = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
+					tmp.Close();
+
+					ipv4Supported = 1;
+				}
+				catch {
+					ipv4Supported = 0;
+				}
+			}
+
+			if(ipv6Supported == -1) {
+				NetConfig config = (NetConfig)System.Configuration.ConfigurationSettings.GetConfig("system.net/settings");
+
+				if(config != null)
+					ipv6Supported = config.ipv6Enabled?-1:0;
+
+				if(ipv6Supported != 0) {
+					try {
+						Socket tmp = new Socket(AddressFamily.InterNetworkV6, SocketType.Stream, ProtocolType.Tcp);
+						tmp.Close();
+
+						ipv6Supported = 1;
+					}
+					catch { }
+				}
+			}
+		}
+
 		// Creates a new system socket, returning the handle
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]
 		private extern static IntPtr Accept_internal(IntPtr sock);
@@ -635,7 +687,7 @@
 			if(remote_end==null) {
 				throw new ArgumentNullException();
 			}
-			
+
 			Connect_internal(socket, remote_end.Serialize());
 			connected=true;
 		}
diff -Nurd mono-cvs/mcs/class/System/System.Net.Sockets/SocketOptionLevel.cs mono-ipv6/mcs/class/System/System.Net.Sockets/SocketOptionLevel.cs
--- mono-cvs/mcs/class/System/System.Net.Sockets/SocketOptionLevel.cs	2001-09-07 17:27:34.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net.Sockets/SocketOptionLevel.cs	2003-06-30 22:18:37.000000000 +0200
@@ -27,6 +27,10 @@
 
 		/// <summary>
 		/// </summary>
+		IPv6 = 41,
+
+		/// <summary>
+		/// </summary>
 		Tcp = 6,
 
 		/// <summary>
diff -Nurd mono-cvs/mcs/class/System/System.Net.Sockets/TcpClient.cs mono-ipv6/mcs/class/System/System.Net.Sockets/TcpClient.cs
--- mono-cvs/mcs/class/System/System.Net.Sockets/TcpClient.cs	2002-11-02 13:33:08.000000000 +0100
+++ mono-ipv6/mcs/class/System/System.Net.Sockets/TcpClient.cs	2003-06-30 22:18:37.000000000 +0200
@@ -32,11 +32,16 @@
 		/// <summary>
 		/// Some code that is shared between the constructors.
 		/// </summary>
-		private void Init ()
+		private void Init (AddressFamily family)
 		{
 			active = false;
-			client = new Socket(AddressFamily.InterNetwork,
-				SocketType.Stream, ProtocolType.Tcp);
+
+			if(client != null) {
+				client.Close();
+				client = null;
+			}
+
+			client = new Socket(family, SocketType.Stream, ProtocolType.Tcp);
 		}
 
 		/// <summary>
@@ -44,7 +49,7 @@
 		/// </summary>
 		public TcpClient ()
 		{
-			Init();
+			Init(AddressFamily.InterNetwork);
 			client.Bind(new IPEndPoint(IPAddress.Any, 0));
 		}
 	
@@ -57,7 +62,7 @@
 		/// <param name="local_end_point">The aforementioned local endpoint</param>
 		public TcpClient (IPEndPoint local_end_point)
 		{
-			Init();
+			Init(local_end_point.AddressFamily);
 			client.Bind(local_end_point);
 		}
 		
@@ -71,8 +76,6 @@
 		/// <param name="port">The port to connect to, e.g. 80 for HTTP</param>
 		public TcpClient (string hostname, int port)
 		{
-			Init();
-			client.Bind(new IPEndPoint(IPAddress.Any, 0));
 			Connect(hostname, port);
 		}
 				
@@ -276,10 +279,33 @@
 		public void Connect (string hostname, int port)
 		{
 			CheckDisposed ();
+
 			IPHostEntry host = Dns.GetHostByName(hostname);
-			/* TODO: This will connect to the first IP address returned
-			from GetHostByName.  Is that right? */
-			Connect(new IPEndPoint(host.AddressList[0], port));
+
+			for(int i=0; i<host.AddressList.Length; i++)
+			{
+				try {
+					Init(host.AddressList[i].AddressFamily);
+
+					if(host.AddressList[i].AddressFamily == AddressFamily.InterNetwork)
+						client.Bind(new IPEndPoint(IPAddress.Any, 0));
+					else if(host.AddressList[i].AddressFamily == AddressFamily.InterNetworkV6)
+						client.Bind(new IPEndPoint(IPAddress.IPv6Any, 0));
+
+					Connect(new IPEndPoint(host.AddressList[i], port));
+					break;
+				}
+				catch(Exception e) {
+					if(client != null) {
+						client.Close();
+						client = null;
+					}
+
+					/// This is the last known address, re-throw the exception
+					if(i == host.AddressList.Length-1)
+						throw e;
+				}
+			}
 		}
 		
 		/// <summary>
diff -Nurd mono-cvs/mcs/class/System/System.Net.Sockets/TcpListener.cs mono-ipv6/mcs/class/System/System.Net.Sockets/TcpListener.cs
--- mono-cvs/mcs/class/System/System.Net.Sockets/TcpListener.cs	2002-05-17 17:53:05.000000000 +0200
+++ mono-ipv6/mcs/class/System/System.Net.Sockets/TcpListener.cs	2003-06-30 22:18:37.000000000 +0200
@@ -30,11 +30,10 @@
 		/// <summary>
 		/// Some code that is shared between the constructors.
 		/// </summary>
-		private void Init ()
+		private void Init (AddressFamily family)
 		{
 			active = false;
-			server = new Socket(AddressFamily.InterNetwork,
-				SocketType.Stream, ProtocolType.Tcp);
+			server = new Socket(family, SocketType.Stream, ProtocolType.Tcp);
 		}
 		
 		/// <summary>
@@ -44,7 +43,7 @@
 		/// are a web server</param>
 		public TcpListener (int port)
 		{
-			Init();
+			Init(AddressFamily.InterNetwork);
 			server.Bind(new IPEndPoint(IPAddress.Any, port));
 		}
 
@@ -54,7 +53,7 @@
 		/// <param name="local_end_point">The endpoint</param>
 		public TcpListener (IPEndPoint local_end_point)
 		{
-			Init();
+			Init(local_end_point.AddressFamily);
 			server.Bind(local_end_point);
 		}
 		
@@ -66,7 +65,7 @@
 		/// <param name="port">The port to listen on</param>
 		public TcpListener (IPAddress listen_ip, int port)
 		{
-			Init();
+			Init(listen_ip.AddressFamily);
 			server.Bind(new IPEndPoint(listen_ip, port));
 		}
 
diff -Nurd mono-cvs/mcs/class/System/System.Net.Sockets/UdpClient.cs mono-ipv6/mcs/class/System/System.Net.Sockets/UdpClient.cs
--- mono-cvs/mcs/class/System/System.Net.Sockets/UdpClient.cs	2003-03-25 01:16:59.000000000 +0100
+++ mono-ipv6/mcs/class/System/System.Net.Sockets/UdpClient.cs	2003-06-30 22:18:37.000000000 +0200
@@ -17,10 +17,19 @@
 		private bool disposed = false;
 		private bool active = false;
 		private Socket socket;
+		private AddressFamily family = AddressFamily.InterNetwork;
 		
 #region Constructors
-		public UdpClient ()
+		public UdpClient () : this(AddressFamily.InterNetwork)
+		{
+		}
+
+		public UdpClient(AddressFamily family)
 		{
+			if(family != AddressFamily.InterNetwork && family != AddressFamily.InterNetwork)
+				throw new ArgumentException("family");
+
+			this.family = family;
 			InitSocket (null);
 		}
 
@@ -29,6 +38,8 @@
 			if (port < IPEndPoint.MinPort || port > IPEndPoint.MaxPort)
 				throw new ArgumentOutOfRangeException ("port");
 
+			this.family = AddressFamily.InterNetwork;
+
 			IPEndPoint localEP = new IPEndPoint (IPAddress.Any, port);
 			InitSocket (localEP);
 		}
@@ -38,6 +49,8 @@
 			if (localEP == null)
 				throw new ArgumentNullException ("localEP");
 
+			this.family = localEP.AddressFamily;
+
 			InitSocket (localEP);
 		}
 
@@ -55,7 +68,13 @@
 
 		private void InitSocket (EndPoint localEP)
 		{
-			socket = new Socket (AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
+			if(socket != null) {
+				socket.Close();
+				socket = null;
+			}
+
+			socket = new Socket (family, SocketType.Dgram, ProtocolType.Udp);
+
 			if (localEP != null)
 				socket.Bind (localEP);
 		}
@@ -95,25 +114,57 @@
 			if (port < IPEndPoint.MinPort || port > IPEndPoint.MaxPort)
 				throw new ArgumentOutOfRangeException ("port");
 
-			Connect (new IPEndPoint (Dns.Resolve (hostname).AddressList [0], port));
+			IPAddress[] addresses = Dns.Resolve (hostname).AddressList;
+			for(int i=0; i<addresses.Length; i++) {
+				try {
+					Console.WriteLine("Trying: {0}, Family: {1}", addresses[i], addresses[i].AddressFamily);
+
+					this.family = addresses[i].AddressFamily;
+					Connect (new IPEndPoint (addresses[i], port));
+
+					Console.WriteLine("Connected: {0}, Family: {1}", addresses[i], family);
+					break;
+				}
+				catch(Exception e) {
+					if(i == addresses.Length - 1){
+						if(socket != null) {
+							socket.Close();
+							socket = null;
+						}
+
+						/// This is the last entry, re-throw the exception
+						throw e;
+					}
+				}
+			}
+
 		}
 #endregion
-#region Multicast methods
+		#region Multicast methods
 		public void DropMulticastGroup (IPAddress multicastAddr)
 		{
 			CheckDisposed ();
 			if (multicastAddr == null)
 				throw new ArgumentNullException ("multicastAddr");
 
-			socket.SetSocketOption (SocketOptionLevel.IP, SocketOptionName.DropMembership,
-						new MulticastOption (multicastAddr));
+			if(family == AddressFamily.InterNetwork)
+				socket.SetSocketOption (SocketOptionLevel.IP, SocketOptionName.DropMembership,
+					new MulticastOption (multicastAddr));
+			else
+				socket.SetSocketOption (SocketOptionLevel.IPv6, SocketOptionName.DropMembership,
+					new IPv6MulticastOption (multicastAddr));
 		}
 
 		public void JoinMulticastGroup (IPAddress multicastAddr)
 		{
 			CheckDisposed ();
-			socket.SetSocketOption (SocketOptionLevel.IP, SocketOptionName.AddMembership,
-						new MulticastOption (multicastAddr));
+
+			if(family == AddressFamily.InterNetwork)
+				socket.SetSocketOption (SocketOptionLevel.IP, SocketOptionName.AddMembership,
+					new MulticastOption (multicastAddr));
+			else
+				socket.SetSocketOption (SocketOptionLevel.IPv6, SocketOptionName.AddMembership,
+					new IPv6MulticastOption (multicastAddr));
 		}
 
 		public void JoinMulticastGroup (IPAddress multicastAddr, int timeToLive)
@@ -123,10 +174,14 @@
 			if (timeToLive < 0 || timeToLive > 255)
 				throw new ArgumentOutOfRangeException ("timeToLive");
 
-			socket.SetSocketOption (SocketOptionLevel.IP, SocketOptionName.MulticastTimeToLive,
-						timeToLive);
+			if(family == AddressFamily.InterNetwork)
+				socket.SetSocketOption (SocketOptionLevel.IP, SocketOptionName.MulticastTimeToLive,
+					timeToLive);
+			else
+				socket.SetSocketOption (SocketOptionLevel.IPv6, SocketOptionName.MulticastTimeToLive,
+					timeToLive);
 		}
-#endregion
+		#endregion
 #region Data I/O
 		public byte [] Receive (ref IPEndPoint remoteEP)
 		{
diff -Nurd mono-cvs/mcs/class/System/Test/System.Net/IPAddressTest.cs mono-ipv6/mcs/class/System/Test/System.Net/IPAddressTest.cs
--- mono-cvs/mcs/class/System/Test/System.Net/IPAddressTest.cs	2003-03-18 22:45:40.000000000 +0100
+++ mono-ipv6/mcs/class/System/Test/System.Net/IPAddressTest.cs	2003-06-30 22:18:37.000000000 +0200
@@ -20,6 +20,79 @@
 [TestFixture]
 public class IPAddressTest
 {
+	static string[] ipv6AddressList = new string[] {
+													   "::",					"0:0:0:0:0:0:0:0", 
+													   "1::",					"1:0:0:0:0:0:0:0",
+													   "2:2::",					"2:2:0:0:0:0:0:0",
+													   "7:7:7:7:7:7:7:0",		"7:7:7:7:7:7:7:0",
+													   "::1",					"0:0:0:0:0:0:0:1",
+													   "0:7:7:7:7:7:7:7",		"0:7:7:7:7:7:7:7",
+													   "E::1",					"E:0:0:0:0:0:0:1",
+													   "E::2:2",				"E:0:0:0:0:0:2:2",
+													   "E:0:6:6:6:6:6:6",		"E:0:6:6:6:6:6:6",
+													   "E:E::1",				"E:E:0:0:0:0:0:1",
+													   "E:E::2:2",				"E:E:0:0:0:0:2:2",
+													   "E:E:0:5:5:5:5:5",		"E:E:0:5:5:5:5:5",
+													   "E:E:E::1",				"E:E:E:0:0:0:0:1",
+													   "E:E:E::2:2",			"E:E:E:0:0:0:2:2",
+													   "E:E:E:0:4:4:4:4",		"E:E:E:0:4:4:4:4",
+													   "E:E:E:E::1",			"E:E:E:E:0:0:0:1",
+													   "E:E:E:E::2:2",			"E:E:E:E:0:0:2:2",
+													   "E:E:E:E:0:3:3:3",		"E:E:E:E:0:3:3:3",
+													   "E:E:E:E:E::1",			"E:E:E:E:E:0:0:1",
+													   "E:E:E:E:E:0:2:2",		"E:E:E:E:E:0:2:2",
+													   "E:E:E:E:E:E:0:1",		"E:E:E:E:E:E:0:1",
+													   "::0.2.0.2",				"0:0:0:0:0:0:2:2",
+													   "::FFFF:192.168.0.1",	"::FFFF:192.168.0.1",
+													   "::FFFF:0.168.0.1",		"::FFFF:0.168.0.1",
+													   "::FFFF",				"::0.0.255.255",
+													   "::10.0.0.1",			"::10.0.0.1",
+													   "1234::1234:0:0",		"1234:0:0:0:0:1234:0:0",
+													   "1:0:1:0:1:0:1:0",		"1:0:1:0:1:0:1:0",
+													   "1:1:1::1:1:0",			"1:1:1:0:0:1:1:0",
+													   "::1234:0:0",			"0:0:0:0:0:1234:0:0",
+													   "3ffe:38e1::100:1:1",	"3ffe:38e1::0100:1:0001",
+													   "0:0:1:2::",				"0:0:1:2:00:00:000:0000",
+													   "100:0:1:2::abcd",		"100:0:1:2:0:0:000:abcd",
+													   "ffff::abcd",			"ffff:0:0:0:0:0:00:abcd",
+													   "ffff:0:0:2::abcd",		"ffff:0:0:2:0:0:00:abcd",
+													   "0:0:1:2::",				"0:0:1:2:0:00:0000:0000",
+													   "::1:0:0",				"0000:0000::1:0000:0000",
+													   "::111:234:5:6:789a:0",	"0:0:111:234:5:6:789A:0",
+													   "11:22:33:44:55:66:77:8","11:22:33:44:55:66:77:8",
+													   "0:0:7711:ab42:1230::",	"::7711:ab42:1230:0:0:0",
+	};
+
+	static string[] ipv4ParseOk = new string[] {
+												   "192.168.1.1",				"192.168.1.1",
+												   "0xff.0x7f.0x20.0x01",		"255.127.32.1",
+												   "0xff.0x7f.0x20.0xf",		"255.127.32.15",
+												   "0.0.0.0",					IPAddress.Any.ToString(),
+												   "255.255.255.255",			IPAddress.Broadcast.ToString(),
+												   "12.1.1.3 ",					"12.1.1.3",
+												   " 12.1.1.1",					"0.0.0.0",
+												   "12.1 .1.2",					"12.0.0.1",
+												   ".1.1.6",					"0.1.1.6",
+												   "12.1.7",					"12.1.0.7",
+												   "12.1.8. ",					"12.1.8.0",
+												   "12",						"0.0.0.12",
+												   "12.1 foo.1.2.3.4.5.bar",	"12.0.0.1",		
+												   "12.1.2. ",					"12.1.2.0",		
+												   "12.. .",					"12.0.0.0",	
+												   " ",							"0.0.0.0",		
+												   " foo",						"0.0.0.0"
+											   };
+
+	static object[] ipv4ParseWrong = new object[] {
+													  "12.+1.1.4",	typeof(FormatException),
+													  "12.1.-1.5",	typeof(FormatException), 
+													  "257.1.1.9",	typeof(FormatException), 
+													  "12.",		typeof(FormatException),
+													  "12.1.2.",	typeof(FormatException),
+													  "12...",		typeof(FormatException),
+													  null,			typeof(ArgumentNullException),
+												  };
+
 	[Test]
 	public void PublicFields ()
 	{
@@ -41,6 +114,11 @@
 		Assertion.AssertEquals ("ToString #3", "255.255.255.255", IPAddress.Broadcast.ToString ());
 		Assertion.AssertEquals ("ToString #4", "127.0.0.1", IPAddress.Loopback.ToString ());
 		Assertion.AssertEquals ("ToString #5", "255.255.255.255", IPAddress.None.ToString ());
+
+		for(int i=0; i<ipv6AddressList.Length/2; i++) {
+			string addr = IPAddress.Parse (ipv6AddressList[i*2+1]).ToString().ToLower();
+			Assertion.AssertEquals ("ToStringIPv6 #" + i, ipv6AddressList[i*2].ToLower(), addr);
+		}
 	}
 	
 	[Test]
@@ -48,6 +126,40 @@
 	{
 		IPAddress ip = IPAddress.Parse ("127.0.0.1");
 		Assertion.AssertEquals ("IsLoopback #1", true, IPAddress.IsLoopback (ip));
+
+		ip = IPAddress.Parse ("::101");
+		Assertion.AssertEquals ("IsLoopback #2", false, IPAddress.IsLoopback (ip));
+
+		ip = IPAddress.IPv6Loopback;
+		Assertion.AssertEquals ("IsLoopback #3", true, IPAddress.IsLoopback (ip));
+
+		ip = IPAddress.IPv6None;
+		Assertion.AssertEquals ("IsLoopback #7", false, IPAddress.IsLoopback (ip));
+
+		ip = IPAddress.Any;
+		Assertion.AssertEquals ("IsLoopback #5", false, IPAddress.IsLoopback (ip));
+
+		ip = IPAddress.Loopback;
+		Assertion.AssertEquals ("IsLoopback #6", true, IPAddress.IsLoopback (ip));
+	}
+
+	[Test]
+	public void GetAddressBytes()
+	{
+		byte[] dataIn	= { 10, 11, 12, 13 };
+		byte[] dataOut	= IPAddress.Parse ("10.11.12.13").GetAddressBytes ();
+		for(int i=0; i<dataIn.Length; i++)
+			Assertion.AssertEquals ("GetAddressBytes #1", dataIn[i], dataOut[i]);	
+	
+		dataIn	= new byte[]{ 0x01, 0x23, 0x45, 0x67, 0x89, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67, 0x89, 0x98 };
+		dataOut	= IPAddress.Parse ("123:4567:8998:7654:3210:0123:4567:8998").GetAddressBytes ();
+		for(int i=0; i<dataIn.Length; i++)
+			Assertion.AssertEquals ("GetAddressBytes #2", dataIn[i], dataOut[i]);
+
+		dataIn	= new byte[]{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x01 };
+		dataOut	= IPAddress.Parse ("::FFFF:127.0.0.1").GetAddressBytes ();
+		for(int i=0; i<dataIn.Length; i++)
+			Assertion.AssertEquals ("GetAddressBytes #3", dataIn[i], dataOut[i]);
 	}
 	
 	[Test]
@@ -76,112 +188,41 @@
 	[Test]
 	public void ParseOk ()
 	{
-		IPAddress ip = IPAddress.Parse ("192.168.1.1");
-		Assertion.Assert ("Parse #1", ip.ToString () == "192.168.1.1");
-
-		ip = IPAddress.Parse ("0xff.0x7f.0x20.0x01");
-		Assertion.Assert ("Parse #1b", ip.ToString () == "255.127.32.1");
-
-		ip = IPAddress.Parse ("0xff.0x7f.0x20.0xf");
-		Assertion.Assert ("Parse #1c", ip.ToString () == "255.127.32.15");
-
-		ip = IPAddress.Parse ("0.0.0.0");
-		Assertion.AssertEquals ("Parse #2", ip, IPAddress.Any);
-
-		ip = IPAddress.Parse ("255.255.255.255");
-		Assertion.AssertEquals ("Parse #3", ip, IPAddress.Broadcast);
-		Assertion.AssertEquals ("Parse #4", ip, IPAddress.None);
-
-		ip = IPAddress.Parse ("127.0.0.1");
-		Assertion.AssertEquals ("Parse #5", IPAddress.IsLoopback (ip), true);
-
-		ip = IPAddress.Parse ("12.1.1.3 ");
-		Assertion.AssertEquals ("Parse #6", IPAddress.Parse ("12.1.1.3"), ip);
-
-		ip = IPAddress.Parse (" 12.1.1.1");
-		Assertion.AssertEquals ("Parse #7", IPAddress.Parse ("0.0.0.0"), ip);
-
-		ip = IPAddress.Parse ("12.1 .1.2");
-		Assertion.AssertEquals ("Parse #8", IPAddress.Parse ("12.0.0.1"), ip);
-
-		ip = IPAddress.Parse (".1.1.6");
-		Assertion.AssertEquals ("Parse #9", IPAddress.Parse ("0.1.1.6"), ip);
-
-		ip = IPAddress.Parse ("12.1.7");
-		Assertion.AssertEquals ("Parse #10", IPAddress.Parse ("12.1.0.7"), ip);
-
-		ip = IPAddress.Parse ("12.1.8. ");
-		Assertion.AssertEquals ("Parse #11", IPAddress.Parse ("12.1.8.0"), ip);
-
-		ip = IPAddress.Parse ("12");
-		Assertion.AssertEquals ("Parse #12", IPAddress.Parse ("0.0.0.12"), ip);	
-
-		ip = IPAddress.Parse ("12.1 foo.1.2.3.4.5.bar");
-		Assertion.AssertEquals ("Parse #13", IPAddress.Parse ("12.0.0.1"), ip);			
-
-		ip = IPAddress.Parse ("12.1.2. ");
-		Assertion.AssertEquals ("Parse #14", IPAddress.Parse ("12.1.2.0"), ip);			
-
-		ip = IPAddress.Parse ("12.. .");
-		Assertion.AssertEquals ("Parse #15", IPAddress.Parse ("12.0.0.0"), ip);			
-
-		ip = IPAddress.Parse (" ");
-		Assertion.AssertEquals ("Parse #16", IPAddress.Parse ("0.0.0.0"), ip);			
+		for(int i=0; i<ipv4ParseOk.Length / 2; i++) {
+			IPAddress ip = IPAddress.Parse (ipv4ParseOk [i*2]);
+			Assertion.Assert ("ParseIPv4 #" + i, ip.ToString () == ipv4ParseOk [i*2+1]);
+		}
 
-		ip = IPAddress.Parse (" foo");
-		Assertion.AssertEquals ("Parse #17", IPAddress.Parse ("0.0.0.0"), ip);			
+		for(int i=0; i<ipv6AddressList.Length / 2; i++) 
+		{
+			string source = ipv6AddressList [i*2].ToLower();
+
+			IPAddress ip = IPAddress.Parse (source);
+			Assertion.Assert (string.Format("ParseIPv6 #{0}-1: {1} != {2}", i,
+				ip.ToString ().ToLower (), source), ip.ToString ().ToLower () == source);
+
+			ip = IPAddress.Parse (ipv6AddressList [i*2+1].ToLower ());
+			Assertion.Assert (string.Format("ParseIPv6 #{0}-2: {1} != {2}", i,
+				ip.ToString ().ToLower (), source), ip.ToString ().ToLower () == source);
+		}
 	}
 
 	[Test]
 	public void ParseWrong ()
 	{
-		IPAddress ip = IPAddress.None;
-		try {
-			ip = IPAddress.Parse ("12.+1.1.4");
-                        Assertion.Fail("Should raise a FormatException #1");
-		} catch (FormatException) {
-		} catch (Exception e) {
-			Assertion.Fail ("ParseWrong #1:" + e.ToString());
-		}
-
-		try {
-			ip = IPAddress.Parse ("12.1.-1.5");
-                        Assertion.Fail("Should raise a FormatException #2");
-		} catch (FormatException) {
-		} catch (Exception e) {
-			Assertion.Fail ("ParseWrong #2:" + e.ToString());
-		}
-
-		try {
-			ip = IPAddress.Parse ("257.1.1.9");
-                        Assertion.Fail("Should raise a FormatException #3");
-		} catch (FormatException) {
-		} catch (Exception e) {
-			Assertion.Fail ("ParseWrong #3:" + e.ToString());
-		}
-
-		try {
-			ip = IPAddress.Parse (null);
-                        Assertion.Fail("Should raise a ArgumentNullException #1");
-		} catch (ArgumentNullException) {
-		} catch (Exception e) {
-			Assertion.Fail ("ParseWrong #4:" + e.ToString());
+		for(int i=0; i<ipv4ParseWrong.Length/2; i++) {
+			Type	exception	= ipv4ParseWrong[i*2+1] as Type;
+			string	ipAddress	= ipv4ParseWrong[i*2] as string;
+
+			try {
+				IPAddress ip = IPAddress.Parse (ipAddress);
+				Assertion.Fail ("IPv4: Should raise a " + exception + " #" + i);
+			} 
+			catch (Exception e)  {
+				if(!e.GetType ().Equals (exception))
+					Assertion.Fail ("ParseWrongIPv4 #" + i + ": " + e.ToString());
+			}
 		}
-
-		try {
-			ip = IPAddress.Parse ("12.");
-			Assertion.Fail ("ParseWrong #5: Should raise a FormatException");
-		} catch (FormatException) {}
-
-		try {
-			ip = IPAddress.Parse ("12.1.2.");
-			Assertion.Fail ("ParseWrong #6: Should raise a FormatException");
-		} catch (FormatException) {}		
-
-		try {
-			ip = IPAddress.Parse ("12...");
-			Assertion.Fail ("ParseWrong #7: Should raise a FormatException");
-		} catch (FormatException) {}		
 	}
 
 	[Test]
diff -Nurd mono-cvs/mcs/class/System/Test/System.Net.Sockets/TcpListenerTest.cs mono-ipv6/mcs/class/System/Test/System.Net.Sockets/TcpListenerTest.cs
--- mono-cvs/mcs/class/System/Test/System.Net.Sockets/TcpListenerTest.cs	2003-03-18 22:45:40.000000000 +0100
+++ mono-ipv6/mcs/class/System/Test/System.Net.Sockets/TcpListenerTest.cs	2003-06-30 22:18:37.000000000 +0200
@@ -28,24 +28,30 @@
 		[Test]
 		public void TcpListener()
 		{
-			// listen with a new listener
+			// listen with a new listener (IPv4 is the default)
 			TcpListener inListener = new TcpListener(1234);
 			inListener.Start();
 			
 
 			// connect to it from a new socket
-			Socket outSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
-				ProtocolType.IP);
 			IPHostEntry hostent = Dns.GetHostByAddress("127.0.0.1");
-			IPEndPoint remote = new IPEndPoint(hostent.AddressList[0], 1234);
-			outSock.Connect(remote);
+			Socket outSock;
 
+			foreach(IPAddress address in hostent.AddressList) {
+				if(address.AddressFamily == AddressFamily.InterNetwork) {
+					/// Only keep IPv4 addresses, our Server is in IPv4 only mode.
+					outSock = new Socket(address.AddressFamily, SocketType.Stream,
+						ProtocolType.IP);
+					IPEndPoint remote = new IPEndPoint(address, 1234);
+					outSock.Connect(remote);
+					break;
+				}
+			}
 			
 			// make sure the connection arrives
 			Assertion.Assert(inListener.Pending());
 			Socket inSock = inListener.AcceptSocket();
 
-
 			// now send some data and see if it comes out the other end
 			const int len = 1024;
 			byte[] outBuf = new Byte[len];
diff -Nurd mono-cvs/mono/data/machine.config mono-ipv6/mono/data/machine.config
--- mono-cvs/mono/data/machine.config	2003-06-09 20:10:18.000000000 +0200
+++ mono-ipv6/mono/data/machine.config	2003-06-30 22:19:10.000000000 +0200
@@ -23,6 +23,8 @@
 				 type="System.Web.SessionState.SessionStateSectionHandler, System.Web" />
 		</sectionGroup>
 		<sectionGroup name="system.net">
+			<section name="settings"
+				 type="System.Net.Configuration.NetConfigurationHandler, System" />
 			<section name="connectionManagement"
 				 type="System.Net.Configuration.ConnectionManagementHandler, System" />
 			<section name="authenticationModules"
@@ -50,6 +52,9 @@
 			<add prefix="https" type="System.Net.HttpRequestCreator, System" />
 			<add prefix="file" type="System.Net.FileWebRequestCreator, System" />
 		</webRequestModules>
+		<settings>
+			<ipv6 enabled="false"/>
+		</settings>
 	</system.net>
 	<system.web>
 		<httpHandlers>
diff -Nurd mono-cvs/mono/mono/metadata/socket-io.c mono-ipv6/mono/mono/metadata/socket-io.c
--- mono-cvs/mono/mono/metadata/socket-io.c	2003-06-10 19:02:25.000000000 +0200
+++ mono-ipv6/mono/mono/metadata/socket-io.c	2003-06-30 22:19:10.000000000 +0200
@@ -13,6 +13,7 @@
 #include <string.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <errno.h>
 
 #include <mono/metadata/object.h>
 #include <mono/io-layer/io-layer.h>
@@ -39,6 +40,7 @@
 
 #undef DEBUG
 
+
 static gint32 convert_family(MonoAddressFamily mono_family)
 {
 	gint32 family=-1;
@@ -96,7 +98,7 @@
 		family=AF_APPLETALK;
 		break;
 		
-#ifdef AF_INET6
+#if defined(AF_INET6) /* && (defined(NET_1_0) || defined(NET_1_1)) */
 	case AddressFamily_InterNetworkV6:
 		family=AF_INET6;
 		break;
@@ -148,7 +150,7 @@
 		family=AddressFamily_AppleTalk;
 		break;
 		
-#ifdef AF_INET6
+#if defined(AF_INET6) /* && defined(NET_1_1) */
 	case AF_INET6:
 		family=AddressFamily_InterNetworkV6;
 		break;
@@ -208,6 +210,7 @@
 	
 	switch(mono_proto) {
 	case ProtocolType_IP:
+	case ProtocolType_IPv6:
 	case ProtocolType_Icmp:
 	case ProtocolType_Igmp:
 	case ProtocolType_Ggp:
@@ -387,6 +390,51 @@
 			return(-1);
 		}
 		break;
+
+#if defined(AF_INET6) /* && defined(NET_1_1) */
+	case SocketOptionLevel_IPv6:
+		*system_level = SOL_IPV6;
+
+		switch(mono_name) {
+		case SocketOptionName_IpTimeToLive:
+			*system_name = IPV6_UNICAST_HOPS;
+			break;
+		case SocketOptionName_MulticastInterface:
+			*system_name = IPV6_MULTICAST_IF;
+			break;
+		case SocketOptionName_MulticastTimeToLive:
+			*system_name = IPV6_MULTICAST_HOPS;
+			break;
+		case SocketOptionName_MulticastLoopback:
+			*system_name = IPV6_MULTICAST_LOOP;
+			break;
+		case SocketOptionName_AddMembership:
+			*system_name = IPV6_JOIN_GROUP;
+			break;
+		case SocketOptionName_DropMembership:
+			*system_name = IPV6_LEAVE_GROUP;
+			break;
+		case SocketOptionName_PacketInformation:
+			*system_name = IPV6_PKTINFO;
+			break;
+		case SocketOptionName_HeaderIncluded:
+		case SocketOptionName_IPOptions:
+		case SocketOptionName_TypeOfService:
+		case SocketOptionName_DontFragment:
+		case SocketOptionName_AddSourceMembership:
+		case SocketOptionName_DropSourceMembership:
+		case SocketOptionName_BlockSource:
+		case SocketOptionName_UnblockSource:
+			/* Can't figure out how to map these, so fall
+			 * through
+			 */
+		default:
+			g_warning("System.Net.Sockets.SocketOptionName 0x%x is not supported at IPv6 level", mono_name);
+			return(-1);
+		}
+
+		break;	/// SocketOptionLevel_IPv6
+#endif
 		
 	case SocketOptionLevel_Tcp:
 #ifdef HAVE_SOL_TCP
@@ -456,6 +504,30 @@
 
 static MonoImage *system_assembly=NULL;
 
+
+static gint32 get_family_hint(void)
+{
+	MonoClass *socket_class;
+	MonoClassField *ipv6_field, *ipv4_field;
+	gint32 ipv6_enabled = -1, ipv4_enabled = -1;
+	MonoVTable *vtable;
+
+	socket_class = mono_class_from_name (system_assembly, "System.Net.Sockets", "Socket");
+	ipv4_field = mono_class_get_field_from_name (socket_class, "ipv4Supported");
+	ipv6_field = mono_class_get_field_from_name (socket_class, "ipv6Supported");
+	vtable = mono_class_vtable (mono_domain_get (), socket_class);
+
+	mono_field_static_get_value(vtable, ipv4_field, &ipv4_enabled);
+	mono_field_static_get_value(vtable, ipv6_field, &ipv6_enabled);
+
+	if(ipv4_enabled == 1 && ipv6_enabled == 1)
+		return PF_UNSPEC;
+	else if(ipv4_enabled == 1)
+		return PF_INET;
+	else 
+		return PF_INET6;
+}
+
 static MonoException *get_socket_exception(guint32 error_code)
 {
 	/* Don't cache this exception, because we need the object
@@ -513,7 +585,7 @@
 		return(NULL);
 	}
 
-	if (sock_family == AF_INET && sock_type == SOCK_DGRAM)
+	if ( (sock_family == AF_INET || sock_family == AF_INET6) && sock_type == SOCK_DGRAM)
 		return (GUINT_TO_POINTER (sock));
 
 	/* .net seems to set this by default for SOCK_STREAM,
@@ -664,6 +736,32 @@
 		*(MonoArray **)(((char *)sockaddr_obj) + field->offset)=data;
 
 		return(sockaddr_obj);
+#if defined(AF_INET6) /* && defined(NET_1_1) */
+	} else if (saddr->sa_family == AF_INET6) {
+		struct sockaddr_in6 *sa_in=(struct sockaddr_in6 *)saddr;
+		int i;
+
+		guint16 port=ntohs(sa_in->sin6_port);
+
+		if(sa_size<28) {
+			mono_raise_exception((MonoException *)mono_exception_from_name(mono_defaults.corlib, "System", "SystemException"));
+		}
+
+		mono_array_set(data, guint8, 2, (port>>8) & 0xff);
+		mono_array_set(data, guint8, 3, (port) & 0xff);
+
+		for(i=0; i<16; i++)
+			mono_array_set(data, guint8, 8+i, sa_in->sin6_addr.s6_addr[i]);
+
+		mono_array_set(data, guint8, 24, sa_in->sin6_scope_id & 0xff);
+		mono_array_set(data, guint8, 25, (sa_in->sin6_scope_id >> 8) & 0xff);
+		mono_array_set(data, guint8, 26, (sa_in->sin6_scope_id >> 16) & 0xff);
+		mono_array_set(data, guint8, 27, (sa_in->sin6_scope_id >> 24) & 0xff);
+
+		*(MonoArray **)(((char *)sockaddr_obj) + field->offset)=data;
+
+		return(sockaddr_obj);
+#endif
 #ifdef HAVE_SYS_UN_H
 	} else if (saddr->sa_family == AF_UNIX) {
 		int i;
@@ -683,14 +781,14 @@
 
 extern MonoObject *ves_icall_System_Net_Sockets_Socket_LocalEndPoint_internal(SOCKET sock)
 {
-	struct sockaddr sa;
+	gchar sa[32];	/// sockaddr in not big enough for sockaddr_in6
 	int salen;
 	int ret;
 	
 	MONO_ARCH_SAVE_REGS;
 
-	salen=sizeof(struct sockaddr);
-	ret=getsockname(sock, &sa, &salen);
+	salen=sizeof(sa);
+	ret=getsockname(sock, (struct sockaddr*)sa, &salen);
 	
 	if(ret==SOCKET_ERROR) {
 		mono_raise_exception(get_socket_exception(WSAGetLastError()));
@@ -705,13 +803,13 @@
 
 extern MonoObject *ves_icall_System_Net_Sockets_Socket_RemoteEndPoint_internal(SOCKET sock)
 {
-	struct sockaddr sa;
+	gchar sa[32];	/// sockaddr in not big enough for sockaddr_in6
 	int salen;
 	int ret;
 	
 	MONO_ARCH_SAVE_REGS;
 
-	salen=sizeof(struct sockaddr);
+	salen=sizeof(sa);
 	ret=getpeername(sock, &sa, &salen);
 	
 	if(ret==SOCKET_ERROR) {
@@ -722,7 +820,7 @@
 	g_message(G_GNUC_PRETTY_FUNCTION ": connected to %s port %d", inet_ntoa(((struct sockaddr_in *)&sa)->sin_addr), ntohs(((struct sockaddr_in *)&sa)->sin_port));
 #endif
 
-	return(create_object_from_sockaddr(&sa, salen));
+	return(create_object_from_sockaddr((struct sockaddr*)sa, salen));
 }
 
 static struct sockaddr *create_sockaddr_from_object(MonoObject *saddr_obj,
@@ -767,6 +865,28 @@
 
 		*sa_size=sizeof(struct sockaddr_in);
 		return((struct sockaddr *)sa);
+
+#if defined(AF_INET6) /* && defined(NET_1_1) */
+	} else if (family == AF_INET6) {
+		struct sockaddr_in6 *sa=g_new0(struct sockaddr_in6, 1);
+		int i;
+
+		guint16 port = mono_array_get(data, guint8, 3) + (mono_array_get(data, guint8, 2) << 8);
+		guint32 scopeid = mono_array_get(data, guint8, 24) + 
+			(mono_array_get(data, guint8, 25)<<8) + 
+			(mono_array_get(data, guint8, 26)<<16) + 
+			(mono_array_get(data, guint8, 27)<<24);
+
+		sa->sin6_family=family;
+		sa->sin6_port=htons(port);
+		sa->sin6_scope_id = scopeid;
+
+		for(i=0; i<16; i++)
+			sa->sin6_addr.s6_addr[i] = mono_array_get(data, guint8, 8+i);
+
+		*sa_size=sizeof(struct sockaddr_in6);
+		return((struct sockaddr *)sa);
+#endif
 #ifdef HAVE_SYS_UN_H
 	} else if (family == AF_UNIX) {
 		struct sockaddr_un *sock_un = g_new0 (struct sockaddr_un, 1);
@@ -803,6 +923,7 @@
 #ifdef DEBUG
 	g_message(G_GNUC_PRETTY_FUNCTION ": binding to %s port %d", inet_ntoa(((struct sockaddr_in *)sa)->sin_addr), ntohs (((struct sockaddr_in *)sa)->sin_port));
 #endif
+
 	ret=bind(sock, sa, sa_size);
 	g_free(sa);
 	
@@ -1251,6 +1372,24 @@
 	return(inaddr);
 }
 
+#if defined(AF_INET6) /* && defined(NET_1_1) */
+static struct in6_addr ipaddress_to_struct_in6_addr(MonoObject *ipaddr)
+{
+	struct in6_addr in6addr;
+	MonoClassField *field;
+	MonoArray *data;
+	int i;
+
+	field=mono_class_get_field_from_name(ipaddr->vtable->klass, "_numbers");
+	data=*(MonoArray **)(((char *)ipaddr) + field->offset);
+
+	for(i=0; i<8; i++)
+		in6addr.s6_addr16[i] = mono_array_get (data, guint16, i);
+
+	return(in6addr);
+}
+#endif /* AF_INET6 */
+
 void ves_icall_System_Net_Sockets_Socket_SetSocketOption_internal(SOCKET sock, gint32 level, gint32 name, MonoObject *obj_val, MonoArray *byte_val, gint32 int_val)
 {
 	int system_level;
@@ -1300,37 +1439,61 @@
 		{
 			MonoObject *address = NULL;
 
+#if defined(AF_INET6) /* && defined(NET_1_1) */
+			if(system_level == SOL_IPV6)
+			{
+				struct ipv6_mreq mreq6;
+
+				/*
+				 *	Get group address
+				 */
+				field = mono_class_get_field_from_name (obj_val->vtable->klass, "group");
+				address = *(gpointer *)(((char *)obj_val) + field->offset);
+				
+				if(address)
+					mreq6.ipv6mr_multiaddr = ipaddress_to_struct_in6_addr (address);
+
+				field=mono_class_get_field_from_name(obj_val->vtable->klass, "ifIndex");
+				mreq6.ipv6mr_interface =*(guint64 *)(((char *)obj_val)+field->offset);
+
+				ret = setsockopt (sock, system_level, system_name,
+					&mreq6, sizeof (mreq6));
+			}
+			else if(system_level == SOL_IP)
+#endif /* AF_INET6 */
+			{
 #ifdef HAVE_STRUCT_IP_MREQN
-			struct ip_mreqn mreq = {{0}};
+				struct ip_mreqn mreq = {{0}};
 #else
-			struct ip_mreq mreq = {{0}};
+				struct ip_mreq mreq = {{0}};
 #endif /* HAVE_STRUCT_IP_MREQN */
 			
-			/* pain! MulticastOption holds two IPAddress
-			 * members, so I have to dig the value out of
-			 * those :-(
-			 */
-			field = mono_class_get_field_from_name (obj_val->vtable->klass, "group");
-			address = *(gpointer *)(((char *)obj_val) + field->offset);
+				/* pain! MulticastOption holds two IPAddress
+				 * members, so I have to dig the value out of
+				 * those :-(
+				 */
+				field = mono_class_get_field_from_name (obj_val->vtable->klass, "group");
+				address = *(gpointer *)(((char *)obj_val) + field->offset);
 
-			/* address might not be defined and if so, set the address to ADDR_ANY.
-			 */
-			if(address)
-				mreq.imr_multiaddr = ipaddress_to_struct_in_addr (address);
+				/* address might not be defined and if so, set the address to ADDR_ANY.
+				 */
+				if(address)
+					mreq.imr_multiaddr = ipaddress_to_struct_in_addr (address);
 
-			field = mono_class_get_field_from_name (obj_val->vtable->klass, "local");
-			address = *(gpointer *)(((char *)obj_val) + field->offset);
+				field = mono_class_get_field_from_name (obj_val->vtable->klass, "local");
+				address = *(gpointer *)(((char *)obj_val) + field->offset);
 
 #ifdef HAVE_STRUCT_IP_MREQN
-			if(address)
-				mreq.imr_address = ipaddress_to_struct_in_addr (address);
+				if(address)
+					mreq.imr_address = ipaddress_to_struct_in_addr (address);
 #else
-			if(address)
-				mreq.imr_interface = ipaddress_to_struct_in_addr (address);
+				if(address)
+					mreq.imr_interface = ipaddress_to_struct_in_addr (address);
 #endif /* HAVE_STRUCT_IP_MREQN */
 			
-			ret = setsockopt (sock, system_level, system_name,
-					  &mreq, sizeof (mreq));
+				ret = setsockopt (sock, system_level, system_name,
+						&mreq, sizeof (mreq));
+			}
 			break;
 		}
 #endif /* HAVE_STRUCT_IP_MREQN || HAVE_STRUCT_IP_MREQ */
@@ -1425,22 +1588,107 @@
 	return(TRUE);
 }
 
+#if defined(AF_INET6) /* && defined(NET_1_1) */
+static gboolean 
+addrinfo_to_IPHostEntry(struct addrinfo *info, MonoString **h_name,
+						MonoArray **h_aliases,
+						MonoArray **h_addr_list)
+{
+	gint32 count, i;
+	struct addrinfo *ai = NULL;
+
+	MonoDomain *domain = mono_domain_get ();
+
+	for (count=0, ai=info; ai!=NULL; ai=ai->ai_next)
+	{
+		if ((ai->ai_family != PF_INET) && (ai->ai_family != PF_INET6))
+			continue;
+
+		count++;
+	}
+
+	*h_aliases=mono_array_new(domain, mono_defaults.string_class, 0);
+	*h_addr_list=mono_array_new(domain, mono_defaults.string_class, count);
+
+	for (ai=info, i=0; ai!=NULL; ai=ai->ai_next) {
+		MonoString *addr_string;
+		char *ret, *buffer;
+		gint32 buffer_size = 0;
+
+		if ((ai->ai_family != PF_INET) && (ai->ai_family != PF_INET6))
+			continue;
+
+		buffer_size = 256;
+		do {
+			buffer = g_malloc0(buffer_size);
+
+			if(ai->ai_family == PF_INET)
+				ret = inet_ntop(ai->ai_family, (void*)&(((struct sockaddr_in*)ai->ai_addr)->sin_addr), buffer, buffer_size);
+			else
+				ret = inet_ntop(ai->ai_family, (void*)&(((struct sockaddr_in6*)ai->ai_addr)->sin6_addr), buffer, buffer_size);
+
+			if(ret == 0) {
+				g_free(buffer);
+				buffer_size += 256;
+			}
+
+		} while(ret == 0 && errno == ENOSPC);
+
+		if(ret) {
+			addr_string=mono_string_new(domain, buffer);
+			g_free(buffer);
+		}
+		else
+			addr_string=mono_string_new(domain, "");
+
+		mono_array_set(*h_addr_list, MonoString *, i, addr_string);
+
+		if(!i)
+			*h_name=mono_string_new(domain, ai->ai_canonname);
+
+		i++;
+	}
+
+	if(info)
+		freeaddrinfo(info);
+
+	return(TRUE);
+}
+#endif
+
 extern MonoBoolean ves_icall_System_Net_Dns_GetHostByName_internal(MonoString *host, MonoString **h_name, MonoArray **h_aliases, MonoArray **h_addr_list)
 {
 	char *hostname;
-	struct hostent *he;
 	
 	MONO_ARCH_SAVE_REGS;
 
 	hostname=mono_string_to_utf8(host);
+
+#if defined(AF_INET6) /* && defined(NET_1_1) */
+	struct addrinfo *info = NULL, hints;
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family		= get_family_hint ();
+	hints.ai_socktype	= SOCK_STREAM;
+	hints.ai_flags		= AI_CANONNAME;
+
+	if( getaddrinfo(hostname, NULL, &hints, &info) == -1 )
+		return FALSE;
+	g_free(hostname);
+
+	return(addrinfo_to_IPHostEntry(info, h_name, h_aliases, h_addr_list));
+#else
+	struct hostent *he;
+
 	he=gethostbyname(hostname);
 	g_free(hostname);
-	
+
 	if(he==NULL) {
 		return(FALSE);
 	}
 
 	return(hostent_to_IPHostEntry(he, h_name, h_aliases, h_addr_list));
+#endif
 }
 
 #ifndef HAVE_INET_PTON
@@ -1484,23 +1732,72 @@
 
 extern MonoBoolean ves_icall_System_Net_Dns_GetHostByAddr_internal(MonoString *addr, MonoString **h_name, MonoArray **h_aliases, MonoArray **h_addr_list)
 {
+	char *address;
+
+#if defined(AF_INET6) /* && defined(NET_1_1) */
+	struct sockaddr_in saddr;
+	struct sockaddr_in6 saddr6;
+	struct addrinfo *info = NULL, hints;
+	gint32 family;
+	char hostname[1024] = {0};
+#else
 	struct in_addr inaddr;
 	struct hostent *he;
-	char *address;
-	
+#endif
+
 	MONO_ARCH_SAVE_REGS;
 
 	address = mono_string_to_utf8 (addr);
+
+#if defined(AF_INET6) /* && defined(NET_1_1) */
+	if (inet_pton (AF_INET, address, &saddr.sin_addr ) <= 0) {
+		/* Maybe an ipv6 address */
+		if (inet_pton (AF_INET6, address, &saddr6.sin6_addr) <= 0) {
+			g_free (address);
+			return FALSE;
+		}
+		else {
+			family = AF_INET6;
+			saddr6.sin6_family = AF_INET6;
+		}
+	}
+	else {
+		family = AF_INET;
+		saddr.sin_family = AF_INET;
+	}
+	g_free(address);
+
+	if(family == AF_INET) {
+		if(getnameinfo((struct sockaddr*)&saddr, sizeof(saddr), hostname, sizeof(hostname), NULL, 0, NI_NAMEREQD) != 0)
+			return FALSE;
+	}
+	else if(family == AF_INET6) {
+		if(getnameinfo((struct sockaddr*)&saddr6, sizeof(saddr6), hostname, sizeof(hostname), NULL, 0, NI_NAMEREQD) != 0)
+			return FALSE;
+	}
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family		= get_family_hint ();
+	hints.ai_socktype	= SOCK_STREAM;
+	hints.ai_flags		= AI_CANONNAME;
+
+	if( getaddrinfo(hostname, NULL, &hints, &info) == -1 )
+		return FALSE;
+
+	return(addrinfo_to_IPHostEntry(info, h_name, h_aliases, h_addr_list));
+#else
 	if (inet_pton (AF_INET, address, &inaddr) <= 0) {
 		g_free (address);
 		return FALSE;
 	}
-	
 	g_free (address);
+
 	if ((he = gethostbyaddr ((char *) &inaddr, sizeof (inaddr), AF_INET)) == NULL)
 		return FALSE;
-	
+
 	return(hostent_to_IPHostEntry(he, h_name, h_aliases, h_addr_list));
+
+#endif
 }
 
 extern MonoBoolean ves_icall_System_Net_Dns_GetHostName_internal(MonoString **h_name)
diff -Nurd mono-cvs/mono/mono/metadata/socket-io.h mono-ipv6/mono/mono/metadata/socket-io.h
--- mono-cvs/mono/mono/metadata/socket-io.h	2002-10-03 11:13:56.000000000 +0200
+++ mono-ipv6/mono/mono/metadata/socket-io.h	2003-06-30 22:19:10.000000000 +0200
@@ -70,6 +70,7 @@
 	ProtocolType_Pup=12,
 	ProtocolType_Udp=17,
 	ProtocolType_Idp=22,
+	ProtocolType_IPv6=41,
 	ProtocolType_ND=77,
 	ProtocolType_Raw=255,
 	ProtocolType_Unspecified=0,
@@ -83,6 +84,7 @@
 typedef enum {
 	SocketOptionLevel_Socket=65535,
 	SocketOptionLevel_IP=0,
+	SocketOptionLevel_IPv6=41,
 	SocketOptionLevel_Tcp=6,
 	SocketOptionLevel_Udp=17,
 } MonoSocketOptionLevel;
