Index: class/System/Test/System.ComponentModel/TypeDescriptorTests.cs
===================================================================
--- class/System/Test/System.ComponentModel/TypeDescriptorTests.cs	(revision 61911)
+++ class/System/Test/System.ComponentModel/TypeDescriptorTests.cs	(working copy)
@@ -3,9 +3,12 @@
 //
 // Authors:
 // 	Lluis Sanchez Gual (lluis@ximian.com)
+//  Ivan N. Zlatev (contact i-nZ.net)
 //
 // (c) 2004 Novell, Inc. (http://www.ximian.com)
+// (c) 2006 Ivan N. Zlatev
 //
+
 using NUnit.Framework;
 using System;
 using System.Collections;
@@ -517,6 +520,32 @@
 			AssertEquals ("#1", 1, pc.Count);
 			AssertEquals ("#2", "Length", pc [0].Name);
 		}
+
+#if NET_2_0
+		[Test]
+		public void TestAssociations ()
+		{
+			Object x = new Object ();
+			ArrayList y = new ArrayList ();
+			Hashtable z = new Hashtable ();
+
+			AssertEquals ("#1", TypeDescriptor.GetAssociation (y.GetType (), x), x);
+			
+			TypeDescriptor.CreateAssociation (y, x);
+			TypeDescriptor.CreateAssociation (y, z);
+			TypeDescriptor.CreateAssociation (x, y);
+			TypeDescriptor.CreateAssociation (x, y);			
+			TypeDescriptor.CreateAssociation (x, z);
+			AssertEquals ("#2", TypeDescriptor.GetAssociation (y.GetType (), x), y);
+			AssertEquals ("#3", TypeDescriptor.GetAssociation (z.GetType (), x), z);
+			AssertEquals ("#4", TypeDescriptor.GetAssociation (z.GetType (), y), z);
+			TypeDescriptor.RemoveAssociations (y);
+			AssertEquals ("#5", TypeDescriptor.GetAssociation (z.GetType (), y), y);
+			TypeDescriptor.RemoveAssociation (x, z);
+			AssertEquals ("#6", TypeDescriptor.GetAssociation (z.GetType (), x), x);			
+		}
+#endif
+		
 	}
 }

Index: class/System/System.ComponentModel/TypeDescriptor.cs
===================================================================
--- class/System/System.ComponentModel/TypeDescriptor.cs	(revision 61911)
+++ class/System/System.ComponentModel/TypeDescriptor.cs	(working copy)
@@ -4,9 +4,11 @@
 // Authors:
 //   Gonzalo Paniagua Javier (gonzalo@ximian.com)
 //   Andreas Nahr (ClassDevelopment@A-SoftTech.com)
+//   Ivan N. Zlatev (contact i-nZ.net)
 //
 // (C) 2002 Ximian, Inc (http://www.ximian.com)
 // (C) 2003 Andreas Nahr
+// (C) 2006 Ivan N. Zlatev
 //
 
 //
@@ -47,6 +49,12 @@
 	private static Hashtable componentTable = new Hashtable ();
 	private static Hashtable typeTable = new Hashtable ();
 
+#if NET_2_0
+	private static WeakReferenceHashtable _associationTable;
+	private static WeakReferenceHashtable _providerTable;
+	private static object _lockObject = new Object ();
+#endif
+	
 	private TypeDescriptor ()
 	{
 	}
@@ -72,6 +80,214 @@
 		return null;
 	}
 
+	
+#if NET_2_0
+	
+	public static void AddProvider (TypeDescriptionProvider provider, Object instance)
+	{		
+		throw new NotImplementedException ();		
+	}
+
+	[MonoTODO]
+	public static void AddProvider (TypeDescriptionProvider provider, Type type)
+	{
+		throw new NotImplementedException ();		
+	}
+
+	[MonoTODO]
+	public static void RemoveProvider (TypeDescriptionProvider provider, Object instance)
+	{
+		throw new NotImplementedException ();
+	}
+	
+	[MonoTODO]
+	public static void RemoveProvider (TypeDescriptionProvider provider, Type type)
+	{
+		throw new NotImplementedException ();
+	}
+	
+	[MonoTODO]
+	public static string GetFullComponentName (Object component)
+	{
+		throw new NotImplementedException ();
+	}
+
+	// MSDN2 says associations are kept as weakreferences, so we keep them
+	// in a special weakreferencehashtable, where the key is the primary object and
+	// the value is an arraylist of all associations to the object
+	//
+	public static void CreateAssociation (object primary, object secondary)
+	{
+		if (primary == null) {
+			throw new ArgumentNullException ("primary");
+		}
+		if (secondary == null) {
+			throw new ArgumentNullException ("secondary");
+		}
+		if (primary == secondary) {
+			throw new ArgumentException ("primary == secondary");
+		}
+
+		if (_associationTable == null) {			
+			lock (_lockObject) {
+				if (_associationTable == null) {
+					_associationTable = new WeakReferenceHashtable ();
+				}
+			}
+		}
+
+		ArrayList associations = _associationTable[primary] as ArrayList;
+
+		// no association? -> create one
+		if (associations == null) {
+			ArrayList newAssociation = new ArrayList ();
+			newAssociation.Add (new WeakReference (secondary));
+			
+			lock (_associationTable) {
+				_associationTable[primary] = newAssociation;
+			}
+		}
+		else {    // Append to the list of existing associations
+			bool exists = false;
+			
+			lock (associations) {
+				for (int i = 0; i < associations.Count; i++) {
+					WeakReference wref = (WeakReference) associations[i];
+					if (wref.IsAlive && wref.Target == secondary) {
+						exists = true;
+						break;
+					}
+				}
+			
+				if (exists == true) {
+					// Should we trow an exception here?
+				}
+				else {
+					associations.Add (new WeakReference (secondary));
+				}
+			}					
+		}
+	}
+
+		// never return null
+	public static object GetAssociation (Type type, object primary)
+	{
+		if (type == null) {
+			throw new ArgumentNullException ("type");
+		}
+		if (primary == null) {
+			throw new ArgumentNullException ("primary");
+		}
+
+		object result = primary;
+
+		// try to find an association in the internal table
+		if (_associationTable != null) {
+			ArrayList associations = (ArrayList) _associationTable[primary];
+			
+			if (associations != null) {
+				lock (associations) {
+					for (int i = 0; i < associations.Count; i++) {						
+						WeakReference wref = (WeakReference) associations[i];
+						object o = wref.Target;
+
+						if (o == null) {
+							associations.RemoveAt(i);
+						}
+						else if (type.IsInstanceOfType (o)) {
+							result = o;
+						}
+					}
+				}
+			}
+		}
+
+		// if there was no association found in the table try to retrieve a designer
+		if (result == primary) {
+			IComponent component = primary as IComponent;
+			if (component != null) {
+				ISite site = component.Site;
+				if (site != null && site.DesignMode) {
+					IDesignerHost host = site.GetService (typeof (IDesignerHost)) as IDesignerHost;
+					if (host != null) {
+						object designer = host.GetDesigner (component);
+						if (designer != null && type.IsInstanceOfType (designer)) {
+							result = designer;
+						}
+					}
+				}
+			}
+		}
+		
+		return result;
+	}
+
+	
+	public static void RemoveAssociations (object primary)
+	{
+		lock (_associationTable) {
+			_associationTable.Remove (primary);
+		}
+	}
+
+	
+	public static void RemoveAssociation (object primary, object secondary)
+	{
+		if (_associationTable != null) {
+			ArrayList associations = _associationTable[primary] as ArrayList;
+			if (associations != null) {
+				lock (associations) {
+					for (int i = 0; i < associations.Count; i++) {						
+						WeakReference wref = (WeakReference) associations[i];
+						object o = wref.Target;
+
+						if (o == null) {
+							associations.RemoveAt(i);
+						}
+						else if (o == secondary) {
+							associations.RemoveAt(i);
+						}
+					}
+				}
+			}						
+		}
+	}
+			
+
+	
+	[MonoTODO]
+	public static object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args)
+	{
+		object result = null;
+		
+		if (objectType == null) {
+			throw new ArgumentNullException ("objectType");
+		}
+		if (args == null) {
+			throw new ArgumentNullException ("args");
+		}
+		if (argTypes.Length != args.Length) {
+			throw new ArgumentException ("argTypes.Length != args.Length");
+		}
+		
+		if (provider != null) {
+			TypeDescriptionProvider typeDProv = provider.GetService (typeof (TypeDescriptionProvider)) as TypeDescriptionProvider;
+			if (typeDProv != null) {
+				result = typeDProv.CreateInstance (provider, objectType, argTypes, args);
+			}
+		}
+		else {
+			
+			// TODO TODO TODO: Implement type providers
+			throw new System.NotImplementedException ();
+		}
+
+		return result;
+	}
+	
+#endif
+
+	
 	public static EventDescriptor CreateEvent (Type componentType,
 						   string name,
 						   Type type,
