Index: mini.c
===================================================================
--- mini.c	(revision 37909)
+++ mini.c	(working copy)
@@ -981,6 +981,9 @@
 
 handle_enum:
 	switch (type->type) {
+	case MONO_TYPE_VOID:
+		inst->type = STACK_INV;
+		return;
 	case MONO_TYPE_I1:
 	case MONO_TYPE_U1:
 	case MONO_TYPE_BOOLEAN:
@@ -2035,7 +2038,8 @@
 	call->args = args;
 	call->signature = sig;
 	call = mono_arch_call_opcode (cfg, bblock, call, virtual);
-
+	type_to_eval_stack_type (sig->ret, &call->inst);
+	
 	for (arg = call->out_args; arg;) {
 		MonoInst *narg = arg->next;
 		arg->next = NULL;
@@ -2828,10 +2832,24 @@
 	return 1;
 }
 
+static gboolean
+ip_in_bb (MonoCompile *cfg, MonoBasicBlock *bb, const guint8* ip)
+{
+	MonoBasicBlock *b = g_hash_table_lookup (cfg->bb_hash, ip);
+	
+	return b == NULL || b == bb;
+}
+
 static MonoInst*
-emit_tree (MonoCompile *cfg, MonoBasicBlock *bblock, MonoInst *ins)
+emit_tree (MonoCompile *cfg, MonoBasicBlock *bblock, MonoInst *ins, const guint8* ip_next)
 {
 	MonoInst *store, *temp, *load;
+	
+	if (ip_in_bb (cfg, bblock, ip_next) &&
+		(CODE_IS_STLOC (ip_next) || *ip_next == CEE_BRTRUE || *ip_next == CEE_BRFALSE ||
+		*ip_next == CEE_BRTRUE_S || *ip_next == CEE_BRFALSE_S || *ip_next == CEE_RET))
+			return ins;
+	
 	temp = mono_compile_create_var (cfg, type_from_stack_type (ins), OP_LOCAL);
 	NEW_TEMPSTORE (cfg, store, temp->inst_c0, ins);
 	store->cil_code = ins->cil_code;
@@ -3695,7 +3713,11 @@
 				}
 
 			} else {
-				if (0 && CODE_IS_STLOC (ip + 5) && (!MONO_TYPE_ISSTRUCT (fsig->ret)) && (!MONO_TYPE_IS_VOID (fsig->ret) || cmethod->string_ctor)) {
+				if (ip_in_bb (cfg, bblock, ip + 5) 
+				    && (!MONO_TYPE_ISSTRUCT (fsig->ret))
+				    && (!MONO_TYPE_IS_VOID (fsig->ret) || cmethod->string_ctor)
+				    && (CODE_IS_STLOC (ip + 5) || ip [5] == CEE_POP || ip [5] == CEE_BRTRUE || ip [5] == CEE_BRFALSE ||
+					ip [5] == CEE_BRTRUE_S || ip [5] == CEE_BRFALSE_S || ip [5] == CEE_RET)) {
 					/* no need to spill */
 					ins = (MonoInst*)mono_emit_method_call (cfg, bblock, cmethod, fsig, sp, ip, virtual ? sp [0] : NULL);
 					*sp++ = ins;
@@ -3969,7 +3991,7 @@
 			}
 			if (mono_find_jit_opcode_emulation (ins->opcode)) {
 				--sp;
-				*sp++ = emit_tree (cfg, bblock, ins);
+				*sp++ = emit_tree (cfg, bblock, ins, ip + 1);
 			}
 			ip++;
 			break;
@@ -3990,7 +4012,7 @@
 			ADD_UNOP (*ip);
 			if (mono_find_jit_opcode_emulation (ins->opcode)) {
 				--sp;
-				*sp++ = emit_tree (cfg, bblock, ins);
+				*sp++ = emit_tree (cfg, bblock, ins, ip + 1);
 			}
 			ip++;			
 			break;
@@ -4322,7 +4344,7 @@
 				ins->inst_left = *sp;
 				ins->inst_newa_class = klass;
 				ins->cil_code = ip;
-				*sp++ = emit_tree (cfg, bblock, ins);
+				*sp++ = emit_tree (cfg, bblock, ins, ip + 5);
 				ip += 5;
 			}
 			break;
@@ -4506,7 +4528,7 @@
 				ins->klass = klass;
 				ins->inst_newa_class = klass;
 				ins->cil_code = ip;
-				*sp++ = emit_tree (cfg, bblock, ins);
+				*sp++ = emit_tree (cfg, bblock, ins, ip + 5);
 				ip += 5;
 			}
 			break;
@@ -5254,7 +5276,7 @@
 			ADD_BINOP (*ip);
 			if (mono_find_jit_opcode_emulation (ins->opcode)) {
 				--sp;
-				*sp++ = emit_tree (cfg, bblock, ins);
+				*sp++ = emit_tree (cfg, bblock, ins, ip + 1);
 			}
 			ip++;
 			break;
@@ -5489,7 +5511,7 @@
 				ins->inst_left = *sp;
 				ins->inst_newa_class = klass;
 				ins->cil_code = ip;
-				*sp++ = emit_tree (cfg, bblock, ins);
+				*sp++ = emit_tree (cfg, bblock, ins, ip + 6);
 				ip += 6;
 				break;
 			}
@@ -5566,7 +5588,7 @@
 				 */
 				if (cmp->inst_left->type == STACK_I8) {
 					--sp;
-					*sp++ = emit_tree (cfg, bblock, ins);
+					*sp++ = emit_tree (cfg, bblock, ins, ip + 2);
 				}
 				ip += 2;
 				break;
