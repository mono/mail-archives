//
// Mono.Posix/PosixStream.cs
//
// Authors:
//   Jonathan Pryor (jonpryor@vt.edu)
//
// (C) 2004 Jonathan Pryor
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.IO;
using System.Runtime.InteropServices;
using Mono.Posix;

internal sealed class Locale {
	public static string GetText (string msg)
	{
		return msg;
	}

	public static string GetText (string fmt, params object[] args)
	{
		return string.Format (fmt, args);
	}
}

namespace Mono.Posix {

	public sealed class MapAttribute : Attribute {}
	
	[Map]
	public enum SeekFlags {
		// values liberally copied from /usr/include/unistd.h
		SEEK_SET = 0, /* Seek from beginning of file.  */
		SEEK_CUR = 1, /* Seek from current position.  */
		SEEK_END = 2, /* Seek from end of file.  */
	}
	
	public class PosixException : IOException {
		public PosixException ()
			: this (Marshal.GetLastWin32Error())
		{}
		
		public PosixException (int error)
		{
			this.error = error;
		}
		
		public int NativeErrorCode {
			get {return error;}
		}
		
		public Errors ErrorCode {
			get {return PosixStream.ConvertError (error);}
		}
		private int error;
	}
	
	[Map]
	public enum Errors {
		// errors & their values liberally copied from
		// FC2 /usr/include/asm/errno.h
		
		EPERM		 = 1,	/* Operation not permitted */
		ENOENT		 = 2,	/* No such file or directory */
		ESRCH		 = 3,	/* No such process */
		EINTR		 = 4,	/* Interrupted system call */
		EIO		 = 5,	/* I/O error */
		ENXIO		 = 6,	/* No such device or address */
		E2BIG		 = 7,	/* Arg list too long */
		ENOEXEC		 = 8,	/* Exec format error */
		EBADF		 = 9,	/* Bad file number */
		ECHILD		= 10,	/* No child processes */
		EAGAIN		= 11,	/* Try again */
		ENOMEM		= 12,	/* Out of memory */
		EACCES		= 13,	/* Permission denied */
		EFAULT		= 14,	/* Bad address */
		ENOTBLK		= 15,	/* Block device required */
		EBUSY		= 16,	/* Device or resource busy */
		EEXIST		= 17,	/* File exists */
		EXDEV		= 18,	/* Cross-device link */
		ENODEV		= 19,	/* No such device */
		ENOTDIR		= 20,	/* Not a directory */
		EISDIR		= 21,	/* Is a directory */
		EINVAL		= 22,	/* Invalid argument */
		ENFILE		= 23,	/* File table overflow */
		EMFILE		= 24,	/* Too many open files */
		ENOTTY		= 25,	/* Not a typewriter */
		ETXTBSY		= 26,	/* Text file busy */
		EFBIG		= 27,	/* File too large */
		ENOSPC		= 28,	/* No space left on device */
		ESPIPE		= 29,	/* Illegal seek */
		EROFS		= 30,	/* Read-only file system */
		EMLINK		= 31,	/* Too many links */
		EPIPE		= 32,	/* Broken pipe */
		EDOM		= 33,	/* Math argument out of domain of func */
		ERANGE		= 34,	/* Math result not representable */
		EDEADLK		= 35,	/* Resource deadlock would occur */
		ENAMETOOLONG	= 36,	/* File name too long */
		ENOLCK		= 37,	/* No record locks available */
		ENOSYS		= 38,	/* Function not implemented */
		ENOTEMPTY	= 39,	/* Directory not empty */
		ELOOP		= 40,	/* Too many symbolic links encountered */
		EWOULDBLOCK	= EAGAIN,	/* Operation would block */
		ENOMSG		= 42,	/* No message of desired type */
		EIDRM		= 43,	/* Identifier removed */
		ECHRNG		= 44,	/* Channel number out of range */
		EL2NSYNC	= 45,	/* Level 2 not synchronized */
		EL3HLT		= 46,	/* Level 3 halted */
		EL3RST		= 47,	/* Level 3 reset */
		ELNRNG		= 48,	/* Link number out of range */
		EUNATCH		= 49,	/* Protocol driver not attached */
		ENOCSI		= 50,	/* No CSI structure available */
		EL2HLT		= 51,	/* Level 2 halted */
		EBADE		= 52,	/* Invalid exchange */
		EBADR		= 53,	/* Invalid request descriptor */
		EXFULL		= 54,	/* Exchange full */
		ENOANO		= 55,	/* No anode */
		EBADRQC		= 56,	/* Invalid request code */
		EBADSLT		= 57,	/* Invalid slot */

		EDEADLOCK	= EDEADLK,

		EBFONT		= 59,	/* Bad font file format */
		ENOSTR		= 60,	/* Device not a stream */
		ENODATA		= 61,	/* No data available */
		ETIME		= 62,	/* Timer expired */
		ENOSR		= 63,	/* Out of streams resources */
		ENONET		= 64,	/* Machine is not on the network */
		ENOPKG		= 65,	/* Package not installed */
		EREMOTE		= 66,	/* Object is remote */
		ENOLINK		= 67,	/* Link has been severed */
		EADV		= 68,	/* Advertise error */
		ESRMNT		= 69,	/* Srmount error */
		ECOMM		= 70,	/* Communication error on send */
		EPROTO		= 71,	/* Protocol error */
		EMULTIHOP	= 72,	/* Multihop attempted */
		EDOTDOT		= 73,	/* RFS specific error */
		EBADMSG		= 74,	/* Not a data message */
		EOVERFLOW	= 75,	/* Value too large for defined data type */
		ENOTUNIQ	= 76,	/* Name not unique on network */
		EBADFD		= 77,	/* File descriptor in bad state */
		EREMCHG		= 78,	/* Remote address changed */
		ELIBACC		= 79,	/* Can not access a needed shared library */
		ELIBBAD		= 80,	/* Accessing a corrupted shared library */
		ELIBSCN		= 81,	/* .lib section in a.out corrupted */
		ELIBMAX		= 82,	/* Attempting to link in too many shared libraries */
		ELIBEXEC	= 83,	/* Cannot exec a shared library directly */
		EILSEQ		= 84,	/* Illegal byte sequence */
		ERESTART	= 85,	/* Interrupted system call should be restarted */
		ESTRPIPE	= 86,	/* Streams pipe error */
		EUSERS		= 87,	/* Too many users */
		ENOTSOCK	= 88,	/* Socket operation on non-socket */
		EDESTADDRREQ	= 89,	/* Destination address required */
		EMSGSIZE	= 90,	/* Message too long */
		EPROTOTYPE	= 91,	/* Protocol wrong type for socket */
		ENOPROTOOPT	= 92,	/* Protocol not available */
		EPROTONOSUPPORT	= 93,	/* Protocol not supported */
		ESOCKTNOSUPPORT	= 94,	/* Socket type not supported */
		EOPNOTSUPP	= 95,	/* Operation not supported on transport endpoint */
		EPFNOSUPPORT	= 96,	/* Protocol family not supported */
		EAFNOSUPPORT	= 97,	/* Address family not supported by protocol */
		EADDRINUSE	= 98,	/* Address already in use */
		EADDRNOTAVAIL	= 99,	/* Cannot assign requested address */
		ENETDOWN	= 100,	/* Network is down */
		ENETUNREACH	= 101,	/* Network is unreachable */
		ENETRESET	= 102,	/* Network dropped connection because of reset */
		ECONNABORTED	= 103,	/* Software caused connection abort */
		ECONNRESET	= 104,	/* Connection reset by peer */
		ENOBUFS		= 105,	/* No buffer space available */
		EISCONN		= 106,	/* Transport endpoint is already connected */
		ENOTCONN	= 107,	/* Transport endpoint is not connected */
		ESHUTDOWN	= 108,	/* Cannot send after transport endpoint shutdown */
		ETOOMANYREFS	= 109,	/* Too many references: cannot splice */
		ETIMEDOUT	= 110,	/* Connection timed out */
		ECONNREFUSED	= 111,	/* Connection refused */
		EHOSTDOWN	= 112,	/* Host is down */
		EHOSTUNREACH	= 113,	/* No route to host */
		EALREADY	= 114,	/* Operation already in progress */
		EINPROGRESS	= 115,	/* Operation now in progress */
		ESTALE		= 116,	/* Stale NFS file handle */
		EUCLEAN		= 117,	/* Structure needs cleaning */
		ENOTNAM		= 118,	/* Not a XENIX named type file */
		ENAVAIL		= 119,	/* No XENIX semaphores available */
		EISNAM		= 120,	/* Is a named type file */
		EREMOTEIO	= 121,	/* Remote I/O error */
		EDQUOT		= 122,	/* Quota exceeded */

		ENOMEDIUM	= 123,	/* No medium found */
		EMEDIUMTYPE	= 124,	/* Wrong medium type */
	}
	
	public sealed class PosixStream : Stream, IDisposable
	{
		// BEGIN MOVE TO Syscall.cs
		public static Errors ConvertError (int error)
		{
			// TODO: Fix me
			return (Errors) error;
		}
		
		public static Errors GetLastError ()
		{
			return ConvertError (Marshal.GetLastWin32Error());
		}
		// END MOVE TO Syscall.cs
		
		public const int InvalidFileDescriptor = -1;
		public const int StandardInputFileDescriptor = 0;
		public const int StandardOutputFileDescriptor = 1;
		public const int StandardErrorFileDescriptor = 2;

		public PosixStream (int fileDescriptor)
			: this (fileDescriptor, true) {}

		public PosixStream (int fileDescriptor, bool ownsHandle)
		{
			if (InvalidFileDescriptor == fileDescriptor)
				throw new ArgumentException ("fileDescriptor", Locale.GetText ("Invalid"));
			
			this.fileDescriptor = fileDescriptor;
			this.owner = ownsHandle;
			
			int offset = Syscall.lseek (fileDescriptor, 0, (int) SeekFlags.SEEK_CUR);
			if (offset != -1)
				canSeek = true;
			IntPtr read = Syscall.read (fileDescriptor, null, (IntPtr) 0);
			if (read != (IntPtr) (-1))
				canRead = true;
			IntPtr write = Syscall.write (fileDescriptor, null, (IntPtr) 0);
			if (write != (IntPtr) (-1))
				canWrite = true;  
		}

		public int FileDescriptor {
			get {return fileDescriptor;}
		}

		public override bool CanRead {
			get {return canRead;}
		}

		public override bool CanSeek {
			get {return canSeek;}
		}

		public override bool CanWrite {
			get {return canWrite;}
		}

		public override long Length {
			get {
				/* requires Mono.Posix changes
				Stat stat;
				Syscall.fstat (fileDescriptor, out stat);
				return stat.Size;
				 */
				throw new NotImplementedException ();
			}
		}

		public override long Position {
			get {
				if (fileDescriptor == InvalidFileDescriptor)
					throw new ObjectDisposedException ("File Descriptor has been closed");
				if (!CanSeek)
					throw new NotSupportedException ("The stream does not support seeking");
				int pos = Syscall.lseek (fileDescriptor, 0, (int) SeekFlags.SEEK_CUR);
				if (pos == -1)
					throw new PosixException ();
				return pos;
			}
			set {
				Seek (value, SeekOrigin.Begin);
			}
		}

		public override void Flush ()
		{
			/* TODO: 
			int err = Syscall.fsync (fileDescriptor);
			if (err == -1)
				throw new PosixException ();
			 */
			throw new NotImplementedException ();
		}

		public override unsafe int Read ([In, Out] byte[] buffer, int offset, int count)
		{
			if (fileDescriptor == InvalidFileDescriptor)
				throw new ObjectDisposedException ("Stream has been closed");
			if (buffer == null)
				throw new ArgumentNullException ("buffer");
			if (!CanRead)
				throw new NotSupportedException ("Stream does not support reading");
			if (offset < 0)
				throw new ArgumentOutOfRangeException ("offset", "< 0");
			if (count < 0)
				throw new ArgumentOutOfRangeException ("count", "< 0");
			if (offset > buffer.Length)
				throw new ArgumentException ("destination offset is beyond array size");
			if (offset > (buffer.Length - count))
				throw new ArgumentException ("Reading would overrun buffer");
				 
			IntPtr r = IntPtr.Zero;
			fixed (byte* buf = &buffer[offset]) {
				do {
					r = Syscall.read (fileDescriptor, buf, (IntPtr) count);
				}	while (r == (IntPtr) (-1) && GetLastError() == Errors.EINTR);
			}
			if (r == (IntPtr)(-1))
				throw new PosixException ();
			checked {return (int) r;}
		}

		public override long Seek (long offset, SeekOrigin origin)
		{
			if (fileDescriptor == InvalidFileDescriptor)
				throw new ObjectDisposedException ("File Descriptor has been closed");
			if (!CanSeek)
				throw new NotSupportedException ("The File Descriptor does not support seeking");
			if (offset > int.MaxValue)
				throw new ArgumentOutOfRangeException ("offset", "too large");
					
			SeekFlags sf = SeekFlags.SEEK_CUR;
			switch (origin) {
				case SeekOrigin.Begin:   sf = SeekFlags.SEEK_SET; break;
				case SeekOrigin.Current: sf = SeekFlags.SEEK_CUR; break;
				case SeekOrigin.End:     sf = SeekFlags.SEEK_END; break;
			}

			int pos = Syscall.lseek (fileDescriptor, (int) offset, (int) sf);
			if (pos == -1)
				throw new PosixException ();
			return pos;
		}

		public override void SetLength (long value)
		{
			if (fileDescriptor == InvalidFileDescriptor)
				throw new ObjectDisposedException ("File Descriptor has been closed");
			if (value > int.MaxValue)
				throw new ArgumentOutOfRangeException ("value", "too large");
			if (value < 0)
				throw new ArgumentOutOfRangeException ("value", "< 0");
			
			/* TODO: need ftruncate in Syscall
			int r = Syscall.ftruncate (fileDescriptor, (int) value);
			if (r == -1)
				throw new PosixException ();
			 */
			throw new NotImplementedException ();
		}

		public override unsafe void Write (byte[] buffer, int offset, int count)
		{
			if (fileDescriptor == InvalidFileDescriptor)
				throw new ObjectDisposedException("File Descriptor has been closed");
			if (buffer == null)
				throw new ArgumentNullException ("buffer");
			if (offset < 0)
				throw new ArgumentOutOfRangeException ("offset", "< 0");
			if (count < 0)
				throw new ArgumentOutOfRangeException ("count", "< 0");
			if (offset > buffer.Length - count)
				throw new ArgumentException ("Writing would overrun buffer");
			if (!CanWrite)
				throw new NotSupportedException ("File Descriptor does not support writing");

			IntPtr r = IntPtr.Zero;
			fixed (byte* buf = &buffer[offset]) {
				do {
					r = Syscall.write (fileDescriptor, buf, (IntPtr) count);
				}	while (r == (IntPtr)(-1) && GetLastError() == Errors.EINTR);
			}
			if (r == (IntPtr)(-1))
				throw new PosixException ();
		}
		
		~PosixStream ()
		{
			Close ();
		}

		public override void Close ()
		{
			if (fileDescriptor == InvalidFileDescriptor)
				return;
				
			// Flush ();
			int r;
			do {
				r = Syscall.close (fileDescriptor);
			} while (r == -1 && GetLastError() == Errors.EINTR);
			Console.WriteLine ("file closed!");
			if (r == -1)
				throw new PosixException ();
			fileDescriptor = InvalidFileDescriptor;
		}
		
		void IDisposable.Dispose ()
		{
			if (fileDescriptor == InvalidFileDescriptor)
				throw new ObjectDisposedException ("File Descriptor has been closed");
			if (owner) {
				Close ();
			}
		}

		private bool canSeek = false;
		private bool canRead = false;
		private bool canWrite = false;
		private bool owner = true;
		private int fileDescriptor = InvalidFileDescriptor;
	}
}

// vim: noexpandtab
