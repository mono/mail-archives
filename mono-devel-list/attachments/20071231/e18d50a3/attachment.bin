Index: System.Reflection.Emit/ChangeLog
===================================================================
--- System.Reflection.Emit/ChangeLog	(revision 92059)
+++ System.Reflection.Emit/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2007-12-31  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* AssemblyBuilder.cs (UnprotectedGetName): Set the public key token
+	as well.
+
 2007-12-10  Zoltan Varga  <vargaz@gmail.com>
 
 	* FieldBuilder.cs (GetToken): Use the MetadataToken property.
Index: System.Reflection.Emit/AssemblyBuilder.cs
===================================================================
--- System.Reflection.Emit/AssemblyBuilder.cs	(revision 92059)
+++ System.Reflection.Emit/AssemblyBuilder.cs	(working copy)
@@ -912,6 +912,7 @@
 			AssemblyName an = base.UnprotectedGetName ();
 			if (sn != null) {
 				an.SetPublicKey (sn.PublicKey);
+				an.SetPublicKeyToken (sn.PublicKeyToken);
 			}
 			return an;
 		}
Index: Test/System.Reflection.Emit/ChangeLog
===================================================================
--- Test/System.Reflection.Emit/ChangeLog	(revision 92059)
+++ Test/System.Reflection.Emit/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2007-12-31  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* AssemblyBuilderTest.cs: Improved existing AssemblyName related tests.
+	Enabled AssemblyName tests that previously failed.
+
 2007-12-29  Gert Driesen  <drieseng@users.sourceforge.net>
 
 	* TypeBuilderTest.cs: Added tests for GetConstructor(s), GetEvent(s),
Index: Test/System.Reflection.Emit/AssemblyBuilderTest.cs
===================================================================
--- Test/System.Reflection.Emit/AssemblyBuilderTest.cs	(revision 92059)
+++ Test/System.Reflection.Emit/AssemblyBuilderTest.cs	(working copy)
@@ -108,17 +108,15 @@
 		ModuleBuilder mb1 = (ModuleBuilder) ab.ManifestModule;
 		Assert.AreSame (mb1, ab.GetModules () [0], "#B1");
 		Assert.IsFalse (mb1.IsResource (), "#B2");
-		Assert.AreSame (ab, mb1.Assembly, "#B3");
-		Assert.AreSame (mb1, ab.ManifestModule, "#B4");
+		Assert.AreSame (mb1, ab.ManifestModule, "#B3");
 
 		ab.Save ("ManifestModule.dll");
 
 		ModuleBuilder mb2 = (ModuleBuilder) ab.ManifestModule;
 		Assert.AreSame (mb2, ab.GetModules () [0], "#C1");
 		Assert.IsFalse (mb2.IsResource (), "#C2");
-		Assert.AreSame (ab, mb2.Assembly, "#C3");
-		Assert.AreSame (mb2, ab.ManifestModule, "#C4");
-		Assert.AreSame (mb1, mb2, "#C5");
+		Assert.AreSame (mb2, ab.ManifestModule, "#C3");
+		Assert.AreSame (mb1, mb2, "#C4");
 	}
 #endif
 
@@ -776,7 +774,20 @@
 		AssemblyName check = AssemblyName.GetAssemblyName (filename);
 		// no exception is thrown (file not found)
 		// because it's not AssemblyBuilder.Save job to do the signing :-/
-		Assert.IsNull (check.GetPublicKeyToken (), "Token");
+#if NET_2_0
+		Assert.AreEqual (AssemblyNameFlags.None, check.Flags, "#1");
+		Assert.IsNull (check.GetPublicKey (), "#2");
+		Assert.IsNotNull (check.GetPublicKeyToken (), "#3a");
+		Assert.AreEqual (0, check.GetPublicKeyToken ().Length, "#3b");
+#else
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, check.Flags, "#1");
+		Assert.IsNotNull (check.GetPublicKey (), "#2a");
+		Assert.AreEqual (0, check.GetPublicKey ().Length, "#2b");
+		Assert.IsNull (check.GetPublicKeyToken (), "#3");
+#endif
+		Assert.IsTrue (check.FullName.IndexOf ("Version=0.0.0.0") != -1, "#4");
+		Assert.IsTrue (check.FullName.IndexOf ("Culture=neutral") != -1, "#5");
+		Assert.IsTrue (check.FullName.IndexOf ("PublicKeyToken=null") != -1, "#6");
 	}
 
 	[Test]
@@ -795,7 +806,20 @@
 		AssemblyName check = AssemblyName.GetAssemblyName (filename);
 		// no public key is inserted into the assembly
 		// because it's not AssemblyBuilder.Save job to do the signing :-/
-		Assert.IsNull (check.GetPublicKeyToken (), "Token");
+#if NET_2_0
+		Assert.AreEqual (AssemblyNameFlags.None, check.Flags, "#1");
+		Assert.IsNull (check.GetPublicKey (), "#2");
+		Assert.IsNotNull (check.GetPublicKeyToken (), "#3a");
+		Assert.AreEqual (0, check.GetPublicKeyToken ().Length, "#3b");
+#else
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, check.Flags, "#1");
+		Assert.IsNotNull (check.GetPublicKey (), "#2a");
+		Assert.AreEqual (0, check.GetPublicKey ().Length, "#2b");
+		Assert.IsNull (check.GetPublicKeyToken (), "#3");
+#endif
+		Assert.IsTrue (check.FullName.IndexOf ("Version=0.0.0.0") != -1, "#4");
+		Assert.IsTrue (check.FullName.IndexOf ("Culture=neutral") != -1, "#5");
+		Assert.IsTrue (check.FullName.IndexOf ("PublicKeyToken=null") != -1, "#6");
 	}
 
 	[Test]
@@ -810,7 +834,14 @@
 
 		string filename = Path.Combine (tempDir, "StrongName_WithoutAttributes.dll");
 		AssemblyName check = AssemblyName.GetAssemblyName (filename);
-		Assert.AreEqual ("0E-EA-7C-E6-5F-35-F2-D8", BitConverter.ToString (check.GetPublicKeyToken ()), "Token");
+		Assert.IsNotNull (check.GetPublicKey (), "#1a");
+		Assert.IsTrue (check.GetPublicKey ().Length > 0, "#1b");
+		Assert.AreEqual ("0E-EA-7C-E6-5F-35-F2-D8", BitConverter.ToString (check.GetPublicKeyToken ()), "#2");
+
+		Assert.IsTrue (check.FullName.IndexOf ("Version=0.0.0.0") != -1, "#3");
+		Assert.IsTrue (check.FullName.IndexOf ("Culture=neutral") != -1, "#4");
+		Assert.IsTrue (check.FullName.IndexOf ("PublicKeyToken=0eea7ce65f35f2d8") != -1, "#5");
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, check.Flags, "#6");
 	}
 
 	[Test]
@@ -849,7 +880,6 @@
 	}
 
 	[Test]
-	[Category ("NotWorking")]
 	public void AssemblyName_Culture ()
 	{
 		AssemblyName assemblyName = new AssemblyName ();
@@ -871,7 +901,7 @@
 		assemblyName.Version = new Version ("1.2.3.4");
 		assemblyName.KeyPair = new StrongNameKeyPair (strongName);
 
-		Assert.AreEqual ("AssemblyNameTest_PublicKey, Version=1.2.3.4", assemblyName.FullName, "#1");
+		Assert.AreEqual ("AssemblyNameTest_PublicKey, Version=1.2.3.4", assemblyName.FullName, "#A1");
 
 		const string fullName = "AssemblyNameTest_PublicKey, Version=1.2.3.4, Culture=neutral, PublicKeyToken=0eea7ce65f35f2d8";
 
@@ -879,22 +909,32 @@
 			assemblyName, AssemblyBuilderAccess.Save, tempDir);
 
 		AssemblyName abName = ab.GetName ();
-		Assert.IsNotNull (abName.GetPublicKeyToken (), "#2");
-		Assert.IsTrue (abName.GetPublicKeyToken ().Length > 0, "#3");
-		Assert.IsNotNull (abName.GetPublicKey () != null, "#4");
-		Assert.IsTrue (abName.GetPublicKey ().Length > 0, "#5");
+		Assert.AreEqual (CultureInfo.InvariantCulture, abName.CultureInfo, "#B1");
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, abName.Flags, "#B2");
+		Assert.IsNotNull (abName.GetPublicKey () != null, "#B3a");
+		Assert.IsTrue (abName.GetPublicKey ().Length > 0, "#B3b");
+		Assert.IsNotNull (abName.GetPublicKeyToken (), "#B4a");
+		Assert.IsTrue (abName.GetPublicKeyToken ().Length > 0, "#B4b");
+#if NET_2_0
+		Assert.AreEqual (fullName, abName.FullName, "#B5");
+#else
+		//Assert.AreEqual ("AssemblyNameTest_PublicKey, Version=1.2.3.4, PublicKeyToken=0eea7ce65f35f2d8", abName.FullName, "#B5");
+		Assert.IsTrue (abName.FullName.IndexOf ("AssemblyNameTest_PublicKey, Version=1.2.3.4") != -1, "#B5a");
+		Assert.IsTrue (abName.FullName.IndexOf ("PublicKeyToken=0eea7ce65f35f2d8") != -1, "#B5b");
+#endif
 
 		ab.Save ("AssemblyNameTest_PublicKey.dll");
 		AssemblyName bakedName = AssemblyName.GetAssemblyName (Path.Combine(
 			tempDir, "AssemblyNameTest_PublicKey.dll"));
 
-		Assert.IsNotNull (bakedName.GetPublicKeyToken (), "#6");
-		Assert.IsNotNull (bakedName.GetPublicKey (), "#7");
-		Assert.AreEqual (fullName, bakedName.FullName, "#8");
+		Assert.AreEqual (CultureInfo.InvariantCulture, bakedName.CultureInfo, "#C1");
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, bakedName.Flags, "#C2");
+		Assert.IsNotNull (bakedName.GetPublicKeyToken (), "#32");
+		Assert.IsNotNull (bakedName.GetPublicKey (), "#C4");
+		Assert.AreEqual (fullName, bakedName.FullName, "#C5");
 	}
 
 	[Test]
-	[Category ("NotWorking")] 
 	public void AssemblyName_MoreCultureInfo ()
 	{
 		AssemblyName assemblyName = new AssemblyName ();
@@ -902,8 +942,8 @@
 		assemblyName.Version = new Version ("1.2.3.4");
 		assemblyName.KeyPair = new StrongNameKeyPair (strongName);
 
-		Assert.IsNull (assemblyName.CultureInfo, "#1");
-		Assert.AreEqual ("AssemblyNameTest_MoreCultureInfo, Version=1.2.3.4", assemblyName.FullName, "#2");
+		Assert.IsNull (assemblyName.CultureInfo, "#A1");
+		Assert.AreEqual ("AssemblyNameTest_MoreCultureInfo, Version=1.2.3.4", assemblyName.FullName, "#A2");
 
 		const string fullName = "AssemblyNameTest_MoreCultureInfo, Version=1.2.3.4, Culture=neutral, PublicKeyToken=0eea7ce65f35f2d8";
 
@@ -911,14 +951,18 @@
 			assemblyName, AssemblyBuilderAccess.Save, tempDir);
 
 		AssemblyName abName = ab.GetName ();
-		Assert.IsNotNull (abName.CultureInfo != null, "#3");
+		Assert.IsNotNull (abName.CultureInfo != null, "#B1");
 #if NET_2_0
-		Assert.IsTrue (abName.CultureInfo != CultureInfo.InvariantCulture, "#4");
-		Assert.AreEqual (CultureInfo.InvariantCulture.LCID, abName.CultureInfo.LCID, "#5");
-		Assert.AreEqual (fullName, abName.FullName, "#6");
+		Assert.IsTrue (abName.CultureInfo != CultureInfo.InvariantCulture, "#B2a");
+		Assert.AreEqual (CultureInfo.InvariantCulture.LCID, abName.CultureInfo.LCID, "#B2a");
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, abName.Flags, "#B3");
+		Assert.AreEqual (fullName, abName.FullName, "#B4");
 #else
-		Assert.AreEqual (CultureInfo.InvariantCulture, abName.CultureInfo, "#7");
-		Assert.AreEqual ("AssemblyNameTest_MoreCultureInfo, Version=1.2.3.4, PublicKeyToken=0eea7ce65f35f2d8", abName.FullName, "#8");
+		Assert.AreEqual (CultureInfo.InvariantCulture, abName.CultureInfo, "#B2");
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, abName.Flags, "#B3");
+		//Assert.AreEqual ("AssemblyNameTest_MoreCultureInfo, Version=1.2.3.4, PublicKeyToken=0eea7ce65f35f2d8", abName.FullName, "#B4");
+		Assert.IsTrue (abName.FullName.IndexOf ("AssemblyNameTest_MoreCultureInfo, Version=1.2.3.4") != -1, "#B4a");
+		Assert.IsTrue (abName.FullName.IndexOf ("PublicKeyToken=0eea7ce65f35f2d8") != -1, "#B4b");
 #endif
 
 		ab.Save ("AssemblyNameTest_MoreCultureInfo.dll");
@@ -926,19 +970,18 @@
 		AssemblyName bakedName = AssemblyName.GetAssemblyName (Path.Combine(
 			tempDir, "AssemblyNameTest_MoreCultureInfo.dll"));
 
-		Assert.IsNotNull (bakedName.CultureInfo, "#9");
+		Assert.IsNotNull (bakedName.CultureInfo, "#C1");
 
 #if NET_2_0
-		Assert.IsTrue (abName.CultureInfo != CultureInfo.InvariantCulture, "#10");
-		Assert.AreEqual (CultureInfo.InvariantCulture.LCID, abName.CultureInfo.LCID, "#11");
+		Assert.IsTrue (abName.CultureInfo != CultureInfo.InvariantCulture, "#C2a");
+		Assert.AreEqual (CultureInfo.InvariantCulture.LCID, abName.CultureInfo.LCID, "#C2b");
 #else
-		Assert.AreEqual (CultureInfo.InvariantCulture, bakedName.CultureInfo, "#12");
+		Assert.AreEqual (CultureInfo.InvariantCulture, bakedName.CultureInfo, "#C2");
 #endif
-		Assert.AreEqual (fullName, bakedName.FullName, "#13");
+		Assert.AreEqual (fullName, bakedName.FullName, "#C3");
 	}
 
 	[Test]
-	[Category ("NotWorking")]
 	public void AssemblyName_NoVersion ()
 	{
 		AssemblyName assemblyName = new AssemblyName ();
@@ -951,17 +994,25 @@
 	}
 
 	[Test]
-	[Category ("NotWorking")]
 	public void AssemblyName_Version ()
 	{
 		AssemblyName assemblyName = new AssemblyName ();
 		assemblyName.Name = "AssemblyNameTest";
 		assemblyName.Version = new Version (1, 2, 3, 4);
 
-		const string fullName = "AssemblyNameTest, Version=1.2.3.4, Culture=neutral, PublicKeyToken=null";
-		const string abName = "AssemblyNameTest, Version=1.2.3.4";
+		string fullName = "AssemblyNameTest, Version=1.2.3.4, Culture=neutral, PublicKeyToken=null";
+		string abName = "AssemblyNameTest, Version=1.2.3.4";
 
 		AssertAssemblyName (tempDir, assemblyName, abName, fullName);
+
+		assemblyName = new AssemblyName ();
+		assemblyName.Name = "AssemblyNameTest";
+		assemblyName.Version = new Version (1, 2);
+
+		fullName = "AssemblyNameTest, Version=1.2.0.0, Culture=neutral, PublicKeyToken=null";
+		abName = "AssemblyNameTest, Version=1.2.0.0";
+
+		AssertAssemblyName (tempDir, assemblyName, abName, fullName);
 	}
 
 	[Test]
@@ -996,11 +1047,23 @@
 #if NET_2_0
 			// on .NET 2.0, the full name of the AssemblyBuilder matches the 
 			// fully qualified assembly name
-			Assert.AreEqual (fullName, ab.FullName);
+			Assert.AreEqual (fullName, ab.FullName, "#1");
 #else
-			Assert.AreEqual (abName, ab.FullName);
+			//Assert.AreEqual (abName, ab.FullName, "#1");
 #endif
 
+			AssemblyName an = ab.GetName ();
+
+			Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#2");
+			Assert.IsNotNull (an.GetPublicKey (), "#3a");
+			Assert.AreEqual (0, an.GetPublicKey ().Length, "#3b");
+#if NET_2_0
+			Assert.IsNotNull (an.GetPublicKeyToken (), "#4a");
+			Assert.AreEqual (0, an.GetPublicKeyToken ().Length, "#4b");
+#else
+			Assert.IsNull (an.GetPublicKeyToken (), "#4");
+#endif
+
 			// load assembly in separate domain, so we can clean-up after the 
 			// test
 			newDomain = AppDomain.CreateDomain ("test2", currentDomain.Evidence,
@@ -1027,6 +1090,7 @@
 			_assemblyPath = assemblyPath;
 			_assemblyName = assemblyName;
 		}
+
 		public void Test ()
 		{
 			AssemblyName assemblyName = AssemblyName.GetAssemblyName (_assemblyPath);
Index: Test/System.Reflection/AssemblyNameTest.cs
===================================================================
--- Test/System.Reflection/AssemblyNameTest.cs	(revision 92059)
+++ Test/System.Reflection/AssemblyNameTest.cs	(working copy)
@@ -21,34 +21,12 @@
 using System.Globalization;
 using System.Runtime.Serialization.Formatters.Binary;
 using System.Security;
+using System.Security.Permissions;
 
 namespace MonoTests.System.Reflection {
 
 [TestFixture]
 public class AssemblyNameTest {
-	static public void AssertEqualsByteArrays (string msg, byte[] array1, byte[] array2) 
-	{
-		if ((array1 == null) && (array2 == null))
-			return;
-		if (array1 == null)
-			Assert.Fail (msg + " -> First array is NULL");
-		if (array2 == null)
-			Assert.Fail (msg + " -> Second array is NULL");
-
-		bool a = (array1.Length == array2.Length);
-		if (a) {
-			for (int i = 0; i < array1.Length; i++) {
-				if (array1 [i] != array2 [i]) {
-					a = false;
-					break;
-				}
-			}
-		}
-		msg += " -> Expected " + (array1.Length > 0 ? BitConverter.ToString (array1, 0) : "<empty>");
-		msg += " is different than " + (array2.Length > 0 ? BitConverter.ToString (array2, 0) : "<empty>");
-		Assert.IsTrue (a, msg);
-	}
-
 	private AssemblyName an;
 
 	private string tempDir = Path.Combine (Path.GetTempPath (), "MonoTests.System.Reflection.AssemblyNameTest");
@@ -95,11 +73,8 @@
 		}
 	}
 
-	[Test]
-#if NET_2_0
-	[Category ("NotWorking")]
-#endif
-	public void EmptyAssembly () 
+	[Test] // ctor ()
+	public void Constructor0 ()
 	{
 		an = new AssemblyName ();
 		Assert.IsNull (an.CodeBase, "CodeBase");
@@ -114,39 +89,176 @@
 		Assert.AreEqual (AssemblyHashAlgorithm.None, an.HashAlgorithm, "HashAlgorithm");
 		Assert.IsNull (an.KeyPair, "KeyPair");
 		Assert.IsNull (an.Name, "Name");
+#if NET_2_0
+		Assert.AreEqual (ProcessorArchitecture.None, an.ProcessorArchitecture, "PA");
+#endif
 		Assert.IsNull (an.Version, "Version");
 		Assert.AreEqual (AssemblyVersionCompatibility.SameMachine, 
 			an.VersionCompatibility, "VersionCompatibility");
+		Assert.IsNull (an.GetPublicKey (), "GetPublicKey");
+		Assert.IsNull (an.GetPublicKeyToken (), "GetPublicKeyToken");
+#if NET_2_0
+		Assert.AreEqual (string.Empty, an.ToString (), "ToString");
+#else
+		Assert.AreEqual (typeof (AssemblyName).FullName, an.ToString (), "ToString");
+#endif
 	}
 
 	[Test]
+	public void SetPublicKey () 
+	{
+		an = new AssemblyName ();
+		Assert.IsNull (an.GetPublicKey (), "#A1");
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#A2");
+		Assert.IsNull (an.KeyPair, "#A3");
+		Assert.IsNull (an.GetPublicKeyToken (), "#A4");
+
+		an.SetPublicKey (publicKey);
+
+		Assert.AreEqual (publicKey, an.GetPublicKey (), "#B1");
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#B2");
+		Assert.IsNull (an.KeyPair, "#B3");
 #if NET_2_0
-	[Category ("NotWorking")]
-	[ExpectedException (typeof (SecurityException))]
+		try {
+			an.GetPublicKeyToken ();
+			Assert.Fail ("#B4a");
+		} catch (SecurityException ex) {
+			// Invalid assembly public key
+			Assert.AreEqual (typeof (SecurityException), ex.GetType (), "#B4b");
+			Assert.AreEqual ((SecurityAction) 0, ex.Action, "#B4c");
+			Assert.IsNull (ex.InnerException, "#B4d");
+			Assert.IsNotNull (ex.Message, "#B4e");
+		}
+#else
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "#B4");
 #endif
-	public void PublicKey () 
-	{
+
+		an.SetPublicKey ((byte []) null);
+
+		Assert.IsNull (an.GetPublicKey (), "#C1");
+#if NET_2_0
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#C2");
+#else
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#C2");
+#endif
+		Assert.IsNull (an.KeyPair, "#C3");
+#if NET_2_0
+		Assert.IsNull (an.GetPublicKeyToken (), "#C4");
+#else
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "#C4");
+#endif
+
+		an.SetPublicKey (publicKey);
+		an.SetPublicKeyToken (token);
+		an.SetPublicKey ((byte []) null);
+
+		Assert.IsNull (an.GetPublicKey (), "#D1");
+#if NET_2_0
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#D2");
+#else
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#D2");
+#endif
+		Assert.IsNull (an.KeyPair, "#D3");
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "#D4");
+
+		an.SetPublicKey ((byte []) null);
+		an.SetPublicKeyToken (token);
+		an.SetPublicKey ((byte []) null);
+
+		Assert.IsNull (an.GetPublicKey (), "#E1");
+#if NET_2_0
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#E2");
+#else
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#E2");
+#endif
+		Assert.IsNull (an.KeyPair, "#E3");
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "#E4");
+
 		an = new AssemblyName ();
-		Assert.IsNull (an.GetPublicKey (), "PublicKey(empty)");
 		an.SetPublicKey (publicKey);
+		an.SetPublicKey ((byte []) null);
+		an.SetPublicKeyToken (token);
+		an.SetPublicKey ((byte []) null);
 
-		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "Flags");
-		// strangly it doesn't affect the KeyPair ?
-		Assert.IsNull (an.KeyPair, "KeyPair");
-		AssertEqualsByteArrays ("PublicKey", publicKey, an.GetPublicKey ());
-		AssertEqualsByteArrays ("PublicKeyToken", token, an.GetPublicKeyToken ());
+		Assert.IsNull (an.GetPublicKey (), "#F1");
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#F2");
+		Assert.IsNull (an.KeyPair, "#F3");
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "#F4");
+
+		an = new AssemblyName ();
+		an.SetPublicKey (publicKey);
+		an.SetPublicKey ((byte []) null);
+		an.SetPublicKeyToken (token);
+
+		Assert.IsNull (an.GetPublicKey (), "#G1");
+#if NET_2_0
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#G2");
+#else
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#G2");
+#endif
+		Assert.IsNull (an.KeyPair, "#G3");
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "#G4");
+
+		an = new AssemblyName ();
+		an.SetPublicKey (new byte [0]);
+
+		Assert.IsNotNull (an.GetPublicKey (), "#H1");
+		Assert.AreEqual (0, an.GetPublicKey ().Length, "#H2");
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#H3");
+		Assert.IsNull (an.KeyPair, "#H4");
+#if NET_2_0
+		Assert.IsNotNull (an.GetPublicKeyToken (), "#H5");
+		Assert.AreEqual (0, an.GetPublicKeyToken ().Length, "#H6");
+#else
+		Assert.IsNull (an.GetPublicKeyToken (), "#H5");
+#endif
+
+		an = new AssemblyName ();
+		an.SetPublicKey (publicKey);
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#I1");
+		an.SetPublicKey (publicKey);
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#I2");
+
+		an = new AssemblyName ();
+		an.SetPublicKey ((byte []) null);
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#J1");
+		an.SetPublicKey ((byte []) null);
+#if NET_2_0
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#J2");
+#else
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#J2");
+#endif
+		an.SetPublicKey ((byte []) null);
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#J3");
+		an.SetPublicKey (publicKey);
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "#J4");
 	}
 
 	[Test]
-	public void PublicKeyToken () 
+	public void SetPublicKeyToken ()
 	{
 		an = new AssemblyName ();
 		an.SetPublicKeyToken (token);
 
-		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "Flags");
-		Assert.IsNull (an.KeyPair, "KeyPair");
-		Assert.IsNull (an.GetPublicKey (), "PublicKey");
-		AssertEqualsByteArrays ("PublicKeyToken", token, an.GetPublicKeyToken ());
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#A1");
+		Assert.IsNull (an.KeyPair, "#A2");
+		Assert.IsNull (an.GetPublicKey (), "#A3");
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "#A4");
+
+		an.SetPublicKeyToken ((byte []) null);
+
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#B1");
+		Assert.IsNull (an.KeyPair, "#B2");
+		Assert.IsNull (an.GetPublicKey (), "#B3");
+		Assert.IsNull (an.GetPublicKeyToken (), "#B4");
+
+		an.SetPublicKeyToken (new byte [0]);
+
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#C1");
+		Assert.IsNull (an.KeyPair, "#C2");
+		Assert.IsNull (an.GetPublicKey (), "#C3");
+		Assert.IsNotNull (an.GetPublicKeyToken (), "#C4");
+		Assert.AreEqual (0, an.GetPublicKeyToken ().Length, "#C5");
 	}
 
 	[Test]
@@ -155,38 +267,79 @@
 		an = new AssemblyName ();
 		an.KeyPair = new StrongNameKeyPair (publicKey);
 
-		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "Flags");
-		Assert.IsNotNull (an.KeyPair, "KeyPair");
-		Assert.IsNull (an.GetPublicKey (), "PublicKey");
-		Assert.IsNull (an.GetPublicKeyToken (), "PublicKeyToken");
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#A1");
+		Assert.IsNotNull (an.KeyPair, "#A2");
+		Assert.IsNull (an.GetPublicKey (), "#A3");
+		Assert.IsNull (an.GetPublicKeyToken (), "#A4");
+
+		an.KeyPair = null;
+
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "#B1");
+		Assert.IsNull (an.KeyPair, "#B2");
+		Assert.IsNull (an.GetPublicKey (), "#B3");
+		Assert.IsNull (an.GetPublicKeyToken (), "#B4");
 	}
 
 	// !!! this assembly MUST NOT use a StrongName !!!
 	[Test]
-	[Category ("NotWorking")] // in other cases null is returned
-	public void Self () 
+	public void Self ()
 	{
 		Assembly a = Assembly.GetExecutingAssembly ();
 		AssemblyName an = a.GetName ();
 
-		Assert.IsNotNull (an.GetPublicKey (), "PublicKey(self)");
-		Assert.AreEqual (0, an.GetPublicKey ().Length, "PublicKey.Length");
+		Assert.AreEqual (CultureInfo.InvariantCulture, an.CultureInfo, "CultureInfo");
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags, "Flags");
+		Assert.AreEqual (AssemblyHashAlgorithm.SHA1, an.HashAlgorithm, "HashAlgorithm");
+		Assert.IsNull (an.KeyPair, "KeyPair");
+		Assert.IsNotNull (an.Name, "Name");
+#if NET_2_0
+		//Assert.AreEqual (ProcessorArchitecture.MSIL, an.ProcessorArchitecture, "PA");
+#endif
+		Assert.AreEqual (new Version (0, 0, 0, 0), an.Version, "Version");
+		Assert.AreEqual (AssemblyVersionCompatibility.SameMachine,
+			an.VersionCompatibility, "VersionCompatibility");
+		Assert.AreEqual (new byte [0], an.GetPublicKey (), "GetPublicKey");
+		Assert.AreEqual (an.FullName, an.ToString (), "ToString");
 	}
 
 	[Test]
-	public void FullName1 ()
+	public void Flags_Corlib ()
 	{
-		// !!! we assume the mscorlib has a strong name !!!
+		AssemblyName an = typeof (int).Assembly.GetName ();
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags);
+	}
+
+	[Test]
+	public void Flags_Self ()
+	{
+		Assembly a = Assembly.GetExecutingAssembly ();
+		AssemblyName an = a.GetName ();
+		Assert.AreEqual (AssemblyNameFlags.PublicKey, an.Flags);
+	}
+
+	[Test]
+	public void FullName_Corlib ()
+	{
 		AssemblyName an = typeof(int).Assembly.GetName ();
-		Assert.IsNotNull (an.FullName, "FullName1#1");
-		Assert.IsTrue (an.FullName.IndexOf ("Version=") != -1, "FullName1#2");
-		Assert.IsTrue (an.FullName.IndexOf("Culture=") != -1, "FullName1#3");
-		Assert.IsTrue (an.FullName.IndexOf ("PublicKeyToken=") != -1, "FullName1#4");
+		Assert.IsNotNull (an.FullName, "#1");
+		Assert.AreEqual (Consts.AssemblyCorlib, an.FullName, "#2");
 	}
 
 	[Test]
-	public void FullName2 ()
+	public void FullName_Self ()
 	{
+		Assembly a = Assembly.GetExecutingAssembly ();
+		AssemblyName an = a.GetName ();
+
+		Assert.IsNotNull (an.FullName, "#1");
+		Assert.IsTrue (an.FullName.IndexOf ("Version=0.0.0.0") != -1, "#2");
+		Assert.IsTrue (an.FullName.IndexOf ("Culture=neutral") != -1, "#3");
+		Assert.IsTrue (an.FullName.IndexOf ("PublicKeyToken=null") != -1, "#4");
+	}
+
+	[Test]
+	public void FullName_Name ()
+	{
 		const string assemblyName = "TestAssembly";
 
 		// tests for AssemblyName with only name
@@ -199,7 +352,7 @@
 	}
 
 	[Test]
-	public void FullName3 ()
+	public void FullName_Version ()
 	{
 		const string assemblyName = "TestAssembly";
 		const string assemblyVersion = "1.2";
@@ -212,7 +365,7 @@
 	}
 
 	[Test]
-	public void FullName4 ()
+	public void FullName_Culture ()
 	{
 		const string assemblyName = "TestAssembly";
 
@@ -224,23 +377,88 @@
 	}
 
 	[Test]
+	public void FullName_PublicKey_Only ()
+	{
+		const string assemblyName = "TestAssembly";
+
+		// tests for AssemblyName with name and public key
+		AssemblyName an = new AssemblyName ();
+		an.Name = assemblyName;
+		an.SetPublicKey (publicKey);
 #if NET_2_0
-	[Category ("NotWorking")]
-	[ExpectedException (typeof (SecurityException))]
+		try {
+			Assert.Fail ("#A1: " + an.FullName);
+		} catch (SecurityException ex) {
+			// Invalid assembly public key
+			Assert.AreEqual (typeof (SecurityException), ex.GetType (), "#A2");
+			Assert.AreEqual ((SecurityAction) 0, ex.Action, "#A3");
+			Assert.IsNull (ex.InnerException, "#A4");
+			Assert.IsNotNull (ex.Message, "#A5");
+		}
+#else
+		Assert.AreEqual (assemblyName + ", PublicKeyToken=" + GetTokenString (token), an.FullName, "#A1");
 #endif
-	public void FullName5 ()
+
+		an.SetPublicKey ((byte []) null);
+		Assert.AreEqual (assemblyName, an.FullName, "#B1");
+
+		an.SetPublicKey (new byte [0]);
+		Assert.AreEqual (assemblyName + ", PublicKeyToken=null", an.FullName, "#C1");
+	}
+
+	[Test]
+	public void FullName_PublicKeyToken_Only ()
 	{
 		const string assemblyName = "TestAssembly";
 
+		// tests for AssemblyName with name and only a token
+		AssemblyName an = new AssemblyName ();
+		an.Name = assemblyName;
+		an.SetPublicKeyToken (token);
+		Assert.AreEqual (assemblyName + ", PublicKeyToken=" + GetTokenString (token), an.FullName, "#1");
+
+		an.SetPublicKeyToken ((byte []) null);
+		Assert.AreEqual (assemblyName, an.FullName, "#2");
+
+		an.SetPublicKeyToken (new byte [0]);
+		Assert.AreEqual (assemblyName + ", PublicKeyToken=null", an.FullName, "#3");
+	}
+
+	[Test]
+	public void FullName_PublicKey ()
+	{
+		const string assemblyName = "TestAssembly";
+
 		// tests for AssemblyName with name and public key
 		AssemblyName an = new AssemblyName ();
 		an.Name = assemblyName;
 		an.SetPublicKey (publicKey);
-		Assert.AreEqual (assemblyName + ", PublicKeyToken=" + GetTokenString(token), an.FullName, "FullName5#1");
+		an.SetPublicKeyToken (token);
+		Assert.AreEqual (assemblyName + ", PublicKeyToken=" + GetTokenString (token), an.FullName, "#A1");
+
+		an.SetPublicKey ((byte []) null);
+#if NET_2_0
+		Assert.AreEqual (assemblyName + ", PublicKeyToken=" + GetTokenString (token), an.FullName, "#A2");
+#else
+		Assert.AreEqual (assemblyName, an.FullName, "#A2");
+#endif
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "#A3");
+		an.SetPublicKey (new byte [0]);
+#if NET_2_0
+		Assert.AreEqual (assemblyName + ", PublicKeyToken=" + GetTokenString (token), an.FullName, "#A4");
+#else
+		Assert.AreEqual (assemblyName + ", PublicKeyToken=null", an.FullName, "#A4");
+#endif
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "#A5");
+
+		an = new AssemblyName ();
+		an.Name = assemblyName;
+		an.SetPublicKey (new byte [0]);
+		Assert.AreEqual (assemblyName + ", PublicKeyToken=null", an.FullName, "#B1");
 	}
 
 	[Test]
-	public void FullName6 ()
+	public void FullName_VersionCulture ()
 	{
 		const string assemblyName = "TestAssembly";
 		const string assemblyVersion = "1.2";
@@ -250,16 +468,18 @@
 		an.Name = assemblyName;
 		an.Version = new Version (assemblyVersion);
 		an.CultureInfo = CultureInfo.InvariantCulture;
-		Assert.AreEqual (assemblyName + ", Version=" + assemblyVersion 
-			+ ", Culture=neutral", an.FullName, "FullName6#1");
+		Assert.AreEqual (assemblyName + ", Version=" + assemblyVersion
+			+ ", Culture=neutral", an.FullName, "#1");
+		an.CultureInfo = new CultureInfo ("en-US");
+		Assert.AreEqual (assemblyName + ", Version=" + assemblyVersion
+			+ ", Culture=en-US", an.FullName, "#2");
+		an.CultureInfo = new CultureInfo ("en");
+		Assert.AreEqual (assemblyName + ", Version=" + assemblyVersion
+			+ ", Culture=en", an.FullName, "#3");
 	}
 
 	[Test]
-#if NET_2_0
-	[Category ("NotWorking")]
-	[ExpectedException (typeof (SecurityException))]
-#endif
-	public void FullName7 ()
+	public void FullName_VersionPublicKey ()
 	{
 		const string assemblyName = "TestAssembly";
 		const string assemblyVersion = "1.2";
@@ -269,17 +489,14 @@
 		an.Name = assemblyName;
 		an.Version = new Version (assemblyVersion);
 		an.SetPublicKey (publicKey);
+		an.SetPublicKeyToken (token);
 		Assert.AreEqual (assemblyName + ", Version=" + assemblyVersion
 			+ ", PublicKeyToken=" + GetTokenString (token), 
-			an.FullName, "FullName7#1");
+			an.FullName, "#1");
 	}
 
 	[Test]
-#if NET_2_0
-	[Category ("NotWorking")]
-	[ExpectedException (typeof (SecurityException))]
-#endif
-	public void FullName8 ()
+	public void FullName_CulturePublicKey ()
 	{
 		const string assemblyName = "TestAssembly";
 
@@ -288,11 +505,32 @@
 		an.Name = assemblyName;
 		an.CultureInfo = CultureInfo.InvariantCulture;
 		an.SetPublicKey (publicKey);
+		an.SetPublicKeyToken (token);
 		Assert.AreEqual (assemblyName + ", Culture=neutral"
 			+ ", PublicKeyToken=" + GetTokenString (token),
-			an.FullName, "FullName8#1");
+			an.FullName, "#1");
 	}
 
+	[Test]
+	public void GetPublicKeyToken_Corlib ()
+	{
+		AssemblyName an = typeof (int).Assembly.GetName ();
+		Assert.IsNotNull (an.GetPublicKeyToken (), "#1");
+		Assert.IsTrue (an.GetPublicKeyToken ().Length > 0, "#2");
+	}
+
+	[Test]
+	public void GetPublicKeyToken_Self ()
+	{
+		Assembly a = Assembly.GetExecutingAssembly ();
+		AssemblyName an = a.GetName ();
+#if NET_2_0
+		Assert.AreEqual (new byte [0], an.GetPublicKeyToken ());
+#else
+		Assert.IsNull (an.GetPublicKeyToken ());
+#endif
+	}
+
 	static int nameIndex = 0;
 
 	private AssemblyName GenAssemblyName () 
@@ -504,8 +742,8 @@
 		Assert.AreEqual (an.EscapedCodeBase, dsAssemblyName.EscapedCodeBase, "EscapedCodeBase");
 		Assert.AreEqual (an.FullName, dsAssemblyName.FullName, "FullName");
 		Assert.AreEqual (an.ToString (), dsAssemblyName.ToString (), "ToString");
-		AssertEqualsByteArrays ("PublicKey", an.GetPublicKey (), dsAssemblyName.GetPublicKey ());
-		AssertEqualsByteArrays ("PublicToken", an.GetPublicKeyToken (), dsAssemblyName.GetPublicKeyToken ());
+		Assert.AreEqual (an.GetPublicKey (), dsAssemblyName.GetPublicKey (), "PublicKey");
+		Assert.AreEqual (an.GetPublicKeyToken (), dsAssemblyName.GetPublicKeyToken (), "PublicToken");
 	}
 
 	[Test]
@@ -545,24 +783,29 @@
 		Assert.AreEqual (an.EscapedCodeBase, dsAssemblyName.EscapedCodeBase, "EscapedCodeBase");
 		Assert.AreEqual (an.FullName, dsAssemblyName.FullName, "FullName");
 		Assert.AreEqual (an.ToString (), dsAssemblyName.ToString (), "ToString");
-		AssertEqualsByteArrays ("PublicKey", an.GetPublicKey (), dsAssemblyName.GetPublicKey ());
-		AssertEqualsByteArrays ("PublicToken", an.GetPublicKeyToken (), dsAssemblyName.GetPublicKeyToken ());
+		Assert.AreEqual (an.GetPublicKey (), dsAssemblyName.GetPublicKey (), "PublicKey");
+		Assert.AreEqual (an.GetPublicKeyToken (), dsAssemblyName.GetPublicKeyToken (), "PublicToken");
 	}
 
 #if !TARGET_JVM // Assemblyname.GetObjectData not implemented yet for TARGET_JVM
 	[Test]
-	[ExpectedException (typeof (ArgumentNullException))]
-	public void GetObjectData_Null ()
+	public void GetObjectData_Info_Null ()
 	{
 		AssemblyName an = new AssemblyName ();
-		an.GetObjectData (null, new StreamingContext (StreamingContextStates.All));
+		try {
+			an.GetObjectData (null, new StreamingContext (StreamingContextStates.All));
+			Assert.Fail ("#1");
+		} catch (ArgumentNullException ex) {
+			Assert.AreEqual (typeof (ArgumentNullException), ex.GetType (), "#2");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
+			Assert.IsNotNull (ex.ParamName, "#5");
+			Assert.AreEqual ("info", ex.ParamName, "#6");
+		}
 	}
 #endif // TARGET_JVM
 
 	[Test]
-#if NET_2_0
-	[Category ("NotWorking")]
-#endif
 	public void Clone_Empty ()
 	{
 		an = new AssemblyName ();
@@ -580,6 +823,9 @@
 		Assert.AreEqual (AssemblyHashAlgorithm.None, clone.HashAlgorithm, "HashAlgorithm");
 		Assert.IsNull (clone.KeyPair, "KeyPair");
 		Assert.IsNull (clone.Name, "Name");
+#if NET_2_0
+		Assert.AreEqual (ProcessorArchitecture.None, clone.ProcessorArchitecture, "PA");
+#endif
 		Assert.IsNull (clone.Version, "Version");
 		Assert.AreEqual (AssemblyVersionCompatibility.SameMachine, 
 			clone.VersionCompatibility, "VersionCompatibility");
@@ -599,6 +845,9 @@
 		Assert.AreEqual (an.HashAlgorithm, clone.HashAlgorithm, "HashAlgorithm");
 		Assert.AreEqual (an.KeyPair, clone.KeyPair, "KeyPair");
 		Assert.AreEqual (an.Name, clone.Name, "Name");
+#if NET_2_0
+		//Assert.AreEqual (ProcessorArchitecture.MSIL, clone.ProcessorArchitecture, "PA");
+#endif
 		Assert.AreEqual (an.Version, clone.Version, "Version");
 		Assert.AreEqual (an.VersionCompatibility, clone.VersionCompatibility, "VersionCompatibility");
 	}
@@ -612,7 +861,7 @@
 
 	[Test]
 	[Category ("NotWorking")]
-	public void GetAssemblyName_AssemblyFile_LoadFailure ()
+	public void GetAssemblyName_AssemblyFile_ReadLock ()
 	{
 		string file = Path.Combine (tempDir, "loadfailure.dll");
 		using (FileStream fs = File.Open (file, FileMode.OpenOrCreate, FileAccess.Read, FileShare.None)) {
@@ -620,6 +869,20 @@
 				AssemblyName.GetAssemblyName (file);
 				Assert.Fail ("#1");
 			} catch (FileLoadException ex) {
+				// Could not load file or assembly '...' or one
+				// of its dependencies. The process cannot access
+				// the file because it is being used by another
+				// process
+				Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.FileName, "#3");
+#if NET_2_0
+				Assert.AreEqual (file, ex.FileName, "#4");
+#else
+				Assert.IsTrue (ex.FileName.IndexOf ("loadfailure.dll") != -1, "#4");
+#endif
+				Assert.IsNull (ex.InnerException, "#5");
+				Assert.IsNotNull (ex.Message, "#6");
+				throw;
 			}
 		}
 		File.Delete (file);
@@ -636,8 +899,18 @@
 			AssemblyName.GetAssemblyName (file);
 			Assert.Fail ("#1");
 		} catch (BadImageFormatException ex) {
+			Assert.AreEqual (typeof (BadImageFormatException), ex.GetType (), "#2");
+			Assert.IsNotNull (ex.FileName, "#3");
+#if NET_2_0
+			Assert.AreEqual (file, ex.FileName, "#4");
+#else
+			Assert.IsTrue (ex.FileName.IndexOf ("badimage.dll") != -1, "#4");
+#endif
+			Assert.IsNull (ex.InnerException, "#5");
+			Assert.IsNotNull (ex.Message, "#6");
+		} finally {
+			File.Delete (file);
 		}
-		File.Delete (file);
 	}
 
 	[Test]
@@ -663,163 +936,394 @@
 
 #if NET_2_0
 	[Test]
-	[Category ("NotWorking")]
-	public void Ctor1 ()
+	public void Constructor1_Name ()
 	{
 		const string assemblyName = "TestAssembly";
 		AssemblyName an = new AssemblyName (assemblyName);
-		Assert.IsNotNull (an.Name, "Ctor1#1");
-		Assert.AreEqual (an.Name, assemblyName, "Ctor1#2");
-		Assert.IsNull (an.Version, "Ctor1#3");
-		Assert.IsNull (an.CultureInfo, "Ctor1#4");
-		Assert.IsNull (an.GetPublicKeyToken (), "Ctor1#5");
+		Assert.IsNull (an.CodeBase, "CodeBase");
+		Assert.IsNull (an.CultureInfo, "CultureInfo");
+		Assert.IsNull (an.EscapedCodeBase, "EscapedCodeBase");
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "Flags");
+		Assert.AreEqual ("TestAssembly", an.FullName, "FullName");
+		Assert.AreEqual (AssemblyHashAlgorithm.None, an.HashAlgorithm, "HashAlgorithm");
+		Assert.IsNull (an.KeyPair, "KeyPair");
+		Assert.AreEqual (assemblyName, an.Name, "Name");
+		Assert.AreEqual (ProcessorArchitecture.None, an.ProcessorArchitecture, "PA");
+		Assert.IsNull (an.Version, "Version");
+		Assert.AreEqual (AssemblyVersionCompatibility.SameMachine, 
+			an.VersionCompatibility, "VersionCompatibility");
+		Assert.IsNull (an.GetPublicKey (), "GetPublicKey");
+		Assert.IsNull (an.GetPublicKeyToken (), "GetPublicKeyToken");
+		Assert.AreEqual ("TestAssembly", an.ToString (), "ToString");
 	}
 
 	[Test]
 	[Category("TargetJvmNotWorking")] // Not yet supported for TARGET_JVM.
-	public void Ctor2 ()
+	public void Constructor1_Full ()
 	{
 		const string assemblyName = "TestAssembly";
+		const string assemblyCulture = "neutral";
 		const string assemblyVersion = "1.2.3.4";
-		AssemblyName an = new AssemblyName (assemblyName + ", Version=" + assemblyVersion);
-		Assert.IsNotNull (an.Name, "Ctor2#1");
-		Assert.AreEqual (an.Name, assemblyName, "Ctor2#2");
-		Assert.IsNotNull (an.Version, "Ctor2#3");
-		Assert.AreEqual (an.Version, new Version (assemblyVersion), "Ctor2#4");
-		Assert.IsNull (an.CultureInfo, "Ctor2#5");
-		Assert.IsNull (an.GetPublicKeyToken (), "Ctor2#6");
+
+		AssemblyName an = new AssemblyName (assemblyName + ", Version=" + assemblyVersion + 
+				", Culture=" + assemblyCulture + ", PublicKeyToken=" + GetTokenString (token));
+		Assert.IsNull (an.CodeBase, "CodeBase");
+		Assert.AreEqual (CultureInfo.InvariantCulture, an.CultureInfo, "CultureInfo");
+		Assert.IsNull (an.EscapedCodeBase, "EscapedCodeBase");
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "Flags");
+		Assert.AreEqual ("TestAssembly, Version=1.2.3.4, Culture=neutral, PublicKeyToken=ffef94536769da06", an.FullName, "FullName");
+		Assert.AreEqual (AssemblyHashAlgorithm.None, an.HashAlgorithm, "HashAlgorithm");
+		Assert.IsNull (an.KeyPair, "KeyPair");
+		Assert.AreEqual (assemblyName, an.Name, "Name");
+		Assert.AreEqual (ProcessorArchitecture.None, an.ProcessorArchitecture, "PA");
+		Assert.AreEqual (new Version (assemblyVersion), an.Version, "Version");
+		Assert.AreEqual (AssemblyVersionCompatibility.SameMachine, 
+			an.VersionCompatibility, "VersionCompatibility");
+		Assert.IsNull (an.GetPublicKey (), "GetPublicKey");
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "GetPublicKeyToken");
+		Assert.AreEqual ("TestAssembly, Version=1.2.3.4, Culture=neutral, PublicKeyToken=ffef94536769da06", an.ToString (), "ToString");
 	}
 
 	[Test]
-	[Category ("NotWorking")]
-	public void Ctor3 ()
+	public void Constructor1_AssemblyName_Empty ()
 	{
+		try {
+			new AssemblyName (string.Empty);
+			Assert.Fail ("#1");
+		} catch (ArgumentException ex) {
+			// String cannot have zero length
+			Assert.AreEqual (typeof (ArgumentException), ex.GetType (), "#2");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
+			Assert.IsNull (ex.ParamName, "#5");
+		}
+	}
+
+	[Test]
+	public void Constructor1_AssemblyName_Invalid ()
+	{
 		const string assemblyName = "TestAssembly";
+
+		try {
+			new AssemblyName (assemblyName + ", =1.2.4.5");
+			Assert.Fail ("#A1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
+		}
+
+		try {
+			new AssemblyName (assemblyName + ", OtherAttribute");
+			Assert.Fail ("#B1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
+		}
+	}
+
+	[Test]
+	public void Constructor1_AssemblyName_Null ()
+	{
+		try {
+			new AssemblyName (null);
+			Assert.Fail ("#1");
+		} catch (ArgumentNullException ex) {
+			Assert.AreEqual (typeof (ArgumentNullException), ex.GetType (), "#2");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
+			Assert.IsNotNull (ex.ParamName, "#5");
+			Assert.AreEqual ("assemblyName", ex.ParamName, "#6");
+		}
+	}
+
+	[Test]
+	public void Constructor1_Culture ()
+	{
+		const string assemblyName = "TestAssembly";
 		const string assemblyCulture = "en-US";
 		AssemblyName an = new AssemblyName (assemblyName + ", Culture=" + assemblyCulture);
-		Assert.IsNotNull (an.Name, "Ctor3#1");
-		Assert.AreEqual (an.Name, assemblyName, "Ctor3#2");
-		Assert.IsNotNull (an.CultureInfo, "Ctor3#3");
-		Assert.AreEqual (an.CultureInfo, new CultureInfo (assemblyCulture), "Ctor3#4");
-		Assert.IsNull (an.Version, "Ctor3#5");
-		Assert.IsNull (an.GetPublicKeyToken (), "Ctor3#6");
+		Assert.IsNull (an.CodeBase, "CodeBase");
+		Assert.AreEqual (new CultureInfo (assemblyCulture), an.CultureInfo, "CultureInfo");
+		Assert.IsNull (an.EscapedCodeBase, "EscapedCodeBase");
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "Flags");
+		Assert.AreEqual ("TestAssembly, Culture=en-US", an.FullName, "FullName");
+		Assert.AreEqual (AssemblyHashAlgorithm.None, an.HashAlgorithm, "HashAlgorithm");
+		Assert.IsNull (an.KeyPair, "KeyPair");
+		Assert.AreEqual (assemblyName, an.Name, "Name");
+		Assert.AreEqual (ProcessorArchitecture.None, an.ProcessorArchitecture, "PA");
+		Assert.IsNull (an.Version, "Version");
+		Assert.AreEqual (AssemblyVersionCompatibility.SameMachine, 
+			an.VersionCompatibility, "VersionCompatibility");
+		Assert.IsNull (an.GetPublicKey (), "GetPublicKey");
+		Assert.IsNull (an.GetPublicKeyToken (), "GetPublicKeyToken");
+		Assert.AreEqual ("TestAssembly, Culture=en-US", an.ToString (), "ToString");
 	}
 
 	[Test]
-	[Category ("NotWorking")]
-	public void Ctor4 ()
+	public void Constructor1_Culture_Incomplete ()
 	{
 		const string assemblyName = "TestAssembly";
-		byte [] assemblyKeyToken;
-		AssemblyName an = new AssemblyName (assemblyName + ", PublicKeyToken=" + GetTokenString (token));
-		Assert.IsNotNull (an.Name, "Ctor4#1");
-		Assert.AreEqual (an.Name, assemblyName, "Ctor4#2");
-		Assert.IsNotNull (assemblyKeyToken = an.GetPublicKeyToken (), "Ctor4#3");
-		Assert.AreEqual (assemblyKeyToken, token, "Ctor4#4");
-		Assert.IsNull (an.Version, "Ctor4#5");
-		Assert.IsNull (an.CultureInfo, "Ctor4#6");
+
+		try {
+			new AssemblyName (assemblyName + ", Culture=");
+			Assert.Fail ("#1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
+		}
 	}
 
 	[Test]
-	[Category("TargetJvmNotWorking")] // Not yet supported for TARGET_JVM.
-	public void Ctor5 ()
+	public void Constructor1_Culture_NotSupported ()
 	{
 		const string assemblyName = "TestAssembly";
-		const string assemblyCulture = "neutral";
-		const string assemblyVersion = "1.2.3.4";
-		byte [] assemblyKeyToken;
 
-		AssemblyName an = new AssemblyName (assemblyName + ", Version=" + assemblyVersion + 
-				", Culture=" + assemblyCulture + ", PublicKeyToken=" + GetTokenString (token));
-		Assert.IsNotNull (an.Name, "Ctor5#1");
-		Assert.AreEqual (an.Name, assemblyName, "Ctor5#2");
-		Assert.IsNotNull (an.CultureInfo, "Ctor5#3");
-		Assert.AreEqual (an.CultureInfo, new CultureInfo (""), "Ctor5#4");
-		Assert.IsNotNull (an.Version, "Ctor5#5");
-		Assert.AreEqual (an.Version, new Version (assemblyVersion), "Ctor5#6");
-		Assert.IsNotNull (assemblyKeyToken = an.GetPublicKeyToken (), "Ctor5#7");
-		Assert.AreEqual (assemblyKeyToken, token, "Ctor5#8");
+		try {
+			new AssemblyName (assemblyName + ", Culture=aa-AA");
+			Assert.Fail ("#1");
+		} catch (ArgumentException ex) {
+			// Culture name 'aa-aa' is not supported
+			Assert.AreEqual (typeof (ArgumentException), ex.GetType (), "#2");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
+			Assert.IsNotNull (ex.ParamName, "#5");
+			Assert.AreEqual ("name", ex.ParamName, "#6");
+		}
 	}
 
 	[Test]
 	[Category ("NotWorking")]
-	public void Ctor6 ()
+	public void Constructor1_ProcessorArchitecture ()
 	{
 		const string assemblyName = "TestAssembly";
-		AssemblyName an = null;
-		
-		// null argument
+		AssemblyName an = new AssemblyName (assemblyName + ", ProcessorArchitecture=X86");
+		Assert.IsNull (an.CodeBase, "CodeBase");
+		Assert.IsNull (an.CultureInfo, "CultureInfo");
+		Assert.IsNull (an.EscapedCodeBase, "EscapedCodeBase");
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "Flags");
+		Assert.AreEqual ("TestAssembly", an.FullName, "FullName");
+		Assert.AreEqual (AssemblyHashAlgorithm.None, an.HashAlgorithm, "HashAlgorithm");
+		Assert.IsNull (an.KeyPair, "KeyPair");
+		Assert.AreEqual (assemblyName, an.Name, "Name");
+		Assert.AreEqual (ProcessorArchitecture.X86, an.ProcessorArchitecture, "PA");
+		Assert.IsNull (an.Version, "Version");
+		Assert.AreEqual (AssemblyVersionCompatibility.SameMachine, 
+			an.VersionCompatibility, "VersionCompatibility");
+		Assert.IsNull (an.GetPublicKey (), "GetPublicKey");
+		Assert.IsNull (an.GetPublicKeyToken (), "GetPublicKeyToken");
+		Assert.AreEqual ("TestAssembly", an.ToString (), "ToString");
+	}
+
+	[Test]
+	[Category ("NotWorking")]
+	public void Constructor1_ProcessorArchitecture_Incomplete ()
+	{
+		const string assemblyName = "TestAssembly";
 		try {
-			an = new AssemblyName (null);
-		} catch (ArgumentNullException) {
+			new AssemblyName (assemblyName + ", ProcessorArchitecture=");
+			Assert.Fail ("#1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
 		}
-		Assert.IsNull (an, "Ctor6#1");
+	}
 
-		// empty string
-		an = null;
+	[Test]
+	[Category ("NotWorking")]
+	public void Constructor1_ProcessorArchitecture_Invalid ()
+	{
+		const string assemblyName = "TestAssembly";
 		try {
-			an = new AssemblyName ("");
-		} catch (ArgumentException) {
+			new AssemblyName (assemblyName + ", ProcessorArchitecture=XXX");
+			Assert.Fail ("#1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
 		}
-		Assert.IsNull (an, "Ctor6#2");
+	}
 
-		// incomplete entry
-		an = null;
+	[Test]
+	[Category ("NotWorking")]
+	public void Constructor1_PublicKey ()
+	{
+		const string assemblyName = "TestAssembly";
+
 		try {
-			an = new AssemblyName (assemblyName + ", Version=,Culture=neutral");
-		} catch (FileLoadException) {
+			new AssemblyName (assemblyName + ", PublicKey=" + GetTokenString (publicKey));
+			Assert.Fail ("#1");
+		} catch (SecurityException ex) {
+			// Invalid assembly public key
+			Assert.AreEqual (typeof (SecurityException), ex.GetType (), "#2");
+			Assert.AreEqual ((SecurityAction) 0, ex.Action, "#3");
+			Assert.IsNull (ex.InnerException, "#4");
+			Assert.IsNotNull (ex.Message, "#5");
 		}
-		Assert.IsNull (an, "Ctor6#3");
+	}
 
-		// bad format for version
-		an = null;
+	[Test]
+	public void Constructor1_PublicKey_Incomplete ()
+	{
+		const string assemblyName = "TestAssembly";
+		
 		try {
-			an = new AssemblyName (assemblyName + ", Version=a.b");
-		} catch (FileLoadException) {
+			new AssemblyName (assemblyName + ", PublicKey=");
+			Assert.Fail ("#1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
 		}
-		Assert.IsNull (an, "Ctor6#4");
+	}
 
-		// bad culture info
-		an = null;
+	[Test]
+	public void Constructor1_PublicKey_Invalid ()
+	{
+		const string assemblyName = "TestAssembly";
+		
 		try {
-			an = new AssemblyName (assemblyName + ", Culture=aa-AA");
-		} catch (ArgumentException) {
+			new AssemblyName (assemblyName + ", PublicKey=0024000004800000940000000602000000240000525341310004000011000000e39d99616f48cf7d6d59f345e485e713e89b8b1265a31b1a393e9894ee3fbddaf382dcaf4083dc31ee7a40a2a25c69c6d019fba9f37ec17fd680e4f6fe3b5305f71ae9e494e3501d92508c2e98ca1e22991a217aa8ce259c9882ffdfff4fbc6fa5e6660a8ff951cd94ed011e5633651b64e8f4522519b6ec84921ee22e4840e");
+			Assert.Fail ("#1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
 		}
-		Assert.IsNull (an, "Ctor6#5");
+	}
 
-		// incorrect length for key token
-		an = null;
+	[Test]
+	public void Constructor1_PublicKeyToken ()
+	{
+		const string assemblyName = "TestAssembly";
+
+		AssemblyName an = new AssemblyName (assemblyName + ", PublicKeyToken=" + GetTokenString (token));
+		Assert.IsNull (an.CodeBase, "CodeBase");
+		Assert.IsNull (an.CultureInfo, "CultureInfo");
+		Assert.IsNull (an.EscapedCodeBase, "EscapedCodeBase");
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "Flags");
+		Assert.AreEqual ("TestAssembly, PublicKeyToken=ffef94536769da06", an.FullName, "FullName");
+		Assert.AreEqual (AssemblyHashAlgorithm.None, an.HashAlgorithm, "HashAlgorithm");
+		Assert.IsNull (an.KeyPair, "KeyPair");
+		Assert.AreEqual (assemblyName, an.Name, "Name");
+		Assert.AreEqual (ProcessorArchitecture.None, an.ProcessorArchitecture, "PA");
+		Assert.IsNull (an.Version, "Version");
+		Assert.AreEqual (AssemblyVersionCompatibility.SameMachine, 
+			an.VersionCompatibility, "VersionCompatibility");
+		Assert.IsNull (an.GetPublicKey (), "GetPublicKey");
+		Assert.AreEqual (token, an.GetPublicKeyToken (), "GetPublicKeyToken");
+		Assert.AreEqual ("TestAssembly, PublicKeyToken=ffef94536769da06", an.ToString (), "ToString");
+	}
+
+	[Test]
+	public void Constructor1_PublicKeyToken_Incomplete ()
+	{
+		const string assemblyName = "TestAssembly";
+
 		try {
-			an = new AssemblyName (assemblyName + ", PublicKeyToken=27576a8182a188");
-		} catch (FileLoadException) {
+			new AssemblyName (assemblyName + ", PublicKeyToken=");
+			Assert.Fail ("#1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
 		}
-		Assert.IsNull (an, "Ctor6#6");
+	}
 
-		// Incorrect length for key
-		an = null;
+	[Test]
+	public void Constructor1_PublicKeyToken_Invalid ()
+	{
+		const string assemblyName = "TestAssembly";
+
 		try {
-			an = new AssemblyName (assemblyName + ", PublicKey=0024000004800000940000000602000000240000525341310004000011000000e39d99616f48cf7d6d59f345e485e713e89b8b1265a31b1a393e9894ee3fbddaf382dcaf4083dc31ee7a40a2a25c69c6d019fba9f37ec17fd680e4f6fe3b5305f71ae9e494e3501d92508c2e98ca1e22991a217aa8ce259c9882ffdfff4fbc6fa5e6660a8ff951cd94ed011e5633651b64e8f4522519b6ec84921ee22e4840e");
-		} catch (FileLoadException) {
+			new AssemblyName (assemblyName + ", PublicKeyToken=27576a8182a188");
+			Assert.Fail ("#1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
 		}
-		Assert.IsNull (an, "Ctor6#7");
+	}
 
-		// missing spec
-		an = null;
+	[Test]
+	[Category("TargetJvmNotWorking")] // Not yet supported for TARGET_JVM.
+	public void Constructor1_Version ()
+	{
+		const string assemblyName = "TestAssembly";
+		const string assemblyVersion = "1.2.3.4";
+		AssemblyName an = new AssemblyName (assemblyName + ", Version=" + assemblyVersion);
+		Assert.IsNull (an.CodeBase, "CodeBase");
+		Assert.IsNull (an.CultureInfo, "CultureInfo");
+		Assert.IsNull (an.EscapedCodeBase, "EscapedCodeBase");
+		Assert.AreEqual (AssemblyNameFlags.None, an.Flags, "Flags");
+		Assert.AreEqual ("TestAssembly, Version=1.2.3.4", an.FullName, "FullName");
+		Assert.AreEqual (AssemblyHashAlgorithm.None, an.HashAlgorithm, "HashAlgorithm");
+		Assert.IsNull (an.KeyPair, "KeyPair");
+		Assert.AreEqual (assemblyName, an.Name, "Name");
+		Assert.AreEqual (ProcessorArchitecture.None, an.ProcessorArchitecture, "PA");
+		Assert.AreEqual (new Version (assemblyVersion), an.Version, "Version");
+		Assert.AreEqual (AssemblyVersionCompatibility.SameMachine, 
+			an.VersionCompatibility, "VersionCompatibility");
+		Assert.IsNull (an.GetPublicKey (), "GetPublicKey");
+		Assert.IsNull (an.GetPublicKeyToken (), "GetPublicKeyToken");
+		Assert.AreEqual ("TestAssembly, Version=1.2.3.4", an.ToString (), "ToString");
+	}
+
+
+	[Test]
+	public void Constructor1_Version_Incomplete ()
+	{
+		const string assemblyName = "TestAssembly";
+
 		try {
-			an = new AssemblyName (assemblyName + ", =1.2.4.5");
-		} catch (FileLoadException) {
+			new AssemblyName (assemblyName + ", Version=, Culture=neutral");
+			Assert.Fail ("#1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
 		}
-		Assert.IsNull (an, "Ctor6#8");
+	}
 
-		// No '=' found
-		an = null;
+	[Test]
+	public void Constructor1_Version_Invalid ()
+	{
+		const string assemblyName = "TestAssembly";
+
 		try {
-			an = new AssemblyName (assemblyName + ", OtherAttribute");
-		} catch (FileLoadException) {
+			new AssemblyName (assemblyName + ", Version=a.b");
+			Assert.Fail ("#1");
+		} catch (FileLoadException ex) {
+			// The given assembly name or codebase was invalid
+			Assert.AreEqual (typeof (FileLoadException), ex.GetType (), "#2");
+			Assert.IsNull (ex.FileName, "#3");
+			Assert.IsNull (ex.InnerException, "#3");
+			Assert.IsNotNull (ex.Message, "#4");
 		}
-		Assert.IsNull (an, "Ctor6#9");
 	}
-
 #endif
 }
 
Index: Test/System.Reflection/ChangeLog
===================================================================
--- Test/System.Reflection/ChangeLog	(revision 92059)
+++ Test/System.Reflection/ChangeLog	(working copy)
@@ -1,3 +1,11 @@
+2007-12-31  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* AssemblyNameCas.cs: Sync test methods with AssemblyNameTest.cs.
+	* AssemblyNameTest.cs: Removed AssertEqualsByteArrays method since
+	NUnit supports this out-of-the-box. Use more meaningful names for
+	some existing tests. Improved existing tests and added lots more.
+	Enabled tests that were previously failing. 
+
 2007-12-28  Gert Driesen  <drieseng@users.sourceforge.net>
 
 	* AssemblyNameTest.cs: Improved culture test to cover bug #347174.
Index: Test/System.Reflection/AssemblyNameCas.cs
===================================================================
--- Test/System.Reflection/AssemblyNameCas.cs	(revision 92059)
+++ Test/System.Reflection/AssemblyNameCas.cs	(working copy)
@@ -71,9 +71,9 @@
 		public void PartialTrust_Deny_Unrestricted ()
 		{
 			// call "normal" unit with reduced privileges
-			ant.EmptyAssembly ();
-			ant.PublicKey ();
-			ant.PublicKeyToken ();
+			ant.Constructor0 ();
+			ant.SetPublicKey ();
+			ant.SetPublicKeyToken ();
 			ant.Clone_Empty ();
 		}
 
@@ -121,14 +121,14 @@
 		public void PartialTrust_PermitOnly_FileIOPermission ()
 		{
 			// call "normal" unit with reduced privileges
-			ant.FullName1 ();
-			ant.FullName2 ();
-			ant.FullName3 ();
-			ant.FullName4 ();
-			ant.FullName5 ();
-			ant.FullName6 ();
-			ant.FullName7 ();
-			ant.FullName8 ();
+			ant.FullName_Name ();
+			ant.FullName_Version ();
+			ant.FullName_Culture ();
+			ant.FullName_PublicKey_Only ();
+			ant.FullName_PublicKeyToken_Only ();
+			ant.FullName_VersionCulture ();
+			ant.FullName_VersionPublicKey ();
+			ant.FullName_CulturePublicKey ();
 			ant.HashAlgorithm ();
 			ant.Clone_Empty ();
 			// mostly because they call Assembly.GetName
Index: System.Reflection/AssemblyName.cs
===================================================================
--- System.Reflection/AssemblyName.cs	(revision 92059)
+++ System.Reflection/AssemblyName.cs	(working copy)
@@ -32,6 +32,7 @@
 using System.Configuration.Assemblies;
 using System.Globalization;
 using System.Runtime.Serialization;
+using System.Security;
 using System.Security.Cryptography;
 using System.Security.Permissions;
 using System.Text;
@@ -68,11 +69,11 @@
 		AssemblyVersionCompatibility versioncompat;
 		Version version;
 #if NET_2_0
-		ProcessorArchitecture processor_architecture = ProcessorArchitecture.MSIL;
+		ProcessorArchitecture processor_architecture = ProcessorArchitecture.None;
 #else
 		int processor_architecture;
 #endif
-        #endregion
+		#endregion
 		
 		public AssemblyName ()
 		{
@@ -154,7 +155,11 @@
 		public string FullName {
 			get {
 				if (name == null)
+#if NET_2_0
+					return string.Empty;
+#else
 					return null;
+#endif
 				StringBuilder fname = new StringBuilder ();
 				fname.Append (name);
 				if (Version != null) {
@@ -168,7 +173,7 @@
 					else
 						fname.Append (cultureinfo.Name);
 				}
-				byte[] pub_tok = GetPublicKeyToken ();
+				byte [] pub_tok = InternalGetPublicKeyToken ();
 				if (pub_tok != null) {
 					if (pub_tok.Length == 0)
 						fname.Append (", PublicKeyToken=null");
@@ -221,40 +226,83 @@
 			return (name != null) ? name : base.ToString ();
 		}
 
-		public byte[] GetPublicKey() 
+		public byte[] GetPublicKey()
 		{
 			return publicKey;
-			// FIXME: In some cases MS implementation returns 
-			// "new byte [0]" instead of null
 		}
 
-		public byte[] GetPublicKeyToken() 
+		public byte[] GetPublicKeyToken ()
 		{
 			if (keyToken != null)
 				return keyToken;
 			else if (publicKey == null)
 				return null;
 			else {
-				HashAlgorithm ha = null;
-				switch (hashalg) {
-					case AssemblyHashAlgorithm.MD5:
-						ha = MD5.Create ();
-						break;
-					default:
-						// None default to SHA1
-						ha = SHA1.Create ();
-						break;
-				}
-				byte[] hash = ha.ComputeHash (publicKey);
-				// we need the last 8 bytes in reverse order
-				keyToken = new byte [8];
-				Array.Copy (hash, (hash.Length - 8), keyToken, 0, 8);
-				Array.Reverse (keyToken, 0, 8);
+#if NET_2_0
+				if (publicKey.Length == 0)
+					return new byte [0];
+
+				throw new SecurityException ("PublicKeyToken not set.");
+#else
+				if (keyToken != null)
+					return keyToken;
+
+				if (publicKey.Length == 0)
+					return null;
+
+				keyToken = ComputePublicKeyToken ();
 				return keyToken;
+#endif
 			}
 		}
 
+		private byte [] InternalGetPublicKeyToken ()
+		{
 #if NET_2_0
+			return GetPublicKeyToken ();
+#else
+			if ((Flags & AssemblyNameFlags.PublicKey) != 0) {
+				if (publicKey == null)
+					return null;
+				if (publicKey.Length == 0 && keyToken != null)
+					return new byte [0];
+			}
+
+			if (keyToken != null)
+				return keyToken;
+
+			if (publicKey == null)
+				return null;
+
+			if (publicKey.Length == 0)
+				return new byte [0];
+
+			keyToken = ComputePublicKeyToken ();
+			return keyToken;
+#endif
+		}
+
+		private byte [] ComputePublicKeyToken ()
+		{
+			HashAlgorithm ha = null;
+			switch (hashalg) {
+			case AssemblyHashAlgorithm.MD5:
+				ha = MD5.Create ();
+				break;
+			default:
+				// None default to SHA1
+				ha = SHA1.Create ();
+				break;
+			}
+			byte [] hash = ha.ComputeHash (publicKey);
+			// we need the last 8 bytes in reverse order
+			byte [] token = new byte [8];
+			Array.Copy (hash, (hash.Length - 8), token, 0, 8);
+			Array.Reverse (token, 0, 8);
+			return token;
+		}
+
+#if NET_2_0
 		[MonoTODO]
 		public static bool ReferenceMatchesDefinition (AssemblyName reference, AssemblyName definition)
 		{
@@ -264,7 +312,14 @@
 
 		public void SetPublicKey (byte[] publicKey) 
 		{
-			flags = AssemblyNameFlags.PublicKey;
+#if NET_2_0
+			if (publicKey == null)
+				flags ^= AssemblyNameFlags.PublicKey;
+			else
+				flags |= AssemblyNameFlags.PublicKey;
+#else
+			flags |= AssemblyNameFlags.PublicKey;
+#endif
 			this.publicKey = publicKey;
 		}
 
Index: System.Reflection/ChangeLog
===================================================================
--- System.Reflection/ChangeLog	(revision 92059)
+++ System.Reflection/ChangeLog	(working copy)
@@ -1,3 +1,13 @@
+2007-12-31  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* AssemblyName.cs: Fixed default value for ProcessorArchitecture to
+	match MS. On 2.0 profile, return zero-length in FullName is no name
+	is set, and throw a SecurityException in FullName and GetPublicKeyToken
+	if a public key is set with no corresponding public key token. 
+	Fixed FullName to also include PublicKeyToken spec with "null" value
+	if public key is empty byte array. Fixed corlib part of bug #351057.
+	In SetPublicKey, modify Flags accordingly. 
+
 2007-12-26  Zoltan Varga  <vargaz@gmail.com>
 
 	* Assembly.cs (GetSatelliteAssembly): Search in the assembly directory as well.
