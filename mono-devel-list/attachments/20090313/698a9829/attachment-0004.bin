Index: mono/metadata/security-core-clr.c
===================================================================
--- mono/metadata/security-core-clr.c	(revision 129271)
+++ mono/metadata/security-core-clr.c	(working copy)
@@ -16,6 +16,7 @@
 #include "security-core-clr.h"
 
 gboolean mono_security_core_clr_test = FALSE;
+char* mono_security_core_clr_prefix = NULL;
 
 static MonoClass*
 security_critical_attribute (void)
@@ -48,9 +49,6 @@
 {
 	int level = MONO_SECURITY_CORE_CLR_TRANSPARENT;
 
-	if (!mono_security_core_clr_test && !mono_security_core_clr_is_platform_image (image))
-		return level;
-
 	if (cinfo && mono_custom_attrs_has_attr (cinfo, security_safe_critical_attribute ()))
 		level = MONO_SECURITY_CORE_CLR_SAFE_CRITICAL;
 	if (cinfo && mono_custom_attrs_has_attr (cinfo, security_critical_attribute ()))
@@ -62,55 +60,116 @@
 MonoSecurityCoreCLRLevel
 mono_security_core_clr_class_level (MonoClass *class)
 {
-	MonoCustomAttrInfo *cinfo = mono_custom_attrs_from_class (class);
-	MonoSecurityCoreCLRLevel lvl = mono_security_core_clr_level_from_cinfo (cinfo, class->image);
+	MonoCustomAttrInfo *cinfo;
+	MonoSecurityCoreCLRLevel level = MONO_SECURITY_CORE_CLR_TRANSPARENT;
 
-	if (cinfo)
+	/* non-platform code is always Transparent - whatever the attributes says */
+	if (!mono_security_core_clr_test && !mono_security_core_clr_is_platform_image (class->image))
+		return level;
+
+	cinfo = mono_custom_attrs_from_class (class);
+	if (cinfo) {
+		level = mono_security_core_clr_level_from_cinfo (cinfo, class->image);
 		mono_custom_attrs_free (cinfo);
+	}
 
-	if (lvl == MONO_SECURITY_CORE_CLR_TRANSPARENT && class->nested_in)
-		return mono_security_core_clr_class_level (class->nested_in);
-	else
-		return lvl;
+	if (level == MONO_SECURITY_CORE_CLR_TRANSPARENT && class->nested_in)
+		level = mono_security_core_clr_class_level (class->nested_in);
+
+	return level;
 }
 
 MonoSecurityCoreCLRLevel
 mono_security_core_clr_method_level (MonoMethod *method, gboolean with_class_level)
 {
-	MonoCustomAttrInfo *cinfo = mono_custom_attrs_from_method (method);
-	MonoSecurityCoreCLRLevel level = mono_security_core_clr_level_from_cinfo (cinfo, method->klass->image);
+	MonoCustomAttrInfo *cinfo;
+	MonoSecurityCoreCLRLevel level = MONO_SECURITY_CORE_CLR_TRANSPARENT;
 
+	/* non-platform code is always Transparent - whatever the attributes says */
+	if (!mono_security_core_clr_test && !mono_security_core_clr_is_platform_image (method->klass->image))
+		return level;
+
+	cinfo = mono_custom_attrs_from_method (method);
+	if (cinfo) {
+		level = mono_security_core_clr_level_from_cinfo (cinfo, method->klass->image);
+		mono_custom_attrs_free (cinfo);
+	}
+
 	if (with_class_level && level == MONO_SECURITY_CORE_CLR_TRANSPARENT)
 		level = mono_security_core_clr_class_level (method->klass);
 
-	if (cinfo)
-		mono_custom_attrs_free (cinfo);
-
 	return level;
 }
 
+/*
+ * mono_security_core_clr_is_platform_image:
+ *
+ *   Return the (cached) boolean value indicating if this image represent platform code
+ */
 gboolean
 mono_security_core_clr_is_platform_image (MonoImage *image)
 {
+	return image->core_clr_platform_code;
+}
+
+static char* platform_code_assemblies [] = {
+	"mscorlib",
+	"Microsoft.VisualBasic",
+	"System",
+	"System.Core",
+	"System.Net",
+	"System.Runtime.Serialization",
+	"System.ServiceModel",
+	"System.ServiceModel.Web",
+	"System.Windows",
+	"System.Windows.Browser",
+	"System.Xml",
+	NULL
+};
+
+/*
+ * mono_security_core_clr_determine_platform_image:
+ *
+ *   Check if this image represent platform code
+ */
+gboolean
+mono_security_core_clr_determine_platform_image (MonoImage *image)
+{
+	/* FIXME: existing code not safe enough wrt XAP XXX we need to better define *platform* code (e.g. location) 
 	const char *prefix = mono_assembly_getrootdir ();
 	int prefix_len = strlen (prefix);
-	static const char subprefix[] = "/mono/2.1/";
-	int subprefix_len = strlen (subprefix);
+	static const char subprefix[] = "/2.1/";
+	int subprefix_len = strlen (subprefix); */
+	int i;
 
+	if (mono_security_get_mode () != MONO_SECURITY_MODE_CORE_CLR)
+		return FALSE;
+
 	if (!image->name)
 		return FALSE;
+
+	for (i = 0; i < 11; i++) {
+		if (strstr (image->name, platform_code_assemblies[i]))
+			return TRUE;
+	}
+	return FALSE;
+
+/*
 	if (strncmp (prefix, image->name, prefix_len) != 0)
 		return FALSE;
 	if (strncmp (subprefix, image->name + prefix_len, subprefix_len) != 0)
 		return FALSE;
 	if (strchr (image->name + prefix_len + subprefix_len, '/'))
 		return FALSE;
-	return TRUE;
+	return TRUE;*/
 }
 
 void
-mono_security_enable_core_clr ()
+mono_security_enable_core_clr (const char *prefix)
 {
+	mono_security_core_clr_prefix = g_strdup (prefix);
+/* we need to let the runtime knows that platform code is fully trusted (even if not in the GAC
 	mono_verifier_set_mode (MONO_VERIFIER_MODE_VERIFIABLE);
+*/
 	mono_security_set_mode (MONO_SECURITY_MODE_CORE_CLR);
 }
Index: mono/metadata/security-core-clr.h
===================================================================
--- mono/metadata/security-core-clr.h	(revision 129271)
+++ mono/metadata/security-core-clr.h	(working copy)
@@ -28,5 +28,6 @@
 extern MonoSecurityCoreCLRLevel mono_security_core_clr_method_level (MonoMethod *method, gboolean with_class_level) MONO_INTERNAL;
 
 extern gboolean mono_security_core_clr_is_platform_image (MonoImage *image) MONO_INTERNAL;
+extern gboolean mono_security_core_clr_determine_platform_image (MonoImage *image) MONO_INTERNAL;
 
 #endif	/* _MONO_METADATA_SECURITY_CORE_CLR_H_ */
Index: mono/metadata/ChangeLog
===================================================================
--- mono/metadata/ChangeLog	(revision 129133)
+++ mono/metadata/ChangeLog	(working copy)
@@ -1,3 +1,25 @@
+2009-03-13  Sebastien Pouliot  <sebastien@ximian.com>
+
+	* appdomain.h: Add a parameter to mono_security_enable_core_clr to
+	specify the prefix leading to platform code.
+	* class.c (check_core_clr_override_method): Avoid calling 
+	mono_security_core_clr_method_level on the overrided method unless
+	the base method is decorated with a [SecurityCritical] attribute.
+	Also makes it easier to use a breakpoint on this specific condition.
+	* icall.c: Fix comment
+	* image.c (do_mono_image_open):Set core_clr_platform_code flag on
+	platform code images.
+	* metadata-internals.h: Add a core_clr_platform_code flag on 
+	_MonoImage to (cache and) know if it is representing platform 
+	code.
+	* security-core-clr.c|h: (mono_security_core_clr_class_level, 
+	mono_security_core_clr_method_level): Avoid potential 
+	MonoCustomAttrInfo allocation for transparent assemblies (e.g. 
+	user/application code) and make it easier to set breakpoints
+	(mono_security_core_clr_determine_platform_image): Temporary hack
+	to change logic to work with moon-unit. A new, safe, technique is
+	under discussion.
+
 2009-03-10  Zoltan Varga  <vargaz@gmail.com>
 
 	* reflection.c (ensure_complete_type): New helper function to call
Index: mono/metadata/class.c
===================================================================
--- mono/metadata/class.c	(revision 129271)
+++ mono/metadata/class.c	(working copy)
@@ -2730,11 +2730,13 @@
 static void
 check_core_clr_override_method (MonoClass *class, MonoMethod *override, MonoMethod *base)
 {
-	MonoSecurityCoreCLRLevel override_level = mono_security_core_clr_method_level (override, FALSE);
 	MonoSecurityCoreCLRLevel base_level = mono_security_core_clr_method_level (base, FALSE);
-
-	if (override_level != base_level && base_level == MONO_SECURITY_CORE_CLR_CRITICAL)
-		mono_class_set_failure (class, MONO_EXCEPTION_TYPE_LOAD, NULL);
+	/* if the base method is decorated with [SecurityCritical] then the overrided method MUST be too */
+	if (base_level == MONO_SECURITY_CORE_CLR_CRITICAL) {
+		MonoSecurityCoreCLRLevel override_level = mono_security_core_clr_method_level (override, FALSE);
+		if (override_level != MONO_SECURITY_CORE_CLR_CRITICAL)
+			mono_class_set_failure (class, MONO_EXCEPTION_TYPE_LOAD, NULL);
+	}
 }
 
 
Index: mono/metadata/appdomain.h
===================================================================
--- mono/metadata/appdomain.h	(revision 129271)
+++ mono/metadata/appdomain.h	(working copy)
@@ -203,7 +203,7 @@
 mono_get_exception_class    (void);
 
 void
-mono_security_enable_core_clr (void);
+mono_security_enable_core_clr (const char *prefix);
 
 G_END_DECLS
 #endif /* _MONO_METADATA_APPDOMAIN_H_ */
Index: mono/metadata/image.c
===================================================================
--- mono/metadata/image.c	(revision 129271)
+++ mono/metadata/image.c	(working copy)
@@ -911,6 +911,8 @@
 	image->name = mono_path_resolve_symlinks (fname);
 	image->ref_only = refonly;
 	image->ref_count = 1;
+	/* if MONO_SECURITY_MODE_CORE_CLR is set then determine if this image is platform code */
+	image->core_clr_platform_code = mono_security_core_clr_determine_platform_image (image);
 
 	mono_file_map_close (filed);
 	return do_mono_image_load (image, status, care_about_cli);
Index: mono/metadata/metadata-internals.h
===================================================================
--- mono/metadata/metadata-internals.h	(revision 129271)
+++ mono/metadata/metadata-internals.h	(working copy)
@@ -108,6 +108,9 @@
 	guint8 idx_string_wide : 1;
 	guint8 idx_guid_wide : 1;
 	guint8 idx_blob_wide : 1;
+
+	/* Whenever this image is considered as platform code for the CoreCLR security model */
+	guint8 core_clr_platform_code : 1;
 			    
 	char *name;
 	const char *assembly_name;
Index: mono/metadata/icall.c
===================================================================
--- mono/metadata/icall.c	(revision 129271)
+++ mono/metadata/icall.c	(working copy)
@@ -6002,7 +6002,7 @@
 
 	mono_assert (delegate_class->parent == mono_defaults.multicastdelegate_class);
 
-	/* FIME: We must check if target is visible to the caller under coreclr.
+	/* FIXME: We must check if target is visible to the caller under coreclr.
 	 * The check should be disabled otherwise as it shouldn't raise expection under fulltrust.
 	 */
 
Index: mono/mini/method-to-ir.c
===================================================================
--- mono/mini/method-to-ir.c	(revision 129271)
+++ mono/mini/method-to-ir.c	(working copy)
@@ -4460,6 +4460,32 @@
 }
 
 static MonoMethod*
+field_access_exception (void)
+{
+	static MonoMethod *method = NULL;
+
+	if (!method) {
+		MonoSecurityManager *secman = mono_security_manager_get_methods ();
+		method = mono_class_get_method_from_name (secman->securitymanager,
+							  "FieldAccessException", 2);
+	}
+	g_assert (method);
+	return method;
+}
+
+static void
+emit_throw_field_access_exception (MonoCompile *cfg, MonoMethod *caller, MonoClassField *field,
+				    MonoBasicBlock *bblock, unsigned char *ip)
+{
+	MonoMethod *thrower = field_access_exception ();
+	MonoInst *args [2];
+
+	EMIT_NEW_METHODCONST (cfg, args [0], caller);
+	EMIT_NEW_METHODCONST (cfg, args [1], field);
+	mono_emit_method_call (cfg, thrower, args, NULL);
+}
+
+static MonoMethod*
 verification_exception (void)
 {
 	static MonoMethod *method = NULL;
@@ -4481,28 +4507,60 @@
 	mono_emit_method_call (cfg, thrower, NULL, NULL);
 }
 
+static MonoMethod*
+unwrap (MonoMethod *method)
+{
+	if (method->wrapper_type == MONO_WRAPPER_NONE)
+		return method;
+
+	/* native code (which is like Critical) can call any managed method XXX FIXME XXX to validate all usages */
+	if (method->wrapper_type == MONO_WRAPPER_NATIVE_TO_MANAGED)
+		return NULL;
+
+	/* in other cases we need to find the original method */
+	return mono_marshal_method_from_wrapper (method);
+}
+
 static void
+ensure_method_is_allowed_to_access_field (MonoCompile *cfg, MonoMethod *caller, MonoClassField *field,
+					  MonoBasicBlock *bblock, unsigned char *ip)
+{
+	/* there's no restriction to access Transparent or SafeCritical fields, so we only check calls to Critical methods */
+	if (mono_security_core_clr_class_level (mono_field_get_parent (field)) != MONO_SECURITY_CORE_CLR_CRITICAL)
+		return;
+
+	/* we can't get the coreclr security level on wrappers since they don't have the attributes */
+	caller = unwrap (caller);
+	if (!caller)
+		return;
+
+	/* only SafeCritical and Critical callers can call Critical code, so we throw if caller is Transparent */
+	if (mono_security_core_clr_method_level (caller, TRUE) == MONO_SECURITY_CORE_CLR_TRANSPARENT)
+		emit_throw_field_access_exception (cfg, caller, field, bblock, ip);
+}
+
+static void
 ensure_method_is_allowed_to_call_method (MonoCompile *cfg, MonoMethod *caller, MonoMethod *callee,
 					 MonoBasicBlock *bblock, unsigned char *ip)
 {
-	MonoSecurityCoreCLRLevel caller_level = mono_security_core_clr_method_level (caller, TRUE);
-	MonoSecurityCoreCLRLevel callee_level = mono_security_core_clr_method_level (callee, TRUE);
-	gboolean is_safe = TRUE;
+	/* there's no restriction to call Transparent or SafeCritical code, so we only check calls to Critical methods */
+	if (mono_security_core_clr_method_level (callee, TRUE) != MONO_SECURITY_CORE_CLR_CRITICAL)
+		return;
 
-	if (!(caller_level >= callee_level ||
-			caller_level == MONO_SECURITY_CORE_CLR_SAFE_CRITICAL ||
-			callee_level == MONO_SECURITY_CORE_CLR_SAFE_CRITICAL)) {
-		is_safe = FALSE;
-	}
+	/* we can't get the coreclr security level on wrappers since they don't have the attributes */
+	caller = unwrap (caller);
+	if (!caller)
+		return;
 
-	if (!is_safe)
+	/* only SafeCritical and Critical callers can call Critical code, so we throw if caller is Transparent */
+	if (mono_security_core_clr_method_level (caller, TRUE) == MONO_SECURITY_CORE_CLR_TRANSPARENT)
 		emit_throw_method_access_exception (cfg, caller, callee, bblock, ip);
 }
 
 static gboolean
 method_is_safe (MonoMethod *method)
 {
-	/*
+	/* FIXME: looks somewhat incomplete
 	if (strcmp (method->name, "unsafeMethod") == 0)
 		return FALSE;
 	*/
@@ -7744,6 +7802,12 @@
 				FIELD_ACCESS_FAILURE;
 			mono_class_init (klass);
 
+			/* XXX this is technically required but, so far (SL2), no [SecurityCritical] types (not many exists) have
+			   any visible *instance* field  (in fact there's a single case for a static field in Marshal) XXX
+			if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)
+				ensure_method_is_allowed_to_access_field (cfg, method, field, bblock, ip);
+			*/
+
 			foffset = klass->valuetype? field->offset - sizeof (MonoObject): field->offset;
 			if (*ip == CEE_STFLD) {
 				if (target_type_is_incompatible (cfg, field->type, sp [1]))
@@ -7877,6 +7941,10 @@
 			if (!dont_verify && !cfg->skip_visibility && !mono_method_can_access_field (method, field))
 				FIELD_ACCESS_FAILURE;
 
+			/* if the class is Critical then transparent code cannot access it's fields */
+			if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)
+				ensure_method_is_allowed_to_access_field (cfg, method, field, bblock, ip);
+
 			/*
 			 * We can only support shared generic static
 			 * field access on architectures where the
Index: mono/mini/ChangeLog
===================================================================
--- mono/mini/ChangeLog	(revision 129271)
+++ mono/mini/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2009-03-13  Sebastien Pouliot  <sebastien@ximian.com>
+
+	* method-to-ir.c: Allow CoreCLR to throw FieldAccessException. Handle
+	method wrappers.
+
 2009-03-13  Zoltan Varga  <vargaz@gmail.com>
 
 	* dwarfwriter.c (emit_line_number_info): Fix eglib build as eglib doesn't
