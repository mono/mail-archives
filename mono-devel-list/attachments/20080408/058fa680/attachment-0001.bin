Index: mono/eglib/test/utf8.c
===================================================================
--- mono/eglib/test/utf8.c	(revision 100107)
+++ mono/eglib/test/utf8.c	(working copy)
@@ -269,6 +269,221 @@
 		return OK;
 }
 
+static RESULT
+ucs4_to_utf16_check_result (const gunichar2 *result_str, const gunichar2 *expected_str,
+			    glong result_items_read, glong expected_items_read,
+			    glong result_items_written, glong expected_items_written,
+			    GError* result_error, gboolean expect_error)
+{
+	glong i;
+	if (result_items_read != expected_items_read)
+		return FAILED("Incorrect number of items read %d", result_items_read);
+	if (result_items_written != expected_items_written)
+		return FAILED("Incorrect number of items written %d", result_items_written);
+	if (result_error && !expect_error)
+		return FAILED("There should not be an error code.");
+	if (!result_error && expect_error)
+		return FAILED("Unexpected error object.");
+	if (expect_error && result_str)
+		return FAILED("NULL should be returned when an error occurs.");
+	if (!expect_error && !result_str)
+		return FAILED("When no error occurs NULL should not be returned.");
+	for (i=0; i<expected_items_written;i++) {
+		if (result_str [i] != expected_str [i])
+			return FAILED("Incorrect value %d at index %d", result_str [i], i);
+	}
+	if (result_str && result_str[expected_items_written] != '\0') 
+		return FAILED("Null termination not found at the end of the string.");
+	
+	return OK;
+}
+
+RESULT
+test_ucs4_to_utf16 ()
+{
+	static gunichar str1[12] = {'H','e','l','l','o',' ','W','o','r','l','d','\0'};
+	static gunichar2 exp1[12] = {'H','e','l','l','o',' ','W','o','r','l','d','\0'};
+	static gunichar str2[3] = {'h',0x80000000,'\0'};
+	static gunichar2 exp2[2] = {'h','\0'};
+	static gunichar str3[3] = {'h',0xDA00,'\0'};
+	static gunichar str4[3] = {'h',0x10FFFF,'\0'};
+	static gunichar2 exp4[4] = {'h',0xdbff,0xdfff,'\0'};
+	static gunichar str5[7] = {0xD7FF,0xD800,0xDFFF,0xE000,0x110000,0x10FFFF,'\0'};
+	static gunichar2 exp5[5] = {0xD7FF,0xE000,0xdbff,0xdfff,'\0'};
+	static glong read_write[12] = {1,1,0,0,0,0,1,1,0,0,1,2};
+	gunichar2* res;
+	glong items_read, items_written, current_write_index;
+	GError* err=0;
+	RESULT check_result;
+	glong i;
+	
+	res = g_ucs4_to_utf16 (str1, 12, &items_read, &items_written, &err);
+	check_result = ucs4_to_utf16_check_result (res, exp1, items_read, 11, items_written, 11, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	res = g_ucs4_to_utf16 (str2, 0, &items_read, &items_written, &err);
+	check_result = ucs4_to_utf16_check_result (res, exp2, items_read, 0, items_written, 0, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	res = g_ucs4_to_utf16 (str2, 1, &items_read, &items_written, &err);
+	check_result = ucs4_to_utf16_check_result (res, exp2, items_read, 1, items_written, 1, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	res = g_ucs4_to_utf16 (str2, 2, &items_read, &items_written, &err);
+	check_result = ucs4_to_utf16_check_result (res, 0, items_read, 1, items_written, 0, err, TRUE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	err = 0;
+	res = g_ucs4_to_utf16 (str3, 2, &items_read, &items_written, &err);
+	check_result = ucs4_to_utf16_check_result (res, 0, items_read, 1, items_written, 0, err, TRUE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	err = 0;
+	res = g_ucs4_to_utf16 (str4, 5, &items_read, &items_written, &err);
+	check_result = ucs4_to_utf16_check_result (res, exp4, items_read, 2, items_written, 3, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	// This loop tests the bounds of the conversion algorithm
+	current_write_index = 0;
+	for (i=0;i<6;i++) {
+		items_read = items_written = 0;
+		err = 0;
+		res = g_ucs4_to_utf16 (&str5[i], 1, &items_read, &items_written, &err);
+		check_result = ucs4_to_utf16_check_result (res, &exp5[current_write_index], 
+					items_read, read_write[i*2], items_written, read_write[(i*2)+1], err, !read_write[(i*2)+1]);
+		if (check_result) return check_result;
+		g_free (res);
+		current_write_index += items_written;
+	}
+
+	return OK;
+}
+
+static RESULT
+utf16_to_ucs4_check_result (const gunichar *result_str, const gunichar *expected_str,
+			    glong result_items_read, glong expected_items_read,
+			    glong result_items_written, glong expected_items_written,
+			    GError* result_error, gboolean expect_error)
+{
+	glong i;
+	if (result_items_read != expected_items_read)
+		return FAILED("Incorrect number of items read %d", result_items_read);
+	if (result_items_written != expected_items_written)
+		return FAILED("Incorrect number of items written %d", result_items_written);
+	if (result_error && !expect_error)
+		return FAILED("There should not be an error code.");
+	if (!result_error && expect_error)
+		return FAILED("Unexpected error object.");
+	if (expect_error && result_str)
+		return FAILED("NULL should be returned when an error occurs.");
+	if (!expect_error && !result_str)
+		return FAILED("When no error occurs NULL should not be returned.");
+	for (i=0; i<expected_items_written;i++) {
+		if (result_str [i] != expected_str [i])
+			return FAILED("Incorrect value %d at index %d", result_str [i], i);
+	}
+	if (result_str && result_str[expected_items_written] != '\0') 
+		return FAILED("Null termination not found at the end of the string.");
+	
+	return OK;
+}
+
+RESULT
+test_utf16_to_ucs4 ()
+{
+	static gunichar2 str1[12] = {'H','e','l','l','o',' ','W','o','r','l','d','\0'};
+	static gunichar exp1[12] = {'H','e','l','l','o',' ','W','o','r','l','d','\0'};
+	static gunichar2 str2[7] = {'H', 0xD800, 0xDC01,0xD800,0xDBFF,'l','\0'};
+	static gunichar exp2[3] = {'H',0x00010001,'\0'};
+	static gunichar2 str3[4] = {'H', 0xDC00 ,'l','\0'};
+	static gunichar exp3[2] = {'H','\0'};
+	static gunichar2 str4[20] = {0xDC00,0xDFFF,0xDFF,0xD800,0xDBFF,0xD800,0xDC00,0xD800,0xDFFF,
+				     0xD800,0xE000,0xDBFF,0xDBFF,0xDBFF,0xDC00,0xDBFF,0xDFFF,0xDBFF,0xE000,'\0'};
+	static gunichar exp4[6] = {0xDFF,0x10000,0x103ff,0x10fc00,0x10FFFF,'\0'};
+	static glong read_write[33] = {1,0,0,1,0,0,1,1,1,2,1,0,2,2,1,2,2,1,2,1,0,2,1,0,2,2,1,2,2,1,2,1,0};
+	gunichar* res;
+	glong items_read, items_written, current_read_index,current_write_index;
+	GError* err=0;
+	RESULT check_result;
+	glong i;
+	
+	res = g_utf16_to_ucs4 (str1, 12, &items_read, &items_written, &err);
+	check_result = utf16_to_ucs4_check_result (res, exp1, items_read, 11, items_written, 11, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	res = g_utf16_to_ucs4 (str2, 0, &items_read, &items_written, &err);
+	check_result = utf16_to_ucs4_check_result (res, exp2, items_read, 0, items_written, 0, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	res = g_utf16_to_ucs4 (str2, 1, &items_read, &items_written, &err);
+	check_result = utf16_to_ucs4_check_result (res, exp2, items_read, 1, items_written, 1, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+	
+	items_read = items_written = 0;
+	res = g_utf16_to_ucs4 (str2, 2, &items_read, &items_written, &err);
+	check_result = utf16_to_ucs4_check_result (res, exp2, items_read, 1, items_written, 1, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	res = g_utf16_to_ucs4 (str2, 3, &items_read, &items_written, &err);
+	check_result = utf16_to_ucs4_check_result (res, exp2, items_read, 3, items_written, 2, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	res = g_utf16_to_ucs4 (str2, 4, &items_read, &items_written, &err);
+	check_result = utf16_to_ucs4_check_result (res, exp2, items_read, 3, items_written, 2, err, FALSE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	res = g_utf16_to_ucs4 (str2, 5, &items_read, &items_written, &err);
+	check_result = utf16_to_ucs4_check_result (res, exp2, items_read, 4, items_written, 0, err, TRUE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	items_read = items_written = 0;
+	err = 0;
+	res = g_utf16_to_ucs4 (str3, 5, &items_read, &items_written, &err);
+	check_result = utf16_to_ucs4_check_result (res, exp3, items_read, 1, items_written, 0, err, TRUE);
+	if (check_result) return check_result;
+	g_free (res);
+
+	// This loop tests the bounds of the conversion algorithm
+	current_read_index = current_write_index = 0;
+	for (i=0;i<11;i++) {
+		items_read = items_written = 0;
+		err = 0;
+		res = g_utf16_to_ucs4 (&str4[current_read_index], read_write[i*3], &items_read, &items_written, &err);
+		check_result = utf16_to_ucs4_check_result (res, &exp4[current_write_index], items_read, 
+					     read_write[(i*3)+1], items_written, read_write[(i*3)+2], err, 
+					     !read_write[(i*3)+2]);
+		if (check_result) return check_result;
+		g_free (res);
+		current_read_index += read_write[i*3];
+		current_write_index += items_written;
+	}
+
+	return OK;
+}
+
 /*
  * test initialization
  */
@@ -279,6 +494,8 @@
 	{"g_utf8_seq", test_utf8_seq},
 	{"g_convert", test_convert },
 	{"g_unichar_xdigit_value", test_xdigit },
+	{"g_ucs4_to_utf16", test_ucs4_to_utf16 },
+	{"g_utf16_to_ucs4", test_utf16_to_ucs4 },
 	{NULL, NULL}
 };
 
Index: mono/eglib/src/gutf8.c
===================================================================
--- mono/eglib/src/gutf8.c	(revision 100107)
+++ mono/eglib/src/gutf8.c	(working copy)
@@ -380,18 +380,170 @@
 	return ret;
 }
 
+static glong
+g_ucs4_to_utf16_len (const gunichar *str, glong len, glong *items_read, GError **error)
+{
+	glong retlen = 0;
+	glong errindex = 0;
+	const gunichar *lstr = str;
+
+	if (!str)
+		return 0;
+
+	while (*lstr != '\0' && len--) {
+		gunichar ch;
+		ch = *lstr++;
+		if (ch <= 0x0000FFFF) { 
+			if (ch >= 0xD800 && ch <= 0xDFFF) {
+				errindex = (glong)(lstr - str)-1;
+				if (error)
+					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
+					"Invalid sequence in conversion input");
+				if (items_read)
+					*items_read = errindex;
+				return 0;
+			} else {
+				retlen++;
+			}
+		} else if (ch > 0x10FFFF) {
+			errindex = (glong)(lstr - str)-1;
+			if (error)
+				g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
+				"Character out of range for UTF-16");
+			if (items_read)
+				*items_read = errindex;
+			return 0;
+
+		} else {
+			retlen+=2;
+		}
+	}
+
+	if (items_read)
+		*items_read = (glong)(lstr - str);
+	return retlen;
+}
+
 gunichar2*
 g_ucs4_to_utf16 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error)
 {
-	g_assert_not_reached ();
+	glong allocsz;
+	gunichar2 *retstr = 0;
+	gunichar2 *retch = 0;
+	glong nwritten = 0;
+	GError *lerror =0 ;
 
-	return NULL;
+	allocsz = g_ucs4_to_utf16_len (str, len, items_read, &lerror);
+
+	if (!lerror) {
+		retch = retstr = g_malloc ((allocsz+1) * sizeof (gunichar2));
+		retstr[allocsz] = '\0';
+
+		while (*str != '\0' && len--) {
+			gunichar ch;
+			ch = *str++;
+			if (ch <= 0x0000FFFF && (ch < 0xD800 || ch > 0xDFFF)) {
+				*retch++ = (gunichar2)ch;
+				nwritten ++;
+			} else {
+				ch -= 0x0010000UL;
+				*retch++ = (gunichar2)((ch >> 10) + 0xD800);
+				*retch++ = (gunichar2)((ch & 0x3FFUL) + 0xDC00);
+				nwritten +=2;
+			}
+		}
+	}
+
+	if (items_written)
+		*items_written = nwritten;
+	if (error)
+		*error = lerror;
+
+	return retstr;
 }
 
+static glong
+g_utf16_to_ucs4_len (const gunichar2 *str, glong len, glong *items_read, GError **error)
+{
+	glong retlen = 0;
+	glong errindex = 0;
+	const gunichar2 *lstr = str;
+	gunichar2 ch,ch2;
+
+	if (!str)
+		return 0;
+
+	while (*lstr != '\0' && len--) {
+		ch = *lstr++;
+		if (ch >= 0xD800 && ch <= 0xDBFF) {
+			if (!len--) {
+				lstr--;
+				break;
+			}
+			ch2 = *lstr;
+			if (ch2 >= 0xDC00 && ch2 <= 0xDFFF) {
+				lstr++;
+			} else {
+				errindex = (glong)(lstr - str);
+				if (error)
+					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
+					"Invalid sequence in conversion input");
+				if (items_read)
+					*items_read = errindex;
+				return 0;
+			}
+		} else {
+			if (ch >= 0xDC00 && ch <= 0xDFFF) {
+				errindex = (glong)(lstr - str)-1;
+				if (error)
+					g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
+					"Invalid sequence in conversion input");
+				if (items_read)
+					*items_read = errindex;
+				return 0;
+			}
+		}
+		retlen++;
+	}
+
+	if (items_read)
+		*items_read = (glong)(lstr - str);
+
+	return retlen;
+}
+
 gunichar*
 g_utf16_to_ucs4 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error)
 {
-	g_assert_not_reached ();
+	glong allocsz;
+	gunichar *retstr = 0;
+	gunichar *retch = 0;
+	glong nwritten = 0;
+	GError *lerror =0 ;
+	gunichar ch,ch2;
 
-	return NULL;
+	allocsz = g_utf16_to_ucs4_len (str, len, items_read, &lerror);
+
+	if (!lerror) {
+		retch = retstr = g_malloc ((allocsz+1) * sizeof (gunichar));
+		retstr[allocsz] = '\0';
+		nwritten = allocsz;
+
+		while (*str != '\0' && allocsz--) {
+			ch = *str++;
+			if (ch >= 0xD800 && ch <= 0xDBFF) {
+				ch2 = *str++;
+				ch = ((ch - (gunichar)0xD800) << 10)
+				      + (ch2 - (gunichar)0xDC00) + (gunichar)0x0010000UL;
+			}
+			*retch++ = ch;
+		}
+	}
+
+	if (items_written)
+		*items_written = nwritten;
+	if (error)
+		*error = lerror;
+
+	return retstr;
 }
Index: mono/eglib/src/glib.h
===================================================================
--- mono/eglib/src/glib.h	(revision 100107)
+++ mono/eglib/src/glib.h	(working copy)
@@ -562,6 +562,8 @@
 
 gunichar2 *g_utf8_to_utf16 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error);
 gchar     *g_utf16_to_utf8 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error);
+gunichar2 *g_ucs4_to_utf16 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error);
+gunichar  *g_utf16_to_ucs4 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error);
 
 #define u8to16(str) g_utf8_to_utf16(str, (glong)strlen(str), NULL, NULL, NULL)
 
Index: mono/eglib/ChangeLog
===================================================================
--- mono/eglib/ChangeLog	(revision 100107)
+++ mono/eglib/ChangeLog	(working copy)
@@ -1,5 +1,15 @@
-2007-03-19  Bill Holmes  <billholmes54@gmail.com>
+2008-04-08  Bill Holmes  <billholmes54@gmail.com>
 
+	* src/glib.h : Adding declarations for g_ucs4_to_utf16 and g_utf16_to_ucs4.
+
+	* src/gutf8.c : Adding implementation for g_ucs4_to_utf16 and g_utf16_to_ucs4.
+
+	* test/utf8.c Adding tests for g_ucs4_to_utf16 and g_utf16_to_ucs4.
+
+	Contributed under MIT/X11 license.
+
+2008-03-19  Bill Holmes  <billholmes54@gmail.com>
+
 	* src/gpath.c (g_path_is_absolute) : Adding a case for '/'
 	  on Windows.
 	