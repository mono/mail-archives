Index: System.Messaging/System.Messaging/ChangeLog
===================================================================
--- System.Messaging/System.Messaging/ChangeLog	(revision 121890)
+++ System.Messaging/System.Messaging/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2008-12-20  Michael Barker  <mike@middlesoft.co.uk>
+
+	* MessageQueue.cs:  Added implementation for async methods: BeginReceive,
+	BeginPeek, EndReceive and EndPeek.
+	
 2008-11-23  Michael Barker  <mike@middlesoft.co.uk>
 
 	* MessageQueue.cs:  Added support for MessageQueueTransactionType methods, 
Index: System.Messaging/System.Messaging/MessageQueue.cs
===================================================================
--- System.Messaging/System.Messaging/MessageQueue.cs	(revision 121890)
+++ System.Messaging/System.Messaging/MessageQueue.cs	(working copy)
@@ -34,6 +34,7 @@
 using System.ComponentModel;
 using System.Drawing;
 using System.Messaging.Design;
+using System.Threading;
 
 using Mono.Messaging;
 
@@ -372,47 +373,48 @@
 
 		#region Methods
 
-		[MonoTODO]
 		public IAsyncResult BeginPeek ()
 		{
-			throw new NotImplementedException ();
+			return new PeekAsyncResult (null, this, InfiniteTimeout, NullAsyncCallback);
 		}
-		[MonoTODO]
+
 		public IAsyncResult BeginPeek (TimeSpan timeout)
 		{
-			throw new NotImplementedException ();
+			return new PeekAsyncResult (null, this, timeout, NullAsyncCallback);
 		}
-		[MonoTODO]
+
 		public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject)
 		{
-			throw new NotImplementedException ();
+			return new PeekAsyncResult (stateObject, this,
+			                            timeout, NullAsyncCallback);
 		}
-		[MonoTODO]
+
 		public IAsyncResult BeginPeek (TimeSpan timeout,
 									  object stateObject,
 									  AsyncCallback callback)
 		{
-			throw new NotImplementedException ();
-		}
-		[MonoTODO]
+			return new PeekAsyncResult (stateObject, this, timeout, callback);
+		}		
+
 		public IAsyncResult BeginReceive ()
 		{
-			throw new NotImplementedException ();
+			return new ReceiveAsyncResult (null, this, InfiniteTimeout, NullAsyncCallback);
 		}
-		[MonoTODO]
+
 		public IAsyncResult BeginReceive (TimeSpan timeout)
 		{
-			throw new NotImplementedException ();
+			return new ReceiveAsyncResult (null, this,
+			                               timeout, NullAsyncCallback);
 		}
-		[MonoTODO]
+
 		public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject)
 		{
-			throw new NotImplementedException ();
+			return new ReceiveAsyncResult (stateObject, this, timeout, NullAsyncCallback);
 		}
-		[MonoTODO]
+
 		public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback)
 		{
-			throw new NotImplementedException ();
+			return new ReceiveAsyncResult (stateObject, this, timeout, callback);
 		}
 		[MonoTODO]
 		public static void ClearConnectionCache ()
@@ -445,15 +447,23 @@
 			QueueReference qRef = QueueReference.Parse (path);
 			MessagingProviderLocator.GetProvider ().DeleteQueue (qRef);
 		}
-		[MonoTODO]
+
 		public Message EndPeek (IAsyncResult asyncResult)
 		{
-			throw new NotImplementedException ();
+			if (asyncResult == null)
+				throw new ArgumentNullException ();
+			
+			PeekAsyncResult result = (PeekAsyncResult) asyncResult;
+			return result.Message;
 		}
-		[MonoTODO]
+		
 		public Message EndReceive (IAsyncResult asyncResult)
 		{
-			throw new NotImplementedException ();
+			if (asyncResult == null)
+				throw new ArgumentNullException ();
+			
+			ReceiveAsyncResult result = (ReceiveAsyncResult) asyncResult;
+			return result.Message;
 		}
 
 		public static bool Exists (string path)
@@ -1154,5 +1164,96 @@
 		{
 			return MessagingProviderLocator.GetProvider ().Exists (qRef);
 		}
+		
+		internal void NullAsyncCallback (IAsyncResult result)
+		{
+		}
+		
+		internal class ReceiveAsyncResult : IAsyncResult {
+			
+			private readonly object asyncState;
+			protected readonly EventWaitHandle asyncWaitHandle;
+			protected volatile bool isCompleted;
+			protected readonly MessageQueue q;
+			private readonly Thread t;
+			protected Message message;
+			protected readonly TimeSpan timeout;
+			protected readonly AsyncCallback callback;
+			
+			public ReceiveAsyncResult (object asyncState,
+			                           MessageQueue q,
+			                           TimeSpan timeout,
+			                           AsyncCallback callback)
+			{
+				this.asyncState = asyncState;
+				this.asyncWaitHandle = new EventWaitHandle (false, EventResetMode.AutoReset);
+				this.q = q;
+				this.timeout = timeout;
+				this.callback = callback;
+				this.t = new Thread(run);
+				t.Start ();
+			}
+			
+			public object AsyncState {
+				get { return asyncState; }
+			}
+			
+			public WaitHandle AsyncWaitHandle {
+				get { return asyncWaitHandle; }
+			}
+			
+			public bool CompletedSynchronously {
+				get { return false; }
+			}
+			
+			public bool IsCompleted {
+				get { return isCompleted; }
+			}
+			
+			private void run()
+			{
+				try {
+					if (timeout == InfiniteTimeout)
+						message = q.Receive ();
+					else
+						message = q.Receive (timeout);
+					
+					isCompleted = true;
+					callback (this);
+				} finally {
+					asyncWaitHandle.Set ();
+				}
+			}
+			
+			internal Message Message {
+				get { return message; }
+			}
+		}
+
+		internal class PeekAsyncResult : ReceiveAsyncResult {
+						
+			public PeekAsyncResult (object asyncState,
+			                        MessageQueue q,
+			                        TimeSpan timeout,
+			                        AsyncCallback callback)
+				: base (asyncState, q, timeout, callback)
+			{
+			}
+			
+			private void run()
+			{
+				try {
+					if (timeout == InfiniteTimeout)
+						message = q.Peek ();
+					else
+						message = q.Peek (timeout);
+					
+					isCompleted = true;
+					callback (this);
+				} finally {
+					asyncWaitHandle.Set ();
+				}
+			}			
+		}
 	}
 }