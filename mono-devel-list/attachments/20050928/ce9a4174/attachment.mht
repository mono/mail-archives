[From nobody Fri Feb  8 09:01:03 2008
Subject: Re: [Mono-dev] HTTPS - MS .NET Client - Linux Mono Server -
	Interoperability
From: Yngve Zackrisson &lt;yngve.zackrisson@mobila-kontoret.se&gt;
To: sebastien.pouliot@gmail.com
In-Reply-To: &lt;1127909536.30652.119.camel@localhost.localdomain&gt;
References: &lt;1127744779.7652.83.camel@localhost.localdomain&gt;
	&lt;1127751032.30652.29.camel@localhost.localdomain&gt;
	&lt;1127815308.3839.69.camel@localhost.localdomain&gt;
	&lt;1127825227.30652.81.camel@localhost.localdomain&gt;
	&lt;1127900562.3865.133.camel@localhost.localdomain&gt;
	&lt;1127909536.30652.119.camel@localhost.localdomain&gt;
Content-Type: text/plain
Organization: Mobila Kontoret
Message-Id: &lt;1127911855.4830.26.camel@localhost.localdomain&gt;
Mime-Version: 1.0
X-Mailer: Ximian Evolution 1.4.6 (1.4.6-2) 
Date: Wed, 28 Sep 2005 14:50:55 +0200
Content-Transfer-Encoding: 7bit

On Wed, 2005-09-28 at 14:12, Sebastien Pouliot wrote:
&gt; Hello Yngve,
&gt; 
&gt; On Wed, 2005-28-09 at 11:42 +0200, Yngve Zackrisson wrote:
&gt; &gt; Hello Sebastien,
&gt; &gt; 
&gt; &gt; Things seems to go better for me, 
&gt; 
&gt; great :)
&gt; 
&gt; &gt; but I still have problems 
&gt; &gt; with my server side (Mono) authentication and decryption.
&gt; &gt; I now use a PKCS#12 file on my server side.
&gt; &gt; Se below for more info.
&gt; 
&gt; ...
&gt; 
&gt; &gt; &gt; &gt; For the authentication probably an custom channel have to be used.
&gt; &gt; &gt; 
&gt; &gt; &gt; I don't see why this would be required (for client-side certificates) as
&gt; &gt; &gt; the authentication is part of the protocol itself.
&gt; &gt; &gt; 
&gt; &gt; 
&gt; &gt; OK. Maybe I do not need this.
&gt; &gt; I just read some articles/samples at msdn about 
&gt; &gt; .NET Remoting Authentication 
&gt; &gt; and those articles suggested a custom channel.
&gt; &gt; (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dndotnet/html/remsspi.asp and http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dndotnet/html/remsec.asp
&gt; &gt; and
&gt; &gt; http://msdn.microsoft.com/msdnmag/issues/03/06/NETRemoting/default.aspx
&gt; &gt; ). 
&gt; &gt; The examples was about other forms of authentication (Kerberos etc) 
&gt; &gt; and encryption so these references may not apply?.
&gt; 
&gt; I don't think you'll need that unless you have some additional (more
&gt; than the client certificate) authentication data.
&gt; 
&gt; ...
&gt; 
&gt; &gt; We intend to sign both our server and client certificates 
&gt; &gt; with our own root CA.
&gt; &gt; There is already unix scripts for this using openssl, 
&gt; &gt; hence the preference for openssl.
&gt; 
&gt; Ok, so you'll have a single root CA signing both your server and client
&gt; certificate. This root certificate will have to be in the Mono's Trusted
&gt; store on the server.
&gt; 
&gt; ...
&gt; 
&gt; &gt; &gt; &gt; Binary formating shall be used.
&gt; &gt; &gt; 
&gt; &gt; &gt; Was there a specific reason for using https and a binary formatting ? If
&gt; &gt; &gt; I understand correctly you'll be supplying your own server software ? so
&gt; &gt; &gt; you _could_ use SSL without using HTTP(S).
&gt; &gt; 
&gt; &gt; Firewalls.
&gt; 
&gt; Ok, so it's a port issue (not a protocol issue).
&gt; 
&gt; &gt; &gt; &gt; The server is in house and should be a Linux one.
&gt; &gt; &gt; &gt; We use latest version on Mono (1.1.9).
&gt; &gt; &gt; 
&gt; &gt; &gt; Is the server software using Mono.Security.dll ? 
&gt; &gt; &gt; or is it using (vanilla or custom) XSP ?
&gt; &gt; 
&gt; &gt; Currently Mono.Security.dll.
&gt; &gt; 
&gt; &gt; The intention is to run the services as &quot;Windows services&quot; in Mono,
&gt; &gt; if that works.
&gt; 
&gt; Remember that if the Mono service runs under another identity then the
&gt; trusted root certificate must either be (a) in that user Trust store or
&gt; (b) in the machine Trust store.
&gt; 
&gt; &gt; I have not got into this yet, so we might have to shift.
&gt; &gt; Currently I host the remote objects in a console application.
&gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; &gt; The clients are Win32 clients using MS .NET 
&gt; &gt; &gt; &gt; (v1.0 or v1.1 with SP enough to handle the certificates).
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; The clients are not connected all the time, but only during 
&gt; &gt; &gt; &gt; initialization and zip file transfer.
&gt; &gt; &gt; &gt; 
&gt; &gt; &gt; &gt; The installation on the client side should be as simple as possible 
&gt; &gt; &gt; &gt; for the clients. 
&gt; &gt; &gt; &gt; Hence, preferable PKCS#12 client certificates should be used 
&gt; &gt; &gt; &gt; and it should preferable be stored only in one file or in one store 
&gt; &gt; &gt; &gt; (Windows store).
&gt; &gt; &gt; 
&gt; &gt; &gt; You'll either have to :
&gt; &gt; &gt; 
&gt; &gt; &gt; (a) write your own glue (p/invokes) if you want Mono.Security.dll to
&gt; &gt; &gt; co-exists with Windows certificate stores;
&gt; &gt; &gt; 
&gt; &gt; &gt; (b) completely skip Mono.Security.dll on the client side. I.e. once
&gt; &gt; &gt; installed &quot;correctly&quot; the MS runtime should be able to &quot;find&quot; the
&gt; &gt; &gt; private key matching the certificate you use in HttpWebRequest.
&gt; &gt; 
&gt; &gt; OK. I have gone for (b).
&gt; &gt; 
&gt; &gt; First I set the ServicePointManager.CertificatePolicy 
&gt; &gt; to an custom class to detect any certificate errors.
&gt; &gt; 
&gt; &gt; Then I use a DLL from Mentalis (Org.Mentalis.Security.dll) 
&gt; &gt; to extract the client certificates from the Windows store, 
&gt; &gt; and then select on the IssuerName.
&gt; &gt; Once that done, I use the Mentalis Certificate.ToX509() method 
&gt; &gt; to convert to X509Certificate(s).
&gt; &gt; (See: http://www.mentalis.org/ and 
&gt; &gt; http://www.mentalis.org/soft/projects/certificates/ ).
&gt; &gt; 
&gt; &gt; Last I create the HttpWebRequest, 
&gt; &gt; Add the X509Certificate(s) the requests ClientCertificates 
&gt; &gt; and set the WebResponse to the HttpWebRequest.GetResponse().
&gt; &gt; It seems to work (on the client side). 
&gt; &gt; No more &quot;Untrusted root&quot;, since the certificates 
&gt; &gt; is in the Windows store now.
&gt; 
&gt; That's ok.
&gt; 
&gt; &gt; Other options for extracting the certificate(s) 
&gt; &gt; from the Windows store seems to be: 
&gt; &gt; 
&gt; &gt; Using CryptoAPI calls:
&gt; &gt; http://support.microsoft.com/default.aspx?scid=kb;en-us;895971
&gt; &gt; 
&gt; &gt; Using a CAPICOM wrapper: 
&gt; &gt; http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncapi/html/netcryptoapi.asp
&gt; &gt; 
&gt; &gt; Using WS-Security with the Web Service Developement Kit:
&gt; &gt; http://www.codeproject.com/csharp/cryptography.asp
&gt; 
&gt; Yes, they are the other options.
&gt; 
&gt; &gt; &gt; &gt; As a first step, I would like to have the HttpWebRequest 
&gt; &gt; &gt; &gt; and HttpWebResponse to work toghther with HTTPS.
&gt; &gt; &gt; 
&gt; &gt; &gt; MS version of HttpWebRequest.ClientCertificates will &quot;try to find&quot;
&gt; &gt; &gt; private keys (in it's store) associated with the certificate(s) you're
&gt; &gt; &gt; supplying.
&gt; &gt; &gt; 
&gt; &gt; &gt; Note that you may have problems if the client application runs on
&gt; &gt; &gt; another identity (e.g. services runs as SYSTEM).
&gt; &gt; 
&gt; &gt; OK. (Seems no problem for me).
&gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; Then, on the server side, you'll get this certificate (from
&gt; &gt; &gt; SslServerStream) and you can validate it (with your own code) and decide
&gt; &gt; &gt; what to do next...
&gt; &gt; 
&gt; &gt; Here I still have problems.
&gt; &gt; 
&gt; &gt; I have created a mssslserver2.exe based on your mssslserver.exe.
&gt; &gt; The difference is that mssslserver2.exe uses 
&gt; &gt; a PKCS#12-filename and a password as arguments, 
&gt; &gt; instead of a .cer-filename and .pvk-filename.
&gt; &gt; I have change the internals accordingly.
&gt; &gt; 
&gt; &gt; When I run this program with: 
&gt; &gt; 
&gt; &gt; $ mono --debug --verbose mssslserver2.exe server16-cert.p12 'password'
&gt; &gt; 
&gt; &gt; and call this with my client HttpWebRequest, 
&gt; &gt; I got this error message on my server: 
&gt; &gt; 
&gt; &gt;     error #-2146762486
&gt; &gt; 
&gt; &gt; meaning a CERT_E_CHAINING problem 
&gt; &gt; (also: X509ChainStatusFlags.UntrustedRoot 
&gt; &gt; and AlertDescription.UnknownCA).
&gt; &gt; 
&gt; &gt; I am pretty sure I have the right cert, key and CA in the .p12 file.
&gt; &gt; It seems that the root CA could not be found if it is in a PKCS#12 file.
&gt; 
&gt; The root can (very probably) be found in the PKCS#12 file. However it
&gt; _cannot_ be trusted *unless* it's installed in the Trust store.
&gt; 
&gt; &gt; Should I add a PKCS#12 cert file to the Mono Store (Machine store) 
&gt; &gt; (mono /.../certmgr.exe -add -c -m Trust server16-cert.p12) 
&gt; &gt; or add only the CA to the trust store
&gt; &gt; (mono /.../certmgr.exe -add -c -m Trust cacert16t.cer)
&gt; &gt; or anything else to get rid of this error message?.
&gt; 
&gt; It must be either the user or machine Trusted store (otherwise you'll
&gt; get a trust error).

OK. But witch certificate is preferable to add to the store?: 

a) mono /.../certmgr.exe -add -c -m Trust server16-cert.p12

or 

b) mono /.../certmgr.exe -add -c -m Trust cacert16t.cer



I also have a question about the trust of the root CA certificate.
The cacert16t.cer above I have created with the following 
openssl commands:

...
$ openssl x509 -in cacert16.pem -trustout -setalias &quot;TrustedRootCert&quot;
-out cacert16t.pem

$ openssl x509 -inform PEM -in cacert16t.pem -outform DER -out
cacert16t.cer

is the first openssl command necessary since the signed client 
and server certificates, or at least its root CA, 
should be added to the Windows/Mono (Trust) store?.



Currently I use the cacert16t.pem file as -certfile 
when creating the client and server PKCS#12 files - 
with the openssl pkcs12 command.
Will the cacert16.pem file be enough?



&gt; 
&gt; &gt; On the server I get an exception during the client call 
&gt; &gt; (in: reader.ReadLine ()) below: 
&gt; &gt; &gt;&gt;&gt;
&gt; &gt; ...
&gt; &gt; using (SslServerStream s = new SslServerStream (ns, Certificate, true, 
&gt; &gt; false)) {
&gt; &gt; ... 
&gt; &gt; StreamReader reader = new StreamReader (s);
&gt; &gt; ...
&gt; &gt; string line;
&gt; &gt; // Read request header 
&gt; &gt; do {
&gt; &gt;         line = reader.ReadLine ();
&gt; &gt; ...
&gt; &gt; &lt;&lt;&lt;
&gt; &gt; 
&gt; &gt; The exception goes like this:
&gt; &gt; &gt;&gt;&gt;
&gt; &gt; EXCEPTION handling: TlsException
&gt; &gt; EXCEPTION handling: TlsException
&gt; &gt; EXCEPTION handling: IOException
&gt; &gt; EXCEPTION handling: IOException
&gt; &gt; ---------------------------------------------------------
&gt; &gt; System.IO.IOException: The authentication or decryption has failed. ---&gt;
&gt; &gt; Mono.Security.Protocol.Tls.TlsException: Handshake Failure.
&gt; &gt; in &lt;0x00134&gt; 
&gt; &gt; Mono.Security.Protocol.Tls.Handshake.Server.TlsClientCertificateVerify:ProcessAsSs3  ()
&gt; &gt; in &lt;0x00057&gt; 
&gt; &gt; Mono.Security.Protocol.Tls.Handshake.HandshakeMessage:Process ()
&gt; &gt; in (wrapper remoting-invoke-with-check) 
&gt; &gt; Mono.Security.Protocol.Tls.Handshake.HandshakeMessage:Process ()
&gt; &gt; in &lt;0x00084&gt; 
&gt; &gt; Mono.Security.Protocol.Tls.ServerRecordProtocol:ProcessHandshakeMessage 
&gt; &gt; (Mono.Security.Protocol.Tls.TlsStream handMsg)
&gt; &gt; in &lt;0x00239&gt; 
&gt; &gt; Mono.Security.Protocol.Tls.RecordProtocol:InternalReceiveRecordCallBack 
&gt; &gt; (IAsyncResult asyncResult)--- End of inner exception stack trace ---
&gt; &gt; 
&gt; &gt; in &lt;0x000d4&gt; 
&gt; &gt; Mono.Security.Protocol.Tls.SslStreamBase:AsyncHandshakeCallback
&gt; &gt; (IAsyncResult asyncResult)
&gt; &gt; &lt;&lt;&lt;
&gt; &gt; 
&gt; &gt; I guess that this has to do with the CERT_E_CHAINING problem 
&gt; &gt; mentioned above. Possible?. Right?
&gt; 
&gt; Maybe but I don't think so.
&gt; 
&gt; Yesterday (after your previous email) I tried to use the MS runtime for
&gt; client certificate without success (same failure). Somehow MS does
&gt; something different* because the server can't verify the signature (and
&gt; it's not a key and/or decryption problem - the hash value is different
&gt; but the padding is ok).
&gt; 
&gt; Using IE (with the SSL2 client hello) to do the same turned out another
&gt; problem, very similar to the bug #76254 reported today.
&gt; 
&gt; [*] The client certificate testing is done with wget/openssl
&gt; (linux/cygwin) - which sadly doesn't seems enough :(

Please let me know if you come up with some solution.

I have been working with the HTTPS communication for some 2 months now, 
and my boss is eager to get an solution :-).



Regards 



Yngve Zackrisson.

]