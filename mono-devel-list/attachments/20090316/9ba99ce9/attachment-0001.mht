[From nobody Mon Mar 16 15:01:06 2009
Message-ID: &lt;49B09274.50608@us.ibm.com&gt;
Date: Thu, 05 Mar 2009 21:03:16 -0600
From: Steven Munroe &lt;munroesj@us.ibm.com&gt;
Reply-To: munroesj@us.ibm.com
User-Agent: Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.19)
	Gecko/20081213 SUSE/1.1.14-1.1 SeaMonkey/1.1.14
MIME-Version: 1.0
To: mono-devel &lt;mono-devel-list@lists.ximian.com&gt;,
	Paolo Molaro &lt;lupus@ximian.com&gt;
CC: Mark Probst &lt;mark.probst@gmail.com&gt;
Subject: [PATCH] Update AuxV memcpy and icbi optimizations
Content-Type: multipart/mixed; boundary=&quot;------------070602030605080708060400&quot;


--------------070602030605080708060400
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

This patch address Paolo's concerns

We need this committed in some form so I can move on to other
optimizations.

Paolo Molaro wrote:

&gt; &gt; &lt;snip&gt;
&gt; &gt;
&gt; &gt; Headers included without proper checks, besides, pthread is not needed
&gt; &gt; here, elf.h can be simply avoided (there was already a structure to
&gt; &gt; represent the auxv data that you deleted).
&gt; &gt;
&gt; &gt;   
&gt;   
cleaned up the use of header to be the minimum.

&gt;&gt; &gt;&gt; +volatile static ElfW(auxv_t) *linux_auxv_buf = NULL;
&gt;&gt; &gt;&gt;     
&gt;&gt;     
&gt; &gt;
&gt; &gt; We don't want to keep this data duplicated in memory: there is no use
&gt; &gt; except using more memory.
&gt; &gt;
&gt; &gt;   
&gt;   
I Now free the buffer at the end of mono_arch_cpu_init.


&gt;&gt; &gt;&gt; +		/* Older kernels did not support /proc/&lt;PID&gt;/auxv. But
&gt;&gt; &gt;&gt; +		   the auvx table does exist in the process address
&gt;&gt; &gt;&gt; +		   space following the env table. So try scanning over
&gt;&gt; &gt;&gt; +		   the environment table to find the auxv. */
&gt;&gt; &gt;&gt; +			if (errno == ENOENT) {
&gt;&gt; &gt;&gt; +				auxv_temp = (ElfW(auxv_t)*) linux_find_auxv();
&gt;&gt; &gt;&gt; +		/* If someone has done a setenv() the __environ pointer
&gt;&gt; &gt;&gt; +		   may have been moved and the assumption that the auxv
&gt;&gt; &gt;&gt; +		   follows is not true. So look at the first entry and
&gt;&gt; &gt;&gt; +		   verify that it is an auxv entry. */
&gt;&gt; &gt;&gt;     
&gt;&gt;     
&gt; &gt;
&gt; &gt; If this detection is not reliable we should simply not do it. We can
&gt; &gt; document that users should have a 2.6 kernel.
&gt; &gt;
&gt; &gt;   
&gt;   
This the method we support in libauxv.so so I don't why mono should be
different.

&gt;&gt; &gt;&gt; +			} else {
&gt;&gt; &gt;&gt; +				perror(&quot;Error opening file for reading&quot;);
&gt;&gt; &gt;&gt;     
&gt;&gt;     
&gt; &gt;
&gt; &gt; We don't want to bother users with an error message that is both
&gt; &gt; non-informative and that they can't do anything about.
&gt; &gt;
&gt; &gt;   
&gt;   
Ok, removed these and the associated headers.


&gt;&gt; &gt;&gt; +static pthread_once_t auxv_once_control = PTHREAD_ONCE_INIT;
&gt;&gt; &gt;&gt;     
&gt;&gt;     
&gt; &gt;
&gt; &gt; There is no need to use pthread_once_t: just doing the setup in the init
&gt; &gt; call is ok.
&gt; &gt;
&gt; &gt;   
&gt;   
Ok, removed

&gt; &gt; &lt;snip&gt;
&gt;   
&gt;&gt; &gt;&gt; +/* Number of independent load store pipes in each core. */
&gt;&gt; &gt;&gt; +static int		linux_ppc_LSUs = 0;
&gt;&gt; &gt;&gt; +/* Number of independent fixed point pipes in each core. */
&gt;&gt; &gt;&gt; +static int		linux_ppc_FXUs = 0;
&gt;&gt; &gt;&gt; +/* Number of independent floating point pipes in each core. */
&gt;&gt; &gt;&gt; +static int		linux_ppc_FPUs = 0;
&gt;&gt; &gt;&gt;     
&gt;&gt;     
&gt; &gt;
&gt; &gt; A single uint bitmask can replace all of the above for the jit usage.
&gt; &gt; Besides, having one or more load/store units is not a linux property,
&gt; &gt; so the names of the variables is incorrect.
&gt; &gt;
&gt; &gt;   
&gt;   
Actually with current and future processors in the pipeline a bitmask is
not enough.


&gt;&gt; &gt;&gt; +#ifdef PPC_FEATURE_ICACHE_SNOOP
&gt;&gt; &gt;&gt; +#define HAS_ICACHE_SNOOP (linux_ppc_hwcap &amp; PPC_FEATURE_ICACHE_SNOOP)
&gt;&gt; &gt;&gt; +#else
&gt;&gt; &gt;&gt; +#define HAS_ICACHE_SNOOP 0
&gt;&gt; &gt;&gt; +#endif
&gt;&gt; &gt;&gt; +
&gt;&gt; &gt;&gt; +static int
&gt;&gt; &gt;&gt; +linux_init_ppc_SMP(void)
&gt;&gt; &gt;&gt; +{
&gt;&gt; &gt;&gt; +	struct utsname u;
&gt;&gt; &gt;&gt; +	/* FIXME For 2.6.26 kernels we can try to use sysfs
&gt;&gt; &gt;&gt; +	   /sys/devices/system/cpu/possible,  but we would have to fall
&gt;&gt; &gt;&gt; +	   back to uname for early kernels anyway. */
&gt;&gt; &gt;&gt; +
&gt;&gt; &gt;&gt; +	if (uname(&amp;u) != 0) {
&gt;&gt; &gt;&gt; +		perror(&quot;Error uname syscall failer\n&quot;);
&gt;&gt; &gt;&gt; +		return 1;
&gt;&gt; &gt;&gt; +	}
&gt;&gt; &gt;&gt; +
&gt;&gt; &gt;&gt; +	if (strstr(u.version, &quot;SMP&quot;))
&gt;&gt; &gt;&gt; +		return 1;
&gt;&gt; &gt;&gt; +	else {
&gt;&gt; &gt;&gt; +		if (strstr(u.version, &quot;smp&quot;))
&gt;&gt; &gt;&gt; +			return 1;
&gt;&gt; &gt;&gt; +		else
&gt;&gt; &gt;&gt; +			return 0;
&gt;&gt; &gt;&gt;     
&gt;&gt;     
&gt; &gt;
&gt; &gt; This doesn't look like a reliable way. We have already utility calls to
&gt; &gt; get the number of processors and that should be enough.
&gt; &gt;
&gt; &gt;   
&gt;   
I have not found any evidence of a framework for detecting SMP in the
mono source. Also in the server world, where dynamic CPU add is common,
a SMP capable kernel is the best evidence.


&gt; &gt; &lt;snip&gt;
&gt;   
&gt;&gt; &gt;&gt; +#else
&gt;&gt; &gt;&gt; +	if ((linux_ppc_LSUs &gt; 1) &amp;&amp; (dreg != ppc_r12) &amp;&amp; (sreg != ppc_r12)) { 
&gt;&gt; &gt;&gt; +		while (size &gt;= 8) {
&gt;&gt; &gt;&gt; +			ppc_load_reg (code, ppc_r0, soffset, sreg);
&gt;&gt; &gt;&gt; +			ppc_load_reg (code, ppc_r12, soffset+4, sreg);
&gt;&gt; &gt;&gt; +			ppc_store_reg (code, ppc_r0, doffset, dreg);
&gt;&gt; &gt;&gt; +			ppc_store_reg (code, ppc_r12, doffset+4, dreg);
&gt;&gt; &gt;&gt; +			size -= 8;
&gt;&gt; &gt;&gt; +			soffset += 8;
&gt;&gt; &gt;&gt; +			doffset += 8; 
&gt;&gt; &gt;&gt; +		}
&gt;&gt; &gt;&gt; +	}
&gt;&gt; &gt;&gt;     
&gt;&gt;     
&gt; &gt;
&gt; &gt; This optimization should be in its own separate patch (together with
&gt; &gt; numbers that show it's worthwhile).
&gt; &gt;
&gt; &gt;   
&gt;   
This was the way processor designers told us to implement memcpy. That
is why we used this used this in both GCC and GLIBC memcpy. The GLIBC
memcpy improvement where on the order of 20% for micro benchmarks.

&gt;&gt; &gt;&gt; @@ -664,21 +890,29 @@
&gt;&gt; &gt;&gt;  		isync
&gt;&gt; &gt;&gt;  	}
&gt;&gt; &gt;&gt;  #else
&gt;&gt; &gt;&gt; -	if (1) {
&gt;&gt; &gt;&gt; -		for (p = start; p &lt; endp; p += cachelineinc) {
&gt;&gt; &gt;&gt; -			asm (&quot;dcbf 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
&gt;&gt; &gt;&gt; +	/* For POWER5/6 with ICACHE_SNOOP the dcbst/icbi is not required.  */
&gt;&gt; &gt;&gt; +	if (!HAS_ICACHE_SNOOP) {
&gt;&gt; &gt;&gt; +		if (linux_ppc_SMP) {
&gt;&gt; &gt;&gt; +			for (p = start; p &lt; endp; p += cachelineinc) {
&gt;&gt; &gt;&gt; +				asm (&quot;dcbf 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
&gt;&gt; &gt;&gt; +			}
&gt;&gt; &gt;&gt; +		} else {
&gt;&gt; &gt;&gt; +			for (p = start; p &lt; endp; p += cachelineinc) {
&gt;&gt; &gt;&gt; +				asm (&quot;dcbst 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
&gt;&gt; &gt;&gt; +			}
&gt;&gt; &gt;&gt;     
&gt;&gt;     
&gt; &gt;
&gt; &gt; The changes to icache flush should be a separate patch. As I said already
&gt; &gt; on irc, though, unless there is a bug in the code, changes to it should
&gt; &gt; be done only if there are hard numbers showing that the change is a
&gt; &gt; performance benefit in some real-world case. The code as it is written
&gt; &gt; fixed some random crashes happening a few years ago, so there must be
&gt; &gt; very strong reasons to change it even a single instruction.
&gt; &gt;
&gt; &gt;   
&gt;   
I provided results in a separate email.






--------------070602030605080708060400
Content-Type: text/plain; name=&quot;ppc-part4-opt-20090303.txt&quot;
Content-Disposition: inline; filename=&quot;ppc-part4-opt-20090303.txt&quot;
Content-Transfer-Encoding: 7bit

2009-03-04  Steven Munroe  &lt;munroesj@us.ibm.com&gt;

This patch is contributed under the terms of the MIT/X11 license

	* mini-ppc.c: Add includes to get at Aux vector definitions..
	[__linux__]: Define functions linux_find_auxv, linux_get_auxv,
	linux_auxv_init_once, linux_query_auxv, linux_init_ppc_SMP,
	linux_init_ppc_platform.
	Define flags/values auxv_once_control, linux_ppc_hwcap,
	linux_ppc_platform, linux_ppc_ISA2x, linux_ppc_ISA2x_mask,
	linux_ppc_SMP, linux_ppc_LSUs, linux_ppc_FXUs, linux_ppc_FPUs.
	Define macros HAS_ICACHE_SNOOP.
	(emit_memcpy): Generate optimized code for longer moves where
	linux_ppc_LSUs is 2 or more.
	(mono_arch_cpu_init) [__linux__]: Add calls to linux_auxv_init_once
	and linux_init_ppc_platform.
	(mono_arch_flush_icache) [__linux__]: Use linux_query_auxv
	(AT_DCACHEBSIZE) and set cachelineinc and cachelinesize.
	Optimize using HAS_ICACHE_SNOOP, linux_ppc_SMP, and
	linux_ppc_ISA2x.
	(mono_arch_output_basic_block)[__mono_ppc64__]: Replace
	lwz/lwzx/extsw sequence with lwa/lwax.
	(mono_arch_output_basic_block): Replace ppc_addic with ppc_addi
	for case OP_JMP.
	(mono_arch_emit_epilog): Replace ppc_addic with ppc_addi for
	unstacking frames.

diff -urN mono-svn-20090301/mono/mono/mini/mini-ppc.c mono-svn/mono/mono/mini/mini-ppc.c
--- mono-svn-20090301/mono/mono/mini/mini-ppc.c	2009-03-01 08:37:35.000000000 -0600
+++ mono-svn/mono/mono/mini/mini-ppc.c	2009-03-03 00:41:47.000000000 -0600
@@ -11,6 +11,13 @@
  */
 #include &quot;mini.h&quot;
 #include &lt;string.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;link.h&gt;
+#ifdef __linux__
+#include &lt;asm/cputable.h&gt;
+#include &lt;sys/utsname.h&gt;
+#endif
 
 #include &lt;mono/metadata/appdomain.h&gt;
 #include &lt;mono/metadata/debug-helpers.h&gt;
@@ -153,6 +160,189 @@
 	return &quot;unknown&quot;;
 }
 
+static int cachelinesize = 0;
+
+#ifdef __linux__
+/* Scan the env to find the aux vector. */
+static inline char** linux_find_auxv (void)
+{
+	char **result = __environ;
+	/* Scan over the env vector looking for the ending NULL */
+	for (; *result != NULL; ++result) {
+	}
+	/* Bump the pointer one more step, which should be the auxv. */
+	return ++result;
+}
+
+static ElfW(auxv_t) *linux_auxv_buf = NULL;
+
+static ElfW(auxv_t) * 
+linux_get_auxv(void)
+{
+	ElfW(auxv_t) *auxv_temp = (ElfW(auxv_t) *)linux_auxv_buf;
+	int auxv_f;
+	size_t page_size = getpagesize();
+	ssize_t bytes;
+
+	/* If the /proc/self/auxv file has not been copied into the heap
+	   yet, then do it */
+
+	if(auxv_temp == NULL)
+	{
+		auxv_f = open(&quot;/proc/self/auxv&quot;, O_RDONLY);
+
+		if(auxv_f == -1) {
+		/* Older kernels did not support /proc/&lt;PID&gt;/auxv. But
+		   the auvx table does exist in the process address
+		   space following the env table. So try scanning over
+		   the environment table to find the auxv. */
+			if (errno == ENOENT) {
+				auxv_temp = (ElfW(auxv_t)*) linux_find_auxv();
+		/* If someone has done a setenv() the __environ pointer
+		   may have been moved and the assumption that the auxv
+		   follows is not true. So look at the first entry and
+		   verify that it is an auxv entry. */
+				if (auxv_temp-&gt;a_type != AT_IGNOREPPC) {
+					return 0;
+				}
+			} else {
+				return 0;
+			}
+		} else {
+			auxv_temp = (ElfW(auxv_t) *)malloc(page_size);
+
+			bytes = read (auxv_f, (void*)auxv_temp, page_size);
+			if (bytes &gt; 0) {
+			} else {
+				free (auxv_temp);
+				auxv_temp = NULL;
+				return 0;
+      			}
+			/* We have the auxv buffered and the file handle
+			   is no longer needed. so close the file. */
+			close (auxv_f);
+		}
+		linux_auxv_buf = auxv_temp;
+	}
+	return (ElfW(auxv_t) *)auxv_temp;
+}
+
+static ElfW(Addr) 
+linux_query_auxv(int type)
+{
+	ElfW(auxv_t) *auxv_temp;
+	int i = 0;
+
+	/* if the /proc/self/auxv file has not been copied into
+	   the heap yet, then do it now.  */
+	auxv_temp = (ElfW(auxv_t) *)linux_auxv_buf;
+	if(auxv_temp == NULL) {
+		auxv_temp = linux_get_auxv();
+	}
+
+	do {
+		if(auxv_temp[i].a_type == type) {
+			return auxv_temp[i].a_un.a_val;
+		}
+		i++;
+	} while (auxv_temp[i].a_type != AT_NULL);
+
+	return 0;
+}
+
+static unsigned long	linux_ppc_hwcap;
+static char 		*linux_ppc_platform;
+static int		linux_ppc_ISA2x; /* PowerISA-2.0 or newer */
+static unsigned long	linux_ppc_ISA2x_mask = 0
+#ifdef PPC_FEATURE_POWER4 /* PowerISA-2.01 */
+			| PPC_FEATURE_POWER4
+#endif
+#ifdef PPC_FEATURE_POWER5 /* PowerISA-2.03 */
+			| PPC_FEATURE_POWER5
+#endif
+#ifdef PPC_FEATURE_POWER5_PLUS  /* PowerISA-2.04 */
+			| PPC_FEATURE_POWER5_PLUS
+#endif
+#ifdef PPC_FEATURE_CELL
+			| PPC_FEATURE_CELL
+#endif
+#ifdef PPC_FEATURE_PA6T
+			| PPC_FEATURE_PA6T
+#endif
+#ifdef PPC_FEATURE_ARCH_2_05
+			| PPC_FEATURE_ARCH_2_05
+#endif
+	; /* it took a while to figure out that the AT_HWCAP should represent
+	     ISA versions and optional categories/features and the AT_PLATFORM 
+	     should represent the CHIP design and specific micro-architecture.
+	     Which explains the mess above.*/
+
+/* Default to SMP true in case we can't find out.  */
+static int		linux_ppc_SMP = 1;
+
+/* Number of independent load store pipes in each core. */
+static int		linux_ppc_LSUs = 0;
+/* Number of independent fixed point pipes in each core. */
+static int		linux_ppc_FXUs = 0;
+/* Number of independent floating point pipes in each core. */
+static int		linux_ppc_FPUs = 0;
+
+#ifdef PPC_FEATURE_ICACHE_SNOOP
+#define HAS_ICACHE_SNOOP (linux_ppc_hwcap &amp; PPC_FEATURE_ICACHE_SNOOP)
+#else
+#define HAS_ICACHE_SNOOP 0
+#endif
+
+static int
+linux_init_ppc_SMP(void)
+{
+	struct utsname u;
+	/* FIXME For 2.6.26 kernels we can try to use sysfs
+	   /sys/devices/system/cpu/possible,  but we would have to fall
+	   back to uname for early kernels anyway. */
+
+	if (uname(&amp;u) != 0) {
+		return 1;
+	}
+
+	if (strstr(u.version, &quot;SMP&quot;))
+		return 1;
+	else {
+		if (strstr(u.version, &quot;smp&quot;))
+			return 1;
+		else
+			return 0;
+	}
+}
+
+
+static void
+linux_init_ppc_platform(void)
+{
+	
+	cachelinesize = (long) linux_query_auxv (AT_DCACHEBSIZE);
+	linux_ppc_hwcap = (unsigned long) linux_query_auxv (AT_HWCAP);
+	linux_ppc_platform = (char*) linux_query_auxv (AT_PLATFORM);
+	linux_ppc_ISA2x = (linux_ppc_hwcap &amp; linux_ppc_ISA2x_mask) != 0L;
+	linux_ppc_SMP = linux_init_ppc_SMP();
+	
+	if ((strcmp(linux_ppc_platform, &quot;power4&quot;) &gt;= 0)
+	&amp;&amp;  (strcmp(linux_ppc_platform, &quot;power6x&quot;) &lt;= 0)) {
+		linux_ppc_LSUs = 2;
+		linux_ppc_FXUs = 2;
+		linux_ppc_FPUs = 2;
+	} else if  (strcmp(linux_ppc_platform, &quot;ppc970&quot;) == 0) {
+		linux_ppc_LSUs = 2;
+		linux_ppc_FXUs = 2;
+		linux_ppc_FPUs = 2;
+	} else if  (strcmp(linux_ppc_platform, &quot;cell&quot;) == 0) {
+		linux_ppc_LSUs = 1;
+		linux_ppc_FXUs = 1;
+		linux_ppc_FPUs = 1;
+	}
+}
+#endif
+
 /* this function overwrites r0, r11, r12 */
 static guint8*
 emit_memcpy (guint8 *code, int size, int dreg, int doffset, int sreg, int soffset)
@@ -178,6 +368,20 @@
 		dreg = ppc_r12;
 	}
 #ifdef __mono_ppc64__
+	/* the hardware has multiple load/store units and the move is long
+	   enough to use more then one regiester, then use load/load/store/store
+	   to execute 2 instructions per cycle. */
+	if ((linux_ppc_LSUs &gt; 1) &amp;&amp; (dreg != ppc_r12) &amp;&amp; (sreg != ppc_r12)) { 
+		while (size &gt;= 16) {
+			ppc_load_reg (code, ppc_r0, soffset, sreg);
+			ppc_load_reg (code, ppc_r12, soffset+8, sreg);
+			ppc_store_reg (code, ppc_r0, doffset, dreg);
+			ppc_store_reg (code, ppc_r12, doffset+8, dreg);
+			size -= 16;
+			soffset += 16;
+			doffset += 16; 
+		}
+	}
 	while (size &gt;= 8) {
 		ppc_load_reg (code, ppc_r0, soffset, sreg);
 		ppc_store_reg (code, ppc_r0, doffset, dreg);
@@ -185,6 +389,18 @@
 		soffset += 8;
 		doffset += 8;
 	}
+#else
+	if ((linux_ppc_LSUs &gt; 1) &amp;&amp; (dreg != ppc_r12) &amp;&amp; (sreg != ppc_r12)) { 
+		while (size &gt;= 8) {
+			ppc_load_reg (code, ppc_r0, soffset, sreg);
+			ppc_load_reg (code, ppc_r12, soffset+4, sreg);
+			ppc_store_reg (code, ppc_r0, doffset, dreg);
+			ppc_store_reg (code, ppc_r12, doffset+4, dreg);
+			size -= 8;
+			soffset += 8;
+			doffset += 8; 
+		}
+	}
 #endif
 	while (size &gt;= 4) {
 		ppc_lwz (code, ppc_r0, soffset, sreg);
@@ -481,6 +697,14 @@
 void
 mono_arch_cpu_init (void)
 {
+#ifdef __linux__
+	if (linux_get_auxv())
+	{
+		linux_init_ppc_platform();
+		free (linux_auxv_buf);
+		linux_auxv_buf = NULL;
+	}
+#endif
 }
 
 /*
@@ -609,17 +833,11 @@
 	return 2;
 }
 
-typedef struct {
-	long int type;
-	long int value;
-} AuxVec;
-
 void
 mono_arch_flush_icache (guint8 *code, gint size)
 {
 	register guint8 *p;
 	guint8 *endp, *start;
-	static int cachelinesize = 0;
 	static int cachelineinc = 16;
 
 	if (!cachelinesize) {
@@ -637,20 +855,9 @@
 			/*g_print (&quot;setting cl size to %d\n&quot;, cachelinesize);*/
 		}
 #elif defined(__linux__)
-		/* sadly this will work only with 2.6 kernels... */
-		FILE* f = fopen (&quot;/proc/self/auxv&quot;, &quot;rb&quot;);
-		if (f) {
-			AuxVec vec;
-			while (fread (&amp;vec, sizeof (vec), 1, f) == 1) {
-				if (vec.type == 19) {
-					cachelinesize = vec.value;
-					break;
-				}
-			}
-			fclose (f);
-		}
 		if (!cachelinesize)
 			cachelinesize = 128;
+		cachelineinc = cachelinesize;
 #elif defined(G_COMPILER_CODEWARRIOR)
 	cachelinesize = 32;
 	cachelineinc = 32;
@@ -686,22 +893,41 @@
 		isync
 	}
 #else
-	if (1) {
-		for (p = start; p &lt; endp; p += cachelineinc) {
-			asm (&quot;dcbf 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
-		}
+	/* For POWER5/6 with ICACHE_SNOOPing only one icbi in the range is required.
+	   The sync is required to insure that the store queue is completely empty.
+	   While the icbi performs no cache operations, icbi/isync is required to
+	   kill local prefetch.  */
+	if (HAS_ICACHE_SNOOP) {
+		asm (&quot;sync&quot;);
+		asm (&quot;icbi 0,%0;&quot; : : &quot;r&quot;(code) : &quot;memory&quot;);
+		asm (&quot;isync&quot;);	
 	} else {
+	/* use dcbf for smp support, see pem._64bit.d20030611.pdf page 211 */
+		if (linux_ppc_SMP) {
+			for (p = start; p &lt; endp; p += cachelineinc) {
+				asm (&quot;dcbf 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
+			}
+		} else {
+			for (p = start; p &lt; endp; p += cachelineinc) {
+				asm (&quot;dcbst 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
+			}
+		}
+		asm (&quot;sync&quot;);
+		p = code;
+	/* for ISA2.0+ implementations we should not need any extra sync between the
+	   icbi instructions.  Both the 2.0 PEM and the PowerISA-2.05 say this.
+	   So I am not sure which chip had this problem but its not an issue on
+	   of the ISA V2 chips. */
 		for (p = start; p &lt; endp; p += cachelineinc) {
-			asm (&quot;dcbst 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
+			if (linux_ppc_ISA2x)
+				asm (&quot;icbi 0,%0;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
+			else
+				asm (&quot;icbi 0,%0; sync;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
 		}
+		if (!linux_ppc_ISA2x)
+			asm (&quot;sync&quot;);
+		asm (&quot;isync&quot;);
 	}
-	asm (&quot;sync&quot;);
-	p = code;
-	for (p = start; p &lt; endp; p += cachelineinc) {
-		asm (&quot;icbi 0,%0; sync;&quot; : : &quot;r&quot;(p) : &quot;memory&quot;);
-	}
-	asm (&quot;sync&quot;);
-	asm (&quot;isync&quot;);
 #endif
 }
 
@@ -4531,7 +4757,6 @@
 						ppc_sthx (code, ainfo-&gt;reg, ppc_r11, inst-&gt;inst_basereg);
 					}
 					break;
-#ifdef __mono_ppc64__
 				case 4:
 					if (ppc_is_imm16 (inst-&gt;inst_offset)) {
 						ppc_stw (code, ainfo-&gt;reg, inst-&gt;inst_offset, inst-&gt;inst_basereg);
@@ -4540,8 +4765,16 @@
 						ppc_stwx (code, ainfo-&gt;reg, ppc_r11, inst-&gt;inst_basereg);
 					}
 					break;
-#else
 				case 8:
+#ifdef __mono_ppc64__
+					if (ppc_is_imm16 (inst-&gt;inst_offset)) {
+						ppc_std (code, ainfo-&gt;reg, inst-&gt;inst_offset, inst-&gt;inst_basereg);
+					} else {
+						ppc_load (code, ppc_r11, inst-&gt;inst_offset);
+						ppc_stdx (code, ainfo-&gt;reg, ppc_r11, inst-&gt;inst_basereg);
+					}
+					break;
+#else
 					if (ppc_is_imm16 (inst-&gt;inst_offset + 4)) {
 						ppc_stw (code, ainfo-&gt;reg, inst-&gt;inst_offset, inst-&gt;inst_basereg);
 						ppc_stw (code, ainfo-&gt;reg + 1, inst-&gt;inst_offset + 4, inst-&gt;inst_basereg);
@@ -4551,8 +4784,8 @@
 						ppc_stw (code, ainfo-&gt;reg, 0, ppc_r11);
 						ppc_stw (code, ainfo-&gt;reg + 1, 4, ppc_r11);
 					}
-					break;
 #endif
+					break;
 				default:
 					if (ppc_is_imm16 (inst-&gt;inst_offset)) {
 						ppc_store_reg (code, ainfo-&gt;reg, inst-&gt;inst_offset, inst-&gt;inst_basereg);

--------------070602030605080708060400--
]