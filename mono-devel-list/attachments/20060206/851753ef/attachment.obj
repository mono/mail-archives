Index: Test/System.Xml.Serialization/XmlSerializerTests.cs
===================================================================
--- Test/System.Xml.Serialization/XmlSerializerTests.cs	(revision 56569)
+++ Test/System.Xml.Serialization/XmlSerializerTests.cs	(working copy)
@@ -41,6 +41,7 @@
 	[TestFixture]
 	public class XmlSerializerTests
 	{
+		private const string XmlSchemaInstanceNamespace = "http://www.w3.org/2001/XMLSchema-instance";
 		StringWriter sw;
 		XmlTextWriter xtw;
 		XmlSerializer xs;
@@ -70,7 +71,14 @@
 			xs = new XmlSerializer(o.GetType());
 			xs.Serialize(xtw, o);
 		}
-		
+
+		private void Serialize (object o, XmlTypeMapping typeMapping)
+		{
+			SetUpWriter ();
+			xs = new XmlSerializer (typeMapping);
+			xs.Serialize (xtw, o);
+		}
+
 		private void Serialize(object o, Type type)
 		{
 			SetUpWriter();
@@ -98,7 +106,20 @@
 			xs = new XmlSerializer(o.GetType(), root);
 			xs.Serialize(xtw, o);
 		}
-		
+
+		private void SoapSerialize (object o)
+		{
+			SoapSerialize (o, o.GetType ());
+		}
+
+		private void SoapSerialize (object o, Type type)
+		{
+			XmlTypeMapping mapping = CreateSoapMapping (type);
+			SetUpWriter ();
+			xs = new XmlSerializer (mapping);
+			xs.Serialize (xtw, o);
+		}
+
 		// test constructors
 #if USE_VERSION_1_1	// It doesn't pass on MS.NET 1.1.
 		[Test]
@@ -203,25 +224,373 @@
 		public void TestSerializeEnumeration()
 		{
 			Serialize(SimpleEnumeration.FIRST);
-			Assert.AreEqual (Infoset ("<SimpleEnumeration>FIRST</SimpleEnumeration>"), WriterText);
-			
+			Assert.AreEqual (Infoset ("<SimpleEnumeration>FIRST</SimpleEnumeration>"), WriterText, "#A1");
 			Serialize(SimpleEnumeration.SECOND);
-			Assert.AreEqual (Infoset ("<SimpleEnumeration>SECOND</SimpleEnumeration>"), WriterText);
+			Assert.AreEqual (Infoset ("<SimpleEnumeration>SECOND</SimpleEnumeration>"), WriterText, "#A2");
+
+			SoapSerialize (SimpleEnumeration.FIRST);
+			Assert.AreEqual (string.Format(CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<SimpleEnumeration d1p1:type='SimpleEnumeration' xmlns:d1p1='{0}'>FIRST</SimpleEnumeration>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#B1");
+			SoapSerialize (SimpleEnumeration.SECOND);
+			Assert.AreEqual (string.Format(CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<SimpleEnumeration d1p1:type='SimpleEnumeration' xmlns:d1p1='{0}'>SECOND</SimpleEnumeration>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#B2");
 		}
 		
 		[Test]
-		public void TestSerializeEnumDefaultValue() {
-			Serialize(new EnumDefaultValue());
-			Assert.AreEqual (Infoset ("<EnumDefaultValue />"), WriterText);
-			
-			Serialize(new EnumDefaultValueNF());
+		public void TestSerializeEnumDefaultValue ()
+		{
+			Serialize (new EnumDefaultValue ());
+			Assert.AreEqual (Infoset ("<EnumDefaultValue />"), WriterText, "#1");
+			Serialize (new SimpleEnumeration ());
+			Assert.AreEqual (Infoset ("<SimpleEnumeration>FIRST</SimpleEnumeration>"), WriterText, "#2");
+			Serialize (3, typeof (EnumDefaultValue));
+			Assert.AreEqual (Infoset ("<EnumDefaultValue>e3</EnumDefaultValue>"), WriterText, "#3");
+			Serialize (EnumDefaultValue.e3, typeof (EnumDefaultValue));
+			Assert.AreEqual (Infoset ("<EnumDefaultValue>e3</EnumDefaultValue>"), WriterText, "#4");
+			Serialize (EnumDefaultValue.e1 | EnumDefaultValue.e2, typeof (EnumDefaultValue));
+			Assert.AreEqual (Infoset ("<EnumDefaultValue>e3</EnumDefaultValue>"), WriterText, "#5");
+			Serialize (EnumDefaultValue.e1 | EnumDefaultValue.e2 | EnumDefaultValue.e3, typeof (EnumDefaultValue));
+			Assert.AreEqual (Infoset ("<EnumDefaultValue>e3</EnumDefaultValue>"), WriterText, "#6");
+			Serialize (EnumDefaultValue.e1 | EnumDefaultValue.e3, typeof (EnumDefaultValue));
+			Assert.AreEqual (Infoset ("<EnumDefaultValue>e3</EnumDefaultValue>"), WriterText, "#7");
+			Serialize (EnumDefaultValue.e2 | EnumDefaultValue.e3, typeof (EnumDefaultValue));
+			Assert.AreEqual (Infoset ("<EnumDefaultValue>e3</EnumDefaultValue>"), WriterText, "#8");
+			Serialize (3, typeof (FlagEnum));
+			Assert.AreEqual (Infoset ("<FlagEnum>one two</FlagEnum>"), WriterText, "#9");
+			Serialize (5, typeof (FlagEnum));
+			Assert.AreEqual (Infoset ("<FlagEnum>one four</FlagEnum>"), WriterText, "#10");
+			Serialize (FlagEnum.e4, typeof (FlagEnum));
+			Assert.AreEqual (Infoset ("<FlagEnum>four</FlagEnum>"), WriterText, "#11");
+			Serialize (FlagEnum.e1 | FlagEnum.e2, typeof (FlagEnum));
+			Assert.AreEqual (Infoset ("<FlagEnum>one two</FlagEnum>"), WriterText, "#12");
+			Serialize (FlagEnum.e1 | FlagEnum.e2 | FlagEnum.e4, typeof (FlagEnum));
+			Assert.AreEqual (Infoset ("<FlagEnum>one two four</FlagEnum>"), WriterText, "#13");
+			Serialize (FlagEnum.e1 | FlagEnum.e4, typeof (FlagEnum));
+			Assert.AreEqual (Infoset ("<FlagEnum>one four</FlagEnum>"), WriterText, "#14");
+			Serialize (FlagEnum.e2 | FlagEnum.e4, typeof (FlagEnum));
+			Assert.AreEqual (Infoset ("<FlagEnum>two four</FlagEnum>"), WriterText, "#15");
+			Serialize (3, typeof (EnumDefaultValueNF));
+			Assert.AreEqual (Infoset ("<EnumDefaultValueNF>e3</EnumDefaultValueNF>"), WriterText, "#16");
+			Serialize (EnumDefaultValueNF.e2, typeof (EnumDefaultValueNF));
+			Assert.AreEqual (Infoset ("<EnumDefaultValueNF>e2</EnumDefaultValueNF>"), WriterText, "#17");
+			Serialize (2, typeof (ZeroFlagEnum));
+			Assert.AreEqual (Infoset ("<ZeroFlagEnum>two</ZeroFlagEnum>"), WriterText, "#18");
+			Serialize (new ZeroFlagEnum ()); // enum actually has a field with value 0
+			Assert.AreEqual (Infoset ("<ZeroFlagEnum>zero</ZeroFlagEnum>"), WriterText, "#19");
+		}
+
+		[Test]
+		[Category ("NotWorking")]
+		public void TestSerializeEnumDefaultValue_SOAP ()
+		{
+			SoapSerialize (new EnumDefaultValue ());
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<EnumDefaultValue d1p1:type='EnumDefaultValue' xmlns:d1p1='{0}' />",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#1");
+
+			SoapSerialize (new SimpleEnumeration ());
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<SimpleEnumeration d1p1:type='SimpleEnumeration' xmlns:d1p1='{0}'>FIRST</SimpleEnumeration>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#2");
+
+			SoapSerialize (3, typeof (EnumDefaultValue));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<EnumDefaultValue d1p1:type='EnumDefaultValue' xmlns:d1p1='{0}'>e3</EnumDefaultValue>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#3");
+
+			SoapSerialize (EnumDefaultValue.e3, typeof (EnumDefaultValue));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<EnumDefaultValue d1p1:type='EnumDefaultValue' xmlns:d1p1='{0}'>e3</EnumDefaultValue>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#4");
+
+			SoapSerialize (EnumDefaultValue.e1 | EnumDefaultValue.e2, typeof (EnumDefaultValue));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<EnumDefaultValue d1p1:type='EnumDefaultValue' xmlns:d1p1='{0}'>e3</EnumDefaultValue>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#5");
+
+			SoapSerialize (EnumDefaultValue.e1 | EnumDefaultValue.e2 | EnumDefaultValue.e3, typeof (EnumDefaultValue));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<EnumDefaultValue d1p1:type='EnumDefaultValue' xmlns:d1p1='{0}'>e3</EnumDefaultValue>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#6");
+
+			SoapSerialize (EnumDefaultValue.e1 | EnumDefaultValue.e3, typeof (EnumDefaultValue));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<EnumDefaultValue d1p1:type='EnumDefaultValue' xmlns:d1p1='{0}'>e3</EnumDefaultValue>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#7");
+
+			SoapSerialize (EnumDefaultValue.e2 | EnumDefaultValue.e3, typeof (EnumDefaultValue));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<EnumDefaultValue d1p1:type='EnumDefaultValue' xmlns:d1p1='{0}'>e3</EnumDefaultValue>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#8");
+
+			SoapSerialize (3, typeof (FlagEnum));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<FlagEnum d1p1:type='FlagEnum' xmlns:d1p1='{0}'>e1 e2</FlagEnum>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#9");
+
+			SoapSerialize (5, typeof (FlagEnum));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<FlagEnum d1p1:type='FlagEnum' xmlns:d1p1='{0}'>e1 e4</FlagEnum>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#10");
+
+			SoapSerialize (FlagEnum.e4, typeof (FlagEnum));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<FlagEnum d1p1:type='FlagEnum' xmlns:d1p1='{0}'>e4</FlagEnum>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#11");
+
+			SoapSerialize (FlagEnum.e1 | FlagEnum.e2, typeof (FlagEnum));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<FlagEnum d1p1:type='FlagEnum' xmlns:d1p1='{0}'>e1 e2</FlagEnum>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#12");
+
+			SoapSerialize (FlagEnum.e1 | FlagEnum.e2 | FlagEnum.e4, typeof (FlagEnum));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<FlagEnum d1p1:type='FlagEnum' xmlns:d1p1='{0}'>e1 e2 e4</FlagEnum>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#13");
+
+			SoapSerialize (FlagEnum.e1 | FlagEnum.e4, typeof (FlagEnum));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<FlagEnum d1p1:type='FlagEnum' xmlns:d1p1='{0}'>e1 e4</FlagEnum>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#14");
+
+			SoapSerialize (FlagEnum.e2 | FlagEnum.e4, typeof (FlagEnum));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<FlagEnum d1p1:type='FlagEnum' xmlns:d1p1='{0}'>e2 e4</FlagEnum>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#15");
+
+			SoapSerialize (3, typeof (EnumDefaultValueNF));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<EnumDefaultValueNF d1p1:type='EnumDefaultValueNF' xmlns:d1p1='{0}'>e3</EnumDefaultValueNF>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#16");
+
+			SoapSerialize (EnumDefaultValueNF.e2, typeof (EnumDefaultValueNF));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<EnumDefaultValueNF d1p1:type='EnumDefaultValueNF' xmlns:d1p1='{0}'>e2</EnumDefaultValueNF>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#17");
+
+			SoapSerialize (2, typeof (ZeroFlagEnum));
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<ZeroFlagEnum d1p1:type='ZeroFlagEnum' xmlns:d1p1='{0}'>e2</ZeroFlagEnum>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#18");
+
+			SoapSerialize (new ZeroFlagEnum ()); // enum actually has a field with value 0
+			Assert.AreEqual (string.Format (CultureInfo.InvariantCulture,
+				"<?xml version='1.0' encoding='utf-16'?>" +
+				"<ZeroFlagEnum d1p1:type='ZeroFlagEnum' xmlns:d1p1='{0}'>e0</ZeroFlagEnum>",
+				XmlSchemaInstanceNamespace), sw.ToString (), "#19");
+		}
+
+		[Test]
+		public void TestSerializeEnumDefaultValue_InvalidValue1 ()
+		{
+			try {
+				Serialize ("b", typeof (EnumDefaultValue));
+				Assert.Fail ("#A1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#A2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#A3");
+			}
+
+			try {
+				Serialize ("e1", typeof (EnumDefaultValue));
+				Assert.Fail ("#B1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#B2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#B3");
+			}
+
+			try {
+				Serialize ("e1,e2", typeof (EnumDefaultValue));
+				Assert.Fail ("#C1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#C2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#C3");
+			}
+
+			try {
+				Serialize (string.Empty, typeof (EnumDefaultValue));
+				Assert.Fail ("#D1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#D2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#D3");
+			}
+
+			try {
+				Serialize ("1", typeof (EnumDefaultValue));
+				Assert.Fail ("#E1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#E2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#E3");
+			}
+
+			try {
+				Serialize ("0", typeof (EnumDefaultValue));
+				Assert.Fail ("#F1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#F2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#F3");
+			}
+
+			try {
+				Serialize (new SimpleClass (), typeof (EnumDefaultValue));
+				Assert.Fail ("#G1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#G2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#G3");
+			}
+		}
+
+		[Test]
+		public void TestSerializeEnumDefaultValue_InvalidValue2 ()
+		{
+#if NET_2_0
+			try {
+				Serialize (5, typeof (EnumDefaultValue));
+				Assert.Fail ("#1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.InnerException, "#3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#4");
+				Assert.IsNotNull (ex.InnerException.Message, "#5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'5'") != -1, "#6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (EnumDefaultValue).FullName) != -1, "#7");
+			}
+#else
+			Serialize (5, typeof (EnumDefaultValue));
+			Assert.AreEqual (Infoset ("<EnumDefaultValue>5</EnumDefaultValue>"), WriterText);
+#endif
+		}
+
+		[Test]
+		public void TestSerializeEnumDefaultValueNF_InvalidValue1 ()
+		{
+#if NET_2_0
+			try {
+				Serialize (new EnumDefaultValueNF ());
+				Assert.Fail ("#1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.InnerException, "#3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#4");
+				Assert.IsNotNull (ex.InnerException.Message, "#5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'0'") != -1, "#6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (EnumDefaultValueNF).FullName) != -1, "#7");
+			}
+#else
+			Serialize (new EnumDefaultValueNF ());
 			Assert.AreEqual (Infoset ("<EnumDefaultValueNF>0</EnumDefaultValueNF>"), WriterText);
+#endif
+		}
 
-			Serialize(new SimpleEnumeration());
-			Assert.AreEqual (Infoset ("<SimpleEnumeration>FIRST</SimpleEnumeration>"), WriterText);
+		[Test]
+		public void TestSerializeEnumDefaultValueNF_InvalidValue2 ()
+		{
+#if NET_2_0
+			try {
+				Serialize (15, typeof (EnumDefaultValueNF));
+				Assert.Fail ("#1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.InnerException, "#3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#4");
+				Assert.IsNotNull (ex.InnerException.Message, "#5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'15'") != -1, "#6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (EnumDefaultValueNF).FullName) != -1, "#7");
+			}
+#else
+			Serialize (15, typeof (EnumDefaultValueNF));
+			Assert.AreEqual (Infoset ("<EnumDefaultValueNF>15</EnumDefaultValueNF>"), WriterText);
+#endif
 		}
 
 		[Test]
+		public void TestSerializeEnumDefaultValueNF_InvalidValue3 ()
+		{
+			try {
+				Serialize ("b", typeof (EnumDefaultValueNF));
+				Assert.Fail ("#A1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#A2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#A3");
+			}
+
+			try {
+				Serialize ("e2", typeof (EnumDefaultValueNF));
+				Assert.Fail ("#B1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#B2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#B3");
+			}
+
+			try {
+				Serialize (string.Empty, typeof (EnumDefaultValueNF));
+				Assert.Fail ("#C1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#C2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#C3");
+			}
+
+			try {
+				Serialize ("1", typeof (EnumDefaultValueNF));
+				Assert.Fail ("#D1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#D2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#D3");
+			}
+
+			try {
+				Serialize ("0", typeof (EnumDefaultValueNF));
+				Assert.Fail ("#E1");
+			} catch (InvalidOperationException ex) {
+				Assert.IsNotNull (ex.InnerException, "#E2");
+				Assert.AreEqual (typeof (InvalidCastException), ex.InnerException.GetType (), "#E3");
+			}
+		}
+
+		[Test]
+		public void TestSerializeZeroFlagEnum_InvalidValue ()
+		{
+#if NET_2_0
+			try {
+				Serialize (4, typeof (ZeroFlagEnum)); // corresponding enum field is marked XmlIgnore
+				Assert.Fail ("#1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.InnerException, "#3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#4");
+				Assert.IsNotNull (ex.InnerException.Message, "#5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'4'") != -1, "#6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (ZeroFlagEnum).FullName) != -1, "#7");
+			}
+#else
+			Serialize (4, typeof (ZeroFlagEnum)); // corresponding enum field is marked XmlIgnore
+			Assert.AreEqual (Infoset ("<ZeroFlagEnum>4</ZeroFlagEnum>"), WriterText);
+#endif
+		}
+
+		[Test]
 		public void TestSerializeQualifiedName()
 		{
 			Serialize(new XmlQualifiedName("me", "home.urn"));
@@ -434,6 +803,9 @@
 				Serialize(simple, overrides);
 				Assert.Fail("XmlText.Type does not match the type it serializes: this should have failed");
 			} catch (InvalidOperationException ex) {
+				// FIXME
+
+				/*
 				// there was an error reflecting type 'MonoTests.System.Xml.TestClasses.SimpleClass'.
 				Assert.IsNotNull (ex.Message, "#A1");
 				Assert.IsTrue (ex.Message.IndexOf (typeof (SimpleClass).FullName) != -1, "#A2");
@@ -450,8 +822,7 @@
 				Assert.IsNotNull (ex.InnerException.Message, "#A9");
 
 				Assert.IsNull (ex.InnerException.InnerException.InnerException, "#A10");
-			} catch (InvalidCastException ex) {
-				// FIXME: we should report InvalidOperationException
+				*/
 			}
 			
 			try {
@@ -711,17 +1082,36 @@
 		[Test]
 		public void TestSerializeXmlEnumAttribute()
 		{
-			// technically this has an XmlIgnore attribute, 
-			// but it is not being serialized as a member.
-			Serialize(XmlSchemaForm.None);
-			Assert.AreEqual (Infoset ("<XmlSchemaForm>0</XmlSchemaForm>"), WriterText);
-			
 			Serialize(XmlSchemaForm.Qualified);
-			Assert.AreEqual (Infoset ("<XmlSchemaForm>qualified</XmlSchemaForm>"), WriterText);
+			Assert.AreEqual (Infoset ("<XmlSchemaForm>qualified</XmlSchemaForm>"), WriterText, "#1");
 			
 			Serialize(XmlSchemaForm.Unqualified);
-			Assert.AreEqual (Infoset ("<XmlSchemaForm>unqualified</XmlSchemaForm>"), WriterText);
+			Assert.AreEqual (Infoset ("<XmlSchemaForm>unqualified</XmlSchemaForm>"), WriterText, "#2");
 		}
+
+		[Test]
+		public void TestSerializeXmlEnumAttribute_IgnoredValue ()
+		{
+			// technically XmlSchemaForm.None has an XmlIgnore attribute,
+			// but it is not being serialized as a member.
+
+#if NET_2_0
+			try {
+				Serialize (XmlSchemaForm.None);
+				Assert.Fail ("#1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#2");
+				Assert.IsNotNull (ex.InnerException, "#3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#4");
+				Assert.IsNotNull (ex.InnerException.Message, "#5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'0'") != -1, "#6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (XmlSchemaForm).FullName) != -1, "#7");
+			}
+#else
+			Serialize (XmlSchemaForm.None);
+			Assert.AreEqual (Infoset ("<XmlSchemaForm>0</XmlSchemaForm>"), WriterText);
+#endif
+		}
 		
 		[Test]
 		public void TestSerializeXmlNodeArray ()
@@ -807,65 +1197,65 @@
 		[Test]
 		public void TestSerializeIList()
 		{
-			clsPerson k = new clsPerson();
-			k.EmailAccounts = new ArrayList();
-			k.EmailAccounts.Add("a");
-			k.EmailAccounts.Add("b");
+			clsPerson k = new clsPerson();
+			k.EmailAccounts = new ArrayList();
+			k.EmailAccounts.Add("a");
+			k.EmailAccounts.Add("b");
 			Serialize (k);
 			Assert.AreEqual (Infoset ("<clsPerson xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><EmailAccounts><anyType xsi:type=\"xsd:string\">a</anyType><anyType xsi:type=\"xsd:string\">b</anyType></EmailAccounts></clsPerson>"), WriterText);
-		}
-		
-		[Test]
-		public void TestSerializeArrayEnc ()
-		{
-			SoapReflectionImporter imp = new SoapReflectionImporter ();
-			XmlTypeMapping map = imp.ImportTypeMapping (typeof(ArrayClass));
-			XmlSerializer ser = new XmlSerializer (map);
-			StringWriter sw = new StringWriter ();
-			XmlTextWriter tw = new XmlTextWriter (sw);
-			tw.WriteStartElement ("aa");
-			ser.Serialize (tw, new ArrayClass ());
-			tw.WriteEndElement ();
-		}
-		
+		}
+		
 		[Test]
+		public void TestSerializeArrayEnc ()
+		{
+			SoapReflectionImporter imp = new SoapReflectionImporter ();
+			XmlTypeMapping map = imp.ImportTypeMapping (typeof(ArrayClass));
+			XmlSerializer ser = new XmlSerializer (map);
+			StringWriter sw = new StringWriter ();
+			XmlTextWriter tw = new XmlTextWriter (sw);
+			tw.WriteStartElement ("aa");
+			ser.Serialize (tw, new ArrayClass ());
+			tw.WriteEndElement ();
+		}
+		
+		[Test]
 		public void TestIncludeType()
-		{
-			// Test for bug #76049
-			XmlReflectionImporter imp = new XmlReflectionImporter ();
-			XmlTypeMapping map = imp.ImportTypeMapping (typeof(object));
-			imp.IncludeType (typeof(TestSpace));
-			XmlSerializer ser = new XmlSerializer (map);
-			ser.Serialize (new StringWriter (), new TestSpace ());
-		}
+		{
+			// Test for bug #76049
+			XmlReflectionImporter imp = new XmlReflectionImporter ();
+			XmlTypeMapping map = imp.ImportTypeMapping (typeof(object));
+			imp.IncludeType (typeof(TestSpace));
+			XmlSerializer ser = new XmlSerializer (map);
+			ser.Serialize (new StringWriter (), new TestSpace ());
+		}
 		
 		[Test]
 		public void TestSerializeChoiceArray()
 		{
-			CompositeValueType v = new CompositeValueType ();
-			v.Init ();
+			CompositeValueType v = new CompositeValueType ();
+			v.Init ();
 			Serialize (v);
-			Assert.AreEqual (Infoset ("<?xml version=\"1.0\" encoding=\"utf-16\"?><CompositeValueType xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><In>1</In><Es>2</Es></CompositeValueType>"), WriterText);
-		}
-		
-		[Test]
-		public void TestArrayAttributeWithDataType ()
-		{
-			Serialize (new ArrayAttributeWithType ());
-			string res = "<ArrayAttributeWithType xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' ";
+			Assert.AreEqual (Infoset ("<?xml version=\"1.0\" encoding=\"utf-16\"?><CompositeValueType xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><In>1</In><Es>2</Es></CompositeValueType>"), WriterText);
+		}
+		
+		[Test]
+		public void TestArrayAttributeWithDataType ()
+		{
+			Serialize (new ArrayAttributeWithType ());
+			string res = "<ArrayAttributeWithType xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' ";
 			res += "at='a b' bin1='AQI= AQI=' bin2='AQI=' />";
 			Assert.AreEqual (Infoset (res), WriterText);
-		}
-		
-		[Test]
-		[ExpectedException (typeof(InvalidOperationException))]
-		public void TestArrayAttributeWithWrongDataType ()
-		{
-			Serialize (new ArrayAttributeWithWrongType ());
-		}
-		
-		// Helper methods
-				
+		}
+		
+		[Test]
+		[ExpectedException (typeof(InvalidOperationException))]
+		public void TestArrayAttributeWithWrongDataType ()
+		{
+			Serialize (new ArrayAttributeWithWrongType ());
+		}
+		
+		// Helper methods
+				
 		public static string Infoset (string sx)
 		{
 			XmlDocument doc = new XmlDocument ();
@@ -918,5 +1308,10 @@
 					break;
 			}
 		}
+
+		private static XmlTypeMapping CreateSoapMapping (Type type) {
+			SoapReflectionImporter importer = new SoapReflectionImporter ();
+			return importer.ImportTypeMapping (type);
+		}
 	}
 }
Index: Test/System.Xml.Serialization/XmlSerializationWriterTests.cs
===================================================================
--- Test/System.Xml.Serialization/XmlSerializationWriterTests.cs	(revision 55191)
+++ Test/System.Xml.Serialization/XmlSerializationWriterTests.cs	(working copy)
@@ -77,7 +77,7 @@
 			// returns a byte array.
 			// 
 			//string val = this.FromByteArrayBase64(new byte [] {143, 144, 1, 0});
-			//Assertion.AssertEquals(FromByteArrayBase64(null), "");
+			//Assert.AreEqual (FromByteArrayBase64(null), "");
 			
 			//val = FromByteArrayBase64(null);
 			//try/catch or AssertEruals?
@@ -87,31 +87,31 @@
 		public void TestFromByteArrayHex()
 		{
 			byte [] vals = {143, 144, 1, 0};
-			Assertion.AssertEquals("8F900100", FromByteArrayHex(vals));
-			Assertion.AssertEquals(null, FromByteArrayHex(null));
+			Assert.AreEqual ("8F900100", FromByteArrayHex(vals));
+			Assert.IsNull (FromByteArrayHex (null));
 		}
 
 		[Test]
 		public void TestFromChar()
 		{
-			Assertion.AssertEquals("97", FromChar('a'));
-			Assertion.AssertEquals("0", FromChar('\0'));
-			Assertion.AssertEquals("10", FromChar('\n'));
-			Assertion.AssertEquals("65281", FromChar('\uFF01'));
+			Assert.AreEqual ("97", FromChar ('a'));
+			Assert.AreEqual ("0", FromChar ('\0'));
+			Assert.AreEqual ("10", FromChar ('\n'));
+			Assert.AreEqual ("65281", FromChar ('\uFF01'));
 		}
 
 		[Test]
 		public void TestFromDate()
 		{
 			DateTime d = new DateTime();
-			Assertion.AssertEquals("0001-01-01", FromDate(d));
+			Assert.AreEqual ("0001-01-01", FromDate (d));
 		}
 
 		[Test]
 		public void TestFromDateTime()
 		{
 			DateTime d = new DateTime();
-			Assertion.AssertEquals("0001-01-01T00:00:00.0000000", FromDateTime(d).Substring (0, 27));
+			Assert.AreEqual ("0001-01-01T00:00:00.0000000", FromDateTime (d).Substring (0, 27));
 		}
 
 		[Test]
@@ -119,62 +119,155 @@
 		{
 			long[] ids = {1, 2, 3, 4};
 			string[] values = {"one", "two", "three"};
-			
-			Assertion.AssertEquals("one", FromEnum(1, values, ids));
-			Assertion.AssertEquals("", FromEnum(0, values, ids));
 
-			try
-			{
+			Assert.AreEqual ("one", FromEnum (1, values, ids), "#1");
+			Assert.AreEqual (string.Empty, FromEnum (0, values, ids), "#2");
+			Assert.AreEqual ("one two", FromEnum (3, values, ids), "#3");
+
+			try {
 				string dummy = FromEnum(4, values, ids);
-				Assertion.Fail("This should fail with an array-out-of-bunds error");
+				Assert.Fail("#4");
+			} catch (IndexOutOfRangeException) {
 			}
-			catch (Exception)
-			{
+
+			string[] correctValues = {"one", "two", "three", "four"};
+			Assert.AreEqual ("four", FromEnum (4, correctValues, ids), "#5");
+			Assert.AreEqual ("one four", FromEnum (5, correctValues, ids), "#6");
+			Assert.AreEqual ("two four", FromEnum (6, correctValues, ids), "#7");
+			Assert.AreEqual ("one two three four", FromEnum (7, correctValues, ids), "#8");
+
+			string[] flagValues = {"one", "two", "four", "eight"};
+			long[] flagIDs = {1, 2, 4, 8};
+			Assert.AreEqual (string.Empty, FromEnum (0, flagValues, flagIDs), "#9");
+			Assert.AreEqual ("two", FromEnum (2, flagValues, flagIDs), "#10");
+			Assert.AreEqual ("four", FromEnum (4, flagValues, flagIDs), "#1");
+			Assert.AreEqual ("one four", FromEnum (5, flagValues, flagIDs), "#12");
+			Assert.AreEqual ("two four", FromEnum (6, flagValues, flagIDs), "#13");
+			Assert.AreEqual ("one two four", FromEnum (7, flagValues, flagIDs), "#14");
+			Assert.AreEqual ("eight", FromEnum (8, flagValues, flagIDs), "#15");
+			Assert.AreEqual ("one four eight", FromEnum (13, flagValues, flagIDs), "#16");
+
+			string[] unorderedValues = {"one", "four", "two", "zero"};
+			long[] unorderedIDs = {1, 4, 2, 0};
+
+			Assert.AreEqual (string.Empty, FromEnum (0, unorderedValues, unorderedIDs), "#17");
+			Assert.AreEqual ("two", FromEnum (2, unorderedValues, unorderedIDs), "#18");
+			Assert.AreEqual ("four", FromEnum (4, unorderedValues, unorderedIDs), "#19");
+			Assert.AreEqual ("one four", FromEnum (5, unorderedValues, unorderedIDs), "#20");
+			Assert.AreEqual ("four two", FromEnum (6, unorderedValues, unorderedIDs), "#21");
+			Assert.AreEqual ("one four two", FromEnum (7, unorderedValues, unorderedIDs), "#22");
+
+			string[] zeroValues = {"zero", "ten"};
+			long[] zeroIDs = {0, 10};
+
+			Assert.AreEqual ("zero", FromEnum (0, zeroValues, zeroIDs), "#9");
+			Assert.AreEqual ("ten", FromEnum (10, zeroValues, zeroIDs), "#9");
+
+			string[] reverseZeroValues = {"", "zero"};
+			long[] reverseZeroIDs = {4, 0};
+			Assert.AreEqual (string.Empty, FromEnum (0, reverseZeroValues, reverseZeroIDs), "#9");
+			Assert.AreEqual ("zero", FromEnum (4, reverseZeroValues, reverseZeroIDs), "#9");
+
+			string[] emptyValues = { "zero" };
+			long[] emptyIDs = {0};
+			Assert.AreEqual ("zero", FromEnum (0, emptyValues, emptyIDs), "#9");
+		}
+
+		[Test]
+		public void TestFromEnum_InvalidValue ()
+		{
+			long[] ids = {1, 2, 3, 4};
+			string[] values = {"one", "two", "three", "four"};
+
+#if NET_2_0
+			try {
+				FromEnum (8, values, ids);
+				Assert.Fail ("#A1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#A2");
+				Assert.IsNotNull (ex.Message, "#A3");
+				Assert.IsTrue (ex.Message.IndexOf ("'8'") != -1, "#A4");
+				Assert.IsNull (ex.InnerException, "#A5");
 			}
+#else
+			Assert.AreEqual ("8", FromEnum (8, values, ids), "#A6");
+#endif
+
+#if NET_2_0
+			try {
+				FromEnum (8, values, ids, "Some.Type.Name");
+				Assert.Fail ("#B1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#B2");
+				Assert.IsNotNull (ex.Message, "#B3");
+				Assert.IsTrue (ex.Message.IndexOf ("'8'") != -1, "#B4");
+				Assert.IsTrue (ex.Message.IndexOf ("Some.Type.Name") != -1, "#B5");
+				Assert.IsNull (ex.InnerException, "#B6");
+			}
+#endif
 		}
 
 		[Test]
+		[ExpectedException (typeof (NullReferenceException))]
+		public void TestFromEnum_Null_Values ()
+		{
+			long[] ids = { 1, 2, 3, 4 };
+			string[] values = { "one", "two", "three", "four" };
+
+			FromEnum (1, (string[]) null, ids);
+		}
+
+		[Test]
+		[ExpectedException (typeof (NullReferenceException))]
+		public void TestFromEnum_Null_IDs ()
+		{
+			string[] values = { "one", "two", "three", "four" };
+
+			FromEnum (1, values, (long[]) null);
+		}
+
+		[Test]
 		public void TestFromTime()
 		{
 			DateTime d = new DateTime();
 			// Don't include time zone.
-			Assertion.AssertEquals("00:00:00.0000000", FromTime(d).Substring (0, 16));
+			Assert.AreEqual ("00:00:00.0000000", FromTime (d).Substring (0, 16));
 		}
 
 		[Test]
 		public void TestFromXmlName()
 		{
-			Assertion.AssertEquals("Hello", FromXmlName("Hello"));
-			Assertion.AssertEquals("go_x0020_dogs_x0020_go", FromXmlName("go dogs go"));
-			Assertion.AssertEquals("what_x0027_s_x0020_up", FromXmlName("what's up"));
-			Assertion.AssertEquals("_x0031_23go", FromXmlName("123go"));
-			Assertion.AssertEquals("Hello_x0020_what_x0027_s.up", FromXmlName("Hello what's.up"));
+			Assert.AreEqual ("Hello", FromXmlName ("Hello"));
+			Assert.AreEqual ("go_x0020_dogs_x0020_go", FromXmlName ("go dogs go"));
+			Assert.AreEqual ("what_x0027_s_x0020_up", FromXmlName ("what's up"));
+			Assert.AreEqual ("_x0031_23go", FromXmlName ("123go"));
+			Assert.AreEqual ("Hello_x0020_what_x0027_s.up", FromXmlName ("Hello what's.up"));
 		}
 
 		[Test]
 		public void TestFromXmlNCName()
 		{
-			Assertion.AssertEquals("Hello", FromXmlNCName("Hello"));
-			Assertion.AssertEquals("go_x0020_dogs_x0020_go", FromXmlNCName("go dogs go"));
-			Assertion.AssertEquals("what_x0027_s_x0020_up", FromXmlNCName("what's up"));
-			Assertion.AssertEquals("_x0031_23go", FromXmlNCName("123go"));
-			Assertion.AssertEquals("Hello_x0020_what_x0027_s.up", FromXmlNCName("Hello what's.up"));
+			Assert.AreEqual ("Hello", FromXmlNCName ("Hello"));
+			Assert.AreEqual ("go_x0020_dogs_x0020_go", FromXmlNCName ("go dogs go"));
+			Assert.AreEqual ("what_x0027_s_x0020_up", FromXmlNCName ("what's up"));
+			Assert.AreEqual ("_x0031_23go", FromXmlNCName ("123go"));
+			Assert.AreEqual ("Hello_x0020_what_x0027_s.up", FromXmlNCName ("Hello what's.up"));
 		}
 
 		[Test]
 		public void TestFromXmlNmToken()
 		{
-			Assertion.AssertEquals("Hello", FromXmlNmToken("Hello"));
-			Assertion.AssertEquals("go_x0020_dogs_x0020_go", FromXmlNmToken("go dogs go"));
-			Assertion.AssertEquals("what_x0027_s_x0020_up", FromXmlNmToken("what's up"));
-			Assertion.AssertEquals("123go", FromXmlNmToken("123go"));
-			Assertion.AssertEquals("Hello_x0020_what_x0027_s.up", FromXmlNmToken("Hello what's.up"));
+			Assert.AreEqual ("Hello", FromXmlNmToken ("Hello"));
+			Assert.AreEqual ("go_x0020_dogs_x0020_go", FromXmlNmToken ("go dogs go"));
+			Assert.AreEqual ("what_x0027_s_x0020_up", FromXmlNmToken ("what's up"));
+			Assert.AreEqual ("123go", FromXmlNmToken ("123go"));
+			Assert.AreEqual ("Hello_x0020_what_x0027_s.up", FromXmlNmToken ("Hello what's.up"));
 		}
 
 		[Test]
 		public void TestFromXmlNmTokens()
 		{
-			Assertion.AssertEquals("Hello go dogs_go 123go what_x0027_s.up", FromXmlNmTokens("Hello go dogs_go 123go what's.up"));
+			Assert.AreEqual ("Hello go dogs_go 123go what_x0027_s.up", FromXmlNmTokens ("Hello go dogs_go 123go what's.up"));
 		}
 
 		[Test]
@@ -183,46 +276,44 @@
 			WriteStartElement("x");
 			WriteAttribute("a", "b");
 			WriteEndElement();
-			Assertion.AssertEquals("<x a='b' />", Content);
+			Assert.AreEqual ("<x a='b' />", Content);
 
 			Reset();
 			WriteStartElement("x");
 			WriteAttribute("a", new byte[] {1, 2, 3});
 			WriteEndElement();
-			Assertion.AssertEquals("<x a='AQID' />", Content);
+			Assert.AreEqual ("<x a='AQID' />", Content);
 
 			Reset();
 			WriteStartElement("x");
 			WriteAttribute("a", "<b");
 			WriteEndElement();
-			Assertion.AssertEquals("<x a='&lt;b' />", Content);
+			Assert.AreEqual ("<x a='&lt;b' />", Content);
 
 			Reset();
 			WriteStartElement("x");
 			string typedPlaceholder = null;
 			WriteAttribute("a", typedPlaceholder);
 			WriteEndElement();
-			Assertion.AssertEquals("<x />", Content);
+			Assert.AreEqual ("<x />", Content);
 
 			Reset();
 			WriteStartElement("x");
 			WriteAttribute("a", "\"");
 			WriteEndElement();
-			Assertion.AssertEquals("<x a='\"' />", Content);
+			Assert.AreEqual ("<x a='\"' />", Content);
 
 			Reset();
 			WriteStartElement("x");
 			WriteAttribute("a", "b\nc");
 			WriteEndElement();
-			Assertion.AssertEquals("<x a='b&#xA;c' />", Content);
+			Assert.AreEqual ("<x a='b&#xA;c' />", Content);
 
 			Reset();
 			WriteStartElement("x");
 			WriteAttribute("a", ANamespace, "b");
 			WriteEndElement();
-			Assertion.AssertEquals("<x d1p1:a='b' xmlns:d1p1='some:urn' />", Content);
-
-
+			Assert.AreEqual ("<x d1p1:a='b' xmlns:d1p1='some:urn' />", Content);
 		}
 
 		[Test]
@@ -243,11 +334,11 @@
 		public void TestWriteElementString()
 		{
 			WriteElementString("x", "a");
-			Assertion.AssertEquals("<x>a</x>", Content);
+			Assert.AreEqual ("<x>a</x>", Content);
 
 			Reset();
 			WriteElementString("x", "<a");
-			Assertion.AssertEquals("<x>&lt;a</x>", Content);
+			Assert.AreEqual ("<x>&lt;a</x>", Content);
 		}
 
 		[Test]
@@ -255,27 +346,27 @@
 		{
 			byte [] placeHolderArray = null;
 			WriteElementStringRaw("x", placeHolderArray);
-			Assertion.AssertEquals("", Content);
+			Assert.AreEqual ("", Content);
 
 			Reset();
 			WriteElementStringRaw("x", new byte[] {0, 2, 4});
-			Assertion.AssertEquals("<x>AAIE</x>", Content);
+			Assert.AreEqual ("<x>AAIE</x>", Content);
 
 			Reset();
 			WriteElementStringRaw("x", new byte[] {});
-			Assertion.AssertEquals("<x />", Content);
+			Assert.AreEqual ("<x />", Content);
 
 			// Note to reader, the output is not valid xml
 			Reset();
 			WriteElementStringRaw("x", "a > 13 && a < 19");
-			Assertion.AssertEquals("<x>a > 13 && a < 19</x>", Content);
+			Assert.AreEqual ("<x>a > 13 && a < 19</x>", Content);
 		}
 
 		[Test]
 		public void TestWriteEmptyTag()
 		{
 			WriteEmptyTag("x");
-			Assertion.AssertEquals("<x />", Content);
+			Assert.AreEqual ("<x />", Content);
 		}
 
 		[Test]
@@ -286,83 +377,83 @@
 			WriteStartElement("x");
 			WriteNamespaceDeclarations(ns);
 			WriteEndElement();
-			Assertion.AssertEquals("<x />", Content);
+			Assert.AreEqual ("<x />", Content);
 
 			Reset();
 			ns.Add("mypref", ANamespace);
 			WriteStartElement("x");
 			WriteNamespaceDeclarations(ns);
 			WriteEndElement();
-			Assertion.AssertEquals(XmlSerializerTests.Infoset("<x xmlns:mypref='some:urn' />"), XmlSerializerTests.Infoset(Content));
+			Assert.AreEqual (XmlSerializerTests.Infoset("<x xmlns:mypref='some:urn' />"), XmlSerializerTests.Infoset(Content));
 
 			Reset();
 			ns.Add("ns2", "another:urn");
 			WriteStartElement("x");
 			WriteNamespaceDeclarations(ns);
 			WriteEndElement();
-			Assertion.AssertEquals(XmlSerializerTests.Infoset("<x xmlns:ns2='another:urn' xmlns:mypref='some:urn' />"), XmlSerializerTests.Infoset(Content));
+			Assert.AreEqual (XmlSerializerTests.Infoset("<x xmlns:ns2='another:urn' xmlns:mypref='some:urn' />"), XmlSerializerTests.Infoset(Content));
 
 			Reset();
 			ns.Add("ns3", "ya:urn");
 			WriteStartElement("x");
 			WriteNamespaceDeclarations(ns);
 			WriteEndElement();
-			Assertion.AssertEquals(XmlSerializerTests.Infoset("<x xmlns:ns3='ya:urn' xmlns:ns2='another:urn' xmlns:mypref='some:urn' />"), XmlSerializerTests.Infoset(Content));
+			Assert.AreEqual (XmlSerializerTests.Infoset("<x xmlns:ns3='ya:urn' xmlns:ns2='another:urn' xmlns:mypref='some:urn' />"), XmlSerializerTests.Infoset(Content));
 		}
 
 		[Test]
 		public void TestWriteNullableStringLiteral()
 		{
 			WriteNullableStringLiteral("x", null, null);
-			Assertion.AssertEquals(XmlSerializerTests.Infoset("<x d1p1:nil='true' xmlns:d1p1='http://www.w3.org/2001/XMLSchema-instance' />"), XmlSerializerTests.Infoset(Content));
+			Assert.AreEqual (XmlSerializerTests.Infoset("<x d1p1:nil='true' xmlns:d1p1='http://www.w3.org/2001/XMLSchema-instance' />"), XmlSerializerTests.Infoset(Content));
 
 			Reset();
 			WriteNullableStringLiteral("x", null, "");
-			Assertion.AssertEquals("<x />", Content);
+			Assert.AreEqual ("<x />", Content);
 			
 			Reset();
 			WriteNullableStringLiteral("x", null, "a<b\'c");
-			Assertion.AssertEquals("<x>a&lt;b\'c</x>", Content);
+			Assert.AreEqual ("<x>a&lt;b\'c</x>", Content);
 
 			Reset();
 			WriteNullableStringLiteral("x", ANamespace, "b");
-			Assertion.AssertEquals("<x xmlns='some:urn'>b</x>", Content);
+			Assert.AreEqual ("<x xmlns='some:urn'>b</x>", Content);
 		}
 
 		[Test]
 		public void TestWriteNullableStringLiteralRaw()
 		{
 			WriteNullableStringLiteralRaw("x", null, new byte[] {1, 2, 244});
-			Assertion.AssertEquals("<x>AQL0</x>", Content);
+			Assert.AreEqual ("<x>AQL0</x>", Content);
 		}
 
 		[Test]
 		public void TestWriteNullTagEncoded()
 		{
 			WriteNullTagEncoded("x");
-			Assertion.AssertEquals(XmlSerializerTests.Infoset("<x d1p1:nil='true' xmlns:d1p1='http://www.w3.org/2001/XMLSchema-instance' />"), XmlSerializerTests.Infoset(Content));
+			Assert.AreEqual (XmlSerializerTests.Infoset("<x d1p1:nil='true' xmlns:d1p1='http://www.w3.org/2001/XMLSchema-instance' />"), XmlSerializerTests.Infoset(Content));
 		}
 
 		[Test]
 		public void TestWriteNullTagLiteral()
 		{
 			WriteNullTagLiteral("x");
-			Assertion.AssertEquals(XmlSerializerTests.Infoset("<x d1p1:nil='true' xmlns:d1p1='http://www.w3.org/2001/XMLSchema-instance' />"), XmlSerializerTests.Infoset(Content));
+			Assert.AreEqual (XmlSerializerTests.Infoset("<x d1p1:nil='true' xmlns:d1p1='http://www.w3.org/2001/XMLSchema-instance' />"), XmlSerializerTests.Infoset(Content));
 		}
 
 		[Test]
 		public void TestWriteSerializable()
 		{
 			// FIXME
-			//Assertion.AssertEquals(, "");
+			//Assert.AreEqual (, "");
 		}
 
 		public void TestWriteStartDocument()
 		{
-			Assertion.AssertEquals("", Content);
+			Assert.AreEqual ("", Content);
 			
 			WriteStartDocument();
-			Assertion.AssertEquals("<?xml version='1.0' encoding='utf-16'?>", Content);
+			Assert.AreEqual ("<?xml version='1.0' encoding='utf-16'?>", Content);
 		}
 
 		[Test]
@@ -370,66 +461,63 @@
 		{
 			WriteStartElement("x");
 			WriteEndElement();
-			Assertion.AssertEquals("<x />", Content);
+			Assert.AreEqual ("<x />", Content);
 
 			Reset();
 			WriteStartElement("x");
 			WriteValue("a");
 			WriteEndElement();
-			Assertion.AssertEquals("<x>a</x>", Content);
+			Assert.AreEqual ("<x>a</x>", Content);
 
 			Reset();
 			WriteStartElement("x");
 			WriteStartElement("y", "z");
 			WriteEndElement();
 			WriteEndElement();
-			Assertion.AssertEquals("<x><y xmlns='z' /></x>", Content);
+			Assert.AreEqual ("<x><y xmlns='z' /></x>", Content);
 
 			Reset();
 			WriteStartElement("x");
 			WriteStartElement("y", "z", true);
 			WriteEndElement();
 			WriteEndElement();
-			Assertion.AssertEquals("<x><q1:y xmlns:q1='z' /></x>", Content);
+			Assert.AreEqual ("<x><q1:y xmlns:q1='z' /></x>", Content);
 		}
 		
 		public void TestWriteTypedPrimitive()
 		{
 			// as long as WriteTypePrimitive's last argument is false, this is OK here.
 			WriteTypedPrimitive("x", ANamespace, "hello", false);
-			Assertion.AssertEquals("<x xmlns='some:urn'>hello</x>", Content);
+			Assert.AreEqual ("<x xmlns='some:urn'>hello</x>", Content);
 
 			Reset();
 			WriteTypedPrimitive("x", ANamespace, 10, false);
-			Assertion.AssertEquals("<x xmlns='some:urn'>10</x>", Content);
+			Assert.AreEqual ("<x xmlns='some:urn'>10</x>", Content);
 
-			try
-			{
+			try {
 				WriteTypedPrimitive("x", ANamespace, null, false);
-				Assertion.Fail("Should not be able to write a null primitive");
+				Assert.Fail("Should not be able to write a null primitive");
+			} catch (NullReferenceException) {
 			}
-			catch (Exception)
-			{
-			}
 		}
 
 		public void TestWriteValue()
 		{
 			WriteValue("");
-			Assertion.AssertEquals("", Content);
+			Assert.AreEqual ("", Content);
 
 			Reset();
 			WriteValue("hello");
-			Assertion.AssertEquals("hello", Content);
+			Assert.AreEqual ("hello", Content);
 
 			Reset();
 			string v = null;
 			WriteValue(v);
-			Assertion.AssertEquals("", Content);
+			Assert.AreEqual ("", Content);
 
 			Reset();
 			WriteValue(new byte[] {13, 8, 99});
-			Assertion.AssertEquals("DQhj", Content);
+			Assert.AreEqual ("DQhj", Content);
 		}
 
 		public void TestWriteXmlAttribute()
@@ -443,7 +531,29 @@
 			WriteStartElement("x");
 			WriteXsiType("pref", null);
 			WriteEndElement();
-			Assertion.AssertEquals(XmlSerializerTests.Infoset("<x d1p1:type='pref' xmlns:d1p1='http://www.w3.org/2001/XMLSchema-instance' />"), XmlSerializerTests.Infoset(Content));
+			Assert.AreEqual (XmlSerializerTests.Infoset("<x d1p1:type='pref' xmlns:d1p1='http://www.w3.org/2001/XMLSchema-instance' />"), XmlSerializerTests.Infoset(Content));
 		}
+
+#if NET_2_0
+		[Test]
+		public void TestFromEnum_Null_TypeName ()
+		{
+			string[] values = { "one", "two", "three", "four" };
+			long[] ids = { 1, 2, 3, 4 };
+
+			Assert.AreEqual ("one", FromEnum (1, values, ids, (string) null));
+		}
+
+		[Test]
+		public void TestCreateInvalidEnumValueException ()
+		{
+			Exception ex = CreateInvalidEnumValueException("AnInvalidValue", "SomeType");
+			Assert.IsNotNull (ex, "#1");
+			Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#2");
+			Assert.IsNotNull (ex.Message, "#3");
+			Assert.IsTrue (ex.Message.IndexOf ("AnInvalidValue") != -1, "#4");
+			Assert.IsTrue (ex.Message.IndexOf ("SomeType") != -1, "#5");
+		}
+#endif
 	}
 }
Index: Test/System.Xml.Serialization/SoapReflectionImporterTests.cs
===================================================================
--- Test/System.Xml.Serialization/SoapReflectionImporterTests.cs	(revision 55929)
+++ Test/System.Xml.Serialization/SoapReflectionImporterTests.cs	(working copy)
@@ -1160,11 +1160,9 @@
 
 		[Test]
 		[Category ("NotWorking")] // mark it NotWorking until fixes have landed in svn
-/*
 #if ONLY_1_1
 		[Category ("NotDotNet")] // results in NullReferenceException in .NET 1.1 (SP1)
 #endif
- */
 		public void TypeMapping_IEnumerable_SimpleClass_PrivateGetEnumerator ()
 		{
 			XmlTypeMapping tm = Map (typeof (SimpleClassEnumerablePrivateGetEnumerator));
Index: Test/System.Xml.Serialization/ChangeLog
===================================================================
--- Test/System.Xml.Serialization/ChangeLog	(revision 56579)
+++ Test/System.Xml.Serialization/ChangeLog	(working copy)
@@ -1,5 +1,17 @@
 2006-02-06  Gert Driesen  <drieseng@users.sourceforge.net>
 
+	* XmlSerializerTests.cs: Added tests for serialization of enums, fixed
+	failures on .NET 2.0. Fixed line endings. Started working on tests
+	for serialization using XmlTypMapping creating using
+	SoapReflectionImporter.
+	* XmlSerializationWriterTests.cs: Use Assert instead of deprecated
+	Assertion class. Added tests for FromEnum.
+	* DeserializeTests.cs: Added tests for deserialization of enums.
+	* XmlSerializerTestClasses.cs: Added test enums and class.
+	* SoapReflectionImporterTests.cs: Marked test NotDotNet on 1.x.
+
+2006-02-06  Gert Driesen  <drieseng@users.sourceforge.net>
+
 	* DeserializeTests.cs: Use Assert instead of deprecated Assertion.
 	Renumbered tests. Fixed line endings.
 
Index: Test/System.Xml.Serialization/DeserializeTests.cs
===================================================================
--- Test/System.Xml.Serialization/DeserializeTests.cs	(revision 56579)
+++ Test/System.Xml.Serialization/DeserializeTests.cs	(working copy)
@@ -573,5 +573,206 @@
 			Assert.IsNotNull (cont.Collection1, "#2");
 			Assert.AreEqual (0, cont.Collection1.Length, "#3");
 		}
+
+		[Test]
+		public void TestDeserialize_EnumDefaultValue ()
+		{
+			EnumDefaultValue e;
+
+			e = (EnumDefaultValue) Deserialize (typeof (EnumDefaultValue), "<EnumDefaultValue />");
+			Assert.AreEqual (0, (int) e, "#1");
+
+			e = (EnumDefaultValue) Deserialize (typeof (EnumDefaultValue), "<EnumDefaultValue>e3</EnumDefaultValue>");
+			Assert.AreEqual (EnumDefaultValue.e3, e, "#2");
+
+			e = (EnumDefaultValue) Deserialize (typeof (EnumDefaultValue), "<EnumDefaultValue>e1 e2</EnumDefaultValue>");
+			Assert.AreEqual (EnumDefaultValue.e3, e, "#3");
+
+			e = (EnumDefaultValue) Deserialize (typeof (EnumDefaultValue), "<EnumDefaultValue>e1 e2</EnumDefaultValue>");
+			Assert.AreEqual (EnumDefaultValue.e1 | EnumDefaultValue.e2, e, "#4");
+		}
+
+		[Test]
+		public void TestDeserialize_EnumDefaultValueNF ()
+		{
+			EnumDefaultValueNF e;
+
+			e = (EnumDefaultValueNF) Deserialize (typeof (EnumDefaultValueNF), "<EnumDefaultValueNF>e3</EnumDefaultValueNF>");
+			Assert.AreEqual (EnumDefaultValueNF.e3, e, "#A1");
+
+			try {
+				Deserialize (typeof (EnumDefaultValueNF), "<EnumDefaultValueNF />");
+				Assert.Fail ("#B1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#B2");
+				Assert.IsNotNull (ex.InnerException, "#B3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#B4");
+				Assert.IsNotNull (ex.InnerException.Message, "#B5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("''") != -1, "#B6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (EnumDefaultValueNF).Name) != -1, "#B7");
+			}
+
+			try {
+				Deserialize (typeof (EnumDefaultValueNF), "<EnumDefaultValueNF>e1 e3</EnumDefaultValueNF>");
+				Assert.Fail ("#C1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#C2");
+				Assert.IsNotNull (ex.InnerException, "#C3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#C4");
+				Assert.IsNotNull (ex.InnerException.Message, "#C5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'e1 e3'") != -1, "#C6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (EnumDefaultValueNF).Name) != -1, "#C7");
+			}
+
+			try {
+				Deserialize (typeof (EnumDefaultValueNF), "<EnumDefaultValueNF> e3</EnumDefaultValueNF>");
+				Assert.Fail ("#D1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#D2");
+				Assert.IsNotNull (ex.InnerException, "#D3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#D4");
+				Assert.IsNotNull (ex.InnerException.Message, "#D5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("' e3'") != -1, "#D6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (EnumDefaultValueNF).Name) != -1, "#D7");
+			}
+
+			try {
+				Deserialize (typeof (EnumDefaultValueNF), "<EnumDefaultValueNF> </EnumDefaultValueNF>");
+				Assert.Fail ("#E1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#E2");
+				Assert.IsNotNull (ex.InnerException, "#E3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#E4");
+				Assert.IsNotNull (ex.InnerException.Message, "#E5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("' '") != -1, "#E6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (EnumDefaultValueNF).Name) != -1, "#E7");
+			}
+
+			try {
+				Deserialize (typeof (EnumDefaultValueNF), "<EnumDefaultValueNF>1</EnumDefaultValueNF>");
+				Assert.Fail ("#F1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#F2");
+				Assert.IsNotNull (ex.InnerException, "#F3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#F4");
+				Assert.IsNotNull (ex.InnerException.Message, "#F5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'1'") != -1, "#F6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (EnumDefaultValueNF).Name) != -1, "#F7");
+			}
+		}
+
+		[Test]
+		public void TestDeserialize_FlagEnum ()
+		{
+			FlagEnum e;
+
+			e = (FlagEnum) Deserialize (typeof (FlagEnum), "<FlagEnum />");
+			Assert.AreEqual (0, (int) e, "#1");
+
+			e = (FlagEnum) Deserialize (typeof (FlagEnum), "<FlagEnum>one</FlagEnum>");
+			Assert.AreEqual (FlagEnum.e1, e, "#2");
+
+			e = (FlagEnum) Deserialize (typeof (FlagEnum), "<FlagEnum>one two</FlagEnum>");
+			Assert.AreEqual (FlagEnum.e1 | FlagEnum.e2, e, "#3");
+
+			e = (FlagEnum) Deserialize (typeof (FlagEnum), "<FlagEnum>one two four</FlagEnum>");
+			Assert.AreEqual (FlagEnum.e1 | FlagEnum.e2 | FlagEnum.e4, e, "#4");
+
+			e = (FlagEnum) Deserialize (typeof (FlagEnum), "<FlagEnum> two  four </FlagEnum>");
+			Assert.AreEqual (FlagEnum.e2 | FlagEnum.e4, e, "#5");
+
+			e = (FlagEnum) Deserialize (typeof (FlagEnum), "<FlagEnum>two four two</FlagEnum>");
+			Assert.AreEqual (FlagEnum.e2 | FlagEnum.e4, e, "#6");
+
+			e = (FlagEnum) Deserialize (typeof (FlagEnum), "<FlagEnum>two four two one four two one</FlagEnum>");
+			Assert.AreEqual (FlagEnum.e1 | FlagEnum.e2 | FlagEnum.e4, e, "#7");
+
+			e = (FlagEnum) Deserialize (typeof (FlagEnum), "<FlagEnum></FlagEnum>");
+			Assert.AreEqual (0, (int) e, "#8");
+
+			try {
+				Deserialize (typeof (FlagEnum), "<FlagEnum>1</FlagEnum>");
+				Assert.Fail ("#B1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#B2");
+				Assert.IsNotNull (ex.InnerException, "#B3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#B4");
+				Assert.IsNotNull (ex.InnerException.Message, "#B5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'1'") != -1, "#B6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (FlagEnum).FullName) != -1, "#B7");
+			}
+
+			try {
+				Deserialize (typeof (FlagEnum), "<FlagEnum>one,two</FlagEnum>");
+				Assert.Fail ("#C1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#C2");
+				Assert.IsNotNull (ex.InnerException, "#C3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#C4");
+				Assert.IsNotNull (ex.InnerException.Message, "#C5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'one,two'") != -1, "#C6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (FlagEnum).FullName) != -1, "#C7");
+			}
+
+			try {
+				Deserialize (typeof (FlagEnum), "<FlagEnum>one something</FlagEnum>");
+				Assert.Fail ("#D1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#D2");
+				Assert.IsNotNull (ex.InnerException, "#D3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#D4");
+				Assert.IsNotNull (ex.InnerException.Message, "#D5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'something'") != -1, "#D6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (FlagEnum).FullName) != -1, "#D7");
+			}
+		}
+
+		[Test]
+		public void TestDeserialize_ZeroFlagEnum ()
+		{
+			ZeroFlagEnum e;
+
+			e = (ZeroFlagEnum) Deserialize (typeof (ZeroFlagEnum), "<ZeroFlagEnum />");
+			Assert.AreEqual (ZeroFlagEnum.e0, e, "#A1");
+			e = (ZeroFlagEnum) Deserialize (typeof (ZeroFlagEnum), "<ZeroFlagEnum></ZeroFlagEnum>");
+			Assert.AreEqual (ZeroFlagEnum.e0, e, "#A2");
+
+			try {
+				Deserialize (typeof (ZeroFlagEnum), "<ZeroFlagEnum>four</ZeroFlagEnum>");
+				Assert.Fail ("#B1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#B2");
+				Assert.IsNotNull (ex.InnerException, "#B3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#B4");
+				Assert.IsNotNull (ex.InnerException.Message, "#B5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'four'") != -1, "#B6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (ZeroFlagEnum).FullName) != -1, "#B7");
+			}
+
+			try {
+				Deserialize (typeof (ZeroFlagEnum), "<ZeroFlagEnum> one  four </ZeroFlagEnum>");
+				Assert.Fail ("#C1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#C2");
+				Assert.IsNotNull (ex.InnerException, "#C3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#C4");
+				Assert.IsNotNull (ex.InnerException.Message, "#C5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'four'") != -1, "#C6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (ZeroFlagEnum).FullName) != -1, "#C7");
+			}
+
+			try {
+				Deserialize (typeof (ZeroFlagEnum), "<ZeroFlagEnum>four one</ZeroFlagEnum>");
+				Assert.Fail ("#D1");
+			} catch (InvalidOperationException ex) {
+				Assert.AreEqual (typeof (InvalidOperationException), ex.GetType (), "#D2");
+				Assert.IsNotNull (ex.InnerException, "#D3");
+				Assert.AreEqual (typeof (InvalidOperationException), ex.InnerException.GetType (), "#D4");
+				Assert.IsNotNull (ex.InnerException.Message, "#D5");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf ("'four'") != -1, "#D6");
+				Assert.IsTrue (ex.InnerException.Message.IndexOf (typeof (ZeroFlagEnum).FullName) != -1, "#D7");
+			}
+		}
+
 	}
 }
Index: Test/System.Xml.Serialization/XmlSerializerTestClasses.cs
===================================================================
--- Test/System.Xml.Serialization/XmlSerializerTestClasses.cs	(revision 55929)
+++ Test/System.Xml.Serialization/XmlSerializerTestClasses.cs	(working copy)
@@ -23,6 +23,28 @@
 	[Flags]
 	public enum EnumDefaultValue { e1 = 1, e2 = 2, e3 = 3 }
 	public enum EnumDefaultValueNF { e1 = 1, e2 = 2, e3 = 3 }
+
+	[Flags]
+	public enum FlagEnum { 
+		[XmlEnum ("one")]
+		e1 = 1,
+		[XmlEnum ("two")]
+		e2 = 2,
+		[XmlEnum ("four")]
+		e4 = 4 }
+
+	[Flags]
+	public enum ZeroFlagEnum {
+		[XmlEnum ("zero")]
+		e0 = 0,
+		[XmlEnum ("one")]
+		e1 = 1,
+		[XmlEnum ("two")]
+		e2 = 2,
+		[XmlEnum ("four")]
+		[XmlIgnore]
+		e4 = 4
+	}
 	
 	public class SimpleClass
 	{
@@ -449,5 +471,16 @@
 			get { return collection1; }
 		}
 	}
+
+	public class DictionaryWithIndexer : DictionaryBase
+	{
+		public TimeSpan this[int index] {
+			get { return TimeSpan.MinValue; }
+		}
+
+		public void Add (TimeSpan value)
+		{
+		}
+	}
 }
 
Index: System.Xml.Serialization/XmlTypeMapping.cs
===================================================================
--- System.Xml.Serialization/XmlTypeMapping.cs	(revision 55192)
+++ System.Xml.Serialization/XmlTypeMapping.cs	(working copy)
@@ -598,14 +598,20 @@
 
 		public class EnumMapMember
 		{
-			string _xmlName;
-			string _enumName;
+			readonly string _xmlName;
+			readonly string _enumName;
+			readonly long _value;
 			string _documentation;
 
-			public EnumMapMember (string xmlName, string enumName)
+			public EnumMapMember (string xmlName, string enumName) : this (xmlName, enumName, 0)
 			{
+			}
+
+			public EnumMapMember (string xmlName, string enumName, long value)
+			{
 				_xmlName = xmlName;
 				_enumName = enumName;
+				_value = value;
 			}
 
 			public string XmlName
@@ -618,6 +624,11 @@
 				get { return _enumName; }
 			}
 
+			public long Value
+			{
+				get { return _value; }
+			}
+
 			public string Documentation
 			{
 				get { return _documentation; }
@@ -641,41 +652,56 @@
 			get { return _members; }
 		}
 
-		public string GetXmlName (object enumValue)
+		public string GetXmlName (string typeName, object enumValue)
 		{
-			string enumName = enumValue.ToString();
+			if (enumValue is string) {
+				throw new InvalidCastException ();
+			}
 
-			if (_isFlags && enumName.IndexOf (',') != -1)
-			{
-				System.Text.StringBuilder sb = new System.Text.StringBuilder ();
-				string[] enumNames = enumValue.ToString().Split (',');
-				foreach (string name in enumNames)
-				{
-					string tname = name.Trim();
-					foreach (EnumMapMember mem in _members)
-						if (mem.EnumName == tname) {
-							sb.Append (mem.XmlName).Append (' ');
-							break;
-						}
+			long value = 0;
+
+			try {
+				value = ((IConvertible) enumValue).ToInt64 (CultureInfo.CurrentCulture);
+			} catch (FormatException) {
+				throw new InvalidCastException ();
+			}
+
+			string[] names = new string[_members.Length];
+			long[] values = new long[_members.Length];
+
+			for (int i = 0; i < _members.Length; i++) {
+				EnumMapMember mem = _members[i];
+				names[i] = mem.XmlName;
+				values[i] = mem.Value;
+
+				if (mem.Value == value) {
+					return mem.XmlName;
 				}
-				sb.Remove (sb.Length-1, 1);
-				return sb.ToString ();
 			}
 
-			foreach (EnumMapMember mem in _members)
-				if (mem.EnumName == enumName) return mem.XmlName;
-			
-			// Enum default value will not be written
-			// unless it is one of the enum legal values
-			if (enumName == "0" && IsFlags)
-				return String.Empty;
-			else
-				return Convert.ToInt64(enumValue).ToString(CultureInfo.InvariantCulture);
+			if (IsFlags && value == 0)
+				return string.Empty;
+
+#if NET_2_0
+			string xmlName = XmlCustomFormatter.FromEnum (value, names, values, typeName);
+#else
+			string xmlName = XmlCustomFormatter.FromEnum (value, names, values);
+#endif
+
+			if (xmlName.Length == 0) {
+#if NET_2_0
+				throw new InvalidOperationException (string.Format(CultureInfo.CurrentCulture,
+					"'{0}' is not a valid value for {1}.", value, typeName));
+#else
+				return value.ToString (CultureInfo.InvariantCulture);
+#endif
+			}
+			return xmlName;
 		}
 
-		public string GetEnumName (string xmlName)
+		public string GetEnumName (string typeName, string xmlName)
 		{
-			if (_isFlags && xmlName.Length == 0) 
+			if (_isFlags && xmlName.Length == 0)
 				return "0";
 			
 			if (_isFlags && xmlName.Trim().IndexOf (' ') != -1)
@@ -687,12 +713,20 @@
 					if (name == string.Empty) continue;
 					string foundEnumValue = null;
 					foreach (EnumMapMember mem in _members)
-						if (mem.XmlName == name) { foundEnumValue = mem.EnumName; break; }
+						if (mem.XmlName == name) {
+							foundEnumValue = mem.EnumName;
+							break;
+						}
 
-					if (foundEnumValue != null) sb.Append (foundEnumValue).Append (','); 
-					else return null;
+					if (foundEnumValue != null) {
+						if (sb.Length != 0)
+							sb.Append (',');
+						sb.Append (foundEnumValue);
+					} else {
+						throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture,
+							"'{0}' is not a valid value for {1}.", name, typeName));
+					}
 				}
-				sb.Remove (sb.Length-1, 1);
 				return sb.ToString ();
 			}
 
Index: System.Xml.Serialization/XmlSerializationReaderInterpreter.cs
===================================================================
--- System.Xml.Serialization/XmlSerializationReaderInterpreter.cs	(revision 55082)
+++ System.Xml.Serialization/XmlSerializationReaderInterpreter.cs	(working copy)
@@ -784,8 +784,8 @@
 
 		object GetEnumValue (XmlTypeMapping typeMap, string val)
 		{
-			EnumMap map = (EnumMap) typeMap.ObjectMap;
-			string ev = map.GetEnumName (val);
+			EnumMap map = (EnumMap) typeMap.ObjectMap;
+			string ev = map.GetEnumName (typeMap.TypeFullName, val);
 			if (ev == null) throw CreateUnknownConstantException (val, typeMap.TypeData.Type);
 			return Enum.Parse (typeMap.TypeData.Type, ev);
 		}
Index: System.Xml.Serialization/ChangeLog
===================================================================
--- System.Xml.Serialization/ChangeLog	(revision 55210)
+++ System.Xml.Serialization/ChangeLog	(working copy)
@@ -1,3 +1,52 @@
+2006-02-06  Gert Driesen  <drieseng@users.sourceforge.net>
+
+	* XmlTypeMapping.cs: EnumMapMemer now also stores value for enum
+	fields. Modified EnumMapping.GetXmlName to use XmlCustomerFormatter
+	to support serializing value to enum field and made sure the 
+	exceptions we throw match those of MSFT. To match MSFT, throw 
+	InvalidOperationException in EnumMapping.GetEnumName if matching 
+	constant does not exist in enum.
+	* XmlSerializationReaderInterpreter.cs: Pass full typename to
+	EnumMapping.GetEnumName for construction of exception message.
+	* XmlSerializer.cs: In Deserialize, wrap InvalidOperationException
+	and InvalidCastException in another InvalidOperationException to match
+	MSFT. In Serialize, wrap InvalidOperationException, InvalidCastException
+	and the inner exception for a TargetInvocationException in a
+	InvalidOperationException to match MSFT.
+	* SerializationCodeGenerator.cs: In GenerateGetXmlEnumValue, use 
+	XmlCustomerFormatter.FromEnum in order to also support serialization
+	from the underlying value of a constant. In 2.0 profile, throw
+	InvalidOperationException if numeric value cannot be serialized into
+	enum constant(s). In GenerateSingleEnumValue, no longer attempt
+	to parse unknown constant value but instead report it as
+	InvalidOperationException.
+	* XmlSerializationWriter.cs: Implemented 2.0 version of FromEnum, and
+	CreateInvalidEnumValueException.
+	* XmlCustomerFormatter.cs: Added FromEnum overload that takes name of
+	enum for which string value must be created. Modified FromEnum
+	to behave more like MSFT's implementation:
+	- treat value as bit field.
+	- no longer return empty string if the value matches an id for which there's no corresponding
+	name.
+	- if one of the ids has value 0 and there's a match for the enum value
+	(with a zero length XML name) or the enum value is 0, then return the 
+	corresponding XML for the id with value 0.
+	- in 2.0 profile, throw InvalidOperationException is no match is found
+	for (part of) the enum value.
+	* XmlSerializationWriterInterpreter.cs: Do not treat numeric enum value
+	as typed primitive type. Pass full typename of enum to 
+	EnumMap.GetXmlName.
+	* XmlSchemaImporter.cs: Pass full typename to EnumMap.GetEnumName
+	to allow it to be used in exception messages.
+	* XmlReflectionImporter.cs: Use FieldInfo instead of MemberInfo for
+	enum fields. Use IsDefined instead of GetCustomAttributes for checking
+	if a certain attribute is defined. Use value of enum field in
+	EnumMapMember ctor.
+	* SoapReflectionImporter.cs: Use FieldInfo instead of MemberInfo for
+	enum fields. Use IsDefined instead of GetCustomAttribute for checking
+	if a certain attribute is defined. Use value of enum field in
+	EnumMapMember ctor.
+
 2006-01-08  Gert Driesen  <drieseng@users.sourceforge.net>
 
 	* XmlSchemaImporter.cs: Fixed line endings (to CRLF).
Index: System.Xml.Serialization/XmlSerializer.cs
===================================================================
--- System.Xml.Serialization/XmlSerializer.cs	(revision 55082)
+++ System.Xml.Serialization/XmlSerializer.cs	(working copy)
@@ -52,6 +52,7 @@
 	{
 		internal const string WsdlNamespace = "http://schemas.xmlsoap.org/wsdl/";
 		internal const string EncodingNamespace = "http://schemas.xmlsoap.org/soap/encoding/";
+		internal const string WsdlTypesNamespace = "http://microsoft.com/wsdl/types/";
 		static int generationThreshold;
 		static bool backgroundGeneration = true;
 		static bool deleteTempFiles = true;
@@ -326,11 +327,18 @@
 			if (customSerializer)
 				// Must be implemented in derived class
 				throw new NotImplementedException ();
-			
-			if (reader is XmlSerializationReaderInterpreter)
-				return ((XmlSerializationReaderInterpreter)reader).ReadRoot ();
-			else
-				return serializerData.ReaderMethod.Invoke (reader, null);
+
+			try {
+				if (reader is XmlSerializationReaderInterpreter)
+					return ((XmlSerializationReaderInterpreter) reader).ReadRoot ();
+				else
+					return serializerData.ReaderMethod.Invoke (reader, null);
+			} catch (Exception ex) {
+				if (ex is InvalidOperationException || ex is InvalidCastException)
+					throw new InvalidOperationException ("There was an error generating" +
+						" the XML document.", ex);
+				throw;
+			}
 		}
 
 		public static XmlSerializer [] FromMappings (XmlMapping	[] mappings)
@@ -412,22 +420,32 @@
 		public void Serialize (XmlWriter writer, object o, XmlSerializerNamespaces namespaces)
 		{
 			XmlSerializationWriter xsWriter;
-			
-			if (customSerializer)
-				xsWriter = CreateWriter ();
-			else
-				xsWriter = CreateWriter (typeMapping);
-				
-			if (namespaces == null || namespaces.Count == 0)
-			{
-				namespaces = new XmlSerializerNamespaces ();
-				namespaces.Add ("xsd", XmlSchema.Namespace);
-				namespaces.Add ("xsi", XmlSchema.InstanceNamespace);
+
+			try {
+				if (customSerializer)
+					xsWriter = CreateWriter ();
+				else
+					xsWriter = CreateWriter (typeMapping);
+
+				if (namespaces == null || namespaces.Count == 0) {
+					namespaces = new XmlSerializerNamespaces ();
+					namespaces.Add ("xsd", XmlSchema.Namespace);
+					namespaces.Add ("xsi", XmlSchema.InstanceNamespace);
+				}
+
+				xsWriter.Initialize (writer, namespaces);
+				Serialize (o, xsWriter);
+				writer.Flush ();
+			} catch (Exception ex) {
+				if (ex is TargetInvocationException)
+					ex = ex.InnerException;
+
+				if (ex is InvalidOperationException || ex is InvalidCastException)
+					throw new InvalidOperationException ("There was an error generating" +
+						" the XML document.", ex);
+
+				throw;
 			}
-			
-			xsWriter.Initialize (writer, namespaces);
-			Serialize (o, xsWriter);
-			writer.Flush ();
 		}
 		
 #if NET_2_0
Index: System.Xml.Serialization/SerializationCodeGenerator.cs
===================================================================
--- System.Xml.Serialization/SerializationCodeGenerator.cs	(revision 55082)
+++ System.Xml.Serialization/SerializationCodeGenerator.cs	(working copy)
@@ -516,25 +516,44 @@
 			if (emap.IsFlags)
 			{
 				WriteLineInd ("default:");
-				WriteLine ("if (val.ToString () == \"0\") return string.Empty;");
-				WriteLine ("System.Text.StringBuilder sb = new System.Text.StringBuilder ();");
-				WriteLine ("string[] enumNames = val.ToString().Split (',');");
-				WriteLine ("foreach (string name in enumNames)");
-				WriteLineInd ("{");
-				WriteLine ("switch (name.Trim())");
-				WriteLineInd ("{");
-				
-				foreach (EnumMap.EnumMapMember mem in emap.Members)
-					WriteLine ("case " + GetLiteral(mem.EnumName) + ": sb.Append (" + GetLiteral(mem.XmlName) + ").Append (' '); break; ");
-
-				WriteLine ("default: sb.Append (name.Trim()).Append (' '); break; ");
-				WriteLineUni ("}");
-				WriteLineUni ("}");
-				WriteLine ("return sb.ToString ().Trim();");
+				_writer.Write ("return FromEnum (");
+				_writer.Write ('('); // start cast
+				_writer.Write (typeof (long).FullName);
+				_writer.Write (')'); // end cast
+				_writer.Write ("val, new string[] {");
+				for (int i = 0; i < emap.Members.Length; i++) {
+					EnumMap.EnumMapMember mem = emap.Members[i];
+					if (i > 0) {
+						_writer.Write (',');
+					}
+					_writer.Write (mem.XmlName);
+				}
+				_writer.Write ("}, new ");
+				_writer.Write (typeof (long).FullName);
+				_writer.Write ("[] {");
+				for (int i = 0; i < emap.Members.Length; i++) {
+					EnumMap.EnumMapMember mem = emap.Members[i];
+					if (i > 0) {
+						_writer.Write (',');
+					}
+					_writer.Write ('(');
+					_writer.Write (typeof (long).FullName);
+					_writer.Write (')');
+					_writer.Write (map.TypeFullName);
+					_writer.Write ('.');
+					_writer.Write (mem.EnumName);
+				}
+				_writer.Write ('}');
+				_writer.Write (')'); // close FromEnum method call
+				_writer.Write (';'); // end statement
 				Unindent ();
 			}
 			else
+#if NET_2_0
+//				WriteLine ("default: throw CreateInvalidEnumValueException (val, map.TypeFullName);");
+#else
 				WriteLine ("default: return ((long)val).ToString(CultureInfo.InvariantCulture);");
+#endif
 			
 			WriteLineUni ("}");
 			
@@ -2287,13 +2306,8 @@
 				WriteLine ("case " + GetLiteral (mem.XmlName) + ": return " + typeMap.TypeFullName + "." + mem.EnumName + ";");
 			}
 			WriteLineInd ("default:");
-			WriteLineInd ("try {");
-			WriteLine ("return (" + typeMap.TypeFullName + ") Int64.Parse (" + val + ", CultureInfo.InvariantCulture);");
-			WriteLineUni ("}");
-			WriteLineInd ("catch {");
 			WriteLine ("throw CreateUnknownConstantException (" + val + ", typeof(" + typeMap.TypeFullName + "));");
 			WriteLineUni ("}");
-			Unindent ();
 			WriteLineUni ("}");
 		}
 		
Index: System.Xml.Serialization/XmlReflectionImporter.cs
===================================================================
--- System.Xml.Serialization/XmlReflectionImporter.cs	(revision 55082)
+++ System.Xml.Serialization/XmlReflectionImporter.cs	(working copy)
@@ -551,14 +551,15 @@
 			ArrayList members = new ArrayList();
 			foreach (string name in names)
 			{
-				MemberInfo[] mem = type.GetMember (name);
+				FieldInfo field = type.GetField (name);
 				string xmlName = null;
-				object[] atts = mem[0].GetCustomAttributes (typeof(XmlIgnoreAttribute), false);
-				if (atts.Length > 0) continue;
-				atts = mem[0].GetCustomAttributes (typeof(XmlEnumAttribute), false);
-				if (atts.Length > 0) xmlName = ((XmlEnumAttribute)atts[0]).Name;
+				if (field.IsDefined (typeof (XmlIgnoreAttribute), false))
+					continue;
+				object[] atts = field.GetCustomAttributes (typeof (XmlEnumAttribute), false);
+				if (atts.Length > 0) xmlName = ((XmlEnumAttribute) atts[0]).Name;
 				if (xmlName == null) xmlName = name;
-				members.Add (new EnumMap.EnumMapMember (XmlConvert.EncodeLocalName (xmlName), name));
+				long value = ((IConvertible) field.GetValue (null)).ToInt64 (CultureInfo.InvariantCulture);
+				members.Add (new EnumMap.EnumMapMember (XmlConvert.EncodeLocalName (xmlName), name, value));
 			}
 
 			bool isFlags = type.GetCustomAttributes (typeof(FlagsAttribute),false).Length > 0;
@@ -912,7 +913,7 @@
 				}
 
 				if (choiceEnumMap != null) {
-					string cname = choiceEnumMap.GetEnumName (elem.ElementName);
+					string cname = choiceEnumMap.GetEnumName (choiceEnumType.FullName, elem.ElementName);
 					if (cname == null) throw new InvalidOperationException ("The '" + choiceEnumType + "' enumeration does not have a value for the element '" + elem.ElementName + "'");
 					elem.ChoiceValue = Enum.Parse (choiceEnumType, cname);
 				}
Index: System.Xml.Serialization/SoapReflectionImporter.cs
===================================================================
--- System.Xml.Serialization/SoapReflectionImporter.cs	(revision 55082)
+++ System.Xml.Serialization/SoapReflectionImporter.cs	(working copy)
@@ -28,10 +28,11 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 
+using System.Collections;
+using System.Globalization;
 using System.Reflection;
 using System.Xml;
 using System.Xml.Schema;
-using System.Collections;
 
 namespace System.Xml.Serialization {
 	public class SoapReflectionImporter {
@@ -349,14 +350,15 @@
 			EnumMap.EnumMapMember[] members = new EnumMap.EnumMapMember[names.Length];
 			for (int n=0; n<names.Length; n++)
 			{
-				MemberInfo[] mem = type.GetMember (names[n]);
+				FieldInfo field = type.GetField (names[n]);
 				string xmlName = names[n];
-				object[] atts = mem[0].GetCustomAttributes (typeof(SoapEnumAttribute), false);
+				object[] atts = field.GetCustomAttributes (typeof(SoapEnumAttribute), false);
 				if (atts.Length > 0) xmlName = ((SoapEnumAttribute)atts[0]).Name;
-				members[n] = new EnumMap.EnumMapMember (XmlConvert.EncodeLocalName (xmlName), names[n]);
+				long value = ((IConvertible) field.GetValue (null)).ToInt64 (CultureInfo.InvariantCulture);
+				members[n] = new EnumMap.EnumMapMember (XmlConvert.EncodeLocalName (xmlName), names[n], value);
 			}
 
-			bool isFlags = type.GetCustomAttributes (typeof(FlagsAttribute),false).Length > 0;
+			bool isFlags = type.IsDefined (typeof(FlagsAttribute), false);
 			map.ObjectMap = new EnumMap (members, isFlags);
 			ImportTypeMapping (typeof(object), defaultNamespace).DerivedTypes.Add (map);
 			return map;
Index: System.Xml.Serialization/XmlSchemaImporter.cs
===================================================================
--- System.Xml.Serialization/XmlSchemaImporter.cs	(revision 55210)
+++ System.Xml.Serialization/XmlSchemaImporter.cs	(working copy)
@@ -927,7 +927,7 @@
 			if (typeData.SchemaType == SchemaTypes.Enum) {
 				XmlTypeMapping map = GetTypeMapping (typeData);
 				EnumMap emap = (EnumMap) map.ObjectMap;
-				string res = emap.GetEnumName (value);
+				string res = emap.GetEnumName (typeData.Type.FullName, value);
 				if (res == null) throw new InvalidOperationException ("'" + value + "' is not a valid enumeration value");
 				return res;
 			} else
Index: System.Xml.Serialization/XmlCustomFormatter.cs
===================================================================
--- System.Xml.Serialization/XmlCustomFormatter.cs	(revision 55082)
+++ System.Xml.Serialization/XmlCustomFormatter.cs	(working copy)
@@ -72,20 +72,53 @@
 		internal static string FromTime (DateTime value)
 		{
 			return XmlConvert.ToString (value, "HH:mm:ss.fffffffzzz");
+		}
+
+		internal static string FromEnum (long value, string[] values, long[] ids)
+		{
+			return FromEnum (value, values, ids, (string) null);
 		}
 
-		internal static string FromEnum (long value, string[] values, long[] ids)
+		internal static string FromEnum (long value, string[] values, long[] ids, string typeName)
 		{
+			StringBuilder sb = new StringBuilder();
 			int length = ids.Length;
+			long valueToProcess = value;
+			int zeroValue = -1;
 
-			for (int i = 0; i < length; i ++) {
-				if (ids[i] == value) 
-					if (i >= values.Length)
-						return String.Empty;
-					else
-						return values[i].ToString ();
+			for (int i = 0; i < length; i ++) {
+				if (ids[i] == 0) {
+					zeroValue = i;
+				} else {
+					if (valueToProcess == 0) {
+						break;
+					}
+
+					if ((ids[i] & value) == ids[i]) {
+						if (sb.Length != 0)
+							sb.Append (' ');
+						sb.Append (values[i]);
+						valueToProcess &= ~ids[i];
+					}
+				}
+			}
+
+			if (valueToProcess != 0) {
+#if NET_2_0
+				if (typeName != null)
+					throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture,
+						"'{0}' is not a valid value for {1}.", value, typeName));
+				else
+					throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture,
+						"'{0}' is not a valid value.", value));
+#else
+				return value.ToString ();
+#endif
+			}
+			if (sb.Length == 0 && zeroValue != -1) {
+				sb.Append (values[zeroValue]);
 			}
-			return String.Empty;
+			return sb.ToString ();
 		}
 
 		internal static string FromXmlName (string name)
Index: System.Xml.Serialization/XmlSerializationWriterInterpreter.cs
===================================================================
--- System.Xml.Serialization/XmlSerializationWriterInterpreter.cs	(revision 55082)
+++ System.Xml.Serialization/XmlSerializationWriterInterpreter.cs	(working copy)
@@ -118,14 +118,18 @@
 			{
 				WriteSerializable ((IXmlSerializable)ob, element, namesp, isNullable);
 				return;
-			}
-
+			}
+
 			XmlTypeMapping map = typeMap.GetRealTypeMap (ob.GetType().FullName);
 
 			if (map == null) 
-			{
-				WriteTypedPrimitive (element, namesp, ob, true);
-				return;
+			{
+				if (typeMap.TypeData.SchemaType == SchemaTypes.Enum) {
+					map = typeMap;
+				} else {
+					WriteTypedPrimitive (element, namesp, ob, true);
+					return;
+				}
 			}
 
 			if (writeWrappingElem)
@@ -490,9 +494,9 @@
 		}
 
 		string GetEnumXmlValue (XmlTypeMapping typeMap, object ob)
-		{
-			EnumMap map = (EnumMap)typeMap.ObjectMap;
-			return map.GetXmlName (ob);
+		{
+			EnumMap map = (EnumMap) typeMap.ObjectMap;
+			return map.GetXmlName (typeMap.TypeFullName, ob);
 		}
 
 		class CallbackInfo
Index: System.Xml.Serialization/XmlSerializationWriter.cs
===================================================================
--- System.Xml.Serialization/XmlSerializationWriter.cs	(revision 55082)
+++ System.Xml.Serialization/XmlSerializationWriter.cs	(working copy)
@@ -925,16 +925,15 @@
 			throw new NotImplementedException ();
 		}
 
-		[MonoTODO]
 		protected Exception CreateInvalidEnumValueException (object value, string typeName)
 		{
-			throw new NotImplementedException ();
+			return new InvalidOperationException (string.Format(CultureInfo.CurrentCulture,
+				"'{0}' is not a valid value for {1}.", value, typeName));
 		}
 
-		[MonoTODO]
 		protected static string FromEnum (long value, string[] values, long[] ids, string typeName)
 		{
-			throw new NotImplementedException ();
+			return XmlCustomFormatter.FromEnum (value, values, ids, typeName);
 		}
 
 		[MonoTODO]
@@ -962,7 +961,7 @@
 			set { throw new NotImplementedException(); }
 		}
 #endif
-		
+
 		#endregion
 
 		class WriteCallbackInfo
