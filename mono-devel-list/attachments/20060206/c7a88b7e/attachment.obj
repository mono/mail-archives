Index: Novell.Directory.Ldap/SupportClass.cs
===================================================================
--- Novell.Directory.Ldap/SupportClass.cs	(revision 56097)
+++ Novell.Directory.Ldap/SupportClass.cs	(working copy)
@@ -560,7 +560,7 @@
 		/// <param name="arrayList">The ArrayList instance</param>
 		/// <param name="element">The element to remove</param>
 		/// <returns>True if item is found in the ArrayList; otherwise, false</returns>  
-		public static System.Boolean VectorRemoveElement(System.Collections.ArrayList arrayList, System.Object element)
+		public static System.Boolean VectorRemoveElement(System.Collections.IList arrayList, System.Object element)
 		{
 			System.Boolean containsItem = arrayList.Contains(element);
 			arrayList.Remove(element);
Index: Novell.Directory.Ldap/Message.cs
===================================================================
--- Novell.Directory.Ldap/Message.cs	(revision 56034)
+++ Novell.Directory.Ldap/Message.cs	(working copy)
@@ -151,7 +151,7 @@
 				return null;
 			}
 			// sync on message so don't confuse with timer thread
-			lock (replies)
+			lock (replies.SyncRoot)
 			{
 				System.Object msg = null;
 				while (waitForReply_Renamed_Field)
@@ -160,7 +160,7 @@
 					{
 						try
 						{
-							System.Threading.Monitor.Wait(replies);
+							System.Threading.Monitor.Wait(replies.SyncRoot);
 						}
 						catch (System.Threading.ThreadInterruptedException ir)
 						{
@@ -213,7 +213,7 @@
 				{
 					return null;
 				}
-				lock (replies)
+				lock (replies.SyncRoot)
 				{
 					// Test and remove must be atomic
 					if ((replies.Count == 0))
@@ -466,10 +466,7 @@
 			{
 				return ;
 			}
-			lock(replies)
-			{
 			replies.Add(message);
-			}
 			message.RequestingMessage = msg; // Save request message info
 			switch (message.Type)
 			{
@@ -544,9 +541,9 @@
 		private void  sleepersAwake()
 		{
 			// Notify any thread waiting for this message id
-			lock (replies)
+			lock (replies.SyncRoot)
 			{
-				System.Threading.Monitor.Pulse(replies);
+				System.Threading.Monitor.Pulse(replies.SyncRoot);
 			}
 			// Notify a thread waiting for any message id
 			agent.sleepersAwake(false);
Index: Novell.Directory.Ldap/MessageAgent.cs
===================================================================
--- Novell.Directory.Ldap/MessageAgent.cs	(revision 56034)
+++ Novell.Directory.Ldap/MessageAgent.cs	(working copy)
@@ -103,10 +103,9 @@
 			get
 			{
 				int count = 0;
-				System.Object[] msgs = messages.ToArray();
-				for (int i = 0; i < msgs.Length; i++)
+				for (int i = 0; i < messages.Count; i++)
 				{
-					Message m = (Message) msgs[i];
+					Message m = (Message) messages[i];
 					count += m.Count;
 				}
 				return count;
@@ -140,15 +139,15 @@
 				messages.Add(msgs[i]);
 				((Message) (msgs[i])).Agent = this;
 			}
-			lock (messages)
+			lock (messages.SyncRoot)
 			{
 				if (msgs.Length > 1)
 				{
-					System.Threading.Monitor.PulseAll(messages); // wake all threads waiting for messages
+					System.Threading.Monitor.PulseAll(messages.SyncRoot); // wake all threads waiting for messages
 				}
 				else if (msgs.Length == 1)
 				{
-					System.Threading.Monitor.Pulse(messages); // only wake one thread
+					System.Threading.Monitor.Pulse(messages.SyncRoot); // only wake one thread
 				}
 			}
 			return ;
@@ -161,12 +160,12 @@
 		/* package */
 		internal void  sleepersAwake(bool all)
 		{
-			lock (messages)
+			lock (messages.SyncRoot)
 			{
 				if (all)
-					System.Threading.Monitor.PulseAll(messages);
+					System.Threading.Monitor.PulseAll(messages.SyncRoot);
 				else
-					System.Threading.Monitor.Pulse(messages);
+					System.Threading.Monitor.Pulse(messages.SyncRoot);
 			}
 			return ;
 		}
@@ -368,7 +367,7 @@
 			else
 			{
 				// A msgId was NOT specified, any message will do
-				lock (messages)
+				lock (messages.SyncRoot)
 				{
 					while (true)
 					{
@@ -413,7 +412,7 @@
 						// No data, wait for something to come in.
 						try
 						{
-							System.Threading.Monitor.Wait(messages);
+							System.Threading.Monitor.Wait(messages.SyncRoot);
 						}
 						catch (System.Threading.ThreadInterruptedException ex)
 						{
Index: Novell.Directory.Ldap/MessageVector.cs
===================================================================
--- Novell.Directory.Ldap/MessageVector.cs	(revision 56034)
+++ Novell.Directory.Ldap/MessageVector.cs	(working copy)
@@ -38,8 +38,9 @@
 	/// to Vector needed for handling messages.
 	/// </summary>
 	/* package */
-	class MessageVector:System.Collections.ArrayList
+	class MessageVector:System.Collections.IList
 	{
+		private readonly System.Collections.ArrayList _innerList;
 		/// <summary>Returns an array containing all of the elements in this MessageVector.
 		/// The elements returned are in the same order in the array as in the
 		/// Vector.  The contents of the vector are cleared.
@@ -47,29 +48,25 @@
 		/// </summary>
 		/// <returns> the array containing all of the elements.
 		/// </returns>
-		virtual internal System.Object[] ObjectArray
+		internal System.Object[] ObjectArray
 		{
 			/* package */
 			
 			get
 			{
-				lock (this)
+				lock (this.SyncRoot)
 				{
-					System.Object[] results = new System.Object[Count];
-					Array.Copy((System.Array) ToArray(), 0, (System.Array) results, 0, Count);
-					for (int i = 0; i < Count; i++)
-					{
-						ToArray()[i] = null;
-					}
-//					Count = 0;
+					System.Object[] results = ToArray();
+					Clear();
 					return results;
 				}
 			}
 			
 		}
 		/* package */
-		internal MessageVector(int cap, int incr):base(cap)
+		internal MessageVector(int cap, int incr)
 		{
+			_innerList = System.Collections.ArrayList.Synchronized(new System.Collections.ArrayList(cap));
 			return ;
 		}
 		
@@ -88,12 +85,12 @@
 		/* package */
 		internal Message findMessageById(int msgId)
 		{
-			lock (this)
+			lock (this.SyncRoot)
 			{
 				Message msg = null;
 				for (int i = 0; i < Count; i++)
 				{
-					if ((msg = (Message) ToArray()[i]) == null)
+					if ((msg = (Message) this[i]) == null)
 					{
 						throw new System.FieldAccessException();
 					}
@@ -105,5 +102,106 @@
 				throw new System.FieldAccessException();
 			}
 		}
+
+		#region ArrayList members
+		public object[] ToArray()
+		{
+			return _innerList.ToArray();
+		}
+		#endregion
+
+		#region IList Members
+
+		public int Add(object value)
+		{
+			return _innerList.Add(value);
+		}
+
+		public void Clear()
+		{
+			_innerList.Clear();
+		}
+
+		public bool Contains(object value)
+		{
+			return _innerList.Contains(value);
+		}
+
+		public int IndexOf(object value)
+		{
+			return _innerList.IndexOf(value);
+		}
+
+		public void Insert(int index, object value)
+		{
+			_innerList.Insert(index, value);
+		}
+
+		public bool IsFixedSize
+		{
+			get { return _innerList.IsFixedSize; }
+		}
+
+		public bool IsReadOnly
+		{
+			get { return _innerList.IsReadOnly; }
+		}
+
+		public void Remove(object value)
+		{
+			_innerList.Remove(value);
+		}
+
+		public void RemoveAt(int index)
+		{
+			_innerList.RemoveAt(index);
+		}
+
+		public object this[int index]
+		{
+			get
+			{
+				return _innerList[index];
+			}
+			set
+			{
+				_innerList[index] = value;
+			}
+		}
+
+		#endregion
+
+		#region ICollection Members
+
+		public void CopyTo(Array array, int index)
+		{
+			_innerList.CopyTo(array, index);
+		}
+
+		public int Count
+		{
+			get { return _innerList.Count; }
+		}
+
+		public bool IsSynchronized
+		{
+			get { return _innerList.IsSynchronized; }
+		}
+
+		public object SyncRoot
+		{
+			get { return _innerList.SyncRoot; }
+		}
+
+		#endregion
+
+		#region IEnumerable Members
+
+		public System.Collections.IEnumerator GetEnumerator()
+		{
+			return _innerList.GetEnumerator();
+		}
+
+		#endregion
 	}
 }
