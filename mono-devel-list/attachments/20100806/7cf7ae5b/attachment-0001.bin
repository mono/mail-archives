diff -rusb mono-20100806.orig/eglib/src/goutput.c mono-20100806/eglib/src/goutput.c
--- mono-20100806.orig/eglib/src/goutput.c	2010-05-02 09:01:29.000000000 +0200
+++ mono-20100806/eglib/src/goutput.c	2010-08-06 17:42:07.000000000 +0200
@@ -151,7 +151,8 @@
 	va_list args;
 
 	va_start (args, format);
-	g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, format, args);
+	g_logv (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, format, args); /* this call might abort and not return if 'fatal' is set the right way */
 	va_end (args);
-}
 
+	abort (); /* assertion messages are terminal regardless what value 'fatal' is set to */
+}
diff -rusb mono-20100806.orig/eglib/src/gspawn.c mono-20100806/eglib/src/gspawn.c
--- mono-20100806.orig/eglib/src/gspawn.c	2010-07-20 09:02:05.000000000 +0200
+++ mono-20100806/eglib/src/gspawn.c	2010-08-06 17:26:14.000000000 +0200
@@ -35,7 +35,10 @@
 #include <glib.h>
 
 #ifdef HAVE_UNISTD_H
+#ifndef __USE_GNU
+/* if not already defined (e.g. in /usr/include/features.h) */
 #define __USE_GNU
+#endif
 #include <unistd.h>
 #endif
 
diff -rusb mono-20100806.orig/eglib/test/markup.c mono-20100806/eglib/test/markup.c
--- mono-20100806.orig/eglib/test/markup.c	2009-08-24 21:29:48.000000000 +0200
+++ mono-20100806/eglib/test/markup.c	2010-08-06 17:45:12.000000000 +0200
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <glib.h>
 #include "test.h"
diff -rusb mono-20100806.orig/libgc/darwin_stop_world.c mono-20100806/libgc/darwin_stop_world.c
--- mono-20100806.orig/libgc/darwin_stop_world.c	2010-06-18 09:00:57.000000000 +0200
+++ mono-20100806/libgc/darwin_stop_world.c	2010-08-06 18:39:21.000000000 +0200
@@ -474,7 +474,7 @@
 static struct GC_mach_thread GC_mach_threads[SUSPEND_THREADS_SIZE];
 static int GC_mach_threads_count;
 
-void GC_stop_init() {
+void GC_stop_init(void) {
   int i;
 
   for (i = 0; i < SUSPEND_THREADS_SIZE; i++) {
@@ -565,7 +565,7 @@
 
 
 /* Caller holds allocation lock.	*/
-void GC_stop_world()
+void GC_stop_world(void)
 {
   int i, changes;
     GC_thread p;
@@ -649,7 +649,7 @@
 
 /* Caller holds allocation lock, and has held it continuously since	*/
 /* the world stopped.							*/
-void GC_start_world()
+void GC_start_world(void)
 {
   task_t my_task = current_task();
   mach_port_t my_thread = mach_thread_self();
diff -rusb mono-20100806.orig/libgc/include/private/gcconfig.h mono-20100806/libgc/include/private/gcconfig.h
--- mono-20100806.orig/libgc/include/private/gcconfig.h	2010-04-24 09:01:30.000000000 +0200
+++ mono-20100806/libgc/include/private/gcconfig.h	2010-08-06 18:20:28.000000000 +0200
@@ -2412,7 +2412,7 @@
 	           extern void *ps3_get_mem (size_t size);
 #              define GET_MEM(bytes) (struct hblk*) ps3_get_mem (bytes)
 #           else
-		extern ptr_t GC_unix_get_mem();
+		extern ptr_t GC_unix_get_mem(word bytes);
 #               define GET_MEM(bytes) (struct hblk *)GC_unix_get_mem(bytes)
 #endif
 #	      endif
diff -rusb mono-20100806.orig/libgc/include/private/gc_priv.h mono-20100806/libgc/include/private/gc_priv.h
--- mono-20100806.orig/libgc/include/private/gc_priv.h	2010-02-22 09:01:42.000000000 +0100
+++ mono-20100806/libgc/include/private/gc_priv.h	2010-08-06 18:37:12.000000000 +0200
@@ -423,8 +423,8 @@
 # else
 #   if defined(GC_SOLARIS_THREADS) || defined(GC_WIN32_THREADS) \
 	|| defined(GC_PTHREADS)
-      void GC_stop_world();
-      void GC_start_world();
+      void GC_stop_world(void);
+      void GC_start_world(void);
 #     define STOP_WORLD() GC_stop_world()
 #     define START_WORLD() GC_start_world()
 #   else
@@ -1840,7 +1840,7 @@
 #   ifdef __DMC__
       GC_API void GC_noop(...);
 #   else
-      GC_API void GC_noop();
+      GC_API void GC_noop(/* var args */);
 #   endif
 # endif
 
@@ -1929,17 +1929,17 @@
     /* GC_notify_all_builder() is called when GC_fl_builder_count	*/
     /* reaches 0.							*/
 
-     extern void GC_acquire_mark_lock();
-     extern void GC_release_mark_lock();
-     extern void GC_notify_all_builder();
-     /* extern void GC_wait_builder(); */
-     extern void GC_wait_for_reclaim();
+     extern void GC_acquire_mark_lock(void);
+     extern void GC_release_mark_lock(void);
+     extern void GC_notify_all_builder(void);
+     /* extern void GC_wait_builder(void); */
+     extern void GC_wait_for_reclaim(void);
 
      extern word GC_fl_builder_count;	/* Protected by mark lock.	*/
 # endif /* PARALLEL_MARK || THREAD_LOCAL_ALLOC */
 # ifdef PARALLEL_MARK
-     extern void GC_notify_all_marker();
-     extern void GC_wait_marker();
+     extern void GC_notify_all_marker(void);
+     extern void GC_wait_marker(void);
      extern word GC_mark_no;		/* Protected by mark lock.	*/
 
      extern void GC_help_marker(word my_mark_no);
diff -rusb mono-20100806.orig/libgc/include/private/pthread_support.h mono-20100806/libgc/include/private/pthread_support.h
--- mono-20100806.orig/libgc/include/private/pthread_support.h	2009-08-24 21:29:47.000000000 +0200
+++ mono-20100806/libgc/include/private/pthread_support.h	2010-08-06 18:38:47.000000000 +0200
@@ -94,7 +94,7 @@
 
 void GC_thread_deregister_foreign (void *data);
 
-void GC_stop_init();
+void GC_stop_init(void);
 
 extern GC_bool GC_in_thread_creation;
 	/* We may currently be in thread creation or destruction.	*/
diff -rusb mono-20100806.orig/libgc/mark.c mono-20100806/libgc/mark.c
--- mono-20100806.orig/libgc/mark.c	2009-08-24 21:29:48.000000000 +0200
+++ mono-20100806/libgc/mark.c	2010-08-06 18:33:02.000000000 +0200
@@ -28,7 +28,7 @@
 #ifdef __WATCOMC__
   void GC_noop(void *p, ...) {}
 #else
-  void GC_noop() {}
+  void GC_noop(/* var args */) {}
 #endif
 
 /* Single argument version, robust against whole program analysis. */
diff -rusb mono-20100806.orig/libgc/pthread_stop_world.c mono-20100806/libgc/pthread_stop_world.c
--- mono-20100806.orig/libgc/pthread_stop_world.c	2009-08-24 21:29:48.000000000 +0200
+++ mono-20100806/libgc/pthread_stop_world.c	2010-08-06 18:24:46.000000000 +0200
@@ -412,7 +412,7 @@
 }
 
 /* Caller holds allocation lock.	*/
-void GC_stop_world()
+void GC_stop_world(void)
 {
     if (GC_notify_event)
         GC_notify_event (GC_EVENT_PRE_STOP_WORLD);
@@ -501,7 +501,7 @@
     #endif
 }
 
-void GC_start_world()
+void GC_start_world(void)
 {
 #ifdef MONO_DEBUGGER_SUPPORTED
     if (gc_thread_vtable && gc_thread_vtable->start_world)
diff -rusb mono-20100806.orig/libgc/pthread_support.c mono-20100806/libgc/pthread_support.c
--- mono-20100806.orig/libgc/pthread_support.c	2009-08-24 21:29:48.000000000 +0200
+++ mono-20100806/libgc/pthread_support.c	2010-08-06 18:37:39.000000000 +0200
@@ -1709,7 +1709,7 @@
 
 static pthread_cond_t builder_cv = PTHREAD_COND_INITIALIZER;
 
-void GC_acquire_mark_lock()
+void GC_acquire_mark_lock(void)
 {
 /*
     if (pthread_mutex_lock(&mark_mutex) != 0) {
@@ -1722,7 +1722,7 @@
 #   endif
 }
 
-void GC_release_mark_lock()
+void GC_release_mark_lock(void)
 {
     GC_ASSERT(GC_mark_lock_holder == pthread_self());
 #   ifdef GC_ASSERTIONS
@@ -1738,7 +1738,7 @@
 /* 2) Partial free lists referenced only by locals may not be scanned 	*/
 /*    correctly, e.g. if they contain "pointer-free" objects, since the	*/
 /*    free-list link may be ignored.					*/
-void GC_wait_builder()
+void GC_wait_builder(void)
 {
     GC_ASSERT(GC_mark_lock_holder == pthread_self());
 #   ifdef GC_ASSERTIONS
@@ -1753,7 +1753,7 @@
 #   endif
 }
 
-void GC_wait_for_reclaim()
+void GC_wait_for_reclaim(void)
 {
     GC_acquire_mark_lock();
     while (GC_fl_builder_count > 0) {
@@ -1762,7 +1762,7 @@
     GC_release_mark_lock();
 }
 
-void GC_notify_all_builder()
+void GC_notify_all_builder(void)
 {
     GC_ASSERT(GC_mark_lock_holder == pthread_self());
     if (pthread_cond_broadcast(&builder_cv) != 0) {
@@ -1776,7 +1776,7 @@
 
 static pthread_cond_t mark_cv = PTHREAD_COND_INITIALIZER;
 
-void GC_wait_marker()
+void GC_wait_marker(void)
 {
     GC_ASSERT(GC_mark_lock_holder == pthread_self());
 #   ifdef GC_ASSERTIONS
@@ -1791,7 +1791,7 @@
 #   endif
 }
 
-void GC_notify_all_marker()
+void GC_notify_all_marker(void)
 {
     if (pthread_cond_broadcast(&mark_cv) != 0) {
 	ABORT("pthread_cond_broadcast failed");
diff -rusb mono-20100806.orig/libgc/solaris_threads.c mono-20100806/libgc/solaris_threads.c
--- mono-20100806.orig/libgc/solaris_threads.c	2009-09-30 09:01:59.000000000 +0200
+++ mono-20100806/libgc/solaris_threads.c	2010-08-06 18:24:50.000000000 +0200
@@ -405,14 +405,14 @@
 
 GC_bool GC_multithreaded = 0;
 
-void GC_stop_world()
+void GC_stop_world(void)
 {
     preempt_off();
     if (GC_multithreaded)
         stop_all_lwps();
 }
 
-void GC_start_world()
+void GC_start_world(void)
 {
     if (GC_multithreaded)
         restart_all_lwps();
diff -rusb mono-20100806.orig/libgc/win32_threads.c mono-20100806/libgc/win32_threads.c
--- mono-20100806.orig/libgc/win32_threads.c	2009-08-24 21:29:48.000000000 +0200
+++ mono-20100806/libgc/win32_threads.c	2010-08-06 18:24:40.000000000 +0200
@@ -247,7 +247,7 @@
 /* Defined in misc.c */
 extern CRITICAL_SECTION GC_write_cs;
 
-void GC_stop_world()
+void GC_stop_world(void)
 {
   DWORD thread_id = GetCurrentThreadId();
   int i;
@@ -300,7 +300,7 @@
 # endif /* !CYGWIN32 */
 }
 
-void GC_start_world()
+void GC_start_world(void)
 {
   DWORD thread_id = GetCurrentThreadId();
   int i;
diff -rusb mono-20100806.orig/mono/metadata/sgen-gc.c mono-20100806/mono/metadata/sgen-gc.c
--- mono-20100806.orig/mono/metadata/sgen-gc.c	2010-07-14 09:01:26.000000000 +0200
+++ mono-20100806/mono/metadata/sgen-gc.c	2010-08-06 18:53:18.000000000 +0200
@@ -237,7 +237,6 @@
  * ########  Types and constants used by the GC.
  * ######################################################################
  */
-
 static int gc_initialized = 0;
 static int gc_debug_level = 0;
 static FILE* gc_debug_file;
@@ -254,6 +253,13 @@
 /* If set, do a plausibility check on the scan_starts before and after
    each collection */
 static gboolean do_scan_starts_check = FALSE;
+/* default signal numbers */
+#ifdef __APPLE__
+const int suspend_signal_num = SIGXFSZ;
+#else
+const int suspend_signal_num = SIGPWR;
+#endif
+static const int restart_signal_num = SIGXCPU;
 
 /*
  * Turning on heavy statistics will turn off the managed allocator and
diff -rusb mono-20100806.orig/mono/metadata/sgen-gc.h mono-20100806/mono/metadata/sgen-gc.h
--- mono-20100806.orig/mono/metadata/sgen-gc.h	2010-07-14 09:01:26.000000000 +0200
+++ mono-20100806/mono/metadata/sgen-gc.h	2010-08-06 18:54:03.000000000 +0200
@@ -89,12 +89,7 @@
 #endif
 };
 
-#ifdef __APPLE__
-static int suspend_signal_num = SIGXFSZ;
-#else
-static int suspend_signal_num = SIGPWR;
-#endif
-static int restart_signal_num = SIGXCPU;
+extern const int suspend_signal_num;
 
 /*
  * Recursion is not allowed for the thread lock.
@@ -143,4 +138,3 @@
 gboolean mono_sgen_is_worker_thread (pthread_t thread) MONO_INTERNAL;
 
 #endif /* __MONO_SGENGC_H__ */
-
diff -rusb mono-20100806.orig/mono/utils/dlmalloc.c mono-20100806/mono/utils/dlmalloc.c
--- mono-20100806.orig/mono/utils/dlmalloc.c	2009-08-24 21:29:50.000000000 +0200
+++ mono-20100806/mono/utils/dlmalloc.c	2010-08-06 19:43:07.000000000 +0200
@@ -454,6 +454,13 @@
 
 */
 
+#if defined(__STDC__)
+#   define VOLATILE volatile
+#else
+#   define VOLATILE
+#endif
+#define UNUSED_VARIABLE(v) (void)(v)
+
 #ifndef WIN32
 #ifdef _WIN32
 #define WIN32 1
@@ -2504,6 +2511,7 @@
   return 0;
 }
 
+#if (MSPACES) || (!ONLY_MSPACES && 0)
 /* support for mallopt */
 static int change_mparam(int param_number, int value) {
   size_t val = (size_t)value;
@@ -2526,6 +2534,7 @@
     return 0;
   }
 }
+#endif
 
 #if DEBUG
 /* ------------------------- Debugging Support --------------------------- */
@@ -2837,6 +2846,7 @@
 }
 #endif /* !NO_MALLINFO */
 
+#if (MSPACES) || (!ONLY_MSPACES && 0)
 static void internal_malloc_stats(mstate m) {
   if (!PREACTION(m)) {
     size_t maxfp = 0;
@@ -2868,6 +2878,7 @@
     POSTACTION(m);
   }
 }
+#endif
 
 /* ----------------------- Operations on smallbins ----------------------- */
 
@@ -3413,7 +3424,8 @@
             if (end != CMFAIL)
               asize += esize;
             else {            /* Can't use; try to release */
-              CALL_MORECORE(-asize);
+              VOLATILE char *c = (char*)(CALL_MORECORE(-asize));
+              UNUSED_VARIABLE(c);
               br = CMFAIL;
             }
           }
diff -rusb mono-20100806.orig/mono/utils/strtod.c mono-20100806/mono/utils/strtod.c
--- mono-20100806.orig/mono/utils/strtod.c	2010-03-05 09:01:43.000000000 +0100
+++ mono-20100806/mono/utils/strtod.c	2010-08-06 18:16:52.000000000 +0200
@@ -2438,6 +2438,7 @@
 	return sign ? -dval(rv) : dval(rv);
 	}
 
+#if 0
  static int
 quorem
 #ifdef KR_headers
@@ -2555,6 +2556,7 @@
 		}
 	return q;
 	}
+#endif
 
 #ifndef MULTIPLE_THREADS
  static char *dtoa_result;
@@ -2583,6 +2585,7 @@
 		(char *)(r+1);
 	}
 
+#if 0
  static char *
 #ifdef KR_headers
 nrv_alloc(s, rve, n) char *s, **rve; int n;
@@ -2598,7 +2601,11 @@
 		*rve = t;
 	return rv;
 	}
+#endif
+
+#if 0 /* dtoa/freedtoa() */
 
+#ifndef MULTIPLE_THREADS
 /* freedtoa(s) must be used to free values s returned by dtoa
  * when MULTIPLE_THREADS is #defined.  It should be used in all cases,
  * but for consistency with earlier versions of dtoa, it is optional
@@ -2622,8 +2629,8 @@
 		dtoa_result = 0;
 #endif
 	}
+#endif
 
-#if 0
 /* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.
  *
  * Inspired by "How to Print Floating-Point Numbers Accurately" by
@@ -2749,7 +2756,8 @@
 #endif
 		return nrv_alloc("NaN", rve, 3);
 		}
-#endif
+#endif /* #if defined(IEEE_Arith) + defined(VAX) */
+
 #ifdef IBM
 	dval(d) += 0; /* normalize */
 #endif
@@ -3336,7 +3344,7 @@
 		*rve = s;
 	return s0;
 	}
-#endif
+#endif /* #if 0 */
 
 #ifdef __cplusplus
 }
