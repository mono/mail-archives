=== ChangeLog
==================================================================
--- ChangeLog	(revision 76511)
+++ ChangeLog	(local)
@@ -1,3 +1,18 @@
+2006-12-20  Raja R Harinath  <rharinath@novell.com>
+
+	Fix WaitHandle usage in delegates.
+	* class-internals (MonoSafeHandle): Move to ...
+	* object-internals.h (MonoSafeHandle): ... here.
+	(MonoWaitHandle): Change 'handle' field to an union.
+	(mono_wait_handle_get_HANDLE): Declare.
+	* object.c (mono_wait_handle_new): Use the property set method to
+	initialize the handle.
+	(mono_wait_handle_get_HANDLE): New.
+	* threadpool.c (mono_async_invoke): Use it.
+	* threads.c (ves_icall_System_Threading_WaitHandle_WaitAll_internal):
+	Likewise.
+	(ves_icall_System_Threading_WaitHandle_WaitAny_internal): Likewise.
+
 2006-12-19  Jonathan Chambers  <joncham@gmail.com>
 
 	* marshal.c (ves_icall_System_Runtime_InteropServices_Marshal_AllocHGlobal,
=== class-internals.h
==================================================================
--- class-internals.h	(revision 76511)
+++ class-internals.h	(local)
@@ -561,16 +561,6 @@
 	gboolean enabled;
 } MonoStats;
 
-/*
- * The definition of the first field in SafeHandle,
- * Keep in sync with SafeHandle.cs, this is only used
- * to access the `handle' parameter.
- */
-typedef struct {
-	MonoObject  base;
-	void       *handle;
-} MonoSafeHandle;
-
 extern MonoStats mono_stats MONO_INTERNAL;
 
 typedef gpointer (*MonoTrampoline)       (MonoMethod *method);
=== object-internals.h
==================================================================
--- object-internals.h	(revision 76511)
+++ object-internals.h	(local)
@@ -161,9 +161,22 @@
 	MonoObject  *original_context;
 } MonoAsyncResult;
 
+/*
+ * The definition of the first field in SafeHandle,
+ * Keep in sync with SafeHandle.cs, this is only used
+ * to access the `handle' parameter.
+ */
 typedef struct {
+	MonoObject  base;
+	void       *handle;
+} MonoSafeHandle;
+
+typedef struct {
 	MonoMarshalByRefObject object;
-	gpointer     handle;
+	union {
+		gpointer 	os_handle;
+		MonoSafeHandle *safe_handle;
+	} handle;
 	MonoBoolean  disposed;
 } MonoWaitHandle;
 
@@ -427,6 +440,9 @@
 MonoWaitHandle *
 mono_wait_handle_new	    (MonoDomain *domain, HANDLE handle) MONO_INTERNAL;
 
+HANDLE
+mono_wait_handle_get_HANDLE (MonoWaitHandle *handle) MONO_INTERNAL;
+
 void
 mono_message_init	    (MonoDomain *domain, MonoMethodMessage *this_obj, 
 			     MonoReflectionMethod *method, MonoArray *out_args) MONO_INTERNAL;
=== object.c
==================================================================
--- object.c	(revision 76511)
+++ object.c	(local)
@@ -3773,14 +3773,35 @@
 mono_wait_handle_new (MonoDomain *domain, HANDLE handle)
 {
 	MonoWaitHandle *res;
+	gpointer params [1];
+	static MonoMethod *handle_set;
 
 	res = (MonoWaitHandle *)mono_object_new (domain, mono_defaults.waithandle_class);
 
-	res->handle = handle;
+	/* Even though this method is virtual, it's safe to invoke directly, since the object type matches.  */
+	if (!handle_set)
+		handle_set = mono_class_get_property_from_name (mono_defaults.waithandle_class, "Handle")->set;
 
+	params [0] = &handle;
+	mono_runtime_invoke (handle_set, res, params, NULL);
+
 	return res;
 }
 
+HANDLE
+mono_wait_handle_get_HANDLE (MonoWaitHandle *handle)
+{
+	static MonoClassField *f_os_handle;
+	static MonoClassField *f_safe_handle;
+
+	if (!f_os_handle && !f_safe_handle) {
+		f_os_handle = mono_class_get_field_from_name (mono_defaults.waithandle_class, "os_handle");
+		f_safe_handle = mono_class_get_field_from_name (mono_defaults.waithandle_class, "safe_wait_handle");
+	}
+
+	return f_os_handle ? handle->handle.os_handle : handle->handle.safe_handle->handle;
+}
+
 /**
  * mono_async_result_new:
  * @domain:domain where the object will be created.
=== threadpool.c
==================================================================
--- threadpool.c	(revision 76511)
+++ threadpool.c	(local)
@@ -970,7 +970,7 @@
 	/* notify listeners */
 	mono_monitor_enter ((MonoObject *) ares);
 	if (ares->handle != NULL) {
-		ac->wait_event = (gsize)((MonoWaitHandle *) ares->handle)->handle;
+		ac->wait_event = (gsize) mono_wait_handle_get_HANDLE ((MonoWaitHandle *) ares->handle);
 		SetEvent ((gpointer)(gsize)ac->wait_event);
 	}
 	mono_monitor_exit ((MonoObject *) ares);
=== threads.c
==================================================================
--- threads.c	(revision 76511)
+++ threads.c	(local)
@@ -84,13 +84,6 @@
 #define CULTURES_START_IDX 0
 #define UICULTURES_START_IDX NUM_CACHED_CULTURES
 
-/*
- * The "os_handle" field or the "safe_wait_handle" field of the WaitHandle class.
- * the former is used for 1.x profiles, the later for 2.0
- */
-static MonoClassField *wait_handle_os_handle_field = NULL;
-static MonoClassField *wait_handle_safe_handle_field = NULL;
-
 /* Controls access to the 'threads' hash table */
 #define mono_threads_lock() EnterCriticalSection (&threads_mutex)
 #define mono_threads_unlock() LeaveCriticalSection (&threads_mutex)
@@ -858,20 +851,6 @@
 	return(FALSE);
 }
 
-static void
-ensure_wait_handle_fields ()
-{
-	MonoClass *klass;
-
-	if (wait_handle_os_handle_field == 0 && wait_handle_safe_handle_field == 0) {
-		/* Get the field os_handle which will contain the actual handle */
-		klass = mono_class_from_name(mono_defaults.corlib, "System.Threading", "WaitHandle");
-		wait_handle_os_handle_field = mono_class_get_field_from_name(klass, "os_handle");
-		if (wait_handle_os_handle_field == NULL)
-			wait_handle_safe_handle_field = mono_class_get_field_from_name (klass, "safe_wait_handle");
-	}
-}
-
 /* FIXME: exitContext isnt documented */
 gboolean ves_icall_System_Threading_WaitHandle_WaitAll_internal(MonoArray *mono_handles, gint32 ms, gboolean exitContext)
 {
@@ -890,18 +869,9 @@
 	numhandles = mono_array_length(mono_handles);
 	handles = g_new0(HANDLE, numhandles);
 
-	ensure_wait_handle_fields ();
-		
 	for(i = 0; i < numhandles; i++) {	
 		waitHandle = mono_array_get(mono_handles, MonoObject*, i);
-		if (wait_handle_os_handle_field != NULL)
-			mono_field_get_value(waitHandle, wait_handle_os_handle_field, &handles[i]);
-		else {
-			MonoSafeHandle *sh;
-			
-			mono_field_get_value(waitHandle, wait_handle_safe_handle_field, &sh);
-			handles [i] = sh->handle;
-		}
+		handles [i] = mono_wait_handle_get_HANDLE ((MonoWaitHandle *) waitHandle);
 	}
 	
 	if(ms== -1) {
@@ -954,18 +924,9 @@
 	numhandles = mono_array_length(mono_handles);
 	handles = g_new0(HANDLE, numhandles);
 
-	ensure_wait_handle_fields ();
-
 	for(i = 0; i < numhandles; i++) {	
 		waitHandle = mono_array_get(mono_handles, MonoObject*, i);
-		if (wait_handle_os_handle_field != NULL)
-			mono_field_get_value(waitHandle, wait_handle_os_handle_field, &handles[i]);
-		else {
-			MonoSafeHandle *sh;
-			
-			mono_field_get_value(waitHandle, wait_handle_safe_handle_field, &sh);
-			handles [i] = sh->handle;
-		}
+		handles [i] = mono_wait_handle_get_HANDLE ((MonoWaitHandle *) waitHandle);
 	}
 	
 	if(ms== -1) {
