Index: mono/metadata/object.c
===================================================================
--- mono/metadata/object.c	(revision 17)
+++ mono/metadata/object.c	(working copy)
@@ -3414,7 +3414,7 @@
 void
 mono_array_full_copy (MonoArray *src, MonoArray *dest)
 {
-	int size;
+	gsize size;
 	MonoClass *klass = src->obj.vtable->klass;
 
 	MONO_ARCH_SAVE_REGS;
@@ -3450,8 +3450,8 @@
 mono_array_clone_in_domain (MonoDomain *domain, MonoArray *array)
 {
 	MonoArray *o;
-	guint32 size, i;
-	guint32 *sizes;
+	gsize size, i;
+	gsize *sizes;
 	MonoClass *klass = array->obj.vtable->klass;
 
 	MONO_ARCH_SAVE_REGS;
@@ -3476,7 +3476,7 @@
 		return o;
 	}
 	
-	sizes = alloca (klass->rank * sizeof(guint32) * 2);
+	sizes = alloca (klass->rank * sizeof(gsize) * 2);
 	size = mono_array_element_size (klass);
 	for (i = 0; i < klass->rank; ++i) {
 		sizes [i] = array->bounds [i].length;
@@ -3513,12 +3513,23 @@
 }
 
 /* helper macros to check for overflow when calculating the size of arrays */
-#define MYGUINT32_MAX 4294967295U
+#if (GLIB_SIZEOF_SIZE_T < 4 )
+#define MYGUINT32_MAX 0xFFFFFFFFUL
+#define MYGUINT_MAX MYGUINT32_MAX
 #define CHECK_ADD_OVERFLOW_UN(a,b) \
         (guint32)(MYGUINT32_MAX) - (guint32)(b) < (guint32)(a) ? -1 : 0
 #define CHECK_MUL_OVERFLOW_UN(a,b) \
         ((guint32)(a) == 0) || ((guint32)(b) == 0) ? 0 : \
         (guint32)(b) > ((MYGUINT32_MAX) / (guint32)(a))
+#else
+#define MYGUINT64_MAX 0x0000FFFFFFFFFFFFUL
+#define MYGUINT_MAX MYGUINT64_MAX
+#define CHECK_ADD_OVERFLOW_UN(a,b) \
+        (guint64)(MYGUINT64_MAX) - (guint64)(b) < (guint64)(a) ? -1 : 0
+#define CHECK_MUL_OVERFLOW_UN(a,b) \
+        ((guint64)(a) == 0) || ((guint64)(b) == 0) ? 0 : \
+        (guint64)(b) > ((MYGUINT64_MAX) / (guint64)(a))
+#endif
 
 /**
  * mono_array_new_full:
@@ -3531,9 +3542,9 @@
  * lower bounds and type.
  */
 MonoArray*
-mono_array_new_full (MonoDomain *domain, MonoClass *array_class, guint32 *lengths, guint32 *lower_bounds)
+mono_array_new_full (MonoDomain *domain, MonoClass *array_class, gsize *lengths, gsize *lower_bounds)
 {
-	guint32 byte_len, len, bounds_size;
+	gsize byte_len, len, bounds_size;
 	MonoObject *o;
 	MonoArray *array;
 	MonoVTable *vtable;
@@ -3548,34 +3559,30 @@
 	/* A single dimensional array with a 0 lower bound is the same as an szarray */
 	if (array_class->rank == 1 && ((array_class->byval_arg.type == MONO_TYPE_SZARRAY) || (lower_bounds && lower_bounds [0] == 0))) {
 		len = lengths [0];
-		if ((int) len < 0)
-			arith_overflow ();
 		bounds_size = 0;
 	} else {
 		bounds_size = sizeof (MonoArrayBounds) * array_class->rank;
 
 		for (i = 0; i < array_class->rank; ++i) {
-			if ((int) lengths [i] < 0)
-				arith_overflow ();
 			if (CHECK_MUL_OVERFLOW_UN (len, lengths [i]))
-				mono_gc_out_of_memory (MYGUINT32_MAX);
+				mono_gc_out_of_memory (MYGUINT_MAX);
 			len *= lengths [i];
 		}
 	}
 
 	if (CHECK_MUL_OVERFLOW_UN (byte_len, len))
-		mono_gc_out_of_memory (MYGUINT32_MAX);
+		mono_gc_out_of_memory (MYGUINT_MAX);
 	byte_len *= len;
 	if (CHECK_ADD_OVERFLOW_UN (byte_len, sizeof (MonoArray)))
-		mono_gc_out_of_memory (MYGUINT32_MAX);
+		mono_gc_out_of_memory (MYGUINT_MAX);
 	byte_len += sizeof (MonoArray);
 	if (bounds_size) {
 		/* align */
 		if (CHECK_ADD_OVERFLOW_UN (byte_len, 3))
-			mono_gc_out_of_memory (MYGUINT32_MAX);
+			mono_gc_out_of_memory (MYGUINT_MAX);
 		byte_len = (byte_len + 3) & ~3;
 		if (CHECK_ADD_OVERFLOW_UN (byte_len, bounds_size))
-			mono_gc_out_of_memory (MYGUINT32_MAX);
+			mono_gc_out_of_memory (MYGUINT_MAX);
 		byte_len += bounds_size;
 	}
 	/* 
@@ -3621,7 +3628,7 @@
  * This routine creates a new szarray with @n elements of type @eclass.
  */
 MonoArray *
-mono_array_new (MonoDomain *domain, MonoClass *eclass, guint32 n)
+mono_array_new (MonoDomain *domain, MonoClass *eclass, gsize n)
 {
 	MonoClass *ac;
 
@@ -3642,24 +3649,28 @@
  * can be sure about the domain it operates in.
  */
 MonoArray *
-mono_array_new_specific (MonoVTable *vtable, guint32 n)
+mono_array_new_specific (MonoVTable *vtable, gsize n)
 {
 	MonoObject *o;
 	MonoArray *ao;
-	guint32 byte_len, elem_size;
+	gsize byte_len, elem_size;
 
 	MONO_ARCH_SAVE_REGS;
 
-	if ((int) n < 0)
-		arith_overflow ();
-	
 	elem_size = mono_array_element_size (vtable->klass);
-	if (CHECK_MUL_OVERFLOW_UN (n, elem_size))
-		mono_gc_out_of_memory (MYGUINT32_MAX);
+	if (CHECK_MUL_OVERFLOW_UN (n, elem_size)) {
+		g_print("CHECK_MUL_OVERFLOW_UN(%zd,%zd) failed\n",n, elem_size);
+		mono_gc_out_of_memory (MYGUINT_MAX);
+        }
 	byte_len = n * elem_size;
-	if (CHECK_ADD_OVERFLOW_UN (byte_len, sizeof (MonoArray)))
-		mono_gc_out_of_memory (MYGUINT32_MAX);
+	if (CHECK_ADD_OVERFLOW_UN (byte_len, sizeof (MonoArray))) {
+		g_print("CHECK_ADD_OVERFLOW_UN(%zd,%zd) failed\n",byte_len, sizeof (MonoArray));
+		mono_gc_out_of_memory (MYGUINT_MAX);
+        }
 	byte_len += sizeof (MonoArray);
+	if ( byte_len > 0x1000000000000000) {
+		g_print("mono_array_new_specific: Allocating a big one 0x%zx\n",byte_len);
+	}
 	if (!vtable->klass->has_references) {
 		o = mono_object_allocate_ptrfree (byte_len, vtable);
 #if NEED_TO_ZERO_PTRFREE
Index: mono/metadata/object.h
===================================================================
--- mono/metadata/object.h	(revision 17)
+++ mono/metadata/object.h	(working copy)
@@ -29,8 +29,8 @@
 } MonoObject;
 
 typedef struct {
-	guint32 length;
-	guint32 lower_bound;
+	gsize length;
+	gsize lower_bound;
 } MonoArrayBounds;
 
 typedef struct {
@@ -38,7 +38,7 @@
 	/* bounds is NULL for szarrays */
 	MonoArrayBounds *bounds;
 	/* total number of elements of the array */
-	guint32 max_length; 
+	gsize max_length; 
 	/* we use double to ensure proper alignment on platforms that need it */
 	double vector [MONO_ZERO_LEN_ARRAY];
 } MonoArray;
@@ -103,14 +103,14 @@
 mono_object_new_from_token  (MonoDomain *domain, MonoImage *image, guint32 token);
 
 MonoArray*
-mono_array_new		    (MonoDomain *domain, MonoClass *eclass, guint32 n);
+mono_array_new		    (MonoDomain *domain, MonoClass *eclass, gsize n);
 
 MonoArray*
 mono_array_new_full	    (MonoDomain *domain, MonoClass *array_class,
-			     guint32 *lengths, guint32 *lower_bounds);
+			     gsize *lengths, gsize *lower_bounds);
 
 MonoArray *
-mono_array_new_specific	    (MonoVTable *vtable, guint32 n);
+mono_array_new_specific	    (MonoVTable *vtable, gsize n);
 
 MonoArray*
 mono_array_clone	    (MonoArray *array);
Index: mono/metadata/icall-def.h
===================================================================
--- mono/metadata/icall-def.h	(revision 17)
+++ mono/metadata/icall-def.h	(working copy)
@@ -90,9 +90,11 @@
 ICALL(ARRAY_1, "ClearInternal",    ves_icall_System_Array_ClearInternal)
 ICALL(ARRAY_2, "Clone",            mono_array_clone)
 ICALL(ARRAY_3, "CreateInstanceImpl",   ves_icall_System_Array_CreateInstanceImpl)
+ICALL(ARRAY_14, "CreateInstanceImpl64",   ves_icall_System_Array_CreateInstanceImpl64)
 ICALL(ARRAY_4, "FastCopy",         ves_icall_System_Array_FastCopy)
 ICALL(ARRAY_5, "GetGenericValueImpl", ves_icall_System_Array_GetGenericValueImpl)
 ICALL(ARRAY_6, "GetLength",        ves_icall_System_Array_GetLength)
+ICALL(ARRAY_16, "GetLongLength",        ves_icall_System_Array_GetLongLength)
 ICALL(ARRAY_7, "GetLowerBound",    ves_icall_System_Array_GetLowerBound)
 ICALL(ARRAY_8, "GetRank",          ves_icall_System_Array_GetRank)
 ICALL(ARRAY_9, "GetValue",         ves_icall_System_Array_GetValue)
Index: mono/metadata/icall.c
===================================================================
--- mono/metadata/icall.c	(revision 17)
+++ mono/metadata/icall.c	(working copy)
@@ -503,7 +503,7 @@
 {
 	MonoClass *aklass;
 	MonoArray *array;
-	guint32 *sizes, i;
+	gsize *sizes, i;
 	gboolean bounded = FALSE;
 
 	MONO_ARCH_SAVE_REGS;
@@ -527,11 +527,11 @@
 
 	aklass = mono_bounded_array_class_get (mono_class_from_mono_type (type->type), mono_array_length (lengths), bounded);
 
-	sizes = alloca (aklass->rank * sizeof(guint32) * 2);
+	sizes = alloca (aklass->rank * sizeof(gsize) * 2);
 	for (i = 0; i < aklass->rank; ++i) {
-		sizes [i] = mono_array_get (lengths, guint32, i);
+		sizes [i] = mono_array_get (lengths, gint32, i);
 		if (bounds)
-			sizes [i + aklass->rank] = mono_array_get (bounds, guint32, i);
+			sizes [i + aklass->rank] = mono_array_get (bounds, gint32, i);
 		else
 			sizes [i + aklass->rank] = 0;
 	}
@@ -541,6 +541,50 @@
 	return array;
 }
 
+static MonoArray *
+ves_icall_System_Array_CreateInstanceImpl64 (MonoReflectionType *type, MonoArray *lengths, MonoArray *bounds)
+{
+	MonoClass *aklass;
+	MonoArray *array;
+	gsize *sizes, i;
+	gboolean bounded = FALSE;
+
+	MONO_ARCH_SAVE_REGS;
+
+	MONO_CHECK_ARG_NULL (type);
+	MONO_CHECK_ARG_NULL (lengths);
+
+	MONO_CHECK_ARG (lengths, mono_array_length (lengths) > 0);
+	if (bounds)
+		MONO_CHECK_ARG (bounds, mono_array_length (lengths) == mono_array_length (bounds));
+
+	for (i = 0; i < mono_array_length (lengths); i++)
+		if (mono_array_get (lengths, gint64, i) < 0)
+			mono_raise_exception (mono_get_exception_argument_out_of_range (NULL));
+
+	if (bounds && (mono_array_length (bounds) == 1) && (mono_array_get (bounds, gint64, 0) != 0))
+		/* vectors are not the same as one dimensional arrays with no-zero bounds */
+		bounded = TRUE;
+	else
+		bounded = FALSE;
+
+	aklass = mono_bounded_array_class_get (mono_class_from_mono_type (type->type), mono_array_length (lengths), bounded);
+
+	sizes = alloca (aklass->rank * sizeof(gsize) * 2);
+	for (i = 0; i < aklass->rank; ++i) {
+		sizes [i] = mono_array_get (lengths, gint64, i);
+		if (bounds)
+			sizes [i + aklass->rank] = mono_array_get (bounds, gint64, i);
+		else
+			sizes [i + aklass->rank] = 0;
+	}
+
+	array = mono_array_new_full (mono_object_domain (type), aklass, sizes, sizes + aklass->rank);
+
+	return array;
+}
+
+
 static gint32 
 ves_icall_System_Array_GetRank (MonoObject *this)
 {
@@ -553,6 +597,7 @@
 ves_icall_System_Array_GetLength (MonoArray *this, gint32 dimension)
 {
 	gint32 rank = ((MonoObject *)this)->vtable->klass->rank;
+	gsize length;
 
 	MONO_ARCH_SAVE_REGS;
 
@@ -562,6 +607,26 @@
 	if (this->bounds == NULL)
 		return this->max_length;
 	
+	length = this->bounds [dimension].length;
+	if (length > G_MAXINT32)
+	        mono_raise_exception (mono_get_exception_overflow ());
+
+	return length;
+}
+
+static gint64
+ves_icall_System_Array_GetLongLength (MonoArray *this, gint32 dimension)
+{
+	gint32 rank = ((MonoObject *)this)->vtable->klass->rank;
+
+	MONO_ARCH_SAVE_REGS;
+
+	if ((dimension < 0) || (dimension >= rank))
+		mono_raise_exception (mono_get_exception_index_out_of_range ());
+	
+	if (this->bounds == NULL)
+		return this->max_length;
+	
 	return this->bounds [dimension].length;
 }
 
@@ -2782,12 +2847,12 @@
 	
 	if (m->klass->rank && !strcmp (m->name, ".ctor")) {
 		int i;
-		guint32 *lengths;
-		guint32 *lower_bounds;
+		gsize *lengths;
+		gsize *lower_bounds;
 		pcount = mono_array_length (params);
-		lengths = alloca (sizeof (guint32) * pcount);
+		lengths = alloca (sizeof (gsize) * pcount);
 		for (i = 0; i < pcount; ++i)
-			lengths [i] = *(gint32*) ((char*)mono_array_get (params, gpointer, i) + sizeof (MonoObject));
+			lengths [i] = *(gsize*) ((char*)mono_array_get (params, gpointer, i) + sizeof (MonoObject));
 
 		if (m->klass->rank == pcount) {
 			/* Only lengths provided. */
Index: mono/metadata/socket-io.c
===================================================================
--- mono/metadata/socket-io.c	(revision 17)
+++ mono/metadata/socket-io.c	(working copy)
@@ -1494,7 +1494,7 @@
 	MonoObject *obj;
 	mono_pollfd *pfds;
 	int nfds, idx;
-	int ret;
+	gssize ret;
 	int i, count;
 	int mode;
 	MonoClass *sock_arr_class;
@@ -1579,7 +1579,7 @@
 
 	sock_arr_class= ((MonoObject *)*sockets)->vtable->klass;
 	ret += 3; /* space for the NULL delimiters */
-	socks = mono_array_new_full (mono_domain_get (), sock_arr_class, (guint32*)&ret, NULL);
+	socks = mono_array_new_full (mono_domain_get (), sock_arr_class, (gsize*)&ret, NULL);
 	ret -= 3;
 	mode = idx = 0;
 	for (i = 0; i < count && ret > 0; i++) {
Index: mono/mini/mini.c
===================================================================
--- mono/mini/mini.c	(revision 17)
+++ mono/mini/mini.c	(working copy)
@@ -12400,8 +12400,8 @@
 	register_icall (mono_helper_stelem_ref_check, "helper_stelem_ref_check", "void object object", FALSE);
 	register_icall (mono_object_new, "mono_object_new", "object ptr ptr", FALSE);
 	register_icall (mono_object_new_specific, "mono_object_new_specific", "object ptr", FALSE);
-	register_icall (mono_array_new, "mono_array_new", "object ptr ptr int32", FALSE);
-	register_icall (mono_array_new_specific, "mono_array_new_specific", "object ptr int32", FALSE);
+	register_icall (mono_array_new, "mono_array_new", "object ptr ptr int", FALSE);
+	register_icall (mono_array_new_specific, "mono_array_new_specific", "object ptr int", FALSE);
 	register_icall (mono_runtime_class_init, "mono_runtime_class_init", "void ptr", FALSE);
 	register_icall (mono_ldftn, "mono_ldftn", "ptr ptr", FALSE);
 	register_icall (mono_ldftn_nosync, "mono_ldftn_nosync", "ptr ptr", FALSE);
Index: mono/mini/inssel-amd64.brg
===================================================================
--- mono/mini/inssel-amd64.brg	(revision 17)
+++ mono/mini/inssel-amd64.brg	(working copy)
@@ -1,7 +1,7 @@
 #define MONO_EMIT_NEW_AMD64_ICOMPARE_MEMBASE_REG(cfg,basereg,offset,operand) do { \
 		MonoInst *inst; \
 		inst = mono_mempool_alloc0 ((cfg)->mempool, sizeof (MonoInst));	\
-		inst->opcode = OP_AMD64_ICOMPARE_MEMBASE_REG; \
+		inst->opcode = OP_AMD64_COMPARE_MEMBASE_REG_I8; \
 		inst->inst_basereg = basereg; \
 		inst->inst_offset = offset; \
 		inst->sreg2 = operand; \
@@ -412,7 +412,7 @@
 	
 	MONO_EMIT_BOUNDS_CHECK (s, state->left->reg1, MonoArray, max_length, state->right->reg1);
 
-	if (size == 1 || size == 2 || size == 4 || size == 8) {
+	if ( size < 0) {
 		static const int fast_log2 [] = { 1, 0, 1, -1, 2, -1, -1, -1, 3 };
 		int reg;
 
Index: mono/mini/mini-amd64.c
===================================================================
--- mono/mini/mini-amd64.c	(revision 17)
+++ mono/mini/mini-amd64.c	(working copy)
@@ -2763,6 +2763,9 @@
 		case OP_AMD64_ICOMPARE_MEMBASE_REG:
 			amd64_alu_membase_reg_size (code, X86_CMP, ins->inst_basereg, ins->inst_offset, ins->sreg2, 4);
 			break;
+		case OP_AMD64_COMPARE_MEMBASE_REG_I8:
+			amd64_alu_membase_reg_size (code, X86_CMP, ins->inst_basereg, ins->inst_offset, ins->sreg2, 8);
+			break;
 		case OP_AMD64_ICOMPARE_MEMBASE_IMM:
 			amd64_alu_membase_imm_size (code, X86_CMP, ins->inst_basereg, ins->inst_offset, ins->inst_imm, 4);
 			break;
Index: mono/mini/mini-ops.h
===================================================================
--- mono/mini/mini-ops.h	(revision 17)
+++ mono/mini/mini-ops.h	(working copy)
@@ -578,6 +578,7 @@
 MINI_OP(OP_AMD64_OUTARG_XMMREG_R4,       "amd64_outarg_xmmreg_r4")
 MINI_OP(OP_AMD64_OUTARG_XMMREG_R8,       "amd64_outarg_xmmreg_r8")
 MINI_OP(OP_AMD64_ICOMPARE_MEMBASE_REG,   "amd64_icompare_membase_reg")
+MINI_OP(OP_AMD64_COMPARE_MEMBASE_REG_I8, "amd64_compare_membase_reg_i8")
 MINI_OP(OP_AMD64_ICOMPARE_MEMBASE_IMM,   "amd64_icompare_membase_imm")
 MINI_OP(OP_AMD64_ICOMPARE_REG_MEMBASE,   "amd64_icompare_reg_membase")
 MINI_OP(OP_AMD64_OUTARG_ALIGN_STACK,     "amd64_outarg_align_stack")
Index: mono/mini/cpu-amd64.md
===================================================================
--- mono/mini/cpu-amd64.md	(revision 17)
+++ mono/mini/cpu-amd64.md	(working copy)
@@ -311,6 +311,7 @@
 tls_get: dest:i len:16
 amd64_test_null: src1:i len:5
 amd64_icompare_membase_reg: src1:b src2:i len:8
+amd64_compare_membase_reg_i8: src1:b src2:i len:8
 amd64_icompare_membase_imm: src1:b len:13
 amd64_icompare_reg_membase: src1:i src2:b len:8
 amd64_set_xmmreg_r4: dest:f src1:f len:14 clob:m
Index: mono/mini/version.h
===================================================================
--- mono/mini/version.h	(revision 17)
+++ mono/mini/version.h	(working copy)
@@ -1 +1 @@
-#define FULL_VERSION "tarball"
+#define FULL_VERSION "URL: file:///fs/svn/Mono/branches/ISC_BigBlob126/mono/mini r17"
Index: mono/mini/jit-icalls.c
===================================================================
--- mono/mini/jit-icalls.c	(revision 17)
+++ mono/mini/jit-icalls.c	(working copy)
@@ -610,11 +610,12 @@
 {
 	MonoDomain *domain = mono_domain_get ();
 	va_list ap;
-	guint32 *lengths;
-	guint32 *lower_bounds;
+	gsize *lengths;
+	gsize *lower_bounds;
 	int pcount;
 	int rank;
-	int i, d;
+	int i;
+	gssize d;
 
 	MONO_ARCH_SAVE_REGS;
 
@@ -623,15 +624,15 @@
 
 	va_start (ap, cm);
 	
-	lengths = alloca (sizeof (guint32) * pcount);
+	lengths = alloca (sizeof (gsize) * pcount);
 	for (i = 0; i < pcount; ++i)
 		lengths [i] = d = va_arg(ap, int);
 
 	if (rank == pcount) {
 		/* Only lengths provided. */
 		if (cm->klass->byval_arg.type == MONO_TYPE_ARRAY) {
-			lower_bounds = alloca (sizeof (guint32) * rank);
-			memset (lower_bounds, 0, sizeof (guint32) * rank);
+			lower_bounds = alloca (sizeof (gsize) * rank);
+			memset (lower_bounds, 0, sizeof (gsize) * rank);
 		} else {
 			lower_bounds = NULL;
 		}
Index: mono/mini/exceptions.cs
===================================================================
--- mono/mini/exceptions.cs	(revision 17)
+++ mono/mini/exceptions.cs	(working copy)
@@ -2279,22 +2279,51 @@
 		}
 	}
 
-	public static int test_0_array_size () {
+	public static int test_0_array_size32 () {
 		bool failed;
 
+		if (IntPtr.Size == 4) {
+			// This will only fail on 32 bit machines
+			try {
+				failed = true;
+				int[] mem1 = new int [Int32.MaxValue];
+			}
+			catch (OutOfMemoryException e) {
+				failed = false;
+			}
+			if (failed)
+				return 1;
+		}
+		// This will fail on 64 bit machines as well
 		try {
 			failed = true;
-			int[] mem1 = new int [Int32.MaxValue];
+			int[,] mem2 = new int [Int32.MaxValue, Int32.MaxValue];
 		}
 		catch (OutOfMemoryException e) {
 			failed = false;
 		}
 		if (failed)
+			return 2;
+
+		return 0;
+	}
+
+	public static int test_0_array_size64 () {
+		bool failed;
+
+		try {
+			failed = true;
+			int[] mem1 = new int [Int64.MaxValue];
+		}
+		catch (OutOfMemoryException e) {
+			failed = false;
+		}
+		if (failed)
 			return 1;
 
 		try {
 			failed = true;
-			int[,] mem2 = new int [Int32.MaxValue, Int32.MaxValue];
+			int[,] mem2 = new int [Int64.MaxValue, Int64.MaxValue];
 		}
 		catch (OutOfMemoryException e) {
 			failed = false;
@@ -2305,6 +2334,7 @@
 		return 0;
 	}
 
+
 	struct S {
 		int i, j, k, l, m, n;
 	}
Index: mcs/mcs/ecore.cs
===================================================================
--- mcs/mcs/ecore.cs	(revision 17)
+++ mcs/mcs/ecore.cs	(working copy)
@@ -5209,7 +5209,7 @@
 					if (!prepared)
 						EmitInstance (ec, false);
 					ec.ig.Emit (OpCodes.Ldlen);
-					ec.ig.Emit (OpCodes.Conv_I4);
+					ec.ig.Emit (OpCodes.Conv_Ovf_I4);
 					return;
 				}
 			}
Index: mcs/mcs/expression.cs
===================================================================
--- mcs/mcs/expression.cs	(revision 17)
+++ mcs/mcs/expression.cs	(working copy)
@@ -7455,7 +7455,7 @@
 			ea.Expr.Emit (ec);
 			if (rank == 1) {
 				ig.Emit (OpCodes.Ldlen);
-				ig.Emit (OpCodes.Conv_I4);
+				ig.Emit (OpCodes.Conv_Ovf_I4);
 			} else {
 				IntLiteral.EmitInt (ig, dim);
 				ig.Emit (OpCodes.Callvirt, TypeManager.int_getlength_int);
Index: mcs/class/corlib/System/Array.cs
===================================================================
--- mcs/class/corlib/System/Array.cs	(revision 17)
+++ mcs/class/corlib/System/Array.cs	(working copy)
@@ -272,7 +272,14 @@
 #if NET_2_0
 			[ReliabilityContractAttribute (Consistency.WillNotCorruptState, Cer.Success)]
 #endif
-			get { return Length; }
+			get {
+				long length = this.GetLongLength (0);
+
+				for (int i = 1; i < this.Rank; i++) {
+					length *= this.GetLongLength (i); 
+				}
+				return length;
+			}
 		}
 #endif
 
@@ -371,10 +378,8 @@
 
 #if NET_1_1
 		[ComVisible (false)]
-		public long GetLongLength (int dimension)
-		{
-			return GetLength (dimension);
-		}
+		[MethodImplAttribute (MethodImplOptions.InternalCall)]
+		public extern long GetLongLength (int dimension);
 #endif
 
 #if NET_2_0
@@ -389,6 +394,12 @@
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
 		public extern void SetValue (object value, params int[] indices);
 
+		[MethodImplAttribute (MethodImplOptions.InternalCall)]
+		public extern object GetValue (params long[] indices);
+
+		[MethodImplAttribute (MethodImplOptions.InternalCall)]
+		public extern void SetValue (object value, params long[] indices);
+
 		// CAUTION! No bounds checking!
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
 		internal extern object GetValueImpl (int pos);
@@ -397,12 +408,23 @@
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
 		internal extern void SetValueImpl (object value, int pos);
 
+		// CAUTION! No bounds checking!
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
+		internal extern object GetValueImpl (long pos);
+
+		// CAUTION! No bounds checking!
+		[MethodImplAttribute (MethodImplOptions.InternalCall)]
+		internal extern void SetValueImpl (object value, long pos);
+
+		[MethodImplAttribute (MethodImplOptions.InternalCall)]
 		internal extern static bool FastCopy (Array source, int source_idx, Array dest, int dest_idx, int length);
 
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
 		internal extern static Array CreateInstanceImpl (Type elementType, int[] lengths, int[] bounds);
 
+		[MethodImplAttribute (MethodImplOptions.InternalCall)]
+		internal extern static Array CreateInstanceImpl64 (Type elementType, long[] lengths, long[] bounds);
+
 		// Properties
 		int ICollection.Count {
 			get {
@@ -494,92 +516,64 @@
 		[ComVisible (false)]
 		public object GetValue (long index)
 		{
-			if (index < 0 || index > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
+			if (Rank != 1)
+				throw new ArgumentException (Locale.GetText ("Array was not a one-dimensional array."));
+			if (index < GetLowerBound (0) || index > GetUpperBound (0))
+				throw new IndexOutOfRangeException (Locale.GetText (
+					"Index has to be between upper and lower bound of the array."));
 
-			return GetValue ((int) index);
+			return GetValueImpl (index - GetLowerBound (0));
 		}
 
 		[ComVisible (false)]
 		public object GetValue (long index1, long index2)
 		{
-			if (index1 < 0 || index1 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index1", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			if (index2 < 0 || index2 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index2", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			return GetValue ((int) index1, (int) index2);
+			long[] ind = {index1, index2};
+			return GetValue (ind);
 		}
 
 		[ComVisible (false)]
 		public object GetValue (long index1, long index2, long index3)
 		{
-			if (index1 < 0 || index1 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index1", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			if (index2 < 0 || index2 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index2", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			if (index3 < 0 || index3 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index3", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			return GetValue ((int) index1, (int) index2, (int) index3);
+			long[] ind = {index1, index2, index3};
+			return GetValue (ind);
 		}
 
 		[ComVisible (false)]
 		public void SetValue (object value, long index)
 		{
-			if (index < 0 || index > Int32.MaxValue)
+			if (index < 0)
 				throw new ArgumentOutOfRangeException ("index", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
+					"Value must be >= 0 ."));
+			if (Rank != 1)
+				throw new ArgumentException (Locale.GetText ("Array was not a one-dimensional array."));
+			if (index < GetLowerBound (0) || index > GetUpperBound (0))
+				throw new IndexOutOfRangeException (Locale.GetText (
+					"Index has to be >= lower bound and <= upper bound of the array."));
 
-			SetValue (value, (int) index);
+			SetValueImpl (value, index - GetLowerBound (0));
 		}
 
 		[ComVisible (false)]
 		public void SetValue (object value, long index1, long index2)
 		{
-			if (index1 < 0 || index1 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index1", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			if (index2 < 0 || index2 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index2", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			int[] ind = {(int) index1, (int) index2};
+			long[] ind = {index1, index2};
 			SetValue (value, ind);
 		}
 
 		[ComVisible (false)]
 		public void SetValue (object value, long index1, long index2, long index3)
 		{
-			if (index1 < 0 || index1 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index1", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			if (index2 < 0 || index2 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index2", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			if (index3 < 0 || index3 > Int32.MaxValue)
-				throw new ArgumentOutOfRangeException ("index3", Locale.GetText (
-					"Value must be >= 0 and <= Int32.MaxValue."));
-
-			int[] ind = {(int) index1, (int) index2, (int) index3};
+			long[] ind = {index1, index2, index3};
 			SetValue (value, ind);
 		}
 #endif
 
 		public void SetValue (object value, int index)
 		{
+			if (index < 0)
+				throw new ArgumentOutOfRangeException ("index", Locale.GetText (
+					"Value must be >= 0 ."));
 			if (Rank != 1)
 				throw new ArgumentException (Locale.GetText ("Array was not a one-dimensional array."));
 			if (index < GetLowerBound (0) || index > GetUpperBound (0))
@@ -697,27 +691,19 @@
 			if (lengths == null)
 				throw new ArgumentNullException ("lengths");
 #endif
-			return CreateInstance (elementType, GetIntArray (lengths));
-		}
+			if (elementType == null)
+				throw new ArgumentNullException ("elementType");
 
-		[ComVisible (false)]
-		public object GetValue (params long [] indices)
-		{
-#if NET_2_0
-			if (indices == null)
-				throw new ArgumentNullException ("indices");
-#endif
-			return GetValue (GetIntArray (indices));
-		}
+			if (lengths.Length > 255)
+				throw new TypeLoadException ();
 
-		[ComVisible (false)]
-		public void SetValue (object value, params long [] indices)
-		{
-#if NET_2_0
-			if (indices == null)
-				throw new ArgumentNullException ("indices");
-#endif
-			SetValue (value, GetIntArray (indices));
+			long[] bounds = null;
+
+			elementType = elementType.UnderlyingSystemType;
+			if (!elementType.IsSystemType)
+				throw new ArgumentException ("Type must be a type provided by the runtime.", "elementType");
+			
+			return CreateInstanceImpl64 (elementType, lengths, bounds);
 		}
 #endif
 
