Index: mono/mono/metadata/ChangeLog
===================================================================
--- mono/mono/metadata/ChangeLog	(revision 80476)
+++ mono/mono/metadata/ChangeLog	(working copy)
@@ -1,3 +1,13 @@
+2007-06-22  Jonathan Chambers  <joncham@gmail.com>
+
+       * icall-def.h: Update System.__ComObject icalls
+       * marshal.c: Avoid managed transition (and object creation)
+       when looking up COM interface in RCW.
+       * marshal.h: Ditto.
+       
+       
+       Code is contributed under MIT/X11 license.
+
 2007-06-21  Raja R Harinath  <rharinath@novell.com>
 
 	* reflection.c (method_encode_methodspec): Add a tripwire.
Index: mono/mono/metadata/icall-def.h
===================================================================
--- mono/mono/metadata/icall-def.h	(revision 80476)
+++ mono/mono/metadata/icall-def.h	(working copy)
@@ -851,8 +851,7 @@
 ICALL(WEBIC_2, "GetMachineInstallDirectory", ves_icall_System_Web_Util_ICalls_get_machine_install_dir)
 
 ICALL_TYPE(COMOBJ, "System.__ComObject", COMOBJ_1)
-ICALL(COMOBJ_1, "AddInterface", ves_icall_System_ComObject_AddInterface)
-ICALL(COMOBJ_2, "CreateRCW", ves_icall_System_ComObject_CreateRCW)
-ICALL(COMOBJ_4, "FindInterface", ves_icall_System_ComObject_FindInterface)
+ICALL(COMOBJ_1, "CreateRCW", ves_icall_System_ComObject_CreateRCW)
+ICALL(COMOBJ_2, "GetInterfaceInternal", ves_icall_System_ComObject_GetInterfaceInternal)
 ICALL(COMOBJ_3, "ReleaseInterfaces", ves_icall_System_ComObject_ReleaseInterfaces)
 
Index: mono/mono/metadata/marshal.c
===================================================================
--- mono/mono/metadata/marshal.c	(revision 80476)
+++ mono/mono/metadata/marshal.c	(working copy)
@@ -407,16 +407,16 @@
 }
 
 /**
- * cominterop_get_com_slot_for_method:
- * @method: a method
+ * cominterop_get_method_interface:
+ * @method: method being called
  *
- * Returns: the method's slot in the COM interface vtable
+ * Returns: the MonoClass* representing the interface on which
+ * the method is defined.
  */
-static int
-cominterop_get_com_slot_for_method (MonoMethod* method)
+static MonoClass*
+cominterop_get_method_interface (MonoMethod* method)
 {
-	guint32 slot = method->slot;
- 	MonoClass *ic = method->klass;
+	MonoClass *ic = method->klass;
 
 	/* if method is on a class, we need to look up interface method exists on */
 	if (!MONO_CLASS_IS_INTERFACE(method->klass)) {
@@ -427,10 +427,8 @@
 				int offset;
 				ic = g_ptr_array_index (ifaces, i);
 				offset = mono_class_interface_offset (method->klass, ic);
-				if (method->slot >= offset && method->slot < offset + ic->method.count) {
-					slot -= offset;
+				if (method->slot >= offset && method->slot < offset + ic->method.count)
 					break;
-				}
 				ic = NULL;
 			}
 			g_ptr_array_free (ifaces, TRUE);
@@ -440,48 +438,115 @@
 	g_assert (ic);
 	g_assert (MONO_CLASS_IS_INTERFACE (ic));
 
-	return slot + cominterop_get_com_slot_begin (ic);
+	return ic;
 }
 
 /**
- * cominterop_get_method_interface:
- * @method: method being called
+ * cominterop_get_com_slot_for_method:
+ * @method: a method
  *
- * Returns: the Type on which the method is defined on
+ * Returns: the method's slot in the COM interface vtable
  */
-static MonoReflectionType*
-cominterop_get_method_interface (MonoMethod* method)
+static int
+cominterop_get_com_slot_for_method (MonoMethod* method)
 {
-	MonoType* t = NULL;
-	MonoReflectionType* rt = NULL;
-	MonoClass *ic = method->klass;
+	guint32 slot = method->slot;
+ 	MonoClass *ic = method->klass;
 
 	/* if method is on a class, we need to look up interface method exists on */
-	if (!MONO_CLASS_IS_INTERFACE(method->klass)) {
-		GPtrArray *ifaces = mono_class_get_implemented_interfaces (method->klass);
-		if (ifaces) {
-			int i;
-			for (i = 0; i < ifaces->len; ++i) {
-				int offset;
-				ic = g_ptr_array_index (ifaces, i);
-				offset = mono_class_interface_offset (method->klass, ic);
-				if (method->slot >= offset && method->slot < offset + ic->method.count)
-					break;
-				ic = NULL;
-			}
-			g_ptr_array_free (ifaces, TRUE);
-		}
+	if (!MONO_CLASS_IS_INTERFACE(ic)) {
+		int offset = 0;
+		ic = cominterop_get_method_interface (method);
+		offset = mono_class_interface_offset (method->klass, ic);
+		g_assert(offset >= 0);
+		slot -= offset;
 	}
 
 	g_assert (ic);
 	g_assert (MONO_CLASS_IS_INTERFACE (ic));
 
-	t = mono_class_get_type (ic);
-	rt = mono_type_get_object (mono_domain_get(), t);
+	return slot + cominterop_get_com_slot_begin (ic);
+}
 
-	return rt;
+
+static void
+cominterop_mono_string_to_guid (const MonoString* string, guint8 *guid);
+
+static gboolean
+cominterop_class_guid (MonoClass* klass, guint8* guid)
+{
+	static MonoClass *GuidAttribute = NULL;
+	MonoCustomAttrInfo *cinfo;
+
+	/* Handle the GuidAttribute */
+	if (!GuidAttribute)
+		GuidAttribute = mono_class_from_name (mono_defaults.corlib, "System.Runtime.InteropServices", "GuidAttribute");
+
+	cinfo = mono_custom_attrs_from_class (klass);	
+	if (cinfo) {
+		MonoReflectionGuidAttribute *attr = (MonoReflectionGuidAttribute*)mono_custom_attrs_get_attr (cinfo, GuidAttribute);
+
+		if (!attr)
+			return FALSE;
+		if (!cinfo->cached)
+			mono_custom_attrs_free (cinfo);
+
+		cominterop_mono_string_to_guid (attr->guid, guid);
+		return TRUE;
+	}
+	return FALSE;
 }
 
+/**
+ * cominterop_get_interface:
+ * @obj: managed wrapper object containing COM object
+ * @ic: interface type to retrieve for COM object
+ *
+ * Returns: the COM interface requested
+ */
+static gpointer
+cominterop_get_interface (MonoComObject* obj, MonoClass* ic, gboolean throw_exception)
+{
+	gpointer itf = NULL;
+
+	g_assert (ic);
+	g_assert (MONO_CLASS_IS_INTERFACE (ic));
+
+	mono_cominterop_lock ();
+	if (obj->itf_hash)
+		itf = g_hash_table_lookup (obj->itf_hash, GUINT_TO_POINTER ((guint)ic->interface_id));
+	mono_cominterop_unlock ();
+
+	if (!itf) {
+		guint8 iid [16];
+		int found = cominterop_class_guid (ic, iid);
+		int hr;
+		g_assert(found);
+		hr = ves_icall_System_Runtime_InteropServices_Marshal_QueryInterfaceInternal (obj->iunknown, iid, &itf);
+		if (hr < 0 && throw_exception) {
+			static MonoMethod* throw_exception_for_hr = NULL;
+			MonoException* ex;
+			void* params[1] = {&hr};
+			if (!throw_exception_for_hr)
+				throw_exception_for_hr = mono_class_get_method_from_name (mono_defaults.marshal_class, "GetExceptionForHR", 1);
+			ex = (MonoException*)mono_runtime_invoke (throw_exception_for_hr, NULL, params, NULL);
+			mono_raise_exception (ex);
+		}
+
+		if (hr >= 0 && itf) {
+			mono_cominterop_lock ();
+			if (!obj->itf_hash)
+				obj->itf_hash = g_hash_table_new (mono_aligned_addr_hash, NULL);
+			g_hash_table_insert (obj->itf_hash, GUINT_TO_POINTER ((guint)ic->interface_id), itf);
+			mono_cominterop_unlock ();
+		}
+
+	}
+	g_assert (itf);
+
+	return itf;
+}
+
 static int
 cominterop_get_hresult_for_exception (MonoException* exc)
 {
@@ -547,12 +612,13 @@
 		register_icall (mono_upgrade_remote_class_wrapper, "mono_upgrade_remote_class_wrapper", "void object object", FALSE);
 		register_icall (type_from_handle, "type_from_handle", "object ptr", FALSE);
 		register_icall (mono_gc_wbarrier_generic_store, "wb_generic", "void ptr object", FALSE);
-		register_icall (cominterop_get_method_interface, "cominterop_get_method_interface", "object ptr", FALSE);
+		register_icall (cominterop_get_method_interface, "cominterop_get_method_interface", "ptr ptr", FALSE);
 		register_icall (cominterop_get_function_pointer, "cominterop_get_function_pointer", "ptr ptr int32", FALSE);
 		register_icall (cominterop_object_is_rcw, "cominterop_object_is_rcw", "int32 object", FALSE);
 		register_icall (cominterop_get_ccw, "cominterop_get_ccw", "ptr object ptr", FALSE);
 		register_icall (cominterop_get_ccw_object, "cominterop_get_ccw_object", "object ptr int32", FALSE);
 		register_icall (cominterop_get_hresult_for_exception, "cominterop_get_hresult_for_exception", "int32 object", FALSE);
+		register_icall (cominterop_get_interface, "cominterop_get_interface", "ptr object ptr int32", FALSE);
 	}
 }
 
@@ -2372,13 +2438,10 @@
 		mono_mb_emit_byte (mb, CEE_LDIND_REF);
 
 		if (conv == MONO_MARSHAL_CONV_OBJECT_INTERFACE) {
-			static MonoMethod* GetInterface = NULL;
-			
-			if (!GetInterface)
-				GetInterface = mono_class_get_method_from_name (mono_defaults.com_object_class, "GetInterface", 1);
-			mono_mb_emit_ptr (mb, type);
-			mono_mb_emit_icall (mb, type_from_handle);
-			mono_mb_emit_managed_call (mb, GetInterface, NULL);
+			mono_mb_emit_ptr (mb, mono_type_get_class (type));
+			mono_mb_emit_icon (mb, TRUE);
+			mono_mb_emit_icall (mb, cominterop_get_interface);
+
 		}
 		else if (conv == MONO_MARSHAL_CONV_OBJECT_IUNKNOWN) {
 			static MonoProperty* iunknown = NULL;
@@ -3483,14 +3546,11 @@
 		}
 		else {
 			static MonoMethod * ThrowExceptionForHR = NULL;
-			static MonoMethod * GetInterface = NULL;
 			MonoMethod *adjusted_method;
 			int retval = 0;
 			int ptr_this;
 			int i;
 			gboolean preserve_sig = method->iflags & METHOD_IMPL_ATTRIBUTE_PRESERVE_SIG;
-			if (!GetInterface)
-				GetInterface = mono_class_get_method_from_name (mono_defaults.com_object_class, "GetInterface", 1);
 
 			// add local variables
 			ptr_this = mono_mb_add_local (mb, &mono_defaults.int_class->byval_arg);
@@ -3502,7 +3562,8 @@
 			mono_mb_emit_ldarg (mb, 0);
 			mono_mb_emit_ptr (mb, method);
 			mono_mb_emit_icall (mb, cominterop_get_method_interface);
-			mono_mb_emit_managed_call (mb, GetInterface, NULL);
+			mono_mb_emit_icon (mb, TRUE);
+			mono_mb_emit_icall (mb, cominterop_get_interface);
 			mono_mb_emit_stloc (mb, ptr_this);
 
 			// arg 1 is unmanaged this pointer
@@ -10661,46 +10722,12 @@
 }
 
 gpointer
-ves_icall_System_ComObject_FindInterface (MonoComObject* obj, MonoReflectionType* type)
+ves_icall_System_ComObject_GetInterfaceInternal (MonoComObject* obj, MonoReflectionType* type, MonoBoolean throw_exception)
 {
-	MonoClass* klass;
-	gpointer itf = NULL;
-	g_assert(obj);
-	g_assert(type);
-	if (!obj->itf_hash)
-		return NULL;
-
-	klass = mono_object_class (obj);
-	klass = mono_class_from_mono_type (type->type);
-
-	mono_cominterop_lock ();
-	itf = g_hash_table_lookup (obj->itf_hash, GUINT_TO_POINTER ((guint)klass->interface_id));
-	mono_cominterop_unlock ();
-
-	return itf;
+	return cominterop_get_interface (obj, mono_type_get_class (type->type), (gboolean)throw_exception);
 }
 
 void
-ves_icall_System_ComObject_AddInterface (MonoComObject* obj, MonoReflectionType* type, gpointer pItf)
-{
-	MonoClass* klass;
-	g_assert(obj);
-	g_assert(type);
-	if (!obj->itf_hash) {
-		mono_cominterop_lock ();
-		obj->itf_hash = g_hash_table_new (mono_aligned_addr_hash, NULL);
-		mono_cominterop_unlock ();
-	}
-
-	klass = mono_object_class (obj);
-	klass = mono_class_from_mono_type (type->type);
-
-	mono_cominterop_lock ();
-	g_hash_table_insert (obj->itf_hash, GUINT_TO_POINTER ((guint)klass->interface_id), pItf);
-	mono_cominterop_unlock ();
-}
-
-void
 ves_icall_Mono_Interop_ComInteropProxy_AddProxy (gpointer pUnk, MonoComInteropProxy* proxy)
 {
 	guint32 gchandle = 0;
@@ -11720,48 +11747,14 @@
 
 	for (i = 0; i < sizeof(indexes); i++)
 		guid [i] = g_unichar_xdigit_value (chars [indexes [i]]) + (g_unichar_xdigit_value (chars [indexes [i] - 1]) << 4);
-
-	//guid [0] = g_unichar_xdigit_value (chars [7]) + (g_unichar_xdigit_value (chars [6]) << 4);
-	//guid [1] = g_unichar_xdigit_value (chars [5]) + (g_unichar_xdigit_value (chars [4]) << 4);
-	//guid [2] = g_unichar_xdigit_value (chars [3]) + (g_unichar_xdigit_value (chars [2]) << 4);
-	//guid [3] = g_unichar_xdigit_value (chars [1]) + (g_unichar_xdigit_value (chars [0]) << 4);
-	//guid [4] = g_unichar_xdigit_value (chars [12]) + (g_unichar_xdigit_value (chars [11]) << 4);
-	//guid [5] = g_unichar_xdigit_value (chars [10]) + (g_unichar_xdigit_value (chars [9]) << 4);
-	//guid [6] = g_unichar_xdigit_value (chars [17]) + (g_unichar_xdigit_value (chars [16]) << 4);
-	//guid [7] = g_unichar_xdigit_value (chars [15]) + (g_unichar_xdigit_value (chars [14]) << 4);
-	//guid [8] = g_unichar_xdigit_value (chars [20]) + (g_unichar_xdigit_value (chars [19]) << 4);
-	//guid [9] = g_unichar_xdigit_value (chars [22]) + (g_unichar_xdigit_value (chars [21]) << 4);
-	//guid [10] = g_unichar_xdigit_value (chars [25]) + (g_unichar_xdigit_value (chars [24]) << 4);
-	//guid [11] = g_unichar_xdigit_value (chars [27]) + (g_unichar_xdigit_value (chars [26]) << 4);
-	//guid [12] = g_unichar_xdigit_value (chars [29]) + (g_unichar_xdigit_value (chars [28]) << 4);
-	//guid [13] = g_unichar_xdigit_value (chars [31]) + (g_unichar_xdigit_value (chars [30]) << 4);
-	//guid [14] = g_unichar_xdigit_value (chars [33]) + (g_unichar_xdigit_value (chars [32]) << 4);
-	//guid [15] = g_unichar_xdigit_value (chars [35]) + (g_unichar_xdigit_value (chars [34]) << 4);
 }
 
 static gboolean
 cominterop_class_guid_equal (guint8* guid, MonoClass* klass)
 {
-	static MonoClass *GuidAttribute = NULL;
-	MonoCustomAttrInfo *cinfo;
-
-	/* Handle the GuidAttribute */
-	if (!GuidAttribute)
-		GuidAttribute = mono_class_from_name (mono_defaults.corlib, "System.Runtime.InteropServices", "GuidAttribute");
-
-	cinfo = mono_custom_attrs_from_class (klass);	
-	if (cinfo) {
-		guint8 klass_guid [16];
-		MonoReflectionGuidAttribute *attr = (MonoReflectionGuidAttribute*)mono_custom_attrs_get_attr (cinfo, GuidAttribute);
-
-		if (!attr)
-			return FALSE;
-		if (!cinfo->cached)
-			mono_custom_attrs_free (cinfo);
-
-		cominterop_mono_string_to_guid (attr->guid, klass_guid);
+	guint8 klass_guid [16];
+	if (cominterop_class_guid (klass, klass_guid))
 		return !memcmp (guid, klass_guid, sizeof (klass_guid));
-	}
 	return FALSE;
 }
 
Index: mono/mono/metadata/marshal.h
===================================================================
--- mono/mono/metadata/marshal.h	(revision 80476)
+++ mono/mono/metadata/marshal.h	(working copy)
@@ -421,12 +421,9 @@
 ves_icall_System_ComObject_ReleaseInterfaces(MonoComObject* obj) MONO_INTERNAL;
 
 gpointer
-ves_icall_System_ComObject_FindInterface (MonoComObject* obj, MonoReflectionType* type) MONO_INTERNAL;
+ves_icall_System_ComObject_GetInterfaceInternal (MonoComObject* obj, MonoReflectionType* type, MonoBoolean throw_exception) MONO_INTERNAL;
 
 void
-ves_icall_System_ComObject_AddInterface (MonoComObject* obj, MonoReflectionType* type, gpointer pItf) MONO_INTERNAL;
-
-void
 ves_icall_Mono_Interop_ComInteropProxy_AddProxy (gpointer pUnk, MonoComInteropProxy* proxy) MONO_INTERNAL;
 
 MonoComInteropProxy*
Index: mcs/class/corlib/System/ChangeLog
===================================================================
--- mcs/class/corlib/System/ChangeLog	(revision 80476)
+++ mcs/class/corlib/System/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2007-06-22  Jonathan Chambers  <joncham@gmail.com>
+
+	* __ComObject.cs: Move interface lookup to unmanaged.
+
 2007-06-05  David Ferguson <davecferguson@gmail.com>
 
 	* DateTime.cs: Changed DateTime.Parse() to throw a FormatException
Index: mcs/class/corlib/System/__ComObject.cs
===================================================================
--- mcs/class/corlib/System/__ComObject.cs	(revision 80476)
+++ mcs/class/corlib/System/__ComObject.cs	(working copy)
@@ -61,12 +61,6 @@
 		internal static extern __ComObject CreateRCW (Type t);
 
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		private static extern void AddInterface (__ComObject co, Type t, IntPtr pItf);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		private static extern IntPtr FindInterface (__ComObject co, Type t);
-
-		[MethodImplAttribute (MethodImplOptions.InternalCall)]
 		private extern void ReleaseInterfaces ();
 
 		~__ComObject ()
@@ -109,21 +103,12 @@
 			throw new COMException ("Could not find base COM type for type " + t.ToString());
 		}
 
+		[MethodImplAttribute (MethodImplOptions.InternalCall)]
+		internal extern IntPtr GetInterfaceInternal (Type t, bool throwException);
+
 		internal IntPtr GetInterface (Type t, bool throwException) {
 			CheckIUnknown ();
-			IntPtr pItf = FindInterface (this, t);
-			if (pItf != IntPtr.Zero) {
-				return pItf;
-			}
-
-			Guid iid = t.GUID;
-			IntPtr ppv;
-			int hr = Marshal.QueryInterface (iunknown, ref iid, out ppv);
-			if (throwException)
-				Marshal.ThrowExceptionForHR (hr);
-			if (hr > 0 && ppv != IntPtr.Zero)
-				AddInterface (this, t, ppv);
-			return ppv;
+			return GetInterfaceInternal (t, throwException);
 		}
 
 		internal IntPtr GetInterface(Type t)
Index: mcs/class/corlib/System.Runtime.InteropServices/ChangeLog
===================================================================
--- mcs/class/corlib/System.Runtime.InteropServices/ChangeLog	(revision 80476)
+++ mcs/class/corlib/System.Runtime.InteropServices/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2007-06-22  Jonathan Chambers  <joncham@gmail.com>
+
+	* __ComObject.cs (ThrowExceptionForHR): Implement/consolidate.
+	* __ComObject.cs (GetExceptionForHR): Implement/consolidate.
+
 2007-05-11  Jonathan Chambers  <joncham@gmail.com>
 
 	* Marshal.cs (SecureStringToBSTR): BSTR header is size in bytes,
Index: mcs/class/corlib/System.Runtime.InteropServices/Marshal.cs
===================================================================
--- mcs/class/corlib/System.Runtime.InteropServices/Marshal.cs	(revision 80476)
+++ mcs/class/corlib/System.Runtime.InteropServices/Marshal.cs	(working copy)
@@ -1008,16 +1008,16 @@
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]
 		public extern static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);
 
-		public static void ThrowExceptionForHR (int errorCode)
-		{
-			if (errorCode < 0)
-				throw new COMException ("", errorCode);
+		public static void ThrowExceptionForHR (int errorCode) {
+			Exception ex = GetExceptionForHR (errorCode);
+			if (ex != null)
+				throw ex;
 		}
 
-		[MonoTODO]
-		public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo)
-		{
-			throw new NotImplementedException ();
+		public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo) {
+			Exception ex = GetExceptionForHR (errorCode, errorInfo);
+			if (ex != null)
+				throw ex;
 		}
 
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]
@@ -1109,22 +1109,30 @@
 		}
 
 #if NET_2_0
-		public static int FinalReleaseComObject (object o)
-		{
-			while (ReleaseComObject (o) != 0);
-			return 0;
+		public
+#else
+		internal
+#endif
+		static Exception GetExceptionForHR (int errorCode) {
+			return GetExceptionForHR (errorCode, IntPtr.Zero);
 		}
 
-		[MonoTODO]
-		public static Exception GetExceptionForHR (int errorCode)
-		{
-			throw new NotImplementedException ();
+#if NET_2_0
+		public
+#else
+		internal
+#endif
+		static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo) {
+			if (errorCode < 0)
+				return new COMException ("", errorCode);
+			return null;
 		}
 
-		[MonoTODO]
-		public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo)
+#if NET_2_0
+		public static int FinalReleaseComObject (object o)
 		{
-			throw new NotImplementedException ();
+			while (ReleaseComObject (o) != 0);
+			return 0;
 		}
 
 		[MethodImplAttribute(MethodImplOptions.InternalCall)]