Index: Assembly.cs
===================================================================
--- Assembly.cs	(revisión: 40470)
+++ Assembly.cs	(copia de trabajo)
@@ -361,11 +361,16 @@
 		}
 		
 		[MethodImplAttribute (MethodImplOptions.InternalCall)]
-		public extern static Assembly LoadFrom (String assemblyFile);
+		private extern static Assembly LoadFrom (String assemblyFile, bool refonly);
 
+		public static Assembly LoadFrom (String assemblyFile)
+		{
+			return LoadFrom (assemblyFile, false);
+		}
+
 		public static Assembly LoadFrom (String assemblyFile, Evidence securityEvidence)
 		{
-			Assembly a = LoadFrom (assemblyFile);
+			Assembly a = LoadFrom (assemblyFile, false);
 			if ((a != null) && (securityEvidence != null)) {
 				// merge evidence (i.e. replace defaults with provided evidences)
 				a.Evidence.Merge (securityEvidence);
@@ -437,20 +442,25 @@
 		}
 
 #if NET_2_0
-		[MonoTODO]
 		public static Assembly ReflectionOnlyLoad (byte[] rawAssembly)
 		{
-			throw new NotImplementedException ();
+			if (rawAssembly == null)
+				throw new ArgumentNullException ("rawAssembly");
+			
+			return AppDomain.CurrentDomain.LoadAssemblyRaw (rawAssembly, null, null, true);
 		}
 
-		[MonoTODO]
-		public static Assembly ReflectionOnlyLoad (string assemblyString) {
-			throw new NotImplementedException ();
+		public static Assembly ReflectionOnlyLoad (string assemblyName) 
+		{
+			if (assemblyName == null)
+				throw new ArgumentNullException ("assemblyName");
+			
+			return AppDomain.CurrentDomain.LoadAssembly (assemblyName, null, true);
 		}
 
-		[MonoTODO]
-		public static Assembly ReflectionOnlyLoadFrom (string assemblyFile) {
-			throw new NotImplementedException ();
+		public static Assembly ReflectionOnlyLoadFrom (string assemblyFile) 
+		{
+			return LoadFrom (assemblyFile, true);
 		}
 #endif
 
@@ -525,7 +535,11 @@
 			if (t == null)
 				return null;
 
-			return Activator.CreateInstance (t);
+			try {
+				return Activator.CreateInstance (t);
+			} catch (InvalidOperationException) {
+				throw new ArgumentException ("It is illegal to invoke a method on a Type loaded via ReflectionOnly methods.");
+			}
 		}
 
 		public Object CreateInstance (String typeName, Boolean ignoreCase,
@@ -537,7 +551,11 @@
 			if (t == null)
 				return null;
 
-			return Activator.CreateInstance (t, bindingAttr, binder, args, culture, activationAttributes);
+			try {
+				return Activator.CreateInstance (t, bindingAttr, binder, args, culture, activationAttributes);
+			} catch (InvalidOperationException) {
+				throw new ArgumentException ("It is illegal to invoke a method on a Type loaded via ReflectionOnly methods.");
+			}
 		}
 
 		public Module[] GetLoadedModules ()
@@ -705,10 +723,10 @@
 			}
 		}
 
-		[MonoTODO ("see ReflectionOnlyLoad")]
 		[ComVisible (false)]
-		public virtual bool ReflectionOnly {
-			get { return false; }
+		public virtual extern bool ReflectionOnly {
+			[MethodImplAttribute (MethodImplOptions.InternalCall)]
+			get;
 		}
 #endif
 
Index: MonoMethod.cs
===================================================================
--- MonoMethod.cs	(revisión: 40470)
+++ MonoMethod.cs	(copia de trabajo)
@@ -118,6 +118,8 @@
 				throw new ArgumentException ("parameters");
 			try {
 				return InternalInvoke (obj, parameters);
+			} catch (InvalidOperationException) {
+				throw;
 			} catch (TargetException) {
 				throw;
 			} catch (Exception e) {
@@ -316,6 +318,8 @@
 				throw new ArgumentException ("parameters");
 			try {
 				return InternalInvoke (obj, parameters);
+			} catch (InvalidOperationException) {
+				throw;
 			} catch (TargetException) {
 				throw;
 			} catch (Exception e) {
