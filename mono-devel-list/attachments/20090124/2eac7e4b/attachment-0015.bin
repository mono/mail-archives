Index: mono/mini/mini-ppc.c
===================================================================
--- mono.orig/mini/mini-ppc.c	2009-01-24 17:12:48.000000000 +0100
+++ mono/mini/mini-ppc.c	2009-01-24 17:28:42.000000000 +0100
@@ -92,9 +92,36 @@
 		if ((dreg) != ppc_r3) ppc_mr ((code), ppc_r3, ppc_r11);	\
 	} while (0);
 
+#ifdef __mono_ppc64__
+#define emit_nptl_tls(code,dreg,key) do { \
+		int off1 = key; \
+		int off2 = key >> 15; \
+		if ((off2 == 0) || (off2 == -1)) { \
+			ppc_load_reg ((code), (dreg), off1, ppc_r13);	\
+		} else { \
+			int off3 = (off2 + 1) > 1; \
+			ppc_addis ((code), ppc_r11, ppc_r13, off3); \
+			ppc_load_reg ((code), (dreg), off1, ppc_r11);	\
+		} \
+	} while (0);
+#else
+#define emit_nptl_tls(code,dreg,key) do { \
+		int off1 = key; \
+		int off2 = key >> 15; \
+		if ((off2 == 0) || (off2 == -1)) { \
+			ppc_load_reg ((code), (dreg), off1, ppc_r2);	\
+		} else { \
+			int off3 = (off2 + 1) > 1; \
+			ppc_addis ((code), ppc_r11, ppc_r2, off3); \
+			ppc_load_reg ((code), (dreg), off1, ppc_r11);	\
+		} \
+	} while (0);
+#endif
+
 #define emit_tls_access(code,dreg,key) do {	\
 		switch (tls_mode) {	\
 		case TLS_MODE_LTHREADS: emit_linuxthreads_tls(code,dreg,key); break;	\
+		case TLS_MODE_NPTL: emit_nptl_tls(code,dreg,key); break;	\
 		case TLS_MODE_DARWIN_G5: emit_darwing5_tls(code,dreg,key); break;	\
 		case TLS_MODE_DARWIN_G4: emit_darwing4_tls(code,dreg,key); break;	\
 		default: g_assert_not_reached ();	\
@@ -4941,7 +4968,7 @@
 	if (method->save_lmf) {
 		if (lmf_pthread_key != -1) {
 			emit_tls_access (code, ppc_r3, lmf_pthread_key);
-			if (G_STRUCT_OFFSET (MonoJitTlsData, lmf))
+			if (tls_mode != TLS_MODE_NPTL && G_STRUCT_OFFSET (MonoJitTlsData, lmf))
 				ppc_addi (code, ppc_r3, ppc_r3, G_STRUCT_OFFSET (MonoJitTlsData, lmf));
 		} else {
 			mono_add_patch_info (cfg, code - cfg->native_code, MONO_PATCH_INFO_INTERNAL_METHOD, 
@@ -5268,23 +5295,32 @@
 static void
 setup_tls_access (void)
 {
-#ifdef __mono_ppc64__
-	/* FIXME: implement */
-	tls_mode = TLS_MODE_FAILED;
-	return;
-#else
 	guint32 ptk;
+
+#if defined(__linux__) && defined(_CS_GNU_LIBPTHREAD_VERSION)
+	size_t conf_size = 0;
+	char confbuf[128];
+#else
+	/* FIXME for darwin */
 	guint32 *ins, *code;
 	guint32 cmplwi_1023, li_0x48, blr_ins;
+#endif
+
 	if (tls_mode == TLS_MODE_FAILED)
 		return;
-
 	if (g_getenv ("MONO_NO_TLS")) {
 		tls_mode = TLS_MODE_FAILED;
 		return;
 	}
 
-	if (tls_mode == TLS_MODE_DETECT) {
+ 	if (tls_mode == TLS_MODE_DETECT) {
+#if defined(__linux__) && defined(_CS_GNU_LIBPTHREAD_VERSION)
+		conf_size = confstr ( _CS_GNU_LIBPTHREAD_VERSION, confbuf, sizeof(confbuf));
+		if ((conf_size > 4) && (strncmp (confbuf, "NPTL", 4) == 0))
+			tls_mode = TLS_MODE_NPTL;
+		else
+			tls_mode = TLS_MODE_LTHREADS;
+#else
 		ins = (guint32*)pthread_getspecific;
 		/* uncond branch to the real method */
 		if ((*ins >> 26) == 18) {
@@ -5356,7 +5392,13 @@
 			tls_mode = TLS_MODE_FAILED;
 			return;
 		}
+#endif
 	}
+	if ((monodomain_key == -1) && (tls_mode == TLS_MODE_NPTL)) {
+		monodomain_key = mono_domain_get_tls_offset();
+ 	}
+	/* if not TLS_MODE_NPTL or local dynamic (as indicated by
+	   mono_domain_get_tls_offset returning -1) then use keyed access. */
 	if (monodomain_key == -1) {
 		ptk = mono_domain_get_tls_key ();
 		if (ptk < 1024) {
@@ -5366,6 +5408,12 @@
 			}
 		}
 	}
+
+	if ((lmf_pthread_key == -1) && (tls_mode == TLS_MODE_NPTL)) {
+		lmf_pthread_key = mono_get_lmf_addr_tls_offset();
+	}
+	/* if not TLS_MODE_NPTL or local dynamic (as indicated by
+	   mono_get_lmf_addr_tls_offset returning -1) then use keyed access. */
 	if (lmf_pthread_key == -1) {
 		ptk = mono_pthread_key_for_tls (mono_jit_tls_id);
 		if (ptk < 1024) {
@@ -5377,6 +5425,12 @@
 			lmf_pthread_key = ptk;
 		}
 	}
+
+	if ((monothread_key == -1) && (tls_mode == TLS_MODE_NPTL)) {
+		monothread_key = mono_thread_get_tls_offset();
+	}
+	/* if not TLS_MODE_NPTL or local dynamic (as indicated by
+	   mono_get_lmf_addr_tls_offset returning -1) then use keyed access. */
 	if (monothread_key == -1) {
 		ptk = mono_thread_get_tls_key ();
 		if (ptk < 1024) {
@@ -5389,7 +5443,6 @@
 			/*g_print ("thread not inited yet %d\n", ptk);*/
 		}
 	}
-#endif
 }
 
 void
Index: mono/mini/mini-ppc.h
===================================================================
--- mono.orig/mini/mini-ppc.h	2009-01-24 16:51:56.000000000 +0100
+++ mono/mini/mini-ppc.h	2009-01-24 17:13:50.000000000 +0100
@@ -57,7 +57,18 @@
 #define MONO_ARCH_NO_EMULATE_LONG_MUL_OPTS
 #define MONO_ARCH_HAVE_ATOMIC_ADD 1
 #define PPC_USES_FUNCTION_DESCRIPTOR
-#else
+#define MONO_ARCH_HAVE_TLS_GET 1
+#define MONO_ARCH_ENABLE_MONITOR_IL_FASTPATH 1
+#else /* must be __mono_ppc__ */
+#if 0
+/* enabling this for PPC32 causes hangs in the thread/delegate tests.
+   So disable for now. */
+#if defined(__linux__)
+#define MONO_ARCH_ENABLE_MONITOR_IL_FASTPATH 1
+#endif
+#endif
+
+#define MONO_ARCH_HAVE_TLS_GET 1
 #define MONO_ARCH_EMULATE_FCONV_TO_I8 1
 #define MONO_ARCH_EMULATE_LCONV_TO_R8 1
 #define MONO_ARCH_EMULATE_LCONV_TO_R4 1
@@ -120,6 +131,7 @@
 #define PPC_LAST_FPARG_REG ppc_f13
 #define PPC_PASS_STRUCTS_BY_VALUE 1
 #define PPC_SMALL_RET_STRUCT_IN_REG 0
+#define PPC_THREAD_PTR_REG ppc_r13
 #else
 #define PPC_RET_ADDR_OFFSET 4
 #define PPC_STACK_PARAM_OFFSET 8
@@ -128,6 +140,7 @@
 #define PPC_LAST_FPARG_REG ppc_f8
 #define PPC_PASS_STRUCTS_BY_VALUE 0
 #define PPC_SMALL_RET_STRUCT_IN_REG 1
+#define PPC_THREAD_PTR_REG ppc_r2
 #endif
 #define PPC_FIRST_ARG_REG ppc_r3
 #define PPC_LAST_ARG_REG ppc_r10
Index: mono/utils/mono-compiler.h
===================================================================
--- mono.orig/utils/mono-compiler.h	2009-01-24 16:51:56.000000000 +0100
+++ mono/utils/mono-compiler.h	2009-01-24 17:13:50.000000000 +0100
@@ -26,15 +26,24 @@
  */
 //#define PIC_INITIAL_EXEC
 
-#if defined (__powerpc__)
-#define MONO_TLS_FAST
-#elif defined(PIC)
+#if defined(PIC)
 
 #ifdef PIC_INITIAL_EXEC
 #define MONO_TLS_FAST __attribute__((tls_model("initial-exec")))
 #else
+#if defined (__powerpc__)
+/* local dynamic requires a call to __tls_get_addr to look up the
+   TLS block address via the Dynamic Thread Vector. In this case Thread
+   Pointer relative offsets can't be used as this modules TLS was
+   allocated separately (none contiguoiusly) from the initial TLS
+   block.
+
+   For now we will disable this. */
+#define MONO_TLS_FAST
+#else
 #define MONO_TLS_FAST __attribute__((tls_model("local-dynamic")))
 #endif
+#endif
 
 #else
 
@@ -65,6 +74,43 @@
 #else
 #define MONO_THREAD_VAR_OFFSET(var,offset) __asm ("addl %0 = @tprel(" #var "#), r0 ;;\n" : "=r" (offset))
 #endif
+
+#elif defined(__mono_ppc__) && defined(__GNUC__)
+#if defined(PIC)
+#ifdef PIC_INITIAL_EXEC
+
+#if defined(__mono_ppc64__)
+#define MONO_THREAD_VAR_OFFSET(var,offset) \
+	do { long off; \
+	__asm (	"ld	%0," #var "@got@tprel(2)\n" \
+	: "=r" (off)); \
+	(offset) = off; } while (0)
+#else
+/* must be powerpc32 */
+#define MONO_THREAD_VAR_OFFSET(var,offset) \
+	__asm (	"lwz	%0," #var "@got@tprel(30)\n" \
+	: "=r" (offset))
+#endif
+
+#else
+
+/* local dynamic requires a call to __tls_get_addr to look up the
+   TLS block address via the Dynamic Thread Vector. In this case Thread
+   Pointer relative offsets can't be used as this modules TLS was
+   allocated separately (none contiguoiusly) from the initial TLS
+   block.
+
+   For now we will disable this. */
+#define MONO_THREAD_VAR_OFFSET(var,offset) (offset) = -1
+
+#endif
+#else
+/* Must be local-exec TLS */
+#define MONO_THREAD_VAR_OFFSET(var,offset) \
+	__asm (	"lis	%0," #var "@tprel@ha\n" \
+		"addi	%0,%0, " #var "@tprel@l\n" \
+	: "=r" (offset))
+#endif
 #else
 #define MONO_THREAD_VAR_OFFSET(var,offset) (offset) = -1
 #endif
