Index: Encoding.cs
===================================================================
--- Encoding.cs	(revision 59294)
+++ Encoding.cs	(working copy)
@@ -227,58 +227,16 @@
 	{
 		if (s == null)
 			throw new ArgumentNullException ("s");
-#if NET_2_0
-		if (charIndex < 0 || charIndex > s.Length)
-			throw new ArgumentOutOfRangeException ("charIndex", _("ArgRange_Array"));
-		if (charCount < 0 || charIndex + charCount > s.Length)
-			throw new ArgumentOutOfRangeException ("charCount", _("ArgRange_Array"));
-		if (byteIndex < 0 || byteIndex > bytes.Length)
-			throw new ArgumentOutOfRangeException ("byteIndex", _("ArgRange_Array"));
 
-		if (charCount == 0 || bytes.Length == byteIndex)
-			return 0;
-		unsafe {
-			fixed (char* cptr = s) {
-				fixed (byte* bptr = bytes) {
-					return GetBytes (cptr + charIndex,
-						charCount,
-						bptr + byteIndex,
-						bytes.Length - byteIndex);
-				}
-			}
-		}
-#else
 		return GetBytes (s.ToCharArray(), charIndex, charCount, bytes, byteIndex);
-#endif
 	}
 	public virtual byte[] GetBytes (String s)
 	{
 		if (s == null)
 			throw new ArgumentNullException ("s");
 
-#if NET_2_0
-		if (s.Length == 0)
-			return new byte [0];
-		int byteCount = GetByteCount (s);
-		if (byteCount == 0)
-			return new byte [0];
-		unsafe {
-			fixed (char* cptr = s) {
-				byte [] bytes = new byte [byteCount];
-				fixed (byte* bptr = bytes) {
-					GetBytes (cptr, s.Length,
-						bptr, byteCount);
-					return bytes;
-				}
-			}
-		}
-#else
 		char[] chars = s.ToCharArray ();
-		int numBytes = GetByteCount (chars, 0, chars.Length);
-		byte[] bytes = new byte [numBytes];
-		GetBytes (chars, 0, chars.Length, bytes, 0);
-		return bytes;
-#endif
+		return GetBytes (chars, 0, chars.Length);
 	}
 	public virtual byte[] GetBytes (char[] chars, int index, int count)
 	{
@@ -289,10 +247,10 @@
 	}
 	public virtual byte[] GetBytes (char[] chars)
 	{
-		int numBytes = GetByteCount (chars, 0, chars.Length);
-		byte[] bytes = new byte [numBytes];
-		GetBytes (chars, 0, chars.Length, bytes, 0);
-		return bytes;
+		if (chars == null)
+			throw new ArgumentNullException ("chars");
+
+		return GetBytes (chars, 0, chars.Length);
 	}
 
 	// Get the number of characters needed to decode a byte buffer.
@@ -324,10 +282,7 @@
 		if (bytes == null) {
 			throw new ArgumentNullException ("bytes");
 		}
-		int numChars = GetCharCount (bytes, 0, bytes.Length);
-		char[] chars = new char [numChars];
-		GetChars (bytes, 0, bytes.Length, chars, 0);
-		return chars;
+		return GetChars (bytes, 0, bytes.Length);
 	}
 
 	// Get a decoder that forwards requests to this object.
@@ -663,7 +618,10 @@
 	}
 	public virtual String GetString (byte[] bytes)
 	{
-		return new String (GetChars(bytes));
+		if (bytes == null)
+			throw new ArgumentNullException ("bytes");
+
+		return GetString (bytes, 0, bytes.Length);
 	}
 
 #if !ECMA_COMPAT
Index: UnicodeEncoding.cs
===================================================================
--- UnicodeEncoding.cs	(revision 59294)
+++ UnicodeEncoding.cs	(working copy)
@@ -147,7 +147,7 @@
 	}
 
 #if !NET_2_0
-	public unsafe override byte [] GetBytes (String s)
+	public override byte [] GetBytes (String s)
 	{
 		if (s == null)
 			throw new ArgumentNullException ("s");
@@ -155,10 +155,7 @@
 		int byteCount = GetByteCount (s);
 		byte [] bytes = new byte [byteCount];
 
-		if (byteCount != 0)
-			fixed (char* charPtr = s)
-				fixed (byte* bytePtr = bytes)
-					GetBytesInternal (charPtr, s.Length, bytePtr, byteCount);
+		GetBytes (s, 0, s.Length, bytes, 0);
 
 		return bytes;
 	}
@@ -298,6 +295,29 @@
 
 		return GetCharsInternal (bytes, byteCount, chars, charCount);
 	}
+
+	// Decode a buffer of bytes into a string.
+	public unsafe override String GetString (byte [] bytes, int index, int count)
+	{
+		if (bytes == null)
+			throw new ArgumentNullException ("bytes");
+		if (index < 0 || index > bytes.Length)
+			throw new ArgumentOutOfRangeException ("index", _("ArgRange_Array"));
+		if (count < 0 || count > (bytes.Length - index))
+			throw new ArgumentOutOfRangeException ("count", _("ArgRange_Array"));
+
+		if (count == 0)
+			return string.Empty;
+
+		int charCount = GetCharCount (bytes, index, count);
+		string s = string.InternalAllocateStr (charCount);
+
+		fixed (byte* bytePtr = bytes)
+			fixed (char* charPtr = s)
+				GetCharsInternal (bytePtr + index, count, charPtr, charCount);
+
+		return s;
+	}
 #endif
 
 	private unsafe int GetCharsInternal (byte* bytes, int byteCount,
