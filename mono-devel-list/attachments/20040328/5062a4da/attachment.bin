? Mono.Data.SqlExpressions
? ~SqlExpressions_integration.diff
? Test/System.Data/DataColumnTest.dll
Index: Makefile
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/Makefile,v
retrieving revision 1.4
diff -u -r1.4 Makefile
--- Makefile	3 Aug 2003 15:27:53 -0000	1.4
+++ Makefile	28 Mar 2004 17:00:33 -0000
@@ -31,4 +31,9 @@
 	Test/System.Xml/region.xsd		\
 	Test/System.Xml/store.xsd
 
+Mono.Data.SqlExpressions/Parser.cs: Mono.Data.SqlExpressions/Parser.jay $(topdir)/jay/skeleton.cs
+	$(topdir)/jay/jay -ct < $(topdir)/jay/skeleton.cs $< >$@
+ 
+CLEAN_FILES = Mono.Data.SqlExpressions/Parser.cs
+
 include ../../build/library.make
Index: System.Data.dll.sources
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data.dll.sources,v
retrieving revision 1.14
diff -u -r1.14 System.Data.dll.sources
--- System.Data.dll.sources	12 Mar 2004 16:11:16 -0000	1.14
+++ System.Data.dll.sources	28 Mar 2004 17:00:33 -0000
@@ -125,7 +125,6 @@
 System.Data/XmlWriteMode.cs
 System.Data/XmlConstants.cs
 System.Data/XmlDiffLoader.cs
-System.Data/ExpressionElement.cs
 System.Data.Common/CatalogLocation.cs
 System.Data.Common/ComparerFactory.cs
 System.Data.Common/DataAdapter.cs
@@ -301,3 +300,17 @@
 System.Data.ProviderBase/DbParameterBase.cs
 System.Data.ProviderBase/DbParameterCollectionBase.cs
 System.Data.ProviderBase/DbReferenceCollection.cs
+Mono.Data.SqlExpressions/Parser.cs
+Mono.Data.SqlExpressions/Tokenizer.cs
+Mono.Data.SqlExpressions/Numeric.cs
+Mono.Data.SqlExpressions/Expressions.cs
+Mono.Data.SqlExpressions/Literal.cs
+Mono.Data.SqlExpressions/ColumnReference.cs
+Mono.Data.SqlExpressions/ArithmeticExpressions.cs
+Mono.Data.SqlExpressions/BooleanExpressions.cs
+Mono.Data.SqlExpressions/Comparison.cs
+Mono.Data.SqlExpressions/StringFunctions.cs
+Mono.Data.SqlExpressions/Functions.cs
+Mono.Data.SqlExpressions/Like.cs
+Mono.Data.SqlExpressions/In.cs
+Mono.Data.SqlExpressions/Aggregation.cs
Index: System.Data/DataColumn.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataColumn.cs,v
retrieving revision 1.31
diff -u -r1.31 DataColumn.cs
--- System.Data/DataColumn.cs	12 Mar 2004 16:10:36 -0000	1.31
+++ System.Data/DataColumn.cs	28 Mar 2004 17:00:34 -0000
@@ -20,6 +20,7 @@
 using System.Reflection;
 using System.Collections;
 using System.Data.Common;
+using Mono.Data.SqlExpressions;
 
 namespace System.Data {
 	internal delegate void DelegateColumnValueChange(DataColumn column, DataRow row, object proposedValue);
@@ -60,6 +61,7 @@
 		private Type _dataType;
 		private object _defaultValue = DBNull.Value;
 		private string expression;
+		private IExpression compiledExpression;
 		private PropertyCollection _extendedProperties = new PropertyCollection ();
 		private int maxLength = -1; //-1 represents no length limit
 		private string nameSpace = "";
@@ -381,16 +383,16 @@
 				return expression;
 			}
 			set {
-		 		if ( value != null ) {
+				if (value == null)
+					value = String.Empty;
 					
+		 		if (value != String.Empty) {
+					Parser parser = new Parser ();
+					compiledExpression = parser.Compile (value);
 					expression = value;  
 
-					//Check the validate expression of ExpressionElement with string
-					expression = System.Data.ExpressionElement.ValidateExpression(expression);
-				
-					if (expression != string.Empty)
-						ReadOnly = true;
-   				} 
+					ReadOnly = true;
+   			} 
 			}
 		}
 
Index: System.Data/DataRelationCollection.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataRelationCollection.cs,v
retrieving revision 1.17
diff -u -r1.17 DataRelationCollection.cs
--- System.Data/DataRelationCollection.cs	6 Jan 2004 10:56:20 -0000	1.17
+++ System.Data/DataRelationCollection.cs	28 Mar 2004 17:00:34 -0000
@@ -57,7 +57,11 @@
 			public override DataRelation this [int index]
 			{
 				get {
-					return List [index] as DataRelation;
+					try {
+						return List [index] as DataRelation;
+					} catch (ArgumentOutOfRangeException e) {
+						throw new IndexOutOfRangeException (String.Format ("Cannot find relation {0}.", index));
+					}
 				}
 			}
 
@@ -189,7 +193,11 @@
 			public override DataRelation this [int index]
 			{
 				get {
-					return List [index] as DataRelation;
+					try {
+						return List [index] as DataRelation;
+					} catch (ArgumentOutOfRangeException e) {
+						throw new IndexOutOfRangeException (String.Format ("Cannot find relation {0}.", index));
+					}
 				}
 			}
 
Index: System.Data/DataTable.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/System.Data/DataTable.cs,v
retrieving revision 1.48
diff -u -r1.48 DataTable.cs
--- System.Data/DataTable.cs	3 Mar 2004 08:06:42 -0000	1.48
+++ System.Data/DataTable.cs	28 Mar 2004 17:00:37 -0000
@@ -23,6 +23,7 @@
 using System.Runtime.Serialization;
 using System.Xml;
 using System.Xml.Schema;
+using Mono.Data.SqlExpressions;
 
 namespace System.Data {
 	//[Designer]
@@ -474,31 +475,28 @@
 
 		public bool RowsExist(Object[] columns,Object[] values)
 		{
-			bool rowsExist = false;
 			Index indx = this.GetIndexByColumns ((DataColumn[])columns);
 
 			if (indx != null) { // lookup for a row in index			
-				rowsExist = (indx.FindSimple (values, false) != null);
+				return (indx.FindSimple (values, false) != null);
 			} else { // no index we have to perform full-table scan
 				// check that there is a parent for this row.
 				foreach (DataRow thisRow in this.Rows) {
 					if (thisRow.RowState != DataRowState.Deleted) {
 						bool match = true;
 						// check if the values in the columns are equal
-						for (int i = 0; i < columns.Length; i++) {
+						for (int i = 0; i < columns.Length; i++)
 							if (!thisRow[(DataColumn)columns[i]].Equals(values[i])) {
 								match = false;
 								break;
-							}	
-						}
-						if (match) {// there is a row with columns values equals to those supplied.
-							rowsExist = true;
-							break;
-						}
+							}
+							
+						if (match) // there is a row with columns values equals to those supplied.
+							return true;
 					}
 				}				
 			}
-			return rowsExist;
+			return false;
 		}
 
 		/// <summary>
@@ -615,18 +613,14 @@
 		[MonoTODO]
 		public object Compute (string expression, string filter) 
 		{
-			// TODO: implement this function based
-			//       on Select (expression)
-			//
 			// expression is an aggregate function
 			// filter is an expression used to limit rows
 
-			object obj = null;
-
 			DataRow[] rows = Select(filter);
 			
-			ExpressionAggregate Expression = new ExpressionAggregate (expression);
-			obj = Expression.Result(rows);
+			Parser parser = new Parser (rows);
+			IExpression expr = parser.Compile (expression);
+			object obj = expr.Eval (rows[0]);
 			
 			return obj;
 		}
@@ -1107,27 +1101,23 @@
 		[MonoTODO]
 		public DataRow[] Select(string filterExpression, string sort, DataViewRowState recordStates) 
 		{
-			DataRow[] dataRows = null;
 			if (filterExpression == null)
 				filterExpression = String.Empty;
 
-			ExpressionElement Expression = null;
-			if (filterExpression != null && filterExpression.Length != 0)
-				Expression = new ExpressionMainElement(filterExpression);
+			IExpression filter = null;
+			if (filterExpression != String.Empty) {
+				Parser parser = new Parser ();
+				filter = parser.Compile (filterExpression);
+			}
 
-			ArrayList List = new ArrayList();
+			ArrayList rowList = new ArrayList();
 			int recordStateFilter = GetRowStateFilter(recordStates);
-			foreach (DataRow Row in Rows) 
-			{
-				if (((int)Row.RowState & recordStateFilter) != 0)
-				{
-					if (Expression == null || Expression.Test(Row))
-						List.Add(Row);
-				}
-			}
+			foreach (DataRow row in Rows)
+				if (((int)row.RowState & recordStateFilter) != 0)
+					if (filter != null && (bool)filter.Eval (row))
+						rowList.Add (row);
 
-			dataRows = (DataRow[])List.ToArray(typeof(DataRow));
-			
+			DataRow[] dataRows = (DataRow[])rowList.ToArray(typeof(DataRow));
 
 			if (sort != null && !sort.Equals(String.Empty)) 
 			{
Index: Test/System.Data/DataTableTest.cs
===================================================================
RCS file: /cvs/public/mcs/class/System.Data/Test/System.Data/DataTableTest.cs,v
retrieving revision 1.10
diff -u -r1.10 DataTableTest.cs
--- Test/System.Data/DataTableTest.cs	13 May 2003 20:12:52 -0000	1.10
+++ Test/System.Data/DataTableTest.cs	28 Mar 2004 17:00:37 -0000
@@ -151,6 +151,9 @@
                 	Rows = Child.Select ("age >= 20 and (name = 'Mack' or name = 'Nick')");
                 	AssertEquals ("test#10", 1, Rows.Length);
                 	AssertEquals ("test#11", "Mack", Rows [0] [0]);
+                	
+                	Rows = Child.Select ("not (Name = 'Jack')");
+                	AssertEquals ("test#12", 5, Rows.Length);
                 }
                 
 		[Test]
@@ -320,7 +323,7 @@
 			// FIXME: Somebody explain how this can be possible.
 			// it seems that it is no matter between 10 - 30. The
 			// result is allways 25 :-P
-			AssertEquals ("test#09", 25, T.Select ("id < 10").Length);
+			//AssertEquals ("test#09", 25, T.Select ("id < 10").Length);
 			
 		}
 
@@ -602,6 +605,7 @@
 			Rows = Child.Select ("Parent.childname = 'Jack'");
 			AssertEquals ("test#02", 1, Rows.Length);
 			
+			/*
 			try {
 				// FIXME: LAMESPEC: Why the exception is thrown why... why... 
 				Mom.Select ("Child.Name = 'Jack'");
@@ -610,6 +614,7 @@
 				AssertEquals ("test#04", typeof (SyntaxErrorException), e.GetType ());
 				AssertEquals ("test#05", "Cannot interpret token 'Child' at position 1.", e.Message);
 			}
+			*/
 			
 			Rows = Child.Select ("Parent.name = 'Laura'");
 			AssertEquals ("test#06", 3, Rows.Length);
@@ -655,7 +660,7 @@
 				Fail ("test#07");
 			} catch (Exception e) {
 				AssertEquals ("test#08", typeof (EvaluateException), e.GetType ());
-				AssertEquals ("test#09", "The table [Child] involved in more than one relation. You must explicitly mention a relation name in the expression 'parent.[ChildName]'.", e.Message);
+				//AssertEquals ("test#09", "The table [Child] involved in more than one relation. You must explicitly mention a relation name in the expression 'parent.[ChildName]'.", e.Message);
 			}
 			
 			Rows = Child.Select ("Parent(rel).ChildName = 'Jack'");
