<tt>
&lt;div&nbsp;class=&quot;gmail_quote&quot;&gt;On&nbsp;Wed,&nbsp;Nov&nbsp;5,&nbsp;2008&nbsp;at&nbsp;4:45&nbsp;PM,&nbsp;Cliff&nbsp;Stanford&nbsp;&lt;span&nbsp;dir=&quot;ltr&quot;&gt;&amp;lt;&lt;a&nbsp;href=&quot;mailto:cliff@may.be&quot;&gt;cliff@may.be&lt;/a&gt;&amp;gt;&lt;/span&gt;&nbsp;wrote:&lt;br&gt;<br>
&lt;blockquote&nbsp;class=&quot;gmail_quote&quot;&nbsp;style=&quot;PADDING-LEFT:&nbsp;1ex;&nbsp;MARGIN:&nbsp;0px&nbsp;0px&nbsp;0px&nbsp;0.8ex;&nbsp;BORDER-LEFT:&nbsp;#ccc&nbsp;1px&nbsp;solid&quot;&gt;I&nbsp;don&amp;#39;t&nbsp;want&nbsp;to&nbsp;turn&nbsp;this&nbsp;into&nbsp;a&nbsp;language&nbsp;argument&nbsp;but&nbsp;my&nbsp;feeling&nbsp;was&lt;br&gt;that&nbsp;mono&nbsp;was&nbsp;allowing&nbsp;C#&nbsp;to&nbsp;become&nbsp;a&nbsp;serious&nbsp;Unix&nbsp;programming&nbsp;language.&lt;br&gt;<br>
&lt;br&gt;Becoming&nbsp;a&nbsp;daemon&nbsp;is&nbsp;a&nbsp;common&nbsp;part&nbsp;of&nbsp;Unix&nbsp;programming.&nbsp;&amp;nbsp;I&nbsp;don&amp;#39;t&nbsp;know&lt;br&gt;anything&nbsp;about&nbsp;the&nbsp;Mono&nbsp;internals&nbsp;but&nbsp;it&nbsp;seems&nbsp;to&nbsp;me&nbsp;that&nbsp;there&nbsp;should&lt;br&gt;be&nbsp;some&nbsp;way&nbsp;to&nbsp;achieve&nbsp;it.&nbsp;&amp;nbsp;The&nbsp;Service&nbsp;paradigm,&nbsp;whilst&nbsp;great&nbsp;for&lt;br&gt;<br>
porting&nbsp;of&nbsp;Windows&nbsp;code,&nbsp;just&nbsp;isn&amp;#39;t&nbsp;what&nbsp;is&nbsp;needed&nbsp;for&nbsp;true&nbsp;Unix&lt;br&gt;programming.&lt;br&gt;&lt;/blockquote&gt;<br>
&lt;div&gt;I&nbsp;just&nbsp;want&nbsp;to&nbsp;point&nbsp;out&nbsp;that&nbsp;the&nbsp;C#&nbsp;compiler&nbsp;and&nbsp;the&nbsp;.NET&nbsp;Framework&nbsp;provide&nbsp;a&nbsp;much&nbsp;better&nbsp;framework&nbsp;for&nbsp;programming&nbsp;for&nbsp;Unix&nbsp;applications&nbsp;than&nbsp;the&nbsp;traditional&nbsp;POSIX&nbsp;API&nbsp;model.&nbsp;Both&nbsp;the&nbsp;C#&nbsp;language&nbsp;and&nbsp;.NET&nbsp;Framework&nbsp;are&nbsp;designed&nbsp;from&nbsp;the&nbsp;ground&nbsp;up&nbsp;to&nbsp;support&nbsp;multithreading&nbsp;within&nbsp;a&nbsp;single&nbsp;application&nbsp;process&nbsp;space.&nbsp;This&nbsp;is&nbsp;opposite&nbsp;of&nbsp;the&nbsp;POSIX&nbsp;model&nbsp;where&nbsp;fork()&nbsp;was&nbsp;necessary&nbsp;when&nbsp;Unix&nbsp;processes&nbsp;were&nbsp;only&nbsp;single&nbsp;threaded.&nbsp;POSIX&nbsp;threads&nbsp;are&nbsp;a&nbsp;relatively&nbsp;new&nbsp;feature&nbsp;for&nbsp;Unix.&nbsp;In&nbsp;fact,&nbsp;threads&nbsp;were&nbsp;added&nbsp;to&nbsp;POSIX&nbsp;to&nbsp;cope&nbsp;with&nbsp;the&nbsp;limitations&nbsp;and&nbsp;inefficiencies&nbsp;of&nbsp;fork()&nbsp;and&nbsp;the&nbsp;programming&nbsp;model&nbsp;around&nbsp;it.&lt;br&gt;<br>
&amp;nbsp;&lt;br&gt;I&nbsp;think&nbsp;is&nbsp;important&nbsp;to&nbsp;realize&nbsp;that&nbsp;.NET&nbsp;and&nbsp;POSIX&nbsp;propose&nbsp;different&nbsp;solutions&nbsp;and&nbsp;programming&nbsp;models.&nbsp;Attempting&nbsp;to&nbsp;use&nbsp;fork()&nbsp;in&nbsp;a&nbsp;.NET&nbsp;application&nbsp;or&nbsp;service&nbsp;is&nbsp;opposite&nbsp;to&nbsp;the&nbsp;design&nbsp;goals&nbsp;of&nbsp;.NET&nbsp;which&nbsp;are&nbsp;(among&nbsp;lots&nbsp;of&nbsp;other&nbsp;things)&nbsp;to&nbsp;provide&nbsp;better,&nbsp;alternative&nbsp;solutions&nbsp;to&nbsp;the&nbsp;POSIX&nbsp;model.&lt;br&gt;<br>
&amp;nbsp;&lt;br&gt;Just&nbsp;my,&nbsp;hopefully&nbsp;helpful,&nbsp;two&nbsp;cents.&nbsp;No&nbsp;flames&nbsp;please.&lt;br&gt;&amp;nbsp;&lt;br&gt;Phil&lt;/div&gt;&lt;/div&gt;<br>

</tt>
