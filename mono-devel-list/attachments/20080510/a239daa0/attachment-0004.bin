//
// System.BitConverter.cs
//
// Author:
//   Matt Kimball (matt@kimball.net)
//
//
// Copyright (C) 2004 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Text;
using System.Runtime.InteropServices;

namespace Test
{
	public
#if NET_2_0
	static
#else
	sealed
#endif
	class BitConverter
	{
#if !NET_2_0
		private BitConverter ()
		{
		}
#endif
		[StructLayoutAttribute(LayoutKind.Explicit)]
		private struct Convert16
		{
			[FieldOffsetAttribute(0)]
			public bool boolean;
			
			[FieldOffsetAttribute(0)]
			public char c;
			
			[FieldOffsetAttribute(0)]
			public short s;
			
			[FieldOffsetAttribute(0)]
			public ushort us;

			[FieldOffsetAttribute(0)]
			public byte b0;
			
			[FieldOffsetAttribute(1)]
			public byte b1;
		}
		
		[StructLayoutAttribute(LayoutKind.Explicit)]
		private struct Convert32
		{
			[FieldOffsetAttribute(0)]
			public int i;
			
			[FieldOffsetAttribute(0)]
			public float f;
			
			[FieldOffsetAttribute(0)]
			public uint ui;
			
			[FieldOffsetAttribute(0)]
			public byte b0;
			
			[FieldOffsetAttribute(1)]
			public byte b1;
			
			[FieldOffsetAttribute(2)]
			public byte b2;
			
			[FieldOffsetAttribute(3)]
			public byte b3;
		}
	
		[StructLayoutAttribute(LayoutKind.Explicit)]
		private struct Convert64
		{
			[FieldOffsetAttribute(0)]
			public double d;
			
			[FieldOffsetAttribute(0)]
			public long l;
			
			[FieldOffsetAttribute(0)]
			public ulong ul;
			
			[FieldOffsetAttribute(0)]
			public byte b0;
			
			[FieldOffsetAttribute(1)]
			public byte b1;
			
			[FieldOffsetAttribute(2)]
			public byte b2;
			
			[FieldOffsetAttribute(3)]
			public byte b3;
		
			[FieldOffsetAttribute(4)]
			public byte b4;
			
			[FieldOffsetAttribute(5)]
			public byte b5;
			
			[FieldOffsetAttribute(6)]
			public byte b6;
			
			[FieldOffsetAttribute(7)]
			public byte b7;
		}
		
		static readonly bool SwappedWordsInDouble = DoubleWordsAreSwapped ();
		public static readonly bool IsLittleEndian = AmILittleEndian ();

		static bool AmILittleEndian ()
		{
			// binary representations of 1.0:
			// big endian: 3f f0 00 00 00 00 00 00
			// little endian: 00 00 00 00 00 00 f0 3f
			// arm fpa little endian: 00 00 f0 3f 00 00 00 00
			Convert64 c = new Convert64 ();
			c.d = 1.0;
			return c.b0 == 0;
		}

		static bool DoubleWordsAreSwapped ()
		{
			// binary representations of 1.0:
			// big endian: 3f f0 00 00 00 00 00 00
			// little endian: 00 00 00 00 00 00 f0 3f
			// arm fpa little endian: 00 00 f0 3f 00 00 00 00
			Convert64 c = new Convert64 ();
			c.d = 1.0;
			return c.b2 == 0xf0;
		}

		public static long DoubleToInt64Bits (double value)
		{
			Convert64 c = new Convert64 ();
			c.d = value;
			return c.l;
		}

		public static double Int64BitsToDouble (long value)
		{
			Convert64 c = new Convert64 ();
			c.l = value;
			return c.d;
		}

		internal static double InternalInt64BitsToDouble (long value)
		{
			return SwappableToDouble (GetBytes (value), 0);
		}

		public static byte[] GetBytes (bool value)
		{
			return value ? new byte[] { 1 } : new byte[] { 0 };
		}

		public static byte[] GetBytes (char value)
		{
			Convert16 c = new Convert16 ();
			c.c = value;
			return new byte[] { c.b0, c.b1 };
		}

		public static byte[] GetBytes (short value)
		{
			Convert16 c = new Convert16 ();
			c.s = value;
			return new byte[] { c.b0, c.b1 };
		}

		public static byte[] GetBytes (int value)
		{
			Convert32 c = new Convert32 ();
			c.i = value;
			return new byte[] { c.b0, c.b1, c.b2, c.b3 };
		}

		public static byte[] GetBytes (long value)
		{
			Convert64 c = new Convert64 ();
			c.l = value;
			return new byte[] { c.b0, c.b1, c.b2, c.b3, c.b4, c.b5, c.b6, c.b7 };
		}

		[CLSCompliant (false)]
		public static byte[] GetBytes (ushort value)
		{
			Convert16 c = new Convert16 ();
			c.us = value;
			return new byte[] { c.b0, c.b1 };
		}

		[CLSCompliant (false)]
		public static byte[] GetBytes (uint value)
		{
			Convert32 c = new Convert32 ();
			c.ui = value;
			return new byte[] { c.b0, c.b1, c.b2, c.b3 };
		}

		[CLSCompliant (false)]
		public static byte[] GetBytes (ulong value)
		{
			Convert64 c = new Convert64 ();
			c.ul = value;
			return new byte[] { c.b0, c.b1, c.b2, c.b3, c.b4, c.b5, c.b6, c.b7 };
		}

		public static byte[] GetBytes (float value)
		{
			Convert32 c = new Convert32 ();
			c.f = value;
			return new byte[] { c.b0, c.b1, c.b2, c.b3 };
		}

		public static byte[] GetBytes (double value)
		{
			Convert64 c = new Convert64 ();
			c.d = value;
			
			if (SwappedWordsInDouble) {
				return new byte[] { c.b4, c.b5, c.b6, c.b7, c.b0, c.b1, c.b2, c.b3 };
			} else {
				return new byte[] { c.b0, c.b1, c.b2, c.b3, c.b4, c.b5, c.b6, c.b7 };
			}
		}

		private static void CheckArguments (byte[] src, int start_index, int count)
		{
			if (src == null)
#if NET_2_0
				throw new ArgumentNullException ("value");
#else
				throw new ArgumentNullException ("byteArray");
#endif

			if (start_index < 0 || (start_index > src.Length - 1))
				throw new ArgumentOutOfRangeException ("startIndex", "Index was"
					+ " out of range. Must be non-negative and less than the"
					+ " size of the collection.");

			// avoid integer overflow (with large pos/neg start_index values)
			if (src.Length - count < start_index)
				throw new ArgumentException ("Destination array is not long"
					+ " enough to copy all the items in the collection."
					+ " Check array index and length.");
		}
		
		static void PutBytes16 (ref Convert16 c, byte[] src, int start_index)
		{
			CheckArguments (src, start_index, 2);
			c.b0 = src[start_index];
			c.b1 = src[start_index + 1];
		}
		static void PutBytes32 (ref Convert32 c, byte[] src, int start_index)
		{
			CheckArguments (src, start_index, 4);
			c.b0 = src[start_index];
			c.b1 = src[start_index + 1];
			c.b2 = src[start_index + 2];
			c.b3 = src[start_index + 3];
		}
		static void PutBytes64 (ref Convert64 c, byte[] src, int start_index)
		{
			CheckArguments (src, start_index, 8);
			c.b0 = src[start_index];
			c.b1 = src[start_index + 1];
			c.b2 = src[start_index + 2];
			c.b3 = src[start_index + 3];
			c.b4 = src[start_index + 4];
			c.b5 = src[start_index + 5];
			c.b6 = src[start_index + 6];
			c.b7 = src[start_index + 7];
		}

		public static bool ToBoolean (byte[] value, int startIndex)
		{
			if (value == null) 
				throw new ArgumentNullException ("value");

			if (startIndex < 0 || (startIndex > value.Length - 1))
				throw new ArgumentOutOfRangeException ("startIndex", "Index was"
					+ " out of range. Must be non-negative and less than the"
					+ " size of the collection.");

			if (value [startIndex] != 0)
				return true;
			
			return false;
		}

		public static char ToChar (byte[] value, int startIndex)
		{
			Convert16 c = new Convert16 ();
			
			PutBytes16 (ref c, value, startIndex);
			
			return c.c;
		}

		public static short ToInt16 (byte[] value, int startIndex)
		{
			Convert16 c = new Convert16 ();
			
			PutBytes16 (ref c, value, startIndex);
			
			return c.s;
		}

		public static int ToInt32 (byte[] value, int startIndex)
		{
			Convert32 c = new Convert32 ();
			
			PutBytes32 (ref c, value, startIndex);
			
			return c.i;
		}

		public static long ToInt64 (byte[] value, int startIndex)
		{
			Convert64 c = new Convert64();
			
			PutBytes64 (ref c, value, startIndex);
			
			return c.l;
		}

		[CLSCompliant (false)]
		public static ushort ToUInt16 (byte[] value, int startIndex)
		{
			Convert16 c = new Convert16 ();
			
			PutBytes16 (ref c, value, startIndex);
			
			return c.us;
		}

		[CLSCompliant (false)]
		public static uint ToUInt32 (byte[] value, int startIndex)
		{
			Convert32 c = new Convert32 ();
			
			PutBytes32 (ref c, value, startIndex);
			
			return c.ui;
		}

		[CLSCompliant (false)]
		public static ulong ToUInt64 (byte[] value, int startIndex)
		{
			Convert64 c = new Convert64 ();
			
			PutBytes64 (ref c, value, startIndex);
			
			return c.ul;
		}

		public static float ToSingle (byte[] value, int startIndex)
		{
			Convert32 c = new Convert32 ();
			
			PutBytes32 (ref c, value, startIndex);
			
			return c.f;
		}

		public static double ToDouble (byte[] value, int startIndex)
		{
			Convert64 c = new Convert64 ();

			if (SwappedWordsInDouble) {
				if (value == null)
					throw new ArgumentNullException ("value");

				if (startIndex < 0 || (startIndex > value.Length - 1))
					throw new ArgumentOutOfRangeException ("startIndex", "Index was"
						+ " out of range. Must be non-negative and less than the"
						+ " size of the collection.");

				// avoid integer overflow (with large pos/neg start_index values)
				if (value.Length - 8 < startIndex)
					throw new ArgumentException ("Destination array is not long"
						+ " enough to copy all the items in the collection."
						+ " Check array index and length.");
				
				c.b0 = value [startIndex + 4];
				c.b1 = value [startIndex + 5];
				c.b2 = value [startIndex + 6];
				c.b3 = value [startIndex + 7];
				c.b4 = value [startIndex + 0];
				c.b5 = value [startIndex + 1];
				c.b6 = value [startIndex + 2];
				c.b7 = value [startIndex + 3];

				return c.d;
			}
			
			PutBytes64 (ref c, value, startIndex);
			return c.d;
		}

		internal static double SwappableToDouble (byte[] value, int startIndex)
		{
			Convert64 c = new Convert64 ();

			if (SwappedWordsInDouble) {
				if (value == null)
					throw new ArgumentNullException ("value");

				if (startIndex < 0 || (startIndex > value.Length - 1))
					throw new ArgumentOutOfRangeException ("startIndex", "Index was"
						+ " out of range. Must be non-negative and less than the"
						+ " size of the collection.");

				// avoid integer overflow (with large pos/neg start_index values)
				if (value.Length - 8 < startIndex)
					throw new ArgumentException ("Destination array is not long"
						+ " enough to copy all the items in the collection."
						+ " Check array index and length.");

				c.b0 = value [startIndex + 4];
				c.b1 = value [startIndex + 5];
				c.b2 = value [startIndex + 6];
				c.b3 = value [startIndex + 7];
				c.b4 = value [startIndex + 0];
				c.b5 = value [startIndex + 1];
				c.b6 = value [startIndex + 2];
				c.b7 = value [startIndex + 3];

				return c.d;
			} else if (!IsLittleEndian) {
				if (value == null)
					throw new ArgumentNullException ("value");

				if (startIndex < 0 || (startIndex > value.Length - 1))
					throw new ArgumentOutOfRangeException ("startIndex", "Index was"
						+ " out of range. Must be non-negative and less than the"
						+ " size of the collection.");

				// avoid integer overflow (with large pos/neg start_index values)
				if (value.Length - 8 < startIndex)
					throw new ArgumentException ("Destination array is not long"
						+ " enough to copy all the items in the collection."
						+ " Check array index and length.");

				c.b0 = value [startIndex + 7];
				c.b1 = value [startIndex + 6];
				c.b2 = value [startIndex + 5];
				c.b3 = value [startIndex + 4];
				c.b4 = value [startIndex + 3];
				c.b5 = value [startIndex + 2];
				c.b6 = value [startIndex + 1];
				c.b7 = value [startIndex + 0];

				return c.d;
			}

			PutBytes64 (ref c, value, startIndex);

			return c.d;
		}
		
		public static string ToString (byte[] value)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			return ToString (value, 0, value.Length);
		}

		public static string ToString (byte[] value, int startIndex)
		{
			if (value == null)
				throw new ArgumentNullException ("value");

			return ToString (value, startIndex, value.Length - startIndex);
		}

		public static string ToString (byte[] value, int startIndex, int length)
		{
			if (value == null)
				throw new ArgumentNullException ("byteArray");

			// The 4th and last clause (start_index >= value.Length)
			// was added as a small fix to a very obscure bug.
			// It makes a small difference when start_index is
			// outside the range and length==0. 
			if (startIndex < 0 || startIndex >= value.Length) {
#if NET_2_0
				// special (but valid) case (e.g. new byte [0])
				if ((startIndex == 0) && (value.Length == 0))
					return String.Empty;
#endif
				throw new ArgumentOutOfRangeException ("startIndex", "Index was"
					+ " out of range. Must be non-negative and less than the"
					+ " size of the collection.");
			}

			if (length < 0)
				throw new ArgumentOutOfRangeException ("length",
					"Value must be positive.");

			// note: re-ordered to avoid possible integer overflow
			if (startIndex > value.Length - length)
				throw new ArgumentException ("startIndex + length > value.Length");

			if (length == 0)
				return string.Empty;

			StringBuilder builder = new StringBuilder(length * 3 - 1);
			int end = startIndex + length;

			for (int i = startIndex; i < end; i++) {
				if (i > startIndex)
					builder.Append('-');
				
				char high = (char)((value[i] >> 4) & 0x0f);
				char low = (char)(value[i] & 0x0f);

				if (high < 10) 
					high += '0';
				else {
					high -= (char) 10;
					high += 'A';
				}

				if (low < 10)
					low += '0';
				else {
					low -= (char) 10;
					low += 'A';
				}
				builder.Append(high);
				builder.Append(low);
			}

			return builder.ToString ();
		}
	}
}
