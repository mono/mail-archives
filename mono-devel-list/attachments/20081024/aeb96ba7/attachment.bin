Index: metadata/marshal.c
===================================================================
--- metadata/marshal.c	(revision 116603)
+++ metadata/marshal.c	(working copy)
@@ -9793,7 +9793,7 @@
 MonoMethod *
 mono_marshal_get_synchronized_wrapper (MonoMethod *method)
 {
-	static MonoMethod *enter_method, *exit_method;
+	static MonoMethod *enter_method, *exit_method, *gettypefromhandle_method;
 	MonoMethodSignature *sig;
 	MonoExceptionClause *clause;
 	MonoMethodHeader *header;
@@ -9853,21 +9853,27 @@
 		enter_method = mono_method_desc_search_in_class (desc, mono_defaults.monitor_class);
 		g_assert (enter_method);
 		mono_method_desc_free (desc);
+
 		desc = mono_method_desc_new ("Monitor:Exit", FALSE);
 		exit_method = mono_method_desc_search_in_class (desc, mono_defaults.monitor_class);
 		g_assert (exit_method);
 		mono_method_desc_free (desc);
+
+		desc = mono_method_desc_new ("Type:GetTypeFromHandle", FALSE);
+		gettypefromhandle_method = mono_method_desc_search_in_class (desc, mono_defaults.monotype_class->parent);
+		g_assert (gettypefromhandle_method);
+		mono_method_desc_free (desc);
 	}
 
 	/* Push this or the type object */
 	if (method->flags & METHOD_ATTRIBUTE_STATIC) {
-		/*
-		 * GetTypeFromHandle isn't called as a managed method because it has
-		 * a funky calling sequence, e.g. ldtoken+GetTypeFromHandle gets
-		 * transformed into something else by the JIT.
-		 */
-		mono_mb_emit_ptr (mb, &method->klass->byval_arg);
-		mono_mb_emit_icall (mb, type_from_handle);
+		/* We have special handling for this in the JIT */
+		int index = mono_mb_add_data (mb, method->klass);
+		mono_mb_add_data (mb, mono_defaults.typehandle_class);
+		mono_mb_emit_byte (mb, CEE_LDTOKEN);
+		mono_mb_emit_i4 (mb, index);
+
+		mono_mb_emit_managed_call (mb, gettypefromhandle_method, NULL);
 	}
 	else
 		mono_mb_emit_ldarg (mb, 0);
Index: mini/method-to-ir.c
===================================================================
--- mini/method-to-ir.c	(revision 116603)
+++ mini/method-to-ir.c	(working copy)
@@ -8326,7 +8345,8 @@
 			CHECK_OPSIZE (5);
 			n = read32 (ip + 1);
 
-			if (method->wrapper_type == MONO_WRAPPER_DYNAMIC_METHOD) {
+			if (method->wrapper_type == MONO_WRAPPER_DYNAMIC_METHOD ||
+					method->wrapper_type == MONO_WRAPPER_SYNCHRONIZED) {
 				handle = mono_method_get_wrapper_data (method, n);
 				handle_class = mono_method_get_wrapper_data (method, n + 1);
 				if (handle_class == mono_defaults.typehandle_class)
@@ -8356,7 +8376,9 @@
 					g_assert_not_reached ();
 			}
 
-			if (cfg->opt & MONO_OPT_SHARED) {
+			if ((cfg->opt & MONO_OPT_SHARED) &&
+					method->wrapper_type != MONO_WRAPPER_DYNAMIC_METHOD &&
+					method->wrapper_type != MONO_WRAPPER_SYNCHRONIZED) {
 				MonoInst *addr, *vtvar, *iargs [3];
 				int method_context_used;
 
Index: mini/mini.c
===================================================================
--- mini/mini.c	(revision 116603)
+++ mini/mini.c	(working copy)
@@ -8765,7 +8766,8 @@
 			CHECK_OPSIZE (5);
 			n = read32 (ip + 1);
 
-			if (method->wrapper_type == MONO_WRAPPER_DYNAMIC_METHOD) {
+			if (method->wrapper_type == MONO_WRAPPER_DYNAMIC_METHOD ||
+					method->wrapper_type == MONO_WRAPPER_SYNCHRONIZED) {
 				handle = mono_method_get_wrapper_data (method, n);
 				handle_class = mono_method_get_wrapper_data (method, n + 1);
 				if (handle_class == mono_defaults.typehandle_class)
@@ -8796,7 +8798,9 @@
 					g_assert_not_reached ();
 			}
 
-			if (cfg->opt & MONO_OPT_SHARED) {
+			if ((cfg->opt & MONO_OPT_SHARED) &&
+					method->wrapper_type != MONO_WRAPPER_DYNAMIC_METHOD &&
+					method->wrapper_type != MONO_WRAPPER_SYNCHRONIZED) {
 				int temp;
 				MonoInst *res, *store, *addr, *vtvar, *iargs [3];
 				int method_context_used;
