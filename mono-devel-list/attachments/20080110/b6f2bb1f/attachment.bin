Index: Mono.Unix.Native/Stdlib.cs
===================================================================
--- Mono.Unix.Native/Stdlib.cs	(revision 92060)
+++ Mono.Unix.Native/Stdlib.cs	(working copy)
@@ -31,6 +31,9 @@
 using System.IO;
 using System.Runtime.InteropServices;
 using System.Text;
+using System.Threading;
+
+using Mono.Unix;
 using Mono.Unix.Native;
 
 namespace Mono.Unix.Native {
@@ -359,7 +362,7 @@
 	//        This is the case for using NativeConvert, which will throw an
 	//        exception if an invalid/unsupported value is used.
 	//
-	public class Stdlib
+	public unsafe class Stdlib
 	{
 		internal const string LIBC = "msvcrt";
 		internal const string MPH  = "MonoPosixHelper";
@@ -437,7 +440,7 @@
 		[CLSCompliant (false)]
 		public static readonly SignalHandler SIG_IGN = new SignalHandler (_IgnoreHandler);
 
-		private static readonly SignalHandler[] registered_signals;
+		internal static readonly SignalHandler[] registered_signals;
 
 		static Stdlib ()
 		{
@@ -445,37 +448,35 @@
 			registered_signals = new SignalHandler [(int) signals.GetValue (signals.Length-1)];
 		}
 
-		[DllImport (LIBC, CallingConvention=CallingConvention.Cdecl,
-				SetLastError=true, EntryPoint="signal")]
+		[DllImport (MPH, CallingConvention=CallingConvention.Cdecl,
+				SetLastError=true, EntryPoint="Mono_Posix_Stdlib_signal")]
 		private static extern IntPtr sys_signal (int signum, SignalHandler handler);
 
-		[DllImport (LIBC, CallingConvention=CallingConvention.Cdecl,
-				SetLastError=true, EntryPoint="signal")]
+		[DllImport (MPH, CallingConvention=CallingConvention.Cdecl,
+				SetLastError=true, EntryPoint="Mono_Posix_Stdlib_signal")]
 		private static extern IntPtr sys_signal (int signum, IntPtr handler);
 
 		[CLSCompliant (false)]
 		public static SignalHandler signal (Signum signum, SignalHandler handler)
 		{
+			InitSignalSupport ();
+
 			int _sig = NativeConvert.FromSignum (signum);
 
-			Delegate[] handlers = handler.GetInvocationList ();
-			for (int i = 0; i < handlers.Length; ++i) {
-				Marshal.Prelink (handlers [i].Method);
-			}
-
+			IntPtr r;
 			lock (registered_signals) {
 				registered_signals [(int) signum] = handler;
+
+				if (handler == SIG_DFL)
+					r = sys_signal (_sig, _SIG_DFL);
+				else if (handler == SIG_ERR)
+					r = sys_signal (_sig, _SIG_ERR);
+				else if (handler == SIG_IGN)
+					r = sys_signal (_sig, _SIG_IGN);
+				else
+					r = sys_signal (_sig, handler);
 			}
 
-			IntPtr r;
-			if (handler == SIG_DFL)
-				r = sys_signal (_sig, _SIG_DFL);
-			else if (handler == SIG_ERR)
-				r = sys_signal (_sig, _SIG_ERR);
-			else if (handler == SIG_IGN)
-				r = sys_signal (_sig, _SIG_IGN);
-			else
-				r = sys_signal (_sig, handler);
 			return TranslateHandler (r);
 		}
 
@@ -494,6 +495,45 @@
 #endif
 		}
 
+		[DllImport (MPH, CallingConvention=CallingConvention.Cdecl,
+				SetLastError=true, EntryPoint="_mph_set_signal_write_fd")]
+		private static extern void set_signal_write_fd (int signum);
+
+		static object signal_dispatcher;
+		static int    signal_read_fd;
+
+		private static void InitSignalSupport ()
+		{
+			if (Path.DirectorySeparatorChar == '\\')
+				return;
+
+			if (signal_dispatcher == null) {
+				object c = new Thread (SignalDispatcher);
+				Thread.MemoryBarrier ();
+				while (Interlocked.CompareExchange (ref signal_dispatcher, c, null) == null) {
+					int writing;
+					if (Syscall.pipe (out signal_read_fd, out writing) < 0)
+						throw UnixMarshal.CreateExceptionForLastError ();
+					set_signal_write_fd (writing);
+					Thread _c = (Thread) c;
+					_c.IsBackground = true;
+					_c.Name = "Mono.Unix.Native Signal Dispatcher";
+					_c.Start ();
+				}
+				Thread.MemoryBarrier ();
+			}
+		}
+
+		private static unsafe void SignalDispatcher ()
+		{
+			byte c;
+			while (Syscall.read (signal_read_fd, &c, 1) >= 1) {
+				SignalHandler h = registered_signals [c];
+				if (h != null)
+					h (c);
+			}
+		}
+
 		[DllImport (LIBC, CallingConvention=CallingConvention.Cdecl, EntryPoint="raise")]
 		private static extern int sys_raise (int sig);
 
Index: Mono.Unix.Native/ChangeLog
===================================================================
--- Mono.Unix.Native/ChangeLog	(revision 92274)
+++ Mono.Unix.Native/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2008-01-09  Jonathan Pryor  <jpryor@novell.com>
+
+	* Stdlib.cs: Update Stdlib.signal() so that it's safe; see also: 
+	  http://lists.ximian.com/pipermail/mono-devel-list/2008-January/026501.html
+	  http://lists.ximian.com/pipermail/mono-devel-list/2008-January/026503.html
+
 2008-01-05  Jonathan Pryor  <jonpryor@vt.edu>
 
 	* Syscall.cs: Add ST_NOEXEC, ST_REMOUNT, ST_BIND to MountFlags.  Patch from
Index: Mono.Posix.dll.sources
===================================================================
--- Mono.Posix.dll.sources	(revision 92060)
+++ Mono.Posix.dll.sources	(working copy)
@@ -25,6 +25,7 @@
 ./Mono.Unix/UnixPath.cs
 ./Mono.Unix/UnixPipes.cs
 ./Mono.Unix/UnixProcess.cs
+./Mono.Unix/UnixSignal.cs
 ./Mono.Unix/UnixStream.cs
 ./Mono.Unix/UnixSymbolicLinkInfo.cs
 ./Mono.Unix/UnixUserInfo.cs
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 92060)
+++ ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2008-01-10  Jonathan Pryor  <jpryor@novell.com>
+
+	* Mono.Posix.dll.sources: Add Mono.Unix/UnixSignal.cs.
+
 2006-10-24  Jonathan Pryor  <jonpryor@vt.edu>
 
 	* Makefile: Don't build make-map.exe.
Index: Mono.Unix/UnixSignal.cs
===================================================================
--- Mono.Unix/UnixSignal.cs	(revision 0)
+++ Mono.Unix/UnixSignal.cs	(revision 0)
@@ -0,0 +1,171 @@
+//
+// Mono.Unix/UnixSignal.cs
+//
+// Authors:
+//   Jonathan Pryor (jpryor@novell.com)
+//
+// (C) 2007 Novell, Inc.
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Runtime.InteropServices;
+using System.Threading;
+
+using Mono.Unix.Native;
+
+namespace Mono.Unix {
+	public class UnixSignal : WaitHandle {
+		private Signum signum;
+		private int _signum;
+		private IntPtr signal_info;
+
+		public UnixSignal (Signum signum)
+		{
+			this.signum = signum;
+			this._signum = NativeConvert.FromSignum (signum);
+			lock (Stdlib.registered_signals) {
+				this.signal_info = install (_signum);
+			}
+			if (this.signal_info == IntPtr.Zero) {
+				throw new ArgumentException ("Unable to handle signal", "signum");
+			}
+		}
+
+		public Signum Signum {
+			get { return signum; }
+		}
+
+		[DllImport (Stdlib.MPH, CallingConvention=CallingConvention.Cdecl,
+				EntryPoint="Mono_Unix_UnixSignal_install")]
+		private static extern IntPtr install (int signum);
+
+		[DllImport (Stdlib.MPH, CallingConvention=CallingConvention.Cdecl,
+				EntryPoint="Mono_Unix_UnixSignal_uninstall")]
+		private static extern void uninstall (int signum);
+
+		private void AssertValid ()
+		{
+			if (signal_info == IntPtr.Zero)
+				throw new ObjectDisposedException (GetType().FullName);
+		}
+
+		private unsafe SignalInfo* Info {
+			get {return (SignalInfo*) signal_info;}
+		}
+
+		public bool IsSet {
+			get {
+				AssertValid ();
+				return Count > 0;
+			}
+		}
+
+		public unsafe bool Reset ()
+		{
+			AssertValid ();
+			int n = Info->count;
+			Info->count = 0;
+			return n != 0;
+		}
+
+		public unsafe int Count {
+			get {return Info->count;}
+			set {Info->count = value;}
+		}
+
+		[Map]
+		struct SignalInfo {
+			public int signum, count, write_fd;
+			public IntPtr handler;
+		}
+
+		#region WaitHandle overrides
+		protected unsafe override void Dispose (bool disposing)
+		{
+			if (signal_info == IntPtr.Zero)
+				return;
+			lock (Stdlib.registered_signals) {
+				uninstall (_signum);
+			}
+			signal_info = IntPtr.Zero;
+		}
+
+		public override bool WaitOne ()
+		{
+			return WaitOne (-1, false);
+		}
+
+		public override bool WaitOne (TimeSpan timeout, bool exitContext)
+		{
+			AssertValid ();
+			long ms = (long) timeout.TotalMilliseconds;
+			if (ms < -1 || ms > Int32.MaxValue)
+				throw new ArgumentOutOfRangeException ("timeout");
+			return WaitOne ((int) ms, exitContext);
+		}
+
+		public unsafe override bool WaitOne (int millisecondsTimeout, bool exitContext)
+		{
+			AssertValid ();
+			if (exitContext)
+				throw new InvalidOperationException ("exitContext is not supported");
+			if (millisecondsTimeout < -1)
+				throw new ArgumentOutOfRangeException ("millisecondsTimeout");
+			int read, write;
+			bool close = true;
+			read = write = -1;
+			try {
+				if (Syscall.pipe (out read, out write) < 0) {
+					close = false;
+					throw UnixMarshal.CreateExceptionForLastError ();
+				}
+				Pollfd[] fds  = new Pollfd[1];
+				fds[0].fd     = read;
+				fds[0].events = PollEvents.POLLIN;
+				if (IsSet)
+					return true;
+				Info->write_fd = write;
+				int r = Syscall.poll (fds, 1, millisecondsTimeout);
+				if (r == -1 && Stdlib.GetLastError () != Errno.EINTR) {
+					return false;
+				}
+				else
+					r = Syscall.poll (fds, 1, 0);
+				if (r > 0) {
+					byte c = 0;
+					Syscall.read (read, &c, 1);
+					return true;
+				}
+				return false;
+			}
+			finally {
+				if (close) {
+					Info->write_fd = 0;
+					Syscall.close (read);
+					Syscall.close (write);
+				}
+			}
+		}
+		#endregion
+	}
+}
+
Index: Mono.Unix/ChangeLog
===================================================================
--- Mono.Unix/ChangeLog	(revision 92060)
+++ Mono.Unix/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2008-01-10  Jonathan Pryor  <jpryor@novell.com>
+
+	* UnixSignal.cs: Added; Polling and blocking based Unix signal mechanism.
+	  http://lists.ximian.com/pipermail/mono-devel-list/2008-January/026501.html
+
 2007-12-17  Jonathan Pryor  <jpryor@novell.com>
 
 	* UnixEnvironment.cs: Update MachineName property accesor to use uname(2)
