Index: mono/mono/metadata/ChangeLog
===================================================================
--- mono/mono/metadata/ChangeLog	(revision 74470)
+++ mono/mono/metadata/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2007-03-16  Jonathan Chambers  <joncham@gmail.com>
+
+	* marshal.c: Add support for PreserveSigAttribute. 
+	
+	Code is contributed under MIT/X11 license.
+
 2007-03-14  Zoltan Varga  <vargaz@gmail.com>
 
 	* process.c: Fix endianness issues. Fixes #81126.
Index: mono/mono/metadata/marshal.c
===================================================================
--- mono/mono/metadata/marshal.c	(revision 74470)
+++ mono/mono/metadata/marshal.c	(working copy)
@@ -276,22 +276,24 @@
 cominterop_get_ccw_object (MonoCCWInterface* ccw_entry, gboolean verify);
 
 /**
- * signature_cominterop:
- * @image: a image
- * @sig: managed method signature
+ * cominterop_method_signature:
+ * @method: a method
  *
  * Returns: the corresponding unmanaged method signature for a managed COM 
  * method.
  */
 static MonoMethodSignature*
-signature_cominterop (MonoImage *image, MonoMethodSignature *sig)
+cominterop_method_signature (MonoMethod* method)
 {
 	MonoMethodSignature *res;
+	MonoImage *image = method->klass->image;
+	MonoMethodSignature *sig = mono_method_signature (method);
+	gboolean preserve_sig = method->iflags & METHOD_IMPL_ATTRIBUTE_PRESERVE_SIG;
 	int sigsize;
 	int i;
 	int param_count = sig->param_count + 1; // convert this arg into IntPtr arg
 
-	if (!MONO_TYPE_IS_VOID (sig->ret))
+	if (!preserve_sig &&!MONO_TYPE_IS_VOID (sig->ret))
 		param_count++;
 
 	sigsize = sizeof (MonoMethodSignature) + ((param_count - MONO_ZERO_LEN_ARRAY) * sizeof (MonoType *));
@@ -307,13 +309,21 @@
 	// first arg is interface pointer
 	res->params[0] = &mono_defaults.int_class->byval_arg;
 
-	// last arg is return type
-	if (!MONO_TYPE_IS_VOID (sig->ret)) {
-		res->params[param_count-1] = mono_metadata_type_dup_mp (image, sig->ret);
-		res->params[param_count-1]->byref = 1;
-		res->params[param_count-1]->attrs = PARAM_ATTRIBUTE_OUT;
+	if (preserve_sig) {
+		res->ret = sig->ret;
 	}
+	else {
+		// last arg is return type
+		if (!MONO_TYPE_IS_VOID (sig->ret)) {
+			res->params[param_count-1] = mono_metadata_type_dup_mp (image, sig->ret);
+			res->params[param_count-1]->byref = 1;
+			res->params[param_count-1]->attrs = PARAM_ATTRIBUTE_OUT;
+		}
 
+		// return type is always int32 (HRESULT)
+		res->ret = &mono_defaults.int32_class->byval_arg;
+	}
+
 	// no pinvoke
 	res->pinvoke = FALSE;
 
@@ -323,9 +333,6 @@
 	// set param_count
 	res->param_count = param_count;
 
-	// return type is always int32 (HRESULT)
-	res->ret = &mono_defaults.int32_class->byval_arg;
-
 	// STDCALL on windows, CDECL everywhere else to work with XPCOM and MainWin COM
 #ifdef PLATFORM_WIN32
 	res->call_convention = MONO_CALL_STDCALL;
@@ -3365,7 +3372,7 @@
 
 	// create unmanaged wrapper
 	mb_native = mono_mb_new (method->klass, method->name, MONO_WRAPPER_MANAGED_TO_NATIVE);
-	sig_native = signature_cominterop (method->klass->image, sig);
+	sig_native = cominterop_method_signature (method);
 
 	mspecs = g_new (MonoMarshalSpec*, sig_native->param_count+1);
 	memset (mspecs, 0, sizeof(MonoMarshalSpec*)*(sig_native->param_count+1));
@@ -3379,11 +3386,13 @@
 	// first arg is IntPtr for interface
 	mspecs[1] = NULL;
 
-	// move return spec to last param
-	if (!MONO_TYPE_IS_VOID (sig->ret))
-		mspecs[sig_native->param_count] = mspecs[0];
+	if (!(method->iflags & METHOD_IMPL_ATTRIBUTE_PRESERVE_SIG)) {
+		// move return spec to last param
+		if (!MONO_TYPE_IS_VOID (sig->ret))
+			mspecs[sig_native->param_count] = mspecs[0];
 
-	mspecs[0] = NULL;
+		mspecs[0] = NULL;
+	}
 
 	mono_marshal_emit_native_wrapper(mono_defaults.corlib, mb_native, sig_native, piinfo, mspecs, piinfo->addr);
 
@@ -3444,15 +3453,14 @@
 			static MonoMethod * ThrowExceptionForHR = NULL;
 			static MonoMethod * GetInterface = NULL;
 			MonoMethod *adjusted_method;
-			int hr;
 			int retval = 0;
 			int ptr_this;
 			int i;
+			gboolean preserve_sig = method->iflags & METHOD_IMPL_ATTRIBUTE_PRESERVE_SIG;
 			if (!GetInterface)
 				GetInterface = mono_class_get_method_from_name (mono_defaults.com_object_class, "GetInterface", 1);
 
 			// add local variables
-			hr = mono_mb_add_local (mb, &mono_defaults.int32_class->byval_arg);
 			ptr_this = mono_mb_add_local (mb, &mono_defaults.int_class->byval_arg);
 			if (!MONO_TYPE_IS_VOID (sig->ret))
 				retval =  mono_mb_add_local (mb, sig->ret);
@@ -3473,24 +3481,22 @@
 				mono_mb_emit_ldarg (mb, i);
 
 			// push managed return value as byref last argument
-			if (!MONO_TYPE_IS_VOID (sig->ret))
+			if (!MONO_TYPE_IS_VOID (sig->ret) && !preserve_sig)
 				mono_mb_emit_ldloc_addr (mb, retval);
 			
 			adjusted_method = cominterop_get_native_wrapper_adjusted (method);
 			mono_mb_emit_managed_call (mb, adjusted_method, NULL);
 
-			// store HRESULT to check
-			mono_mb_emit_stloc (mb, hr);
+			if (!preserve_sig) {
+				if (!ThrowExceptionForHR)
+					ThrowExceptionForHR = mono_class_get_method_from_name (mono_defaults.marshal_class, "ThrowExceptionForHR", 1);
+				mono_mb_emit_managed_call (mb, ThrowExceptionForHR, NULL);
 
-			if (!ThrowExceptionForHR)
-				ThrowExceptionForHR = mono_class_get_method_from_name (mono_defaults.marshal_class, "ThrowExceptionForHR", 1);
-			mono_mb_emit_ldloc (mb, hr);
-			mono_mb_emit_managed_call (mb, ThrowExceptionForHR, NULL);
+				// load return value managed is expecting
+				if (!MONO_TYPE_IS_VOID (sig->ret))
+					mono_mb_emit_ldloc (mb, retval);
+			}
 
-			// load return value managed is expecting
-			if (!MONO_TYPE_IS_VOID (sig->ret))
-				mono_mb_emit_ldloc (mb, retval);
-
 			mono_mb_emit_byte (mb, CEE_RET);
 		}
 		
@@ -11375,6 +11381,7 @@
 				MonoMethod *method = iface->methods [i];
 				MonoMethodSignature* sig_adjusted;
 				MonoMethodSignature* sig = mono_method_signature (method);
+				gboolean preserve_sig = method->iflags & METHOD_IMPL_ATTRIBUTE_PRESERVE_SIG;
 
 
 				mb = mono_mb_new (iface, method->name, MONO_WRAPPER_NATIVE_TO_MANAGED);
@@ -11393,7 +11400,7 @@
 				mspecs [1] = NULL;
 
 				/* move return spec to last param */
-				if (!MONO_TYPE_IS_VOID (sig->ret))
+				if (!preserve_sig && !MONO_TYPE_IS_VOID (sig->ret))
 					mspecs [sig_adjusted->param_count] = mspecs [0];
 
 				mspecs [0] = NULL;
@@ -11515,6 +11522,7 @@
 	int pos_leave;
 	int hr;
 	int i;
+	gboolean preserve_sig = method->iflags & METHOD_IMPL_ATTRIBUTE_PRESERVE_SIG;
 
 	if (!get_hr_for_exception)
 		get_hr_for_exception = mono_class_get_method_from_name (mono_defaults.marshal_class, "GetHRForException", -1);
@@ -11524,7 +11532,7 @@
 	/* create unmanaged wrapper */
 	mb = mono_mb_new (method->klass, method->name, MONO_WRAPPER_COMINTEROP);
 
-	sig_native = signature_cominterop (method->klass->image, sig);
+	sig_native = cominterop_method_signature (method);
 
 	mspecs = g_new0 (MonoMarshalSpec*, sig_native->param_count+1);
 
@@ -11538,19 +11546,21 @@
 	mspecs [1] = NULL;
 
 	/* move return spec to last param */
-	if (!MONO_TYPE_IS_VOID (sig->ret))
+	if (!preserve_sig && !MONO_TYPE_IS_VOID (sig->ret))
 		mspecs [sig_native->param_count] = mspecs [0];
 
 	mspecs [0] = NULL;
 
-	hr = mono_mb_add_local (mb, &mono_defaults.int32_class->byval_arg);
+	if (!preserve_sig) {
+		hr = mono_mb_add_local (mb, &mono_defaults.int32_class->byval_arg);
 
-	/* try */
+		/* try */
+		main_clause = g_new0 (MonoExceptionClause, 1);
+		main_clause->try_offset = mb->pos;
+	}
 
-	main_clause = g_new0 (MonoExceptionClause, 1);
-	main_clause->try_offset = mb->pos;
-
-	if (!MONO_TYPE_IS_VOID (sig->ret))
+	/* load last param to store result if not preserve_sig and not void */
+	if (!preserve_sig && !MONO_TYPE_IS_VOID (sig->ret))
 		mono_mb_emit_ldarg (mb, sig_native->param_count-1);
 
 	/* the CCW -> object conversion */
@@ -11563,29 +11573,31 @@
 
 	mono_mb_emit_managed_call (mb, method, NULL);
 
-	/* store result if we have one */
-	if (!MONO_TYPE_IS_VOID (sig->ret))
-		mono_mb_emit_byte (mb, CEE_STIND_REF);
+	if (!preserve_sig) {
+		/* store result if not preserve_sig and we have one */
+		if (!MONO_TYPE_IS_VOID (sig->ret))
+			mono_mb_emit_byte (mb, mono_type_to_stind (sig->ret));
 
-	pos_leave = mono_mb_emit_branch (mb, CEE_LEAVE);
+		pos_leave = mono_mb_emit_branch (mb, CEE_LEAVE);
 
-	/* Main exception catch */
-	main_clause->flags = MONO_EXCEPTION_CLAUSE_NONE;
-	main_clause->try_len = mb->pos - main_clause->try_offset;
-	main_clause->data.catch_class = mono_defaults.object_class;
-	
-	/* handler code */
-	main_clause->handler_offset = mb->pos;
-	mono_mb_emit_managed_call (mb, get_hr_for_exception, NULL);
-	mono_mb_emit_stloc (mb, hr);
-	mono_mb_emit_branch (mb, CEE_LEAVE);
-	main_clause->handler_len = mb->pos - main_clause->handler_offset;
-	/* end catch */
+		/* Main exception catch */
+		main_clause->flags = MONO_EXCEPTION_CLAUSE_NONE;
+		main_clause->try_len = mb->pos - main_clause->try_offset;
+		main_clause->data.catch_class = mono_defaults.object_class;
+		
+		/* handler code */
+		main_clause->handler_offset = mb->pos;
+		mono_mb_emit_managed_call (mb, get_hr_for_exception, NULL);
+		mono_mb_emit_stloc (mb, hr);
+		mono_mb_emit_branch (mb, CEE_LEAVE);
+		main_clause->handler_len = mb->pos - main_clause->handler_offset;
+		/* end catch */
 
-	mono_mb_patch_addr (mb, pos_leave, mb->pos - (pos_leave + 4));
+		mono_mb_patch_addr (mb, pos_leave, mb->pos - (pos_leave + 4));
 
-	/* FIXME: need to emit try/catch block and return failure code if exception */
-	mono_mb_emit_ldloc (mb, hr);
+		mono_mb_emit_ldloc (mb, hr);
+	}
+
 	mono_mb_emit_byte (mb, CEE_RET);
 
 	mono_loader_lock ();
@@ -11601,9 +11613,11 @@
 			mono_metadata_free_marshal_spec (mspecs [i]);
 	g_free (mspecs);
 
-	header = ((MonoMethodNormal *)res)->header;
-	header->num_clauses = 1;
-	header->clauses = main_clause;
+	if (!preserve_sig) {
+		header = ((MonoMethodNormal *)res)->header;
+		header->num_clauses = 1;
+		header->clauses = main_clause;
+	}
 
 	return res;
 }
Index: mono/mono/tests/cominterop.cs
===================================================================
--- mono/mono/tests/cominterop.cs	(revision 74470)
+++ mono/mono/tests/cominterop.cs	(working copy)
@@ -208,6 +208,9 @@
 	[DllImport ("libtest")]
 	public static extern int mono_test_marshal_ccw_itest ([MarshalAs (UnmanagedType.Interface)]ITest itest);
 
+	[DllImport ("libtest")]
+	public static extern int mono_test_marshal_ccw_itest ([MarshalAs (UnmanagedType.Interface)]ITestPresSig itest);
+
 	public static int Main() {
 
         bool isWindows = !(((int)Environment.OSVersion.Platform == 4) || 
@@ -398,6 +401,12 @@
 			if (pUnk != iunknown)
 				return 171;
 
+			if (TestITest (itest) != 0)
+				return 172;
+
+			if (TestITestPresSig (itest as ITestPresSig) != 0)
+				return 173;
+
 			#endregion // Runtime Callable Wrapper Tests
 
 			#region COM Callable Wrapper Tests
@@ -409,6 +418,10 @@
 			if (test.Status != 0)
 				return 200;
 
+			ManagedTestPresSig test_pres_sig = new ManagedTestPresSig ();
+
+			mono_test_marshal_ccw_itest (test_pres_sig);
+
 			#endregion // COM Callable Wrapper Tests
 		}
 
@@ -455,6 +468,153 @@
 		void ITestOut ([MarshalAs (UnmanagedType.Interface)]out ITest val);
 	}
 
+	[ComImport ()]
+	[Guid ("00000000-0000-0000-0000-000000000001")]
+	[InterfaceType (ComInterfaceType.InterfaceIsIUnknown)]
+	public interface ITestPresSig
+	{
+		// properties need to go first since mcs puts them there
+		ITestPresSig Test
+		{
+			[return: MarshalAs (UnmanagedType.Interface)]
+			[MethodImpl (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime), DispId (5242884)]
+			get;
+		}
+
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int SByteIn (sbyte val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int ByteIn (byte val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int ShortIn (short val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int UShortIn (ushort val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int IntIn (int val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int UIntIn (uint val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int LongIn (long val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int ULongIn (ulong val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int FloatIn (float val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int DoubleIn (double val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int ITestIn ([MarshalAs (UnmanagedType.Interface)]ITestPresSig val);
+		[MethodImplAttribute (MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
+		[PreserveSig ()]
+		int ITestOut ([MarshalAs (UnmanagedType.Interface)]out ITestPresSig val);
+	}
+
+	public class ManagedTestPresSig : ITestPresSig
+	{		// properties need to go first since mcs puts them there
+		public ITestPresSig Test
+		{
+			get
+			{
+				return new ManagedTestPresSig ();
+			}
+		}
+
+		public int SByteIn (sbyte val)
+		{
+			if (val != -100)
+				return 1;
+			return 0;
+		}
+
+		public int ByteIn (byte val)
+		{
+			if (val != 100)
+				return 2;
+			return 0;
+		}
+
+		public int ShortIn (short val)
+		{
+			if (val != -100)
+				return 3;
+			return 0;
+		}
+
+		public int UShortIn (ushort val)
+		{
+			if (val != 100)
+				return 4;
+			return 0;
+		}
+
+		public int IntIn (int val)
+		{
+			if (val != -100)
+				return 5;
+			return 0;
+		}
+
+		public int UIntIn (uint val)
+		{
+			if (val != 100)
+				return 6;
+			return 0;
+		}
+
+		public int LongIn (long val)
+		{
+			if (val != -100)
+				return 7;
+			return 0;
+		}
+
+		public int ULongIn (ulong val)
+		{
+			if (val != 100)
+				return 8;
+			return 0;
+		}
+
+		public int FloatIn (float val)
+		{
+			if (Math.Abs (val - 3.14f) > .000001)
+				return 9;
+			return 0;
+		}
+
+		public int DoubleIn (double val)
+		{
+			if (Math.Abs (val - 3.14f) > .000001)
+				return 10;
+			return 0;
+		}
+
+		public int ITestIn ([MarshalAs (UnmanagedType.Interface)]ITestPresSig val)
+		{
+			if (val == null)
+				return 11;
+			if (null == val as ManagedTestPresSig)
+				return 12;
+			return 0;
+		}
+
+		public int ITestOut ([MarshalAs (UnmanagedType.Interface)]out ITestPresSig val)
+		{
+			val = new ManagedTestPresSig ();
+			return 0;
+		}
+	}
+
 	public class ManagedTest : ITest
 	{
 		private int status = 0;
@@ -666,4 +826,57 @@
 		}
 		return 0;
 	}
+
+	public static int TestITest (ITest itest)
+	{
+		try {
+			ITest itest2;
+			itest.SByteIn (-100);
+			itest.ByteIn (100);
+			itest.ShortIn (-100);
+			itest.UShortIn (100);
+			itest.IntIn (-100);
+			itest.UIntIn (100);
+			itest.LongIn (-100);
+			itest.ULongIn (100);
+			itest.FloatIn (3.14f);
+			itest.DoubleIn (3.14);
+			itest.ITestIn (itest);
+			itest.ITestOut (out itest2);
+		}
+		catch (Exception ex) {
+			return 1;
+		}
+		return 0;
+	}
+
+	public static int TestITestPresSig (ITestPresSig itest)
+	{
+		ITestPresSig itest2;
+		if (itest.SByteIn (-100) != 0)
+			return 1000;
+		if (itest.ByteIn (100) != 0)
+			return 1001;
+		if (itest.ShortIn (-100) != 0)
+			return 1002;
+		if (itest.UShortIn (100) != 0)
+			return 1003;
+		if (itest.IntIn (-100) != 0)
+			return 1004;
+		if (itest.UIntIn (100) != 0)
+			return 1005;
+		if (itest.LongIn (-100) != 0)
+			return 1006;
+		if (itest.ULongIn (100) != 0)
+			return 1007;
+		if (itest.FloatIn (3.14f) != 0)
+			return 1008;
+		if (itest.DoubleIn (3.14) != 0)
+			return 1009;
+		if (itest.ITestIn (itest) != 0)
+			return 1010;
+		if (itest.ITestOut (out itest2) != 0)
+			return 1011;
+		return 0;
+	}
 }
Index: mono/mono/tests/ChangeLog
===================================================================
--- mono/mono/tests/ChangeLog	(revision 74470)
+++ mono/mono/tests/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2007-03-16  Jonathan Chambers  <joncham@gmail.com>
+
+	* libtest.c: Add tests for PreserveSigAttribute.
+	* cominterop.cs: Add tests for PreserveSigAttribute.
+	
+	Code is contributed under MIT/X11 license.
+
 2007-02-19  Massimiliano Mantione  <massi@ximian.com>
 	* iface7.cs, Makefile.am: Added test for bug 75903.
 
Index: mono/mono/tests/libtest.c
===================================================================
--- mono/mono/tests/libtest.c	(revision 74470)
+++ mono/mono/tests/libtest.c	(working copy)
@@ -2706,29 +2706,46 @@
 {
 	int hr = 0;
 	MonoComObject* pTest;
-	MonoComObject* pTest2;
 
 	if (!pUnk)
 		return 1;
 
 	hr = pUnk->vtbl->SByteIn (pUnk, -100);
+	if (hr != 0)
+		return 2;
 	hr = pUnk->vtbl->ByteIn (pUnk, 100);
+	if (hr != 0)
+		return 3;
 	hr = pUnk->vtbl->ShortIn (pUnk, -100);
+	if (hr != 0)
+		return 4;
 	hr = pUnk->vtbl->UShortIn (pUnk, 100);
+	if (hr != 0)
+		return 5;
 	hr = pUnk->vtbl->IntIn (pUnk, -100);
+	if (hr != 0)
+		return 6;
 	hr = pUnk->vtbl->UIntIn (pUnk, 100);
+	if (hr != 0)
+		return 7;
 	hr = pUnk->vtbl->LongIn (pUnk, -100);
+	if (hr != 0)
+		return 8;
 	hr = pUnk->vtbl->ULongIn (pUnk, 100);
+	if (hr != 0)
+		return 9;
 	hr = pUnk->vtbl->FloatIn (pUnk, 3.14f);
+	if (hr != 0)
+		return 10;
 	hr = pUnk->vtbl->DoubleIn (pUnk, 3.14);
+	if (hr != 0)
+		return 11;
 	hr = pUnk->vtbl->ITestIn (pUnk, pUnk);
-
+	if (hr != 0)
+		return 12;
 	hr = pUnk->vtbl->ITestOut (pUnk, &pTest);
-
-	//hr = pUnk->vtbl->get_ITest (pUnk, &pTest2);
-
 	if (hr != 0)
-		return 2;
+		return 13;
 
 	return 0;
 }