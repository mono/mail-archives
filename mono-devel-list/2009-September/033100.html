<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Race condition when disposing a Socket when another	thread is blocking in Accept()?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Race%20condition%20when%20disposing%20a%20Socket%20when%20another%0A%09thread%20is%20blocking%20in%20Accept%28%29%3F&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033097.html">
   <LINK REL="Next"  HREF="033101.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Race condition when disposing a Socket when another	thread is blocking in Accept()?</H1>
    <B>Oskar Berggren</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Race%20condition%20when%20disposing%20a%20Socket%20when%20another%0A%09thread%20is%20blocking%20in%20Accept%28%29%3F&In-Reply-To="
       TITLE="[Mono-dev] Race condition when disposing a Socket when another	thread is blocking in Accept()?">oskar.berggren at gmail.com
       </A><BR>
    <I>Wed Sep 23 16:02:22 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="033097.html">[Mono-dev] How to detect hardware platform - ex: list of	platform-differences
</A></li>
        <LI>Next message: <A HREF="033101.html">[Mono-dev] [PATCH] Mono.Zeroconf Bonjour vs. Endianness
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33100">[ date ]</a>
              <a href="thread.html#33100">[ thread ]</a>
              <a href="subject.html#33100">[ subject ]</a>
              <a href="author.html#33100">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I have a TcpListener and a thread that blocks in AcceptSocket(),
corresponding to Socket.Accept().

Another thread now calls Stop() on the listener, which causes the
socket to be disposed. I believe the intention is that the thread
blocking on Accept() should now get a SocketException with errorcode =
interrupted. This is based on reading the code, and this does happen
sometimes. However, sometimes, quite often, I get this
ThreadAbortException instead:

System.Threading.ThreadAbortException: Thread was being aborted
  at System.Net.Sockets.SocketException..ctor (Int32 error) [0x00007]
in /home/oskar/mono24/mono-2.4.2.3/mono-2.4.2.3/mcs/class/System/System.Net.Sockets/SocketException.cs:54
  at System.Net.Sockets.Socket.Accept () [0x000b8] in
/home/oskar/mono24/mono-2.4.2.3/mono-2.4.2.3/mcs/class/System/System.Net.Sockets/Socket.cs:1434
  at System.Net.Sockets.TcpListener.AcceptSocket () [0x00016] in
/home/oskar/mono24/mono-2.4.2.3/mono-2.4.2.3/mcs/class/System/System.Net.Sockets/TcpListener.cs:193
  at XXXX.TriggerServer.Run_impl () [0x0003b] in MYCODE

BTW, Socket.cs:1434 above seems bogus... There is no call to
SocketException..ctor on that line. Closest one, and only one in
Accept(), is on line 1426.

Looking at the code in Socket.Accept() it is built to handle a
ThreadAbortException by preventing the abort and generating a
SocketException instead. But this does not seem to work reliably!

Is it possible there is a race condition here? That is: Can
Close_internal() in fact cause Accept_internal() to return (with an
error code) before Dispose() calls Abort() on blocking_thread?


This is an excerpt from public Socket Accept():

			blocking_thread = Thread.CurrentThread;
			try {
				sock = Accept_internal(socket, out error, blocking);
			} catch (ThreadAbortException) {
				if (disposed) {
#if !NET_2_1
					Thread.ResetAbort ();
#endif
					error = (int) SocketError.Interrupted;
				}
			} finally {
				blocking_thread = null;
			}

			if (error != 0)
				throw new SocketException (error);


And this is the Dispose():
		protected virtual void Dispose (bool explicitDisposing)
		{
			if (disposed)
				return;

			disposed = true;
			connected = false;
			if ((int) socket != -1) {
				int error;
				closed = true;
				IntPtr x = socket;
				socket = (IntPtr) (-1);
				Close_internal (x, out error);
				if (blocking_thread != null) {
					blocking_thread.Abort ();
					blocking_thread = null;
				}

				if (error != 0)
					throw new SocketException (error);
			}
		}



/Oskar
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033097.html">[Mono-dev] How to detect hardware platform - ex: list of	platform-differences
</A></li>
	<LI>Next message: <A HREF="033101.html">[Mono-dev] [PATCH] Mono.Zeroconf Bonjour vs. Endianness
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33100">[ date ]</a>
              <a href="thread.html#33100">[ thread ]</a>
              <a href="subject.html#33100">[ subject ]</a>
              <a href="author.html#33100">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
