<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Different behaviour deserializing	ISerializable trees Mono &lt;-&gt; .NET
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Different%20behaviour%20deserializing%0A%09ISerializable%20trees%20Mono%20%3C-%3E%20.NET&In-Reply-To=23BE0C16E0C22F48B3FB5B0BD6B5307B2790F3%40visdd003.devdd.vi.lan">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001869.html">
   <LINK REL="Next"  HREF="001871.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Different behaviour deserializing	ISerializable trees Mono &lt;-&gt; .NET</H1>
    <B>Lluis Sanchez</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Different%20behaviour%20deserializing%0A%09ISerializable%20trees%20Mono%20%3C-%3E%20.NET&In-Reply-To=23BE0C16E0C22F48B3FB5B0BD6B5307B2790F3%40visdd003.devdd.vi.lan"
       TITLE="[Mono-devel-list] Different behaviour deserializing	ISerializable trees Mono &lt;-&gt; .NET">lluis at ximian.com
       </A><BR>
    <I>Mon Aug 25 11:23:46 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="001869.html">[Mono-devel-list] Different behaviour deserializing ISerializable trees Mono &lt;-&gt; .NET
</A></li>
        <LI>Next message: <A HREF="001871.html">[Mono-devel-list] advice on portable UI coding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1870">[ date ]</a>
              <a href="thread.html#1870">[ thread ]</a>
              <a href="subject.html#1870">[ subject ]</a>
              <a href="author.html#1870">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi!

&gt;<i> Is this a bug or a feature or simply bad usage of serialization? ;-)
</I>&gt;<i> 
</I>
It is a bad usage of serialization :)

The order in wich objects are deserialized is not defined. When the
serialization constructor is called, all fields referencing other
objects are guaranteed to be set correctly. However, those objects may
not have been initialized yet. It means that you should not execute any
code that depend on the members of the referred objects.

If you really need to do so, your type should implement the interface
IDeserializationCallback. The interface method OnDeserialization will be
called when the whole object tree has been deserialized. That's where
you should build your hastable.

The different behavior of MS.NET and Mono are due to different
implementations of the serialization engine. Your sample might also fail
in MS.NET under other circumstances.

- Lluis

On dl, 2003-08-25 at 15:29, J&#195;&#182;rg Rosenkranz wrote:
&gt;<i> Hi all,
</I>&gt;<i> 
</I>&gt;<i> I have run into a problem serializing/deserializing classes which 
</I>&gt;<i> implement ISerializable.
</I>&gt;<i> 
</I>&gt;<i> I have two classes:
</I>&gt;<i> 1) A data holding class.
</I>&gt;<i> 2) A collection class for objects of class 1
</I>&gt;<i> 
</I>&gt;<i> Both classes implement ISerializable. The class 1 objects are 
</I>&gt;<i> stored in class 2 in a Hashtable internally. I want to restore key 
</I>&gt;<i> to object relation in the deserialization constructor of the 
</I>&gt;<i> collection class.
</I>&gt;<i> 
</I>&gt;<i> My problem is that the collection elements are deserialized *after* the 
</I>&gt;<i> collection class. When I access them in the constructor of class 2
</I>&gt;<i> they are empty.
</I>&gt;<i> 
</I>&gt;<i> You can try the attached sample. It doesn't use Hashtable but shows 
</I>&gt;<i> the different behaviour. Using Mono it prints:
</I>&gt;<i> 
</I>&gt;<i> ========== Serialization ==========
</I>&gt;<i> Serializing TestCollection...
</I>&gt;<i> 0 - Adding member: Value1=member1, Value2=test1 ...
</I>&gt;<i> 1 - Adding member: Value1=member2, Value2=test2 ...
</I>&gt;<i> 2 - Adding member: Value1=member3, Value2=test3 ...
</I>&gt;<i> TestCollection serialized.
</I>&gt;<i> Serializing TestMember: Value1=member3, Value2=test3 ...
</I>&gt;<i> TestMember serialized.
</I>&gt;<i> Serializing TestMember: Value1=member1, Value2=test1 ...
</I>&gt;<i> TestMember serialized.
</I>&gt;<i> Serializing TestMember: Value1=member2, Value2=test2 ...
</I>&gt;<i> TestMember serialized.
</I>&gt;<i> ========== Deserialization ==========
</I>&gt;<i> Deserializing TestCollection...
</I>&gt;<i> 0 - New deserialized member: Value1=, Value2= ...
</I>&gt;<i> 1 - New deserialized member: Value1=, Value2= ...
</I>&gt;<i> 2 - New deserialized member: Value1=, Value2= ...
</I>&gt;<i> Deserialized TestCollection.
</I>&gt;<i> Deserializing TestMember...
</I>&gt;<i> Deserialized TestMember: Value1=member3, Value2=test3
</I>&gt;<i> Deserializing TestMember...
</I>&gt;<i> Deserialized TestMember: Value1=member1, Value2=test1
</I>&gt;<i> Deserializing TestMember...
</I>&gt;<i> Deserialized TestMember: Value1=member2, Value2=test2
</I>&gt;<i> ========== Result ==========
</I>&gt;<i> 0: Value1=member1, Value2=test1
</I>&gt;<i> 1: Value1=member2, Value2=test2
</I>&gt;<i> 2: Value1=member3, Value2=test3
</I>&gt;<i> 
</I>&gt;<i> Running (and compiled too!!) under MS .NET:
</I>&gt;<i> 
</I>&gt;<i> ========== Serialization ==========
</I>&gt;<i> Serializing TestCollection...
</I>&gt;<i> 0 - Adding member: Value1=member1, Value2=test1 ...
</I>&gt;<i> 1 - Adding member: Value1=member2, Value2=test2 ...
</I>&gt;<i> 2 - Adding member: Value1=member3, Value2=test3 ...
</I>&gt;<i> TestCollection serialized.
</I>&gt;<i> Serializing TestMember: Value1=member1, Value2=test1 ...
</I>&gt;<i> TestMember serialized.
</I>&gt;<i> Serializing TestMember: Value1=member2, Value2=test2 ...
</I>&gt;<i> TestMember serialized.
</I>&gt;<i> Serializing TestMember: Value1=member3, Value2=test3 ...
</I>&gt;<i> TestMember serialized.
</I>&gt;<i> ========== Deserialization ==========
</I>&gt;<i> Deserializing TestMember...
</I>&gt;<i> Deserialized TestMember: Value1=member1, Value2=test1
</I>&gt;<i> Deserializing TestMember...
</I>&gt;<i> Deserialized TestMember: Value1=member2, Value2=test2
</I>&gt;<i> Deserializing TestMember...
</I>&gt;<i> Deserialized TestMember: Value1=member3, Value2=test3
</I>&gt;<i> Deserializing TestCollection...
</I>&gt;<i> 0 - New deserialized member: Value1=member1, Value2=test1 ...
</I>&gt;<i> 1 - New deserialized member: Value1=member2, Value2=test2 ...
</I>&gt;<i> 2 - New deserialized member: Value1=member3, Value2=test3 ...
</I>&gt;<i> Deserialized TestCollection.
</I>&gt;<i> ========== Result ==========
</I>&gt;<i> 0: Value1=member1, Value2=test1
</I>&gt;<i> 1: Value1=member2, Value2=test2
</I>&gt;<i> 2: Value1=member3, Value2=test3
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> As you can see the result is the same after deserialization
</I>&gt;<i> but not inside the constructor.
</I>&gt;<i> 
</I>&gt;<i> Is this a bug or a feature or simply bad usage of serialization? ;-)
</I>&gt;<i> 
</I>&gt;<i> And no, I can't serialize the Hashtable directly because then it
</I>&gt;<i> would be binary imcompatible between Mono and .NET.
</I>&gt;<i> 
</I>&gt;<i> Thanks in advance for any comments,
</I>&gt;<i> J&#195;&#182;rg
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001869.html">[Mono-devel-list] Different behaviour deserializing ISerializable trees Mono &lt;-&gt; .NET
</A></li>
	<LI>Next message: <A HREF="001871.html">[Mono-devel-list] advice on portable UI coding
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1870">[ date ]</a>
              <a href="thread.html#1870">[ thread ]</a>
              <a href="subject.html#1870">[ subject ]</a>
              <a href="author.html#1870">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
