<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Generic sharing: Good news, bad news, how to win big
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Generic%20sharing%3A%20Good%20news%2C%20bad%20news%2C%20how%20to%20win%20big&In-Reply-To=f54ff3e80804140758q63600fd6pf8961791eb056333%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027505.html">
   <LINK REL="Next"  HREF="027507.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Generic sharing: Good news, bad news, how to win big</H1>
    <B>Rodrigo Kumpera</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Generic%20sharing%3A%20Good%20news%2C%20bad%20news%2C%20how%20to%20win%20big&In-Reply-To=f54ff3e80804140758q63600fd6pf8961791eb056333%40mail.gmail.com"
       TITLE="[Mono-dev] Generic sharing: Good news, bad news, how to win big">kumpera at gmail.com
       </A><BR>
    <I>Mon Apr 14 11:26:40 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027505.html">[Mono-dev] Generic sharing: Good news, bad news, how to win big
</A></li>
        <LI>Next message: <A HREF="027507.html">[Mono-dev] Generic sharing: Good news, bad news, how to win big
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27506">[ date ]</a>
              <a href="thread.html#27506">[ thread ]</a>
              <a href="subject.html#27506">[ subject ]</a>
              <a href="author.html#27506">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hey Mark,

On Mon, Apr 14, 2008 at 11:58 AM, Mark Probst &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mark.probst at gmail.com</A>&gt; wrote:

&gt;<i> Hey Rodrigo!
</I>&gt;<i>
</I>&gt;<i> Thanks for the feedback!
</I>&gt;<i>
</I>&gt;<i> &gt; Isn't possible or better to do RGCTX free'ing at GC time? It would be
</I>&gt;<i> &gt; simpler, the hardest
</I>&gt;<i> &gt; part would be guarding against parking threads inside RGCTX related
</I>&gt;<i> code,
</I>&gt;<i> &gt; which can be done with
</I>&gt;<i> &gt;  some link time trickery and a lit of changes on stack scanning code.
</I>&gt;<i>
</I>&gt;<i> I'm not sure it would be simpler (to be honest I don't know how much
</I>&gt;<i> work it would involve), plus it would involve the MonoObject overhead
</I>&gt;<i> which is 8/16 bytes per RGCTX.
</I>&gt;<i>
</I>
We don't need to add the MonoObject header. The idea is to use the fact that
all threads are stopped to collect unused rgctx. This would not need hazard
pointers
or any free code on the filling code. Since lookup is always done from a
trampoline
it would be a matter of stack scanning for it to map which free rgctx's
cannot be freed.

Anyway, this would only make sense if freeing is something that happens
enough to
justify the extra work.


&gt;<i>
</I>&gt;<i> &gt; In Madrid we discussed about using segfaults to trigger lazy filling of
</I>&gt;<i> &gt; rgctx, have you thought about using that?
</I>&gt;<i>
</I>&gt;<i> Not seriously.  My first concern was getting everything to work
</I>&gt;<i> correctly, which it now does.  I'll concentrate on saving memory next,
</I>&gt;<i> so that sharing generic code actually makes sense.  Performance was
</I>&gt;<i> never an issue in my tests.
</I>&gt;<i>
</I>&gt;<i> &gt; I remember that a major issue with the rgctx layout was that you need to
</I>&gt;<i> &gt; coordinate slot filling between a type and all it's parents to avoid
</I>&gt;<i> &gt; collisions. How would that work on your proposed schema?
</I>&gt;<i>
</I>&gt;<i> I would still do the bookkeeping for collision avoidance and then use
</I>&gt;<i> the resulting slot number to uniquely identify the type information.
</I>&gt;<i> Just think of it as a sparse array.
</I>&gt;<i>
</I>&gt;<i> &gt; How about using a
</I>&gt;<i> &gt; pointer to the parent context? This would eliminate the whole issue,
</I>&gt;<i> could
</I>&gt;<i> &gt; save some bytes for parents with fat rgctx and make even less likely to
</I>&gt;<i> have
</I>&gt;<i> &gt; a large rgctx.
</I>&gt;<i>
</I>&gt;<i> No, that doesn't work in the general case, because the type arguments
</I>&gt;<i> of the parent class might be different:
</I>&gt;<i>
</I>&gt;<i> class B&lt;T&gt; : C&lt;X&lt;T&gt;&gt;
</I>&gt;<i>
</I>&gt;<i> It would probably work in the special case where they are the same,
</I>&gt;<i> but I don't know if it's worth to do that kind of optimization,
</I>&gt;<i> especially since it makes the lookup code more complicated.  I'd like
</I>&gt;<i> to keep the lookup code for the small RGCTX small so that we can do it
</I>&gt;<i> in managed code (not inline, but in a trampoline).
</I>&gt;<i>
</I>
I was thinking more about collections. Do interfaces have a rgctx too? It
could
make difference for IEnumerable&lt;&gt;, IComparable&lt;&gt; and similar; if it's the
case.

For super type only it would not make such a difference for
System.Collections.Generic that
have a very shallow inheritance tree. Mono.C5, on the other hand, uses a
deep tree.


&gt;<i>
</I>&gt;<i> &gt; One more thing, your stats miss something I guess it's important, how
</I>&gt;<i> many
</I>&gt;<i> &gt; generic sharing failures each test suite has? This is important to see
</I>&gt;<i> how
</I>&gt;<i> &gt; much further this could be improved if constrained and mixed
</I>&gt;<i> &gt; reference/valuetype sharing gets done.
</I>&gt;<i>
</I>&gt;<i> Yes, I don't have those stats yet, but they're on my TODO list.
</I>&gt;<i>
</I>&gt;<i> &gt; It might too early to think about this, but do you have some speed
</I>&gt;<i> results
</I>&gt;<i> &gt; for these tests?
</I>&gt;<i>
</I>&gt;<i> Yes.  At least on x86 there is no noticable speed difference between
</I>&gt;<i> sharing and not sharing.  I also did mini-benchmarks for List`1 and
</I>&gt;<i> Dictionary`2 and there was no speed difference either, in runs that
</I>&gt;<i> lasted about 30 seconds.
</I>&gt;<i>
</I>
I expected that for F# sharing would have saved some overall time since JIT
activity is a lot smaller.

By the way, talking about the F# case, generic sharing compiles 27% less
methods, but only reduces
the compiled code size by 6%. These numbers seen odd to me. Is generic code
really that
smaller than non-generic or is the added code for sharing support that
result on these numbers?

Rodrigo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20080414/6779faff/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20080414/6779faff/attachment.html</A> 
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027505.html">[Mono-dev] Generic sharing: Good news, bad news, how to win big
</A></li>
	<LI>Next message: <A HREF="027507.html">[Mono-dev] Generic sharing: Good news, bad news, how to win big
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27506">[ date ]</a>
              <a href="thread.html#27506">[ thread ]</a>
              <a href="subject.html#27506">[ subject ]</a>
              <a href="author.html#27506">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
