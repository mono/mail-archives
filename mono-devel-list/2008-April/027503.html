<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Generic sharing: Good news, bad news, how to win big
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Generic%20sharing%3A%20Good%20news%2C%20bad%20news%2C%20how%20to%20win%20big&In-Reply-To=f54ff3e80804140533r784a8054n58605c7f4d1bc518%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027502.html">
   <LINK REL="Next"  HREF="027505.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Generic sharing: Good news, bad news, how to win big</H1>
    <B>Rodrigo Kumpera</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Generic%20sharing%3A%20Good%20news%2C%20bad%20news%2C%20how%20to%20win%20big&In-Reply-To=f54ff3e80804140533r784a8054n58605c7f4d1bc518%40mail.gmail.com"
       TITLE="[Mono-dev] Generic sharing: Good news, bad news, how to win big">kumpera at gmail.com
       </A><BR>
    <I>Mon Apr 14 10:13:11 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="027502.html">[Mono-dev] Generic sharing: Good news, bad news, how to win big
</A></li>
        <LI>Next message: <A HREF="027505.html">[Mono-dev] Generic sharing: Good news, bad news, how to win big
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27503">[ date ]</a>
              <a href="thread.html#27503">[ thread ]</a>
              <a href="subject.html#27503">[ subject ]</a>
              <a href="author.html#27503">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&lt;snip&gt;

&gt;<i>
</I>&gt;<i> It seems that only a small number of RGCTXs is ever used, and the ones
</I>&gt;<i> that are used could make do with 2 to 5 slots on average.  For FSharp,
</I>&gt;<i> for instance, if we used an optimal allocation strategy (i.e. only
</I>&gt;<i> allocate RGCTXs if needed, only allocate as many slots as needed and
</I>&gt;<i> don't use any meta-data) we could get the 600k down to about 6k, which
</I>&gt;<i> would be more than acceptable.
</I>&gt;<i>
</I>&gt;<i> There is a problem with allocating a RGCTX lazily, though.  Allocating
</I>&gt;<i> a RGCTX requires some information.  Specifically, it requires the
</I>&gt;<i> MonoVTable* for the class for which to allocate the RGCTX.  This is
</I>&gt;<i> not an issue for non-static methods because the vtable is accessible
</I>&gt;<i> through the &quot;this&quot; argument.  Static methods don't have that argument,
</I>&gt;<i> though.  In fact, the RGCTX must contain a pointer to the vtable
</I>&gt;<i> because we need it in static methods for some purposes, like exception
</I>&gt;<i> handling.  So I think we'll need to switch to passing not the RGCTX,
</I>&gt;<i> but the vtable to static methods, since the latter contains a pointer
</I>&gt;<i> to the RGCTX anyway, which, for lazy allocation, could be NULL.  This
</I>&gt;<i> would give us the additional advantage of not having to store the
</I>&gt;<i> vtable in the RGCTX, saving us 4/8 bytes per RGCTX.
</I>&gt;<i>
</I>&gt;<i> As for how to arrange the RGCTX itself I have the following proposal:
</I>&gt;<i> Let's get rid of all the superclass and type argument type information
</I>&gt;<i> and just concentrate on the extensible part.  I'd like to implement
</I>&gt;<i> two different kinds of RGCTX - small ones and large ones.  Small
</I>&gt;<i> RGCTXs would have space for up to some constant number of slots,
</I>&gt;<i> preferably 3 or 7.  The layout would look like this on a 32-bit
</I>&gt;<i> system:
</I>&gt;<i>
</I>&gt;<i> struct small_rgctx {
</I>&gt;<i>  guint8 size;
</I>&gt;<i>  guint8 slot_numbers[3];
</I>&gt;<i>  gpointer slots[0];
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> size would be the number of slots in the RGCTX.  slot_numbers would
</I>&gt;<i> identify the type information stored in the slots array.
</I>&gt;<i>
</I>&gt;<i> To fetch an item out of the RGCTX we'd have to search through the
</I>&gt;<i> slot_numbers array to find the required type information and then
</I>&gt;<i> fetch the corresponding pointer from the slots array.  If the type
</I>&gt;<i> information is not found we'd jump into unmanaged code and extend the
</I>&gt;<i> RGCTX by allocating a new one with space for one more slot or, if the
</I>&gt;<i> maximum number of slots is reached, upgrading to a large RGCTX.
</I>&gt;<i> Another reason for using a large RGCTX would be if the values of the
</I>&gt;<i> slot numbers exceeded 255, which should be very unlikely, though.
</I>&gt;<i>
</I>&gt;<i> We could keep free lists per domain of the RGCTXs we've thrown away.
</I>&gt;<i> It might be necessary to use hazard pointers for access to the RGCTX
</I>&gt;<i> so as to avoid reusing memory of a thrown-away RGCTX if another thread
</I>&gt;<i> is still accessing it.
</I>&gt;<i>
</I>
Isn't possible or better to do RGCTX free'ing at GC time? It would be
simpler, the hardest
part would be guarding against parking threads inside RGCTX related code,
which can be done with
some link time trickery and a lit of changes on stack scanning code.



&gt;<i>
</I>&gt;<i> A large RGCTX could be some kind of small hash table.
</I>&gt;<i>
</I>&gt;<i> With such data structures we could also do another optimization.
</I>&gt;<i> Right now every class that is either a generic class or is a direct or
</I>&gt;<i> indirect subclass of a generic class has its own RGCTX.  Non-generic
</I>&gt;<i> classes can never give rise to the need for another piece of type
</I>&gt;<i> information in a RGCTX, so they could share the RGCTXs of their
</I>&gt;<i> generic superclasses.
</I>&gt;<i>
</I>&gt;<i> Does this sound like a sensible plan?  Am I missing something crucial?
</I>&gt;<i>  Does anybody have any suggestions or better ideas?
</I>&gt;<i>
</I>&gt;<i> Mark
</I>


These are great news Mark.

In Madrid we discussed about using segfaults to trigger lazy filling of
rgctx, have you thought about using that?

I remember that a major issue with the rgctx layout was that you need to
coordinate slot filling between a type and all it's parents to avoid
collisions. How would that work on your proposed schema? How about using a
pointer to the parent context? This would eliminate the whole issue, could
save some bytes for parents with fat rgctx and make even less likely to have
a large rgctx.

One more thing, your stats miss something I guess it's important, how many
generic sharing failures each test suite has? This is important to see how
much further this could be improved if constrained and mixed
reference/valuetype sharing gets done.

It might too early to think about this, but do you have some speed results
for these tests?


Cheers,
Rodrigo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20080414/0b8a87dc/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20080414/0b8a87dc/attachment.html</A> 
</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027502.html">[Mono-dev] Generic sharing: Good news, bad news, how to win big
</A></li>
	<LI>Next message: <A HREF="027505.html">[Mono-dev] Generic sharing: Good news, bad news, how to win big
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27503">[ date ]</a>
              <a href="thread.html#27503">[ thread ]</a>
              <a href="subject.html#27503">[ subject ]</a>
              <a href="author.html#27503">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
