<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Patch 2/2 - Tests for System.Diagnostics.Contracts in corlib
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Patch%202/2%20-%20Tests%20for%20System.Diagnostics.Contracts%0A%20in%20corlib&In-Reply-To=1277310891.1678.327.camel%40erandi.site">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="035291.html">
   <LINK REL="Next"  HREF="035210.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Patch 2/2 - Tests for System.Diagnostics.Contracts in corlib</H1>
    <B>Chris Bacon</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Patch%202/2%20-%20Tests%20for%20System.Diagnostics.Contracts%0A%20in%20corlib&In-Reply-To=1277310891.1678.327.camel%40erandi.site"
       TITLE="[Mono-dev] Patch 2/2 - Tests for System.Diagnostics.Contracts in corlib">chris at dunelm.org.uk
       </A><BR>
    <I>Sun Jun 27 08:24:48 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="035291.html">[Mono-dev] Patch 2/2 - Tests for System.Diagnostics.Contracts in corlib
</A></li>
        <LI>Next message: <A HREF="035210.html">[Mono-dev] MonoCharge on Windows
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35312">[ date ]</a>
              <a href="thread.html#35312">[ thread ]</a>
              <a href="subject.html#35312">[ subject ]</a>
              <a href="author.html#35312">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

Last Thursday, 24th, I followed these instructions and sent my public 
SSH key to <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">miguel at ximian.com.</A>
Should I expect to hear something back?

Thanks
Chris

Miguel de Icaza wrote:
&gt;<i> Hey Chris,
</I>&gt;<i>
</I>&gt;<i>     Could you get these commited yourself?
</I>&gt;<i>
</I>&gt;<i>     For this you will need an SVN key, follow the steps here:
</I>&gt;<i>
</I>&gt;<i> 	www.mono-project.com/SVN
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Updated patch attached. I've checked that all tests still pass.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The delegate has been removed, and #if NET_4_0 now surrounds the whole 
</I>&gt;&gt;<i> of each file.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> However, the #defines are not un-defined at the end of each file, as I 
</I>&gt;&gt;<i> don't think this is possible in C#, as all #define and #undef statements 
</I>&gt;&gt;<i> have to be before any code. Please let me know if there is a way of 
</I>&gt;&gt;<i> #undef-ing another way.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thanks
</I>&gt;&gt;<i> Chris
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Marek Safar wrote:
</I>&gt;&gt;<i>     
</I>&gt;&gt;&gt;<i> Hello Chris,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Only a few small issues
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Undefined these at the end of each file. They perhaps should be inside 
</I>&gt;&gt;&gt;<i> #if NET_4_0 too.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> +        // Required when compiling/running under .NET3.5
</I>&gt;&gt;&gt;<i> +        delegate void Action&lt;T1, T2, T3, T4, T5&gt; (T1 arg1, T2 arg2, 
</I>&gt;&gt;&gt;<i> T3 arg3, T4 arg4, T5 arg5);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Why is it needed when NET_4_0 is used for whole file ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> When fixed please commit. Thanks!
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Marek
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;&gt;<i> Hi,
</I>&gt;&gt;&gt;&gt;<i> I've attached a new patch with slightly better formatting - it uses 
</I>&gt;&gt;&gt;&gt;<i> tabs rather than spaces.
</I>&gt;&gt;&gt;&gt;<i> Kind regards
</I>&gt;&gt;&gt;&gt;<i> Chris
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Chris Bacon wrote:
</I>&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;&gt;&gt;<i> Hi,
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Here are the tests to add to corlib for System.Diagnostics.Contracts.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Please let me know what changes are required.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Kind regards
</I>&gt;&gt;&gt;&gt;&gt;<i> Chris
</I>&gt;&gt;&gt;&gt;&gt;<i> ------------------------------------------------------------------------ 
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;&gt;&gt;&gt;<i>           
</I>&gt;&gt;&gt;&gt;<i> ------------------------------------------------------------------------
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;<i> plain text document attachment (CodeContractsTest.patch)
</I>&gt;&gt;<i> Index: corlib_test.dll.sources
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- corlib_test.dll.sources	(revision 159418)
</I>&gt;&gt;<i> +++ corlib_test.dll.sources	(working copy)
</I>&gt;&gt;<i> @@ -60,6 +60,14 @@
</I>&gt;&gt;<i>  System.Diagnostics/StackFrameTest.cs
</I>&gt;&gt;<i>  System.Diagnostics/StackTraceTest.cs
</I>&gt;&gt;<i>  System.Diagnostics/TextWriterTraceListenerTest.cs
</I>&gt;&gt;<i> +System.Diagnostics.Contracts/ContractAssertTest.cs
</I>&gt;&gt;<i> +System.Diagnostics.Contracts/ContractAssumeTest.cs
</I>&gt;&gt;<i> +System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs
</I>&gt;&gt;<i> +System.Diagnostics.Contracts/ContractHelperTest.cs
</I>&gt;&gt;<i> +System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs
</I>&gt;&gt;<i> +System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs
</I>&gt;&gt;<i> +System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs
</I>&gt;&gt;<i> +System.Diagnostics.Contracts/Helpers/TestContractBase.cs
</I>&gt;&gt;<i>  System/DoubleFormatterTest.cs
</I>&gt;&gt;<i>  System/DoubleTest.cs
</I>&gt;&gt;<i>  System/EnumTest.cs
</I>&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractAssumeTest.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ContractAssumeTest.cs	(revision 0)
</I>&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ContractAssumeTest.cs	(revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,47 @@
</I>&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +using System;
</I>&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;<i> +	public class ContractAssumeTest : TestContractBase {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// At runtime Contract.Assume() acts just like a Contract.Assert(), except the exact message in the assert
</I>&gt;&gt;<i> +		/// or exception is slightly different.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test]
</I>&gt;&gt;<i> +		public void TestAssumeMessage ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Assume (false);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestAssumeMessage() exception not thrown #1&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof(NotImplementedException), ex, &quot;TestAssumeMessage() wrong exception type #1&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Assume (false, &quot;Message&quot;);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestAssumeMessage() exception not thrown #1&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof(NotImplementedException), ex, &quot;TestAssumeMessage() wrong exception type #1&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		// Identical to Contract.Assert, so no more testing required.
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/ContractAssumeTest.cs
</I>&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;<i>    + native
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs	(revision 0)
</I>&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs	(revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,129 @@
</I>&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +using System;
</I>&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;<i> +	public class ContractCollectionMethodsTest {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Exists() determines that at least one element in the collection satisfies the predicate.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestExistsInt ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Exists (0, 10, null);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestExistsInt() no exception #1&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex, &quot;TestExistsInt() wrong exception #1&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Exists (10, 0, i =&gt; false);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestExistsInt() no exception #2&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentException), ex, &quot;TestExistsInt() wrong exception #2&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Assert.IsTrue (Contract.Exists (0, 10, i =&gt; i &lt;= 0), &quot;TestExistsInt() #1&quot;);
</I>&gt;&gt;<i> +			Assert.IsTrue (Contract.Exists (0, 10, i =&gt; i &gt;= 9), &quot;TestExistsInt() #2&quot;);
</I>&gt;&gt;<i> +			Assert.IsFalse (Contract.Exists (0, 10, i =&gt; i &lt; 0), &quot;TestExistsInt() #3&quot;);
</I>&gt;&gt;<i> +			Assert.IsFalse (Contract.Exists (0, 10, i =&gt; i &gt; 9), &quot;TestExistsInt() #4&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Exists() determines that at least one element in the collection satisfies the predicate.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestExistsEnumeration ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Exists (Enumerable.Range (0, 10), null);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestExistsEnumeration() no exception #1&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex, &quot;TestExistsEnumeration() wrong exception #1&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Exists&lt;int&gt; (null, x =&gt; false);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestExistsEnumeration() no exception #2&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex, &quot;TestExistsEnumeration() wrong exception #2&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			var en = Enumerable.Range (0, 10);
</I>&gt;&gt;<i> +			Assert.IsTrue (Contract.Exists (en, i =&gt; i &lt;= 0), &quot;TestExistsEnumeration() #1&quot;);
</I>&gt;&gt;<i> +			Assert.IsTrue (Contract.Exists (en, i =&gt; i &gt;= 9), &quot;TestExistsEnumeration() #2&quot;);
</I>&gt;&gt;<i> +			Assert.IsFalse (Contract.Exists (en, i =&gt; i &lt; 0), &quot;TestExistsEnumeration() #3&quot;);
</I>&gt;&gt;<i> +			Assert.IsFalse (Contract.Exists (en, i =&gt; i &gt; 9), &quot;TestExistsEnumeration() #4&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.ForAll() determines if all elements in the collection satisfy the predicate.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestForAllInt ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.ForAll (0, 10, null);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestForAllInt() no exception #1&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex, &quot;TestForAllInt() wrong exception #1&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.ForAll (10, 0, i =&gt; false);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestForAllInt() no exception #2&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentException), ex, &quot;TestForAllInt() wrong exception #2&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Assert.IsTrue (Contract.ForAll (0, 10, i =&gt; i &lt;= 9), &quot;TestForAllInt() #1&quot;);
</I>&gt;&gt;<i> +			Assert.IsTrue (Contract.ForAll (0, 10, i =&gt; i &gt;= 0), &quot;TestForAllInt() #2&quot;);
</I>&gt;&gt;<i> +			Assert.IsFalse (Contract.ForAll (0, 10, i =&gt; i &lt; 9), &quot;TestForAllInt() #3&quot;);
</I>&gt;&gt;<i> +			Assert.IsFalse (Contract.ForAll (0, 10, i =&gt; i &gt; 0), &quot;TestForAllInt() #4&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.ForAll() determines if all elements in the collection satisfy the predicate.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestForAllEnumeration ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.ForAll (Enumerable.Range (0, 10), null);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestForAllEnumeration() no exception #1&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex, &quot;TestForAllEnumeration() wrong exception #1&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.ForAll&lt;int&gt; (null, x =&gt; false);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestForAllEnumeration() no exception #2&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex, &quot;TestForAllEnumeration() wrong exception #2&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			var en = Enumerable.Range (0, 10);
</I>&gt;&gt;<i> +			Assert.IsTrue (Contract.ForAll (en, i =&gt; i &lt;= 9), &quot;TestForAllEnumeration() #1&quot;);
</I>&gt;&gt;<i> +			Assert.IsTrue (Contract.ForAll (en, i =&gt; i &gt;= 0), &quot;TestForAllEnumeration() #2&quot;);
</I>&gt;&gt;<i> +			Assert.IsFalse (Contract.ForAll (en, i =&gt; i &lt; 9), &quot;TestForAllEnumeration() #3&quot;);
</I>&gt;&gt;<i> +			Assert.IsFalse (Contract.ForAll (en, i =&gt; i &gt; 0), &quot;TestForAllEnumeration() #4&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs
</I>&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;<i>    + native
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractHelperTest.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ContractHelperTest.cs	(revision 0)
</I>&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ContractHelperTest.cs	(revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,258 @@
</I>&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +using System;
</I>&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;<i> +using System.Diagnostics.Contracts.Internal;
</I>&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;<i> +using NUnit.Framework.Constraints;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;<i> +	public class ContractHelperTest : TestContractBase {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		private void CheckAllMessages (ContractFailureKind kind, string messageStart, Action&lt;string, Exception, string, ContractFailureKind, Func&lt;string&gt;&gt; fnAssert)
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			foreach (Exception ex in new [] { null, new ArgumentNullException () }) {
</I>&gt;&gt;<i> +				fnAssert (messageStart + &quot;.&quot;, ex, null, kind, () =&gt; {
</I>&gt;&gt;<i> +					return ContractHelper.RaiseContractFailedEvent (kind, null, null, ex);
</I>&gt;&gt;<i> +				});
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +				fnAssert (messageStart + &quot;.  Message&quot;, ex, null, kind, () =&gt; {
</I>&gt;&gt;<i> +					return ContractHelper.RaiseContractFailedEvent (kind, &quot;Message&quot;, null, ex);
</I>&gt;&gt;<i> +				});
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +				fnAssert (messageStart + &quot;: Condition&quot;, ex, &quot;Condition&quot;, kind, () =&gt; {
</I>&gt;&gt;<i> +					return ContractHelper.RaiseContractFailedEvent (kind, null, &quot;Condition&quot;, ex);
</I>&gt;&gt;<i> +				});
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +				fnAssert (messageStart + &quot;: Condition  Message&quot;, ex, &quot;Condition&quot;, kind, () =&gt; {
</I>&gt;&gt;<i> +					return ContractHelper.RaiseContractFailedEvent (kind, &quot;Message&quot;, &quot;Condition&quot;, ex);
</I>&gt;&gt;<i> +				});
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		private void CheckAllKinds (Action&lt;string, Exception, string, ContractFailureKind, Func&lt;string&gt;&gt; fnAssert)
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Assert, &quot;Assertion failed&quot;, fnAssert);
</I>&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Assume, &quot;Assumption failed&quot;, fnAssert);
</I>&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Invariant, &quot;Invariant failed&quot;, fnAssert);
</I>&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Postcondition, &quot;Postcondition failed&quot;, fnAssert);
</I>&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.PostconditionOnException, &quot;Postcondition failed after throwing an exception&quot;, fnAssert);
</I>&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Precondition, &quot;Precondition failed&quot;, fnAssert);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		private void CheckAllKinds (Action&lt;string, Exception, Func&lt;string&gt;&gt; fnAssert)
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			this.CheckAllKinds ((expected, ex, condition, kind, fnTest) =&gt; fnAssert (expected, ex, fnTest));
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// If no event handler is present, then the string returned describes the condition failure.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestRaiseContractFailedEventNoHandler ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			this.CheckAllKinds ((expected, ex, fnTest) =&gt; {
</I>&gt;&gt;<i> +				string msg = fnTest ();
</I>&gt;&gt;<i> +				Assert.AreEqual (expected, msg, &quot;TestRaiseContractFailedEventNoHandler() incorrect message&quot;);
</I>&gt;&gt;<i> +			});
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// When SetHandled() is called, null is returned.
</I>&gt;&gt;<i> +		/// The event args are also checked.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestRaiseContractFailedEventHandled ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			string expectedMsg = null;
</I>&gt;&gt;<i> +			Exception originalException = null;
</I>&gt;&gt;<i> +			string expectedCondition = null;
</I>&gt;&gt;<i> +			ContractFailureKind expectedKind = ContractFailureKind.Assert;
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				Assert.AreEqual (expectedMsg, e.Message, &quot;TestRaiseContractFailedEventHandled() event message wrong&quot;);
</I>&gt;&gt;<i> +				Assert.AreSame (originalException, e.OriginalException, &quot;TestRaiseContractFailedEventHandled() event exception wrong&quot;);
</I>&gt;&gt;<i> +				Assert.AreEqual (expectedCondition, e.Condition, &quot;TestRaiseContractFailedEventHandled() event condition wrong&quot;);
</I>&gt;&gt;<i> +				Assert.AreEqual (expectedKind, e.FailureKind, &quot;TestRaiseContractFailedEventHandled() event failure kind wrong&quot;);
</I>&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			this.CheckAllKinds ((expected, ex, condition, kind, fnTest) =&gt; {
</I>&gt;&gt;<i> +				expectedMsg = expected;
</I>&gt;&gt;<i> +				originalException = ex;
</I>&gt;&gt;<i> +				expectedCondition = condition;
</I>&gt;&gt;<i> +				expectedKind = kind;
</I>&gt;&gt;<i> +				string msg = fnTest ();
</I>&gt;&gt;<i> +				Assert.IsNull (msg, &quot;TestRaiseContractFailedEventHandled() expected null message&quot;);
</I>&gt;&gt;<i> +			});
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// When SetUnwind() is called, a ContractException is thrown. If an innerException is passed, then
</I>&gt;&gt;<i> +		/// it is put in the InnerException of the ContractException. Otherwise, the InnerException is set to null.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestRaiseContractFailedEventUnwind ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				e.SetUnwind ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			this.CheckAllKinds ((expected, expectedEx, fnTest) =&gt; {
</I>&gt;&gt;<i> +				try {
</I>&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;<i> +					Assert.Fail (&quot;TestRaiseContractFailedEventUnwind() exception not thrown&quot;);
</I>&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;<i> +					Assert.IsInstanceOfType (base.ContractExceptionType, ex, &quot;TestRaiseContractFailedEventUnwind() wrong exception type&quot;);
</I>&gt;&gt;<i> +					if (expectedEx == null) {
</I>&gt;&gt;<i> +						Assert.IsNull (ex.InnerException, &quot;TestRaiseContractFailedEventUnwind() inner exception should be null&quot;);
</I>&gt;&gt;<i> +					} else {
</I>&gt;&gt;<i> +						Assert.AreSame (expectedEx, ex.InnerException, &quot;TestRaiseContractFailedEventUnwind() wrong inner exception type&quot;);
</I>&gt;&gt;<i> +					}
</I>&gt;&gt;<i> +				}
</I>&gt;&gt;<i> +			});
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// When the ContractFailed event throws an exception, then it becomes the inner exception of the
</I>&gt;&gt;<i> +		/// ContractException. Except if an exception is passed in to the call, then that exception is put
</I>&gt;&gt;<i> +		/// in the InnerException.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestRaiseContractFailedEventThrows ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				throw new InvalidOperationException ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			this.CheckAllKinds ((expected, expectedEx, fnTest) =&gt; {
</I>&gt;&gt;<i> +				try {
</I>&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;<i> +					Assert.Fail (&quot;TestRaiseContractFailedEventThrows() exception not thrown&quot;);
</I>&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;<i> +					Assert.IsInstanceOfType (base.ContractExceptionType, ex, &quot;TestRaiseContractFailedEventThrows() wrong exception type&quot;);
</I>&gt;&gt;<i> +					Type expectedInnerExceptionType = expectedEx == null ? typeof (InvalidOperationException) : expectedEx.GetType ();
</I>&gt;&gt;<i> +					Assert.IsInstanceOfType (expectedInnerExceptionType, ex.InnerException, &quot;TestRaiseContractFailedEventThrows() wrong inner exception type&quot;);
</I>&gt;&gt;<i> +				}
</I>&gt;&gt;<i> +			});
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Both event handlers should be called, constraint is not handled.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestRaiseContractMultipleHandlers1 ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			bool visited1, visited2;
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				visited1 = true;
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				visited2 = true;
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			this.CheckAllKinds ((expected, ex, fnTest) =&gt; {
</I>&gt;&gt;<i> +				visited1 = visited2 = false;
</I>&gt;&gt;<i> +				string msg = fnTest ();
</I>&gt;&gt;<i> +				Assert.AreEqual (expected, msg, &quot;TestRaiseContractMultipleHandlers1() msg not as expected&quot;);
</I>&gt;&gt;<i> +				Assert.IsTrue (visited1, &quot;TestRaiseContractMultipleHandlers1() handler 1 not visited&quot;);
</I>&gt;&gt;<i> +				Assert.IsTrue (visited2, &quot;TestRaiseContractMultipleHandlers1() handler 2 not visited&quot;);
</I>&gt;&gt;<i> +			});
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Both event handlers should be called. SetUnwind() takes precedent over SetHandled().
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestRaiseContractMultipleHandlers2 ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			bool visited1, visited2;
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				visited1 = true;
</I>&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				visited2 = true;
</I>&gt;&gt;<i> +				e.SetUnwind ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			this.CheckAllKinds ((expected, expectedEx, fnTest) =&gt; {
</I>&gt;&gt;<i> +				visited1 = visited2 = false;
</I>&gt;&gt;<i> +				try {
</I>&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;<i> +					Assert.Fail (&quot;TestRaiseContractMultipleHandlers2() exception not thrown&quot;);
</I>&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;<i> +					Assert.IsInstanceOfType (base.ContractExceptionType, ex, &quot;TestRaiseContractMultipleHandlers2() wrong exception type&quot;);
</I>&gt;&gt;<i> +					if (expectedEx == null) {
</I>&gt;&gt;<i> +						Assert.IsNull (ex.InnerException, &quot;TestRaiseContractMultipleHandlers2() inner exception not null&quot;);
</I>&gt;&gt;<i> +					} else {
</I>&gt;&gt;<i> +						Assert.AreSame (expectedEx, ex.InnerException, &quot;TestRaiseContractMultipleHandlers2() wrong inner exception&quot;);
</I>&gt;&gt;<i> +					}
</I>&gt;&gt;<i> +					Assert.IsTrue (visited1, &quot;TestRaiseContractMultipleHandlers2() handler 1 not visited&quot;);
</I>&gt;&gt;<i> +					Assert.IsTrue (visited2, &quot;TestRaiseContractMultipleHandlers2() handler 2 not visited&quot;);
</I>&gt;&gt;<i> +				}
</I>&gt;&gt;<i> +			});
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Both event handlers should be called. The exceptions are treated as calls to SetUnwind(), with
</I>&gt;&gt;<i> +		/// the exception being put in the InnerException.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestRaiseContractMultipleHandlers3 ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			bool visited1, visited2;
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				visited1 = true;
</I>&gt;&gt;<i> +				throw new InvalidOperationException ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				visited2 = true;
</I>&gt;&gt;<i> +				throw new InvalidOperationException ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			this.CheckAllKinds ((expected, expectedEx, fnTest) =&gt; {
</I>&gt;&gt;<i> +				visited1 = visited2 = false;
</I>&gt;&gt;<i> +				try {
</I>&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;<i> +					Assert.Fail (&quot;TestRaiseContractMultipleHandlers3() failed to throw exception&quot;);
</I>&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;<i> +					Type expectedInnerExceptionType = expectedEx == null ? typeof (InvalidOperationException) : expectedEx.GetType ();
</I>&gt;&gt;<i> +					Assert.IsInstanceOfType (base.ContractExceptionType, ex, &quot;TestRaiseContractMultipleHandlers3() wrong exception type&quot;);
</I>&gt;&gt;<i> +					Assert.IsInstanceOfType (expectedInnerExceptionType, ex.InnerException, &quot;TestRaiseContractMultipleHandlers3() wrong inner exception type&quot;);
</I>&gt;&gt;<i> +					Assert.IsTrue (visited1, &quot;TestRaiseContractMultipleHandlers3() handler 1 not visited&quot;);
</I>&gt;&gt;<i> +					Assert.IsTrue (visited2, &quot;TestRaiseContractMultipleHandlers3() handler 2 not visited&quot;);
</I>&gt;&gt;<i> +				}
</I>&gt;&gt;<i> +			});
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.TriggerFailure() triggers the assert. Check that the assert is triggered, with the correct text.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test]
</I>&gt;&gt;<i> +		public void TestTriggerFailure ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				ContractHelper.TriggerFailure (ContractFailureKind.Assert, &quot;Display&quot;, null, &quot;Condition&quot;, null);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestTriggerFailure() failed to throw exception&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType(typeof(NotImplementedException), ex, &quot;TestTriggerFailure() wrong exception type&quot;);
</I>&gt;&gt;<i> +				//Assert.AreEqual (&quot;Expression: Condition&quot; + Environment.NewLine + &quot;Description: Display&quot;, ex.Message, &quot;TestTriggerFailure() wrong message&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/ContractHelperTest.cs
</I>&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;<i>    + native
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs	(revision 0)
</I>&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs	(revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,18 @@
</I>&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +using System;
</I>&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts.Helpers {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
</I>&gt;&gt;<i> +	class RunAgainstReferenceAttribute : CategoryAttribute
</I>&gt;&gt;<i> +	{
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs
</I>&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;<i>    + native
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/Helpers/TestContractBase.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/Helpers/TestContractBase.cs	(revision 0)
</I>&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/Helpers/TestContractBase.cs	(revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,48 @@
</I>&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +using System;
</I>&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;<i> +using System.Diagnostics;
</I>&gt;&gt;<i> +using System.Reflection;
</I>&gt;&gt;<i> +using System.Diagnostics.Contracts.Internal;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts.Helpers {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	public class TestContractBase {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		protected TestContractBase() {
</I>&gt;&gt;<i> +			// Get the type of System.Diagnostics.Contracts.ContractException
</I>&gt;&gt;<i> +			// Have to do this differently depending on how the test is being run.
</I>&gt;&gt;<i> +			this.ContractExceptionType = Type.GetType(&quot;System.Diagnostics.Contracts.ContractException&quot;);
</I>&gt;&gt;<i> +			if (this.ContractExceptionType == null) {
</I>&gt;&gt;<i> +				// Special code for when Contracts namespace is not in CorLib
</I>&gt;&gt;<i> +				var mGetContractExceptionType = typeof (Contract).GetMethod (&quot;GetContractExceptionType&quot;, BindingFlags.NonPublic | BindingFlags.Static);
</I>&gt;&gt;<i> +				this.ContractExceptionType = (Type) mGetContractExceptionType.Invoke (null, null);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		[SetUp]
</I>&gt;&gt;<i> +		public void Setup() {
</I>&gt;&gt;<i> +			// Remove all event handlers from Contract.ContractFailed
</I>&gt;&gt;<i> +			var eventField = typeof(Contract).GetField(&quot;ContractFailed&quot;, BindingFlags.Static | BindingFlags.NonPublic);
</I>&gt;&gt;<i> +			if (eventField == null) {
</I>&gt;&gt;<i> +				// But in MS.NET it's done this way.
</I>&gt;&gt;<i> +				eventField = typeof(ContractHelper).GetField(&quot;contractFailedEvent&quot;, BindingFlags.Static | BindingFlags.NonPublic);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +			eventField.SetValue(null, null);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		[TearDown]
</I>&gt;&gt;<i> +		public void TearDown() {
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		protected Type ContractExceptionType { get; private set; }
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/Helpers/TestContractBase.cs
</I>&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;<i>    + native
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractAssertTest.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ContractAssertTest.cs	(revision 0)
</I>&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ContractAssertTest.cs	(revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,175 @@
</I>&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +using System;
</I>&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;<i> +using System.Diagnostics;
</I>&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;<i> +	public class ContractAssertTest : TestContractBase {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Ensures that Assert(true) allows execution to continue.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestAssertTrue ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			Contract.Assert (true);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Assert(false) will cause an assert to be triggered with the correct message.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test]
</I>&gt;&gt;<i> +		public void TestAssertNoEventHandler ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestAssertNoEventHandler() exception not thrown #1&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (NotImplementedException), ex, &quot;TestAssertNoEventHandler() wrong exception type #1&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Assert (false, &quot;Message&quot;);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestAssertNoEventHandler() exception not thrown #2&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (NotImplementedException), ex, &quot;TestAssertNoEventHandler() wrong exception type #2&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Assert(true) will not call the ContractFailed event handler.
</I>&gt;&gt;<i> +		/// Contract.Assert(false) will call the ContractFailed event handler.
</I>&gt;&gt;<i> +		/// Because nothing is done in the event handler, an assert should be triggered.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test]
</I>&gt;&gt;<i> +		public void TestAssertEventHandlerNoAction ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			bool visitedEventHandler = false;
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				visitedEventHandler = true;
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Contract.Assert (true);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Assert.IsFalse (visitedEventHandler, &quot;TestAssertEventHandlerNoAction() handler visited&quot;);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;<i> +				Assert.Fail (&quot;TestAssertEventHandlerNoAction() exception not thrown&quot;);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (NotImplementedException), ex, &quot;TestAssertEventHandlerNoAction() wrong exception type&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Assert.IsTrue (visitedEventHandler, &quot;TestAssertEventHandlerNoAction() handler not visited&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Event handler calls SetHandled(), so no assert should be triggered.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestAssertEventHandlerSetHandled ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Contract.Assert (false);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Event handler calls SetUnwind(), so exception of type ContractException should be thrown.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestAssertEventHandlerSetUnwind ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				e.SetUnwind ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (base.ContractExceptionType, ex, &quot;TestAssertEventHandlerSetUnwind() wrong exception type&quot;);
</I>&gt;&gt;<i> +				Assert.IsNull (ex.InnerException, &quot;TestAssertEventHandlerSetUnwind() inner exception not null&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Event handler calls SetHandled() and SetUnwind(), so exception of type ContractException should be thrown,
</I>&gt;&gt;<i> +		/// as SetUnwind overrides SetHandled.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestAssertEventHandlerSetUnwindHandled ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;<i> +				e.SetUnwind ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (base.ContractExceptionType, ex, &quot;TestAssertEventHandlerSetUnwindHandled() wrong exception type&quot;);
</I>&gt;&gt;<i> +				Assert.IsNull (ex.InnerException, &quot;TestAssertEventHandlerSetUnwindHandled() inner exception not null&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Event handler throws exception.
</I>&gt;&gt;<i> +		/// ContractException is thrown by Contract.Assert(), with InnerException set to the thrown exception.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestAssertEventHandlerThrows ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				throw new ArgumentNullException ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			try {
</I>&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (base.ContractExceptionType, ex, &quot;TestAssertEventHandlerSetUnwindHandled() wrong exception type&quot;);
</I>&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex.InnerException, &quot;TestAssertEventHandlerSetUnwindHandled() wrong inner exception type&quot;);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Multiple event handlers are registered. Check that both are called, and that the SetHandled()
</I>&gt;&gt;<i> +		/// call in one of them is handled correctly.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestAssertMultipleHandlers ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			bool visited1 = false, visited2 = false;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				visited1 = true;
</I>&gt;&gt;<i> +				Assert.IsFalse (e.Handled, &quot;TestAssertMultipleHandlers() Handled incorrect #1&quot;);
</I>&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				visited2 = true;
</I>&gt;&gt;<i> +				Assert.IsTrue (e.Handled, &quot;TestAssertMultipleHandlers() Handled incorrect #2&quot;);
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Contract.Assert (false);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Assert.IsTrue (visited1, &quot;TestAssertMultipleHandlers() visited1 incorrect&quot;);
</I>&gt;&gt;<i> +			Assert.IsTrue (visited2, &quot;TestAssertMultipleHandlers() visited2 incorrect&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/ContractAssertTest.cs
</I>&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;<i>    + native
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs	(revision 0)
</I>&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs	(revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,76 @@
</I>&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +using System;
</I>&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;<i> +	public class ContractMarkerMethodsTest : TestContractBase {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.EndContractBlock() has no effects.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestEndContractBlock ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			Contract.EndContractBlock ();
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.OldValue() has no effect, and always returns the default value for the type.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestOldValue ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			int i = Contract.OldValue&lt;int&gt; (8);
</I>&gt;&gt;<i> +			object o = Contract.OldValue&lt;object&gt; (new object ());
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Assert.AreEqual (0, i, &quot;TestOldValue() int value wrong&quot;);
</I>&gt;&gt;<i> +			Assert.IsNull (o, &quot;TestOldValue() object value wrong&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Result() has no effect, and always returns the default value for the type.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestResult ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			int i = Contract.Result&lt;int&gt; ();
</I>&gt;&gt;<i> +			object o = Contract.Result&lt;object&gt; ();
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Assert.AreEqual (0, i, &quot;TestResult() int value wrong&quot;);
</I>&gt;&gt;<i> +			Assert.IsNull (o, &quot;TestResult() object value wrong&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.ValueAtReturn() has no effect, and always returns the default value for the type.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;<i> +		public void TestValueAtReturn ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			int iOut, i;
</I>&gt;&gt;<i> +			object oOut, o;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			i = Contract.ValueAtReturn (out iOut);
</I>&gt;&gt;<i> +			o = Contract.ValueAtReturn (out oOut);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Assert.AreEqual (0, i, &quot;TestValueAtReturn() int return value wrong&quot;);
</I>&gt;&gt;<i> +			Assert.IsNull (o, &quot;TestValueAtReturn() object return value wrong&quot;);
</I>&gt;&gt;<i> +			Assert.AreEqual (0, iOut, &quot;TestValueAtReturn() int out value wrong&quot;);
</I>&gt;&gt;<i> +			Assert.IsNull (oOut, &quot;TestValueAtReturn() object out value wrong&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs
</I>&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;<i>    + native
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ChangeLog
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ChangeLog	(revision 0)
</I>&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ChangeLog	(revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,4 @@
</I>&gt;&gt;<i> +2010-06-23  Chris Bacon &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">chrisbacon76 at gmail.com</A>&gt;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	* Added all files
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/ChangeLog
</I>&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;<i>    + native
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs	(revision 0)
</I>&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs	(revision 0)
</I>&gt;&gt;<i> @@ -0,0 +1,121 @@
</I>&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +using System;
</I>&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;<i> +	public class ContractMustUseRewriterTest : TestContractBase {
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		private void CheckMustUseRewriter (string expectedMsg, params Action[] fnTests)
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			foreach (var fnTest in fnTests) {
</I>&gt;&gt;<i> +				try {
</I>&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;<i> +					Assert.Fail (&quot;CheckMustUseRewriter() exception not thrown&quot;);
</I>&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;<i> +					Assert.IsInstanceOfType (typeof (NotImplementedException), ex, &quot;CheckMustUseRewriter() wrong exception thrown&quot;);
</I>&gt;&gt;<i> +				}
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			bool handlerVisited = false;
</I>&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;<i> +				handlerVisited = true;
</I>&gt;&gt;<i> +			};
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			foreach (var fnTest in fnTests) {
</I>&gt;&gt;<i> +				try {
</I>&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;<i> +					Assert.Fail (&quot;CheckMustUseRewriter() exception not thrown&quot;);
</I>&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;<i> +					Assert.IsInstanceOfType (typeof (NotImplementedException), ex, &quot;CheckMustUseRewriter() wrong exception thrown&quot;);
</I>&gt;&gt;<i> +				}
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			Assert.IsFalse (handlerVisited, &quot;CheckMustUseRewriter() handled visited&quot;);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Requires() ALWAYS triggers an assert, regardless of any other factors.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test]
</I>&gt;&gt;<i> +		public void TestRequires ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when using Contract.Requires&quot;,
</I>&gt;&gt;<i> +				() =&gt; Contract.Requires (true),
</I>&gt;&gt;<i> +				() =&gt; Contract.Requires (false),
</I>&gt;&gt;<i> +				() =&gt; Contract.Requires (true, &quot;Message&quot;),
</I>&gt;&gt;<i> +				() =&gt; Contract.Requires (false, &quot;Message&quot;)
</I>&gt;&gt;<i> +			);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Requires() ALWAYS triggers an assert, regardless of any other factors.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test]
</I>&gt;&gt;<i> +		public void TestRequiresTException ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when using Contract.Requires&lt;TException&gt;&quot;,
</I>&gt;&gt;<i> +				() =&gt; Contract.Requires&lt;Exception&gt; (true),
</I>&gt;&gt;<i> +				() =&gt; Contract.Requires&lt;Exception&gt; (false),
</I>&gt;&gt;<i> +				() =&gt; Contract.Requires&lt;Exception&gt; (true, &quot;Message&quot;),
</I>&gt;&gt;<i> +				() =&gt; Contract.Requires&lt;Exception&gt; (false, &quot;Message&quot;)
</I>&gt;&gt;<i> +			);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Ensures() ALWAYS triggers an assert, regardless of any other factors.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test]
</I>&gt;&gt;<i> +		public void TestEnsures ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when using Contract.Ensures&quot;,
</I>&gt;&gt;<i> +				() =&gt; Contract.Ensures (true),
</I>&gt;&gt;<i> +				() =&gt; Contract.Ensures (false),
</I>&gt;&gt;<i> +				() =&gt; Contract.Ensures (true, &quot;Message&quot;),
</I>&gt;&gt;<i> +				() =&gt; Contract.Ensures (false, &quot;Message&quot;)
</I>&gt;&gt;<i> +			);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Ensures() ALWAYS triggers an assert, regardless of any other factors.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test]
</I>&gt;&gt;<i> +		public void TestEnsuresOnThrow ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when using Contract.EnsuresOnThrow&quot;,
</I>&gt;&gt;<i> +				() =&gt; Contract.EnsuresOnThrow&lt;Exception&gt; (true),
</I>&gt;&gt;<i> +				() =&gt; Contract.EnsuresOnThrow&lt;Exception&gt; (false),
</I>&gt;&gt;<i> +				() =&gt; Contract.EnsuresOnThrow&lt;Exception&gt; (true, &quot;Message&quot;),
</I>&gt;&gt;<i> +				() =&gt; Contract.EnsuresOnThrow&lt;Exception&gt; (false, &quot;Message&quot;)
</I>&gt;&gt;<i> +			);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;<i> +		/// Contract.Ensures() ALWAYS triggers an assert, regardless of any other factors.
</I>&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;<i> +		[Test]
</I>&gt;&gt;<i> +		public void TestInvariant ()
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when using Contract.Invariant&quot;,
</I>&gt;&gt;<i> +				() =&gt; Contract.Invariant (true),
</I>&gt;&gt;<i> +				() =&gt; Contract.Invariant (false),
</I>&gt;&gt;<i> +				() =&gt; Contract.Invariant (true, &quot;Message&quot;),
</I>&gt;&gt;<i> +				() =&gt; Contract.Invariant (false, &quot;Message&quot;)
</I>&gt;&gt;<i> +			);
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +#endif
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs
</I>&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;<i>    + native
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>   
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20100627/1ef5e801/attachment-0001.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20100627/1ef5e801/attachment-0001.html</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="035291.html">[Mono-dev] Patch 2/2 - Tests for System.Diagnostics.Contracts in corlib
</A></li>
	<LI>Next message: <A HREF="035210.html">[Mono-dev] MonoCharge on Windows
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35312">[ date ]</a>
              <a href="thread.html#35312">[ thread ]</a>
              <a href="subject.html#35312">[ subject ]</a>
              <a href="author.html#35312">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
