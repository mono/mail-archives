<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Compiling Mono Runtime in VS2010
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Compiling%20Mono%20Runtime%20in%20VS2010&In-Reply-To=mailman.78180.1277641501.2070.mono-devel-list%40lists.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="035357.html">
   <LINK REL="Next"  HREF="035333.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Compiling Mono Runtime in VS2010</H1>
    <B>Guy Sherman</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Compiling%20Mono%20Runtime%20in%20VS2010&In-Reply-To=mailman.78180.1277641501.2070.mono-devel-list%40lists.ximian.com"
       TITLE="[Mono-dev] Compiling Mono Runtime in VS2010">guy at guysherman.com
       </A><BR>
    <I>Sun Jun 27 20:27:36 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="035357.html">[Mono-dev] Standard name for mcs
</A></li>
        <LI>Next message: <A HREF="035333.html">[Mono-dev] Compiling Mono Runtime in VS2010
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35325">[ date ]</a>
              <a href="thread.html#35325">[ thread ]</a>
              <a href="subject.html#35325">[ subject ]</a>
              <a href="author.html#35325">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi All,

I managed to compile a 64-bit version of the mono runtime, using Visual
Studio 2008, and I am having a great time working out how to embed mono.
However, I am using Visual Studio 2010 for my solution, and whenever I call
free on a pointer allocated by the runtime (like a MonoClass*), I get a
failed debug assertion which has something to do with heap corruption, and
something to do with code within the same process being from different
versions of the C runtime (2008 vs 2010 I guess).

So, my question is this: has anyone managed to compile the mono runtime in
Visual Studio 2010 yet? I tried a couple of weeks ago but couldn't, there
was some phantom syntax error, which didn't appear in Visual Studio 2008.

As an aside, when trying to call g_free, I get an unresolved externals
error despite the fact that the path to glib-2.0.lib is definitely in my
project settings. Could this be because the glib libs that ship with mono
for windows a 32-bit, and I'm trying to compile 64-bit?

Thanks very much in advance,

Guy Sherman.

On Sun, 27 Jun 2010 08:25:01 -0400,
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list-request at lists.ximian.com</A> wrote:
&gt;<i> Send Mono-devel-list mailing list submissions to
</I>&gt;<i> 	<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> 
</I>&gt;<i> To subscribe or unsubscribe via the World Wide Web, visit
</I>&gt;<i> 	<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> or, via email, send a message with subject or body 'help' to
</I>&gt;<i> 	<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list-request at lists.ximian.com</A>
</I>&gt;<i> 
</I>&gt;<i> You can reach the person managing the list at
</I>&gt;<i> 	<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list-owner at lists.ximian.com</A>
</I>&gt;<i> 
</I>&gt;<i> When replying, please edit your Subject line so it is more specific
</I>&gt;<i> than &quot;Re: Contents of Mono-devel-list digest...&quot;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Today's Topics:
</I>&gt;<i> 
</I>&gt;<i>    1. Re:  Proposed Patch - Google Native Client (Rafael Teixeira)
</I>&gt;<i>    2. Re:  [PATCH] mono_debugger_agent_thread_interrupt	signature
</I>&gt;<i>       mismatch (Zoltan Varga)
</I>&gt;<i>    3.  svn trunk build fails, 'SIGPWR' undeclared (KISHIMOTO, Makoto)
</I>&gt;<i>    4. Re:  Patch 2/2 - Tests for System.Diagnostics.Contracts in
</I>&gt;<i>       corlib (Chris Bacon)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ----------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 1
</I>&gt;<i> Date: Fri, 25 Jun 2010 12:31:55 -0300
</I>&gt;<i> From: Rafael Teixeira &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">monoman at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [Mono-dev] Proposed Patch - Google Native Client
</I>&gt;<i> To: Elijah Taylor &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">elijahtaylor at google.com</A>&gt;
</I>&gt;<i> Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">AANLkTimd6AxafFDFxmY4w88kgWr6_aRcykkXkd2jzKUi at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;utf-8&quot;
</I>&gt;<i> 
</I>&gt;<i> Looks promising, thanks for the effort, and specially the stricter
</I>checks
&gt;<i> result summary.
</I>&gt;<i> 
</I>&gt;<i> Rafael &quot;Monoman&quot; Teixeira
</I>&gt;<i> ---------------------------------------
</I>&gt;<i> &quot;To be creative means to be in love with life. You can be creative only
</I>if
&gt;<i> you love life enough that you want to enhance its beauty, you want to
</I>bring
&gt;<i> a little more music to it, a little more poetry to it, a little more
</I>dance
&gt;<i> to it.&quot;
</I>&gt;<i> Osho
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On Tue, Jun 22, 2010 at 2:29 PM, Elijah Taylor
</I>&gt;<i> &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">elijahtaylor at google.com</A>&gt;wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> Greetings Mono Developers,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Attached is a patch to support 32-bit x86 code generation for Google
</I>&gt;&gt;<i> Native
</I>&gt;&gt;<i> Client (<A HREF="http://code.google.com/p/nativeclient/">http://code.google.com/p/nativeclient/</A>).  I encourage you to
</I>&gt;&gt;<i> browse our project for more information if you're curious.  I apologize
</I>&gt;&gt;<i> for
</I>&gt;&gt;<i> the large diff, let me try to explain the highlights to make it easier
</I>to
&gt;&gt;<i> digest.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There is a code generation component (define:
</I>__native_client_codegen__)
&gt;&gt;<i> which affects the Mono bytecode -&gt; native code generation for x86-32. 
</I>&gt;&gt;<i> There
</I>&gt;&gt;<i> are a set of alignment restrictions, illegal instructions, and
</I>&gt;&gt;<i> replacement
</I>&gt;&gt;<i> instructions we use for Native Client to ensure proper control-flow
</I>&gt;&gt;<i> sandboxing.  Please see
</I>&gt;&gt;<i>
</I><A HREF="http://nativeclient.googlecode.com/svn/data/docs_tarball/nacl/googleclient/native_client/documentation/nacl_paper.pdffor">http://nativeclient.googlecode.com/svn/data/docs_tarball/nacl/googleclient/native_client/documentation/nacl_paper.pdffor</A>
&gt;&gt;<i> more details.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> There is also a runtime component (define: __native_client__) which
</I>&gt;&gt;<i> modifies or disables some functionality to be compatible with the
</I>Native
&gt;&gt;<i> Client runtime.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> We also had to modify some code that doesn't fall under either of the
</I>&gt;&gt;<i> above
</I>&gt;&gt;<i> defines.  Most of these changes revolved around type safety.  The
</I>&gt;&gt;<i> modified
</I>&gt;&gt;<i> version of gcc we use to compile Native Client modules is more strict
</I>&gt;&gt;<i> about
</I>&gt;&gt;<i> types, and it caught what look like legitimate issues with the Mono
</I>&gt;&gt;<i> codebase.  The largest issue in terms of number of errors was the use
</I>of
&gt;&gt;<i> mono_bool and gboolean interchangeably between declaration and
</I>&gt;&gt;<i> definition of
</I>&gt;&gt;<i> many functions.  gboolean is defined as an &quot;int&quot; but mono_bool is
</I>&gt;&gt;<i> defined as
</I>&gt;&gt;<i> int32_t.  Other type issues are listed directly below.  Feedback is
</I>&gt;&gt;<i> appreciated on these changes because of our unfamiliarity with this
</I>code,
&gt;&gt;<i> but I modified these in the way that seemed most &quot;right&quot; at the time.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> mono/metadata/decimal.h:47 mono_decimal2string int -&gt; gint32
</I>&gt;&gt;<i> mono/metadata/filewatcher.h:28 gboolean -&gt; int
</I>&gt;&gt;<i> mono/metadata/filewatcher.c:158 int32 -&gt; gint32
</I>&gt;&gt;<i> mono/metadata/threads-type.h:64 int -&gt; gint32
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> mono/mini/mini.h:1546  gboolean sort_end -&gt; int sort_type
</I>&gt;&gt;<i> mono/mini/mini.h:1733  gboolean fp -&gt; int bank
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> The last bit of modification is to genmdesc and the Makefiles in
</I>general.
&gt;&gt;<i> We added a new flag to genmdesc called &quot;nacl&quot; which overrides the given
</I>&gt;&gt;<i> max
</I>&gt;&gt;<i> length of an instruction.  Native Client code tends to be larger
</I>because
&gt;&gt;<i> of
</I>&gt;&gt;<i> some of the instruction requirements we have, so some of the
</I>&gt;&gt;<i> instructions in
</I>&gt;&gt;<i> cpu-x86.md had to be modified.  This is all tied to a new configure
</I>flag
&gt;&gt;<i> called &quot;--enable-nacl-codegen&quot;, which enables the codegen define, and
</I>&gt;&gt;<i> sets
</I>&gt;&gt;<i> up calls to genmdesc with a --nacl flag.  It also modifies the
</I>&gt;&gt;<i> mono-wrapper
</I>&gt;&gt;<i> script so one aspect of our code generation rules (masking jump targets
</I>&gt;&gt;<i> to
</I>&gt;&gt;<i> 32-byte boundaries) is turned off while compiling and testing mono from
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> Makefiles, which is required when testing outside of the Native Client
</I>&gt;&gt;<i> environment.  We're also including a standalone check &quot;fsacheck&quot; which
</I>&gt;&gt;<i> tests
</I>&gt;&gt;<i> mono code generation as full AOT and a the library linked into a fully
</I>&gt;&gt;<i> static executable.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I look forward to your comments, questions, and suggestions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> -Elijah Taylor
</I>&gt;&gt;<i> Google Native Client Team
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> An HTML attachment was scrubbed...
</I>&gt;<i> URL:
</I>&gt;<i>
</I><A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20100625/d8b3eee7/attachment-0001.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20100625/d8b3eee7/attachment-0001.html</A>
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 2
</I>&gt;<i> Date: Fri, 25 Jun 2010 21:17:43 +0200
</I>&gt;<i> From: Zoltan Varga &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">vargaz at gmail.com</A>&gt;
</I>&gt;<i> Subject: Re: [Mono-dev] [PATCH] mono_debugger_agent_thread_interrupt
</I>&gt;<i> 	signature mismatch
</I>&gt;<i> To: Angus &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">wangdongming at hipihi.com</A>&gt;
</I>&gt;<i> Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> Message-ID:
</I>&gt;<i> 	&lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">AANLkTikvPoA6VQwJPRhL3ELDx4--A5BjKoL3Eb_jLQMI at mail.gmail.com</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;iso-8859-1&quot;
</I>&gt;<i> 
</I>&gt;<i> No idea, probably the same as on linux.
</I>&gt;<i> 
</I>&gt;<i>             Zoltan
</I>&gt;<i> 
</I>&gt;<i> On Thu, Apr 15, 2010 at 3:50 AM, Angus &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">wangdongming at hipihi.com</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> HI,I'm so sorry to bother you .
</I>&gt;&gt;<i> Could you tell me how to use the --debugger-agent command in windows?
</I>&gt;&gt;<i> Thanks.
</I>&gt;&gt;<i> --
</I>&gt;&gt;<i> View this message in context:
</I>&gt;&gt;<i>
</I><A HREF="http://n4.nabble.com/PATCH-mono-debugger-agent-thread-interrupt-signature-mismatch-tp1523348p1840703.html">http://n4.nabble.com/PATCH-mono-debugger-agent-thread-interrupt-signature-mismatch-tp1523348p1840703.html</A>
&gt;&gt;<i> Sent from the Mono - Dev mailing list archive at Nabble.com.
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;<i>
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> An HTML attachment was scrubbed...
</I>&gt;<i> URL:
</I>&gt;<i>
</I><A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20100625/7fa587a4/attachment-0001.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20100625/7fa587a4/attachment-0001.html</A>
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 3
</I>&gt;<i> Date: Sat, 26 Jun 2010 11:36:17 +0900
</I>&gt;<i> From: &quot;KISHIMOTO, Makoto&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ksmakoto at dd.iij4u.or.jp</A>&gt;
</I>&gt;<i> Subject: [Mono-dev] svn trunk build fails, 'SIGPWR' undeclared
</I>&gt;<i> To: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">20100626113617.be122cd2.ksmakoto at dd.iij4u.or.jp</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=US-ASCII
</I>&gt;<i> 
</I>&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;<i> In my FreeBSD box, mono SVN trunk build fails. FreeBSD has no SIGPWR .
</I>&gt;<i> Signal 29 of FreeBSD is SIGINFO .
</I>&gt;<i> 
</I>&gt;<i> ../../doltlibtool --tag=CC   --mode=compile gcc -DHAVE_CONFIG_H -I.
</I>&gt;<i> -I../../../mono/mono/metadata -I../.. -I../../../mono
</I>-I../../../mono/mono
&gt;<i> -I../../../mono/libgc/include -I../../../mono/eglib/src
</I>-I../../eglib/src
&gt;<i> -DMONO_BINDIR=\&quot;/usr/local/bin/\&quot; -DMONO_ASSEMBLIES=\&quot;/usr/local/lib\&quot;
</I>&gt;<i> -DMONO_CFG_DIR=\&quot;/usr/local/etc\&quot;  -DGC_FREEBSD_THREADS -DPLATFORM_BSD 
</I>&gt;<i> -DHAVE_SGEN_GC -DHAVE_MOVING_COLLECTOR -DHAVE_WRITE_BARRIERS -g -O2
</I>&gt;<i> -fno-strict-aliasing -Wdeclaration-after-statement -g -Wall -Wunused
</I>&gt;<i> -Wmissing-prototypes -Wmissing-declarations -Wstrict-prototypes 
</I>&gt;<i> -Wmissing-prototypes -Wnested-externs -Wpointer-arith -Wno-cast-qual
</I>&gt;<i> -Wwrite-strings -mno-tls-direct-seg-refs -MT
</I>&gt;<i> libmonoruntimesgen_la-sgen-os-posix.lo -MD -MP -MF
</I>&gt;<i> .deps/libmonoruntimesgen_la-sgen-os-posix.Tpo -c -o
</I>&gt;<i> libmonoruntimesgen_la-sgen-os-posix.lo `test -f 'sgen-os-posix.c' ||
</I>echo
&gt;<i> '../../../mono/mono/metadata/'`sgen-os-posix.c
</I>&gt;<i> In file included from ../../../mono/mono/metadata/sgen-os-posix.c:35:
</I>&gt;<i> ../../../mono/mono/metadata/sgen-gc.h:93: error: 'SIGPWR' undeclared
</I>here
&gt;<i> (not in a function)
</I>&gt;<i> gmake[3]: *** [libmonoruntimesgen_la-sgen-os-posix.lo] Error 1
</I>&gt;<i> gmake[3]: Leaving directory
</I>&gt;<i> `/export/home/ksmakoto/Mono/BUILD/mono/metadata'
</I>&gt;<i> gmake[2]: *** [all-recursive] Error 1
</I>&gt;<i> gmake[2]: Leaving directory `/export/home/ksmakoto/Mono/BUILD/mono'
</I>&gt;<i> gmake[1]: *** [all-recursive] Error 1
</I>&gt;<i> gmake[1]: Leaving directory `/export/home/ksmakoto/Mono/BUILD'
</I>&gt;<i> gmake: *** [all] Error 2
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> Message: 4
</I>&gt;<i> Date: Sun, 27 Jun 2010 13:24:48 +0100
</I>&gt;<i> From: Chris Bacon &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">chris at dunelm.org.uk</A>&gt;
</I>&gt;<i> Subject: Re: [Mono-dev] Patch 2/2 - Tests for
</I>&gt;<i> 	System.Diagnostics.Contracts in corlib
</I>&gt;<i> To: Miguel de Icaza &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">miguel at novell.com</A>&gt;
</I>&gt;<i> Cc: Marek Safar &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">marek.safar at seznam.cz</A>&gt;,
</I>&gt;<i> 	<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>,	<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">miguel.novell at gmail.com</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">4C274310.40900 at dunelm.org.uk</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=&quot;iso-8859-1&quot;
</I>&gt;<i> 
</I>&gt;<i> Hi,
</I>&gt;<i> 
</I>&gt;<i> Last Thursday, 24th, I followed these instructions and sent my public 
</I>&gt;<i> SSH key to <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">miguel at ximian.com.</A>
</I>&gt;<i> Should I expect to hear something back?
</I>&gt;<i> 
</I>&gt;<i> Thanks
</I>&gt;<i> Chris
</I>&gt;<i> 
</I>&gt;<i> Miguel de Icaza wrote:
</I>&gt;&gt;<i> Hey Chris,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     Could you get these commited yourself?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>     For this you will need an SVN key, follow the steps here:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 	www.mono-project.com/SVN
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   
</I>&gt;&gt;&gt;<i> Hi,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Updated patch attached. I've checked that all tests still pass.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The delegate has been removed, and #if NET_4_0 now surrounds the whole
</I>
&gt;&gt;&gt;<i> of each file.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> However, the #defines are not un-defined at the end of each file, as I
</I>
&gt;&gt;&gt;<i> don't think this is possible in C#, as all #define and #undef
</I>&gt;&gt;&gt;<i> statements
</I>&gt;&gt;&gt;<i> have to be before any code. Please let me know if there is a way of 
</I>&gt;&gt;&gt;<i> #undef-ing another way.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Thanks
</I>&gt;&gt;&gt;<i> Chris
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Marek Safar wrote:
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;&gt;&gt;<i> Hello Chris,
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Only a few small issues
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Undefined these at the end of each file. They perhaps should be
</I>inside 
&gt;&gt;&gt;&gt;<i> #if NET_4_0 too.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> +        // Required when compiling/running under .NET3.5
</I>&gt;&gt;&gt;&gt;<i> +        delegate void Action&lt;T1, T2, T3, T4, T5&gt; (T1 arg1, T2 arg2, 
</I>&gt;&gt;&gt;&gt;<i> T3 arg3, T4 arg4, T5 arg5);
</I>&gt;&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Why is it needed when NET_4_0 is used for whole file ?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> When fixed please commit. Thanks!
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Marek
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>       
</I>&gt;&gt;&gt;&gt;&gt;<i> Hi,
</I>&gt;&gt;&gt;&gt;&gt;<i> I've attached a new patch with slightly better formatting - it uses 
</I>&gt;&gt;&gt;&gt;&gt;<i> tabs rather than spaces.
</I>&gt;&gt;&gt;&gt;&gt;<i> Kind regards
</I>&gt;&gt;&gt;&gt;&gt;<i> Chris
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Chris Bacon wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> Hi,
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> Here are the tests to add to corlib for
</I>System.Diagnostics.Contracts.
&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> Please let me know what changes are required.
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> Kind regards
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> Chris
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>------------------------------------------------------------------------
&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;&gt;&gt;&gt;&gt;<i>           
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>------------------------------------------------------------------------
&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;&gt;&gt;&gt;<i>         
</I>&gt;&gt;&gt;<i> plain text document attachment (CodeContractsTest.patch)
</I>&gt;&gt;&gt;<i> Index: corlib_test.dll.sources
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> --- corlib_test.dll.sources	(revision 159418)
</I>&gt;&gt;&gt;<i> +++ corlib_test.dll.sources	(working copy)
</I>&gt;&gt;&gt;<i> @@ -60,6 +60,14 @@
</I>&gt;&gt;&gt;<i>  System.Diagnostics/StackFrameTest.cs
</I>&gt;&gt;&gt;<i>  System.Diagnostics/StackTraceTest.cs
</I>&gt;&gt;&gt;<i>  System.Diagnostics/TextWriterTraceListenerTest.cs
</I>&gt;&gt;&gt;<i> +System.Diagnostics.Contracts/ContractAssertTest.cs
</I>&gt;&gt;&gt;<i> +System.Diagnostics.Contracts/ContractAssumeTest.cs
</I>&gt;&gt;&gt;<i> +System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs
</I>&gt;&gt;&gt;<i> +System.Diagnostics.Contracts/ContractHelperTest.cs
</I>&gt;&gt;&gt;<i> +System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs
</I>&gt;&gt;&gt;<i> +System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs
</I>&gt;&gt;&gt;<i> +System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs
</I>&gt;&gt;&gt;<i> +System.Diagnostics.Contracts/Helpers/TestContractBase.cs
</I>&gt;&gt;&gt;<i>  System/DoubleFormatterTest.cs
</I>&gt;&gt;&gt;<i>  System/DoubleTest.cs
</I>&gt;&gt;&gt;<i>  System/EnumTest.cs
</I>&gt;&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractAssumeTest.cs
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ContractAssumeTest.cs	(revision
</I>0)
&gt;&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ContractAssumeTest.cs	(revision
</I>0)
&gt;&gt;&gt;<i> @@ -0,0 +1,47 @@
</I>&gt;&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +using System;
</I>&gt;&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;&gt;<i> +	public class ContractAssumeTest : TestContractBase {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// At runtime Contract.Assume() acts just like a
</I>Contract.Assert(),
&gt;&gt;&gt;<i> except the exact message in the assert
</I>&gt;&gt;&gt;<i> +		/// or exception is slightly different.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test]
</I>&gt;&gt;&gt;<i> +		public void TestAssumeMessage ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Assume (false);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestAssumeMessage() exception not thrown #1&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof(NotImplementedException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestAssumeMessage() wrong exception type #1&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Assume (false, &quot;Message&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestAssumeMessage() exception not thrown #1&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof(NotImplementedException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestAssumeMessage() wrong exception type #1&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		// Identical to Contract.Assert, so no more testing required.
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Property changes on:
</I>&gt;&gt;&gt;<i> Test/System.Diagnostics.Contracts/ContractAssumeTest.cs
</I>&gt;&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;&gt;<i>    + native
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Index:
</I>&gt;&gt;&gt;<i> Test/System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> ---
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> +++
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> @@ -0,0 +1,129 @@
</I>&gt;&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +using System;
</I>&gt;&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;&gt;<i> +	public class ContractCollectionMethodsTest {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Exists() determines that at least one element in the
</I>&gt;&gt;&gt;<i> collection satisfies the predicate.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestExistsInt ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Exists (0, 10, null);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestExistsInt() no exception #1&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestExistsInt() wrong exception #1&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Exists (10, 0, i =&gt; false);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestExistsInt() no exception #2&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestExistsInt() wrong exception #2&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (Contract.Exists (0, 10, i =&gt; i &lt;= 0),
</I>&gt;&gt;&gt;<i> &quot;TestExistsInt() #1&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (Contract.Exists (0, 10, i =&gt; i &gt;= 9),
</I>&gt;&gt;&gt;<i> &quot;TestExistsInt() #2&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (Contract.Exists (0, 10, i =&gt; i &lt; 0),
</I>&gt;&gt;&gt;<i> &quot;TestExistsInt() #3&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (Contract.Exists (0, 10, i =&gt; i &gt; 9),
</I>&gt;&gt;&gt;<i> &quot;TestExistsInt() #4&quot;);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Exists() determines that at least one element in the
</I>&gt;&gt;&gt;<i> collection satisfies the predicate.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestExistsEnumeration ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Exists (Enumerable.Range (0, 10), null);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestExistsEnumeration() no exception #1&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestExistsEnumeration() wrong exception #1&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Exists&lt;int&gt; (null, x =&gt; false);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestExistsEnumeration() no exception #2&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestExistsEnumeration() wrong exception #2&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			var en = Enumerable.Range (0, 10);
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (Contract.Exists (en, i =&gt; i &lt;= 0),
</I>&gt;&gt;&gt;<i> &quot;TestExistsEnumeration() #1&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (Contract.Exists (en, i =&gt; i &gt;= 9),
</I>&gt;&gt;&gt;<i> &quot;TestExistsEnumeration() #2&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (Contract.Exists (en, i =&gt; i &lt; 0),
</I>&gt;&gt;&gt;<i> &quot;TestExistsEnumeration() #3&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (Contract.Exists (en, i =&gt; i &gt; 9),
</I>&gt;&gt;&gt;<i> &quot;TestExistsEnumeration() #4&quot;);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.ForAll() determines if all elements in the collection
</I>&gt;&gt;&gt;<i> satisfy the predicate.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestForAllInt ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.ForAll (0, 10, null);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestForAllInt() no exception #1&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestForAllInt() wrong exception #1&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.ForAll (10, 0, i =&gt; false);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestForAllInt() no exception #2&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestForAllInt() wrong exception #2&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (Contract.ForAll (0, 10, i =&gt; i &lt;= 9),
</I>&gt;&gt;&gt;<i> &quot;TestForAllInt() #1&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (Contract.ForAll (0, 10, i =&gt; i &gt;= 0),
</I>&gt;&gt;&gt;<i> &quot;TestForAllInt() #2&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (Contract.ForAll (0, 10, i =&gt; i &lt; 9),
</I>&gt;&gt;&gt;<i> &quot;TestForAllInt() #3&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (Contract.ForAll (0, 10, i =&gt; i &gt; 0),
</I>&gt;&gt;&gt;<i> &quot;TestForAllInt() #4&quot;);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.ForAll() determines if all elements in the collection
</I>&gt;&gt;&gt;<i> satisfy the predicate.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestForAllEnumeration ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.ForAll (Enumerable.Range (0, 10), null);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestForAllEnumeration() no exception #1&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestForAllEnumeration() wrong exception #1&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.ForAll&lt;int&gt; (null, x =&gt; false);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestForAllEnumeration() no exception #2&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestForAllEnumeration() wrong exception #2&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			var en = Enumerable.Range (0, 10);
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (Contract.ForAll (en, i =&gt; i &lt;= 9),
</I>&gt;&gt;&gt;<i> &quot;TestForAllEnumeration() #1&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (Contract.ForAll (en, i =&gt; i &gt;= 0),
</I>&gt;&gt;&gt;<i> &quot;TestForAllEnumeration() #2&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (Contract.ForAll (en, i =&gt; i &lt; 9),
</I>&gt;&gt;&gt;<i> &quot;TestForAllEnumeration() #3&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (Contract.ForAll (en, i =&gt; i &gt; 0),
</I>&gt;&gt;&gt;<i> &quot;TestForAllEnumeration() #4&quot;);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Property changes on:
</I>&gt;&gt;&gt;<i> Test/System.Diagnostics.Contracts/ContractCollectionMethodsTest.cs
</I>&gt;&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;&gt;<i>    + native
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractHelperTest.cs
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ContractHelperTest.cs	(revision
</I>0)
&gt;&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ContractHelperTest.cs	(revision
</I>0)
&gt;&gt;&gt;<i> @@ -0,0 +1,258 @@
</I>&gt;&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +using System;
</I>&gt;&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics.Contracts.Internal;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;&gt;<i> +using NUnit.Framework.Constraints;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;&gt;<i> +	public class ContractHelperTest : TestContractBase {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		private void CheckAllMessages (ContractFailureKind kind, string
</I>&gt;&gt;&gt;<i> messageStart, Action&lt;string, Exception, string, ContractFailureKind,
</I>&gt;&gt;&gt;<i> Func&lt;string&gt;&gt; fnAssert)
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			foreach (Exception ex in new [] { null, new ArgumentNullException
</I>&gt;&gt;&gt;<i> () }) {
</I>&gt;&gt;&gt;<i> +				fnAssert (messageStart + &quot;.&quot;, ex, null, kind, () =&gt; {
</I>&gt;&gt;&gt;<i> +					return ContractHelper.RaiseContractFailedEvent (kind, null,
</I>null,
&gt;&gt;&gt;<i> ex);
</I>&gt;&gt;&gt;<i> +				});
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +				fnAssert (messageStart + &quot;.  Message&quot;, ex, null, kind, () =&gt; {
</I>&gt;&gt;&gt;<i> +					return ContractHelper.RaiseContractFailedEvent (kind, &quot;Message&quot;,
</I>&gt;&gt;&gt;<i> null, ex);
</I>&gt;&gt;&gt;<i> +				});
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +				fnAssert (messageStart + &quot;: Condition&quot;, ex, &quot;Condition&quot;, kind, ()
</I>&gt;&gt;&gt;<i> =&gt; {
</I>&gt;&gt;&gt;<i> +					return ContractHelper.RaiseContractFailedEvent (kind, null,
</I>&gt;&gt;&gt;<i> &quot;Condition&quot;, ex);
</I>&gt;&gt;&gt;<i> +				});
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +				fnAssert (messageStart + &quot;: Condition  Message&quot;, ex, &quot;Condition&quot;,
</I>&gt;&gt;&gt;<i> kind, () =&gt; {
</I>&gt;&gt;&gt;<i> +					return ContractHelper.RaiseContractFailedEvent (kind, &quot;Message&quot;,
</I>&gt;&gt;&gt;<i> &quot;Condition&quot;, ex);
</I>&gt;&gt;&gt;<i> +				});
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		private void CheckAllKinds (Action&lt;string, Exception, string,
</I>&gt;&gt;&gt;<i> ContractFailureKind, Func&lt;string&gt;&gt; fnAssert)
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Assert, &quot;Assertion
</I>&gt;&gt;&gt;<i> failed&quot;, fnAssert);
</I>&gt;&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Assume, &quot;Assumption
</I>&gt;&gt;&gt;<i> failed&quot;, fnAssert);
</I>&gt;&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Invariant, &quot;Invariant
</I>&gt;&gt;&gt;<i> failed&quot;, fnAssert);
</I>&gt;&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Postcondition,
</I>&gt;&gt;&gt;<i> &quot;Postcondition failed&quot;, fnAssert);
</I>&gt;&gt;&gt;<i> +			this.CheckAllMessages
</I>&gt;&gt;&gt;<i> (ContractFailureKind.PostconditionOnException, &quot;Postcondition failed
</I>&gt;&gt;&gt;<i> after throwing an exception&quot;, fnAssert);
</I>&gt;&gt;&gt;<i> +			this.CheckAllMessages (ContractFailureKind.Precondition,
</I>&gt;&gt;&gt;<i> &quot;Precondition failed&quot;, fnAssert);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		private void CheckAllKinds (Action&lt;string, Exception, Func&lt;string&gt;&gt;
</I>&gt;&gt;&gt;<i> fnAssert)
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			this.CheckAllKinds ((expected, ex, condition, kind, fnTest) =&gt;
</I>&gt;&gt;&gt;<i> fnAssert (expected, ex, fnTest));
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// If no event handler is present, then the string returned
</I>&gt;&gt;&gt;<i> describes the condition failure.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestRaiseContractFailedEventNoHandler ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			this.CheckAllKinds ((expected, ex, fnTest) =&gt; {
</I>&gt;&gt;&gt;<i> +				string msg = fnTest ();
</I>&gt;&gt;&gt;<i> +				Assert.AreEqual (expected, msg,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractFailedEventNoHandler() incorrect message&quot;);
</I>&gt;&gt;&gt;<i> +			});
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// When SetHandled() is called, null is returned.
</I>&gt;&gt;&gt;<i> +		/// The event args are also checked.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestRaiseContractFailedEventHandled ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			string expectedMsg = null;
</I>&gt;&gt;&gt;<i> +			Exception originalException = null;
</I>&gt;&gt;&gt;<i> +			string expectedCondition = null;
</I>&gt;&gt;&gt;<i> +			ContractFailureKind expectedKind = ContractFailureKind.Assert;
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				Assert.AreEqual (expectedMsg, e.Message,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractFailedEventHandled() event message wrong&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.AreSame (originalException, e.OriginalException,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractFailedEventHandled() event exception wrong&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.AreEqual (expectedCondition, e.Condition,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractFailedEventHandled() event condition wrong&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.AreEqual (expectedKind, e.FailureKind,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractFailedEventHandled() event failure kind wrong&quot;);
</I>&gt;&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			this.CheckAllKinds ((expected, ex, condition, kind, fnTest) =&gt; {
</I>&gt;&gt;&gt;<i> +				expectedMsg = expected;
</I>&gt;&gt;&gt;<i> +				originalException = ex;
</I>&gt;&gt;&gt;<i> +				expectedCondition = condition;
</I>&gt;&gt;&gt;<i> +				expectedKind = kind;
</I>&gt;&gt;&gt;<i> +				string msg = fnTest ();
</I>&gt;&gt;&gt;<i> +				Assert.IsNull (msg, &quot;TestRaiseContractFailedEventHandled()
</I>&gt;&gt;&gt;<i> expected null message&quot;);
</I>&gt;&gt;&gt;<i> +			});
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// When SetUnwind() is called, a ContractException is thrown. If
</I>an
&gt;&gt;&gt;<i> innerException is passed, then
</I>&gt;&gt;&gt;<i> +		/// it is put in the InnerException of the ContractException.
</I>&gt;&gt;&gt;<i> Otherwise, the InnerException is set to null.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestRaiseContractFailedEventUnwind ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				e.SetUnwind ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			this.CheckAllKinds ((expected, expectedEx, fnTest) =&gt; {
</I>&gt;&gt;&gt;<i> +				try {
</I>&gt;&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;&gt;<i> +					Assert.Fail (&quot;TestRaiseContractFailedEventUnwind() exception not
</I>&gt;&gt;&gt;<i> thrown&quot;);
</I>&gt;&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +					Assert.IsInstanceOfType (base.ContractExceptionType, ex,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractFailedEventUnwind() wrong exception type&quot;);
</I>&gt;&gt;&gt;<i> +					if (expectedEx == null) {
</I>&gt;&gt;&gt;<i> +						Assert.IsNull (ex.InnerException,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractFailedEventUnwind() inner exception should be
</I>null&quot;);
&gt;&gt;&gt;<i> +					} else {
</I>&gt;&gt;&gt;<i> +						Assert.AreSame (expectedEx, ex.InnerException,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractFailedEventUnwind() wrong inner exception type&quot;);
</I>&gt;&gt;&gt;<i> +					}
</I>&gt;&gt;&gt;<i> +				}
</I>&gt;&gt;&gt;<i> +			});
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// When the ContractFailed event throws an exception, then it
</I>&gt;&gt;&gt;<i> becomes the inner exception of the
</I>&gt;&gt;&gt;<i> +		/// ContractException. Except if an exception is passed in to the
</I>&gt;&gt;&gt;<i> call, then that exception is put
</I>&gt;&gt;&gt;<i> +		/// in the InnerException.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestRaiseContractFailedEventThrows ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				throw new InvalidOperationException ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			this.CheckAllKinds ((expected, expectedEx, fnTest) =&gt; {
</I>&gt;&gt;&gt;<i> +				try {
</I>&gt;&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;&gt;<i> +					Assert.Fail (&quot;TestRaiseContractFailedEventThrows() exception not
</I>&gt;&gt;&gt;<i> thrown&quot;);
</I>&gt;&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +					Assert.IsInstanceOfType (base.ContractExceptionType, ex,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractFailedEventThrows() wrong exception type&quot;);
</I>&gt;&gt;&gt;<i> +					Type expectedInnerExceptionType = expectedEx == null ? typeof
</I>&gt;&gt;&gt;<i> (InvalidOperationException) : expectedEx.GetType ();
</I>&gt;&gt;&gt;<i> +					Assert.IsInstanceOfType (expectedInnerExceptionType,
</I>&gt;&gt;&gt;<i> ex.InnerException, &quot;TestRaiseContractFailedEventThrows() wrong inner
</I>&gt;&gt;&gt;<i> exception type&quot;);
</I>&gt;&gt;&gt;<i> +				}
</I>&gt;&gt;&gt;<i> +			});
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Both event handlers should be called, constraint is not
</I>handled.
&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestRaiseContractMultipleHandlers1 ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			bool visited1, visited2;
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited1 = true;
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited2 = true;
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			this.CheckAllKinds ((expected, ex, fnTest) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited1 = visited2 = false;
</I>&gt;&gt;&gt;<i> +				string msg = fnTest ();
</I>&gt;&gt;&gt;<i> +				Assert.AreEqual (expected, msg,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractMultipleHandlers1() msg not as expected&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.IsTrue (visited1, &quot;TestRaiseContractMultipleHandlers1()
</I>&gt;&gt;&gt;<i> handler 1 not visited&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.IsTrue (visited2, &quot;TestRaiseContractMultipleHandlers1()
</I>&gt;&gt;&gt;<i> handler 2 not visited&quot;);
</I>&gt;&gt;&gt;<i> +			});
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Both event handlers should be called. SetUnwind() takes
</I>&gt;&gt;&gt;<i> precedent over SetHandled().
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestRaiseContractMultipleHandlers2 ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			bool visited1, visited2;
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited1 = true;
</I>&gt;&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited2 = true;
</I>&gt;&gt;&gt;<i> +				e.SetUnwind ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			this.CheckAllKinds ((expected, expectedEx, fnTest) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited1 = visited2 = false;
</I>&gt;&gt;&gt;<i> +				try {
</I>&gt;&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;&gt;<i> +					Assert.Fail (&quot;TestRaiseContractMultipleHandlers2() exception not
</I>&gt;&gt;&gt;<i> thrown&quot;);
</I>&gt;&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +					Assert.IsInstanceOfType (base.ContractExceptionType, ex,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractMultipleHandlers2() wrong exception type&quot;);
</I>&gt;&gt;&gt;<i> +					if (expectedEx == null) {
</I>&gt;&gt;&gt;<i> +						Assert.IsNull (ex.InnerException,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractMultipleHandlers2() inner exception not null&quot;);
</I>&gt;&gt;&gt;<i> +					} else {
</I>&gt;&gt;&gt;<i> +						Assert.AreSame (expectedEx, ex.InnerException,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractMultipleHandlers2() wrong inner exception&quot;);
</I>&gt;&gt;&gt;<i> +					}
</I>&gt;&gt;&gt;<i> +					Assert.IsTrue (visited1, &quot;TestRaiseContractMultipleHandlers2()
</I>&gt;&gt;&gt;<i> handler 1 not visited&quot;);
</I>&gt;&gt;&gt;<i> +					Assert.IsTrue (visited2, &quot;TestRaiseContractMultipleHandlers2()
</I>&gt;&gt;&gt;<i> handler 2 not visited&quot;);
</I>&gt;&gt;&gt;<i> +				}
</I>&gt;&gt;&gt;<i> +			});
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Both event handlers should be called. The exceptions are
</I>treated
&gt;&gt;&gt;<i> as calls to SetUnwind(), with
</I>&gt;&gt;&gt;<i> +		/// the exception being put in the InnerException.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestRaiseContractMultipleHandlers3 ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			bool visited1, visited2;
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited1 = true;
</I>&gt;&gt;&gt;<i> +				throw new InvalidOperationException ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited2 = true;
</I>&gt;&gt;&gt;<i> +				throw new InvalidOperationException ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			this.CheckAllKinds ((expected, expectedEx, fnTest) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited1 = visited2 = false;
</I>&gt;&gt;&gt;<i> +				try {
</I>&gt;&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;&gt;<i> +					Assert.Fail (&quot;TestRaiseContractMultipleHandlers3() failed to
</I>&gt;&gt;&gt;<i> throw exception&quot;);
</I>&gt;&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +					Type expectedInnerExceptionType = expectedEx == null ? typeof
</I>&gt;&gt;&gt;<i> (InvalidOperationException) : expectedEx.GetType ();
</I>&gt;&gt;&gt;<i> +					Assert.IsInstanceOfType (base.ContractExceptionType, ex,
</I>&gt;&gt;&gt;<i> &quot;TestRaiseContractMultipleHandlers3() wrong exception type&quot;);
</I>&gt;&gt;&gt;<i> +					Assert.IsInstanceOfType (expectedInnerExceptionType,
</I>&gt;&gt;&gt;<i> ex.InnerException, &quot;TestRaiseContractMultipleHandlers3() wrong inner
</I>&gt;&gt;&gt;<i> exception type&quot;);
</I>&gt;&gt;&gt;<i> +					Assert.IsTrue (visited1, &quot;TestRaiseContractMultipleHandlers3()
</I>&gt;&gt;&gt;<i> handler 1 not visited&quot;);
</I>&gt;&gt;&gt;<i> +					Assert.IsTrue (visited2, &quot;TestRaiseContractMultipleHandlers3()
</I>&gt;&gt;&gt;<i> handler 2 not visited&quot;);
</I>&gt;&gt;&gt;<i> +				}
</I>&gt;&gt;&gt;<i> +			});
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.TriggerFailure() triggers the assert. Check that the
</I>&gt;&gt;&gt;<i> assert is triggered, with the correct text.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test]
</I>&gt;&gt;&gt;<i> +		public void TestTriggerFailure ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				ContractHelper.TriggerFailure (ContractFailureKind.Assert,
</I>&gt;&gt;&gt;<i> &quot;Display&quot;, null, &quot;Condition&quot;, null);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestTriggerFailure() failed to throw exception&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType(typeof(NotImplementedException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestTriggerFailure() wrong exception type&quot;);
</I>&gt;&gt;&gt;<i> +				//Assert.AreEqual (&quot;Expression: Condition&quot; + Environment.NewLine
</I>+
&gt;&gt;&gt;<i> &quot;Description: Display&quot;, ex.Message, &quot;TestTriggerFailure() wrong
</I>&gt;&gt;&gt;<i> message&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Property changes on:
</I>&gt;&gt;&gt;<i> Test/System.Diagnostics.Contracts/ContractHelperTest.cs
</I>&gt;&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;&gt;<i>    + native
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Index:
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs
&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> ---
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> +++
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> @@ -0,0 +1,18 @@
</I>&gt;&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +using System;
</I>&gt;&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts.Helpers {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
</I>&gt;&gt;&gt;<i> +	class RunAgainstReferenceAttribute : CategoryAttribute
</I>&gt;&gt;&gt;<i> +	{
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Property changes on:
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/Helpers/RunAgainstReferenceAttribute.cs
&gt;&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;&gt;<i>    + native
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/Helpers/TestContractBase.cs
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> ---
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/Helpers/TestContractBase.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> +++
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/Helpers/TestContractBase.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> @@ -0,0 +1,48 @@
</I>&gt;&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +using System;
</I>&gt;&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics;
</I>&gt;&gt;&gt;<i> +using System.Reflection;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics.Contracts.Internal;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts.Helpers {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	public class TestContractBase {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		protected TestContractBase() {
</I>&gt;&gt;&gt;<i> +			// Get the type of System.Diagnostics.Contracts.ContractException
</I>&gt;&gt;&gt;<i> +			// Have to do this differently depending on how the test is being
</I>&gt;&gt;&gt;<i> run.
</I>&gt;&gt;&gt;<i> +			this.ContractExceptionType =
</I>&gt;&gt;&gt;<i> Type.GetType(&quot;System.Diagnostics.Contracts.ContractException&quot;);
</I>&gt;&gt;&gt;<i> +			if (this.ContractExceptionType == null) {
</I>&gt;&gt;&gt;<i> +				// Special code for when Contracts namespace is not in CorLib
</I>&gt;&gt;&gt;<i> +				var mGetContractExceptionType = typeof (Contract).GetMethod
</I>&gt;&gt;&gt;<i> (&quot;GetContractExceptionType&quot;, BindingFlags.NonPublic |
</I>&gt;&gt;&gt;<i> BindingFlags.Static);
</I>&gt;&gt;&gt;<i> +				this.ContractExceptionType = (Type)
</I>&gt;&gt;&gt;<i> mGetContractExceptionType.Invoke (null, null);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		[SetUp]
</I>&gt;&gt;&gt;<i> +		public void Setup() {
</I>&gt;&gt;&gt;<i> +			// Remove all event handlers from Contract.ContractFailed
</I>&gt;&gt;&gt;<i> +			var eventField = typeof(Contract).GetField(&quot;ContractFailed&quot;,
</I>&gt;&gt;&gt;<i> BindingFlags.Static | BindingFlags.NonPublic);
</I>&gt;&gt;&gt;<i> +			if (eventField == null) {
</I>&gt;&gt;&gt;<i> +				// But in MS.NET it's done this way.
</I>&gt;&gt;&gt;<i> +				eventField =
</I>&gt;&gt;&gt;<i> typeof(ContractHelper).GetField(&quot;contractFailedEvent&quot;,
</I>&gt;&gt;&gt;<i> BindingFlags.Static | BindingFlags.NonPublic);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +			eventField.SetValue(null, null);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		[TearDown]
</I>&gt;&gt;&gt;<i> +		public void TearDown() {
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		protected Type ContractExceptionType { get; private set; }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Property changes on:
</I>&gt;&gt;&gt;<i> Test/System.Diagnostics.Contracts/Helpers/TestContractBase.cs
</I>&gt;&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;&gt;<i>    + native
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractAssertTest.cs
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ContractAssertTest.cs	(revision
</I>0)
&gt;&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ContractAssertTest.cs	(revision
</I>0)
&gt;&gt;&gt;<i> @@ -0,0 +1,175 @@
</I>&gt;&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +using System;
</I>&gt;&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics;
</I>&gt;&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;&gt;<i> +	public class ContractAssertTest : TestContractBase {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Ensures that Assert(true) allows execution to continue.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestAssertTrue ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			Contract.Assert (true);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Assert(false) will cause an assert to be triggered
</I>with
&gt;&gt;&gt;<i> the correct message.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test]
</I>&gt;&gt;&gt;<i> +		public void TestAssertNoEventHandler ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestAssertNoEventHandler() exception not thrown
</I>#1&quot;);
&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (NotImplementedException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestAssertNoEventHandler() wrong exception type #1&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Assert (false, &quot;Message&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestAssertNoEventHandler() exception not thrown
</I>#2&quot;);
&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (NotImplementedException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestAssertNoEventHandler() wrong exception type #2&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Assert(true) will not call the ContractFailed event
</I>&gt;&gt;&gt;<i> handler.
</I>&gt;&gt;&gt;<i> +		/// Contract.Assert(false) will call the ContractFailed event
</I>&gt;&gt;&gt;<i> handler.
</I>&gt;&gt;&gt;<i> +		/// Because nothing is done in the event handler, an assert should
</I>&gt;&gt;&gt;<i> be triggered.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test]
</I>&gt;&gt;&gt;<i> +		public void TestAssertEventHandlerNoAction ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			bool visitedEventHandler = false;
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				visitedEventHandler = true;
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Contract.Assert (true);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (visitedEventHandler,
</I>&gt;&gt;&gt;<i> &quot;TestAssertEventHandlerNoAction() handler visited&quot;);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;&gt;<i> +				Assert.Fail (&quot;TestAssertEventHandlerNoAction() exception not
</I>&gt;&gt;&gt;<i> thrown&quot;);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (NotImplementedException), ex,
</I>&gt;&gt;&gt;<i> &quot;TestAssertEventHandlerNoAction() wrong exception type&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (visitedEventHandler,
</I>&gt;&gt;&gt;<i> &quot;TestAssertEventHandlerNoAction() handler not visited&quot;);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Event handler calls SetHandled(), so no assert should be
</I>&gt;&gt;&gt;<i> triggered.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestAssertEventHandlerSetHandled ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Contract.Assert (false);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Event handler calls SetUnwind(), so exception of type
</I>&gt;&gt;&gt;<i> ContractException should be thrown.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestAssertEventHandlerSetUnwind ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				e.SetUnwind ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (base.ContractExceptionType, ex,
</I>&gt;&gt;&gt;<i> &quot;TestAssertEventHandlerSetUnwind() wrong exception type&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.IsNull (ex.InnerException,
</I>&gt;&gt;&gt;<i> &quot;TestAssertEventHandlerSetUnwind() inner exception not null&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Event handler calls SetHandled() and SetUnwind(), so exception
</I>&gt;&gt;&gt;<i> of type ContractException should be thrown,
</I>&gt;&gt;&gt;<i> +		/// as SetUnwind overrides SetHandled.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestAssertEventHandlerSetUnwindHandled ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;&gt;<i> +				e.SetUnwind ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (base.ContractExceptionType, ex,
</I>&gt;&gt;&gt;<i> &quot;TestAssertEventHandlerSetUnwindHandled() wrong exception type&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.IsNull (ex.InnerException,
</I>&gt;&gt;&gt;<i> &quot;TestAssertEventHandlerSetUnwindHandled() inner exception not null&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Event handler throws exception.
</I>&gt;&gt;&gt;<i> +		/// ContractException is thrown by Contract.Assert(), with
</I>&gt;&gt;&gt;<i> InnerException set to the thrown exception.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestAssertEventHandlerThrows ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				throw new ArgumentNullException ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			try {
</I>&gt;&gt;&gt;<i> +				Contract.Assert (false);
</I>&gt;&gt;&gt;<i> +			} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (base.ContractExceptionType, ex,
</I>&gt;&gt;&gt;<i> &quot;TestAssertEventHandlerSetUnwindHandled() wrong exception type&quot;);
</I>&gt;&gt;&gt;<i> +				Assert.IsInstanceOfType (typeof (ArgumentNullException),
</I>&gt;&gt;&gt;<i> ex.InnerException, &quot;TestAssertEventHandlerSetUnwindHandled() wrong
</I>inner
&gt;&gt;&gt;<i> exception type&quot;);
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Multiple event handlers are registered. Check that both are
</I>&gt;&gt;&gt;<i> called, and that the SetHandled()
</I>&gt;&gt;&gt;<i> +		/// call in one of them is handled correctly.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestAssertMultipleHandlers ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			bool visited1 = false, visited2 = false;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited1 = true;
</I>&gt;&gt;&gt;<i> +				Assert.IsFalse (e.Handled, &quot;TestAssertMultipleHandlers() Handled
</I>&gt;&gt;&gt;<i> incorrect #1&quot;);
</I>&gt;&gt;&gt;<i> +				e.SetHandled ();
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				visited2 = true;
</I>&gt;&gt;&gt;<i> +				Assert.IsTrue (e.Handled, &quot;TestAssertMultipleHandlers() Handled
</I>&gt;&gt;&gt;<i> incorrect #2&quot;);
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Contract.Assert (false);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (visited1, &quot;TestAssertMultipleHandlers() visited1
</I>&gt;&gt;&gt;<i> incorrect&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsTrue (visited2, &quot;TestAssertMultipleHandlers() visited2
</I>&gt;&gt;&gt;<i> incorrect&quot;);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Property changes on:
</I>&gt;&gt;&gt;<i> Test/System.Diagnostics.Contracts/ContractAssertTest.cs
</I>&gt;&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;&gt;<i>    + native
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> ---
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> +++
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> @@ -0,0 +1,76 @@
</I>&gt;&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +using System;
</I>&gt;&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;&gt;<i> +	public class ContractMarkerMethodsTest : TestContractBase {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.EndContractBlock() has no effects.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestEndContractBlock ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			Contract.EndContractBlock ();
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.OldValue() has no effect, and always returns the
</I>&gt;&gt;&gt;<i> default value for the type.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestOldValue ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			int i = Contract.OldValue&lt;int&gt; (8);
</I>&gt;&gt;&gt;<i> +			object o = Contract.OldValue&lt;object&gt; (new object ());
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Assert.AreEqual (0, i, &quot;TestOldValue() int value wrong&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsNull (o, &quot;TestOldValue() object value wrong&quot;);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Result() has no effect, and always returns the default
</I>&gt;&gt;&gt;<i> value for the type.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestResult ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			int i = Contract.Result&lt;int&gt; ();
</I>&gt;&gt;&gt;<i> +			object o = Contract.Result&lt;object&gt; ();
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Assert.AreEqual (0, i, &quot;TestResult() int value wrong&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsNull (o, &quot;TestResult() object value wrong&quot;);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.ValueAtReturn() has no effect, and always returns the
</I>&gt;&gt;&gt;<i> default value for the type.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test, RunAgainstReference]
</I>&gt;&gt;&gt;<i> +		public void TestValueAtReturn ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			int iOut, i;
</I>&gt;&gt;&gt;<i> +			object oOut, o;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			i = Contract.ValueAtReturn (out iOut);
</I>&gt;&gt;&gt;<i> +			o = Contract.ValueAtReturn (out oOut);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Assert.AreEqual (0, i, &quot;TestValueAtReturn() int return value
</I>&gt;&gt;&gt;<i> wrong&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsNull (o, &quot;TestValueAtReturn() object return value
</I>wrong&quot;);
&gt;&gt;&gt;<i> +			Assert.AreEqual (0, iOut, &quot;TestValueAtReturn() int out value
</I>&gt;&gt;&gt;<i> wrong&quot;);
</I>&gt;&gt;&gt;<i> +			Assert.IsNull (oOut, &quot;TestValueAtReturn() object out value
</I>wrong&quot;);
&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Property changes on:
</I>&gt;&gt;&gt;<i> Test/System.Diagnostics.Contracts/ContractMarkerMethodsTest.cs
</I>&gt;&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;&gt;<i>    + native
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Index: Test/System.Diagnostics.Contracts/ChangeLog
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> --- Test/System.Diagnostics.Contracts/ChangeLog	(revision 0)
</I>&gt;&gt;&gt;<i> +++ Test/System.Diagnostics.Contracts/ChangeLog	(revision 0)
</I>&gt;&gt;&gt;<i> @@ -0,0 +1,4 @@
</I>&gt;&gt;&gt;<i> +2010-06-23  Chris Bacon &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">chrisbacon76 at gmail.com</A>&gt;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	* Added all files
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Property changes on: Test/System.Diagnostics.Contracts/ChangeLog
</I>&gt;&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;&gt;<i>    + native
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Index:
</I>Test/System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs
&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> ---
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> +++
</I>&gt;&gt;&gt;<i>
</I>Test/System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs	(revision
&gt;&gt;&gt;<i> 0)
</I>&gt;&gt;&gt;<i> @@ -0,0 +1,121 @@
</I>&gt;&gt;&gt;<i> +#if NET_4_0
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#define CONTRACTS_FULL
</I>&gt;&gt;&gt;<i> +#define DEBUG
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +using System;
</I>&gt;&gt;&gt;<i> +using System.Collections.Generic;
</I>&gt;&gt;&gt;<i> +using System.Linq;
</I>&gt;&gt;&gt;<i> +using System.Text;
</I>&gt;&gt;&gt;<i> +using NUnit.Framework;
</I>&gt;&gt;&gt;<i> +using System.Diagnostics.Contracts;
</I>&gt;&gt;&gt;<i> +using MonoTests.System.Diagnostics.Contracts.Helpers;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +namespace MonoTests.System.Diagnostics.Contracts {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	[TestFixture]
</I>&gt;&gt;&gt;<i> +	public class ContractMustUseRewriterTest : TestContractBase {
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		private void CheckMustUseRewriter (string expectedMsg, params
</I>&gt;&gt;&gt;<i> Action[] fnTests)
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			foreach (var fnTest in fnTests) {
</I>&gt;&gt;&gt;<i> +				try {
</I>&gt;&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;&gt;<i> +					Assert.Fail (&quot;CheckMustUseRewriter() exception not thrown&quot;);
</I>&gt;&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +					Assert.IsInstanceOfType (typeof (NotImplementedException), ex,
</I>&gt;&gt;&gt;<i> &quot;CheckMustUseRewriter() wrong exception thrown&quot;);
</I>&gt;&gt;&gt;<i> +				}
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			bool handlerVisited = false;
</I>&gt;&gt;&gt;<i> +			Contract.ContractFailed += (sender, e) =&gt; {
</I>&gt;&gt;&gt;<i> +				handlerVisited = true;
</I>&gt;&gt;&gt;<i> +			};
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			foreach (var fnTest in fnTests) {
</I>&gt;&gt;&gt;<i> +				try {
</I>&gt;&gt;&gt;<i> +					fnTest ();
</I>&gt;&gt;&gt;<i> +					Assert.Fail (&quot;CheckMustUseRewriter() exception not thrown&quot;);
</I>&gt;&gt;&gt;<i> +				} catch (Exception ex) {
</I>&gt;&gt;&gt;<i> +					Assert.IsInstanceOfType (typeof (NotImplementedException), ex,
</I>&gt;&gt;&gt;<i> &quot;CheckMustUseRewriter() wrong exception thrown&quot;);
</I>&gt;&gt;&gt;<i> +				}
</I>&gt;&gt;&gt;<i> +			}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +			Assert.IsFalse (handlerVisited, &quot;CheckMustUseRewriter() handled
</I>&gt;&gt;&gt;<i> visited&quot;);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Requires() ALWAYS triggers an assert, regardless of
</I>any
&gt;&gt;&gt;<i> other factors.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test]
</I>&gt;&gt;&gt;<i> +		public void TestRequires ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when
</I>&gt;&gt;&gt;<i> using Contract.Requires&quot;,
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Requires (true),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Requires (false),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Requires (true, &quot;Message&quot;),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Requires (false, &quot;Message&quot;)
</I>&gt;&gt;&gt;<i> +			);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Requires() ALWAYS triggers an assert, regardless of
</I>any
&gt;&gt;&gt;<i> other factors.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test]
</I>&gt;&gt;&gt;<i> +		public void TestRequiresTException ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when
</I>&gt;&gt;&gt;<i> using Contract.Requires&lt;TException&gt;&quot;,
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Requires&lt;Exception&gt; (true),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Requires&lt;Exception&gt; (false),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Requires&lt;Exception&gt; (true, &quot;Message&quot;),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Requires&lt;Exception&gt; (false, &quot;Message&quot;)
</I>&gt;&gt;&gt;<i> +			);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Ensures() ALWAYS triggers an assert, regardless of any
</I>&gt;&gt;&gt;<i> other factors.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test]
</I>&gt;&gt;&gt;<i> +		public void TestEnsures ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when
</I>&gt;&gt;&gt;<i> using Contract.Ensures&quot;,
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Ensures (true),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Ensures (false),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Ensures (true, &quot;Message&quot;),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Ensures (false, &quot;Message&quot;)
</I>&gt;&gt;&gt;<i> +			);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Ensures() ALWAYS triggers an assert, regardless of any
</I>&gt;&gt;&gt;<i> other factors.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test]
</I>&gt;&gt;&gt;<i> +		public void TestEnsuresOnThrow ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when
</I>&gt;&gt;&gt;<i> using Contract.EnsuresOnThrow&quot;,
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.EnsuresOnThrow&lt;Exception&gt; (true),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.EnsuresOnThrow&lt;Exception&gt; (false),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.EnsuresOnThrow&lt;Exception&gt; (true, &quot;Message&quot;),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.EnsuresOnThrow&lt;Exception&gt; (false, &quot;Message&quot;)
</I>&gt;&gt;&gt;<i> +			);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +		/// &lt;summary&gt;
</I>&gt;&gt;&gt;<i> +		/// Contract.Ensures() ALWAYS triggers an assert, regardless of any
</I>&gt;&gt;&gt;<i> other factors.
</I>&gt;&gt;&gt;<i> +		/// &lt;/summary&gt;
</I>&gt;&gt;&gt;<i> +		[Test]
</I>&gt;&gt;&gt;<i> +		public void TestInvariant ()
</I>&gt;&gt;&gt;<i> +		{
</I>&gt;&gt;&gt;<i> +			CheckMustUseRewriter (&quot;Description: Must use the rewriter when
</I>&gt;&gt;&gt;<i> using Contract.Invariant&quot;,
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Invariant (true),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Invariant (false),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Invariant (true, &quot;Message&quot;),
</I>&gt;&gt;&gt;<i> +				() =&gt; Contract.Invariant (false, &quot;Message&quot;)
</I>&gt;&gt;&gt;<i> +			);
</I>&gt;&gt;&gt;<i> +		}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +	}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +}
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Property changes on:
</I>&gt;&gt;&gt;<i> Test/System.Diagnostics.Contracts/ContractMustUseRewriterTest.cs
</I>&gt;&gt;&gt;<i> ___________________________________________________________________
</I>&gt;&gt;&gt;<i> Added: svn:eol-style
</I>&gt;&gt;&gt;<i>    + native
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;&gt;<i>     
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>   
</I>&gt;<i> -------------- next part --------------
</I>&gt;<i> An HTML attachment was scrubbed...
</I>&gt;<i> URL:
</I>&gt;<i>
</I><A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20100627/1ef5e801/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20100627/1ef5e801/attachment.html</A>
&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> End of Mono-devel-list Digest, Vol 62, Issue 35
</I>&gt;<i> ***********************************************
</I>
-- 
GUY SHERMAN
web: www.guysherman.com
phone: +64 21 355 190
email <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">guy at guysherman.com</A>
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="035357.html">[Mono-dev] Standard name for mcs
</A></li>
	<LI>Next message: <A HREF="035333.html">[Mono-dev] Compiling Mono Runtime in VS2010
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35325">[ date ]</a>
              <a href="thread.html#35325">[ thread ]</a>
              <a href="subject.html#35325">[ subject ]</a>
              <a href="author.html#35325">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
