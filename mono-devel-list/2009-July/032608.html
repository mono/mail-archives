<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Memory usage on Mono remoting
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Memory%20usage%20on%20Mono%20remoting&In-Reply-To=4A5DBD83.6040508%40terra.es">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="032607.html">
   <LINK REL="Next"  HREF="032609.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Memory usage on Mono remoting</H1>
    <B>Gonzalo Paniagua Javier</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Memory%20usage%20on%20Mono%20remoting&In-Reply-To=4A5DBD83.6040508%40terra.es"
       TITLE="[Mono-dev] Memory usage on Mono remoting">gonzalo.mono at gmail.com
       </A><BR>
    <I>Wed Jul 15 12:00:23 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="032607.html">[Mono-dev] Memory usage on Mono remoting
</A></li>
        <LI>Next message: <A HREF="032609.html">[Mono-dev] Memory usage on Mono remoting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32608">[ date ]</a>
              <a href="thread.html#32608">[ thread ]</a>
              <a href="subject.html#32608">[ subject ]</a>
              <a href="author.html#32608">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, 2009-07-15 at 13:29 +0200, <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">pablosantosluac at terra.es</A> wrote:
[...]
&gt;<i> &gt; Your guess is wrong. Those asynchronous calls from Socket are treated as
</I>&gt;<i> &gt; if they were a WorkItem for a ThreadPool, only that when they are made,
</I>&gt;<i> &gt; the socket is added to an epoll fd (if you're on linux with support for
</I>&gt;<i> &gt; epoll). And when there's an event in the socket, there's a dedicated IO
</I>&gt;<i> &gt; threadpool to take care of reading/writing data and invoking the
</I>&gt;<i> &gt; callbacks. The advantages: if you have 10k connections, you don't need
</I>&gt;<i> &gt; 10k threads, threads are reused (no creation overhead), ...
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;   
</I>&gt;<i> Ok, of course. Well, when I said &quot;launching a thread&quot; I really meant
</I>&gt;<i> &quot;launching a thread on a thread pool&quot;.
</I>&gt;<i> 
</I>&gt;<i> Well, I'll try to use the ansync sockets then, but I guess to get the
</I>&gt;<i> best out of them I'll need not only to use them during accept, but also
</I>&gt;<i> read data asynchronously, right?
</I>
Correct. If possible, Write should also be asynchronous, but as long as
the OS buffers everything, there should be no problem.
[...]
&gt;<i> &gt; Coupled with asynchronous I/O, it will make better use of the resources
</I>&gt;<i> &gt; available. There's no need to create 100 threads for 100 client or
</I>&gt;<i> &gt; having 1 threadpool thread blocking on a socket asynchronous
</I>&gt;<i> &gt; operation,... Also, if you're thinking of reusing buffers, this helps
</I>&gt;<i> &gt; too, as the number of buffers will be bound to the maximum number of
</I>&gt;<i> &gt; threads in the threadpool, ...
</I>&gt;<i> &gt;   
</I>&gt;<i> Good, so, whenever I wait for a read or a write using async, the thread
</I>&gt;<i> should be able to work on another request?
</I>
Correct. In fact, you don't 'wait' for an asynchronous read or write.
For instance, when you call BeginRead, the socket is added to an epoll
fd and you BeginRead call returns immediately. The callback you
provided, if any, will be called from a different thread as soon as new
data is available. Just don't spoil it by doing something like
socket.EndRead (socket.BeginRead (...)))   ;-)

&gt;<i> I think this is the way it's implemented on Windows, but I can tell you
</I>&gt;<i> it is still created a huge number of threads, almost 1-1 with clients
</I>&gt;<i> under the most overloaded scenarios.
</I>
The number of threads in the current threadpool can be configured using
MONO_THREADS_PER_CPU (see mono(1)) and SetMaxThreads. I don't remember
the numbers, but if you have a dual-quad core, it means ~140 threads. I
would adjust the maximum number of threads until the performance is more
or less the same than if you add a few more threads, but this may vary
depending on what the threads are doing...

-Gonzalo





</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="032607.html">[Mono-dev] Memory usage on Mono remoting
</A></li>
	<LI>Next message: <A HREF="032609.html">[Mono-dev] Memory usage on Mono remoting
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32608">[ date ]</a>
              <a href="thread.html#32608">[ thread ]</a>
              <a href="subject.html#32608">[ subject ]</a>
              <a href="author.html#32608">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
