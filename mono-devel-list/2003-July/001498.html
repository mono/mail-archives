<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] String constants and localization
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20String%20constants%20and%20localization&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001497.html">
   <LINK REL="Next"  HREF="001531.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] String constants and localization</H1>
    <B>Piers Haken</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20String%20constants%20and%20localization&In-Reply-To="
       TITLE="[Mono-devel-list] String constants and localization">piersh at friskit.com
       </A><BR>
    <I>Mon Jul 14 10:39:37 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="001497.html">[Mono-devel-list] String constants and localization
</A></li>
        <LI>Next message: <A HREF="001531.html">[Mono-devel-list] String constants and localization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1498">[ date ]</a>
              <a href="thread.html#1498">[ thread ]</a>
              <a href="subject.html#1498">[ subject ]</a>
              <a href="author.html#1498">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I guess this implies a potential compiler optimization: if an enum (or
indeed any struct with only const members) is internal to an assembly
and no method calls are made on it, references to its fields can be
inlined and its type definition omitted.

Piers.

&gt;<i> -----Original Message-----
</I>&gt;<i> From: Piers Haken 
</I>&gt;<i> Sent: Monday, July 14, 2003 7:34 AM
</I>&gt;<i> To: A - Soft Technologies; Miguel de Icaza
</I>&gt;<i> Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> Subject: RE: [Mono-devel-list] String constants and localization
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Yes, but using an enum doesn't save you any space in the 
</I>&gt;<i> assembly because its definition must include the names of its members.
</I>&gt;<i> 
</I>&gt;<i> Piers.
</I>&gt;<i> 
</I>&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: A - Soft Technologies [mailto:<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">A-Soft at A-SoftTech.com</A>]
</I>&gt;<i> &gt; Sent: Monday, July 14, 2003 6:43 AM
</I>&gt;<i> &gt; To: Piers Haken; Miguel de Icaza
</I>&gt;<i> &gt; Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt; Subject: Re: [Mono-devel-list] String constants and localization
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Hi,
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I'm not sure what you are meaning with this. But if you mean
</I>&gt;<i> &gt; that you cannot remove the enumeration after compiling 
</I>&gt;<i> &gt; because somebody might use
</I>&gt;<i> &gt; enum.ToString() then you are right.
</I>&gt;<i> &gt; However there is no case in which anybody should use ToString 
</I>&gt;<i> &gt; on that enum anywhere. The enum in this case basically serves 
</I>&gt;<i> &gt; as an auto-(re)indexing int field
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Andreas
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ----- Original Message -----
</I>&gt;<i> &gt; From: &quot;Piers Haken&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">piersh at friskit.com</A>&gt;
</I>&gt;<i> &gt; To: &quot;Andreas Nahr&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ClassDevelopment at A-SoftTech.com</A>&gt;; &quot;Miguel 
</I>&gt;<i> &gt; de Icaza&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">miguel at ximian.com</A>&gt;
</I>&gt;<i> &gt; Cc: &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>&gt;
</I>&gt;<i> &gt; Sent: Monday, July 14, 2003 3:37 PM
</I>&gt;<i> &gt; Subject: RE: [Mono-devel-list] String constants and localization
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; You're forgetting enum.ToString().
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Piers.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; -----Original Message-----
</I>&gt;<i> &gt; &gt; From: Andreas Nahr [mailto:<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ClassDevelopment at A-SoftTech.com</A>]
</I>&gt;<i> &gt; &gt; Sent: Monday, July 14, 2003 1:39 AM
</I>&gt;<i> &gt; &gt; To: Miguel de Icaza
</I>&gt;<i> &gt; &gt; Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt; &gt; Subject: Re: [Mono-devel-list] String constants and localization
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Hi,
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I've read your answer, but it seems that at quite some points you
</I>&gt;<i> &gt; &gt; overlooked advantages (maybe I'm also wrong with any of 
</I>&gt;<i> &gt; these, but I
</I>&gt;<i> &gt; &gt; don't think so). So I added some addidional comments to it
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &gt; right now there is nearly no localization support in the
</I>&gt;<i> &gt; &gt; Mono class
</I>&gt;<i> &gt; &gt; &gt; &gt; libraries and all strings (mainly for errors) are
</I>&gt;<i> &gt; &gt; hardcoded into the
</I>&gt;<i> &gt; &gt; &gt; &gt; source-files.
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; Thanks for this proposal, I have some comments in this
</I>&gt;<i> &gt; &gt; email about the
</I>&gt;<i> &gt; &gt; &gt; specifics of the proposal.
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; Initially, I wanted to use it, but it meant that we 
</I>&gt;<i> would have to:
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; * deviate from the standard practice (something I would not
</I>&gt;<i> &gt; &gt; &gt;   mind, if there were strong enough arguments for)
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; The basic arguments are:
</I>&gt;<i> &gt; &gt; * Much faster
</I>&gt;<i> &gt; &gt; * Much smaller Assembly size (see below)
</I>&gt;<i> &gt; &gt; * Much smaller RAM need
</I>&gt;<i> &gt; &gt; * More safe when programing because of compile errors for 
</I>&gt;<i> e.g. typos
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; * Create and maintain a new infrastructure for localization.
</I>&gt;<i> &gt; &gt; &gt;   Not bad per-se, but it would minimize the reuse of existing
</I>&gt;<i> &gt; &gt; &gt;   knowledge that people might acquire or obtain from the NET.
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; * Reimplement the chunks we already have for handling resources
</I>&gt;<i> &gt; &gt; &gt;   in corlib to cope with all the CultureInfo bits.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; This is not neccesarily true. The sample implementation I
</I>&gt;<i> &gt; did is using
</I>&gt;<i> &gt; &gt; System.Resources namespace to get it's localized data
</I>&gt;<i> &gt; internally. More
</I>&gt;<i> &gt; &gt; specifically it ALLOWS to use it if you want, but does not
</I>&gt;<i> &gt; force you
</I>&gt;<i> &gt; &gt; to if there is a better solution somebody wants to
</I>&gt;<i> &gt; implement. And you
</I>&gt;<i> &gt; &gt; can change this solution at any time without having to
</I>&gt;<i> &gt; change anything
</I>&gt;<i> &gt; &gt; in the sources. You could even use the now-used string tables and
</I>&gt;<i> &gt; &gt; still save a litte memory (see below: Strings as 16bit).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; I also want to avoid loading all the strings in memory, 
</I>&gt;<i> but it is
</I>&gt;<i> &gt; &gt; &gt; possible to do so:
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &gt; with a call like
</I>&gt;<i> &gt; &gt; &gt; &gt; Print (MS.GetString (MonoString.GenericENullNotAllowed));
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; We should use the Resource infrastructure in .NET here:
</I>&gt;<i> &gt; &gt; there are many
</I>&gt;<i> &gt; &gt; &gt; issues related to loading the proper assembly given the selected
</I>&gt;<i> &gt; &gt; &gt; CultureInfo, and the code is mostly implemented.
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; The file format for resources allows for this case: it is
</I>&gt;<i> &gt; &gt; possible to
</I>&gt;<i> &gt; &gt; &gt; fetch the information without having to load all the strings to
</I>&gt;<i> &gt; &gt; &gt; localize.
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; What we need to do is improve the implementation of
</I>&gt;<i> &gt; &gt; &gt; ResourceSet.GetObject.  Basically we should define an
</I>&gt;<i> &gt; &gt; internal method
</I>&gt;<i> &gt; &gt; &gt; in the ResourceReader that can do lookups based on
</I>&gt;<i> &gt; strings, without
</I>&gt;<i> &gt; &gt; &gt; having to use the resource enumerator.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; OK - but IMHO your solution just has two flaws:
</I>&gt;<i> &gt; &gt; * Reimplement the chunks we already have for handling resources
</I>&gt;<i> &gt; &gt;    in corlib to cope with all the CultureInfo bits (which
</I>&gt;<i> &gt; is exactly
</I>&gt;<i> &gt; &gt; what you wanted to avoid above)
</I>&gt;<i> &gt; &gt; * Sooner or later you will always come to the GetResourceStream
</I>&gt;<i> &gt; &gt; function, which actually provides a memory stream, which 
</I>&gt;<i> &gt; is: loading
</I>&gt;<i> &gt; &gt; all things into memory (and if you want to provide a
</I>&gt;<i> &gt; complete second
</I>&gt;<i> &gt; &gt; infrastructure for strings, then the work that has to be
</I>&gt;<i> &gt; done would be
</I>&gt;<i> &gt; &gt; IMHO FAR more work than anything you might have to do to implement
</I>&gt;<i> &gt; &gt; something like my suggested
</I>&gt;<i> &gt; &gt; solution)
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; We already have an API that can load a string from an
</I>&gt;<i> &gt; index, so the
</I>&gt;<i> &gt; &gt; &gt; only thing we have to do is perform a binary search on the
</I>&gt;<i> &gt; &gt; strings in
</I>&gt;<i> &gt; &gt; &gt; the file (like Monodoc does now for its help).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Sorry but IMHO this it total overkill. You want to 
</I>&gt;<i> perform a binary
</I>&gt;<i> &gt; &gt; search DIRECTLY on a file containing an estimated 200KB 
</I>&gt;<i> &gt; string values
</I>&gt;<i> &gt; &gt; EVERY time we do a string lookup. Are you sure this won't
</I>&gt;<i> &gt; totally fry
</I>&gt;<i> &gt; &gt; your HDD. And what about if the assembly we are accessing
</I>&gt;<i> &gt; is on e.g. a
</I>&gt;<i> &gt; &gt; network share that has slow access times? IMHO you will
</I>&gt;<i> &gt; need to load
</I>&gt;<i> &gt; &gt; string index that into memory in any case to perform a
</I>&gt;<i> &gt; binary search
</I>&gt;<i> &gt; &gt; (or probably ANY other search)
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; As I already said: Even with a binary search you will just
</I>&gt;<i> &gt; get search
</I>&gt;<i> &gt; &gt; speeds of O(ln n) while my solution would get O(1) and that
</I>&gt;<i> &gt; is without
</I>&gt;<i> &gt; &gt; taking into account that you have to do the binary search
</I>&gt;<i> &gt; on STRINGS,
</I>&gt;<i> &gt; &gt; not on int's
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &gt; The Advantages are:
</I>&gt;<i> &gt; &gt; &gt; &gt; * Smaller Assemblies (probably leads to faster runtime
</I>&gt;<i> &gt; &gt; performance
</I>&gt;<i> &gt; &gt; &gt; &gt; in Jit also because Jiting a constant int should be 
</I>&gt;<i> faster than
</I>&gt;<i> &gt; &gt; &gt; &gt; Jiting a constant string)
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; Well, the space that you save on strings, say the string:
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; &quot;Null not provided&quot;
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; Would be encoded into an enumeration:
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; Null_Not_Provided
</I>&gt;<i> &gt; &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; And that would end up in the metadata as well, so the
</I>&gt;<i> &gt; &gt; change in size
</I>&gt;<i> &gt; &gt; &gt; is only half the size (strings are stored in 16-bit ucs-2
</I>&gt;<i> &gt; encoding).
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I didn't even think about savings from not-having-to store
</I>&gt;<i> &gt; as unicode
</I>&gt;<i> &gt; &gt; ;) - that even adds to data savings :)
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; I think you are overlooking a LOT of things here:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; First example:
</I>&gt;<i> &gt; &gt; 1. Mono now: Key = &quot;Null not provided&quot;, Translation = &quot;Null not
</I>&gt;<i> &gt; &gt; provided&quot; 2. Suggestion: Key = Null_Not_Provided, 
</I>&gt;<i> &gt; Translation = &quot;Null
</I>&gt;<i> &gt; &gt; not provided&quot;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; In that case key equals about the size of Translation. As
</I>&gt;<i> &gt; you said we
</I>&gt;<i> &gt; &gt; only need half the size for the enum value. So we
</I>&gt;<i> &gt; &gt; need: 1. Memory: SuggestionKey * 2 * 2 (we also need it in
</I>&gt;<i> &gt; the lookup
</I>&gt;<i> &gt; &gt; table) + Translation 2. Memory: SuggestionKey * 1
</I>&gt;<i> &gt; &gt; + Translation SAVING is: SuggestionKey * 3 If you want to
</I>&gt;<i> &gt; &gt; store the string somewhere to not have to hardcode it into each
</I>&gt;<i> &gt; &gt; individual class to prevent e.g. spelling errors (seems to 
</I>&gt;<i> &gt; be what MS
</I>&gt;<i> &gt; &gt; does) this even grows to a saving of:
</I>&gt;<i> &gt; &gt; SuggestionKey * 4
</I>&gt;<i> &gt; &gt; with inlining? active at compiling to a saving of: 
</I>&gt;<i> SuggestionKey * 6
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Second example (IMHO somewhere about what it could be in
</I>&gt;<i> &gt; &gt; reality): 1. Mono now: Key = &quot;Null not provided because we
</I>&gt;<i> &gt; have never
</I>&gt;<i> &gt; &gt; provided null&quot;, Translation = &quot;Null not provided because we
</I>&gt;<i> &gt; have never
</I>&gt;<i> &gt; &gt; provided null&quot; 2. Suggestion: Key = Null_Never_Provided,
</I>&gt;<i> &gt; Translation =
</I>&gt;<i> &gt; &gt; &quot;Null not provided because we have never provided null&quot;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; This should show the savings at a SuggestionKeySize about
</I>&gt;<i> &gt; half of the
</I>&gt;<i> &gt; &gt; size of the string itself (I would estimate this to be a 
</I>&gt;<i> good total
</I>&gt;<i> &gt; &gt; average): 1. Memory: SuggestionKey * 2 * 2 (we also need 
</I>&gt;<i> it in the 
</I>&gt;<i> &gt; &gt; lookup table) * 2 (double the size) + Translation 2. Memory: 
</I>&gt;<i> &gt; &gt; SuggestionKey * 1 + Translation SAVING
</I>&gt;<i> &gt; &gt; is: SuggestionKey * 7 !!!!!! for the other options 
</I>&gt;<i> &gt; described above it
</I>&gt;<i> &gt; &gt; would even save: SuggestionKey * 8 or SuggestionKey * 12
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; A saving of SuggestionKey * 7 (with the settings of the second
</I>&gt;<i> &gt; &gt; example) would in reality mean a saving of about 70% TOTAL size 
</I>&gt;<i> &gt; &gt; (including the
</I>&gt;<i> &gt; &gt; translation)
</I>&gt;<i> &gt; &gt; In the first example we would save about 60% size
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Also for extremely memory limited devices you probably can
</I>&gt;<i> &gt; remove the
</I>&gt;<i> &gt; &gt; enumeration completely after compiling (all enum members
</I>&gt;<i> &gt; are compiled
</I>&gt;<i> &gt; &gt; into int's), which increases savings even more.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; All that I stated now are just savings in assembly size. 
</I>&gt;<i> At runtime
</I>&gt;<i> &gt; &gt; the savings are EVEN HIGHER! At runtime Mono should never need to 
</I>&gt;<i> &gt; &gt; access the enumeration keys (everything is int
</I>&gt;<i> &gt; &gt; now) so the need for RAM is probably about 80% LESS than 
</I>&gt;<i> &gt; the current
</I>&gt;<i> &gt; &gt; solution!!!! That all with more programing safety and much higher
</I>&gt;<i> &gt; &gt; access speeds at much lower CPU usage.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Andreas
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; _______________________________________________
</I>&gt;<i> &gt; &gt; Mono-devel-list mailing list <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt; &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-">http://lists.ximian.com/mailman/listinfo/mono-devel-</A>&gt; list
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-devel-list mailing list
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-">http://lists.ximian.com/mailman/listinfo/mono-devel-</A>&gt; list
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A> 
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-">http://lists.ximian.com/mailman/listinfo/mono-devel-</A>&gt; list
</I>&gt;<i> 
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001497.html">[Mono-devel-list] String constants and localization
</A></li>
	<LI>Next message: <A HREF="001531.html">[Mono-devel-list] String constants and localization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1498">[ date ]</a>
              <a href="thread.html#1498">[ thread ]</a>
              <a href="subject.html#1498">[ subject ]</a>
              <a href="author.html#1498">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
