<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] String constants and localization
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20String%20constants%20and%20localization&In-Reply-To=00e701c34a4f%24f3de2680%24047c06d5%40ansuria">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001508.html">
   <LINK REL="Next"  HREF="001516.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] String constants and localization</H1>
    <B>Miguel de Icaza</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20String%20constants%20and%20localization&In-Reply-To=00e701c34a4f%24f3de2680%24047c06d5%40ansuria"
       TITLE="[Mono-devel-list] String constants and localization">miguel at ximian.com
       </A><BR>
    <I>Mon Jul 14 18:40:21 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="001508.html">[Mono-devel-list] String constants and localization
</A></li>
        <LI>Next message: <A HREF="001516.html">[Mono-devel-list] String constants and localization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1512">[ date ]</a>
              <a href="thread.html#1512">[ thread ]</a>
              <a href="subject.html#1512">[ subject ]</a>
              <a href="author.html#1512">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

&gt;<i> By the time Mono class libraries are complete they will probably contain
</I>&gt;<i> about 1-2MB of hardcoded strings.
</I>&gt;<i> It is not possible to do ANY optimization or improvement on that other than
</I>&gt;<i> removing these.
</I>&gt;<i> For a normal PC 1-2MB is today negligible
</I>&gt;<i> For a memory limited device (e.g. a Palm or a PocketPC or a Cell-Phone) 1-2
</I>&gt;<i> MB permanently lost is HUGE (ok maybe not for a PocketPC ;)
</I>
Understood.  But given that our user population is mostly desktop and
server users, this is not really a problem.

For an embedded device, you will likely do other cuts:

	* Remove unrequired classes, in fact, tuning it to the
	  particular classes that you will use, removing everything
	  you wont use.

	* Remove chunks of the runtime that are not needed.

	* Modify the images to use utf-8 encoding.

	* If you are at a premium, you could even gzip chunks of the
	  image.

And if you go down that path, you might as well modify the compiler to
cope specially with any strings &quot;labeled&quot; for translation, for example:

	throw new Exception (Resource.GetText(&quot;Hello World&quot;));

The compiler could replace the above with:

	throw new Exception (Resource.GetTextFromID (765));

Or we could even add support to translate directly into a specific
language:

	mcs -adapt:myLocale.File.spanish sample.cs

which would do:

	throw new Exception (Resource.GetText (&quot;Hola Mundo&quot;));

&gt;<i> They are obviously having two different code bases.
</I>&gt;<i> .Net framework uses a short string identifier to identify strings (e.g.
</I>&gt;<i> GetString(&quot;Get_Error_NotValid&quot;))
</I>&gt;<i> .Net compact framework seems to use an Int value to identify strings (e.g.
</I>&gt;<i> GetString(45) )
</I>
Today Mono is used by the audience that uses the .NET Framework, and we
have not yet been approached by anyone doing a more compact framework,
but as I said, am willing to add specific changes to the compiler to
address these memory usage patterns.

&gt;<i> The absolute minimum size you can archive (removing all strings, assumed 1MB
</I>&gt;<i> strings without changing the code base):
</I>&gt;<i> Mono: 1000KB (cannot remove without removing every single string)
</I>&gt;<i> MS: estimated 250KB (assuming the identifier is average 1/4 of the string
</I>&gt;<i> itself)
</I>&gt;<i> MS Compact: about 40KB
</I>&gt;<i> Suggestion: about 40KB (assuming you remove the enumeration after compiling)
</I>
We can not remove the enumeration after compiling, as I said before, you
can always do:

	object a = MyEnum.Value;

And given the compiler structure, it is a lot easier to implement what I
described before than removing an enum after it has bene used.

This is a lot more hackish than my proposal above.

&gt;<i> The minimum size you can archive when using localization (one localized
</I>&gt;<i> resource set, assumed 1MB strings):
</I>&gt;<i> Mono: 3000KB
</I>&gt;<i> MS: estimated 1500KB (assuming the identifier is average 1/4 of the string
</I>&gt;<i> itself)
</I>&gt;<i> MS Compact: about 1040KB
</I>&gt;<i> Suggestion: about 1290KB (assuming the enumeration entry is average 1/4 of
</I>&gt;<i> the string itself) (assuming you remove the enumeration after compiling)
</I>&gt;<i> Suggestion: about 1040KB (assuming you remove the enumeration after
</I>&gt;<i> compiling)
</I>
Not quite correct.  Mono would include 1M of strings that are already in
one language (english or as I suggested previously, anyone of your
liking).

We are not likely going to be able to remove the enumeration entries. 

&gt;<i> RAM need at runtime when using localization for getting ONE/The first entry
</I>&gt;<i> (one localized resource set, full memory cache, assumed 1MB strings):
</I>&gt;<i> Mono: 2000KB (Hashtable implementation)
</I>
Wrong.

As I repeated a number of times: you do *not* need to use a Hashtable. 
In fact, Microsoft .NET does *not* use a Hashtable, they use an
&quot;internal&quot; method that maps strings to their index, using a binary
search.

Also, the strings do *not* have to be loaded, until they are requested
(and in fact, if they come from the file, they are mmapped, so the
kernel wont load the page, unless needed, and can always remove the page
from memory, as it has backing store associated with it.  So it is *not*
an issue.

&gt;<i> Mono would use the most memory of all implementations (For the compiled
</I>&gt;<i> assembly as well as RAM for execution)
</I>
It would use the most memory if you *insist* on the hashtable
implementation, as opposed to the binary-search implementation. 

If you do the *right* thing (as I pointed out before), the memory use is
minimal, and does not even show up.

&gt;<i> The memory need of the Mono implementation will never allow Mono to run on a
</I>&gt;<i> memory limited device. And there is NO way to do any optimization on the
</I>&gt;<i> assembly size.
</I>
Yes, there is, I listed various above.

Miguel

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001508.html">[Mono-devel-list] String constants and localization
</A></li>
	<LI>Next message: <A HREF="001516.html">[Mono-devel-list] String constants and localization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1512">[ date ]</a>
              <a href="thread.html#1512">[ thread ]</a>
              <a href="subject.html#1512">[ subject ]</a>
              <a href="author.html#1512">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
