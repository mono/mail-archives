<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] String constants and localization
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20String%20constants%20and%20localization&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001504.html">
   <LINK REL="Next"  HREF="001498.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] String constants and localization</H1>
    <B>Piers Haken</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20String%20constants%20and%20localization&In-Reply-To="
       TITLE="[Mono-devel-list] String constants and localization">piersh at friskit.com
       </A><BR>
    <I>Mon Jul 14 10:34:19 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="001504.html">[Mono-devel-list] how to help with mod_mono
</A></li>
        <LI>Next message: <A HREF="001498.html">[Mono-devel-list] String constants and localization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1497">[ date ]</a>
              <a href="thread.html#1497">[ thread ]</a>
              <a href="subject.html#1497">[ subject ]</a>
              <a href="author.html#1497">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Yes, but using an enum doesn't save you any space in the assembly
because its definition must include the names of its members.

Piers.

&gt;<i> -----Original Message-----
</I>&gt;<i> From: A - Soft Technologies [mailto:<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">A-Soft at A-SoftTech.com</A>] 
</I>&gt;<i> Sent: Monday, July 14, 2003 6:43 AM
</I>&gt;<i> To: Piers Haken; Miguel de Icaza
</I>&gt;<i> Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> Subject: Re: [Mono-devel-list] String constants and localization
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Hi,
</I>&gt;<i> 
</I>&gt;<i> I'm not sure what you are meaning with this. But if you mean 
</I>&gt;<i> that you cannot remove the enumeration after compiling 
</I>&gt;<i> because somebody might use
</I>&gt;<i> enum.ToString() then you are right.
</I>&gt;<i> However there is no case in which anybody should use ToString 
</I>&gt;<i> on that enum anywhere. The enum in this case basically serves 
</I>&gt;<i> as an auto-(re)indexing int field
</I>&gt;<i> 
</I>&gt;<i> Andreas
</I>&gt;<i> 
</I>&gt;<i> ----- Original Message ----- 
</I>&gt;<i> From: &quot;Piers Haken&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">piersh at friskit.com</A>&gt;
</I>&gt;<i> To: &quot;Andreas Nahr&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ClassDevelopment at A-SoftTech.com</A>&gt;; &quot;Miguel 
</I>&gt;<i> de Icaza&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">miguel at ximian.com</A>&gt;
</I>&gt;<i> Cc: &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>&gt;
</I>&gt;<i> Sent: Monday, July 14, 2003 3:37 PM
</I>&gt;<i> Subject: RE: [Mono-devel-list] String constants and localization
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> You're forgetting enum.ToString().
</I>&gt;<i> 
</I>&gt;<i> Piers.
</I>&gt;<i> 
</I>&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: Andreas Nahr [mailto:<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ClassDevelopment at A-SoftTech.com</A>]
</I>&gt;<i> &gt; Sent: Monday, July 14, 2003 1:39 AM
</I>&gt;<i> &gt; To: Miguel de Icaza
</I>&gt;<i> &gt; Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> &gt; Subject: Re: [Mono-devel-list] String constants and localization
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Hi,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I've read your answer, but it seems that at quite some points you 
</I>&gt;<i> &gt; overlooked advantages (maybe I'm also wrong with any of 
</I>&gt;<i> these, but I 
</I>&gt;<i> &gt; don't think so). So I added some addidional comments to it
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; &gt; right now there is nearly no localization support in the
</I>&gt;<i> &gt; Mono class
</I>&gt;<i> &gt; &gt; &gt; libraries and all strings (mainly for errors) are
</I>&gt;<i> &gt; hardcoded into the
</I>&gt;<i> &gt; &gt; &gt; source-files.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Thanks for this proposal, I have some comments in this
</I>&gt;<i> &gt; email about the
</I>&gt;<i> &gt; &gt; specifics of the proposal.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Initially, I wanted to use it, but it meant that we would have to:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; * deviate from the standard practice (something I would not
</I>&gt;<i> &gt; &gt;   mind, if there were strong enough arguments for)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The basic arguments are:
</I>&gt;<i> &gt; * Much faster
</I>&gt;<i> &gt; * Much smaller Assembly size (see below)
</I>&gt;<i> &gt; * Much smaller RAM need
</I>&gt;<i> &gt; * More safe when programing because of compile errors for e.g. typos
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; * Create and maintain a new infrastructure for localization.
</I>&gt;<i> &gt; &gt;   Not bad per-se, but it would minimize the reuse of existing
</I>&gt;<i> &gt; &gt;   knowledge that people might acquire or obtain from the NET.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; * Reimplement the chunks we already have for handling resources
</I>&gt;<i> &gt; &gt;   in corlib to cope with all the CultureInfo bits.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This is not neccesarily true. The sample implementation I 
</I>&gt;<i> did is using 
</I>&gt;<i> &gt; System.Resources namespace to get it's localized data 
</I>&gt;<i> internally. More 
</I>&gt;<i> &gt; specifically it ALLOWS to use it if you want, but does not 
</I>&gt;<i> force you 
</I>&gt;<i> &gt; to if there is a better solution somebody wants to 
</I>&gt;<i> implement. And you 
</I>&gt;<i> &gt; can change this solution at any time without having to 
</I>&gt;<i> change anything 
</I>&gt;<i> &gt; in the sources. You could even use the now-used string tables and 
</I>&gt;<i> &gt; still save a litte memory (see below: Strings as 16bit).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; I also want to avoid loading all the strings in memory, but it is 
</I>&gt;<i> &gt; &gt; possible to do so:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; &gt; with a call like
</I>&gt;<i> &gt; &gt; &gt; Print (MS.GetString (MonoString.GenericENullNotAllowed));
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; We should use the Resource infrastructure in .NET here:
</I>&gt;<i> &gt; there are many
</I>&gt;<i> &gt; &gt; issues related to loading the proper assembly given the selected 
</I>&gt;<i> &gt; &gt; CultureInfo, and the code is mostly implemented.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; The file format for resources allows for this case: it is
</I>&gt;<i> &gt; possible to
</I>&gt;<i> &gt; &gt; fetch the information without having to load all the strings to 
</I>&gt;<i> &gt; &gt; localize.
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; What we need to do is improve the implementation of 
</I>&gt;<i> &gt; &gt; ResourceSet.GetObject.  Basically we should define an
</I>&gt;<i> &gt; internal method
</I>&gt;<i> &gt; &gt; in the ResourceReader that can do lookups based on 
</I>&gt;<i> strings, without 
</I>&gt;<i> &gt; &gt; having to use the resource enumerator.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; OK - but IMHO your solution just has two flaws:
</I>&gt;<i> &gt; * Reimplement the chunks we already have for handling resources
</I>&gt;<i> &gt;    in corlib to cope with all the CultureInfo bits (which 
</I>&gt;<i> is exactly 
</I>&gt;<i> &gt; what you wanted to avoid above)
</I>&gt;<i> &gt; * Sooner or later you will always come to the GetResourceStream 
</I>&gt;<i> &gt; function, which actually provides a memory stream, which 
</I>&gt;<i> is: loading 
</I>&gt;<i> &gt; all things into memory (and if you want to provide a 
</I>&gt;<i> complete second 
</I>&gt;<i> &gt; infrastructure for strings, then the work that has to be 
</I>&gt;<i> done would be 
</I>&gt;<i> &gt; IMHO FAR more work than anything you might have to do to implement 
</I>&gt;<i> &gt; something like my suggested
</I>&gt;<i> &gt; solution)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; We already have an API that can load a string from an 
</I>&gt;<i> index, so the 
</I>&gt;<i> &gt; &gt; only thing we have to do is perform a binary search on the
</I>&gt;<i> &gt; strings in
</I>&gt;<i> &gt; &gt; the file (like Monodoc does now for its help).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Sorry but IMHO this it total overkill. You want to perform a binary 
</I>&gt;<i> &gt; search DIRECTLY on a file containing an estimated 200KB 
</I>&gt;<i> string values 
</I>&gt;<i> &gt; EVERY time we do a string lookup. Are you sure this won't 
</I>&gt;<i> totally fry 
</I>&gt;<i> &gt; your HDD. And what about if the assembly we are accessing 
</I>&gt;<i> is on e.g. a 
</I>&gt;<i> &gt; network share that has slow access times? IMHO you will 
</I>&gt;<i> need to load 
</I>&gt;<i> &gt; string index that into memory in any case to perform a 
</I>&gt;<i> binary search 
</I>&gt;<i> &gt; (or probably ANY other search)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; As I already said: Even with a binary search you will just 
</I>&gt;<i> get search 
</I>&gt;<i> &gt; speeds of O(ln n) while my solution would get O(1) and that 
</I>&gt;<i> is without 
</I>&gt;<i> &gt; taking into account that you have to do the binary search 
</I>&gt;<i> on STRINGS, 
</I>&gt;<i> &gt; not on int's
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; &gt; The Advantages are:
</I>&gt;<i> &gt; &gt; &gt; * Smaller Assemblies (probably leads to faster runtime
</I>&gt;<i> &gt; performance
</I>&gt;<i> &gt; &gt; &gt; in Jit also because Jiting a constant int should be faster than 
</I>&gt;<i> &gt; &gt; &gt; Jiting a constant string)
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Well, the space that you save on strings, say the string:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; &quot;Null not provided&quot;
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Would be encoded into an enumeration:
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; Null_Not_Provided
</I>&gt;<i> &gt; &gt;
</I>&gt;<i> &gt; &gt; And that would end up in the metadata as well, so the
</I>&gt;<i> &gt; change in size
</I>&gt;<i> &gt; &gt; is only half the size (strings are stored in 16-bit ucs-2 
</I>&gt;<i> encoding).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I didn't even think about savings from not-having-to store 
</I>&gt;<i> as unicode 
</I>&gt;<i> &gt; ;) - that even adds to data savings :)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I think you are overlooking a LOT of things here:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; First example:
</I>&gt;<i> &gt; 1. Mono now: Key = &quot;Null not provided&quot;, Translation = &quot;Null not 
</I>&gt;<i> &gt; provided&quot; 2. Suggestion: Key = Null_Not_Provided, 
</I>&gt;<i> Translation = &quot;Null 
</I>&gt;<i> &gt; not provided&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; In that case key equals about the size of Translation. As 
</I>&gt;<i> you said we 
</I>&gt;<i> &gt; only need half the size for the enum value. So we
</I>&gt;<i> &gt; need: 1. Memory: SuggestionKey * 2 * 2 (we also need it in 
</I>&gt;<i> the lookup 
</I>&gt;<i> &gt; table) + Translation 2. Memory: SuggestionKey * 1
</I>&gt;<i> &gt; + Translation SAVING is: SuggestionKey * 3 If you want to
</I>&gt;<i> &gt; store the string somewhere to not have to hardcode it into each 
</I>&gt;<i> &gt; individual class to prevent e.g. spelling errors (seems to 
</I>&gt;<i> be what MS
</I>&gt;<i> &gt; does) this even grows to a saving of:
</I>&gt;<i> &gt; SuggestionKey * 4
</I>&gt;<i> &gt; with inlining? active at compiling to a saving of: SuggestionKey * 6
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Second example (IMHO somewhere about what it could be in
</I>&gt;<i> &gt; reality): 1. Mono now: Key = &quot;Null not provided because we 
</I>&gt;<i> have never 
</I>&gt;<i> &gt; provided null&quot;, Translation = &quot;Null not provided because we 
</I>&gt;<i> have never 
</I>&gt;<i> &gt; provided null&quot; 2. Suggestion: Key = Null_Never_Provided, 
</I>&gt;<i> Translation = 
</I>&gt;<i> &gt; &quot;Null not provided because we have never provided null&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; This should show the savings at a SuggestionKeySize about 
</I>&gt;<i> half of the 
</I>&gt;<i> &gt; size of the string itself (I would estimate this to be a good total 
</I>&gt;<i> &gt; average): 1. Memory: SuggestionKey * 2 * 2 (we also need it in the 
</I>&gt;<i> &gt; lookup table) * 2 (double the size) + Translation 2. Memory: 
</I>&gt;<i> &gt; SuggestionKey * 1 + Translation SAVING
</I>&gt;<i> &gt; is: SuggestionKey * 7 !!!!!! for the other options 
</I>&gt;<i> described above it 
</I>&gt;<i> &gt; would even save: SuggestionKey * 8 or SuggestionKey * 12
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; A saving of SuggestionKey * 7 (with the settings of the second 
</I>&gt;<i> &gt; example) would in reality mean a saving of about 70% TOTAL size 
</I>&gt;<i> &gt; (including the
</I>&gt;<i> &gt; translation)
</I>&gt;<i> &gt; In the first example we would save about 60% size
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Also for extremely memory limited devices you probably can 
</I>&gt;<i> remove the 
</I>&gt;<i> &gt; enumeration completely after compiling (all enum members 
</I>&gt;<i> are compiled 
</I>&gt;<i> &gt; into int's), which increases savings even more.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; All that I stated now are just savings in assembly size. At runtime 
</I>&gt;<i> &gt; the savings are EVEN HIGHER! At runtime Mono should never need to 
</I>&gt;<i> &gt; access the enumeration keys (everything is int
</I>&gt;<i> &gt; now) so the need for RAM is probably about 80% LESS than 
</I>&gt;<i> the current 
</I>&gt;<i> &gt; solution!!!! That all with more programing safety and much higher 
</I>&gt;<i> &gt; access speeds at much lower CPU usage.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Andreas
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-devel-list mailing list
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A> 
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-">http://lists.ximian.com/mailman/listinfo/mono-devel-</A>&gt; list
</I>&gt;<i> &gt;
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A> 
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-">http://lists.ximian.com/mailman/listinfo/mono-devel-</A>&gt; list
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001504.html">[Mono-devel-list] how to help with mod_mono
</A></li>
	<LI>Next message: <A HREF="001498.html">[Mono-devel-list] String constants and localization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1497">[ date ]</a>
              <a href="thread.html#1497">[ thread ]</a>
              <a href="subject.html#1497">[ subject ]</a>
              <a href="author.html#1497">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
