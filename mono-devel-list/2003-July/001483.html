<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] String constants and localization
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20String%20constants%20and%20localization&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001480.html">
   <LINK REL="Next"  HREF="001494.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] String constants and localization</H1>
    <B>Andreas Nahr</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20String%20constants%20and%20localization&In-Reply-To="
       TITLE="[Mono-devel-list] String constants and localization">ClassDevelopment at A-SoftTech.com
       </A><BR>
    <I>Mon Jul 14 04:39:15 EDT 2003</I>
    <P><UL>
        <LI>Previous message: <A HREF="001480.html">[Mono-devel-list] String constants and localization
</A></li>
        <LI>Next message: <A HREF="001494.html">AW: [Mono-devel-list] String constants and localization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1483">[ date ]</a>
              <a href="thread.html#1483">[ thread ]</a>
              <a href="subject.html#1483">[ subject ]</a>
              <a href="author.html#1483">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

I've read your answer, but it seems that at quite some points you overlooked
advantages (maybe I'm also wrong with any of these, but I don't think so).
So I added some addidional comments to it

&gt;<i> &gt; right now there is nearly no localization support in the Mono class
</I>&gt;<i> &gt; libraries and all strings (mainly for errors) are hardcoded into the
</I>&gt;<i> &gt; source-files.
</I>&gt;<i>
</I>&gt;<i> Thanks for this proposal, I have some comments in this email about the
</I>&gt;<i> specifics of the proposal.
</I>&gt;<i>
</I>&gt;<i> Initially, I wanted to use it, but it meant that we would have to:
</I>&gt;<i>
</I>&gt;<i> * deviate from the standard practice (something I would not
</I>&gt;<i>   mind, if there were strong enough arguments for)
</I>
The basic arguments are:
* Much faster
* Much smaller Assembly size (see below)
* Much smaller RAM need
* More safe when programing because of compile errors for e.g. typos

&gt;<i> * Create and maintain a new infrastructure for localization.
</I>&gt;<i>   Not bad per-se, but it would minimize the reuse of existing
</I>&gt;<i>   knowledge that people might acquire or obtain from the NET.
</I>&gt;<i>
</I>&gt;<i> * Reimplement the chunks we already have for handling resources
</I>&gt;<i>   in corlib to cope with all the CultureInfo bits.
</I>
This is not neccesarily true. The sample implementation I did is using
System.Resources namespace to get it's localized data internally. More
specifically it ALLOWS to use it if you want, but does not force you to if
there is a better solution somebody wants to implement. And you can change
this solution at any time without having to change anything in the sources.
You could even use the now-used string tables and still save a litte memory
(see below: Strings as 16bit).

&gt;<i> I also want to avoid loading all the strings in memory, but it is
</I>&gt;<i> possible to do so:
</I>&gt;<i>
</I>&gt;<i> &gt; with a call like
</I>&gt;<i> &gt; Print (MS.GetString (MonoString.GenericENullNotAllowed));
</I>&gt;<i>
</I>&gt;<i> We should use the Resource infrastructure in .NET here: there are many
</I>&gt;<i> issues related to loading the proper assembly given the selected
</I>&gt;<i> CultureInfo, and the code is mostly implemented.
</I>&gt;<i>
</I>&gt;<i> The file format for resources allows for this case: it is possible to
</I>&gt;<i> fetch the information without having to load all the strings to
</I>&gt;<i> localize.
</I>&gt;<i>
</I>&gt;<i> What we need to do is improve the implementation of
</I>&gt;<i> ResourceSet.GetObject.  Basically we should define an internal method in
</I>&gt;<i> the ResourceReader that can do lookups based on strings, without having
</I>&gt;<i> to use the resource enumerator.
</I>
OK - but IMHO your solution just has two flaws:
* Reimplement the chunks we already have for handling resources
   in corlib to cope with all the CultureInfo bits (which is exactly what
you wanted to avoid above)
* Sooner or later you will always come to the GetResourceStream function,
which actually provides a memory stream, which is: loading all things into
memory (and if you want to provide a complete second infrastructure for
strings, then the work that has to be done would be IMHO FAR more work than
anything you might have to do to implement something like my suggested
solution)

&gt;<i> We already have an API that can load a string from an index, so the only
</I>&gt;<i> thing we have to do is perform a binary search on the strings in the
</I>&gt;<i> file (like Monodoc does now for its help).
</I>
Sorry but IMHO this it total overkill. You want to perform a binary search
DIRECTLY on a file containing an estimated 200KB string values EVERY time we
do a string lookup. Are you sure this won't totally fry your HDD. And what
about if the assembly we are accessing is on e.g. a network share that has
slow access times?
IMHO you will need to load string index that into memory in any case to
perform a binary search (or probably ANY other search)

As I already said: Even with a binary search you will just get search speeds
of O(ln n) while my solution would get O(1) and that is without taking into
account that you have to do the binary search on STRINGS, not on int's

&gt;<i> &gt; The Advantages are:
</I>&gt;<i> &gt; * Smaller Assemblies (probably leads to faster runtime performance in
</I>&gt;<i> &gt; Jit also because Jiting a constant int should be faster than Jiting a
</I>&gt;<i> &gt; constant string)
</I>&gt;<i>
</I>&gt;<i> Well, the space that you save on strings, say the string:
</I>&gt;<i>
</I>&gt;<i> &quot;Null not provided&quot;
</I>&gt;<i>
</I>&gt;<i> Would be encoded into an enumeration:
</I>&gt;<i>
</I>&gt;<i> Null_Not_Provided
</I>&gt;<i>
</I>&gt;<i> And that would end up in the metadata as well, so the change in size is
</I>&gt;<i> only half the size (strings are stored in 16-bit ucs-2 encoding).
</I>
I didn't even think about savings from not-having-to store as unicode ;) -
that even adds to data savings :)

I think you are overlooking a LOT of things here:

First example:
1. Mono now: Key = &quot;Null not provided&quot;, Translation = &quot;Null not provided&quot;
2. Suggestion: Key = Null_Not_Provided, Translation = &quot;Null not provided&quot;

In that case key equals about the size of Translation. As you said we only
need half the size for the enum value. So we need:
1. Memory: SuggestionKey * 2 * 2 (we also need it in the lookup table) +
Translation
2. Memory: SuggestionKey * 1 + Translation
SAVING is: SuggestionKey * 3
If you want to store the string somewhere to not have to hardcode it into
each individual class to prevent e.g. spelling errors (seems to be what MS
does) this even grows to a saving of:
SuggestionKey * 4
with inlining? active at compiling to a saving of:
SuggestionKey * 6

Second example (IMHO somewhere about what it could be in reality):
1. Mono now: Key = &quot;Null not provided because we have never provided null&quot;,
Translation = &quot;Null not provided because we have never provided null&quot;
2. Suggestion: Key = Null_Never_Provided, Translation = &quot;Null not provided
because we have never provided null&quot;

This should show the savings at a SuggestionKeySize about half of the size
of the string itself (I would estimate this to be a good total average):
1. Memory: SuggestionKey * 2 * 2 (we also need it in the lookup table) * 2
(double the size) + Translation
2. Memory: SuggestionKey * 1 + Translation
SAVING is: SuggestionKey * 7 !!!!!!
for the other options described above it would even save:
SuggestionKey * 8 or
SuggestionKey * 12

A saving of SuggestionKey * 7 (with the settings of the second example)
would in reality mean a saving of about 70% TOTAL size (including the
translation)
In the first example we would save about 60% size

Also for extremely memory limited devices you probably can remove the
enumeration completely after compiling (all enum members are compiled into
int's), which increases savings even more.

All that I stated now are just savings in assembly size. At runtime the
savings are EVEN HIGHER!
At runtime Mono should never need to access the enumeration keys (everything
is int now) so the need for RAM is probably about 80% LESS than the current
solution!!!!
That all with more programing safety and much higher access speeds at much
lower CPU usage.

Andreas


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001480.html">[Mono-devel-list] String constants and localization
</A></li>
	<LI>Next message: <A HREF="001494.html">AW: [Mono-devel-list] String constants and localization
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1483">[ date ]</a>
              <a href="thread.html#1483">[ thread ]</a>
              <a href="subject.html#1483">[ subject ]</a>
              <a href="author.html#1483">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
