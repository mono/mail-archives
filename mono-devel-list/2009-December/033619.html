<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [PATCH] Use trampolines for vtable fixups (Windows)	(updated)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Use%20trampolines%20for%20vtable%20fixups%20%28Windows%29%0A%09%28updated%29&In-Reply-To=4AEDC4F4.8060504%40gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033630.html">
   <LINK REL="Next"  HREF="033620.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [PATCH] Use trampolines for vtable fixups (Windows)	(updated)</H1>
    <B>Rodrigo Kumpera</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Use%20trampolines%20for%20vtable%20fixups%20%28Windows%29%0A%09%28updated%29&In-Reply-To=4AEDC4F4.8060504%40gmail.com"
       TITLE="[Mono-dev] [PATCH] Use trampolines for vtable fixups (Windows)	(updated)">kumpera at gmail.com
       </A><BR>
    <I>Wed Dec  2 13:33:17 EST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="033630.html">[Mono-dev] crashes while	executing	System.Buffer.BlockCopyInternal
</A></li>
        <LI>Next message: <A HREF="033620.html">[Mono-dev] inlining and performance of SIMD code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33619">[ date ]</a>
              <a href="thread.html#33619">[ thread ]</a>
              <a href="subject.html#33619">[ subject ]</a>
              <a href="author.html#33619">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Submit them separatedly, because the commits should be split anyway.

And please, don't put the patch inline in the email body.

Thanks,
Rodrigo

2009/11/1 Korn&#233;l P&#225;l &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">kornelpal at gmail.com</A>&gt;

&gt;<i> I found out that reference counting in mono_image_close_except_pools was
</I>&gt;<i> broken so I fixed that as well.
</I>&gt;<i>
</I>&gt;<i> Double freeing was possible with mono_close_exe_image and I fixed that as
</I>&gt;<i> well.
</I>&gt;<i>
</I>&gt;<i> I can submit these two separately, but the first one is required by
</I>&gt;<i> mono_vtfixup_trampoline to function correctly.
</I>&gt;<i>
</I>&gt;<i> Korn&#233;l
</I>&gt;<i>
</I>&gt;<i> Korn&#233;l P&#225;l wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Please see the attached patch that is a separated and improved version
</I>&gt;&gt;<i> of the prevously submitted patch.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ChangeLog draft:
</I>&gt;&gt;<i> mono_image_fixup_vtable is now called only when the image is loaded and
</I>&gt;&gt;<i> creates trampolines rather than pointers to wrapper functions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A new trampoline type MONO_TRAMPOLINE_VTFIXUP is added that is created
</I>&gt;&gt;<i> by mono_image_fixup_vtable, and is replacing the pointer to the
</I>&gt;&gt;<i> trampoline with the result mono_marshal_get_vtfixup_ftnptr.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Please review and if you like it, approve the patch.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thanks.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Index: mono/mono/metadata/domain.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/domain.c (revision 145149)
</I>&gt;<i> +++ mono/mono/metadata/domain.c (working copy)
</I>&gt;<i> @@ -1735,8 +1735,10 @@
</I>&gt;<i>  void
</I>&gt;<i>  mono_close_exe_image (void)
</I>&gt;<i>  {
</I>&gt;<i> -       if (exe_image)
</I>&gt;<i> +       if (exe_image) {
</I>&gt;<i>                mono_image_close (exe_image);
</I>&gt;<i> +               exe_image = NULL;
</I>&gt;<i> +       }
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>  /**
</I>&gt;<i> Index: mono/mono/metadata/assembly.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/assembly.c       (revision 145149)
</I>&gt;<i> +++ mono/mono/metadata/assembly.c       (working copy)
</I>&gt;<i> @@ -1522,11 +1522,6 @@
</I>&gt;<i>        loaded_assemblies = g_list_prepend (loaded_assemblies, ass);
</I>&gt;<i>        mono_assemblies_unlock ();
</I>&gt;<i>
</I>&gt;<i> -#ifdef PLATFORM_WIN32
</I>&gt;<i> -       if (image-&gt;is_module_handle)
</I>&gt;<i> -               mono_image_fixup_vtable (image);
</I>&gt;<i> -#endif
</I>&gt;<i> -
</I>&gt;<i>        mono_assembly_invoke_load_hook (ass);
</I>&gt;<i>
</I>&gt;<i>        mono_profiler_assembly_loaded (ass, MONO_PROFILE_OK);
</I>&gt;<i> Index: mono/mono/metadata/coree.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/coree.c  (revision 145149)
</I>&gt;<i> +++ mono/mono/metadata/coree.c  (working copy)
</I>&gt;<i> @@ -106,20 +106,12 @@
</I>&gt;<i>                        }
</I>&gt;<i>                }
</I>&gt;<i>
</I>&gt;<i> -               if (!image) {
</I>&gt;<i> -                       g_free (file_name);
</I>&gt;<i> +               g_free (file_name);
</I>&gt;<i> +
</I>&gt;<i> +               if (!image)
</I>&gt;<i>                        return FALSE;
</I>&gt;<i> -               }
</I>&gt;<i>
</I>&gt;<i> -               /*
</I>&gt;<i> -                * FIXME: Find a better way to call
</I>&gt;<i> mono_image_fixup_vtable. Only
</I>&gt;<i> -                * loader trampolines should be used and assembly loading
</I>&gt;<i> should
</I>&gt;<i> -                * probably be delayed until the first call to an exported
</I>&gt;<i> function.
</I>&gt;<i> -                */
</I>&gt;<i> -               if (image-&gt;tables [MONO_TABLE_ASSEMBLY].rows &amp;&amp;
</I>&gt;<i> ((MonoCLIImageInfo*)
</I>&gt;<i> image-&gt;image_info)-&gt;cli_cli_header.ch_vtable_fixups.rva)
</I>&gt;<i> -                       assembly = mono_assembly_open (file_name, NULL);
</I>&gt;<i> -
</I>&gt;<i> -               g_free (file_name);
</I>&gt;<i> +               mono_image_fixup_vtable (image);
</I>&gt;<i>                break;
</I>&gt;<i>        case DLL_PROCESS_DETACH:
</I>&gt;<i>                if (lpReserved != NULL)
</I>&gt;<i> @@ -198,6 +190,8 @@
</I>&gt;<i>                argv [i] = g_utf16_to_utf8 (argvw [i], -1, NULL, NULL,
</I>&gt;<i> NULL);
</I>&gt;<i>        LocalFree (argvw);
</I>&gt;<i>
</I>&gt;<i> +       mono_image_fixup_vtable (image);
</I>&gt;<i> +
</I>&gt;<i>        mono_runtime_run_main (method, argc, argv, NULL);
</I>&gt;<i>        mono_thread_manage ();
</I>&gt;<i>
</I>&gt;<i> @@ -919,8 +913,10 @@
</I>&gt;<i>  void
</I>&gt;<i>  mono_fixup_exe_image (MonoImage* image)
</I>&gt;<i>  {
</I>&gt;<i> -       if (!init_from_coree &amp;&amp; image &amp;&amp; image-&gt;is_module_handle)
</I>&gt;<i> +       if (!init_from_coree &amp;&amp; image &amp;&amp; image-&gt;is_module_handle) {
</I>&gt;<i>                MonoFixupExe ((HMODULE) image-&gt;raw_data);
</I>&gt;<i> +               mono_image_fixup_vtable (image);
</I>&gt;<i> +       }
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>  #endif /* PLATFORM_WIN32 */
</I>&gt;<i> Index: mono/mono/metadata/object.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/object.c (revision 145149)
</I>&gt;<i> +++ mono/mono/metadata/object.c (working copy)
</I>&gt;<i> @@ -470,10 +470,18 @@
</I>&gt;<i>        return NULL;
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> +static gpointer
</I>&gt;<i> +default_vtfixup_trampoline (gpointer slot, MonoImage *image, guint32
</I>&gt;<i> token, guint16 type)
</I>&gt;<i> +{
</I>&gt;<i> +       g_assert_not_reached ();
</I>&gt;<i> +       return NULL;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i>  static MonoTrampoline arch_create_jit_trampoline = default_trampoline;
</I>&gt;<i>  static MonoJumpTrampoline arch_create_jump_trampoline =
</I>&gt;<i> default_jump_trampoline;
</I>&gt;<i>  static MonoRemotingTrampoline arch_create_remoting_trampoline =
</I>&gt;<i> default_remoting_trampoline;
</I>&gt;<i>  static MonoDelegateTrampoline arch_create_delegate_trampoline =
</I>&gt;<i> default_delegate_trampoline;
</I>&gt;<i> +static MonoVTFixupTrampoline arch_create_vtfixup_trampoline =
</I>&gt;<i> default_vtfixup_trampoline;
</I>&gt;<i>  static MonoImtThunkBuilder imt_thunk_builder = NULL;
</I>&gt;<i>  #define ARCH_USE_IMT (imt_thunk_builder != NULL)
</I>&gt;<i>  #if (MONO_IMT_SIZE &gt; 32)
</I>&gt;<i> @@ -517,6 +525,12 @@
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>  void
</I>&gt;<i> +mono_install_vtfixup_trampoline (MonoVTFixupTrampoline func)
</I>&gt;<i> +{
</I>&gt;<i> +       arch_create_vtfixup_trampoline = func? func:
</I>&gt;<i> default_vtfixup_trampoline;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +void
</I>&gt;<i>  mono_install_imt_thunk_builder (MonoImtThunkBuilder func) {
</I>&gt;<i>        imt_thunk_builder = func;
</I>&gt;<i>  }
</I>&gt;<i> @@ -564,6 +578,12 @@
</I>&gt;<i>        return arch_create_delegate_trampoline (klass);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> +gpointer
</I>&gt;<i> +mono_runtime_create_vtfixup_trampoline (gpointer slot, MonoImage *image,
</I>&gt;<i> guint32 token, guint16 type)
</I>&gt;<i> +{
</I>&gt;<i> +       return arch_create_vtfixup_trampoline (slot, image, token, type);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i>  static MonoFreeMethodFunc default_mono_free_method = NULL;
</I>&gt;<i>
</I>&gt;<i>  /**
</I>&gt;<i> Index: mono/mono/metadata/class-internals.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/class-internals.h        (revision 145149)
</I>&gt;<i> +++ mono/mono/metadata/class-internals.h        (working copy)
</I>&gt;<i> @@ -803,6 +803,7 @@
</I>&gt;<i>  typedef gpointer (*MonoJumpTrampoline)       (MonoDomain *domain,
</I>&gt;<i> MonoMethod *method, gboolean add_sync_wrapper);
</I>&gt;<i>  typedef gpointer (*MonoRemotingTrampoline)       (MonoDomain *domain,
</I>&gt;<i> MonoMethod *method, MonoRemotingTarget target);
</I>&gt;<i>  typedef gpointer (*MonoDelegateTrampoline)       (MonoClass *klass);
</I>&gt;<i> +typedef gpointer (*MonoVTFixupTrampoline)       (gpointer slot, MonoImage
</I>&gt;<i> *image, guint32 token, guint16 type);
</I>&gt;<i>
</I>&gt;<i>  typedef gpointer (*MonoLookupDynamicToken) (MonoImage *image, guint32
</I>&gt;<i> token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext
</I>&gt;<i> *context);
</I>&gt;<i>
</I>&gt;<i> @@ -892,6 +893,9 @@
</I>&gt;<i>  void
</I>&gt;<i>  mono_install_delegate_trampoline (MonoDelegateTrampoline func)
</I>&gt;<i> MONO_INTERNAL;
</I>&gt;<i>
</I>&gt;<i> +void
</I>&gt;<i> +mono_install_vtfixup_trampoline (MonoVTFixupTrampoline func)
</I>&gt;<i> MONO_INTERNAL;
</I>&gt;<i> +
</I>&gt;<i>  gpointer
</I>&gt;<i>  mono_lookup_dynamic_token (MonoImage *image, guint32 token,
</I>&gt;<i> MonoGenericContext *context) MONO_INTERNAL;
</I>&gt;<i>
</I>&gt;<i> @@ -907,6 +911,9 @@
</I>&gt;<i>  gpointer
</I>&gt;<i>  mono_runtime_create_delegate_trampoline (MonoClass *klass) MONO_INTERNAL;
</I>&gt;<i>
</I>&gt;<i> +gpointer
</I>&gt;<i> +mono_runtime_create_vtfixup_trampoline (gpointer slot, MonoImage *image,
</I>&gt;<i> guint32 token, guint16 type) MONO_INTERNAL;
</I>&gt;<i> +
</I>&gt;<i>  void
</I>&gt;<i>  mono_install_get_cached_class_info (MonoGetCachedClassInfo func)
</I>&gt;<i> MONO_INTERNAL;
</I>&gt;<i>
</I>&gt;<i> Index: mono/mono/metadata/image.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/image.c  (revision 145149)
</I>&gt;<i> +++ mono/mono/metadata/image.c  (working copy)
</I>&gt;<i> @@ -572,10 +572,6 @@
</I>&gt;<i>                        if (image-&gt;modules [idx - 1]) {
</I>&gt;<i>                                mono_image_addref (image-&gt;modules [idx -
</I>&gt;<i> 1]);
</I>&gt;<i>                                image-&gt;modules [idx - 1]-&gt;assembly =
</I>&gt;<i> image-&gt;assembly;
</I>&gt;<i> -#ifdef PLATFORM_WIN32
</I>&gt;<i> -                               if (image-&gt;modules [idx -
</I>&gt;<i> 1]-&gt;is_module_handle)
</I>&gt;<i> -                                       mono_image_fixup_vtable
</I>&gt;<i> (image-&gt;modules [idx - 1]);
</I>&gt;<i> -#endif
</I>&gt;<i>                                /* g_print (&quot;loaded module %s from %s
</I>&gt;<i> (%p)\n&quot;, module_ref, image-&gt;name, image-&gt;assembly); */
</I>&gt;<i>                        }
</I>&gt;<i>                        g_free (module_ref);
</I>&gt;<i> @@ -1292,7 +1288,6 @@
</I>&gt;<i>  void
</I>&gt;<i>  mono_image_fixup_vtable (MonoImage *image)
</I>&gt;<i>  {
</I>&gt;<i> -#ifdef PLATFORM_WIN32
</I>&gt;<i>        MonoCLIImageInfo *iinfo;
</I>&gt;<i>        MonoPEDirEntry *de;
</I>&gt;<i>        MonoVTableFixup *vtfixup;
</I>&gt;<i> @@ -1301,7 +1296,10 @@
</I>&gt;<i>        guint16 slot_type;
</I>&gt;<i>        int slot_count;
</I>&gt;<i>
</I>&gt;<i> -       g_assert (image-&gt;is_module_handle);
</I>&gt;<i> +#ifdef PLATFORM_WIN32
</I>&gt;<i> +       if (!image-&gt;is_module_handle)
</I>&gt;<i> +#endif
</I>&gt;<i> +               g_assert_not_reached();
</I>&gt;<i>
</I>&gt;<i>        iinfo = image-&gt;image_info;
</I>&gt;<i>        de = &amp;iinfo-&gt;cli_cli_header.ch_vtable_fixups;
</I>&gt;<i> @@ -1310,7 +1308,7 @@
</I>&gt;<i>        vtfixup = (MonoVTableFixup*) mono_image_rva_map (image, de-&gt;rva);
</I>&gt;<i>        if (!vtfixup)
</I>&gt;<i>                return;
</I>&gt;<i> -
</I>&gt;<i> +
</I>&gt;<i>        count = de-&gt;size / sizeof (MonoVTableFixup);
</I>&gt;<i>        while (count--) {
</I>&gt;<i>                if (!vtfixup-&gt;rva || !vtfixup-&gt;count)
</I>&gt;<i> @@ -1320,24 +1318,26 @@
</I>&gt;<i>                g_assert (slot);
</I>&gt;<i>                slot_type = vtfixup-&gt;type;
</I>&gt;<i>                slot_count = vtfixup-&gt;count;
</I>&gt;<i> -               if (slot_type &amp; VTFIXUP_TYPE_32BIT)
</I>&gt;<i> +
</I>&gt;<i> +               switch (slot_type &amp; (VTFIXUP_TYPE_32BIT |
</I>&gt;<i> VTFIXUP_TYPE_64BIT)) {
</I>&gt;<i> +               case VTFIXUP_TYPE_32BIT:
</I>&gt;<i>                        while (slot_count--) {
</I>&gt;<i> -                               *((guint32*) slot) = (guint32)
</I>&gt;<i> mono_marshal_get_vtfixup_ftnptr (image, *((guint32*) slot), slot_type);
</I>&gt;<i> +                               *((guint32*) slot) = (guint32)
</I>&gt;<i> mono_runtime_create_vtfixup_trampoline (slot, image, *((guint32*) slot),
</I>&gt;<i> slot_type);
</I>&gt;<i>                                slot = ((guint32*) slot) + 1;
</I>&gt;<i>                        }
</I>&gt;<i> -               else if (slot_type &amp; VTFIXUP_TYPE_64BIT)
</I>&gt;<i> +                       break;
</I>&gt;<i> +               case VTFIXUP_TYPE_64BIT:
</I>&gt;<i>                        while (slot_count--) {
</I>&gt;<i> -                               *((guint64*) slot) = (guint64)
</I>&gt;<i> mono_marshal_get_vtfixup_ftnptr (image, *((guint64*) slot), slot_type);
</I>&gt;<i> -                               slot = ((guint32*) slot) + 1;
</I>&gt;<i> +                               *((guint64*) slot) = (guint64)
</I>&gt;<i> mono_runtime_create_vtfixup_trampoline (slot, image, *((guint64*) slot),
</I>&gt;<i> slot_type);
</I>&gt;<i> +                               slot = ((guint64*) slot) + 1;
</I>&gt;<i>                        }
</I>&gt;<i> -               else
</I>&gt;<i> +                       break;
</I>&gt;<i> +               default:
</I>&gt;<i>                        g_assert_not_reached();
</I>&gt;<i> +               }
</I>&gt;<i>
</I>&gt;<i>                vtfixup++;
</I>&gt;<i>        }
</I>&gt;<i> -#else
</I>&gt;<i> -       g_assert_not_reached();
</I>&gt;<i> -#endif
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>  static void
</I>&gt;<i> @@ -1424,6 +1424,15 @@
</I>&gt;<i>                return FALSE;
</I>&gt;<i>        }
</I>&gt;<i>
</I>&gt;<i> +#ifdef PLATFORM_WIN32
</I>&gt;<i> +       if (image-&gt;is_module_handle &amp;&amp; image-&gt;has_entry_point &amp;&amp;
</I>&gt;<i> image-&gt;ref_count == 0) {
</I>&gt;<i> +               /* Image will be closed by _CorDllMain. */
</I>&gt;<i> +               FreeLibrary ((HMODULE) image-&gt;raw_data);
</I>&gt;<i> +               mono_images_unlock ();
</I>&gt;<i> +               return FALSE;
</I>&gt;<i> +       }
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i>        loaded_images = image-&gt;ref_only ? loaded_images_refonly_hash :
</I>&gt;<i> loaded_images_hash;
</I>&gt;<i>        image2 = g_hash_table_lookup (loaded_images, image-&gt;name);
</I>&gt;<i>        if (image == image2) {
</I>&gt;<i> @@ -1435,19 +1444,6 @@
</I>&gt;<i>
</I>&gt;<i>        mono_images_unlock ();
</I>&gt;<i>
</I>&gt;<i> -#ifdef PLATFORM_WIN32
</I>&gt;<i> -       if (image-&gt;is_module_handle &amp;&amp; image-&gt;has_entry_point) {
</I>&gt;<i> -               mono_images_lock ();
</I>&gt;<i> -               if (image-&gt;ref_count == 0) {
</I>&gt;<i> -                       /* Image will be closed by _CorDllMain. */
</I>&gt;<i> -                       FreeLibrary ((HMODULE) image-&gt;raw_data);
</I>&gt;<i> -                       mono_images_unlock ();
</I>&gt;<i> -                       return FALSE;
</I>&gt;<i> -               }
</I>&gt;<i> -               mono_images_unlock ();
</I>&gt;<i> -       }
</I>&gt;<i> -#endif
</I>&gt;<i> -
</I>&gt;<i>        mono_profiler_module_event (image, MONO_PROFILE_START_UNLOAD);
</I>&gt;<i>
</I>&gt;<i>        mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_ASSEMBLY, &quot;Unloading image
</I>&gt;<i> %s [%p].&quot;, image-&gt;name, image);
</I>&gt;<i> @@ -1477,10 +1473,11 @@
</I>&gt;<i>        }
</I>&gt;<i>
</I>&gt;<i>  #ifdef PLATFORM_WIN32
</I>&gt;<i> -       mono_images_lock ();
</I>&gt;<i> -       if (image-&gt;is_module_handle &amp;&amp; !image-&gt;has_entry_point)
</I>&gt;<i> +       if (image-&gt;is_module_handle &amp;&amp; !image-&gt;has_entry_point) {
</I>&gt;<i> +               mono_images_lock ();
</I>&gt;<i>                FreeLibrary ((HMODULE) image-&gt;raw_data);
</I>&gt;<i> -       mono_images_unlock ();
</I>&gt;<i> +               mono_images_unlock ();
</I>&gt;<i> +       }
</I>&gt;<i>  #endif
</I>&gt;<i>
</I>&gt;<i>        if (image-&gt;raw_buffer_used) {
</I>&gt;<i> @@ -1926,10 +1923,6 @@
</I>&gt;<i>                }
</I>&gt;<i>
</I>&gt;<i>                image-&gt;files [fileidx - 1] = res;
</I>&gt;<i> -#ifdef PLATFORM_WIN32
</I>&gt;<i> -               if (res-&gt;is_module_handle)
</I>&gt;<i> -                       mono_image_fixup_vtable (res);
</I>&gt;<i> -#endif
</I>&gt;<i>        }
</I>&gt;<i>        mono_loader_unlock ();
</I>&gt;<i>        g_free (name);
</I>&gt;<i> Index: mono/mono/metadata/marshal.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/marshal.c        (revision 145149)
</I>&gt;<i> +++ mono/mono/metadata/marshal.c        (working copy)
</I>&gt;<i> @@ -8591,7 +8591,7 @@
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>  gpointer
</I>&gt;<i> -mono_marshal_get_vtfixup_ftnptr (MonoImage *image, guint32 token, guint16
</I>&gt;<i> type)
</I>&gt;<i> +mono_marshal_get_vtfixup_ftnptr (MonoImage *image, guint32 token, guint16
</I>&gt;<i> type, MonoMethod **wrapper_method)
</I>&gt;<i>  {
</I>&gt;<i>        MonoMethod *method;
</I>&gt;<i>        MonoMethodSignature *sig;
</I>&gt;<i> @@ -8641,9 +8641,15 @@
</I>&gt;<i>                                mono_metadata_free_marshal_spec (mspecs
</I>&gt;<i> [i]);
</I>&gt;<i>                g_free (mspecs);
</I>&gt;<i>
</I>&gt;<i> +               *wrapper_method = method;
</I>&gt;<i>                return mono_compile_method (method);
</I>&gt;<i>        }
</I>&gt;<i>
</I>&gt;<i> +       if (!(type &amp; VTFIXUP_TYPE_CALL_MOST_DERIVED)) {
</I>&gt;<i> +               wrapper_method = NULL;
</I>&gt;<i> +               return mono_compile_method (method);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i>        sig = mono_method_signature (method);
</I>&gt;<i>        mb = mono_mb_new (method-&gt;klass, method-&gt;name,
</I>&gt;<i> MONO_WRAPPER_MANAGED_TO_MANAGED);
</I>&gt;<i>
</I>&gt;<i> @@ -8651,16 +8657,14 @@
</I>&gt;<i>        for (i = 0; i &lt; param_count; i++)
</I>&gt;<i>                mono_mb_emit_ldarg (mb, i);
</I>&gt;<i>
</I>&gt;<i> -       if (type &amp; VTFIXUP_TYPE_CALL_MOST_DERIVED)
</I>&gt;<i> -               mono_mb_emit_op (mb, CEE_CALLVIRT, method);
</I>&gt;<i> -       else
</I>&gt;<i> -               mono_mb_emit_op (mb, CEE_CALL, method);
</I>&gt;<i> +       mono_mb_emit_op (mb, CEE_CALLVIRT, method);
</I>&gt;<i>        mono_mb_emit_byte (mb, CEE_RET);
</I>&gt;<i>
</I>&gt;<i>        mb-&gt;dynamic = 1;
</I>&gt;<i>        method = mono_mb_create_method (mb, sig, param_count);
</I>&gt;<i>        mono_mb_free (mb);
</I>&gt;<i>
</I>&gt;<i> +       *wrapper_method = method;
</I>&gt;<i>        return mono_compile_method (method);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> Index: mono/mono/metadata/marshal.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/metadata/marshal.h        (revision 145149)
</I>&gt;<i> +++ mono/mono/metadata/marshal.h        (working copy)
</I>&gt;<i> @@ -199,7 +199,7 @@
</I>&gt;<i>  mono_marshal_get_managed_wrapper (MonoMethod *method, MonoClass
</I>&gt;<i> *delegate_klass, MonoObject **this_loc) MONO_INTERNAL;
</I>&gt;<i>
</I>&gt;<i>  gpointer
</I>&gt;<i> -mono_marshal_get_vtfixup_ftnptr (MonoImage *image, guint32 token, guint16
</I>&gt;<i> type) MONO_INTERNAL;
</I>&gt;<i> +mono_marshal_get_vtfixup_ftnptr (MonoImage *image, guint32 token, guint16
</I>&gt;<i> type, MonoMethod **wrapper_method) MONO_INTERNAL;
</I>&gt;<i>
</I>&gt;<i>  MonoMethod *
</I>&gt;<i>  mono_marshal_get_icall_wrapper (MonoMethodSignature *sig, const char
</I>&gt;<i> *name, gconstpointer func, gboolean check_exceptions) MONO_INTERNAL;
</I>&gt;<i> Index: mono/mono/mini/mini.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/mini/mini.c       (revision 145149)
</I>&gt;<i> +++ mono/mono/mini/mini.c       (working copy)
</I>&gt;<i> @@ -5058,6 +5058,7 @@
</I>&gt;<i>        mono_install_jump_trampoline (mono_create_jump_trampoline);
</I>&gt;<i>        mono_install_remoting_trampoline
</I>&gt;<i> (mono_jit_create_remoting_trampoline);
</I>&gt;<i>        mono_install_delegate_trampoline (mono_create_delegate_trampoline);
</I>&gt;<i> +       mono_install_vtfixup_trampoline (mono_create_vtfixup_trampoline);
</I>&gt;<i>        mono_install_create_domain_hook (mini_create_jit_domain_info);
</I>&gt;<i>        mono_install_free_domain_hook (mini_free_jit_domain_info);
</I>&gt;<i>  #endif
</I>&gt;<i> Index: mono/mono/mini/mini.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/mini/mini.h       (revision 145149)
</I>&gt;<i> +++ mono/mono/mini/mini.h       (working copy)
</I>&gt;<i> @@ -827,6 +827,7 @@
</I>&gt;<i>        MONO_TRAMPOLINE_GENERIC_VIRTUAL_REMOTING,
</I>&gt;<i>        MONO_TRAMPOLINE_MONITOR_ENTER,
</I>&gt;<i>        MONO_TRAMPOLINE_MONITOR_EXIT,
</I>&gt;<i> +       MONO_TRAMPOLINE_VTFIXUP,
</I>&gt;<i>  #ifdef ENABLE_LLVM
</I>&gt;<i>        MONO_TRAMPOLINE_LLVM_VCALL,
</I>&gt;<i>  #endif
</I>&gt;<i> @@ -1482,6 +1483,7 @@
</I>&gt;<i>  gpointer          mono_create_monitor_enter_trampoline (void)
</I>&gt;<i> MONO_INTERNAL;
</I>&gt;<i>  gpointer          mono_create_monitor_exit_trampoline (void)
</I>&gt;<i> MONO_INTERNAL;
</I>&gt;<i>  gpointer          mono_create_static_rgctx_trampoline (MonoMethod *m,
</I>&gt;<i> gpointer addr) MONO_INTERNAL;
</I>&gt;<i> +gpointer          mono_create_vtfixup_trampoline (gpointer slot, MonoImage
</I>&gt;<i> *image, guint32 token, guint16 type) MONO_INTERNAL;
</I>&gt;<i>  gpointer          mono_create_llvm_vcall_trampoline (MonoMethod *method)
</I>&gt;<i> MONO_INTERNAL;
</I>&gt;<i>  MonoVTable*       mono_find_class_init_trampoline_by_addr (gconstpointer
</I>&gt;<i> addr) MONO_INTERNAL;
</I>&gt;<i>  guint32           mono_find_rgctx_lazy_fetch_trampoline_by_addr
</I>&gt;<i> (gconstpointer addr) MONO_INTERNAL;
</I>&gt;<i> Index: mono/mono/mini/mini-trampolines.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/mini/mini-trampolines.c   (revision 145149)
</I>&gt;<i> +++ mono/mono/mini/mini-trampolines.c   (working copy)
</I>&gt;<i> @@ -6,6 +6,8 @@
</I>&gt;<i>  #include &lt;mono/metadata/metadata-internals.h&gt;
</I>&gt;<i>  #include &lt;mono/metadata/marshal.h&gt;
</I>&gt;<i>  #include &lt;mono/metadata/tabledefs.h&gt;
</I>&gt;<i> +#include &lt;mono/metadata/assembly.h&gt;
</I>&gt;<i> +#include &lt;mono/metadata/cil-coff.h&gt;
</I>&gt;<i>  #include &lt;mono/utils/mono-counters.h&gt;
</I>&gt;<i>
</I>&gt;<i>  #ifdef HAVE_VALGRIND_MEMCHECK_H
</I>&gt;<i> @@ -779,6 +781,67 @@
</I>&gt;<i>        mono_monitor_exit (obj);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> +static gpointer
</I>&gt;<i> +mono_vtfixup_trampoline (gssize *regs, guint8 *code, guint8 *slot_info,
</I>&gt;<i> guint8* tramp)
</I>&gt;<i> +{
</I>&gt;<i> +       gpointer tramp_addr;
</I>&gt;<i> +       gpointer slot, slot_addr;
</I>&gt;<i> +       MonoImage *image;
</I>&gt;<i> +       guint32 token;
</I>&gt;<i> +       guint16 type;
</I>&gt;<i> +       gpointer addr;
</I>&gt;<i> +       MonoMethod *wrapper_method;
</I>&gt;<i> +       MonoImageOpenStatus status;
</I>&gt;<i> +
</I>&gt;<i> +       tramp_addr = *((gpointer*) (gpointer) slot_info);
</I>&gt;<i> +       slot_info += sizeof (gpointer);
</I>&gt;<i> +       slot = *((gpointer*) (gpointer) slot_info);
</I>&gt;<i> +       slot_info += sizeof (gpointer);
</I>&gt;<i> +       image = *((gpointer*) (gpointer) slot_info);
</I>&gt;<i> +       slot_info += sizeof (gpointer);
</I>&gt;<i> +       token = *((guint32*) (gpointer) slot_info);
</I>&gt;<i> +       slot_info += sizeof (guint32);
</I>&gt;<i> +       type = *((guint16*) (gpointer) slot_info);
</I>&gt;<i> +
</I>&gt;<i> +       if (type &amp; VTFIXUP_TYPE_64BIT)
</I>&gt;<i> +               slot_addr = (gpointer) *((volatile gint64*) (slot));
</I>&gt;<i> +       else
</I>&gt;<i> +               slot_addr = (gpointer) *((volatile gint32*) (slot));
</I>&gt;<i> +
</I>&gt;<i> +       if (slot_addr != tramp_addr)
</I>&gt;<i> +               return slot_addr;
</I>&gt;<i> +
</I>&gt;<i> +       if (!image-&gt;assembly) {
</I>&gt;<i> +               /* Open image to increment LoadLibrary reference count */
</I>&gt;<i> +               g_assert (image == mono_image_open_full (image-&gt;name, NULL,
</I>&gt;<i> FALSE));
</I>&gt;<i> +
</I>&gt;<i> +               /* FIXME: Throw exceptions when assembly cannot be loaded
</I>&gt;<i> */
</I>&gt;<i> +               /* FIXME: Fix mono_assembly_load_from_full to allow loading
</I>&gt;<i> mscorlib.dll */
</I>&gt;<i> +               g_assert (mono_assembly_load_from_full (image, image-&gt;name,
</I>&gt;<i> &amp;status, FALSE));
</I>&gt;<i> +
</I>&gt;<i> +               /* Release temporary reference */
</I>&gt;<i> +               mono_image_close (image);
</I>&gt;<i> +       }
</I>&gt;<i> +
</I>&gt;<i> +       addr = mono_marshal_get_vtfixup_ftnptr (image, token, type,
</I>&gt;<i> &amp;wrapper_method);
</I>&gt;<i> +       if (type &amp; VTFIXUP_TYPE_64BIT)
</I>&gt;<i> +#if SIZEOF_VOID_P == 8
</I>&gt;<i> +               slot_addr = InterlockedCompareExchangePointer (slot, addr,
</I>&gt;<i> tramp_addr);
</I>&gt;<i> +#else
</I>&gt;<i> +               slot_addr = (gpointer)
</I>&gt;<i> ves_icall_System_Threading_Interlocked_CompareExchange_Long ((gint64*) slot,
</I>&gt;<i> (gint64) addr, (gint64) tramp_addr);
</I>&gt;<i> +#endif
</I>&gt;<i> +       else
</I>&gt;<i> +               slot_addr = (gpointer) InterlockedCompareExchange
</I>&gt;<i> ((gint32*) slot, (gint32) addr, (gint32) tramp_addr);
</I>&gt;<i> +
</I>&gt;<i> +       if (slot_addr == tramp_addr)
</I>&gt;<i> +               return addr;
</I>&gt;<i> +
</I>&gt;<i> +       if (wrapper_method)
</I>&gt;<i> +               mono_free_method (wrapper_method);
</I>&gt;<i> +
</I>&gt;<i> +       return slot_addr;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i>  #ifdef MONO_ARCH_HAVE_CREATE_DELEGATE_TRAMPOLINE
</I>&gt;<i>
</I>&gt;<i>  /**
</I>&gt;<i> @@ -922,6 +985,8 @@
</I>&gt;<i>                return mono_monitor_enter_trampoline;
</I>&gt;<i>        case MONO_TRAMPOLINE_MONITOR_EXIT:
</I>&gt;<i>                return mono_monitor_exit_trampoline;
</I>&gt;<i> +       case MONO_TRAMPOLINE_VTFIXUP:
</I>&gt;<i> +               return mono_vtfixup_trampoline;
</I>&gt;<i>  #ifdef ENABLE_LLVM
</I>&gt;<i>        case MONO_TRAMPOLINE_LLVM_VCALL:
</I>&gt;<i>                return mono_llvm_vcall_trampoline;
</I>&gt;<i> @@ -956,6 +1021,7 @@
</I>&gt;<i>        mono_trampoline_code [MONO_TRAMPOLINE_GENERIC_VIRTUAL_REMOTING] =
</I>&gt;<i> mono_arch_create_trampoline_code (MONO_TRAMPOLINE_GENERIC_VIRTUAL_REMOTING);
</I>&gt;<i>        mono_trampoline_code [MONO_TRAMPOLINE_MONITOR_ENTER] =
</I>&gt;<i> mono_arch_create_trampoline_code (MONO_TRAMPOLINE_MONITOR_ENTER);
</I>&gt;<i>        mono_trampoline_code [MONO_TRAMPOLINE_MONITOR_EXIT] =
</I>&gt;<i> mono_arch_create_trampoline_code (MONO_TRAMPOLINE_MONITOR_EXIT);
</I>&gt;<i> +       mono_trampoline_code [MONO_TRAMPOLINE_VTFIXUP] =
</I>&gt;<i> mono_arch_create_trampoline_code (MONO_TRAMPOLINE_VTFIXUP);
</I>&gt;<i>  #ifdef ENABLE_LLVM
</I>&gt;<i>        mono_trampoline_code [MONO_TRAMPOLINE_LLVM_VCALL] =
</I>&gt;<i> mono_arch_create_trampoline_code (MONO_TRAMPOLINE_LLVM_VCALL);
</I>&gt;<i>  #endif
</I>&gt;<i> @@ -1280,7 +1346,31 @@
</I>&gt;<i>  #endif
</I>&gt;<i>        return code;
</I>&gt;<i>  }
</I>&gt;<i> -
</I>&gt;<i> +
</I>&gt;<i> +gpointer
</I>&gt;<i> +mono_create_vtfixup_trampoline (gpointer slot, MonoImage *image, guint32
</I>&gt;<i> token, guint16 type)
</I>&gt;<i> +{
</I>&gt;<i> +       gpointer tramp;
</I>&gt;<i> +
</I>&gt;<i> +       MonoDomain *domain = mono_get_root_domain ();
</I>&gt;<i> +       guint8 *buf, *start;
</I>&gt;<i> +
</I>&gt;<i> +       buf = start = mono_domain_code_reserve (domain, 3 * sizeof
</I>&gt;<i> (gpointer) + sizeof (guint32) + sizeof (guint16));
</I>&gt;<i> +
</I>&gt;<i> +       buf += sizeof (gpointer);
</I>&gt;<i> +       *(gpointer*) (gpointer) buf = slot;
</I>&gt;<i> +       buf += sizeof (gpointer);
</I>&gt;<i> +       *(gpointer*) (gpointer) buf = image;
</I>&gt;<i> +       buf += sizeof (gpointer);
</I>&gt;<i> +       *(guint32*) (gpointer) buf = token;
</I>&gt;<i> +       buf += sizeof (guint32);
</I>&gt;<i> +       *(guint16*) (gpointer) buf = type;
</I>&gt;<i> +
</I>&gt;<i> +       tramp = mono_create_specific_trampoline (start,
</I>&gt;<i> MONO_TRAMPOLINE_VTFIXUP, domain, NULL);
</I>&gt;<i> +       *(gpointer*) (gpointer) start = tramp;
</I>&gt;<i> +       return tramp;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i>  #ifdef ENABLE_LLVM
</I>&gt;<i>  /*
</I>&gt;<i>  * mono_create_llvm_vcall_trampoline:
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20091202/d74d81c1/attachment-0001.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20091202/d74d81c1/attachment-0001.html</A> 
</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033630.html">[Mono-dev] crashes while	executing	System.Buffer.BlockCopyInternal
</A></li>
	<LI>Next message: <A HREF="033620.html">[Mono-dev] inlining and performance of SIMD code
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33619">[ date ]</a>
              <a href="thread.html#33619">[ thread ]</a>
              <a href="subject.html#33619">[ subject ]</a>
              <a href="author.html#33619">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
