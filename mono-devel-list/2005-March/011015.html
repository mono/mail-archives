<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Embedding Mono in a Virtual World
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Embedding%20Mono%20in%20a%20Virtual%20World&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011020.html">
   <LINK REL="Next"  HREF="011069.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Embedding Mono in a Virtual World</H1>
    <B>Jim Purbrick</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Embedding%20Mono%20in%20a%20Virtual%20World&In-Reply-To="
       TITLE="[Mono-devel-list] Embedding Mono in a Virtual World">jimpurbrick at yahoo.co.uk
       </A><BR>
    <I>Wed Mar 16 13:03:53 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="011020.html">[Mono-devel-list] Pascal compiler
</A></li>
        <LI>Next message: <A HREF="011069.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11015">[ date ]</a>
              <a href="thread.html#11015">[ thread ]</a>
              <a href="subject.html#11015">[ subject ]</a>
              <a href="author.html#11015">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>It's been a while since I posted about this stuff, so
I thought I'd give you an update.

I've now got enough of the script language to CLR
compiler written to compile the script language
versions of the mono logic, fibonaci and loops
benchmarks. The current compiler generates code which
runs at about half the speed of the code generated by
mcs. This is still about 400 times faster than the
current interpreted implementation though, which is
good news.

I've also implemented a simple app which embeds mono
and uses NPTL to test the 1 thread per script approach
to concurrency. I could create NPTL threads with 32K
stacks which would run the logic benchmark and managed
to create 8000 threads which ran concurrently, which
is plenty. I think I may have found a bug while
building this application though: if garbage
collection occurs while a thread is being attached the
GC can abort complaining about an unknown thread.
There is code to avoid this happening when a thread is
created by mono, but not when one is attached.

Although using NPTL gives me the level of concurrency
I need, I still need to be able to transparently stop
running scripts, ship them over to another server and
restart them in order to deal with scripted objects
crossing server boundaries. 

This brings me back to the issue of saving and loading
of stacks, which we established is hard. The 2
possible approaches seem to be to build continuations
on the heap as in PicoThreads or to write C functions
which are called from the CLR code which save and
restore the stack. Any idea how I'd go about
implementing the C function approach? Any idea which
approach is going to be easier?

In the future we'd also like to have more control over
scheduling so that we can allocate different fractions
of script CPU time to different scripts. Once we can
save and load stacks in order to migrate scripts we
might be able to use that mechanism as the basis of
user threading which would give us more control over
script scheduling.

Cheers,

Jim.


--- Paolo Molaro &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>&gt; wrote:
&gt;<i> On 02/11/05 Jim Purbrick wrote:
</I>&gt;<i> &gt; I think this approach generalises to the
</I>&gt;<i> continuation
</I>&gt;<i> &gt; based approach used by PicoThreads in Java[1]: you
</I>&gt;<i> &gt; need to build chains of continuations on the heap
</I>&gt;<i> that
</I>&gt;<i> &gt; you can switch between to switch threads,
</I>&gt;<i> something
</I>&gt;<i> &gt; that Dan Sugalski suggests is really inefficient
</I>&gt;<i> and
</I>&gt;<i> &gt; one of the reasons you might want to use Parrot
</I>&gt;<i> &gt; instead of the JVM or Mono[2].
</I>&gt;<i> 
</I>&gt;<i> Except Parrot is still not suitable to develop any
</I>&gt;<i> of this stuff:-)
</I>&gt;<i> Anyway, as I said it will be slow: with mono 2.0
</I>&gt;<i> heap
</I>&gt;<i> allocations should become much faster, so, depending
</I>&gt;<i> on your timeframe it may not be so bad.
</I>&gt;<i> 
</I>&gt;<i> &gt; Fibers are cooperatively scheduled light weight
</I>&gt;<i> &gt; threads in Win32[3]. The core of the approach
</I>&gt;<i> boils
</I>&gt;<i> &gt; down to:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; schedule()
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; saveCLRLogicalThreadState(currentThreadState);
</I>&gt;<i> &gt; switchOSFiber(nextFiber);
</I>&gt;<i> &gt; restoreCLRLogicalThreadState(nextThreadState);
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Which is used to keep the logical managed thread
</I>&gt;<i> state
</I>&gt;<i> &gt; and fiber in sync. They had some problems with
</I>&gt;<i> &gt; exceptions using this approach and the logical
</I>&gt;<i> thread
</I>&gt;<i> &gt; save and restore methods maybe something that's
</I>&gt;<i> only
</I>&gt;<i> &gt; available in Rotor.
</I>&gt;<i> 
</I>&gt;<i> I don't see us implementing any of the support
</I>&gt;<i> needed for this,
</I>&gt;<i> though of corse we would accept good patches to do
</I>&gt;<i> it.
</I>&gt;<i> Personally, I don't think the complexity it
</I>&gt;<i> introduces is
</I>&gt;<i> worth it for the default mono behaviour (the good
</I>&gt;<i> thing about mono
</I>&gt;<i> is that you could write the support and use your own
</I>&gt;<i> build with
</I>&gt;<i> it enabled to run your app:-).
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; It should be pretty safe if you inject in the
</I>&gt;<i> user
</I>&gt;<i> &gt; code checks for a
</I>&gt;<i> &gt; &gt; global var that signals the event
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Couldn't I just call Thread.Suspend from the main
</I>&gt;<i> &gt; thread after the timeout? 
</I>&gt;<i> 
</I>&gt;<i> Yes, but that coiuld lead to deadlocks, since the
</I>&gt;<i> script might
</I>&gt;<i> hold a lock that another script or your engine needs
</I>&gt;<i> to acquire
</I>&gt;<i> or worse, it may have a lock in the mono runtime.
</I>&gt;<i> We'll be
</I>&gt;<i> putting some protection against the latter issue, in
</I>&gt;<i> the future, but
</I>&gt;<i> until then, it's better to make the script call
</I>&gt;<i> Suspend, because
</I>&gt;<i> you can ensure it's in a safe place wrt your engine
</I>&gt;<i> (and
</I>&gt;<i> calling Suspend from managed code on the current
</I>&gt;<i> thread is safe
</I>&gt;<i> wrt the mono runtime state).
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; The Suspend method is marked obsolete in 2.0,
</I>&gt;<i> &gt; &gt; because of the potential for deadlocks, but
</I>&gt;<i> using it
</I>&gt;<i> &gt; this way should
</I>&gt;<i> &gt; &gt; be safe.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Will I still be able to use this approach with
</I>&gt;<i> future
</I>&gt;<i> &gt; versions of Mono then?
</I>&gt;<i> 
</I>&gt;<i> Obsolete means the call will still work, but you'll
</I>&gt;<i> have
</I>&gt;<i> a warning when compiling (if you use a C# compiler
</I>&gt;<i> or the like).
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt; Since most of the scripts should terminate
</I>&gt;<i> within
</I>&gt;<i> &gt; &gt; the timeout, if I understood correctly, you
</I>&gt;<i> should
</I>&gt;<i> &gt; just have a number
</I>&gt;<i> &gt; &gt; of threads created as many as the slow scripts 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Yes, as all bar one of the threads would be
</I>&gt;<i> suspended
</I>&gt;<i> &gt; that presumably wouldn't cause any context
</I>&gt;<i> switching
</I>&gt;<i> &gt; problems. The only problem would be that each
</I>&gt;<i> &gt; suspended thread would still have a full OS thread
</I>&gt;<i> &gt; stack, so might burn a pile of memory.
</I>&gt;<i> 
</I>&gt;<i> The Mono 2.0 API already implements the calls to
</I>&gt;<i> specify your 
</I>&gt;<i> own thread stack size: the minimum is 128 KB IIRC,
</I>&gt;<i> but this will
</I>&gt;<i> allow you to have 100 'slow' scripts in 13 MBs of
</I>&gt;<i> memory.
</I>&gt;<i> If that's enough for your requirements, this could
</I>&gt;<i> be a good approach.
</I>&gt;<i> 
</I>&gt;<i> lupus
</I>&gt;<i> 
</I>&gt;<i> -- 
</I>&gt;<i>
</I>-----------------------------------------------------------------
&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                    
</I>&gt;<i> debian/rules
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys
</I>&gt;<i> do it better
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i>
</I><A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
&gt;<i> 
</I>
Send instant messages to your online friends <A HREF="http://uk.messenger.yahoo.com">http://uk.messenger.yahoo.com</A> 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011020.html">[Mono-devel-list] Pascal compiler
</A></li>
	<LI>Next message: <A HREF="011069.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11015">[ date ]</a>
              <a href="thread.html#11015">[ thread ]</a>
              <a href="subject.html#11015">[ subject ]</a>
              <a href="author.html#11015">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
