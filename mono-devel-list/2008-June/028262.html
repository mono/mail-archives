<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] asynchronous exceptions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20asynchronous%20exceptions&In-Reply-To=200806181222.46407.bastian.schmitz%40udo.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="028263.html">
   <LINK REL="Next"  HREF="028260.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] asynchronous exceptions</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20asynchronous%20exceptions&In-Reply-To=200806181222.46407.bastian.schmitz%40udo.edu"
       TITLE="[Mono-dev] asynchronous exceptions">jonpryor at vt.edu
       </A><BR>
    <I>Wed Jun 18 10:34:05 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="028263.html">[Mono-dev] asynchronous exceptions
</A></li>
        <LI>Next message: <A HREF="028260.html">[Mono-dev] Mono/Visual Studio Team Suite 2008 Giveaway - Now with	more stuff.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28262">[ date ]</a>
              <a href="thread.html#28262">[ thread ]</a>
              <a href="subject.html#28262">[ subject ]</a>
              <a href="author.html#28262">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Wed, 2008-06-18 at 12:22 +0200, Bastian Schmitz wrote:
&gt;<i> I am planning to have a language element, which ensures that a given condition 
</I>&gt;<i> stays fulfilled during the execution of block of code. If the condition is 
</I>&gt;<i> violated an exception should be risen. The condition is (probably) going to 
</I>&gt;<i> be checked/evaluated by another thread, who should inform the first one in 
</I>&gt;<i> case of violation of the condition.
</I>
&#65279;Would you need the condition to be true throughout the block of code,
or just at the beginning and end of the block of code?

If you just need the beginning and end of the block, there's already a
language construct that you can use (meaning you wouldn't need to extend
the language or runtime in any way): the `using' block, which ensures
that a method (Dispose()) is executed at the end of the specified block:

	using (var f = new FileStream (...)) {
	}
	// f.Dispose() implicitly called here, which for FileStream
	// will close the file.

So if you only need start/end support, you would only need to create a
new class which would perform the check in the constructor and Dispose()
method:

	struct AssertInvariant : IDisposable {
		Func&lt;bool&gt; checker;

		public AssertInvariant (Func&lt;bool&gt; checker)
		{
			this.checker = checker;
			Assert ();
		}

		void Assert ()
		{
			if (!checker())
				Thread.CurrentThread.Abort ();
		}

		public void Dispose ()
		{
			Assert ();
		}
	}

Use:

	int x = 0, y = 1;
	using (new AssertInvariant (() =&gt; x &gt;= 0, y == 1)) {
		// manipulate x &amp; y
	}
	// AssertInvariant.Assert() invoked here.

If a simple begin/end check is in appropriate, and you need it asserted
throughout the block (which would make it difficult to break any
invariants for short periods of time, as may be needed to transfer from
one valid state to another), _then_ you would need a new language
construct + compiler change.  I would be dubious of such a feature,
though.

Even Eiffel, patron saint of Design By Contract-goodness, disables
invariants within the method body, and only checks at method enter and
exit (of public methods).

&gt;<i> This pattern resembles to the asynchronous exception used by the 
</I>&gt;<i> Thread.Abort() method being triggered by an external thread, catching the 
</I>&gt;<i> ThreadAbortException and canceling the abort afterwards.
</I>&gt;<i> I am wondering if there is a safe way to achieve this functionality with the 
</I>&gt;<i> crl/mono runtime.
</I>
That's another problem -- the ThreadAbortException() can only be
canceled (via Thread.ResetAbort()) if Thread.Abort() was called by the
current thread, NOT by another thread.  So if Thread1 aborts Thread2,
then Thread2 cannot abort the Abort.

If you need Thread.ResetAbort() behavior, you need to have
Thread.Abort() called on the aborting thread, as AssertInvariant above
does.

 - Jon


</PRE>























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="028263.html">[Mono-dev] asynchronous exceptions
</A></li>
	<LI>Next message: <A HREF="028260.html">[Mono-dev] Mono/Visual Studio Team Suite 2008 Giveaway - Now with	more stuff.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28262">[ date ]</a>
              <a href="thread.html#28262">[ thread ]</a>
              <a href="subject.html#28262">[ subject ]</a>
              <a href="author.html#28262">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
