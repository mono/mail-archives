<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] mixed-mode assemblies in wine
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20mixed-mode%20assemblies%20in%20wine&In-Reply-To=AANLkTim6apZUZy5xbDvsefUKjPR-ZXMOaO0bDgLnVF%2Bu%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="037054.html">
   <LINK REL="Next"  HREF="037052.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] mixed-mode assemblies in wine</H1>
    <B>Korn&#233;l P&#225;l</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20mixed-mode%20assemblies%20in%20wine&In-Reply-To=AANLkTim6apZUZy5xbDvsefUKjPR-ZXMOaO0bDgLnVF%2Bu%40mail.gmail.com"
       TITLE="[Mono-dev] mixed-mode assemblies in wine">kornelpal at gmail.com
       </A><BR>
    <I>Tue Mar  1 05:11:35 EST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="037054.html">[Mono-dev] Mono-2.8.2 Cross Compiled for ARM processor (Interesting issue with Generics)
</A></li>
        <LI>Next message: <A HREF="037052.html">[Mono-dev] mixed-mode assemblies in wine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37051">[ date ]</a>
              <a href="thread.html#37051">[ thread ]</a>
              <a href="subject.html#37051">[ subject ]</a>
              <a href="author.html#37051">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

Vincent Povirk wrote:
&gt;&gt;<i> My preferred way would be to call exports that Windows calls:
</I>&gt;&gt;<i> - _CorValidateImage on image load
</I>&gt;&gt;<i> - _CorImageUnloading on image unload
</I>&gt;&gt;<i> - _CorExeMain instead of exe entry point
</I>&gt;&gt;<i> - _CorDllMain instaad of dll entry
</I>&gt;<i>
</I>&gt;<i> Is there a reason for us to add this to the Wine loader soon? I've
</I>&gt;<i> been putting it off because I have to ask for someone else to do it.
</I>
WIndows 2000 does not call any of these and .NET Framework still works, 
so Wine will work as well. The whole idea behind this is to increase 
security when using IL-only assemblies. The assemblies are loaded but no 
native code (not even entry points, TLS initialization) is executed 
neither is the IAT resolved.

_CorValidateImage becomes necessary once you want to load PE32 IL-only 
images into a 64-bit process. CorValidateImage will convert the PE32 
image to PE32+ in memory that is possible (see implementation) and required.

CorValidateImage also removes entry point of PE32+ IL-only dlls since 
IAT was not resolved. This is not required if the loader is not treating 
IL-only dlls specially.

In my opinion these callbacks are quite easy to implement. One unusual 
thing I noticed is that suspended process and CreateRemoteThread dll 
injection is not working for managed processes (maybe just IL-only) 
because _CorExeMain is called by the loader initialization code rather 
than process initialization code so it will be called on the new thread 
instead of thread entry point.

&gt;&gt;<i> I also planned to get rid of MonoFixupExe  and drop support for mixed-mode
</I>&gt;&gt;<i> assemblies by using mono.exe and introduce a loader that would call
</I>&gt;&gt;<i> CreateProcess on the managed (may be mixed-mode) .exe, inject a loader .dll
</I>&gt;&gt;<i> (or a custom mscoree.dll) by modifying IAT, remove IL-only flag so that the
</I>&gt;&gt;<i> OS loader will not load MS.NET mscorlib.dll, and do inicialization in that
</I>&gt;&gt;<i> loader .dll called by OS loader. This would not affect functionality of
</I>&gt;&gt;<i> mono.dll just would not fixup mscoree.dll by default that also would play
</I>&gt;&gt;<i> more nicely with standalone verifier, dumper, etc. tools and CoreCLR.
</I>&gt;<i>
</I>&gt;<i> That's interesting.
</I>&gt;<i>
</I>&gt;<i> It would seem (to me) that in this case your mscoree.dll and ours can
</I>&gt;<i> and should be the same one. The only difference is how libmono is
</I>&gt;<i> found and loaded.
</I>
.NET Framework has a single shared mscoree.dll in system32 that selects 
and loads the appropriate runtime (mscorwks.dll or mscorsvr.dll for .NET 
Framework 2.0). Each new runtime usually updates mscoree.dll but remains 
backwards compatible. Most exports of mscoree.dll are most likely simply 
forwarded to the loaded runtime.

When experimenting with the above approach I have used my own 
mscoree.dll and loaded Mono and worked fine but this is not the way to 
go on Windows, that's why I have plans to create a loader that would do 
the hooking. The same loader would work on Wine but you will not need it 
as Mono will be your native .NET implementation.

&gt;&gt;<i> I also have the impression that implementing .NET Framework functionality in
</I>&gt;&gt;<i> Wine may not be the right architecture. Ideally those belong to Mono. Since
</I>&gt;&gt;<i> I know that Mono does not accept GPL to runtime (requires MIT X11 license or
</I>&gt;&gt;<i> special permissions to Novell; althoug is licensed under GPL) and Wine
</I>&gt;&gt;<i> prefers GPL this may not be suitable.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Wine loader should call mscoree.dll just like Windows loader does
</I>&gt;&gt;<i> (system32\mscoree.dll is hardcoded, cannot use your own).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> If you prefer to keep mscoree.dll code in Wine, then I belive that Wine
</I>&gt;&gt;<i> mscoree.dll should load mono.dll (as it already does) and forward the above
</I>&gt;&gt;<i> five basic exports to mono.dll and implement other exports on its own by
</I>&gt;&gt;<i> calling native Mono API.
</I>&gt;<i>
</I>&gt;<i> My only strong reason for wanting mscoree.dll to be in Wine is so that
</I>&gt;<i> it can load without any Mono present (which is enough to install many
</I>&gt;<i> apps, and pass tests), and so that it can select between multiple
</I>&gt;<i> available Mono setups at runtime (in order to cover .NET versions 1.1,
</I>&gt;<i> 2.0, and 4.0 simultaneously). For that to work, we need a dll that
</I>&gt;<i> loads Mono dynamically rather than linking to it, and it needs to
</I>&gt;<i> support both embedding ABI's.
</I>
mscoree.dll itself is just a loader and forwarder that can and should 
remain in Wine. (Sorry about not being specific previously.)

I however belive that the actual API implementation should be part of 
Mono because that could be used on Windows as well.

&gt;<i> Licensing is not an issue. Wine is LGPL, and we can use MIT code. The
</I>&gt;<i> reverse isn't true, but I think it would be possible to relicense most
</I>&gt;<i> of Wine's current mscoree code as MIT, since most of that architecture
</I>&gt;<i> was written by me for CodeWeavers.
</I>&gt;<i>
</I>&gt;<i> Still, if you want to work on the .NET embedding API, I think we
</I>&gt;<i> should find a way to collaborate, in whichever project.
</I>
coree.c of Mono was written by me and is already MIT licensed. Mono 
runtime is available under LGPL (I previously have mistaken it for GPL).
As a Mono contributor I may be biased but I belive that the best way to 
collaborate would be to have native .NET embedding API code in Mono 
runtime licensed under MIT X11 (should be discussed with Miguel but I 
think this could work). It could be used on Windows as well and Wine was 
not affected by Mono embedding API changes since it only had to support 
the .NET embedding API and be able to find mono.dll.

&gt;<i> Another possible approach, if we don't share mscoree.dll code, would
</I>&gt;<i> be for Wine and Mono to both implement ICLRMetaHost
</I>&gt;<i> (<A HREF="http://msdn.microsoft.com/en-us/library/dd233134.aspx">http://msdn.microsoft.com/en-us/library/dd233134.aspx</A>) and
</I>&gt;<i> ICLRRuntimeInfo, both of which can be accessed before a runtime is
</I>&gt;<i> chosen and loaded, and for only Mono to implement ICLRRuntimeHost,
</I>&gt;<i> which requires a loaded runtime. Wine's mscoree.dll's other functions
</I>&gt;<i> (except for the _Cor functions which will have to be special) could
</I>&gt;<i> then work based on those interfaces.
</I>
This could work but if we keep the embedding API implementation MIT 
licensed, then any other project can reuse it and customize to its needs 
if needed.

Korn&#233;l
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="037054.html">[Mono-dev] Mono-2.8.2 Cross Compiled for ARM processor (Interesting issue with Generics)
</A></li>
	<LI>Next message: <A HREF="037052.html">[Mono-dev] mixed-mode assemblies in wine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37051">[ date ]</a>
              <a href="thread.html#37051">[ thread ]</a>
              <a href="subject.html#37051">[ subject ]</a>
              <a href="author.html#37051">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
