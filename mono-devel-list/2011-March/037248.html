<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Faster
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Faster&In-Reply-To=AANLkTimR6EkNg8VfqfUYPY1vCRxA3VoYaGB3Ti6pQgF2%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="037247.html">
   <LINK REL="Next"  HREF="037263.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Faster</H1>
    <B>Elijah Taylor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Faster&In-Reply-To=AANLkTimR6EkNg8VfqfUYPY1vCRxA3VoYaGB3Ti6pQgF2%40mail.gmail.com"
       TITLE="[Mono-dev] Faster">elijahtaylor at google.com
       </A><BR>
    <I>Thu Mar 24 14:13:48 EDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="037247.html">[Mono-dev] Faster
</A></li>
        <LI>Next message: <A HREF="037263.html">[Mono-dev] Faster
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37248">[ date ]</a>
              <a href="thread.html#37248">[ thread ]</a>
              <a href="subject.html#37248">[ subject ]</a>
              <a href="author.html#37248">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>If it's worth anything, changing null checks to NREs would also severely
cripple Native Client support in Mono.  NREs rely on hardware signals if I'm
not mistaken, and we don't support that currently (and probably not for a
long time if ever) in NaCl.  We've actually had to rewrite bits of
application code that relied on this behavior instead of explicit null
checks.


On Thu, Mar 24, 2011 at 9:51 AM, Rodrigo Kumpera &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">kumpera at gmail.com</A>&gt; wrote:

&gt;<i> Mono uses zero cost exception handling, so setting up a try-catch handler
</I>&gt;<i> has zero cost.
</I>&gt;<i>
</I>&gt;<i> That's the theory, but using try-catch blocks have a few undesirable
</I>&gt;<i> implications to control-flow.
</I>&gt;<i> The problem are variables that are used in the catch block, for example:
</I>&gt;<i>
</I>&gt;<i> int x;
</I>&gt;<i> try {
</I>&gt;<i>   x = 1;
</I>&gt;<i>   MayThrow ();
</I>&gt;<i>   x = 2;
</I>&gt;<i>   MayThrow ();
</I>&gt;<i>   x = 3;
</I>&gt;<i> } catch (Exception) {
</I>&gt;<i>   Console.WriteLine (x);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> On the above code, when we reach the catch block, we can't statically know
</I>&gt;<i> which assignment was the last to execute, so we have
</I>&gt;<i> to make sure they all use the same storage - which is a very hard problem
</I>&gt;<i> to solve.
</I>&gt;<i>
</I>&gt;<i> Mono's current JIT takes the easy solution which is to mark all those
</I>&gt;<i> variables as volatile, which has the unfortunate effect of producing
</I>&gt;<i> code outside the catch block that is quite worse than otherwise. So, EH has
</I>&gt;<i> a very low overhead, but should not be used for those cases.
</I>&gt;<i>
</I>&gt;<i> Now onto the null check. Such a null check will exploit a cpu feature known
</I>&gt;<i> as branch prediction, which guesses the outcome of the
</I>&gt;<i> conditional jump. Since in the majority of the cases the value won't be
</I>&gt;<i> null, the cpu can pretend the branch doesn't exist and keep executing
</I>&gt;<i> as it was not taken. This means the null check costs virtually nothing on a
</I>&gt;<i> modern cpu.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Thu, Mar 24, 2011 at 5:32 PM, Mikael Lyngvig &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mikael at lyngvig.org</A>&gt;wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not an expert on the JIT compiler and such, but I do know that in
</I>&gt;&gt;<i> virtually all programming languages that support exception handling, the
</I>&gt;&gt;<i> cost of a null-check is infinitesimal compared to the cost of setting up
</I>&gt;&gt;<i> an exception handler.  On many systems, setting up a try-catch handler
</I>&gt;&gt;<i> costs something like 200 instructions whereas the null check only costs
</I>&gt;&gt;<i> one or two instructions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Cheers,
</I>&gt;&gt;<i> Mikael
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Den 24-03-2011 17:06, Steve Bjorg skrev:
</I>&gt;&gt;<i> &gt; Is the cost of the if-null check greater than setting up an exception
</I>&gt;&gt;<i> catch handler?
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; - Steve
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; ---------------------------------
</I>&gt;&gt;<i> &gt; Steve G. Bjorg
</I>&gt;&gt;<i> &gt; MindTouch
</I>&gt;&gt;<i> &gt; San Diego, CA
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; 619.795.8459 office
</I>&gt;&gt;<i> &gt; 425.891.5913 mobile
</I>&gt;&gt;<i> &gt; <A HREF="http://twitter.com/bjorg">http://twitter.com/bjorg</A>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; On Mar 24, 2011, at 9:00 AM, Miguel de Icaza wrote:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;&gt; Hello guys,
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Today in the shower I had an idea that I believe we could use to
</I>&gt;&gt;<i> &gt;&gt; improve the performance of our class library code.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Plenty of our class library code has code like this:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; void Foo (Something x)
</I>&gt;&gt;<i> &gt;&gt; {
</I>&gt;&gt;<i> &gt;&gt;     if (x == null)
</I>&gt;&gt;<i> &gt;&gt;         throw new ArgumentNullException (&quot;x&quot;);
</I>&gt;&gt;<i> &gt;&gt;     x.DoSomething ();
</I>&gt;&gt;<i> &gt;&gt;     x.AndThenMore ();
</I>&gt;&gt;<i> &gt;&gt; }
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Arguably, if this could be inlined, and the JIT could prove that x is
</I>&gt;&gt;<i> &gt;&gt; not null, we would skip the first test, for example:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Foo (new Something ());
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; But this is the exception, in general, the JIT would not be able to
</I>&gt;&gt;<i> &gt;&gt; know this kind of information for even trivial uses like:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Foo (Bar.GetSomething ());
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Rendering the optimization not very effective.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; But what if we changed our code in Foo across our class libraries to
</I>&gt;&gt;<i> &gt;&gt; do this instead:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; void Foo (Something x)
</I>&gt;&gt;<i> &gt;&gt; {
</I>&gt;&gt;<i> &gt;&gt;     try {
</I>&gt;&gt;<i> &gt;&gt;         x.DoSomething ();
</I>&gt;&gt;<i> &gt;&gt;     } catch (NullReferenceException e){
</I>&gt;&gt;<i> &gt;&gt;         if (x == null)
</I>&gt;&gt;<i> &gt;&gt;              throw new ArgumentNullException (&quot;x&quot;);
</I>&gt;&gt;<i> &gt;&gt;         else
</I>&gt;&gt;<i> &gt;&gt;               throw;
</I>&gt;&gt;<i> &gt;&gt;     }
</I>&gt;&gt;<i> &gt;&gt;     x.AndThenMore ();
</I>&gt;&gt;<i> &gt;&gt; }
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; This has the advantage that the test for the value of &quot;x&quot; being null
</I>&gt;&gt;<i> &gt;&gt; is delayed until we actually need it.    The downside of course is
</I>&gt;&gt;<i> &gt;&gt; that DoSomething could actually take other forms and might end up
</I>&gt;&gt;<i> &gt;&gt; running code that we do not need before it touches x, for example,
</I>&gt;&gt;<i> &gt;&gt; this would be a problem:
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; // We should never add null values.
</I>&gt;&gt;<i> &gt;&gt; void AddToCache (Something x)
</I>&gt;&gt;<i> &gt;&gt; {
</I>&gt;&gt;<i> &gt;&gt;     cache.Add (x);
</I>&gt;&gt;<i> &gt;&gt; }
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; void Foo (Something x)
</I>&gt;&gt;<i> &gt;&gt; {
</I>&gt;&gt;<i> &gt;&gt;       if (x == null)
</I>&gt;&gt;<i> &gt;&gt;           throw new ArgumentNullException (&quot;x&quot;);
</I>&gt;&gt;<i> &gt;&gt;       AddToCache (x);
</I>&gt;&gt;<i> &gt;&gt; }
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; If we rewrite the above code, we would end up with a bug like the one
</I>&gt;&gt;<i> &gt;&gt; I described.
</I>&gt;&gt;<i> &gt;&gt;
</I>&gt;&gt;<i> &gt;&gt; Miguel
</I>&gt;&gt;<i> &gt;&gt; _______________________________________________
</I>&gt;&gt;<i> &gt;&gt; Mono-devel-list mailing list
</I>&gt;&gt;<i> &gt;&gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> &gt;&gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;<i> &gt; _______________________________________________
</I>&gt;&gt;<i> &gt; Mono-devel-list mailing list
</I>&gt;&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20110324/76aee697/attachment-0001.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20110324/76aee697/attachment-0001.html</A> 
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="037247.html">[Mono-dev] Faster
</A></li>
	<LI>Next message: <A HREF="037263.html">[Mono-dev] Faster
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37248">[ date ]</a>
              <a href="thread.html#37248">[ thread ]</a>
              <a href="subject.html#37248">[ subject ]</a>
              <a href="author.html#37248">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
