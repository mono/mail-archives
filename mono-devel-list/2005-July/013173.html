<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] mono AES performance woes (was: poor PPC JIT	output)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20mono%20AES%20performance%20woes%20%28was%3A%20poor%20PPC%20JIT%0A%09output%29&In-Reply-To=20050715103936.GK9882%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013167.html">
   <LINK REL="Next"  HREF="013202.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] mono AES performance woes (was: poor PPC JIT	output)</H1>
    <B>Allan Hsu</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20mono%20AES%20performance%20woes%20%28was%3A%20poor%20PPC%20JIT%0A%09output%29&In-Reply-To=20050715103936.GK9882%40debian.org"
       TITLE="[Mono-devel-list] mono AES performance woes (was: poor PPC JIT	output)">allan at counterpop.net
       </A><BR>
    <I>Fri Jul 15 20:42:11 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="013167.html">[Mono-devel-list] poor PPC JIT output
</A></li>
        <LI>Next message: <A HREF="013202.html">[Mono-devel-list] mono AES performance woes (was: poor PPC JIT	output)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13173">[ date ]</a>
              <a href="thread.html#13173">[ thread ]</a>
              <a href="subject.html#13173">[ subject ]</a>
              <a href="author.html#13173">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Jul 15, 2005, at 3:39 AM, Paolo Molaro wrote:

&gt;<i> On 07/14/05 Allan Hsu wrote:
</I>&gt;<i>
</I>&gt;&gt;<i> Code generated by the PPC code emitter performs very poorly in
</I>&gt;&gt;<i> comparison to the same code emitted for other platforms (most
</I>&gt;&gt;<i> notably, x86). I had a brief conversation about this with Miguel in
</I>&gt;&gt;<i> #mono today and he suggested that I post some examples.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I'm sure he meant an actual test case, which you didn't provide.
</I>
I apologize for that. I was sharing the information I had already  
gathered as part of an investigation into the poor performance of the  
OS X port of our product. I was not sure if this sort of data was  
useful or if, as seems the case, I was doing something wrong. It  
looks like the performance problems I was running into are not  
specific to PPC, but the lack of JIT optimization (which I've  
remedied) made them *very* apparent.

&gt;&gt;<i> Preliminary profiling with Shark (a profiling tool that is part of
</I>&gt;&gt;<i> the Apple CHUD tools) shows some heinously inefficient JIT output on
</I>&gt;&gt;<i> both G4 and G5 machines. Here's some sample Shark analysis on the
</I>&gt;&gt;<i> code emitted by mono 1.1.8.1 from
</I>&gt;&gt;<i> System.Security.Cryptography.RijndaelTransform.ECB(byte[], byte[])
</I>&gt;&gt;<i> and System.Security.Cryptography.RijndaelTransform.ShiftRow(bool):
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> <A HREF="http://strangecargo.org/~allan/mono/">http://strangecargo.org/~allan/mono/</A>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It looks like optimizations are not enabled: are you embedding mono
</I>&gt;<i> in your app?
</I>&gt;<i> You should try adding:
</I>&gt;<i>     mono_set_defaults (0, mono_parse_default_optimizations (NULL));
</I>&gt;<i> before the call to mono_jit_init ().
</I>
I am indeed using embedded mono, and I was not at all aware that  
optimizations were disabled by default. This does not occur in any of  
the sample code that I've seen and this is the first I've heard of it.

Is there any reference on what sorts of things you can change using  
mono_set_defaults? Following the mono source for references to that  
function wasn't particularly enlightening. It would be useful if the  
Wiki page on embedding mono mentioned JIT optimization.

I have done some more isolated testing of AES performance after  
turning on optimization and it seems that the JIT-emitted PPC code is  
roughly on par with x86 mono performance. Here is the code I used for  
some simple benchmarking:

<A HREF="http://strangecargo.org/~allan/mono/aes.tar.bz2">http://strangecargo.org/~allan/mono/aes.tar.bz2</A>

Here's some times for 1000 encrypts/decrypts of 32768 byte chunks  
from some machines we have here in the office, ordered by speed:
57.7 seconds under mono 1.1.8.1, OS X 10.4.2 (1.67 Ghz G4 1.2)
55.0 seconds under mono 1.1.8.1, Linux 2.6.9 (1.8 Ghz Athlon XP 2500+)
45.8 seconds under mono 1.1.8.1, Linux 2.6.9 (2.2 Ghz Athlon 64 3200+)
42.4 seconds under mono 1.1.8.1, OS X 10.4.2 (2.0 Ghz G5 3.0)
9.01 seconds under Microsoft .NET 1.1.4322, Windows XP Pro SP2 (2.0  
Ghz Athlon 64 3200+)

If you look at the benchmark code, it uses RijndaelManaged to do  
encrypt/decrypt. This class is supposedly 100% managed code in the  
Microsoft implementation.

Included in the tarball is some native code that links against  
OpenSSL to do the same thing. This is what native performance for the  
same sized chunks looks like:

1.67 seconds under OpenSSL 0.9.7a, Linux 2.6.9 (1.8 Ghz Athlon XP 2500+)
1.44 seconds under OpenSSL 0.9.7, OS X 10.4.2 (1.67 Ghz G4 1.2)
1.05 seconds under OpenSSL 0.9.7, OS X 10.4.2 (2.0 Ghz G5 3.0)
.67 seconds under OpenSSL 0.9.7a, Linux 2.6.9 (2.2 Ghz Athlon 64 3200+)

To be fair, the native implementation is able to take advantage of 64- 
bit processors when available, while all mono builds in the above  
benchmarks are 32-bit. The Windows XP machine is the standard 32-bit  
install, even though the processor is 64-bit. This is a pretty  
informal benchmark, but all I'm interested in showing here is how bad  
the AES performance under mono is.

It was suggested in #mono that I try compiling the mono AES  
implementation under VS.NET and run it under the Microsoft VM to  
compare performance..
The resulting project is available here:
<A HREF="http://strangecargo.org/~allan/mono/AESSpeedTest.zip">http://strangecargo.org/~allan/mono/AESSpeedTest.zip</A>

The same operation benchmarks thusly:
22.76 seconds under Microsoft .NET 1.1.4322, Windows XP Pro SP2 (2.0  
Ghz Athlon 64 3200+)

The AES code is taken from mono svn, so it may be different from the  
code used in the mono 1.1.8.1 benchmarks above.

While switching to the Microsoft VM boosts speed significantly, it  
looks like significant gains could be made by optimizing the mono  
RijndaelManaged code.

(some insightful comment would go here if I weren't so tired of  
writing this email).

-Allan

&lt;everything below doesn't matter so much, since it was based on  
information gathered from unoptimized JIT output&gt;
&gt;&gt;<i> Information on how to read Shark analysis comes with Shark (available
</I>&gt;&gt;<i> for free from the Apple Developer Connection website).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> A direct pointer to the doc would be useful.
</I>
Unfortunately, I can't find a copy of the documentation that's  
available online (otherwise, I would have linked it). The closest  
thing I can find to online documentation is this document: http:// 
developer.apple.com/tools/sharkoptimize.html

&gt;&gt;<i> (A summary:
</I>&gt;&gt;<i> numerous and frequent pipeline stalls, unoptimized loops).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Some of the data looks definitely bogus: it reports a stall even on
</I>&gt;<i> the addi, here:
</I>&gt;<i>
</I>&gt;<i>     0x2e143c8 lwz      r4,32(r1)    3:1 Stall=2
</I>&gt;<i>     0x2e143cc lwz      r5,12(r4)    3:1 Stall=2
</I>&gt;<i>     0x2e143d0 cmplwi   r5,0x0000     3:1 Stall=2
</I>&gt;<i>     0x2e143d4 blel     $+696 &lt;0x2e1468c [8B]&gt;    2:1
</I>&gt;<i> 0.4%    0x2e143d8 addi     r4,r4,16     2:1 Stall=1
</I>&gt;<i>
</I>&gt;<i> How can it stall while adding an immediate value to a register
</I>&gt;<i> that was loaded several instructions before? Anyway, maybe the  
</I>&gt;<i> documentation
</I>&gt;<i> for the output format will shed some light, once provided.
</I>&gt;<i> As for the loop commentary: did you actually test how much you
</I>&gt;<i> gain by aligning loop starts on 32 byte boundaries? It would be
</I>&gt;<i> a huge waste of memory in most cases.
</I>
I was not implying that all of the Shark suggestions were useful. I  
was simply summarizing the bulk of the suggestions. There other sorts  
of optimizations that Shark often suggests that are absent from the  
analysis of JIT code. I agree that loop alignment is probably  
wasteful in the majority of cases.

As for the stall statistics, you have misread them. Each line that  
says &quot;Stall=N&quot; is saying that the instruction latency of the marked  
instruction will cause a subsequent dependent instruction to stall,  
not that the marked instruction itself will stall. N is the maximum  
number of stall cycles for the nearest dependent instruction. The  
documentation claims that the register analysis algorithm they use is  
&quot;very conservative&quot; and the actual stall cycles observed may be higher.

     -Allan
--
Allan Hsu &lt;allan at counterpop dot net&gt;
1E64 E20F 34D9 CBA7 1300  1457 AC37 CBBB 0E92 C779


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013167.html">[Mono-devel-list] poor PPC JIT output
</A></li>
	<LI>Next message: <A HREF="013202.html">[Mono-devel-list] mono AES performance woes (was: poor PPC JIT	output)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13173">[ date ]</a>
              <a href="thread.html#13173">[ thread ]</a>
              <a href="subject.html#13173">[ subject ]</a>
              <a href="author.html#13173">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
