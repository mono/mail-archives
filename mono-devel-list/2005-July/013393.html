<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] COM Interop
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20COM%20Interop&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013452.html">
   <LINK REL="Next"  HREF="013397.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] COM Interop</H1>
    <B>Jonathan S. Chambers</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20COM%20Interop&In-Reply-To="
       TITLE="[Mono-devel-list] COM Interop">Jonathan.Chambers at ansys.com
       </A><BR>
    <I>Mon Jul 25 14:05:30 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="013452.html">[Mono-devel-list] COM Interop
</A></li>
        <LI>Next message: <A HREF="013397.html">[Mono-devel-list] Building mono-tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13393">[ date ]</a>
              <a href="thread.html#13393">[ thread ]</a>
              <a href="subject.html#13393">[ subject ]</a>
              <a href="author.html#13393">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Sorry for the misquote.

-----Original Message-----
From: Korn&#233;l P&#225;l [mailto:<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">kornelpal at hotmail.com</A>] 
Sent: Monday, July 25, 2005 2:00 PM
To: Rafael Teixeira; Jonathan S. Chambers
Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
Subject: Re: [Mono-devel-list] COM Interop

Hi,

&gt;&gt;<i> 2. As MS has a base COM object wrapper (__ComObject), I was planning a
</I>&gt;&gt;<i> similar one for mono. This wrapper would hold onto the unmanaged object
</I>&gt;&gt;<i> pointer and provide additional functionality as required. Does this
</I>&gt;&gt;<i> sound ok?
</I>&gt;<i>
</I>&gt;<i>Yes, but you'll need a lot more baggage than this class. Issues with
</I>&gt;<i>threading-models and GC x ReferenceCounting clutter this space and are
</I>&gt;<i>mapped in this API surface.
</I>
COM interop has to be implemented in the runtime because of AppDomain
independent CCWs and because a lot of wrapper code that has to be generated
by the runtime. Furthermore Import libraries generated by tlbimp.exe or
created by user code using the same techniques are empty methods that are
handled by the runtime.

&gt;&gt;<i> 3. I assume some sort of reference counting will take place. For
</I>&gt;&gt;<i> simplicity, I was planning on AddRef'ing/Release'ing at every
</I>&gt;&gt;<i> interaction. This is different that the MS implementation, I believe.
</I>&gt;&gt;<i> For example, (again, I believe) MS keeps track of the IUnknown pointer
</I>&gt;&gt;<i> and addref's only once upon entry into the managed runtime. Each
</I>&gt;&gt;<i> unmanaged component then seems to be wrapped by only one managed
</I>&gt;&gt;<i> wrapper.
</I>&gt;<i>
</I>&gt;<i>The problem is you can't Release freely as it may kill the object
</I>&gt;<i>prematurely. I'm not sure but I think the Disposable pattern is used
</I>&gt;<i>to control the lifetime of wrapped COM objects a bit better but some
</I>&gt;<i>exceptions to the rule may appear.
</I>
I don't see any problem around MS implementation regarding reference
counting so we should use the same rules.

Everytime you create a new RCW instance it will maintain its own reference
to the IUnknown (or derived) interface. It is not disposable and the
IUnknown interface will be released when it is collected by GC.
Marshal.ReleaseComObject was created to address this problem and this is the
recommended solution by Microsoft.

CCWs maintain a reference to the wrapped managed object. CCW will be
destroyed only when its IUnknown reference cound reaches zero. If the
managed object was destroyed because it's AppDomain was unloaded CCW still
will return MSEE_E_APPDOMAINUNLOADED (AppDomainUnloadedException) until it
is released.

&gt;&gt;<i> 4. I assume each unmanaged interfaces will have a corresponding managed
</I>&gt;&gt;<i> interface defined and tagged with appropriate attributes. The
</I>&gt;&gt;<i> GuidAttribute would work for COM/XPCOM, but Bonobo takes a string for
</I>&gt;&gt;<i> its QueryInterface.
</I>&gt;<i>
</I>&gt;<i>Well that is what I said about Bonobo not fitting in. Let's look at
</I>&gt;<i>the problem from the developer that will be using it perspective.
</I>
I think COM interoc should be implemented using XPCOM because altough Bonobo
is for the same putpose as COM and XPCOM its characteristics are far away
from COM and thus existing COM interop infrastructure cannot cope with
Bonobo. (I mean the managed interfaces of COM interop: Marshal, Guid, ...)

&gt;&gt;<i> (Kornel mentioned having additional namespaces under
</I>&gt;&gt;<i> System.Runtime.InteropServices, such as
</I>&gt;&gt;<i> System.Runtime.InteropServices.Bonobo).
</I>&gt;<i>
</I>&gt;<i>No way. Adding subnamespaces in the ECMA/MS namespaces isn't allowed.
</I>&gt;<i>We can have a Mono.Runtime.InteropServices.Bonobo or a shorter and
</I>&gt;<i>appropriate Bonobo namespace.
</I>
It was actually &quot;Mono.Runtime.InteropServices.Bonobo&quot; that I mentioned for
the same reason as Rafael.

Korn&#233;l

----- Original Message -----
From: &quot;Rafael Teixeira&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">monoman at gmail.com</A>&gt;
To: &quot;Jonathan S. Chambers&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Jonathan.Chambers at ansys.com</A>&gt;
Cc: &quot;mono-devel&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>&gt;
Sent: Monday, July 25, 2005 7:29 PM
Subject: Re: [Mono-devel-list] COM Interop


On 7/25/05, Jonathan S. Chambers &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Jonathan.Chambers at ansys.com</A>&gt; wrote:
&gt;<i>         I am interested in implementing some support for COM Interop for
</I>&gt;<i> the mono runtime. A goal is that the mono version of COM Interop could
</I>&gt;<i> support various component models (COM, XPCOM, and Bonobo have been
</I>&gt;<i> proposed); whether more than one can be supported at one time is another
</I>&gt;<i> decision that someone will need to make.
</I>
I would hope that not to happen, as COM is just more trouble than it
is worth. I prefer to rewrite any COM component as something fully
managed, but yes there are cases (like using OLE Automation to control
omnipresent apps) that we may have to concede. But I personally would
not space for COM to breath.

Alas, you are in the group that may have invested so much on COM, or
depend on OLE Automation or Third-Party ActiveX Components so let's
see what I can help than further discuss the merit of the proposition.

&gt;<i>         Component model specific code will not be part of the mono
</I>&gt;<i> runtime, but part of an external library loaded at runtime (as
</I>&gt;<i> requested).
</I>
Very good decision. I just don't think Bonobo will fit in nicely as it
is very different from the other two, and from the COM-Interop
premises embedded in .NET.

&gt;<i> A few questions
</I>&gt;<i>
</I>&gt;<i> 1. Would the mono runtime be aware of common functionality that exists
</I>&gt;<i> in all (currently proposed) component models; essentially the
</I>&gt;<i> functionality of the Unknown interface (reference counting and interface
</I>&gt;<i> querying)?
</I>
I fear you'll have to do that: Just to mimic correctly all the
COM-specific things that the Base Class Library has.

&gt;<i> 2. As MS has a base COM object wrapper (__ComObject), I was planning a
</I>&gt;<i> similar one for mono. This wrapper would hold onto the unmanaged object
</I>&gt;<i> pointer and provide additional functionality as required. Does this
</I>&gt;<i> sound ok?
</I>
Yes, but you'll need a lot more baggage than this class. Issues with
threading-models and GC x ReferenceCounting clutter this space and are
mapped in this API surface.

&gt;<i> 3. I assume some sort of reference counting will take place. For
</I>&gt;<i> simplicity, I was planning on AddRef'ing/Release'ing at every
</I>&gt;<i> interaction. This is different that the MS implementation, I believe.
</I>&gt;<i> For example, (again, I believe) MS keeps track of the IUnknown pointer
</I>&gt;<i> and addref's only once upon entry into the managed runtime. Each
</I>&gt;<i> unmanaged component then seems to be wrapped by only one managed
</I>&gt;<i> wrapper.
</I>
The problem is you can't Release freely as it may kill the object
prematurely. I'm not sure but I think the Disposable pattern is used
to control the lifetime of wrapped COM objects a bit better but some
exceptions to the rule may appear.

&gt;<i> 4. I assume each unmanaged interfaces will have a corresponding managed
</I>&gt;<i> interface defined and tagged with appropriate attributes. The
</I>&gt;<i> GuidAttribute would work for COM/XPCOM, but Bonobo takes a string for
</I>&gt;<i> its QueryInterface.
</I>
Well that is what I said about Bonobo not fitting in. Let's look at
the problem from the developer that will be using it perspective.

Bonobo components are normally totally diverse from similar COM
components, it is hard to imagine having an interface-for-interface
match that would allow you to write a single hosting code to  accept a
COM component and an equivalent Bonobo component. That's is easier
between COM /XPCOM as that was way XPCOM was written in the first
place.

So If I want to write apps that use Bonobo components the most I would
expect is to be able to reuse &quot;concepts&quot;, and similarly named classes,
but little mor than that.

So probably a BonoboObject (double-underscores aren't really needed in
this case) should be built as a counterpart to the __ComObject that
may be able to deal with COM and XPCOM.

&gt;<i> (Kornel mentioned having additional namespaces under
</I>&gt;<i> System.Runtime.InteropServices, such as
</I>&gt;<i> System.Runtime.InteropServices.Bonobo).
</I>
No way. Adding subnamespaces in the ECMA/MS namespaces isn't allowed.
We can have a Mono.Runtime.InteropServices.Bonobo or a shorter and
appropriate Bonobo namespace.

&gt;<i> Thanks,
</I>&gt;<i> Jonathan
</I>&gt;<i>
</I>
Good luck,

--
Rafael &quot;Monoman&quot; Teixeira
---------------------------------------
I'm trying to become a &quot;Rosh Gadol&quot; before my own eyes.
See <A HREF="http://www.joelonsoftware.com/items/2004/12/06.html">http://www.joelonsoftware.com/items/2004/12/06.html</A> for enlightment.
It hurts!




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013452.html">[Mono-devel-list] COM Interop
</A></li>
	<LI>Next message: <A HREF="013397.html">[Mono-devel-list] Building mono-tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13393">[ date ]</a>
              <a href="thread.html#13393">[ thread ]</a>
              <a href="subject.html#13393">[ subject ]</a>
              <a href="author.html#13393">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
