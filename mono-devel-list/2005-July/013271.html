<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] The first (attempt to checkin) managed	collation	patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20The%20first%20%28attempt%20to%20checkin%29%20managed%09collation%0A%09patch&In-Reply-To=1121897102.4162.33.camel%40omega.boston.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013267.html">
   <LINK REL="Next"  HREF="013301.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] The first (attempt to checkin) managed	collation	patch</H1>
    <B>Atsushi Eno</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20The%20first%20%28attempt%20to%20checkin%29%20managed%09collation%0A%09patch&In-Reply-To=1121897102.4162.33.camel%40omega.boston.ximian.com"
       TITLE="[Mono-devel-list] The first (attempt to checkin) managed	collation	patch">atsushi at ximian.com
       </A><BR>
    <I>Wed Jul 20 22:02:30 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="013267.html">[Mono-devel-list] The first (attempt to checkin) managedcollation	patch
</A></li>
        <LI>Next message: <A HREF="013301.html">[Mono-devel-list] The first (attempt to checkin)	managed	collation patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13271">[ date ]</a>
              <a href="thread.html#13271">[ thread ]</a>
              <a href="subject.html#13271">[ subject ]</a>
              <a href="author.html#13271">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hola Opti-Ben,

Ben Maurer wrote:
&gt;<i> Some messages from your neighborhood optimizer :-).
</I>
Thanks ;-)

&gt;<i> Some things I noticed while viewing the files in a hex editor:
</I>&gt;<i> 
</I>&gt;<i>       * There are extremely long runs of the same char in many instances
</I>&gt;<i>       * The file seems to have tons of 0 bytes.
</I>&gt;<i>       * There are some runs of sequences:
</I>&gt;<i> 
</I>&gt;<i> 0002bfb0: 3c00 3d00 3e00 3f00 4000 4100 4200 4300  &lt;.=.&gt;.?<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">. at .A.B.C.</A>
</I>&gt;<i> 0002bfc0: 4400 4500 4600 4700 4800 4900 4a00 4b00  D.E.F.G.H.I.J.K.
</I>&gt;<i> 0002bfd0: 4c00 4d00 4e00 4f00 5000 5100 5200 5300  L.M.N.O.P.Q.R.S.
</I>&gt;<i> 0002bfe0: 5400 5500 5600 5700 5800 5900 5a00 5b00  T.U.V.W.X.Y.Z.[.
</I>&gt;<i> 
</I>&gt;<i>         though they are somewhat smaller than the runs of the same char.
</I>
As the quality of sortkey data content, the arrays are already
optimized to be usable as live arrays used in the code:

1) The sequences of zeros are not that big I believe, at least now.
I have implemented an index-based table mapping optimizer that skips
such sequences of zeros. I can introduce more indexes to optimize
the table, but it harms performance by introducing extraneous
codepoint comparison.

2) Actually there's a couple of reasons that the table _looks_
extraneously massive. A large chunk of &quot;repetition&quot; is from Hangul
Syllables and CJK ideographs. Due to the silly Windows sortkey
design, the computation is not direct. (The details are described
in <A HREF="http://monkey.workarea.jp/lb/archive/2005/6-25.html">http://monkey.workarea.jp/lb/archive/2005/6-25.html</A> )

The cause of the sequences of similar data is because they are
ushort arrays that maps ASCII characters (they are used to support
CompareOptions.IgnoreWidth). They are *mostly* in ASCII range but
there are still a couple of non-ASCII mappings. I don't think that
table is large now.

&gt;<i> As a datapoint:
</I>&gt;<i> 
</I>&gt;<i> [<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">benm at omega</A> ~]$ du -h collation.core.bin*
</I>&gt;<i> 188K    collation.core.bin
</I>&gt;<i> 16K     collation.core.bin.bz2
</I>&gt;<i> 16K     collation.core.bin.gz
</I>&gt;<i> 
</I>&gt;<i> Obviously, the compression rate from something like this a theoretical
</I>&gt;<i> lowest size we could get. But the fact that we can get over 10x
</I>&gt;<i> compression on the file means there is quite a bit of room for
</I>&gt;<i> improvement.
</I>&gt;<i> 
</I>&gt;<i> It'd be nice to optimize the format *before* we check in the binary
</I>&gt;<i> files, since optimizing will require some frequent changes.
</I>
As the quality of data storage, yes they could be made smaller.
The table could be much smaller even if I introduced simple
run-length compression.

But it also means that the live arrays (used in the collator code)
must be created apart from internal pointer to the managed resources.
I wonder if it makes sense.

&gt;&gt;<i>When this managed collation is enabled, it will eat huge managed
</I>&gt;&gt;<i>resource
</I>&gt;<i> 
</I>&gt;<i> How are you reading in the resource? Do you use it as a byte [] array?
</I>&gt;<i> In mscorlib, when we load a resource, it icall's into the runtime which
</I>&gt;<i> returns a void*/intptr to the data. This pointer comes from the mmap'd
</I>&gt;<i> assembly location. It would be a very large win to use either the stream
</I>&gt;<i> directly (ie, with a binaryreader that did seeking) or using unsafe
</I>&gt;<i> operations on the void*. This has two advantages:
</I>&gt;<i>       * Only pages of data that are ever read get paged in by the OS.
</I>&gt;<i>         Other things can just stay on the disk
</I>&gt;<i>       * Pages can be shared between mono processes.
</I>
Well, what I wanted to mean was &quot;managed heap&quot; (so it anyways creates
managed resource, regardless of whether you use managed collation
or not).

The corresponding code is already in svn,
mcs/class/corlib/Mono.Globalization.Unicode/MSCompatUnicodeTable.cs.
It creates a BinaryReader instance for each manifest resource stream,
and for byte arrays it does Read(array, 0, size).

For ushort array it calls ReadUInt16(). Except for one case
(&quot;widthCompat&quot; array) it is possible to split an ushort array into
two byte arrays.

&gt;&gt;<i>I can make this into unmanaged header file if we want.
</I>&gt;<i> 
</I>&gt;<i> If we do this, it wouldn't be that big of a win to make it an unmanaged
</I>&gt;<i> header. The only win that I can think of there is that we can do
</I>&gt;<i> arch-specific stuff, avoiding the need to be endian safe (btw, have you
</I>&gt;<i> tested this on a ppc box?).
</I>
I don't have PPC. I use BinaryWriter to create those resources,
calling Write(byte), WriteInt32(), etc. and used BinaryReader
to read manifest resource stream, with ReadByte(), ReadUInt16(),
ReadInt32() etc.

If BinaryWriter.Write() (other than byte parameter) writes its
stream output in different byte order depending on the platform
or BinaryReader reads stream as well, how can I know that platform
dependent byte order?

&gt;<i> It might be nice to put the files in /usr/share. A few things we win by
</I>&gt;<i> doing that:
</I>
How can we get the precise file location, especially when we specify
different GAC to reference mscorlib?

&gt;<i>       * It keeps the size of our tarballs and monolites down because the
</I>&gt;<i>         included mscorlib does not have the data
</I>
Similarly, when the collation resources are split, then CompareInfo
in mscorlib will be messed. It is similar to what happens when we
have inconsistent version of mscorlib.dll and the runtime.

&gt;<i> Of course, if the compression can make this data small, we wouldn't need
</I>&gt;<i> to think about this :-).
</I>
Heh, yes ;-)

&gt;<i> Of course, one non-performance advantage of this is that it is easier
</I>&gt;<i> for people to test your bug fixes (and easier for you as well!).
</I>
Actually for debugging purpose it (&quot;make&quot; under Mono.Globalization.
Unicode) also generates the code that contains full managed code
array (it is created as MSCompatUnicodeTableGenerated.cs under
that directory). The file looks like this:
<A HREF="http://monkey.workarea.jp/tmp/20050720/MSCompatUnicodeTableGenerated.cs">http://monkey.workarea.jp/tmp/20050720/MSCompatUnicodeTableGenerated.cs</A>
(warning: it is about 1MB)

It is completely replaceable the one which uses managed resources.

Atsushi Eno

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013267.html">[Mono-devel-list] The first (attempt to checkin) managedcollation	patch
</A></li>
	<LI>Next message: <A HREF="013301.html">[Mono-devel-list] The first (attempt to checkin)	managed	collation patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13271">[ date ]</a>
              <a href="thread.html#13271">[ thread ]</a>
              <a href="subject.html#13271">[ subject ]</a>
              <a href="author.html#13271">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
