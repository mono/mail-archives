<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [PATCH] Implement field load/store verification
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Implement%20field%20load/store%20verification&In-Reply-To=8cca42d80706201602n58465471i6f23b5ede5045292%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023945.html">
   <LINK REL="Next"  HREF="023957.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [PATCH] Implement field load/store verification</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20Implement%20field%20load/store%20verification&In-Reply-To=8cca42d80706201602n58465471i6f23b5ede5045292%40mail.gmail.com"
       TITLE="[Mono-dev] [PATCH] Implement field load/store verification">lupus at ximian.com
       </A><BR>
    <I>Thu Jun 21 09:24:24 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="023945.html">[Mono-dev] [PATCH] Implement field load/store verification
</A></li>
        <LI>Next message: <A HREF="023957.html">[Mono-dev] [PATCH] Implement field load/store verification
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23953">[ date ]</a>
              <a href="thread.html#23953">[ thread ]</a>
              <a href="subject.html#23953">[ subject ]</a>
              <a href="author.html#23953">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 06/20/07 Rodrigo Kumpera wrote:
&gt;<i> The attached patch does the following:
</I>&gt;<i> 
</I>&gt;<i> -implement all field load/store verifications
</I>&gt;<i> -fixes a small typo in a class.c comment
</I>&gt;<i> -function pointer validation now handles call convention
</I>&gt;<i> -fixed: brtrue/false flaged unmanaged pointers as invalid types (now just
</I>&gt;<i> flags as unverifiable)
</I>
&gt;<i> Index: verify.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- verify.c	(revision 80327)
</I>&gt;<i> +++ verify.c	(working copy)
</I>&gt;<i> @@ -2359,6 +2362,156 @@
</I>&gt;<i>  	}
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i> +static void
</I>&gt;<i> +do_push_static_field (VerifyContext *ctx, int token, gboolean take_addr)
</I>&gt;<i> +{
</I>&gt;<i> +	MonoClassField *field;
</I>&gt;<i> +	MonoClass *klass;
</I>&gt;<i> +
</I>&gt;<i> +	field = mono_field_from_token (ctx-&gt;image, token, &amp;klass, ctx-&gt;generic_context);
</I>&gt;<i> +	if (!field) {
</I>&gt;<i> +		ADD_VERIFY_ERROR (ctx, g_strdup_printf (&quot;Cannot load field from token 0x%08x at 0x%04x&quot;, token, ctx-&gt;ip_offset));
</I>&gt;<i> +		return;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (!(field-&gt;type-&gt;attrs &amp; FIELD_ATTRIBUTE_STATIC)) { 
</I>&gt;<i> +		ADD_VERIFY_ERROR (ctx, g_strdup_printf (&quot;Cannot load non static field at 0x%04x&quot;, ctx-&gt;ip_offset));
</I>&gt;<i> +		return;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (take_addr &amp;&amp; (field-&gt;type-&gt;attrs &amp; FIELD_ATTRIBUTE_INIT_ONLY))
</I>&gt;<i> +		CODE_NOT_VERIFIABLE (ctx, g_strdup_printf (&quot;Cannot take the address of a init-only field at 0x%04x&quot;, ctx-&gt;ip_offset));
</I>
This should be allowed in the .cctor for the class (same for the
equivalent case of an instance field and the .ctor): a test case is
something like:

	readonly static MyValueType v = new MyValueType (5);

Note, eventually you also need to add accessibility checks: the method
needs to be able to access the field keeping in mind both the field's
and the field's class visibility.

&gt;<i> +static gboolean
</I>&gt;<i> +check_is_valid_type_for_field_ops (VerifyContext *ctx, int token, ILStackDesc *obj, MonoClassField **ret_field)
</I>&gt;<i> +{
</I>&gt;<i> +	MonoClassField *field;
</I>&gt;<i> +	MonoClass *klass;
</I>&gt;<i> +
</I>&gt;<i> +	/*must be one of: object type, managed pointer, unmanaged pointer (native int) or an instance of a value type */
</I>&gt;<i> +	if (!((obj-&gt;stype == TYPE_COMPLEX)
</I>&gt;<i> +		/* the managed reference must be to an object or value type */
</I>&gt;<i> +		|| ((obj-&gt;stype &amp; POINTER_MASK) &amp;&amp; (UNMASK_TYPE (obj-&gt;stype) == TYPE_COMPLEX))
</I>&gt;<i> +		|| (obj-&gt;stype == TYPE_NATIVE_INT)
</I>&gt;<i> +		|| (obj-&gt;stype == TYPE_PTR)
</I>&gt;<i> +		|| (obj-&gt;stype == TYPE_COMPLEX))) {
</I>&gt;<i> +		ADD_VERIFY_ERROR (ctx, g_strdup_printf (&quot;Invalid argument %s to load field at 0x%04x&quot;, type_names [UNMASK_TYPE (obj-&gt;stype)], ctx-&gt;ip_offset));
</I>&gt;<i> +		return FALSE;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	field = mono_field_from_token (ctx-&gt;image, token, &amp;klass, ctx-&gt;generic_context);
</I>&gt;<i> +	if (!field) {
</I>&gt;<i> +		ADD_VERIFY_ERROR (ctx, g_strdup_printf (&quot;Cannot load field from token 0x%08x at 0x%04x&quot;, token, ctx-&gt;ip_offset));
</I>&gt;<i> +		return FALSE;
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	*ret_field = field;
</I>&gt;<i> +
</I>&gt;<i> +	g_assert (obj-&gt;type);
</I>&gt;<i> +
</I>&gt;<i> +	/*The value on the stack must be a subclass of the defining type of the field*/ 
</I>&gt;<i> +	/* we need to check if we can load the field from the stack value*/
</I>&gt;<i> +	if (UNMASK_TYPE (obj-&gt;stype) == TYPE_COMPLEX) {
</I>&gt;<i> +		MonoType *type = obj-&gt;type-&gt;byref ? &amp;field-&gt;parent-&gt;this_arg : &amp;field-&gt;parent-&gt;byval_arg;
</I>&gt;<i> +
</I>&gt;<i> +		if (!verify_stack_type_compatibility (ctx, type, obj-&gt;type, FALSE)) {
</I>&gt;<i> +			ADD_VERIFY_ERROR (ctx, g_strdup_printf (&quot;Type at stack is not compatible to reference the field at 0x%04x&quot;, ctx-&gt;ip_offset));
</I>&gt;<i> +			return FALSE;
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	if (MONO_TYPE_IS_REFERENCE (field-&gt;type) &amp;&amp; !(field-&gt;type-&gt;attrs &amp; FIELD_ATTRIBUTE_STATIC)) {
</I>&gt;<i> +		MonoClass *p;
</I>&gt;<i> +		MonoClassField * other;
</I>&gt;<i> +
</I>&gt;<i> +		for (p = field-&gt;parent; p != NULL; p = p-&gt;parent) {
</I>&gt;<i> +			gpointer iter = NULL;
</I>&gt;<i> +			while ((other = mono_class_get_fields (p, &amp;iter))) {
</I>&gt;<i> +				if (other != field &amp;&amp; other-&gt;offset == field-&gt;offset &amp;&amp; !(other-&gt;type-&gt;attrs &amp; FIELD_ATTRIBUTE_STATIC)) {
</I>&gt;<i> +					CODE_NOT_VERIFIABLE (ctx, g_strdup_printf (&quot;Overlapped reference field at 0x%04x&quot;, ctx-&gt;ip_offset));
</I>&gt;<i> +					goto overlap_check_end;
</I>&gt;<i> +				}
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +	}
</I>
The code for overlapped fields is not as trivial as this. It is moreover
something you should do on a per-type basis instead of per-field access
in the IL code. metadata/object.c has the code to do proper overlapping
field detection: that code should not be duplicated.

Thanks!

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023945.html">[Mono-dev] [PATCH] Implement field load/store verification
</A></li>
	<LI>Next message: <A HREF="023957.html">[Mono-dev] [PATCH] Implement field load/store verification
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23953">[ date ]</a>
              <a href="thread.html#23953">[ thread ]</a>
              <a href="subject.html#23953">[ subject ]</a>
              <a href="author.html#23953">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
