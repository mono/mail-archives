<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20PATCH%3A%20Make%20Process.Start%28%29%20use%20thesame%27mono%27runtime&In-Reply-To=f4bhrt%24v84%241%40sea.gmane.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023843.html">
   <LINK REL="Next"  HREF="023848.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime</H1>
    <B>Andreas F&#228;rber</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20PATCH%3A%20Make%20Process.Start%28%29%20use%20thesame%27mono%27runtime&In-Reply-To=f4bhrt%24v84%241%40sea.gmane.org"
       TITLE="[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime">andreas.faerber at web.de
       </A><BR>
    <I>Fri Jun  8 10:23:08 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="023843.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
        <LI>Next message: <A HREF="023848.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23847">[ date ]</a>
              <a href="thread.html#23847">[ thread ]</a>
              <a href="subject.html#23847">[ subject ]</a>
              <a href="author.html#23847">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Robert,

&gt;&gt;<i> From my view the core problem is rather the PE format of the
</I>&gt;&gt;<i> assemblies. The reason why Microsoft is using it is because it's
</I>&gt;&gt;<i> their *native* executable format [...]
</I>&gt;<i>
</I>&gt;<i> Well, look at the Java mess on Windows: the average Windows user
</I>&gt;<i> is not even able to launch such apps, when they not come with
</I>&gt;<i> wrappers, shortcuts, whistles and bells.
</I>&gt;<i>
</I>&gt;<i> No wonder MS has chosen their native exec format.
</I>
I know and dislike &quot;the Java mess&quot;, and thus it is a bad argument for  
Mono doing so on Linux and Mac!!!

It's just the most uncomplicated way of going about it from the  
developer's point of view.

&gt;&gt;<i> This is in the ECMA standard, okay, but I have
</I>&gt;&gt;<i> been wondering why we don't provide a converter between PE and ELF/
</I>&gt;&gt;<i> Mach-O to do the equivalent?
</I>&gt;<i>
</I>&gt;<i> #!/bin/sh
</I>&gt;<i> # Universal PE Converter, Copyright (C) Robert `Smartass' J. :-)
</I>&gt;<i> exec mono my-exciting-app.exe &quot;$*&quot;
</I>
This is not a converter and we both know it, we have tons of such  
scripts flying around for Mono, and some do not work on Solaris due  
to shell differences, e.g. mono-service.
Also, mono then gets a different pid than the executable started  
(maybe relevant on Windows and an apparent issue when playing with  
Cocoa# and AppleScript).

&gt;&gt;<i> This is different from mkbundle's semantics in not embedding a full
</I>&gt;&gt;<i> Mono but providing a stub only - either one dynamically linked to
</I>&gt;&gt;<i> libmono.so/.dylib or invoking mono with the assembly, similar to a #!
</I>&gt;&gt;<i> line. I understand that using the PE format is the basis of
</I>&gt;&gt;<i> interoperability with Microsoft .NET but for a Unix-only app we don't
</I>&gt;&gt;<i> need that and rather want to provide a convenient experience to users
</I>&gt;&gt;<i> and developers (which a script does not always). On the Mac we don't
</I>&gt;<i>
</I>&gt;<i> Is it worthwhile to spend a couple of weeks to blow up the runtime
</I>&gt;<i> with X binfmt readers/writers, while breaking the specs and
</I>&gt;<i> eventually obsoleting an one liner script?
</I>
&gt;<i> BTW, you can achieve this with mkbundle using its &quot;--nodeps&quot; option
</I>&gt;<i> and omitting &quot;--static&quot;. It's an one liner, too.
</I>
Thanks for pointing that out, wasn't aware.

However my general point is still valid: We don't have to blindly  
follow Microsoft, they made decisions from their local perspective  
(call it &quot;cross-Windows&quot;) and we might want to be compatible but do  
not need to limit us to that scope. We are not &quot;breaking the specs&quot;  
should we do something unique, and if we want to do breaking  
differences we can still embed our own runtime identifier according  
to those same specs and go ahead with it, in theory.

For example, Microsoft does not seem to implement the full scope of  
their own ECMA spec while I would still very much like to see an  
implementation of the optional System.Threading.Parallel assembly on  
Mono. (I have done some initial non-parallel work on it and it might  
be beneficial to extend the spec's probably-intended-semantics there)
Anyone who reads that section of the spec will clearly see that there  
are a number of vague sections in the standard, and we all know that  
the CLI had not started out as a true cross-platform infrastructure,  
thinking of the platform enum there.


&gt;&gt;<i> Some other options to consider:
</I>&gt;&gt;<i> - use .config file to map exe to the desired executable (whether
</I>&gt;&gt;<i> script or mono) as done for libraries
</I>&gt;&gt;<i> - instead of invoking mono with or without environment variables just
</I>&gt;&gt;<i> strip the .exe extension and let the user take care of the path there
</I>&gt;&gt;<i> (Unix only)
</I>&gt;&gt;<i> - try to execute .exe, if this fails (because .NET is not installed
</I>&gt;&gt;<i> or we can't execute PE binaries) fall back to invoking mono (monow on
</I>&gt;&gt;<i> Windows)
</I>
&gt;&gt;<i> Simply prepending a pure shebang line does not seem to be an option
</I>&gt;&gt;<i> given that mono does not read assemblies from stdin.
</I>&gt;<i>
</I>&gt;<i> The PE format is, like every decent binfmt, mmapable, so handling
</I>&gt;<i> it from a stream is not a smart option.
</I>
I didn't say it should. (But to be picky, for an exception see the  
Symbian thread - it doesn't make sense to map something already in  
memory to another part of limited (flash) memory when you have random  
access to the stream/file in the first place, and it worked fine for  
me.)

If you review the above points you will see that option no. 2 is  
exactly providing a shell script, so your suggestion is not new  
either way.
And it would work on Windows as well if the extension were not  
stripped but replaced with .cmd (as we're only supporting NT anyway).

Andreas

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023843.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
	<LI>Next message: <A HREF="023848.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23847">[ date ]</a>
              <a href="thread.html#23847">[ thread ]</a>
              <a href="subject.html#23847">[ subject ]</a>
              <a href="author.html#23847">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
