<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Dictionary`2: optimized	and	serialization-compatible	with MS.net
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Dictionary%602%3A%20optimized%09and%09serialization-compatible%0A%09with%20MS.net&In-Reply-To=20070608142936.GD4081%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023870.html">
   <LINK REL="Next"  HREF="023876.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Dictionary`2: optimized	and	serialization-compatible	with MS.net</H1>
    <B>Juraj Skripsky</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Dictionary%602%3A%20optimized%09and%09serialization-compatible%0A%09with%20MS.net&In-Reply-To=20070608142936.GD4081%40debian.org"
       TITLE="[Mono-dev] Dictionary`2: optimized	and	serialization-compatible	with MS.net">js at hotfeet.ch
       </A><BR>
    <I>Mon Jun 11 08:43:47 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="023870.html">[Mono-dev] Dictionary`2: optimized and	serialization-compatible	with MS.net
</A></li>
        <LI>Next message: <A HREF="023876.html">[Mono-dev] Dictionary`2: optimized	and	serialization-compatible	with MS.net
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23872">[ date ]</a>
              <a href="thread.html#23872">[ thread ]</a>
              <a href="subject.html#23872">[ subject ]</a>
              <a href="author.html#23872">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 2007-06-08 at 16:29 +0200, Paolo Molaro wrote:
&gt;<i> &gt; 1) Do not store the hashcode: much slower (10-80%).
</I>&gt;<i> &gt;    The Hashtable class stores the hashcode too...
</I>&gt;<i> &gt;    Recalculating the hashcode on every access makes no sense.
</I>&gt;<i> 
</I>&gt;<i> This doesn't look like what I suggested, since GetHashCode()
</I>&gt;<i> would be called more often only in the case of rehash and that should
</I>&gt;<i> not cause a 80% slowdown.
</I>&gt;<i> Could you post for example the new get implementation? There should be
</I>&gt;<i> only a GetHashCode() call for the key, which you need already.
</I>
If we don't store the hashcodes of keys inserted into the hashtable, we
have to call GetHashCode() in most methods (containing the following
code or variations thereof), not just in the case of rehashing:

------
// get first item of linked list corresponding to given key
int hashCode = (hcp.GetHashCode (key) &amp; Int32.MaxValue);
int cur = table [hashCode % table.Length];
				
// walk linked list until right slot is found or end is reached 
while (cur != NO_SLOT) {
    if (linkSlots [cur].HashCode == hashCode &amp;&amp;
        hcp.Equals (dataSlots [cur].Key, key))
        return dataSlots [cur].Value;
    cur = linkSlots [cur].Next;
}
------

&quot;linkSlots [cur].HashCode == hashCode&quot; would have to be replaced with
&quot;linkSlots [cur].Key.GetHashCode() == hashCode&quot;...

Or am I missing something here?

&gt;<i> &gt; 2) Separate key and value arrays: no difference (with current GC).
</I>&gt;<i> &gt;    If the separation will reduce the pressure on future GCs (sgen?),
</I>&gt;<i> &gt;    then it makes a lot of sense.
</I>&gt;<i> 
</I>&gt;<i> I guess it would be significant only with big hash tables
</I>&gt;<i> and it would show up even with the current GC: say you have
</I>&gt;<i> a Hashtable&lt;int,object&gt;. With separate arrays they key array
</I>&gt;<i> is completely skipped and only the values array is scanned
</I>&gt;<i> for references. With the unified array the current GC will have
</I>&gt;<i> to scan all of it. A test case could be to create a few
</I>&gt;<i> large hash-tables (no need to fill them, just force the capacity to
</I>&gt;<i> 1 million entries) and keep them alive while you execute GC.Collect()
</I>&gt;<i> several times. Note the total execution speed of the test
</I>&gt;<i> with the split or unified array. The test should last
</I>&gt;<i> at least 10 seconds. Increasing the size of the arrays
</I>&gt;<i> should make the difference larger (specially if the split array fits
</I>&gt;<i> into the cache while the unified doesn't).
</I>
I'll cook up a test case following your description and post the
results.

&gt;<i> The only downside of the split arrays are a slight increase
</I>&gt;<i> of memory usage: 20 bytes on 32 bit systems. This (apart from the cache
</I>&gt;<i> locality effects described above) is largely offset by the wins we'd
</I>&gt;<i> have with keys and values with different alignment constraints
</I>&gt;<i> (because the unified array entries would need to be aligned to
</I>&gt;<i> the max alignment of key and value). Also, given the not-completely
</I>&gt;<i> precise GC's issues with large arrays, having two smaller ones
</I>&gt;<i> is likely to make its life easier.
</I>&gt;<i> 
</I>&gt;<i> &gt; 3) 0 as 'no slot' value in table: slightly faster (2-7%).
</I>&gt;<i> &gt;    The change is trivial (i.e. add 1 when storing a value in table,
</I>&gt;<i> &gt;    subtract 1 when reading from it) and gives us a slight speed-up.
</I>&gt;<i> 
</I>&gt;<i> Nice.
</I>&gt;<i> 
</I>&gt;<i> &gt; If it where up to me, I would do the changes 2 and 3.
</I>&gt;<i> &gt; What do you think (especially about change 2)?
</I>&gt;<i> 
</I>&gt;<i> Well, it's nice that with change 2 you found no regression, I think
</I>&gt;<i> a specific test would be able to show the differences, so 2 and 3
</I>&gt;<i> look viable and I'll still way for more data to decide on 1.
</I>&gt;<i> Thanks!
</I>&gt;<i> 
</I>&gt;<i> lupus
</I>
Thanks for your feedback!
I can't wait for the optimized implementation to be committed to svn. As
soon as that is done, it will be interesting to replace private/internal
hashtables in the class libs with Dictionaries (e.g. QuickSearch.shift
in System.Text.RegularExpressions) for the NET_2_0 profile and measure
the speedup.

Juraj


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023870.html">[Mono-dev] Dictionary`2: optimized and	serialization-compatible	with MS.net
</A></li>
	<LI>Next message: <A HREF="023876.html">[Mono-dev] Dictionary`2: optimized	and	serialization-compatible	with MS.net
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23872">[ date ]</a>
              <a href="thread.html#23872">[ thread ]</a>
              <a href="subject.html#23872">[ subject ]</a>
              <a href="author.html#23872">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
