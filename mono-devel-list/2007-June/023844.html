<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20PATCH%3A%20Make%20Process.Start%28%29%20use%20thesame%27mono%27runtime&In-Reply-To=20070607221539.GC4081%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023848.html">
   <LINK REL="Next"  HREF="023822.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime</H1>
    <B>Jonathan Chambers</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20PATCH%3A%20Make%20Process.Start%28%29%20use%20thesame%27mono%27runtime&In-Reply-To=20070607221539.GC4081%40debian.org"
       TITLE="[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime">joncham at gmail.com
       </A><BR>
    <I>Fri Jun  8 09:26:06 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="023848.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
        <LI>Next message: <A HREF="023822.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23844">[ date ]</a>
              <a href="thread.html#23844">[ thread ]</a>
              <a href="subject.html#23844">[ subject ]</a>
              <a href="author.html#23844">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello All,
      Just looking through bug list and noticed this thread seems related to
bug 71887, so it could probably be reviewed/closed after this discussion.

Thanks,
Jonathan

On 6/7/07, Paolo Molaro &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>&gt; wrote:
&gt;<i>
</I>&gt;<i> On 06/07/07 Jonathan Gilbert wrote:
</I>&gt;<i> &gt; What use case requires a managed application to create many hundreds of
</I>&gt;<i> &gt; extremely-short-lived processes every second for any period of time? Is
</I>&gt;<i>
</I>&gt;<i> What matters is that you're adding an unacceptable 25% overhead
</I>&gt;<i> for a corner case that has other inexpensive solutions.
</I>&gt;<i>
</I>&gt;<i> &gt; Firstly, if you run a managed C++/COM app in .NET, it will never
</I>&gt;<i> &gt; &quot;accidentally&quot; start a managed child process using mono. Secondly,
</I>&gt;<i> aren't
</I>&gt;<i>
</I>&gt;<i> See my discussion of even using two different MS runtimes.
</I>&gt;<i>
</I>&gt;<i> &gt; support of mixed assemblies and COM interop eventual goals of mono (two
</I>&gt;<i> &gt; independent goals, with much more activity on the latter)?
</I>&gt;<i>
</I>&gt;<i> I never heard of anyone interested in supporting mixed mode assemblies:
</I>&gt;<i> for us it is a completely uninteresting case since it would work only on
</I>&gt;<i> windows, so if someone wants the feature he will have to implement it
</I>&gt;<i> (like Jonathan is implementing COM support).
</I>&gt;<i> The important thing to note is that we're much more likely to get
</I>&gt;<i> compatible serialization than mixed mode support. And mixed mode and COM
</I>&gt;<i> are only 2 examples of many features that are valid only for windows and
</I>&gt;<i> that we don't have plans to implement. We're certainly not going to
</I>&gt;<i> break execution of many programs for this corner case that has perfectly
</I>&gt;<i> valid, simple and not buggy solutions.
</I>&gt;<i>
</I>&gt;<i> &gt; the parent process with Mono. Over the years I have seen many cases
</I>&gt;<i> where
</I>&gt;<i> &gt; something has been rejected for Mono because it would have allowed
</I>&gt;<i> people
</I>&gt;<i> &gt; to write managed applications that *only* Mono could run. Of course,
</I>&gt;<i> there
</I>&gt;<i> &gt; are yet many ways to do that, but the emphasis has always been on
</I>&gt;<i> &gt; interoperability.
</I>&gt;<i>
</I>&gt;<i> Interoperability doesn't include not being able to run some .net programs
</I>&gt;<i> which is what your solution would do.
</I>&gt;<i>
</I>&gt;<i> &gt; &gt;The Process class is for telling the operating system to execute child
</I>&gt;<i> &gt; &gt;processes, there is nothing in the documentation or anywhere else about
</I>&gt;<i> &gt; &gt;&quot;using the same runtime&quot;.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; That documentation is written by Microsoft.
</I>&gt;<i>
</I>&gt;<i> Microsoft provides different runtimes on the same box.
</I>&gt;<i>
</I>&gt;<i> &gt; &gt;I understand that you your scenario needs a solution, but hacking
</I>&gt;<i> &gt; &gt;Process is not it. What if you use &quot;prog&quot; instead of &quot;prog.exe&quot;
</I>&gt;<i> &gt; &gt;as the name of the executable? Windows will look for prog.exe
</I>&gt;<i> &gt; &gt;and run that, right? When you want to test with mono you'll have
</I>&gt;<i> &gt; &gt;a test directory with a prog.bat batch file and you can put that
</I>&gt;<i> &gt; &gt;directory at the start of your PATH environment var and execute your
</I>&gt;<i> &gt; &gt;program with mono: windows will load the batch file which in turn uses
</I>&gt;<i> &gt; &gt;mono to execute your prog.exe managed assembly.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Yes, yes, this works, but it makes an enormous assumption: that I am the
</I>&gt;<i> &gt; author of the application in question. If I am merely a consumer who has
</I>&gt;<i> &gt; purchased a .NET application and wishes to run it on Linux, and it fails
</I>&gt;<i> to
</I>&gt;<i> &gt; run because of something Mono could easily have taken care of, that is,
</I>&gt;<i> in
</I>&gt;<i> &gt; my eyes, pretty much Mono's fault. As far as I'm concerned, depending on
</I>&gt;<i>
</I>&gt;<i> First, it is trivial to make it run as I pointed out already two times:
</I>&gt;<i> use the Linux binfmt support (third time). Miguel is too lazy to do it
</I>&gt;<i> so he committed something like your first patch on Linux, which works
</I>&gt;<i> since there is only one working .net runtime there. So don't worry about
</I>&gt;<i> Linux. Your issue is only related to windows and it has never been a
</I>&gt;<i> problem on Linux.
</I>&gt;<i>
</I>&gt;<i> &gt; the fact that one platform will see &quot;prog&quot; as a binary and another will
</I>&gt;<i> not
</I>&gt;<i> &gt; and will instead search for and find &quot;prog.exe&quot; is a much worse hack
</I>&gt;<i> than
</I>&gt;<i> &gt; doing something that the documentation does not comment on and
</I>&gt;<i>
</I>&gt;<i> A documented behaviour is a hack while breaking execution of programs as
</I>&gt;<i> you suggest is not?
</I>&gt;<i>
</I>&gt;<i> &gt; automatically do what, for the majority of users, is the &quot;right thing&quot;.
</I>&gt;<i> &gt; Asking code authors to use Process.Start on something other than the
</I>&gt;<i> actual
</I>&gt;<i> &gt; program filename and at the same time asking end users to create batch
</I>&gt;<i> &gt; files or shell scripts just for the privilege of using Mono to run a
</I>&gt;<i> &gt; program they did not write and about the internals of which they know
</I>&gt;<i> &gt; nothing is completely unacceptable; it will alienate people.
</I>&gt;<i>
</I>&gt;<i> Breaking execution of .net programs with no way to fix it is going to
</I>&gt;<i> alianate many more people (which is exactly what you suggested above:
</I>&gt;<i> just don't use mono: we want people to use mono, not drive them away
</I>&gt;<i> as your solution does).
</I>&gt;<i>
</I>&gt;<i> &gt; If argc is 0, then argv[0] == NULL (or the platform is non-compliant).
</I>&gt;<i> Do
</I>&gt;<i> &gt; we support any non-compliant platforms?
</I>&gt;<i>
</I>&gt;<i> Point taken, you're right on this one.
</I>&gt;<i>
</I>&gt;<i> &gt; &gt;No, executing a managed assembly that way can be considered a bug,
</I>&gt;<i> &gt; &gt;just like not using PathSeparator for directories: anywhere but
</I>&gt;<i> &gt; &gt;windows it is \n
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I have yet to encounter a platform where the path separator is '\n'.
</I>&gt;<i> Even
</I>&gt;<i> &gt; assuming you meant '/', there are platforms which use other characters,
</I>&gt;<i> &gt; such as ':'. In any event, I have never used Environment.PathSeparator;
</I>&gt;<i> I
</I>&gt;<i> &gt; just use Path.Combine and let it figure out the details. Why can't I
</I>&gt;<i> also
</I>&gt;<i> &gt; use Process.Create and let it figure out the details?
</I>&gt;<i>
</I>&gt;<i> Sure, in fact Process.Create() is supposed to call the operating system
</I>&gt;<i> and make it execute the program you told it to and on windows that means
</I>&gt;<i> eventually executing with the Ms runtime (it's the OS that does that).
</I>&gt;<i>
</I>&gt;<i> &gt; &gt;like anywhere but windows a prog.exe is a simple data
</I>&gt;<i> &gt; &gt;file and not an executable (modulo the binfmt registration I
</I>&gt;<i> mentioned).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; The same applies to the binary format of any other operating systems;
</I>&gt;<i> aside
</I>&gt;<i> &gt; from hacks and wrappers added specifically to support it, a Linux binary
</I>&gt;<i> is
</I>&gt;<i> &gt; &quot;only data&quot; to a FreeBSD machine, and so on. The more abstract one
</I>&gt;<i> becomes,
</I>&gt;<i> &gt; though, the closer a file becomes to a universal binary; most platforms
</I>&gt;<i> can
</I>&gt;<i> &gt; be configured to run .NET binaries directly, and all platforms can be
</I>&gt;<i> &gt; configured to run scripts (Perl, Python, Ruby, etc.) directly.
</I>&gt;<i>
</I>&gt;<i> Sure that's why the problem that you said is a problem on Linux isn't,
</I>&gt;<i> so we don't need to add any slowdown and unmaintainable code to the
</I>&gt;<i> Process class.
</I>&gt;<i>
</I>&gt;<i> &gt; &gt;And it is definitely a bug to assume that the same runtime will be used
</I>&gt;<i> &gt; &gt;and I bet that this happens also when having different MS frameworks
</I>&gt;<i> &gt; &gt;installed on windows (run a program with the 1.1 framework and make it
</I>&gt;<i> &gt; &gt;execute a program that requires 2.0,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; As I understand it, unless you are embedding the run-time, the newest
</I>&gt;<i> &gt; version is always used to launch any .NET application on Windows. Which
</I>&gt;<i> BCL
</I>&gt;<i> &gt; is used is chosen based on where the metadata in the EXE refers, and the
</I>&gt;<i> &gt; bytecode and icalls is backwards-compatible. Launching a .NET 1.1
</I>&gt;<i> &gt; application loads it in the 2.0 VM but runs it against the 1.1 BCL.
</I>&gt;<i> (Mono
</I>&gt;<i> &gt; behaves the same way, does it not?)
</I>&gt;<i>
</I>&gt;<i> 1.1 is a different runtime (the runtime includes mscorlib etc, so even
</I>&gt;<i> if the jit binary is the same, mscorlib and hence the runtime is
</I>&gt;<i> different) and it is binary-incompatible wrt serialization and other
</I>&gt;<i> issues, which exactly proves my point that Process.Create() is in no
</I>&gt;<i> way guaranteed to execute with the same runtime (remember that your
</I>&gt;<i> original asserted reason for your hack was serialization compatibility).
</I>&gt;<i>
</I>&gt;<i> &gt; Launching any .NET application from any other on Windows *is* guaranteed
</I>&gt;<i> to
</I>&gt;<i> &gt; use the same run-time, but obviously there will be remoting
</I>&gt;<i> &gt; incompatibilities and other issues communicating between two processes
</I>&gt;<i> if
</I>&gt;<i> &gt; they are using different versions of the BCL. However, any application
</I>&gt;<i> &gt; which has been designed with a child process communicating back to a
</I>&gt;<i> parent
</I>&gt;<i> &gt; process will have both the parent and the child compiled for the same
</I>&gt;<i> &gt; run-time version against the same BCL.
</I>&gt;<i>
</I>&gt;<i> You can't guarantee that if you use any third-party program, which
</I>&gt;<i> is one of the reasons you can have .config files specify the runtime
</I>&gt;<i> (instead of having a .config file you'd have to use a batch file for
</I>&gt;<i> mono, big deal).
</I>&gt;<i>
</I>&gt;<i> &gt; &gt;or play some tricks with the 32 or
</I>&gt;<i> &gt; &gt;64 variants of the frameworks on a 64 bit box).
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Unless you are embedding the run-time, I'm pretty sure you have no
</I>&gt;<i> control
</I>&gt;<i> &gt; over this. I could be mistaken, however; I have never played with a
</I>&gt;<i> 64-bit
</I>&gt;<i> &gt; Windows box.
</I>&gt;<i>
</I>&gt;<i> Neither did I, but I read the documentation and you can look it up on
</I>&gt;<i> the web, too: Process.Create() has no way to guarantee that a program is
</I>&gt;<i> executed with the same runtime (and for very good reasons). As such, for
</I>&gt;<i> the sake of interoperability which is so dear to you and also because it
</I>&gt;<i> would be a bug to do, we won't force down our users throat the decision
</I>&gt;<i> as to which runtime to use to execute any program: if the user didn't
</I>&gt;<i> specify one (by explicitly using mono to run it) it's up to the
</I>&gt;<i> operating system to decide.
</I>&gt;<i> Until you realize that your solution breaks execution of programs
</I>&gt;<i> and prevents the user from ever being able to fix it (and no, not using
</I>&gt;<i> mono at all is not a solution), you won't be able to convince anyone.
</I>&gt;<i>
</I>&gt;<i> lupus
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> -----------------------------------------------------------------
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20070608/c7f09b34/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20070608/c7f09b34/attachment.html</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023848.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
	<LI>Next message: <A HREF="023822.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23844">[ date ]</a>
              <a href="thread.html#23844">[ thread ]</a>
              <a href="subject.html#23844">[ subject ]</a>
              <a href="author.html#23844">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
