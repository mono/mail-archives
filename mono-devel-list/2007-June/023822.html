<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20PATCH%3A%20Make%20Process.Start%28%29%20use%20thesame%27mono%27runtime&In-Reply-To=29828-16732%40sneakemail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023844.html">
   <LINK REL="Next"  HREF="023800.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime</H1>
    <B>Miguel de Icaza</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20PATCH%3A%20Make%20Process.Start%28%29%20use%20thesame%27mono%27runtime&In-Reply-To=29828-16732%40sneakemail.com"
       TITLE="[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime">miguel at novell.com
       </A><BR>
    <I>Wed Jun  6 11:14:16 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="023844.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
        <LI>Next message: <A HREF="023800.html">[Mono-dev] PATCH: Make Process.Start() use the same 'mono'	runtime
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23822">[ date ]</a>
              <a href="thread.html#23822">[ thread ]</a>
              <a href="subject.html#23822">[ subject ]</a>
              <a href="author.html#23822">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

&gt;<i> This makes having 'mono' in $PATH an official requirement for mono to
</I>&gt;<i> operate correctly...
</I>
This is already a dependency anyways (CodeDOM and anything that uses
CodeDOM for example).

&gt;<i> As Robert Jordan pointed out, this means it will have no effect on Windows.
</I>&gt;<i> For this reason, and also because I prefer managed code, I've rewritten the
</I>&gt;<i> support into Process.Create (attached). You can choose which patch you wish
</I>&gt;<i> to apply :-) (I couldn't resist answering a question in a LAMESPEC comment
</I>&gt;<i> and correcting a minor error in another comment; you may split off or omit
</I>&gt;<i> those parts of the patch if you think they are inappropriately mixing
</I>&gt;<i> changes.)
</I>
Thanks, I'll investigate, but I rather have it in unmanaged land as it
will likely create less managed objects.

&gt;<i> But it is not inherited. If a tool is running a program which could
</I>&gt;<i> potentially spawn a child process, that child process could potentially not
</I>&gt;<i> start at all, or start with the wrong runtime. I mean, I think it's a fair
</I>&gt;<i> assumption that if anyone is using mono to run .NET apps on Windows,
</I>&gt;<i> they're doing it for a reason, and for that same reason they would want
</I>&gt;<i> child processes to also run under mono.
</I>
This one can go both ways, what if you really want to use .NET?

Introducing (a new one, in addition to the current one) environment
variable is not my idea of the code I want to maintain.

&gt;<i> The code in both patches is hereby officially licensed under the terms of
</I>&gt;<i> the MIT X11 license. :-)
</I>
Thanks!

&gt;<i> Enjoy,
</I>&gt;<i> 
</I>&gt;<i> Jonathan Gilbert
</I>&gt;<i> 
</I>&gt;<i> The below is for review only; please use the attached gzip when applying
</I>&gt;<i> the patch to your local source tree.
</I>&gt;<i> 
</I>&gt;<i> Index: class/System/System.Diagnostics/Process.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mcs/class/System/System.Diagnostics/Process.cs	(revision 78469)
</I>&gt;<i> +++ mcs/class/System/System.Diagnostics/Process.cs	(working copy)
</I>&gt;<i> @@ -248,6 +248,11 @@
</I>&gt;<i>  		private extern static bool SetWorkingSet_internal(IntPtr handle, int
</I>&gt;<i> min, int max, bool use_min);
</I>&gt;<i>  
</I>&gt;<i>  		/* LAMESPEC: why is this an IntPtr not a plain int? */
</I>&gt;<i> +		/* One might speculate that on Windows, the API call
</I>&gt;<i> +		 * used by MS.NET takes a 32-bit integer on 32-bit
</I>&gt;<i> +		 * platforms and a 64-bit integer on 64-bit platforms.
</I>&gt;<i> +		 * An IntPtr thereby automatically marshals correctly.
</I>&gt;<i> +		 */
</I>&gt;<i>  		[DesignerSerializationVisibility (DesignerSerializationVisibility.Hidden)]
</I>&gt;<i>  		[MonitoringDescription (&quot;The maximum working set for this process.&quot;)]
</I>&gt;<i>  		public IntPtr MaxWorkingSet {
</I>&gt;<i> @@ -725,7 +730,7 @@
</I>&gt;<i>  		[MethodImplAttribute(MethodImplOptions.InternalCall)]
</I>&gt;<i>  		extern static bool Kill_internal (IntPtr handle, int signo);
</I>&gt;<i>  
</I>&gt;<i> -		/* int kill -&gt; 1 KILL, 2 CloseMainWindow */
</I>&gt;<i> +		/* int signo -&gt; 1 KILL, 2 CloseMainWindow */
</I>&gt;<i>  		bool Close (int signo)
</I>&gt;<i>  		{
</I>&gt;<i>  			if (process_handle == IntPtr.Zero)
</I>&gt;<i> @@ -869,6 +874,293 @@
</I>&gt;<i>  								  IntPtr stderr,
</I>&gt;<i>  								  ref ProcInfo proc_info);
</I>&gt;<i>  
</I>&gt;<i> +		private static string shell_quote (string str)
</I>&gt;<i> +		{
</I>&gt;<i> +			StringBuilder ret = null;
</I>&gt;<i> +
</I>&gt;<i> +			for (int i=0; i &lt; str.Length; i++) {
</I>&gt;<i> +				switch (str [i])
</I>&gt;<i> +				{
</I>&gt;<i> +					case '!':
</I>&gt;<i> +					case '\'':
</I>&gt;<i> +					case '\\':
</I>&gt;<i> +					{
</I>&gt;<i> +						if (ret == null) {
</I>&gt;<i> +							ret = new StringBuilder (&quot;'&quot;);
</I>&gt;<i> +							ret.Append (str, 0, i);
</I>&gt;<i> +						}
</I>&gt;<i> +
</I>&gt;<i> +						ret.Append ('\\').Append (str, i, 1);
</I>&gt;<i> +
</I>&gt;<i> +						break;
</I>&gt;<i> +					}
</I>&gt;<i> +					default:
</I>&gt;<i> +					{
</I>&gt;<i> +						if (ret != null) {
</I>&gt;<i> +							ret.Append (str, i, 1);
</I>&gt;<i> +						}
</I>&gt;<i> +
</I>&gt;<i> +						break;
</I>&gt;<i> +					}
</I>&gt;<i> +				}
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			if (ret != null)
</I>&gt;<i> +				return ret.Append ('\'').ToString ();
</I>&gt;<i> +			else
</I>&gt;<i> +				return str;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		private static string unshellquote_extract_first_word (ref string args)
</I>&gt;<i> +		{
</I>&gt;<i> +			StringBuilder ret = new StringBuilder ();
</I>&gt;<i> +
</I>&gt;<i> +			int idx = 0;
</I>&gt;<i> +			while (idx &lt; args.Length) {
</I>&gt;<i> +				// If we've found the first whitespace dividing off the first word
</I>&gt;<i> +				// from the rest of the string, stop here, and update 'args' to
</I>&gt;<i> +				// match what we've pulled off so far.
</I>&gt;<i> +				if (char.IsWhiteSpace (args, idx)) {
</I>&gt;<i> +					args = args.Substring (idx + 1);
</I>&gt;<i> +					idx = 0;
</I>&gt;<i> +					break;
</I>&gt;<i> +				}
</I>&gt;<i> +
</I>&gt;<i> +				switch (args [idx])
</I>&gt;<i> +				{
</I>&gt;<i> +					case '\'':
</I>&gt;<i> +					case '&quot;':
</I>&gt;<i> +					{
</I>&gt;<i> +						char end_char = args [idx];
</I>&gt;<i> +
</I>&gt;<i> +						idx++;
</I>&gt;<i> +
</I>&gt;<i> +						while ((idx &lt; args.Length)
</I>&gt;<i> +						    &amp;&amp; (args[idx] != end_char)) {
</I>&gt;<i> +							if (args[idx] == '\\') {
</I>&gt;<i> +								idx++;
</I>&gt;<i> +								if (idx &gt;= args.Length) {
</I>&gt;<i> +									break;
</I>&gt;<i> +								}
</I>&gt;<i> +							}
</I>&gt;<i> +
</I>&gt;<i> +							ret.Append (args, idx, 1);
</I>&gt;<i> +
</I>&gt;<i> +							idx++;
</I>&gt;<i> +						}
</I>&gt;<i> +
</I>&gt;<i> +						idx++;
</I>&gt;<i> +
</I>&gt;<i> +						break;
</I>&gt;<i> +					}
</I>&gt;<i> +					case '`':
</I>&gt;<i> +					{
</I>&gt;<i> +						// If the user is asking the shell to insert the output
</I>&gt;<i> +						// of another command to find out what this command is
</I>&gt;<i> +						// going to be, we give up. Sorry :-)
</I>&gt;<i> +						return null;
</I>&gt;<i> +					}
</I>&gt;<i> +					default:
</I>&gt;<i> +					{
</I>&gt;<i> +						if (args[idx] == '\\') {
</I>&gt;<i> +							idx++;
</I>&gt;<i> +							if (idx &gt;= args.Length) {
</I>&gt;<i> +								break;
</I>&gt;<i> +							}
</I>&gt;<i> +						}
</I>&gt;<i> +
</I>&gt;<i> +						ret.Append (args, idx, 1);
</I>&gt;<i> +						idx++;
</I>&gt;<i> +
</I>&gt;<i> +						break;
</I>&gt;<i> +					}
</I>&gt;<i> +				}
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			// If we hit the end of the string before finding a word boundary,
</I>&gt;<i> +			// then there are no arguments after the first word.
</I>&gt;<i> +			if (idx &gt;= args.Length)
</I>&gt;<i> +				args = null;
</I>&gt;<i> +
</I>&gt;<i> +			return ret.ToString();
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		private static bool is_managed_binary (string filename)
</I>&gt;<i> +		{
</I>&gt;<i> +			try
</I>&gt;<i> +			{
</I>&gt;<i> +#if NET_2_0
</I>&gt;<i> +				using (FileStream stream = new FileStream (filename, FileMode.Open,
</I>&gt;<i> FileAccess.Read, FileShare.ReadWrite | FileShare.Delete))
</I>&gt;<i> +#else
</I>&gt;<i> +				using (FileStream stream = new FileStream (filename, FileMode.Open,
</I>&gt;<i> FileAccess.Read, FileShare.ReadWrite))
</I>&gt;<i> +#endif
</I>&gt;<i> +				{
</I>&gt;<i> +					// We know we need to read a header field at offset 60.
</I>&gt;<i> +					if (stream.Length &lt; 64)
</I>&gt;<i> +						return false;
</I>&gt;<i> +
</I>&gt;<i> +					byte[] buffer = new byte[8];
</I>&gt;<i> +					int num_read;
</I>&gt;<i> +
</I>&gt;<i> +					// Verify the MZ executable signature word.
</I>&gt;<i> +					num_read = stream.Read (buffer, 0, 2);
</I>&gt;<i> +
</I>&gt;<i> +					if ((num_read != 2)
</I>&gt;<i> +					 || (buffer[0] != (byte)'M')
</I>&gt;<i> +					 || (buffer[1] != (byte)'Z'))
</I>&gt;<i> +						return false;
</I>&gt;<i> +
</I>&gt;<i> +					// Get the offset of the PE header.
</I>&gt;<i> +					stream.Position = 60;
</I>&gt;<i> +
</I>&gt;<i> +					num_read = stream.Read (buffer, 0, 4);
</I>&gt;<i> +
</I>&gt;<i> +					if (num_read != 4)
</I>&gt;<i> +						return false;
</I>&gt;<i> +
</I>&gt;<i> +					int pe_header_offset = BitConverter.ToInt32 (buffer, 0);
</I>&gt;<i> +
</I>&gt;<i> +					if (pe_header_offset + 24 &gt; stream.Length)
</I>&gt;<i> +						return false;
</I>&gt;<i> +
</I>&gt;<i> +					// Verify that the header we've found is in fact the PE header.
</I>&gt;<i> +					stream.Position = pe_header_offset;
</I>&gt;<i> +
</I>&gt;<i> +					num_read = stream.Read (buffer, 0, 4);
</I>&gt;<i> +
</I>&gt;<i> +					if ((num_read != 4)
</I>&gt;<i> +					 || (buffer[0] != (byte)'P')
</I>&gt;<i> +					 || (buffer[1] != (byte)'E')
</I>&gt;<i> +					 || (buffer[2] != 0)
</I>&gt;<i> +					 || (buffer[3] != 0))
</I>&gt;<i> +						return false;
</I>&gt;<i> +
</I>&gt;<i> +					// Verify that the header we want in the optional header data
</I>&gt;<i> +					// is present in this binary.
</I>&gt;<i> +					stream.Position = pe_header_offset + 20;
</I>&gt;<i> +
</I>&gt;<i> +					num_read = stream.Read (buffer, 0, 2);
</I>&gt;<i> +
</I>&gt;<i> +					if ((num_read != 2)
</I>&gt;<i> +					 || (BitConverter.ToInt16 (buffer, 0) &lt; 216))
</I>&gt;<i> +						return false;
</I>&gt;<i> +
</I>&gt;<i> +					// Read the CLR header address and size fields. These will be
</I>&gt;<i> +					// zero if the binary is not managed.
</I>&gt;<i> +					int optional_header_offset = pe_header_offset + 24;
</I>&gt;<i> +
</I>&gt;<i> +					stream.Position = optional_header_offset + 208;
</I>&gt;<i> +
</I>&gt;<i> +					num_read = stream.Read (buffer, 0, 8);
</I>&gt;<i> +
</I>&gt;<i> +					// We are not concerned with endianness, only with
</I>&gt;<i> +					// whether it is zero or not.
</I>&gt;<i> +					int first_word = BitConverter.ToInt32 (buffer, 0);
</I>&gt;<i> +					int second_word = BitConverter.ToInt32 (buffer, 4);
</I>&gt;<i> +
</I>&gt;<i> +					if ((num_read != 8)
</I>&gt;<i> +					 || (first_word == 0)
</I>&gt;<i> +					 || (second_word == 0))
</I>&gt;<i> +						return false;
</I>&gt;<i> +
</I>&gt;<i> +					// If we get here without cacking, then in all likelihood
</I>&gt;<i> +					// we're looking at a CLR binary!
</I>&gt;<i> +					return true;
</I>&gt;<i> +				}
</I>&gt;<i> +			}
</I>&gt;<i> +			catch
</I>&gt;<i> +			{
</I>&gt;<i> +				// If anything at all goes wrong, then we cannot say that
</I>&gt;<i> +				// it is a managed binary.
</I>&gt;<i> +				return false;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		private static ProcessStartInfo redirect_for_managed_binary
</I>&gt;<i> (ProcessStartInfo start_info)
</I>&gt;<i> +		{
</I>&gt;<i> +			// Check if we have a MONOEXECUTABLE environment variable. If
</I>&gt;<i> +			// we don't, then there is no redirection to be done.
</I>&gt;<i> +			string mono_executable =
</I>&gt;<i> Environment.GetEnvironmentVariable(&quot;MONOEXECUTABLE&quot;);
</I>&gt;<i> +
</I>&gt;<i> +			if (mono_executable == null)
</I>&gt;<i> +				return start_info;
</I>&gt;<i> +
</I>&gt;<i> +			// Determine the target executable and the arguments being passed to it.
</I>&gt;<i> +			string application_filename = null, args = null;
</I>&gt;<i> +
</I>&gt;<i> +			if (start_info.FileName != null) {
</I>&gt;<i> +				application_filename = start_info.FileName;
</I>&gt;<i> +
</I>&gt;<i> +				if ((start_info.Arguments != null)
</I>&gt;<i> +				 &amp;&amp; (start_info.Arguments.Trim().Length &gt; 0)) {
</I>&gt;<i> +					args = start_info.Arguments;
</I>&gt;<i> +				}
</I>&gt;<i> +
</I>&gt;<i> +				// Fall back on treating the filename as the entire command-line
</I>&gt;<i> +				// if it is not (only) the name of an existing file.
</I>&gt;<i> +				if (!File.Exists (application_filename)) {
</I>&gt;<i> +					if (args != null) {
</I>&gt;<i> +						args = application_filename + ' ' + args;
</I>&gt;<i> +					} else {
</I>&gt;<i> +						args = application_filename;
</I>&gt;<i> +					}
</I>&gt;<i> +
</I>&gt;<i> +					application_filename = unshellquote_extract_first_word (ref args);
</I>&gt;<i> +				}
</I>&gt;<i> +			} else if (start_info.Arguments != null) {
</I>&gt;<i> +				args = start_info.Arguments.TrimStart();
</I>&gt;<i> +
</I>&gt;<i> +				application_filename = unshellquote_extract_first_word (ref args);
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			if (application_filename == null) {
</I>&gt;<i> +				return start_info;
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			bool need_redirect = is_managed_binary (application_filename);
</I>&gt;<i> +
</I>&gt;<i> +			// Determine whether we need a redirection.
</I>&gt;<i> +			if (!need_redirect) {
</I>&gt;<i> +				return start_info;
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			// If we need a redirection, build a new ProcessStartInfo and
</I>&gt;<i> +			// then alter just the parts we need. Otherwise, just return
</I>&gt;<i> +			// what we were passed.
</I>&gt;<i> +
</I>&gt;<i> +			ProcessStartInfo redirected = new ProcessStartInfo ();
</I>&gt;<i> +
</I>&gt;<i> +			// Copy over all of the values.
</I>&gt;<i> +			redirected.CreateNoWindow = start_info.CreateNoWindow;
</I>&gt;<i> +			redirected.ErrorDialog = start_info.ErrorDialog;
</I>&gt;<i> +			redirected.ErrorDialogParentHandle = start_info.ErrorDialogParentHandle;
</I>&gt;<i> +			redirected.RedirectStandardError = start_info.RedirectStandardError;
</I>&gt;<i> +			redirected.RedirectStandardInput = start_info.RedirectStandardInput;
</I>&gt;<i> +			redirected.RedirectStandardOutput = start_info.RedirectStandardOutput;
</I>&gt;<i> +			redirected.UseShellExecute = start_info.UseShellExecute;
</I>&gt;<i> +			redirected.Verb = start_info.Verb;
</I>&gt;<i> +			redirected.WindowStyle = start_info.WindowStyle;
</I>&gt;<i> +			redirected.WorkingDirectory = start_info.WorkingDirectory;
</I>&gt;<i> +
</I>&gt;<i> +			if (start_info.HaveEnvVars) {
</I>&gt;<i> +				foreach (DictionaryEntry variable in start_info.EnvironmentVariables) {
</I>&gt;<i> +					redirected.EnvironmentVariables [variable.Key.ToString()] =
</I>&gt;<i> variable.Value.ToString ();
</I>&gt;<i> +				}
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			// Set up the redirected ProcessStartInfo to run the
</I>&gt;<i> +			// application binary using the value of MONOEXECUTABLE.
</I>&gt;<i> +			redirected.FileName = mono_executable;
</I>&gt;<i> +
</I>&gt;<i> +			if (args != null) {
</I>&gt;<i> +				redirected.Arguments = shell_quote(application_filename) + ' ' + args;
</I>&gt;<i> +			} else {
</I>&gt;<i> +				redirected.Arguments = shell_quote(application_filename);
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			return redirected;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		private static bool Start_shell (ProcessStartInfo startInfo,
</I>&gt;<i>  						 Process process)
</I>&gt;<i>  		{
</I>&gt;<i> @@ -885,7 +1177,7 @@
</I>&gt;<i>  				throw new InvalidOperationException (&quot;UseShellExecute must be false in
</I>&gt;<i> order to use environment variables.&quot;);
</I>&gt;<i>  			}
</I>&gt;<i>  
</I>&gt;<i> -			ret = ShellExecuteEx_internal (startInfo,
</I>&gt;<i> +			ret = ShellExecuteEx_internal (redirect_for_managed_binary (startInfo),
</I>&gt;<i>  						       ref proc_info);
</I>&gt;<i>  			if (!ret) {
</I>&gt;<i>  				throw new Win32Exception (-proc_info.pid);
</I>&gt;<i> @@ -978,7 +1270,7 @@
</I>&gt;<i>  				stderr_wr = MonoIO.ConsoleError;
</I>&gt;<i>  			}
</I>&gt;<i>  			
</I>&gt;<i> -			ret = CreateProcess_internal (startInfo,
</I>&gt;<i> +			ret = CreateProcess_internal (redirect_for_managed_binary (startInfo),
</I>&gt;<i>  						      stdin_rd, stdout_wr, stderr_wr,
</I>&gt;<i>  						      ref proc_info);
</I>&gt;<i>  			if (!ret) {
</I>&gt;<i> 
</I>&gt;<i> Index: mono/mono/mini/driver.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- mono/mono/mini/driver.c	(revision 78469)
</I>&gt;<i> +++ mono/mono/mini/driver.c	(working copy)
</I>&gt;<i> @@ -49,6 +49,7 @@
</I>&gt;<i>  #include &quot;inssel.h&quot;
</I>&gt;<i>  #include &lt;locale.h&gt;
</I>&gt;<i>  #include &quot;version.h&quot;
</I>&gt;<i> +#include &lt;glib.h&gt;
</I>&gt;<i>  
</I>&gt;<i>  static FILE *mini_stats_fd = NULL;
</I>&gt;<i>  
</I>&gt;<i> @@ -671,6 +672,14 @@
</I>&gt;<i>  	&quot;\tDisabled:      &quot; DISABLED_FEATURES &quot;\n&quot;
</I>&gt;<i>  	&quot;&quot;;
</I>&gt;<i>  
</I>&gt;<i> +/*
</I>&gt;<i> + * If your platform lacks setenv/unsetenv, you must upgrade your glib.
</I>&gt;<i> + */
</I>&gt;<i> +#if !GLIB_CHECK_VERSION(2,4,0)
</I>&gt;<i> +#define g_setenv(a,b,c)   setenv(a,b,c)
</I>&gt;<i> +#define g_unsetenv(a) unsetenv(a)
</I>&gt;<i> +#endif
</I>&gt;<i> +
</I>&gt;<i>  int
</I>&gt;<i>  mono_main (int argc, char* argv[])
</I>&gt;<i>  {
</I>&gt;<i> @@ -717,6 +726,9 @@
</I>&gt;<i>  	g_log_set_always_fatal (G_LOG_LEVEL_ERROR);
</I>&gt;<i>  	g_log_set_fatal_mask (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR);
</I>&gt;<i>  
</I>&gt;<i> +	if ((argv [0] != NULL) &amp;&amp; (argv [0] [0] != 0))
</I>&gt;<i> +		g_setenv (&quot;MONOEXECUTABLE&quot;, argv [0], TRUE);
</I>&gt;<i> +
</I>&gt;<i>  	opt = parse_optimizations (NULL);
</I>&gt;<i>  
</I>&gt;<i>  	for (i = 1; i &lt; argc; ++i) {
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023844.html">[Mono-dev] PATCH: Make Process.Start() use thesame'mono'runtime
</A></li>
	<LI>Next message: <A HREF="023800.html">[Mono-dev] PATCH: Make Process.Start() use the same 'mono'	runtime
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23822">[ date ]</a>
              <a href="thread.html#23822">[ thread ]</a>
              <a href="subject.html#23822">[ subject ]</a>
              <a href="author.html#23822">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
