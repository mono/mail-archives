<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Dictionary`2: optimized and	serialization-compatible	with MS.net
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Dictionary%602%3A%20optimized%20and%09serialization-compatible%0A%09with%20MS.net&In-Reply-To=1181579248.3231.78.camel%40leonardo.hotfeet.ch">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023879.html">
   <LINK REL="Next"  HREF="023884.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Dictionary`2: optimized and	serialization-compatible	with MS.net</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Dictionary%602%3A%20optimized%20and%09serialization-compatible%0A%09with%20MS.net&In-Reply-To=1181579248.3231.78.camel%40leonardo.hotfeet.ch"
       TITLE="[Mono-dev] Dictionary`2: optimized and	serialization-compatible	with MS.net">lupus at ximian.com
       </A><BR>
    <I>Mon Jun 11 13:34:44 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="023879.html">[Mono-dev] Dictionary`2: optimized	and	serialization-compatible	with MS.net
</A></li>
        <LI>Next message: <A HREF="023884.html">[Mono-dev] Dictionary`2: optimized	and	serialization-compatible	with MS.net
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23880">[ date ]</a>
              <a href="thread.html#23880">[ thread ]</a>
              <a href="subject.html#23880">[ subject ]</a>
              <a href="author.html#23880">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 06/11/07 Juraj Skripsky wrote:
&gt;<i> I changed the code accordingly, getting rid of the hashcodes completely.
</I>&gt;<i> Unfortunately, the result of the change is a slow down which is often
</I>&gt;<i> considerable (especially for string keys):
</I>&gt;<i> 
</I>&gt;<i> Dictionary&lt;int, int&gt;:       6-12%
</I>&gt;<i> Dictionary&lt;double, double&gt;: 25-35%
</I>&gt;<i> Dictionary&lt;string, int&gt;:    30-80% *
</I>
Uhm, these results are similar to what you already posted with the
GetHashCode() calls included. They are suspicious: it means that
we have lots of collisions (bad hash functions) and/or the tests
involve lots of checks for presence that would fail and happen to hash
to the same bucket with different hashcodes. Can you post the test
cases?

&gt;<i> For key types with slow Equals() methods (e.g. String.Equals, whose
</I>&gt;<i> running time is proportional to the length of the matching substring),
</I>&gt;<i> the slow down will always be substantial.
</I>
As you pointed out, the Equals() methods will return at the first
difference, so if we see lots of Equals calls it is again an indication
of a poor hash function. I suspect some of the overhead is because of
the way hashtable and dictionary eventually call Equals...

&gt;<i> I would vote for keeping the hashcode around, as my guess (read: gut
</I>&gt;<i> feeling) for the average slow down in realistic scenarios would be
</I>&gt;<i> around 30%.
</I>
Well, if we exclude the rehash which shouldn't be a big deal, we have
two major cases: a hashtable hit and a hashtable miss.
A well-behaved hashtable will have no collisions or very few anyway
(I don't think it's worth optimizing for the worst case, we should try
to improve the hashing functions instead if that causes the issue).

So in the hit case we save an array element access, a compare/branch
and the need to keep the hashcode in a register (it's a value that gets
used in a loop and we try to use a register for it): so using hashcodes
here must be slower, even if just a bit.

In the miss case the hash code is only relevant if the bucket is not
empty and if the values stored there happen to generate different
hashcodes: keeping the hashcodes is a win in the miss case with
densely populated and relatively small hashtables (the bigger the hash
table the less likely two hash codes hit the same bucket while
being actually different).

So we have two different cases that favour two different
implementations (the first of which also have an advantage with memory
usage that doesn't show up in performance benchmarks).
Which of the two scenarios we should prefer is likely debatable:
some apps may have a large number of hits while others a large number of
misses. What are people's expectations here? Would you optimize for a
hit or for a miss in a hash table lookup?

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023879.html">[Mono-dev] Dictionary`2: optimized	and	serialization-compatible	with MS.net
</A></li>
	<LI>Next message: <A HREF="023884.html">[Mono-dev] Dictionary`2: optimized	and	serialization-compatible	with MS.net
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23880">[ date ]</a>
              <a href="thread.html#23880">[ thread ]</a>
              <a href="subject.html#23880">[ subject ]</a>
              <a href="author.html#23880">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
