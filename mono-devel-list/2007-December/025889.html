<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] String.GetHashCode()
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20String.GetHashCode%28%29&In-Reply-To=117799f00712011002qc94b7c5xd72eb49b999cd3e8%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025888.html">
   <LINK REL="Next"  HREF="025891.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] String.GetHashCode()</H1>
    <B>Steve Bjorg</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20String.GetHashCode%28%29&In-Reply-To=117799f00712011002qc94b7c5xd72eb49b999cd3e8%40mail.gmail.com"
       TITLE="[Mono-dev] String.GetHashCode()">steveb at mindtouch.com
       </A><BR>
    <I>Sat Dec  1 13:16:23 EST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="025888.html">[Mono-dev] String.GetHashCode()
</A></li>
        <LI>Next message: <A HREF="025891.html">[Mono-dev] String.GetHashCode()
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25889">[ date ]</a>
              <a href="thread.html#25889">[ thread ]</a>
              <a href="subject.html#25889">[ subject ]</a>
              <a href="author.html#25889">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>It doesn't make much sense to pre-compute the hashcode for a string  
whose length is not greater than the cacheline size.  Anything that  
fits into the cacheline and is not memory bound is plenty fast enough.

For the same reason, the size and hashcode of a string would need to  
be juxtaposed in memory to load both on first hit.  Otherwise, the  
benefits are again wiped out due to the high cost of loading data  
from memory into the cache.  If optimization at that level isn't  
interesting (b/c we talking nanoseconds in this realm), then the  
bound for N will go up quite quickly before a cached hashcode makes  
sense.  And as Robert so insightfully pointed out, strings for which  
a pre-computed hashcode might make sense may never be used as keys.   
Hence, the complexity increase in th string code -- and therefore  
quality control headache -- introduced by it might not be worth the  
effort.

Just some assembly hacker thoughts on the subject... :)


- Steve

--------------
Steve G. Bjorg
<A HREF="http://wiki.mindtouch.com">http://wiki.mindtouch.com</A>
<A HREF="http://wiki.opengarden.org">http://wiki.opengarden.org</A>


On Dec 1, 2007, at 10:02 AM, Alan McGovern wrote:

&gt;<i> Also, worst case scenario for a zero length string would mean a 22%  
</I>&gt;<i> increase, not a 100% increase as was said before.
</I>&gt;<i>
</I>&gt;<i> Alan.
</I>&gt;<i>
</I>&gt;<i> On Dec 1, 2007 6:01 PM, Alan McGovern &lt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">alan.mcgovern at gmail.com</A>&gt;  
</I>&gt;<i> wrote:
</I>&gt;<i> Well, 'N' could be computed by asking what percent bloat is 'OK' or  
</I>&gt;<i> it could be computed by asking 'What % speedup do we want to make  
</I>&gt;<i> this a worthwhile tradeoff'.
</I>&gt;<i>
</I>&gt;<i> Currently a string has these two fields, an int and a char. Add in  
</I>&gt;<i> the object overhead of (i think) 12 bytes per object, you're up to  
</I>&gt;<i> 18 bytes straight off for a zero length string. Lets assume that  
</I>&gt;<i> you're only going to precalculate the hashcode for strings greater  
</I>&gt;<i> than length 4.
</I>&gt;<i>
</I>&gt;<i> So, take the case of a string of length 5. This puts the size of  
</I>&gt;<i> the string at 18 + 5*2 = 28 bytes. Adding 4 bytes to this is 15%  
</I>&gt;<i> extra memory usage. As string length goes up, this % goes down.
</I>&gt;<i>
</I>&gt;<i> I'm unsure what % speedup precalculating the hashcode would result  
</I>&gt;<i> in, but i'm sure someone could run a few benchmarks if they have  
</I>&gt;<i> the time free. You could say that you want at least a 5x or maybe  
</I>&gt;<i> 10x improvement before it becomes worthwhile, this would then put a  
</I>&gt;<i> lower bound on the string length to make it worthwhile.
</I>&gt;<i>
</I>&gt;<i> Alan.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Dec 1, 2007 5:29 PM, Robert Jordan &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">robertj at gmx.net</A> &gt; wrote:
</I>&gt;<i> Hi Alan,
</I>&gt;<i>
</I>&gt;<i> Alan McGovern wrote:
</I>&gt;<i> &gt; Also, just looking at the string source a bit more closely, it has a
</I>&gt;<i> &gt; GetCaseInsensitiveHashcode method too, so i'd assume that would  
</I>&gt;<i> need to be
</I>&gt;<i> &gt; cached too which would mean 8 bytes would be needed. This  
</I>&gt;<i> wouldn't scale
</I>&gt;<i> &gt; well.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Fair enough. Twas just an idea.
</I>&gt;<i>
</I>&gt;<i> nah, don't give up too early! :) If the string is longer than &quot;n&quot;,
</I>&gt;<i> you could allocate 4 or even 8 additional bytes at the end of the
</I>&gt;<i> array for lazily computed hash codes.
</I>&gt;<i>
</I>&gt;<i> Open questions:
</I>&gt;<i>
</I>&gt;<i> - What's the optimal &quot;n&quot; for all common application classes
</I>&gt;<i>   mono is used for? :) It looks like it should be dynamically
</I>&gt;<i>   computed &amp; adjusted based on profiling data collected at
</I>&gt;<i>   runtime.
</I>&gt;<i>
</I>&gt;<i> - What's the real gain of this optimization? If &quot;n&quot; tends to
</I>&gt;<i>   be really large (say 1-4KB), what's the probability of
</I>&gt;<i>   such large strings being used as a hash key?
</I>&gt;<i>   This question can be reduced to &quot;how frequently is
</I>&gt;<i>   s.GetHashCode called, where s.Length &gt; n&quot;.
</I>&gt;<i>
</I>&gt;<i>   In mono's class libs sources there is only one place (I know
</I>&gt;<i>   of) where large strings are potentially hashed: Sys.Web's
</I>&gt;<i>   cache management.
</I>&gt;<i>
</I>&gt;<i> Robert
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20071201/1c181fe0/attachment.html">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20071201/1c181fe0/attachment.html</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="025888.html">[Mono-dev] String.GetHashCode()
</A></li>
	<LI>Next message: <A HREF="025891.html">[Mono-dev] String.GetHashCode()
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25889">[ date ]</a>
              <a href="thread.html#25889">[ thread ]</a>
              <a href="subject.html#25889">[ subject ]</a>
              <a href="author.html#25889">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
