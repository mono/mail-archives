<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Generics sharing issues
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Generics%20sharing%20issues&In-Reply-To=f54ff3e80712100413o663dcc3aqb9bd5ac9b2c63054%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026020.html">
   <LINK REL="Next"  HREF="026034.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Generics sharing issues</H1>
    <B>&#1178;&#593;&#1564;il &#2824; Skalski</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Generics%20sharing%20issues&In-Reply-To=f54ff3e80712100413o663dcc3aqb9bd5ac9b2c63054%40mail.gmail.com"
       TITLE="[Mono-dev] Generics sharing issues">kamil.skalski at gmail.com
       </A><BR>
    <I>Tue Dec 11 00:25:39 EST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="026020.html">[Mono-dev] Generics sharing issues
</A></li>
        <LI>Next message: <A HREF="026034.html">[Mono-dev] Generics sharing issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26030">[ date ]</a>
              <a href="thread.html#26030">[ thread ]</a>
              <a href="subject.html#26030">[ subject ]</a>
              <a href="author.html#26030">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>2007/12/10, Mark Probst &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mark.probst at gmail.com</A>&gt;:
&gt;<i> * Problems
</I>&gt;<i>
</I>&gt;<i> ** recursive generics
</I>&gt;<i>
</I>&gt;<i> A generic class or method might potentially lead to an infinite number
</I>&gt;<i> of type expansions.  Therefore type expansion must in some cases be
</I>&gt;<i> done lazily.
</I>&gt;<i>
</I>&gt;<i> *** superclasses
</I>&gt;<i>
</I>&gt;<i> class A&lt;T&gt;
</I>&gt;<i> class B&lt;T&gt; : A&lt;B&lt;B&lt;T&gt;&gt;&gt;
</I>
Just to note - specification explicitly states that all instantiations
must be finite. The above code is invalid (though csc has a bug
allowing it to compile, it will still fail in runtime on MS.NET).
The exact description is in ECMA 355 Part II 9.2  Generics and
recursive inheritance graphs

This probably does not help solving the problem, since runtime has no
way to easily detect the wrong cycles - the algorithm described in
spec seems a bit costy.

&gt;<i>
</I>&gt;<i> *** other types
</I>&gt;<i>
</I>&gt;<i> class A&lt;T&gt; {
</I>&gt;<i>   static void test (int n) {
</I>&gt;<i>     if (n &gt; 0)
</I>&gt;<i>       A&lt;A&lt;T&gt;&gt;.test (n - 1);
</I>&gt;<i>     else
</I>&gt;<i>       return;
</I>&gt;<i>   }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> ** interface calls
</I>&gt;<i>
</I>&gt;<i> To resolve an interface call we need the MonoMethod* of the interface
</I>&gt;<i> method.  It's not enough to have the open method because the class
</I>&gt;<i> might implement more than one generic instance of the interface.
</I>&gt;<i>
</I>&gt;<i> ** type argument slots must be superclass-compatible
</I>&gt;<i>
</I>&gt;<i> class A&lt;T&gt;
</I>&gt;<i> class B&lt;T&gt; : A&lt;List&lt;T&gt;&gt;
</I>&gt;<i>
</I>&gt;<i> For B&lt;string&gt;: A&lt;T&gt; assumes typeargs[0] to be string, but it will be
</I>&gt;<i> List&lt;string&gt; in out current implementation.
</I>&gt;<i>
</I>&gt;<i> ** even non-generic classes might need rgctx
</I>&gt;<i>
</I>&gt;<i> class A&lt;T&gt;
</I>&gt;<i> class B : A&lt;string&gt;
</I>&gt;<i>
</I>&gt;<i> B needs a rgctx!
</I>&gt;<i>
</I>&gt;<i> ** function pointers of static methods
</I>&gt;<i>
</I>&gt;<i> A static method of a generic type demands to be passed a rgctx pointer
</I>&gt;<i> as an implicit argument, while no such argument needs to be, or can
</I>&gt;<i> be, given when doing an indirect call using a function pointer.
</I>&gt;<i>
</I>&gt;<i> * Solutions
</I>&gt;<i>
</I>&gt;<i> ** lazy filling of rgctx
</I>&gt;<i>
</I>&gt;<i> We need to have the possibility of leaving fields in the rgctx null
</I>&gt;<i> and instantiate them lazily.  To that end we probably need a small
</I>&gt;<i> trampoline which is passed the rgctx and a location within it.  It has
</I>&gt;<i> to check whether the slot is already filled.  If it is it just returns
</I>&gt;<i> its value.  Otherwise it has to call an unmanaged function to compute
</I>&gt;<i> the slot value.
</I>&gt;<i>
</I>&gt;<i> *** maybe only in cases of increasing depth
</I>&gt;<i>
</I>&gt;<i> We can instantiate the types and fill the corresponding slots if we
</I>&gt;<i> know that doing so will not lead to endless recursion.  The simplest
</I>&gt;<i> heuristic for this is the depth of the type.  Since there is only a
</I>&gt;<i> finite number of types the recursion must terminate eventually (in
</I>&gt;<i> most non-contrived examples very quickly).  Example:
</I>&gt;<i>
</I>&gt;<i> class A&lt;T&gt; {
</I>&gt;<i>   static void test () {
</I>&gt;<i>     new B&lt;T&gt;;
</I>&gt;<i>     new C&lt;D&lt;T&gt;&gt;;
</I>&gt;<i>   }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> The slot for B&lt;T&gt; can be filled and fetching its value doesn't need
</I>&gt;<i> the trampoline, whereas the slot for C&lt;D&lt;T&gt;&gt; would be left empty and
</I>&gt;<i> filled lazily with the trampoline.
</I>&gt;<i>
</I>&gt;<i> ** put methods for interface calls in rgctx
</I>&gt;<i>
</I>&gt;<i> To resolve interface calls we put the MonoMethod pointers in the
</I>&gt;<i> rgctx.
</I>&gt;<i>
</I>&gt;<i> ** extensible rgctx
</I>&gt;<i>
</I>&gt;<i> We need to be able to extend a class's rgctx even after is has already
</I>&gt;<i> been created, to allow fast access to &quot;other&quot; types as well as to
</I>&gt;<i> interface methods (Do we really need extensibility for methods?  We
</I>&gt;<i> already know which interface methods a class provides when we init
</I>&gt;<i> it.).
</I>&gt;<i>
</I>&gt;<i> The extensible part of the rgctx can be a fixed number of slots with
</I>&gt;<i> one or more additional indirect slots.  We could have one indirect
</I>&gt;<i> slots which points to a reallocatable array, or a number of indirect
</I>&gt;<i> slots which point to lazily allocated fixed size arrays of increasing
</I>&gt;<i> size.
</I>&gt;<i>
</I>&gt;<i> *** layout must be compatible with superclasses
</I>&gt;<i>
</I>&gt;<i> As with the other parts of the rgctx, the extensible part must be
</I>&gt;<i> compatible with those of the class's superclasses.  One of the
</I>&gt;<i> consequence is that slots which are filled in a class must be marked
</I>&gt;<i> as not used but occupied in all its superclasses.  For example:
</I>&gt;<i>
</I>&gt;<i> class A&lt;T&gt;
</I>&gt;<i> class B&lt;T&gt; : A&lt;T&gt;
</I>&gt;<i>
</I>&gt;<i> Now we add the type C&lt;string&gt; to B&lt;string&gt;'s rgctx, at slot 0.  If we
</I>&gt;<i> do not mark this slot as occupied in A&lt;string&gt; then we might add
</I>&gt;<i> another type, say D&lt;string&gt; to A&lt;string&gt;'s rgctx at slot 0, which
</I>&gt;<i> would then require us to put D&lt;string&gt; into slot 0 B&lt;string&gt;'s rgctx,
</I>&gt;<i> because B&lt;string&gt;'s rgctx must be usable wherever A&lt;string&gt;'s rgctx is
</I>&gt;<i> usable.  Slot 0 is already occpuied by another type in B&lt;string&gt;,
</I>&gt;<i> though.
</I>&gt;<i>
</I>&gt;<i> *** extending existing rgctxs
</I>&gt;<i>
</I>&gt;<i> Depending on how we access the rgctx in the trampoline we could get
</I>&gt;<i> away with not extending already existing rgctxs.  First, all slots in
</I>&gt;<i> the extensible portion would have to be lazily filled.  We would also
</I>&gt;<i> need an additional null check for the indirect slot(s) and allocate
</I>&gt;<i> that lazily, too.  That would only work for fixed-size indirect
</I>&gt;<i> slot arrays, though.
</I>&gt;<i>
</I>&gt;<i> Alternatively we would have to keep track of all closed generic
</I>&gt;<i> classes for each open generic class and each time we occupy a new slot
</I>&gt;<i> in the extensible portion we would have to run through all of them and
</I>&gt;<i> fill the slot and/or (re)allocate the indirect slot arrays.  That
</I>&gt;<i> would obviate the need for the null check for indirect slots and would
</I>&gt;<i> also enable us to do eager allocation for slots where we may do so.
</I>&gt;<i>
</I>&gt;<i> *** need rgctx template
</I>&gt;<i>
</I>&gt;<i> To be able to manage the extending portion of the rgctx we need to
</I>&gt;<i> keep the layout of it for each open generic class.
</I>&gt;<i>
</I>&gt;<i> ** type argument slots
</I>&gt;<i>
</I>&gt;<i> Simplest solution: Separate slots for each class in the superclass
</I>&gt;<i> chain.
</I>&gt;<i>
</I>&gt;<i> In most cases they probably overlap, so try to reuse slots.
</I>&gt;<i>
</I>&gt;<i> ** taking the function pointer of a static method
</I>&gt;<i>
</I>&gt;<i> We will need to provide a pointer to a stub when taking the function
</I>&gt;<i> pointer, which adds the rgctx pointer as the implicit argument.  We
</I>&gt;<i> must make sure to create a stub at most once, otherwise we'll leak
</I>&gt;<i> memory.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Mark
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>

-- 
Kamil Skalski
<A HREF="http://nazgul.omega.pl">http://nazgul.omega.pl</A>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026020.html">[Mono-dev] Generics sharing issues
</A></li>
	<LI>Next message: <A HREF="026034.html">[Mono-dev] Generics sharing issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26030">[ date ]</a>
              <a href="thread.html#26030">[ thread ]</a>
              <a href="subject.html#26030">[ subject ]</a>
              <a href="author.html#26030">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
