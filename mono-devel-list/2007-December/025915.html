<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] String.GetHashCode()
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20String.GetHashCode%28%29&In-Reply-To=firnvm%24btl%241%40ger.gmane.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025880.html">
   <LINK REL="Next"  HREF="025881.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] String.GetHashCode()</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20String.GetHashCode%28%29&In-Reply-To=firnvm%24btl%241%40ger.gmane.org"
       TITLE="[Mono-dev] String.GetHashCode()">lupus at ximian.com
       </A><BR>
    <I>Mon Dec  3 08:13:32 EST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="025880.html">[Mono-dev] String.GetHashCode()
</A></li>
        <LI>Next message: <A HREF="025881.html">[Mono-dev] String.GetHashCode()
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25915">[ date ]</a>
              <a href="thread.html#25915">[ thread ]</a>
              <a href="subject.html#25915">[ subject ]</a>
              <a href="author.html#25915">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 12/01/07 Robert Jordan wrote:
&gt;<i> &gt; Since strings are immutable, shouldn't it be possible to compute the
</I>&gt;<i> &gt; hashcode once and store it rather than recomputing it over and over again?
</I>&gt;<i> &gt; Is there some really obvious reason that i can't think of that would make
</I>&gt;<i> &gt; this a bad idea?
</I>&gt;<i> 
</I>&gt;<i> This idea already came up a couple of years ago (2002 or so).
</I>[...]
&gt;<i> Therefore, the optimization should consider the string length
</I>&gt;<i> and append the hash code after the string's bytes
</I>&gt;<i> only if its length is greater than some amount (1K or so).
</I>
I'll reply to this mail and try to summarize all the responses and
the constraints we need to obey.

1) we can't change the C-side MonoString struct, because it is part of
the Mono ABI
2) we should try to not increase memory usage
3) we should try to not slowdown the case were the hashcode is
calculated for the first time on a string instance
4) we can't use utf8 to hold string chars because this would break
the mscorlib/CLI ABI (see how fixed on a string is compiled by the C#
compiler, for example)
5) GetHashCode should never be called for a string that is not yet
fully built (like in StringBuilder), so there is no worry aout the
string changing after the hash code field has been set

Point 1 means that if we were to add a new field to the string it can
only be added at the end, after the character data (and the terminating
null char). This also means that if we use an int, we have to be careful
and properly align it (this also means more instructions to access this
field).

About memory usage: objects in Mono are always aligned on 8 byte
boundaries so in some cases the overhead is 50%, 33%, 25%, 20%
(for strings up to 15 chars) and sometimes it is 0. I would
say that, as a mean, the memory overhead is 15% for up to 20 chars,
5% for up to 100 chars and it doesn't matter above that.

After having written the moving GC, where fast computing of an object's
size is important, I would also try to avoid allocating the extra field
only for big strings (this would also slowdown string allocation
somewhat).

So, given the above constraints and considerations, I suggest the
following:
1) wait for the moving GC to become the default: in that case we can use
the same mechanism used to store object hash codes in the object header:
this means no extra memory usage for strings and just a small slowdown
when inserting the hashcode in the header (it needs a locked op).
Implementing this mechanism with the current GC would slowdown a bit
some common operations (lock/unlock), with the moving GC we would take
the hit anyway.
2) in alternative, use a 16 bit hash code field: the memory overhead is
smaller (5-10% for up to 20 chars, 2-3% for up to 100 chars on average),
it requires no alignment calculation so it's fast to access. The
drawback is that for very big hashtables (&gt; 100 K entries) we'd have few
bits. A cheap way to increase bits would be to or the hash with the
first char shifted left 16 bits (but this wouldn't solve the issue for
strings all beginning with the same char). I'm sure this drawback is not
very significant, but I'm also sure someone will write a specific
benchmark to exploit this weakness and whine in some blog or on the list
about it:)

2 is very simple to implement so we could easily get some numbers (hint, hint).

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="025880.html">[Mono-dev] String.GetHashCode()
</A></li>
	<LI>Next message: <A HREF="025881.html">[Mono-dev] String.GetHashCode()
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25915">[ date ]</a>
              <a href="thread.html#25915">[ thread ]</a>
              <a href="subject.html#25915">[ subject ]</a>
              <a href="author.html#25915">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
