<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Embedding Mono in a Virtual World
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Embedding%20Mono%20in%20a%20Virtual%20World&In-Reply-To=20050209180632.1901.qmail%40web25007.mail.ukl.yahoo.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010366.html">
   <LINK REL="Next"  HREF="010413.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Embedding Mono in a Virtual World</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Embedding%20Mono%20in%20a%20Virtual%20World&In-Reply-To=20050209180632.1901.qmail%40web25007.mail.ukl.yahoo.com"
       TITLE="[Mono-devel-list] Embedding Mono in a Virtual World">lupus at ximian.com
       </A><BR>
    <I>Thu Feb 10 13:59:18 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="010366.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
        <LI>Next message: <A HREF="010413.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10395">[ date ]</a>
              <a href="thread.html#10395">[ thread ]</a>
              <a href="subject.html#10395">[ subject ]</a>
              <a href="author.html#10395">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 02/09/05 Jim Purbrick wrote:
&gt;<i> I've started trying this approach out using yields and
</I>&gt;<i> think it might well work, although with yields strange
</I>&gt;<i> things happen mixing them with recursion. I'm not sure
</I>&gt;<i> how generally a call graph can be mapped to a state
</I>&gt;<i> machine, especially in the presence of recursion.
</I>&gt;<i> 
</I>&gt;<i> The easiest way to represent the information would be
</I>&gt;<i> to build a stack for each script, but could I mess
</I>&gt;<i> with the stack pointer to switch stacks or would I
</I>&gt;<i> have to emulate a stack using heaps and would that be
</I>&gt;<i> horribly inefficient?
</I>
Not orrible but not very nice either.

&gt;<i> I keep coming back to the idea that what I really want
</I>&gt;<i> is a light weight user threads library. I've seen some
</I>&gt;<i> stuff about people using Win32 fibers to run managed
</I>&gt;<i> code. Would it be possible to use a Linux light weight
</I>&gt;<i> threads library in a similar way?
</I>
I have no idea what fibers are and how this would interact
with the GC and other info the runtime keeps per-thread.
It would likely require quite a bit of work and debugging.

&gt;<i> &gt; *) use the threadpool as initially suggested: you
</I>&gt;<i> &gt; will queue all the scripts for execution.
</I>&gt;<i> 
</I>&gt;<i> I looked at this approach and implemented a simple
</I>&gt;<i> test app which used Abort and ResetAbort to cancel
</I>&gt;<i> processing after some timeout. While this would stop
</I>&gt;<i> DOS attacks it would also cancel arbitrarily long
</I>&gt;<i> valid processing, which is not the current model and
</I>&gt;<i> so not acceptable.
</I>
Another option you might want to investigate is to use
Thread.Suspend (). You'd have a control thread and you'd
hand out the scripts to execute to a single worker
thread and wait for a timeout. If the script didn't finish, the
thread is suspended and put on a fifo to be resumed later
when you decide it's time to do it. Otherwise the timeout is
reset and you make the thread execute another script.
This is likely an implementation similar to your current code.
The tricky issue here is the exact time you suspend and long
running script. This is likely to cause deadlocks if not
handled carefully. It should be pretty safe if you inject
in the user code checks for a global var that signals the event:

	// user code
	while (true) {
		// do expensive calc
		....
		// code injected by the compiler
		if (suspend_flag)
			CurrentThread.Suspend ();
	}

A volatile read is needed so the jit won't optimize it out of the loop.
The Suspend method is marked obsolete in 2.0, because of the potential
for deadlocks, but using it this way should be safe.
Since most of the scripts should terminate within the timeout, if I
understood correctly, you should just have a number of threads
created as many as the slow scripts and I guess in your current system
you already don't call again a script if it didn't finish it's work
in the previous run.
Hope this helps.

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010366.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
	<LI>Next message: <A HREF="010413.html">[Mono-devel-list] Embedding Mono in a Virtual World
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10395">[ date ]</a>
              <a href="thread.html#10395">[ thread ]</a>
              <a href="subject.html#10395">[ subject ]</a>
              <a href="author.html#10395">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
