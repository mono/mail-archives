<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [PATCH] DataTable.WriteXml
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20DataTable.WriteXml&In-Reply-To=45215C30.9050202%40advmeas.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020721.html">
   <LINK REL="Next"  HREF="020720.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [PATCH] DataTable.WriteXml</H1>
    <B>Nagappan</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BPATCH%5D%20DataTable.WriteXml&In-Reply-To=45215C30.9050202%40advmeas.com"
       TITLE="[Mono-dev] [PATCH] DataTable.WriteXml">anagappan at novell.com
       </A><BR>
    <I>Fri Oct  6 06:10:59 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="020721.html">[Mono-dev] [PATCH] DataTable.WriteXml
</A></li>
        <LI>Next message: <A HREF="020720.html">[Mono-dev] Mono Meeting: Venue Update, second update.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20800">[ date ]</a>
              <a href="thread.html#20800">[ thread ]</a>
              <a href="subject.html#20800">[ subject ]</a>
              <a href="author.html#20800">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Patrick,
The patch looks fine, but it doesn't apply with the latest SVN. Can you
make a new patch and send it across.

Thanks
Nagappan

Patrick Earl wrote:
&gt;<i> I've implemented the WriteXml method for System.Data.DataTable. Since
</I>&gt;<i> writing a table is similar to writing a DataSet, it leverages many of
</I>&gt;<i> the methods used to write DataSets. Included with the patch are a
</I>&gt;<i> successful unit test for the new WriteXml functionality and a failing
</I>&gt;<i> unit test for ReadXml, which has not yet been implemented. The patch
</I>&gt;<i> caused no regressions in the System.Data net_2_0 test suite.
</I>&gt;<i>
</I>&gt;<i> The patch applies against the mcs/class/System.Data folder in the
</I>&gt;<i> latest SVN revision (66162 as of this message).
</I>&gt;<i>
</I>&gt;<i> This is my first substantial contribution, so I'm happy to get
</I>&gt;<i> feedback on it. Thanks.
</I>&gt;<i>
</I>&gt;<i> Patrick Earl
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Index: Test/System.Data/ChangeLog
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Test/System.Data/ChangeLog	(revision 66162)
</I>&gt;<i> +++ Test/System.Data/ChangeLog	(working copy)
</I>&gt;<i> @@ -1,3 +1,9 @@
</I>&gt;<i> +2006-09-28  Patrick Earl &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono at patearl.net</A>&gt;
</I>&gt;<i> +
</I>&gt;<i> +	* DataTableReadWriteXml.cs: Added new tests for the DataTable's
</I>&gt;<i> +	ReadXml and WriteXml methods.  These tests assume proper
</I>&gt;<i> +	functioning of the DataSet ReadXml and WriteXml methods.
</I>&gt;<i> +
</I>&gt;<i>  2006-09-18	Boris Kirzner &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">borisk at mainsoft.com</A>&gt;
</I>&gt;<i>  
</I>&gt;<i>  	* DataViewTest.cs : fix compilation error.
</I>&gt;<i> Index: Test/System.Data/DataTableReadWriteXmlTest.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Test/System.Data/DataTableReadWriteXmlTest.cs	(revision 0)
</I>&gt;<i> +++ Test/System.Data/DataTableReadWriteXmlTest.cs	(revision 0)
</I>&gt;<i> @@ -0,0 +1,373 @@
</I>&gt;<i> +&#239;&#187;&#191;// Author:
</I>&gt;<i> +//   Patrick Earl &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono at patearl.net</A>&gt;
</I>&gt;<i> +//
</I>&gt;<i> +// Copyright (c) 2006
</I>&gt;<i> +//
</I>&gt;<i> +// Permission is hereby granted, free of charge, to any person obtaining
</I>&gt;<i> +// a copy of this software and associated documentation files (the
</I>&gt;<i> +// &quot;Software&quot;), to deal in the Software without restriction, including
</I>&gt;<i> +// without limitation the rights to use, copy, modify, merge, publish,
</I>&gt;<i> +// distribute, sublicense, and/or sell copies of the Software, and to
</I>&gt;<i> +// permit persons to whom the Software is furnished to do so, subject to
</I>&gt;<i> +// the following conditions:
</I>&gt;<i> +//
</I>&gt;<i> +// The above copyright notice and this permission notice shall be
</I>&gt;<i> +// included in all copies or substantial portions of the Software.
</I>&gt;<i> +//
</I>&gt;<i> +// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
</I>&gt;<i> +// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
</I>&gt;<i> +// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
</I>&gt;<i> +// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
</I>&gt;<i> +// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
</I>&gt;<i> +// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
</I>&gt;<i> +// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</I>&gt;<i> +//
</I>&gt;<i> +
</I>&gt;<i> +#if NET_2_0
</I>&gt;<i> +using System;
</I>&gt;<i> +using System.Data;
</I>&gt;<i> +using System.IO;
</I>&gt;<i> +using System.Text.RegularExpressions;
</I>&gt;<i> +using System.Xml;
</I>&gt;<i> +using NUnit.Framework; 
</I>&gt;<i> +
</I>&gt;<i> +namespace MonoTests.System.Data
</I>&gt;<i> +{
</I>&gt;<i> +    [TestFixture]
</I>&gt;<i> +    public class DataTableReadWriteXmlTest
</I>&gt;<i> +    {
</I>&gt;<i> +        void StandardizeXmlFormat(ref string xml)
</I>&gt;<i> +        {
</I>&gt;<i> +            XmlDocument doc = new XmlDocument();
</I>&gt;<i> +            doc.LoadXml(xml);
</I>&gt;<i> +            StringWriter sw = new StringWriter();
</I>&gt;<i> +            doc.Save(sw);
</I>&gt;<i> +            xml = sw.ToString();
</I>&gt;<i> +        }
</I>&gt;<i> +        
</I>&gt;<i> +        void GenerateTestData(out DataSet ds,
</I>&gt;<i> +                              out DataTable dtMainInDS,
</I>&gt;<i> +                              out DataTable dtChildInDS,
</I>&gt;<i> +                              out DataTable dtMain)
</I>&gt;<i> +        {
</I>&gt;<i> +            ds = new DataSet(&quot;MyDataSet&quot;);
</I>&gt;<i> +
</I>&gt;<i> +            // Create a primary table and populate it with some data.  Make a
</I>&gt;<i> +            // copy of the primary table and put it into the dataset.
</I>&gt;<i> +            dtMain = new DataTable(&quot;Main&quot;);
</I>&gt;<i> +            dtMain.Columns.Add(new DataColumn(&quot;ID&quot;, typeof(int)));
</I>&gt;<i> +            dtMain.Columns.Add(new DataColumn(&quot;Data&quot;, typeof(string)));
</I>&gt;<i> +            
</I>&gt;<i> +            DataRow row = dtMain.NewRow();
</I>&gt;<i> +            row[&quot;ID&quot;] = 1;
</I>&gt;<i> +            row[&quot;Data&quot;] = &quot;One&quot;;
</I>&gt;<i> +            dtMain.Rows.Add(row);
</I>&gt;<i> +            
</I>&gt;<i> +            row = dtMain.NewRow();
</I>&gt;<i> +            row[&quot;ID&quot;] = 2;
</I>&gt;<i> +            row[&quot;Data&quot;] = &quot;Two&quot;;
</I>&gt;<i> +            dtMain.Rows.Add(row);
</I>&gt;<i> +            
</I>&gt;<i> +            row = dtMain.NewRow();
</I>&gt;<i> +            row[&quot;ID&quot;] = 3;
</I>&gt;<i> +            row[&quot;Data&quot;] = &quot;Three&quot;;
</I>&gt;<i> +            dtMain.Rows.Add(row);
</I>&gt;<i> +            
</I>&gt;<i> +            dtMainInDS = dtMain.Copy();
</I>&gt;<i> +            ds.Tables.Add(dtMainInDS);
</I>&gt;<i> +            
</I>&gt;<i> +            // Create a child table.  Make a copy of the child table and put
</I>&gt;<i> +            // it into the dataset.
</I>&gt;<i> +            dtChildInDS = new DataTable(&quot;Child&quot;);
</I>&gt;<i> +            dtChildInDS.Columns.Add(new DataColumn(&quot;ID&quot;, typeof(int)));
</I>&gt;<i> +            dtChildInDS.Columns.Add(new DataColumn(&quot;PID&quot;, typeof(int)));
</I>&gt;<i> +            dtChildInDS.Columns.Add(new DataColumn(&quot;ChildData&quot;, typeof(string)));
</I>&gt;<i> +            
</I>&gt;<i> +            row = dtChildInDS.NewRow();
</I>&gt;<i> +            row[&quot;ID&quot;] = 1;
</I>&gt;<i> +            row[&quot;PID&quot;] = 1;
</I>&gt;<i> +            row[&quot;ChildData&quot;] = &quot;Parent1Child1&quot;;
</I>&gt;<i> +            dtChildInDS.Rows.Add(row);
</I>&gt;<i> +            
</I>&gt;<i> +            row = dtChildInDS.NewRow();
</I>&gt;<i> +            row[&quot;ID&quot;] = 2;
</I>&gt;<i> +            row[&quot;PID&quot;] = 1;
</I>&gt;<i> +            row[&quot;ChildData&quot;] = &quot;Parent1Child2&quot;;
</I>&gt;<i> +            dtChildInDS.Rows.Add(row);
</I>&gt;<i> +            
</I>&gt;<i> +            row = dtChildInDS.NewRow();
</I>&gt;<i> +            row[&quot;ID&quot;] = 3;
</I>&gt;<i> +            row[&quot;PID&quot;] = 2;
</I>&gt;<i> +            row[&quot;ChildData&quot;] = &quot;Parent2Child3&quot;;
</I>&gt;<i> +            dtChildInDS.Rows.Add(row);
</I>&gt;<i> +            
</I>&gt;<i> +            ds.Tables.Add(dtChildInDS);
</I>&gt;<i> +            
</I>&gt;<i> +            // Set up the relation in the dataset.
</I>&gt;<i> +            ds.Relations.Add(new DataRelation(&quot;MainToChild&quot;,
</I>&gt;<i> +                                              dtMainInDS.Columns[&quot;ID&quot;],
</I>&gt;<i> +                                              dtChildInDS.Columns[&quot;PID&quot;]));
</I>&gt;<i> +        }
</I>&gt;<i> +        
</I>&gt;<i> +        [Test]
</I>&gt;<i> +        public void TestWriteXml()
</I>&gt;<i> +        {
</I>&gt;<i> +            DataSet ds;
</I>&gt;<i> +            DataTable dtMainInDS, dtChildInDS, dtMain;
</I>&gt;<i> +            
</I>&gt;<i> +            GenerateTestData(out ds,
</I>&gt;<i> +                             out dtMainInDS,
</I>&gt;<i> +                             out dtChildInDS,
</I>&gt;<i> +                             out dtMain);
</I>&gt;<i> +            
</I>&gt;<i> +            StringWriter sw = new StringWriter();
</I>&gt;<i> +            
</I>&gt;<i> +            // Get XML for DataSet writes.
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            ds.WriteXml(sw);
</I>&gt;<i> +            string xmlDSNone = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            ds.WriteXml(sw, XmlWriteMode.DiffGram);
</I>&gt;<i> +            string xmlDSDiffGram = sw.ToString();
</I>&gt;<i> +
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            ds.WriteXml(sw, XmlWriteMode.WriteSchema);
</I>&gt;<i> +            string xmlDSWriteSchema = sw.ToString();
</I>&gt;<i> +
</I>&gt;<i> +            // Get XML for recursive DataTable writes of the same data as in
</I>&gt;<i> +            // the DataSet.
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMainInDS.WriteXml(sw, true);
</I>&gt;<i> +            string xmlDTNone = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMainInDS.WriteXml(sw, XmlWriteMode.DiffGram, true);
</I>&gt;<i> +            string xmlDTDiffGram = sw.ToString();
</I>&gt;<i> +
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMainInDS.WriteXml(sw, XmlWriteMode.WriteSchema, true);
</I>&gt;<i> +            string xmlDTWriteSchema = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            // The schema XML written by the DataTable call has an extra element
</I>&gt;<i> +            // in the element for the dataset schema definition.  We remove that
</I>&gt;<i> +            // extra attribute and then check to see if the rest of the xml is
</I>&gt;<i> +            // identical.
</I>&gt;<i> +            XmlDocument doc = new XmlDocument();
</I>&gt;<i> +            doc.LoadXml(xmlDTWriteSchema);
</I>&gt;<i> +            XmlNode node = doc.DocumentElement.FirstChild.FirstChild;
</I>&gt;<i> +            XmlAttribute a = (XmlAttribute)node.Attributes.GetNamedItem(&quot;msdata:MainDataTable&quot;);
</I>&gt;<i> +            Assert.IsNotNull(a, &quot;Test#01&quot;);
</I>&gt;<i> +            Assert.AreEqual(&quot;Main&quot;, a.Value, &quot;Test#02&quot;);
</I>&gt;<i> +            
</I>&gt;<i> +            node.Attributes.Remove(a);
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            doc.Save(sw);
</I>&gt;<i> +            xmlDTWriteSchema = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            StandardizeXmlFormat(ref xmlDSWriteSchema);
</I>&gt;<i> +            
</I>&gt;<i> +            Assert.AreEqual(xmlDSNone, xmlDTNone, &quot;Test#03&quot;);
</I>&gt;<i> +            Assert.AreEqual(xmlDSDiffGram, xmlDTDiffGram, &quot;Test#04&quot;);
</I>&gt;<i> +            Assert.AreEqual(xmlDSWriteSchema, xmlDTWriteSchema, &quot;Test#05&quot;);
</I>&gt;<i> +                               
</I>&gt;<i> +            // Now that we've tested writing tables (including children),
</I>&gt;<i> +            // we will go on to test the cases where the hierarchy flag
</I>&gt;<i> +            // is false.  For this, we will test one table inside the
</I>&gt;<i> +            // dataset and one table outside the dataset.
</I>&gt;<i> +            
</I>&gt;<i> +            // First, we fix our test DataSet to only have a single table
</I>&gt;<i> +            // with no relations.  Then, we go about comparing the XML.
</I>&gt;<i> +            // Get XML for DataSet writes.
</I>&gt;<i> +            ds.Tables[1].Constraints.Remove(ds.Tables[1].Constraints[0]);
</I>&gt;<i> +            ds.Tables[0].Constraints.Remove(ds.Tables[0].Constraints[0]);
</I>&gt;<i> +            ds.Tables[0].ChildRelations.Remove(&quot;MainToChild&quot;);
</I>&gt;<i> +            ds.Tables.Remove(&quot;Child&quot;);
</I>&gt;<i> +            
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            ds.WriteXml(sw);
</I>&gt;<i> +            xmlDSNone = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            ds.WriteXml(sw, XmlWriteMode.DiffGram);
</I>&gt;<i> +            xmlDSDiffGram = sw.ToString();
</I>&gt;<i> +
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            ds.WriteXml(sw, XmlWriteMode.WriteSchema);
</I>&gt;<i> +            xmlDSWriteSchema = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            // Get all the DataTable.WriteXml results.
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMainInDS.WriteXml(sw);
</I>&gt;<i> +            string xmlDTNoneInDS = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMainInDS.WriteXml(sw, XmlWriteMode.DiffGram);
</I>&gt;<i> +            string xmlDTDiffGramInDS = sw.ToString();
</I>&gt;<i> +
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMainInDS.WriteXml(sw, XmlWriteMode.WriteSchema);
</I>&gt;<i> +            string xmlDTWriteSchemaInDS = sw.ToString();
</I>&gt;<i> +
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMain.WriteXml(sw);
</I>&gt;<i> +            string xmlDTNoneNoDS = sw.ToString();
</I>&gt;<i> +
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMain.WriteXml(sw, XmlWriteMode.DiffGram);
</I>&gt;<i> +            string xmlDTDiffGramNoDS = sw.ToString();
</I>&gt;<i> +
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMain.WriteXml(sw, XmlWriteMode.WriteSchema);
</I>&gt;<i> +            string xmlDTWriteSchemaNoDS = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            Assert.AreEqual(xmlDSNone, xmlDTNoneInDS, &quot;Test#06&quot;);
</I>&gt;<i> +
</I>&gt;<i> +            // The only difference between the xml output from inside the
</I>&gt;<i> +            // dataset and the xml output from outside the dataset is that
</I>&gt;<i> +            // there's a fake &lt;DocumentElement&gt; tag surrounding tbe table
</I>&gt;<i> +            // in the second case.  We replace it with the name of the
</I>&gt;<i> +            // dataset for testing purposes.
</I>&gt;<i> +            doc.LoadXml(xmlDTNoneNoDS);
</I>&gt;<i> +            Assert.AreEqual(&quot;DocumentElement&quot;, doc.DocumentElement.Name, &quot;Test#07&quot;);
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            doc.Save(sw);
</I>&gt;<i> +            xmlDTNoneNoDS = sw.ToString();
</I>&gt;<i> +            xmlDTNoneNoDS = xmlDTNoneNoDS.Replace(&quot;&lt;DocumentElement&gt;&quot;, &quot;&lt;MyDataSet&gt;&quot;);
</I>&gt;<i> +            xmlDTNoneNoDS = xmlDTNoneNoDS.Replace(&quot;&lt;/DocumentElement&gt;&quot;, &quot;&lt;/MyDataSet&gt;&quot;);
</I>&gt;<i> +            
</I>&gt;<i> +            StandardizeXmlFormat(ref xmlDSNone);
</I>&gt;<i> +            
</I>&gt;<i> +            Assert.AreEqual(xmlDSNone, xmlDTNoneNoDS, &quot;Test#08&quot;);
</I>&gt;<i> +            
</I>&gt;<i> +            // Now check the DiffGram.
</I>&gt;<i> +            Assert.AreEqual(xmlDSDiffGram, xmlDTDiffGramInDS, &quot;Test#09&quot;);
</I>&gt;<i> +            
</I>&gt;<i> +            doc.LoadXml(xmlDTDiffGramNoDS);
</I>&gt;<i> +            Assert.AreEqual(&quot;DocumentElement&quot;, doc.DocumentElement.FirstChild.Name, &quot;Test#10&quot;);
</I>&gt;<i> +            xmlDTDiffGramNoDS = xmlDTDiffGramNoDS.Replace(&quot;&lt;DocumentElement&gt;&quot;, &quot;&lt;MyDataSet&gt;&quot;);
</I>&gt;<i> +            xmlDTDiffGramNoDS = xmlDTDiffGramNoDS.Replace(&quot;&lt;/DocumentElement&gt;&quot;, &quot;&lt;/MyDataSet&gt;&quot;);
</I>&gt;<i> +
</I>&gt;<i> +            Assert.AreEqual(xmlDSDiffGram, xmlDTDiffGramNoDS, &quot;Test#11&quot;);
</I>&gt;<i> +            
</I>&gt;<i> +            // Finally we check the WriteSchema version of the data.  First
</I>&gt;<i> +            // we remove the extra &quot;msdata:MainDataTable&quot; attribute from
</I>&gt;<i> +            // the schema declaration part of the DataTable xml.
</I>&gt;<i> +            doc = new XmlDocument();
</I>&gt;<i> +            doc.LoadXml(xmlDTWriteSchemaInDS);
</I>&gt;<i> +            node = doc.DocumentElement.FirstChild.FirstChild;
</I>&gt;<i> +            a = (XmlAttribute)node.Attributes.GetNamedItem(&quot;msdata:MainDataTable&quot;);
</I>&gt;<i> +            Assert.IsNotNull(a, &quot;Test#12&quot;);
</I>&gt;<i> +            Assert.AreEqual(&quot;Main&quot;, a.Value, &quot;Test#13&quot;);
</I>&gt;<i> +            node.Attributes.Remove(a);
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            doc.Save(sw);
</I>&gt;<i> +            xmlDTWriteSchemaInDS = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            StandardizeXmlFormat(ref xmlDSWriteSchema);
</I>&gt;<i> +
</I>&gt;<i> +            Assert.AreEqual(xmlDSWriteSchema, xmlDTWriteSchemaInDS, &quot;Test#14&quot;);
</I>&gt;<i> +            
</I>&gt;<i> +            // Remove the extra &quot;msdata:MainDataTable&quot; for the other test case.
</I>&gt;<i> +            // Also make sure we have &quot;NewDataSet&quot; in the appropriate locations.
</I>&gt;<i> +            doc = new XmlDocument();
</I>&gt;<i> +            doc.LoadXml(xmlDTWriteSchemaNoDS);
</I>&gt;<i> +            node = doc.DocumentElement.FirstChild.FirstChild;
</I>&gt;<i> +            a = (XmlAttribute)node.Attributes.GetNamedItem(&quot;msdata:MainDataTable&quot;);
</I>&gt;<i> +            Assert.IsNotNull(a, &quot;Test#15&quot;);
</I>&gt;<i> +            Assert.AreEqual(&quot;Main&quot;, a.Value, &quot;Test#16&quot;);
</I>&gt;<i> +            node.Attributes.Remove(a);
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            doc.Save(sw);
</I>&gt;<i> +            
</I>&gt;<i> +            Assert.AreEqual(&quot;NewDataSet&quot;, doc.DocumentElement.Name, &quot;Test#17&quot;);
</I>&gt;<i> +            Assert.AreEqual(&quot;NewDataSet&quot;, doc.DocumentElement.FirstChild.Attributes[&quot;id&quot;].Value, &quot;Test#18&quot;);
</I>&gt;<i> +            Assert.AreEqual(&quot;NewDataSet&quot;, doc.DocumentElement.FirstChild.FirstChild.Attributes[&quot;name&quot;].Value, &quot;Test#19&quot;);
</I>&gt;<i> +            
</I>&gt;<i> +            xmlDTWriteSchemaNoDS = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            xmlDTWriteSchemaNoDS = xmlDTWriteSchemaNoDS.Replace(&quot;&lt;NewDataSet&gt;&quot;,&quot;&lt;MyDataSet&gt;&quot;);
</I>&gt;<i> +            xmlDTWriteSchemaNoDS = xmlDTWriteSchemaNoDS.Replace(&quot;&lt;/NewDataSet&gt;&quot;,&quot;&lt;/MyDataSet&gt;&quot;);
</I>&gt;<i> +            xmlDTWriteSchemaNoDS = xmlDTWriteSchemaNoDS.Replace(&quot;\&quot;NewDataSet\&quot;&quot;,&quot;\&quot;MyDataSet\&quot;&quot;);
</I>&gt;<i> +
</I>&gt;<i> +            Assert.AreEqual(xmlDSWriteSchema, xmlDTWriteSchemaNoDS, &quot;Test#20&quot;);
</I>&gt;<i> +        }
</I>&gt;<i> +        
</I>&gt;<i> +        [Test]
</I>&gt;<i> +        public void TestReadXml()
</I>&gt;<i> +        {
</I>&gt;<i> +            // For reading, DataTable.ReadXml only supports reading in xml with
</I>&gt;<i> +            // the schema included.  This means that we can only read in XML
</I>&gt;<i> +            // that was generated with the WriteSchema flag.  
</I>&gt;<i> +            DataSet ds;
</I>&gt;<i> +            DataTable dtMainInDS, dtChildInDS, dtMain;
</I>&gt;<i> +            
</I>&gt;<i> +            GenerateTestData(out ds,
</I>&gt;<i> +                             out dtMainInDS,
</I>&gt;<i> +                             out dtChildInDS,
</I>&gt;<i> +                             out dtMain);
</I>&gt;<i> +            
</I>&gt;<i> +            StringWriter sw = new StringWriter();
</I>&gt;<i> +            
</I>&gt;<i> +            // Get XML for recursive DataTable writes of the same data as in
</I>&gt;<i> +            // the DataSet.
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMainInDS.WriteXml(sw, true);
</I>&gt;<i> +            string xmlDTNone = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMainInDS.WriteXml(sw, XmlWriteMode.DiffGram, true);
</I>&gt;<i> +            string xmlDTDiffGram = sw.ToString();
</I>&gt;<i> +
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMainInDS.WriteXml(sw, XmlWriteMode.WriteSchema, true);
</I>&gt;<i> +            string xmlMultiTable = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            dtMain.WriteXml(sw, XmlWriteMode.WriteSchema);
</I>&gt;<i> +            string xmlSingleTable = sw.ToString();
</I>&gt;<i> +            
</I>&gt;<i> +            DataTable newdt = new DataTable();
</I>&gt;<i> +
</I>&gt;<i> +            try {
</I>&gt;<i> +                newdt.ReadXml(new StringReader(xmlDTNone));
</I>&gt;<i> +                Assert.Fail(&quot;Test#01&quot;);
</I>&gt;<i> +            } catch(InvalidOperationException) {
</I>&gt;<i> +                // DataTable does not support schema inference from Xml.
</I>&gt;<i> +            }
</I>&gt;<i> +            
</I>&gt;<i> +            try {
</I>&gt;<i> +                newdt.ReadXml(new StringReader(xmlDTDiffGram));
</I>&gt;<i> +                Assert.Fail(&quot;Test#02&quot;);
</I>&gt;<i> +            } catch(InvalidOperationException) {
</I>&gt;<i> +                // DataTable does not support schema inference from Xml.
</I>&gt;<i> +            }
</I>&gt;<i> +            
</I>&gt;<i> +            DataTable multiTable = new DataTable();
</I>&gt;<i> +            multiTable.ReadXml(new StringReader(xmlMultiTable));
</I>&gt;<i> +            // Do some simple checks to see if the main dataset was created
</I>&gt;<i> +            // and if there are relationships present.
</I>&gt;<i> +            Assert.AreEqual(&quot;MyDataSet&quot;, multiTable.DataSet.DataSetName, &quot;Test#03&quot;);
</I>&gt;<i> +            Assert.AreEqual(1, multiTable.ChildRelations.Count, &quot;Test#04&quot;);
</I>&gt;<i> +            Assert.AreEqual(1, multiTable.Constraints.Count, &quot;Test#05&quot;);
</I>&gt;<i> +            // Write the table back out and check to see that the XML is
</I>&gt;<i> +            // the same as before.
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            multiTable.WriteXml(sw, XmlWriteMode.WriteSchema, true);
</I>&gt;<i> +            string xmlMultiTableCheck = sw.ToString();
</I>&gt;<i> +            Assert.AreEqual(xmlMultiTable, xmlMultiTableCheck, &quot;Test#06&quot;);
</I>&gt;<i> +            
</I>&gt;<i> +            DataTable singleTable = new DataTable();
</I>&gt;<i> +            singleTable.ReadXml(new StringReader(xmlSingleTable));
</I>&gt;<i> +            // Do some simple checks on the table.
</I>&gt;<i> +            Assert.IsNull(singleTable.DataSet, &quot;Test#07&quot;);
</I>&gt;<i> +            Assert.AreEqual(&quot;Main&quot;, singleTable.TableName, &quot;Test#08&quot;);
</I>&gt;<i> +            // Write the table out and check if it's the same.
</I>&gt;<i> +            sw.GetStringBuilder().Length = 0;
</I>&gt;<i> +            singleTable.WriteXml(sw, XmlWriteMode.WriteSchema);
</I>&gt;<i> +            string xmlSingleTableCheck = sw.ToString();
</I>&gt;<i> +            Assert.AreEqual(xmlSingleTable, xmlSingleTableCheck, &quot;Test#09&quot;);
</I>&gt;<i> +        }
</I>&gt;<i> +    }
</I>&gt;<i> +}
</I>&gt;<i> +#endif
</I>&gt;<i> Index: System.Data.dll.sources
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- System.Data.dll.sources	(revision 66162)
</I>&gt;<i> +++ System.Data.dll.sources	(working copy)
</I>&gt;<i> @@ -318,6 +318,7 @@
</I>&gt;<i>  System.Data/XmlDataLoader.cs
</I>&gt;<i>  System.Data/XmlSchemaDataImporter.cs
</I>&gt;<i>  System.Data/XmlSchemaWriter.cs
</I>&gt;<i> +System.Data/XmlTableWriter.cs
</I>&gt;<i>  System.Xml/XmlDataDocument.cs
</I>&gt;<i>  Mono.Data.SqlExpressions/Tokenizer.cs
</I>&gt;<i>  Mono.Data.SqlExpressions/Numeric.cs
</I>&gt;<i> Index: System.Data_test.dll.sources
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- System.Data_test.dll.sources	(revision 66162)
</I>&gt;<i> +++ System.Data_test.dll.sources	(working copy)
</I>&gt;<i> @@ -40,6 +40,7 @@
</I>&gt;<i>  System.Data/DataTableTest2.cs
</I>&gt;<i>  System.Data/DataTableLoadRowTest.cs
</I>&gt;<i>  System.Data/DataTableReaderTest.cs
</I>&gt;<i> +System.Data/DataTableReadWriteXmlTest.cs
</I>&gt;<i>  System.Data/DataViewManagerTest.cs
</I>&gt;<i>  System.Data/DataViewTest.cs
</I>&gt;<i>  System.Data/DataViewTest2.cs
</I>&gt;<i> Index: ChangeLog
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- ChangeLog	(revision 66162)
</I>&gt;<i> +++ ChangeLog	(working copy)
</I>&gt;<i> @@ -1,3 +1,7 @@
</I>&gt;<i> +2006-10-02	Patrick Earl &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono at patearl.net</A>&gt;
</I>&gt;<i> +
</I>&gt;<i> +	* Implemented DataTable.WriteXml
</I>&gt;<i> +
</I>&gt;<i>  2006-09-26	Boris Kirzner &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">borisk at mainsoft.com</A>&gt;
</I>&gt;<i>  
</I>&gt;<i>  	* run-tests.test.disconnected.bat,run-tests.test.connected.bat: 
</I>&gt;<i> Index: System.Data/XmlSchemaWriter.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- System.Data/XmlSchemaWriter.cs	(revision 66162)
</I>&gt;<i> +++ System.Data/XmlSchemaWriter.cs	(working copy)
</I>&gt;<i> @@ -64,16 +64,50 @@
</I>&gt;<i>  			XmlWriter writer, DataTableCollection tables,
</I>&gt;<i>  			DataRelationCollection relations)
</I>&gt;<i>  		{
</I>&gt;<i> -			ds = dataset;
</I>&gt;<i> +			dataSetName = dataset.DataSetName;
</I>&gt;<i> +			dataSetNamespace = dataset.Namespace;
</I>&gt;<i> +			dataSetLocale = dataset.Locale;
</I>&gt;<i> +			dataSetProperties = dataset.ExtendedProperties;
</I>&gt;<i>  			w = writer;
</I>&gt;<i> +			if (tables != null) {
</I>&gt;<i> +				this.tables = new DataTable[tables.Count];
</I>&gt;<i> +				for(int i=0;i&lt;tables.Count;i++) this.tables[i] = tables[i];
</I>&gt;<i> +			}
</I>&gt;<i> +			if (relations != null) {
</I>&gt;<i> +				this.relations = new DataRelation[relations.Count];
</I>&gt;<i> +				for(int i=0;i&lt;relations.Count;i++) this.relations[i] = relations[i];
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public XmlSchemaWriter (XmlWriter writer,
</I>&gt;<i> +			DataTable[] tables,
</I>&gt;<i> +			DataRelation[] relations,
</I>&gt;<i> +			string mainDataTable,
</I>&gt;<i> +			string dataSetName)
</I>&gt;<i> +		{
</I>&gt;<i> +			w = writer;
</I>&gt;<i>  			this.tables = tables;
</I>&gt;<i>  			this.relations = relations;
</I>&gt;<i> +			this.mainDataTable = mainDataTable;
</I>&gt;<i> +			this.dataSetName = dataSetName;
</I>&gt;<i> +			this.dataSetProperties = new PropertyCollection();
</I>&gt;<i> +			if (tables[0].DataSet != null) {
</I>&gt;<i> +				dataSetNamespace = tables[0].DataSet.Namespace;
</I>&gt;<i> +				dataSetLocale = tables[0].DataSet.Locale;
</I>&gt;<i> +			} else {
</I>&gt;<i> +				dataSetNamespace = tables[0].Namespace;
</I>&gt;<i> +				dataSetLocale = tables[0].Locale;
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		DataSet ds;
</I>&gt;<i>  		XmlWriter w;
</I>&gt;<i> -		DataTableCollection tables;
</I>&gt;<i> -		DataRelationCollection relations;
</I>&gt;<i> +		DataTable[] tables;
</I>&gt;<i> +		DataRelation[] relations;
</I>&gt;<i> +		string mainDataTable;
</I>&gt;<i> +		string dataSetName;
</I>&gt;<i> +		string dataSetNamespace;
</I>&gt;<i> +		PropertyCollection dataSetProperties;
</I>&gt;<i> +		CultureInfo dataSetLocale;
</I>&gt;<i>  
</I>&gt;<i>  		ArrayList globalTypeTables = new ArrayList ();
</I>&gt;<i>  		Hashtable additionalNamespaces = new Hashtable ();
</I>&gt;<i> @@ -81,7 +115,7 @@
</I>&gt;<i>  		ArrayList annotation = new ArrayList ();
</I>&gt;<i>  
</I>&gt;<i>  		public string ConstraintPrefix {
</I>&gt;<i> -			get { return ds.Namespace != String.Empty ? XmlConstants.TnsPrefix + ':' : String.Empty; }
</I>&gt;<i> +			get { return dataSetNamespace != String.Empty ? XmlConstants.TnsPrefix + ':' : String.Empty; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		// the whole DataSet
</I>&gt;<i> @@ -99,18 +133,18 @@
</I>&gt;<i>  			}
</I>&gt;<i>  
</I>&gt;<i>  			w.WriteStartElement (&quot;xs&quot;, &quot;schema&quot;, xmlnsxs);
</I>&gt;<i> -			w.WriteAttributeString (&quot;id&quot;, XmlHelper.Encode (ds.DataSetName));
</I>&gt;<i> +			w.WriteAttributeString (&quot;id&quot;, XmlHelper.Encode (dataSetName));
</I>&gt;<i>  
</I>&gt;<i> -			if (ds.Namespace != String.Empty) {
</I>&gt;<i> +			if (dataSetNamespace != String.Empty) {
</I>&gt;<i>  				w.WriteAttributeString (&quot;targetNamespace&quot;,
</I>&gt;<i> -					ds.Namespace);
</I>&gt;<i> +					dataSetNamespace);
</I>&gt;<i>  				w.WriteAttributeString (
</I>&gt;<i>  					&quot;xmlns&quot;,
</I>&gt;<i>  					XmlConstants.TnsPrefix,
</I>&gt;<i>  					XmlConstants.XmlnsNS,
</I>&gt;<i> -					ds.Namespace);
</I>&gt;<i> +					dataSetNamespace);
</I>&gt;<i>  			}
</I>&gt;<i> -			w.WriteAttributeString (&quot;xmlns&quot;, ds.Namespace);
</I>&gt;<i> +			w.WriteAttributeString (&quot;xmlns&quot;, dataSetNamespace);
</I>&gt;<i>  
</I>&gt;<i>  			w.WriteAttributeString (&quot;xmlns&quot;, &quot;xs&quot;,
</I>&gt;<i>  				XmlConstants.XmlnsNS, xmlnsxs);
</I>&gt;<i> @@ -125,7 +159,7 @@
</I>&gt;<i>  					XmlConstants.XmlnsNS,
</I>&gt;<i>  					XmlConstants.MspropNamespace);
</I>&gt;<i>  
</I>&gt;<i> -			if (ds.Namespace != String.Empty) {
</I>&gt;<i> +			if (dataSetNamespace != String.Empty) {
</I>&gt;<i>  				w.WriteAttributeString (&quot;attributeFormDefault&quot;, &quot;qualified&quot;);
</I>&gt;<i>  				w.WriteAttributeString (&quot;elementFormDefault&quot;, &quot;qualified&quot;);
</I>&gt;<i>  			}
</I>&gt;<i> @@ -156,12 +190,19 @@
</I>&gt;<i>  		private void WriteDataSetElement ()
</I>&gt;<i>  		{
</I>&gt;<i>  			w.WriteStartElement (&quot;xs&quot;, &quot;element&quot;, xmlnsxs);
</I>&gt;<i> -			w.WriteAttributeString (&quot;name&quot;, XmlHelper.Encode (ds.DataSetName));
</I>&gt;<i> +			w.WriteAttributeString (&quot;name&quot;, XmlHelper.Encode (dataSetName));
</I>&gt;<i>  			w.WriteAttributeString (XmlConstants.MsdataPrefix,
</I>&gt;<i>  				&quot;IsDataSet&quot;, XmlConstants.MsdataNamespace,
</I>&gt;<i>  				&quot;true&quot;);
</I>&gt;<i> +
</I>&gt;<i> +			if(mainDataTable != null &amp;&amp; mainDataTable != &quot;&quot;)
</I>&gt;<i> +				w.WriteAttributeString (
</I>&gt;<i> +					XmlConstants.MsdataPrefix,
</I>&gt;<i> +					&quot;MainDataTable&quot;,
</I>&gt;<i> +					XmlConstants.MsdataNamespace,
</I>&gt;<i> +					mainDataTable);
</I>&gt;<i>  #if NET_2_0
</I>&gt;<i> -			if (ds.Locale == CultureInfo.CurrentCulture) {
</I>&gt;<i> +			if (dataSetLocale == CultureInfo.CurrentCulture) {
</I>&gt;<i>  				w.WriteAttributeString (
</I>&gt;<i>  					XmlConstants.MsdataPrefix,
</I>&gt;<i>  					&quot;UseCurrentCulture&quot;,
</I>&gt;<i> @@ -175,10 +216,10 @@
</I>&gt;<i>  					XmlConstants.MsdataPrefix,
</I>&gt;<i>  					&quot;Locale&quot;,
</I>&gt;<i>  					XmlConstants.MsdataNamespace,
</I>&gt;<i> -					ds.Locale.Name);
</I>&gt;<i> +					dataSetLocale.Name);
</I>&gt;<i>  			}
</I>&gt;<i>  
</I>&gt;<i> -			AddExtendedPropertyAttributes (ds.ExtendedProperties);
</I>&gt;<i> +			AddExtendedPropertyAttributes (dataSetProperties);
</I>&gt;<i>  
</I>&gt;<i>  			w.WriteStartElement (&quot;xs&quot;, &quot;complexType&quot;, xmlnsxs);
</I>&gt;<i>  			w.WriteStartElement (&quot;xs&quot;, &quot;choice&quot;, xmlnsxs);
</I>&gt;<i> @@ -194,7 +235,7 @@
</I>&gt;<i>  				}
</I>&gt;<i>  				
</I>&gt;<i>  				if (isTopLevel) {
</I>&gt;<i> -					if (ds.Namespace != table.Namespace) {
</I>&gt;<i> +					if (dataSetNamespace != table.Namespace) {
</I>&gt;<i>  						// &lt;xs:element ref=&quot;X:y&quot; /&gt;
</I>&gt;<i>  						w.WriteStartElement (&quot;xs&quot;,
</I>&gt;<i>  							&quot;element&quot;,
</I>&gt;<i> @@ -286,7 +327,12 @@
</I>&gt;<i>  					}
</I>&gt;<i>  
</I>&gt;<i>  					ForeignKeyConstraint fk = c as ForeignKeyConstraint;
</I>&gt;<i> -					if (fk != null &amp;&amp; (relations == null || !(relations.Contains (fk.ConstraintName)))) {
</I>&gt;<i> +					bool haveConstraint = false;
</I>&gt;<i> +					if (relations != null)
</I>&gt;<i> +						foreach (DataRelation r in relations)
</I>&gt;<i> +							if(r.RelationName == fk.ConstraintName)
</I>&gt;<i> +								haveConstraint = true;
</I>&gt;<i> +					if (fk != null &amp;&amp; !haveConstraint) {
</I>&gt;<i>  						DataRelation rel = new DataRelation (fk.ConstraintName,
</I>&gt;<i>  										fk.RelatedColumns, fk.Columns);
</I>&gt;<i>  						AddForeignKeys (rel, names, true);
</I>&gt;<i> @@ -399,12 +445,12 @@
</I>&gt;<i>  			// first try to find the concatenated name. If we didn't find it - use constraint name.
</I>&gt;<i>  			if (names.Contains (concatName)) {
</I>&gt;<i>  				w.WriteStartAttribute (&quot;refer&quot;, String.Empty);
</I>&gt;<i> -				w.WriteQualifiedName (concatName, ds.Namespace);
</I>&gt;<i> +				w.WriteQualifiedName (concatName, dataSetNamespace);
</I>&gt;<i>  				w.WriteEndAttribute ();
</I>&gt;<i>  			}
</I>&gt;<i>  			else {
</I>&gt;<i>  				w.WriteStartAttribute (&quot;refer&quot;, String.Empty);
</I>&gt;<i> -				w.WriteQualifiedName (XmlHelper.Encode (uqConst.ConstraintName), ds.Namespace);
</I>&gt;<i> +				w.WriteQualifiedName (XmlHelper.Encode (uqConst.ConstraintName), dataSetNamespace);
</I>&gt;<i>  				w.WriteEndAttribute ();
</I>&gt;<i>  			}
</I>&gt;<i>  
</I>&gt;<i> @@ -445,10 +491,10 @@
</I>&gt;<i>  		// ExtendedProperties
</I>&gt;<i>  
</I>&gt;<i>  		private bool CheckExtendedPropertyExists (
</I>&gt;<i> -			DataTableCollection tables,
</I>&gt;<i> -			DataRelationCollection relations)
</I>&gt;<i> +			DataTable[] tables,
</I>&gt;<i> +			DataRelation[] relations)
</I>&gt;<i>  		{
</I>&gt;<i> -			if (ds.ExtendedProperties.Count &gt; 0)
</I>&gt;<i> +			if (dataSetProperties.Count &gt; 0)
</I>&gt;<i>  				return true;
</I>&gt;<i>  			foreach (DataTable dt in tables) {
</I>&gt;<i>  				if (dt.ExtendedProperties.Count &gt; 0)
</I>&gt;<i> @@ -640,7 +686,7 @@
</I>&gt;<i>  
</I>&gt;<i>  		private void WriteChildRelations (DataRelation rel)
</I>&gt;<i>  		{
</I>&gt;<i> -			if (rel.ChildTable.Namespace != ds.Namespace) {
</I>&gt;<i> +			if (rel.ChildTable.Namespace != dataSetNamespace) {
</I>&gt;<i>  				w.WriteStartElement (&quot;xs&quot;, &quot;element&quot;, xmlnsxs);
</I>&gt;<i>  				w.WriteStartAttribute (&quot;ref&quot;, String.Empty);
</I>&gt;<i>  				w.WriteQualifiedName (
</I>&gt;<i> @@ -734,8 +780,8 @@
</I>&gt;<i>  		{
</I>&gt;<i>  			if (ns == String.Empty)
</I>&gt;<i>  				return;
</I>&gt;<i> -			if (ds.Namespace != ns) {
</I>&gt;<i> -				if (names [prefix] != ns) {
</I>&gt;<i> +			if (dataSetNamespace != ns) {
</I>&gt;<i> +				if ((string)names [prefix] != ns) {
</I>&gt;<i>  					for (int i = 1; i &lt; int.MaxValue; i++) {
</I>&gt;<i>  						string p = &quot;app&quot; + i;
</I>&gt;<i>  						if (names [p] == null) {
</I>&gt;<i> Index: System.Data/DataSet.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- System.Data/DataSet.cs	(revision 66162)
</I>&gt;<i> +++ System.Data/DataSet.cs	(working copy)
</I>&gt;<i> @@ -1538,29 +1538,33 @@
</I>&gt;<i>  				WriteTable ( writer, table, mode, version);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		private void WriteTable (XmlWriter writer, DataTable table, XmlWriteMode mode, DataRowVersion version)
</I>&gt;<i> +		internal static void WriteTable (XmlWriter writer, DataTable table, XmlWriteMode mode, DataRowVersion version)
</I>&gt;<i>  		{
</I>&gt;<i>  			DataRow[] rows = table.NewRowArray(table.Rows.Count);
</I>&gt;<i>  			table.Rows.CopyTo (rows, 0);
</I>&gt;<i>  			WriteTable (writer, rows, mode, version, true);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		private void WriteTable (XmlWriter writer,
</I>&gt;<i> +		internal static void WriteTable (XmlWriter writer,
</I>&gt;<i>  			DataRow [] rows,
</I>&gt;<i>  			XmlWriteMode mode,
</I>&gt;<i>  			DataRowVersion version, bool skipIfNested)
</I>&gt;<i>  		{
</I>&gt;<i> +			if (rows.Length == 0) return;
</I>&gt;<i> +			DataTable table = rows[0].Table;
</I>&gt;<i> +
</I>&gt;<i> +			if (table.TableName == null || table.TableName == &quot;&quot;)
</I>&gt;<i> +				throw new InvalidOperationException(&quot;Cannot serialize the DataTable. DataTable name is not set.&quot;);
</I>&gt;<i> +
</I>&gt;<i>  			//The columns can be attributes, hidden, elements, or simple content
</I>&gt;<i>  			//There can be 0-1 simple content cols or 0-* elements
</I>&gt;<i>  			System.Collections.ArrayList atts;
</I>&gt;<i>  			System.Collections.ArrayList elements;
</I>&gt;<i>  			DataColumn simple = null;
</I>&gt;<i>  
</I>&gt;<i> -			if (rows.Length == 0) return;
</I>&gt;<i> -			DataTable table = rows[0].Table;
</I>&gt;<i>  			SplitColumns (table, out atts, out elements, out simple);
</I>&gt;<i>  			//sort out the namespacing
</I>&gt;<i> -			string nspc = table.Namespace.Length &gt; 0 ? table.Namespace : Namespace;
</I>&gt;<i> +			string nspc = (table.Namespace.Length &gt; 0 || table.DataSet == null) ? table.Namespace : table.DataSet.Namespace;
</I>&gt;<i>  			int relationCount = table.ParentRelations.Count;
</I>&gt;<i>  			DataRelation oneRel = relationCount == 1 ? table.ParentRelations [0] : null;
</I>&gt;<i>  
</I>&gt;<i> @@ -1628,7 +1632,7 @@
</I>&gt;<i>  
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		private void WriteColumnAsElement (XmlWriter writer, XmlWriteMode mode, DataColumn col, DataRow row, DataRowVersion version)
</I>&gt;<i> +		internal static void WriteColumnAsElement (XmlWriter writer, XmlWriteMode mode, DataColumn col, DataRow row, DataRowVersion version)
</I>&gt;<i>  		{
</I>&gt;<i>  			string colnspc = null;
</I>&gt;<i>  			object rowObject = row [col, version];
</I>&gt;<i> @@ -1645,16 +1649,16 @@
</I>&gt;<i>  			writer.WriteEndElement ();
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		private void WriteColumnAsAttribute (XmlWriter writer, XmlWriteMode mode, DataColumn col, DataRow row, DataRowVersion version)
</I>&gt;<i> +		internal static void WriteColumnAsAttribute (XmlWriter writer, XmlWriteMode mode, DataColumn col, DataRow row, DataRowVersion version)
</I>&gt;<i>  		{
</I>&gt;<i>  			if (!row.IsNull (col))
</I>&gt;<i>  				WriteAttributeString (writer, mode, col.Namespace, col.Prefix, XmlHelper.Encode (col.ColumnName), WriteObjectXml (row[col, version]));
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		private void WriteTableElement (XmlWriter writer, XmlWriteMode mode, DataTable table, DataRow row, DataRowVersion version)
</I>&gt;<i> +		internal static void WriteTableElement (XmlWriter writer, XmlWriteMode mode, DataTable table, DataRow row, DataRowVersion version)
</I>&gt;<i>  		{
</I>&gt;<i>  			//sort out the namespacing
</I>&gt;<i> -			string nspc = table.Namespace.Length &gt; 0 ? table.Namespace : Namespace;
</I>&gt;<i> +			string nspc = (table.Namespace.Length &gt; 0 || table.DataSet == null) ? table.Namespace : table.DataSet.Namespace;
</I>&gt;<i>  
</I>&gt;<i>  			WriteStartElement (writer, mode, nspc, table.Prefix, XmlHelper.Encode (table.TableName));
</I>&gt;<i>  
</I>&gt;<i> @@ -1672,12 +1676,12 @@
</I>&gt;<i>  			}
</I>&gt;<i>  		}
</I>&gt;<i>  		    
</I>&gt;<i> -		private void WriteStartElement (XmlWriter writer, XmlWriteMode mode, string nspc, string prefix, string name)
</I>&gt;<i> +		internal static void WriteStartElement (XmlWriter writer, XmlWriteMode mode, string nspc, string prefix, string name)
</I>&gt;<i>  		{
</I>&gt;<i>  			writer.WriteStartElement (prefix, name, nspc);
</I>&gt;<i>  		}
</I>&gt;<i>  		
</I>&gt;<i> -		private void WriteAttributeString (XmlWriter writer, XmlWriteMode mode, string nspc, string prefix, string name, string stringValue)
</I>&gt;<i> +		internal static void WriteAttributeString (XmlWriter writer, XmlWriteMode mode, string nspc, string prefix, string name, string stringValue)
</I>&gt;<i>  		{
</I>&gt;<i>  			switch ( mode) {
</I>&gt;<i>  				case XmlWriteMode.WriteSchema:
</I>&gt;<i> @@ -1695,7 +1699,7 @@
</I>&gt;<i>  		internal void WriteIndividualTableContent (XmlWriter writer, DataTable table, XmlWriteMode mode)
</I>&gt;<i>  		{
</I>&gt;<i>  			if (mode == XmlWriteMode.DiffGram) {
</I>&gt;<i> -				SetTableRowsID (table);
</I>&gt;<i> +				table.SetRowsID();
</I>&gt;<i>  				WriteDiffGramElement (writer);
</I>&gt;<i>  			}
</I>&gt;<i>  			
</I>&gt;<i> @@ -1760,7 +1764,7 @@
</I>&gt;<i>  			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		private void WriteDiffGramElement(XmlWriter writer)
</I>&gt;<i> +		internal static void WriteDiffGramElement(XmlWriter writer)
</I>&gt;<i>  		{
</I>&gt;<i>  			WriteStartElement (writer, XmlWriteMode.DiffGram, XmlConstants.DiffgrNamespace, XmlConstants.DiffgrPrefix, &quot;diffgram&quot;);
</I>&gt;<i>  			WriteAttributeString(writer, XmlWriteMode.DiffGram, null, &quot;xmlns&quot;, XmlConstants.MsdataPrefix, XmlConstants.MsdataNamespace);
</I>&gt;<i> @@ -1768,18 +1772,9 @@
</I>&gt;<i>  
</I>&gt;<i>  		private void SetRowsID()
</I>&gt;<i>  		{
</I>&gt;<i> -			foreach (DataTable Table in Tables)
</I>&gt;<i> -				SetTableRowsID (Table);
</I>&gt;<i> +			foreach (DataTable table in Tables)
</I>&gt;<i> +				table.SetRowsID();
</I>&gt;<i>  		}
</I>&gt;<i> -		
</I>&gt;<i> -		private void SetTableRowsID (DataTable Table)
</I>&gt;<i> -		{
</I>&gt;<i> -			int dataRowID = 0;
</I>&gt;<i> -			foreach (DataRow Row in Table.Rows) {
</I>&gt;<i> -				Row.XmlRowID = dataRowID;
</I>&gt;<i> -				dataRowID++;
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i>  		#endregion //Private Xml Serialisation
</I>&gt;<i>  	}
</I>&gt;<i>  }
</I>&gt;<i> Index: System.Data/XmlTableWriter.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- System.Data/XmlTableWriter.cs	(revision 0)
</I>&gt;<i> +++ System.Data/XmlTableWriter.cs	(revision 0)
</I>&gt;<i> @@ -0,0 +1,97 @@
</I>&gt;<i> +// 
</I>&gt;<i> +// System.Data/XmlTableWriter.cs
</I>&gt;<i> +//
</I>&gt;<i> +// Author:
</I>&gt;<i> +//   Patrick Earl &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono at patearl.net</A>&gt;
</I>&gt;<i> +//
</I>&gt;<i> +// Copyright (c) 2006, Patrick Earl
</I>&gt;<i> +//
</I>&gt;<i> +// Permission is hereby granted, free of charge, to any person obtaining
</I>&gt;<i> +// a copy of this software and associated documentation files (the
</I>&gt;<i> +// &quot;Software&quot;), to deal in the Software without restriction, including
</I>&gt;<i> +// without limitation the rights to use, copy, modify, merge, publish,
</I>&gt;<i> +// distribute, sublicense, and/or sell copies of the Software, and to
</I>&gt;<i> +// permit persons to whom the Software is furnished to do so, subject to
</I>&gt;<i> +// the following conditions:
</I>&gt;<i> +// 
</I>&gt;<i> +// The above copyright notice and this permission notice shall be
</I>&gt;<i> +// included in all copies or substantial portions of the Software.
</I>&gt;<i> +// 
</I>&gt;<i> +// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
</I>&gt;<i> +// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
</I>&gt;<i> +// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
</I>&gt;<i> +// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
</I>&gt;<i> +// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
</I>&gt;<i> +// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
</I>&gt;<i> +// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</I>&gt;<i> +
</I>&gt;<i> +#if NET_2_0
</I>&gt;<i> +using System;
</I>&gt;<i> +using System.Collections.Generic;
</I>&gt;<i> +using System.Data;
</I>&gt;<i> +using System.Xml;
</I>&gt;<i> +
</I>&gt;<i> +internal class XmlTableWriter {
</I>&gt;<i> +	// This method is modelled after the DataSet's WriteXml functionality.
</I>&gt;<i> +	internal static void WriteTables(XmlWriter writer,
</I>&gt;<i> +		                 XmlWriteMode mode,
</I>&gt;<i> +				 List&lt;DataTable&gt; tables,
</I>&gt;<i> +				 List&lt;DataRelation&gt; relations,
</I>&gt;<i> +				 string mainDataTable,
</I>&gt;<i> +				 string dataSetName)
</I>&gt;<i> +	{
</I>&gt;<i> +		if (mode == XmlWriteMode.DiffGram) {
</I>&gt;<i> +			foreach (DataTable table in tables)
</I>&gt;<i> +				table.SetRowsID();
</I>&gt;<i> +			DataSet.WriteDiffGramElement(writer);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		bool shouldOutputContent = (mode != XmlWriteMode.DiffGram);
</I>&gt;<i> +		for (int n = 0; n &lt; tables.Count &amp;&amp; !shouldOutputContent; n++)
</I>&gt;<i> +			shouldOutputContent = tables[n].Rows.Count &gt; 0;
</I>&gt;<i> +
</I>&gt;<i> +		if (shouldOutputContent) {
</I>&gt;<i> +			// We assume that tables[0] is the main table being written.
</I>&gt;<i> +			// We happen to know that the code above us does things that way.
</I>&gt;<i> +			DataSet.WriteStartElement(writer, mode, tables[0].Namespace, tables[0].Prefix, XmlHelper.Encode(dataSetName));
</I>&gt;<i> +
</I>&gt;<i> +			if (mode == XmlWriteMode.WriteSchema) {
</I>&gt;<i> +				new XmlSchemaWriter(writer,
</I>&gt;<i> +					tables.ToArray(),
</I>&gt;<i> +					relations.ToArray(),
</I>&gt;<i> +					mainDataTable,
</I>&gt;<i> +					dataSetName
</I>&gt;<i> +				).WriteSchema();
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			WriteTableList (writer, mode, tables, DataRowVersion.Default);
</I>&gt;<i> +
</I>&gt;<i> +			writer.WriteEndElement();
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		if (mode == XmlWriteMode.DiffGram) {
</I>&gt;<i> +			List&lt;DataTable&gt; changedTables = new List&lt;DataTable&gt;();
</I>&gt;<i> +			foreach (DataTable table in tables) {
</I>&gt;<i> +				DataTable changed = table.GetChanges(DataRowState.Modified | DataRowState.Deleted);
</I>&gt;<i> +				if (changed != null &amp;&amp; changed.Rows.Count &gt; 0)
</I>&gt;<i> +					changedTables.Add(changed);
</I>&gt;<i> +			}
</I>&gt;<i> +			if (changedTables.Count &gt; 0) {
</I>&gt;<i> +				DataSet.WriteStartElement(writer, XmlWriteMode.DiffGram, XmlConstants.DiffgrNamespace, XmlConstants.DiffgrPrefix, &quot;before&quot;);
</I>&gt;<i> +				WriteTableList (writer, mode, changedTables, DataRowVersion.Original);
</I>&gt;<i> +				writer.WriteEndElement();
</I>&gt;<i> +			}
</I>&gt;<i> +		
</I>&gt;<i> +			writer.WriteEndElement(); // diffgr:diffgram
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		writer.Flush();
</I>&gt;<i> +	}
</I>&gt;<i> +
</I>&gt;<i> +	internal static void WriteTableList(XmlWriter writer, XmlWriteMode mode, List&lt;DataTable&gt; tables, DataRowVersion version)
</I>&gt;<i> +	{
</I>&gt;<i> +		foreach (DataTable table in tables)
</I>&gt;<i> +			DataSet.WriteTable(writer, table, mode, version);
</I>&gt;<i> +	}
</I>&gt;<i> +}
</I>&gt;<i> +#endif
</I>&gt;<i> Index: System.Data/DataTable.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- System.Data/DataTable.cs	(revision 66162)
</I>&gt;<i> +++ System.Data/DataTable.cs	(working copy)
</I>&gt;<i> @@ -43,6 +43,9 @@
</I>&gt;<i>  using System;
</I>&gt;<i>  using System.Data.Common;
</I>&gt;<i>  using System.Collections;
</I>&gt;<i> +#if NET_2_0
</I>&gt;<i> +using System.Collections.Generic;
</I>&gt;<i> +#endif
</I>&gt;<i>  using System.ComponentModel;
</I>&gt;<i>  using System.Globalization;
</I>&gt;<i>  using System.IO;
</I>&gt;<i> @@ -1929,10 +1932,49 @@
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  #if NET_2_0
</I>&gt;<i> +		public XmlReadMode ReadXml (Stream stream)
</I>&gt;<i> +		{
</I>&gt;<i> +			return ReadXml (new XmlTextReader(stream, null));
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public XmlReadMode ReadXml (string fileName)
</I>&gt;<i> +		{
</I>&gt;<i> +			XmlReader reader = new XmlTextReader(fileName);
</I>&gt;<i> +			try {
</I>&gt;<i> +				return ReadXml (reader);
</I>&gt;<i> +			} finally {
</I>&gt;<i> +				reader.Close();
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public XmlReadMode ReadXml (TextReader reader)
</I>&gt;<i> +		{
</I>&gt;<i> +			return ReadXml (new XmlTextReader(reader));
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		[MonoTODO]
</I>&gt;<i> -		XmlReadMode ReadXml (Stream stream)
</I>&gt;<i> +		public XmlReadMode ReadXml (XmlReader reader)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			// The documentation from MS for this method is rather
</I>&gt;<i> +			// poor.  The following cases have been observed
</I>&gt;<i> +			// during testing:
</I>&gt;<i> +			//
</I>&gt;<i> +			//     Reading a table from XML may create a DataSet to
</I>&gt;<i> +			//     store child tables.
</I>&gt;<i> +			//
</I>&gt;<i> +			//     If the table has at least one column present,
</I>&gt;<i> +			//     we do not require the schema to be present in
</I>&gt;<i> +			//     the xml.  If the table has no columns, neither
</I>&gt;<i> +			//     regular data nor diffgrams will be read, but
</I>&gt;<i> +			//     will throw an error indicating that schema
</I>&gt;<i> +			//     will not be inferred.
</I>&gt;<i> +			//
</I>&gt;<i> +			//     We will likely need to take advantage of the
</I>&gt;<i> +			//     msdata:MainDataTable attribute added to the
</I>&gt;<i> +			//     schema info to load into the appropriate
</I>&gt;<i> +			//     locations.
</I>&gt;<i> +
</I>&gt;<i> +			throw new NotImplementedException();
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public void ReadXmlSchema (Stream stream)
</I>&gt;<i> @@ -2244,57 +2286,158 @@
</I>&gt;<i>  		{
</I>&gt;<i>  			XmlWriterSettings s = new XmlWriterSettings ();
</I>&gt;<i>  			s.Indent = true;
</I>&gt;<i> +			s.OmitXmlDeclaration = true;
</I>&gt;<i>  			return s;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public void WriteXml (Stream stream)
</I>&gt;<i>  		{
</I>&gt;<i> -			WriteXml (stream, XmlWriteMode.IgnoreSchema);
</I>&gt;<i> +			WriteXml (stream, XmlWriteMode.IgnoreSchema, false);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public void WriteXml (string fileName)
</I>&gt;<i> +		{
</I>&gt;<i> +			WriteXml (fileName, XmlWriteMode.IgnoreSchema, false);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public void WriteXml (TextWriter writer)
</I>&gt;<i>  		{
</I>&gt;<i> -			WriteXml (writer, XmlWriteMode.IgnoreSchema);
</I>&gt;<i> +			WriteXml (writer, XmlWriteMode.IgnoreSchema, false);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public void WriteXml (XmlWriter writer)
</I>&gt;<i>  		{
</I>&gt;<i> -			WriteXml (writer, XmlWriteMode.IgnoreSchema);
</I>&gt;<i> +			WriteXml (writer, XmlWriteMode.IgnoreSchema, false);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public void WriteXml (string fileName)
</I>&gt;<i> +		public void WriteXml (Stream stream, XmlWriteMode mode)
</I>&gt;<i>  		{
</I>&gt;<i> -			WriteXml (fileName, XmlWriteMode.IgnoreSchema);
</I>&gt;<i> +			WriteXml (stream, mode, false);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public void WriteXml (Stream stream, XmlWriteMode mode)
</I>&gt;<i> +		public void WriteXml (string fileName, XmlWriteMode mode)
</I>&gt;<i>  		{
</I>&gt;<i> -			WriteXml (XmlWriter.Create (stream, GetWriterSettings ()), mode);
</I>&gt;<i> +			WriteXml (fileName, mode, false);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public void WriteXml (TextWriter writer, XmlWriteMode mode)
</I>&gt;<i>  		{
</I>&gt;<i> -			WriteXml (XmlWriter.Create (writer, GetWriterSettings ()), mode);
</I>&gt;<i> +			WriteXml (writer, mode, false);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public void WriteXml (XmlWriter writer, XmlWriteMode mode)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			WriteXml (writer, mode, false);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public void WriteXml (string fileName, XmlWriteMode mode)
</I>&gt;<i> +		public void WriteXml (Stream stream, bool writeHierarchy)
</I>&gt;<i>  		{
</I>&gt;<i> +			WriteXml (stream, XmlWriteMode.IgnoreSchema, writeHierarchy);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public void WriteXml (string fileName, bool writeHierarchy)
</I>&gt;<i> +		{
</I>&gt;<i> +			WriteXml (fileName, XmlWriteMode.IgnoreSchema, writeHierarchy);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public void WriteXml (TextWriter writer, bool writeHierarchy)
</I>&gt;<i> +		{
</I>&gt;<i> +			WriteXml (writer, XmlWriteMode.IgnoreSchema, writeHierarchy);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public void WriteXml (XmlWriter writer, bool writeHierarchy)
</I>&gt;<i> +		{
</I>&gt;<i> +			WriteXml (writer, XmlWriteMode.IgnoreSchema, writeHierarchy);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public void WriteXml (Stream stream, XmlWriteMode mode, bool writeHierarchy)
</I>&gt;<i> +		{
</I>&gt;<i> +			WriteXml (XmlWriter.Create (stream, GetWriterSettings ()), mode, writeHierarchy);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public void WriteXml (string fileName, XmlWriteMode mode, bool writeHierarchy)
</I>&gt;<i> +		{
</I>&gt;<i>  			XmlWriter xw = null;
</I>&gt;<i>  			try {
</I>&gt;<i>  				xw = XmlWriter.Create (fileName, GetWriterSettings ());
</I>&gt;<i> -				WriteXml (xw, mode);
</I>&gt;<i> +				WriteXml (xw, mode, writeHierarchy);
</I>&gt;<i>  			} finally {
</I>&gt;<i>  				if (xw != null)
</I>&gt;<i>  					xw.Close ();
</I>&gt;<i>  			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public void WriteXml (TextWriter writer, XmlWriteMode mode, bool writeHierarchy)
</I>&gt;<i> +		{
</I>&gt;<i> +			WriteXml (XmlWriter.Create (writer, GetWriterSettings ()), mode, writeHierarchy);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public void WriteXml (XmlWriter writer, XmlWriteMode mode, bool writeHierarchy)
</I>&gt;<i> +		{
</I>&gt;<i> +			// If we're in mode XmlWriteMode.WriteSchema, we need to output an extra
</I>&gt;<i> +			// msdata:MainDataTable attribute that wouldn't normally be part of the
</I>&gt;<i> +			// DataSet WriteXml output.
</I>&gt;<i> +			//
</I>&gt;<i> +			// For the writeHierarchy == true case, we write what would be output by
</I>&gt;<i> +			// a DataSet write, but we limit ourselves to our table and its descendants.
</I>&gt;<i> +			//
</I>&gt;<i> +			// For the writeHierarchy == false case, we write what would be output by
</I>&gt;<i> +			// a DataSet write, but we limit ourselves to this table.
</I>&gt;<i> +			//
</I>&gt;<i> +			// If the table is not in a DataSet, we follow the following behaviour:
</I>&gt;<i> +			//   For WriteSchema cases, we do a write as if there is a wrapper
</I>&gt;<i> +			//   dataset called NewDataSet.
</I>&gt;<i> +			//   For IgnoreSchema or DiffGram cases, we do a write as if there
</I>&gt;<i> +			//   is a wrapper dataset called DocumentElement.
</I>&gt;<i> +			
</I>&gt;<i> +			// Generate a list of tables to write.
</I>&gt;<i> +			List&lt;DataTable&gt; tables = new List&lt;DataTable&gt;();	
</I>&gt;<i> +			if (writeHierarchy == false)
</I>&gt;<i> +				tables.Add(this);
</I>&gt;<i> +			else
</I>&gt;<i> +				FindAllChildren(tables, this);
</I>&gt;<i> +
</I>&gt;<i> +			// If we're in a DataSet, generate a list of relations to write.
</I>&gt;<i> +			List&lt;DataRelation&gt; relations = new List&lt;DataRelation&gt;();
</I>&gt;<i> +			if (DataSet != null)
</I>&gt;<i> +			{
</I>&gt;<i> +				foreach(DataRelation relation in DataSet.Relations)
</I>&gt;<i> +				{
</I>&gt;<i> +					if(tables.Contains(relation.ParentTable) &amp;&amp;
</I>&gt;<i> +					   tables.Contains(relation.ChildTable))
</I>&gt;<i> +						relations.Add(relation);
</I>&gt;<i> +				}
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			// Add the msdata:MainDataTable info if we're writing schema data.
</I>&gt;<i> +			string mainDataTable = null;
</I>&gt;<i> +			if (mode == XmlWriteMode.WriteSchema)
</I>&gt;<i> +				mainDataTable = this.TableName;
</I>&gt;<i> +
</I>&gt;<i> +			// Figure out the DataSet name.
</I>&gt;<i> +			string dataSetName = null;
</I>&gt;<i> +			if (DataSet != null)
</I>&gt;<i> +				dataSetName = DataSet.DataSetName;
</I>&gt;<i> +			else if (DataSet == null &amp;&amp; mode == XmlWriteMode.WriteSchema)
</I>&gt;<i> +				dataSetName = &quot;NewDataSet&quot;;
</I>&gt;<i> +			else
</I>&gt;<i> +				dataSetName = &quot;DocumentElement&quot;;
</I>&gt;<i> +				
</I>&gt;<i> +			XmlTableWriter.WriteTables(writer, mode, tables, relations, mainDataTable, dataSetName);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		private void FindAllChildren(List&lt;DataTable&gt; list, DataTable root)
</I>&gt;<i> +		{
</I>&gt;<i> +			if (!list.Contains(root))
</I>&gt;<i> +			{
</I>&gt;<i> +				list.Add(root);
</I>&gt;<i> +				foreach (DataRelation relation in root.ChildRelations)
</I>&gt;<i> +				{
</I>&gt;<i> +					FindAllChildren(list, relation.ChildTable);
</I>&gt;<i> +				}
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public void WriteXmlSchema (Stream stream)
</I>&gt;<i>  		{
</I>&gt;<i>  			WriteXmlSchema (XmlWriter.Create (stream, GetWriterSettings ()));
</I>&gt;<i> @@ -2581,5 +2724,14 @@
</I>&gt;<i>  		internal void ResetPropertyDescriptorsCache() {
</I>&gt;<i>  			_propertyDescriptorsCache = null;
</I>&gt;<i>  		}
</I>&gt;<i> +
</I>&gt;<i> +		internal void SetRowsID()
</I>&gt;<i> +		{
</I>&gt;<i> +			int dataRowID = 0;
</I>&gt;<i> +			foreach (DataRow row in Rows) {
</I>&gt;<i> +				row.XmlRowID = dataRowID;
</I>&gt;<i> +				dataRowID++;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i>  	}
</I>&gt;<i>  }
</I>&gt;<i>   
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>   
</I>
-- 
Nagappan A &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">anagappan at novell.com</A>&gt;
Novell Software Development (I) Pvt. Ltd.
Linux Desktop Testing Project - <A HREF="http://ldtp.freedesktop.org">http://ldtp.freedesktop.org</A>
<A HREF="http://nagappanal.blogspot.com/">http://nagappanal.blogspot.com/</A>

Novell, Inc.
SUSE&#174; Linux Enterprise 10
Your Linux is ready&#8482;
<A HREF="http://www.novell.com/linux">http://www.novell.com/linux</A>


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020721.html">[Mono-dev] [PATCH] DataTable.WriteXml
</A></li>
	<LI>Next message: <A HREF="020720.html">[Mono-dev] Mono Meeting: Venue Update, second update.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20800">[ date ]</a>
              <a href="thread.html#20800">[ thread ]</a>
              <a href="subject.html#20800">[ subject ]</a>
              <a href="author.html#20800">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
