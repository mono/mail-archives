<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] [Mono-devel-list] Operating System in C# Project
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BMono-devel-list%5D%20Operating%20System%20in%20C%23%20Project&In-Reply-To=45464D07.8040705%40fluggo.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="021156.html">
   <LINK REL="Next"  HREF="021160.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] [Mono-devel-list] Operating System in C# Project</H1>
    <B>Johann MacDonagh</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20%5BMono-devel-list%5D%20Operating%20System%20in%20C%23%20Project&In-Reply-To=45464D07.8040705%40fluggo.com"
       TITLE="[Mono-dev] [Mono-devel-list] Operating System in C# Project">johann at macdonaghs.com
       </A><BR>
    <I>Mon Oct 30 14:51:33 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="021156.html">[Mono-dev] [Mono-devel-list] Operating System in C# Project
</A></li>
        <LI>Next message: <A HREF="021160.html">[Mono-dev] [Mono-devel-list] Operating System in C# Project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21157">[ date ]</a>
              <a href="thread.html#21157">[ thread ]</a>
              <a href="subject.html#21157">[ subject ]</a>
              <a href="author.html#21157">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>

Brian Crowell wrote:
&gt;<i> 
</I>&gt;<i> What interests me most about this is a C# program as a first-class
</I>&gt;<i> citizen, or really, every API in the system being not only available, but
</I>&gt;<i> *designed for* managed programs.
</I>&gt;<i> 
</I>
Right. I dislike how current mainstream operating systems regard executables
as &quot;just another file&quot;. Also, a managed API into the actual kernel would
make managed application development much easier.


Brian Crowell wrote:
&gt;<i> 
</I>&gt;<i> I think a good example of that can be found in Microsoft's DirectX, which
</I>&gt;<i> we were just discussing. Compare Managed DirectX to XNA. The differences
</I>&gt;<i> are big. XNA exposes, for the most part, the very same APIs, but in a much
</I>&gt;<i> more intuitive and friendly manner than Managed DirectX.
</I>&gt;<i> 
</I>
I agree. I always considered managed APIs to be easier to use versus a
non-managed API (such as a C library). Perhaps it was because of the extra
meta-data attached to an IL assembly, or perhaps it was because everything
*could* be organized much better (without global consts, etc...). Certainly
the same thing could be achieved with a managed operating system.


Brian Crowell wrote:
&gt;<i> 
</I>&gt;<i> You could consider fully object-oriented operating systems, where the
</I>&gt;<i> design of the API is every bit as important as its concept. You could
</I>&gt;<i> organize the system around safe plug-ins, each providing some service to
</I>&gt;<i> the whole, such as a windowing system, file systems, etc., but which are
</I>&gt;<i> most importantly *as easy to write as implementing an interface or an
</I>&gt;<i> abstract base class.*
</I>&gt;<i> 
</I>
This was also an idea I had. Taking a page from ASP.net 2.0's new
&quot;providers&quot; mentality. The problem is that those usually require some level
of reflection to execute the correct assembly, which may or may not be easy
at such a low level.


Brian Crowell wrote:
&gt;<i> 
</I>&gt;<i> I'd be very interested in participating on design of such a thing. I've
</I>&gt;<i> been trying to teach myself good object-oriented design over the years,
</I>&gt;<i> and I think I would have some good input to give past the initial problem
</I>&gt;<i> of booting such an environment.
</I>&gt;<i> 
</I>&gt;<i> Perhaps the project could be approached in two stages? Half where we boot
</I>&gt;<i> the managed environment, and half where we assume the managed environment.
</I>&gt;<i> You could design and implement these independently of each other. You
</I>&gt;<i> could even design a set of classes to emulate the kernel on top of an
</I>&gt;<i> ordinary runtime, for the purposes of unit testing. One strategy I've
</I>&gt;<i> become fond of, especially where components and unit testing come into
</I>&gt;<i> play, is generous use of the IServiceProvider interface; if components
</I>&gt;<i> accessed kernel objects this way (or a similar way, where you ask for a
</I>&gt;<i> base class but not a specific implementation), they would neither need to
</I>&gt;<i> know or care whether they're using the real thing or not.
</I>&gt;<i> 
</I>&gt;<i> Several thoughts. Exciting stuff.
</I>&gt;<i> 
</I>&gt;<i> --Brian
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>
I'm in the same state as you are. I have many ideas that such an operating
system could evolve into, but lack the knowledge of getting such a system to
boot. There are some problems.

Could we use Mono in it's entirety? Certainly the code for the base class
libraries (mscorlib, System, etc...) could be used. Mono's compiler could
also be used (perhaps slighly adjusted if need be). Its Virtual Execution
Environment would cause the biggest problem. Again, I haven't taken a look
at it in enough detail to make any real claims.

I wouldn't have any reservations against setting up a central location for
brainstorming ideas (a wiki and a Subversion code repository), if there were
enough people interested. The hardest part would be to get someone with
experience in system programming (someone who has created a simple kernel in
C/C++), who would lend a hand in the translation between C# to native code.
-- 
View this message in context: <A HREF="http://www.nabble.com/Re%3A--Mono-devel-list--Operating-System-in-C--Project-tf2349909.html#a7081676">http://www.nabble.com/Re%3A--Mono-devel-list--Operating-System-in-C--Project-tf2349909.html#a7081676</A>
Sent from the Mono - Dev mailing list archive at Nabble.com.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="021156.html">[Mono-dev] [Mono-devel-list] Operating System in C# Project
</A></li>
	<LI>Next message: <A HREF="021160.html">[Mono-dev] [Mono-devel-list] Operating System in C# Project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21157">[ date ]</a>
              <a href="thread.html#21157">[ thread ]</a>
              <a href="subject.html#21157">[ subject ]</a>
              <a href="author.html#21157">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
