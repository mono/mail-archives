<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Parch for Enum support in Custom attributes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Parch%20for%20Enum%20support%20in%20Custom%20attributes&In-Reply-To=45253DFF.1020404%40evain.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020786.html">
   <LINK REL="Next"  HREF="020834.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Parch for Enum support in Custom attributes</H1>
    <B>Eyal Alaluf</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Parch%20for%20Enum%20support%20in%20Custom%20attributes&In-Reply-To=45253DFF.1020404%40evain.net"
       TITLE="[Mono-dev] Parch for Enum support in Custom attributes">eyala at mainsoft.com
       </A><BR>
    <I>Mon Oct  9 08:33:46 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="020786.html">[Mono-dev] Parch for Enum support in Custom attributes
</A></li>
        <LI>Next message: <A HREF="020834.html">[Mono-dev] Parch for Enum support in Custom attributes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20833">[ date ]</a>
              <a href="thread.html#20833">[ thread ]</a>
              <a href="subject.html#20833">[ subject ]</a>
              <a href="author.html#20833">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi, JB.

I worked a bit further on the patch and implemented the ForceRead logic
for custom attributes.
I aded a ForceResolving property to SignatureReader (it was the easiest way
with the previous patch I made). If the patch if acceptable I'll prepare a
separate and smaller patch to simplify SignatureReader abit and remove this
property (pass it as a parameter).
Attached is the patch and slightly modified test case.

Eyal.

On Thu, 5 Oct 2006, Jb Evain wrote:

&gt;<i> Date: Thu, 05 Oct 2006 19:16:47 +0200
</I>&gt;<i> From: Jb Evain &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono at evain.net</A>&gt;
</I>&gt;<i> To: Eyal Alaluf &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">eyala at mainsoft.com</A>&gt;
</I>&gt;<i> Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> Subject: Re: [Mono-dev] Parch for Enum support in Custom attributes
</I>&gt;<i> 
</I>&gt;<i> Hi Eyal,
</I>&gt;<i>
</I>&gt;<i> Thanks for working on this. I don't want to commit it as it is, but I'll 
</I>&gt;<i> surely use part of it. I don't want to load the assembly referenced only for 
</I>&gt;<i> reading a custom attribute body. Instead, I'll create an interface that 
</I>&gt;<i> CustomAttribute and SecurityDeclaration will share, and will allow one to 
</I>&gt;<i> load the content of something that needs to load a reference.
</I>&gt;<i>
</I>&gt;<i> Something like:
</I>&gt;<i>
</I>&gt;<i> CustomAttribute ca = ...;
</I>&gt;<i> if (!ca.Read) {
</I>&gt;<i> 	ca.ForceRead ();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Otherwise, for a lot of assemblies, Cecil will have to load the corelib while 
</I>&gt;<i> the user don't necessary need to read the content of the custom attribute.
</I>&gt;<i>
</I>&gt;<i> Jb
</I>&gt;<i>
</I>&gt;<i> Eyal Alaluf wrote:
</I>&gt;&gt;<i> Hi, JB.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Attached is patch for supporting enums in cutom attributes. Support is 
</I>&gt;&gt;<i> added
</I>&gt;&gt;<i> for enums as ctor parameters as fields and as properties.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> The main problem with Enums is to identify their underlying integral type.
</I>&gt;&gt;<i> Without this integral type the custom attribute cannot be read. The patch
</I>&gt;&gt;<i> uses the assembly resolver for this purpose.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> I have attached a simple test scenraio with 3 C# files.
</I>&gt;&gt;<i>     * Test1.cs is a DLL defining enums and an attribute that has enums as
</I>&gt;&gt;<i>       field properties and ctor params.
</I>&gt;&gt;<i>     * Test2.cs is another DLL that uses the attribute and enums from 
</I>&gt;&gt;<i> Test1.
</I>&gt;&gt;<i>       This exercise the new code that resolves enum types from another 
</I>&gt;&gt;<i> DLL.
</I>&gt;&gt;<i>     * ReadTest2.cs is an EXE written using Cecil that parses test2.dll and
</I>&gt;&gt;<i>       prints the custom attributes of its types. It gets as argument the 
</I>&gt;&gt;<i> path
</I>&gt;&gt;<i>       to the dll it parses.
</I>&gt;&gt;<i> Note that Test1 uses ClassUsageAttaribute from mscorlib. For some reason 
</I>&gt;&gt;<i> the
</I>&gt;&gt;<i> assembly resolver didn't find mscorlib.dll from the GAC when I ran 
</I>&gt;&gt;<i> ReadTest2
</I>&gt;&gt;<i> on Test2 until I put mscorlib.dll in the same dir as Test2 &amp; ReadTest2.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Eyal.
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> ------------------------------------------------------------------------
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> Index: Mono.Cecil/ReflectionReader.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Mono.Cecil/ReflectionReader.cs	(revision 66216)
</I>&gt;&gt;<i> +++ Mono.Cecil/ReflectionReader.cs	(working copy)
</I>&gt;&gt;<i> @@ -65,7 +65,24 @@
</I>&gt;&gt;<i>  		protected CodeReader m_codeReader;
</I>&gt;&gt;<i>  		protected ISymbolReader m_symbolReader;
</I>&gt;&gt;<i>  -		public ModuleDefinition Module {
</I>&gt;&gt;<i> +		internal AssemblyNameReference Corlib
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			get +			{
</I>&gt;&gt;<i> +				if (m_corlib == null) {
</I>&gt;&gt;<i> +					foreach (AssemblyNameReference ar in 
</I>&gt;&gt;<i> m_module.AssemblyReferences) {
</I>&gt;&gt;<i> +						if (ar.Name == 
</I>&gt;&gt;<i> Constants.Corlib) {
</I>&gt;&gt;<i> +							m_corlib = ar;
</I>&gt;&gt;<i> +							break;
</I>&gt;&gt;<i> +						}
</I>&gt;&gt;<i> +					}
</I>&gt;&gt;<i> +				}
</I>&gt;&gt;<i> +				return m_corlib;
</I>&gt;&gt;<i> +			}			+		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		public ModuleDefinition Module +		{
</I>&gt;&gt;<i>  			get { return m_module; }
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>  @@ -295,19 +312,11 @@
</I>&gt;&gt;<i>   			TypeReference coreType =  m_module.TypeReferences 
</I>&gt;&gt;<i> [fullName];
</I>&gt;&gt;<i>  			if (coreType == null) {
</I>&gt;&gt;<i> -				if (m_corlib == null) {
</I>&gt;&gt;<i> -					foreach (AssemblyNameReference ar in 
</I>&gt;&gt;<i> m_module.AssemblyReferences) {
</I>&gt;&gt;<i> -						if (ar.Name == 
</I>&gt;&gt;<i> Constants.Corlib) {
</I>&gt;&gt;<i> -							m_corlib = ar;
</I>&gt;&gt;<i> -							break;
</I>&gt;&gt;<i> -						}
</I>&gt;&gt;<i> -					}
</I>&gt;&gt;<i> -				}
</I>&gt;&gt;<i>   				string [] parts = fullName.Split ('.');
</I>&gt;&gt;<i>  				if (parts.Length != 2)
</I>&gt;&gt;<i>  					throw new ReflectionException 
</I>&gt;&gt;<i> (&quot;Unvalid core type name&quot;);
</I>&gt;&gt;<i> -				coreType = new TypeReference (parts [1], 
</I>&gt;&gt;<i> parts [0], m_corlib);
</I>&gt;&gt;<i> +				coreType = new TypeReference (parts [1], 
</I>&gt;&gt;<i> parts [0], Corlib);
</I>&gt;&gt;<i>  				m_module.TypeReferences.Add (coreType);
</I>&gt;&gt;<i>  			}
</I>&gt;&gt;<i>  			if (!coreType.IsValueType) {
</I>&gt;&gt;<i> Index: ChangeLog
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- ChangeLog	(revision 66226)
</I>&gt;&gt;<i> +++ ChangeLog	(working copy)
</I>&gt;&gt;<i> @@ -1,3 +1,11 @@
</I>&gt;&gt;<i> +2006-10-05  Eyal Alaluf  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">eyala at mainsoft.com</A>&gt;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +	Mono.Cecil/ReflectionReader.cs:
</I>&gt;&gt;<i> +		Expose Corlib assembly refereice so SignatureReader can ise 
</I>&gt;&gt;<i> it.
</I>&gt;&gt;<i> +	Mono.Cecil.Signatures/SignatureReader.cs:
</I>&gt;&gt;<i> +		Added support for enums in custom attributes ctors, 
</I>&gt;&gt;<i> properties and
</I>&gt;&gt;<i> +		fields.
</I>&gt;&gt;<i> +		 2006-10-04  Eyal Alaluf  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">eyala at mainsoft.com</A>&gt;
</I>&gt;&gt;<i>   	* Mono.Cecil/StructureReader.cs:
</I>&gt;&gt;<i> @@ -2,3 +10,2 @@
</I>&gt;&gt;<i>  		Visit the module we load when a DLL has more then 1 module.
</I>&gt;&gt;<i> -			Visit the module we load when a DLL has more then 1 
</I>&gt;&gt;<i> module.
</I>&gt;&gt;<i>  	  Mono.Cecil/AssemblyNameReference.cs:
</I>&gt;&gt;<i> Index: Mono.Cecil.Signatures/SignatureReader.cs
</I>&gt;&gt;<i> ===================================================================
</I>&gt;&gt;<i> --- Mono.Cecil.Signatures/SignatureReader.cs	(revision 66216)
</I>&gt;&gt;<i> +++ Mono.Cecil.Signatures/SignatureReader.cs	(working copy)
</I>&gt;&gt;<i> @@ -587,7 +587,7 @@
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>   		CustomAttrib.FixedArg ReadFixedArg (byte [] data, 
</I>&gt;&gt;<i> BinaryReader br,
</I>&gt;&gt;<i> -			bool array, object param, ref bool read)
</I>&gt;&gt;<i> +			bool array, TypeReference param, ref bool read)
</I>&gt;&gt;<i>  		{
</I>&gt;&gt;<i>  			CustomAttrib.FixedArg fa = new CustomAttrib.FixedArg 
</I>&gt;&gt;<i> ();
</I>&gt;&gt;<i>  			if (array) {
</I>&gt;&gt;<i> @@ -596,6 +596,7 @@
</I>&gt;&gt;<i>   				if (fa.NumElem == 0 || fa.NumElem == 
</I>&gt;&gt;<i> 0xffffffff) {
</I>&gt;&gt;<i>  					fa.Elems = new CustomAttrib.Elem [0];
</I>&gt;&gt;<i> +					fa.NumElem = 0;
</I>&gt;&gt;<i>  					return fa;
</I>&gt;&gt;<i>  				}
</I>&gt;&gt;<i>  @@ -611,6 +612,95 @@
</I>&gt;&gt;<i>  			return fa;
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>  +		TypeReference CreateEnumTypeReference (string enumName)
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			string asmName = null;
</I>&gt;&gt;<i> +			int asmStart = enumName.IndexOf (',');
</I>&gt;&gt;<i> +			if (asmStart != -1) {
</I>&gt;&gt;<i> +				asmName = enumName.Substring (asmStart + 1);
</I>&gt;&gt;<i> +				enumName = enumName.Substring (0, asmStart);
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +			// Inner class style is reflection style.
</I>&gt;&gt;<i> +			enumName = enumName.Replace ('+', '/');
</I>&gt;&gt;<i> +			AssemblyNameReference asm = null;
</I>&gt;&gt;<i> +			if (asmName == null) {
</I>&gt;&gt;<i> +				// If no assembly is given then the ECMA 
</I>&gt;&gt;<i> standard says the
</I>&gt;&gt;<i> +				// assembly is either the current one or 
</I>&gt;&gt;<i> mscorlib.
</I>&gt;&gt;<i> +				if (m_reflectReader.Module.Types[enumName] != 
</I>&gt;&gt;<i> null)
</I>&gt;&gt;<i> +					return 
</I>&gt;&gt;<i> m_reflectReader.Module.Types[enumName];
</I>&gt;&gt;<i> +				asm = m_reflectReader.Corlib;
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +			else
</I>&gt;&gt;<i> +				asm = AssemblyNameReference.Parse (asmName);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			string[] outers = enumName.Split ('/');
</I>&gt;&gt;<i> +			string outerfullname = outers[0];
</I>&gt;&gt;<i> +			string ns = null;
</I>&gt;&gt;<i> +			int nsIndex = outerfullname.LastIndexOf ('.');
</I>&gt;&gt;<i> +			if (nsIndex != -1)
</I>&gt;&gt;<i> +				ns = outerfullname.Substring(0, nsIndex);
</I>&gt;&gt;<i> +			string name = outerfullname.Substring (nsIndex + 1);
</I>&gt;&gt;<i> +			TypeReference decType = new TypeReference (name, ns, 
</I>&gt;&gt;<i> asm);
</I>&gt;&gt;<i> +			for (int i = 1; i &lt; outers.Length; i++)
</I>&gt;&gt;<i> +			{
</I>&gt;&gt;<i> +				TypeReference t = new TypeReference 
</I>&gt;&gt;<i> (outers[i], null, asm);
</I>&gt;&gt;<i> +				t.DeclaringType = decType;
</I>&gt;&gt;<i> +				decType = t;
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +			decType.IsValueType = true;
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			return decType;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		TypeReference ReadTypeReference (byte[] data, BinaryReader 
</I>&gt;&gt;<i> br, out ElementType elemType, out bool array)
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			array = false;
</I>&gt;&gt;<i> +			elemType = (ElementType) br.ReadByte ();
</I>&gt;&gt;<i> +			if (elemType == ElementType.SzArray) + 
</I>&gt;&gt;<i> {
</I>&gt;&gt;<i> +				elemType = (ElementType) br.ReadByte ();
</I>&gt;&gt;<i> +				array = true;
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +			switch (elemType) {
</I>&gt;&gt;<i> +			case ElementType.Enum :
</I>&gt;&gt;<i> +				return CreateEnumTypeReference 
</I>&gt;&gt;<i> (ReadUTF8String (data, br));
</I>&gt;&gt;<i> +			case ElementType.Boxed :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Object);
</I>&gt;&gt;<i> +			case ElementType.String :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.String);
</I>&gt;&gt;<i> +			case ElementType.Type :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Type);
</I>&gt;&gt;<i> +			case ElementType.Boolean :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Boolean);
</I>&gt;&gt;<i> +			case ElementType.Char :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Char);
</I>&gt;&gt;<i> +			case ElementType.R4 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Single);
</I>&gt;&gt;<i> +			case ElementType.R8 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Double);
</I>&gt;&gt;<i> +			case ElementType.I1 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.SByte);
</I>&gt;&gt;<i> +			case ElementType.I2 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Int16);
</I>&gt;&gt;<i> +			case ElementType.I4 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Int32);
</I>&gt;&gt;<i> +			case ElementType.I8 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Int64);
</I>&gt;&gt;<i> +			case ElementType.U1 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.Byte);
</I>&gt;&gt;<i> +			case ElementType.U2 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.UInt16);
</I>&gt;&gt;<i> +			case ElementType.U4 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.UInt32);
</I>&gt;&gt;<i> +			case ElementType.U8 :
</I>&gt;&gt;<i> +				return m_reflectReader.SearchCoreType 
</I>&gt;&gt;<i> (Constants.UInt64);
</I>&gt;&gt;<i> +			default :
</I>&gt;&gt;<i> +				throw new MetadataFormatException (&quot;Non valid 
</I>&gt;&gt;<i> type in CustomAttrib.Elem: 0x{0}&quot;,
</I>&gt;&gt;<i> +					((byte) elemType).ToString(&quot;x2&quot;));
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i>  		internal CustomAttrib.NamedArg ReadNamedArg (byte [] data, 
</I>&gt;&gt;<i> BinaryReader br, ref bool read)
</I>&gt;&gt;<i>  		{
</I>&gt;&gt;<i>  			CustomAttrib.NamedArg na = new CustomAttrib.NamedArg 
</I>&gt;&gt;<i> ();
</I>&gt;&gt;<i> @@ -625,42 +715,15 @@
</I>&gt;&gt;<i>  				throw new MetadataFormatException (&quot;Wrong 
</I>&gt;&gt;<i> kind of namedarg found: 0x&quot; + kind.ToString(&quot;x2&quot;));
</I>&gt;&gt;<i>   			bool array = false;
</I>&gt;&gt;<i> -			na.FieldOrPropType = (ElementType) br.ReadByte ();
</I>&gt;&gt;<i> -			if (na.FieldOrPropType == ElementType.SzArray) {
</I>&gt;&gt;<i> -				na.FieldOrPropType = (ElementType) 
</I>&gt;&gt;<i> br.ReadByte ();
</I>&gt;&gt;<i> -				array = true;
</I>&gt;&gt;<i> -			}
</I>&gt;&gt;<i>  -			int next, length;
</I>&gt;&gt;<i> +			TypeReference elemType = ReadTypeReference (data, br, 
</I>&gt;&gt;<i> out na.FieldOrPropType, out array);
</I>&gt;&gt;<i>  -			if (na.FieldOrPropType == ElementType.Enum) {
</I>&gt;&gt;<i> -				read = false;
</I>&gt;&gt;<i> -				return na;
</I>&gt;&gt;<i> -			}
</I>&gt;&gt;<i> +			na.FieldOrPropName = ReadUTF8String (data, br);
</I>&gt;&gt;<i> +			na.FixedArg = ReadFixedArg (data, br, array, 
</I>&gt;&gt;<i> elemType, ref read);
</I>&gt;&gt;<i>  -			length = Utilities.ReadCompressedInteger (data, (int) 
</I>&gt;&gt;<i> br.BaseStream.Position, out next);
</I>&gt;&gt;<i> -			br.BaseStream.Position = next;
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -			// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) 
</I>&gt;&gt;<i> is not supported.
</I>&gt;&gt;<i> -			byte [] bytes = br.ReadBytes (length);
</I>&gt;&gt;<i> -			na.FieldOrPropName = Encoding.UTF8.GetString (bytes, 
</I>&gt;&gt;<i> 0, bytes.Length);
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -			na.FixedArg = ReadFixedArg (data, br, array, 
</I>&gt;&gt;<i> na.FieldOrPropType, ref read);
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i>  			return na;
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>  -		// i hate this construction, should find something better
</I>&gt;&gt;<i> -		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, 
</I>&gt;&gt;<i> object param, ref bool read)
</I>&gt;&gt;<i> -		{
</I>&gt;&gt;<i> -			if (param is TypeReference)
</I>&gt;&gt;<i> -				return ReadElem (data, br, param as 
</I>&gt;&gt;<i> TypeReference, ref read);
</I>&gt;&gt;<i> -			else if (param is ElementType)
</I>&gt;&gt;<i> -				return ReadElem (data, br, (ElementType) 
</I>&gt;&gt;<i> param, ref read);
</I>&gt;&gt;<i> -			else
</I>&gt;&gt;<i> -				throw new MetadataFormatException (&quot;Wrong 
</I>&gt;&gt;<i> parameter for ReadElem: &quot; + param.GetType ().FullName);
</I>&gt;&gt;<i> -		}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i>  		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, 
</I>&gt;&gt;<i> TypeReference elemType, ref bool read)
</I>&gt;&gt;<i>  		{
</I>&gt;&gt;<i>  			CustomAttrib.Elem elem = new CustomAttrib.Elem ();
</I>&gt;&gt;<i> @@ -668,11 +731,20 @@
</I>&gt;&gt;<i>  			string elemName = elemType.FullName;
</I>&gt;&gt;<i>   			if (elemName == Constants.Object) {
</I>&gt;&gt;<i> -				ElementType elementType = (ElementType) 
</I>&gt;&gt;<i> br.ReadByte ();
</I>&gt;&gt;<i> -				elem = ReadElem (data, br, elementType, ref 
</I>&gt;&gt;<i> read);
</I>&gt;&gt;<i> +				bool array;
</I>&gt;&gt;<i> +				elemType = ReadTypeReference (data, br, out 
</I>&gt;&gt;<i> elem.FieldOrPropType, out array);
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +				if (array) {
</I>&gt;&gt;<i> +					read = false; // Don't know how to 
</I>&gt;&gt;<i> represent arrays as an object value.
</I>&gt;&gt;<i> +					return elem;
</I>&gt;&gt;<i> +				}
</I>&gt;&gt;<i> +				else if (elemType.FullName == 
</I>&gt;&gt;<i> Constants.Object)
</I>&gt;&gt;<i> +					throw new MetadataFormatException 
</I>&gt;&gt;<i> (&quot;Non valid type in CustomAttrib.Elem after boxed prefix: 0x{0}&quot;,
</I>&gt;&gt;<i> +						((byte) 
</I>&gt;&gt;<i> elem.FieldOrPropType).ToString(&quot;x2&quot;));
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +				elem = ReadElem (data, br, elemType, ref 
</I>&gt;&gt;<i> read);
</I>&gt;&gt;<i>  				elem.String = elem.Simple = elem.Type = 
</I>&gt;&gt;<i> false;
</I>&gt;&gt;<i>  				elem.BoxedValueType = true;
</I>&gt;&gt;<i> -				elem.FieldOrPropType = elementType;
</I>&gt;&gt;<i>  				return elem;
</I>&gt;&gt;<i>  			}
</I>&gt;&gt;<i>  @@ -694,19 +766,45 @@
</I>&gt;&gt;<i>  					elem.Value = null;
</I>&gt;&gt;<i>  					br.BaseStream.Position++;
</I>&gt;&gt;<i>  				} else {
</I>&gt;&gt;<i> -					int next, length = 
</I>&gt;&gt;<i> Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, out 
</I>&gt;&gt;<i> next);
</I>&gt;&gt;<i> -					br.BaseStream.Position = next;
</I>&gt;&gt;<i> -					// COMPACT FRAMEWORK NOTE: 
</I>&gt;&gt;<i> Encoding.GetString(byte[]) is not supported.
</I>&gt;&gt;<i> -					byte [] bytes = br.ReadBytes 
</I>&gt;&gt;<i> (length);
</I>&gt;&gt;<i> -					elem.Value = Encoding.UTF8.GetString 
</I>&gt;&gt;<i> (bytes, 0, bytes.Length);
</I>&gt;&gt;<i> +					elem.Value = ReadUTF8String (data, 
</I>&gt;&gt;<i> br);
</I>&gt;&gt;<i>  				}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i>  				return elem;
</I>&gt;&gt;<i>  			}
</I>&gt;&gt;<i>   			elem.String = elem.Type = elem.BoxedValueType = 
</I>&gt;&gt;<i> false;
</I>&gt;&gt;<i> +			if (!readSimpleValue (br, ref elem, elem.ElemType)) {
</I>&gt;&gt;<i> +				TypeReference typeRef = GetEnumUnderlyingType 
</I>&gt;&gt;<i> (elem.ElemType);
</I>&gt;&gt;<i> +				if (typeRef == null || !readSimpleValue (br, 
</I>&gt;&gt;<i> ref elem, typeRef))
</I>&gt;&gt;<i> +					read = false;
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i>  -			switch (elemName) {
</I>&gt;&gt;<i> +			return elem;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		private IAssemblyResolver AssemblyResolver
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			get +			{ + 
</I>&gt;&gt;<i> return m_reflectReader.Module.Assembly.Resolver;
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		private TypeReference GetEnumUnderlyingType (TypeReference 
</I>&gt;&gt;<i> enumType)
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			TypeDefinition type = enumType as TypeDefinition;
</I>&gt;&gt;<i> +			if (type == null &amp;&amp; AssemblyResolver != null) + 
</I>&gt;&gt;<i> {
</I>&gt;&gt;<i> +				AssemblyDefinition asm = 
</I>&gt;&gt;<i> AssemblyResolver.Resolve (enumType.Scope.Name);
</I>&gt;&gt;<i> +				type = 
</I>&gt;&gt;<i> asm.MainModule.Types[enumType.FullName];
</I>&gt;&gt;<i> +			}
</I>&gt;&gt;<i> +			if (type != null &amp;&amp; type.IsEnum)
</I>&gt;&gt;<i> +				return type.Fields.GetField 
</I>&gt;&gt;<i> (&quot;value__&quot;).FieldType;
</I>&gt;&gt;<i> +			return null;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i> +		bool readSimpleValue (BinaryReader br, ref CustomAttrib.Elem 
</I>&gt;&gt;<i> elem, TypeReference type)
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			switch (type.FullName) {
</I>&gt;&gt;<i>  			case Constants.Boolean :
</I>&gt;&gt;<i>  				elem.Value = br.ReadByte () == 1;
</I>&gt;&gt;<i>  				break;
</I>&gt;&gt;<i> @@ -744,120 +842,12 @@
</I>&gt;&gt;<i>  				elem.Value = br.ReadUInt64 ();
</I>&gt;&gt;<i>  				break;
</I>&gt;&gt;<i>  			default : // enum
</I>&gt;&gt;<i> -				read = false;
</I>&gt;&gt;<i> -				return elem;
</I>&gt;&gt;<i> +				return false;
</I>&gt;&gt;<i>  			}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i>  			elem.Simple = true;
</I>&gt;&gt;<i> -			return elem;
</I>&gt;&gt;<i> +			return true;
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>  -		// elem in named args, only have an ElementType
</I>&gt;&gt;<i> -		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, 
</I>&gt;&gt;<i> ElementType elemType, ref bool read)
</I>&gt;&gt;<i> -		{
</I>&gt;&gt;<i> -			CustomAttrib.Elem elem = new CustomAttrib.Elem ();
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -			if (elemType == ElementType.Boxed) {
</I>&gt;&gt;<i> -				ElementType elementType = (ElementType) 
</I>&gt;&gt;<i> br.ReadByte ();
</I>&gt;&gt;<i> -				elem = ReadElem (data, br, elementType, ref 
</I>&gt;&gt;<i> read);
</I>&gt;&gt;<i> -				elem.String = elem.Simple = elem.Type = 
</I>&gt;&gt;<i> false;
</I>&gt;&gt;<i> -				elem.BoxedValueType = true;
</I>&gt;&gt;<i> -				elem.FieldOrPropType = elementType;
</I>&gt;&gt;<i> -				return elem;
</I>&gt;&gt;<i> -			}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -			if (elemType == ElementType.Type || elemType == 
</I>&gt;&gt;<i> ElementType.String) { // type or string
</I>&gt;&gt;<i> -				switch (elemType) {
</I>&gt;&gt;<i> -				case ElementType.String :
</I>&gt;&gt;<i> -					elem.String = true;
</I>&gt;&gt;<i> -					elem.BoxedValueType = elem.Simple = 
</I>&gt;&gt;<i> elem.Type = false;
</I>&gt;&gt;<i> -					elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.String);
</I>&gt;&gt;<i> -					break;
</I>&gt;&gt;<i> -				case ElementType.Type :
</I>&gt;&gt;<i> -					elem.Type = true;
</I>&gt;&gt;<i> -					elem.BoxedValueType = elem.Simple = 
</I>&gt;&gt;<i> elem.String = false;
</I>&gt;&gt;<i> -					elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.Type);
</I>&gt;&gt;<i> -					break;
</I>&gt;&gt;<i> -				}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -				if (data [br.BaseStream.Position] == 0xff) { 
</I>&gt;&gt;<i> // null
</I>&gt;&gt;<i> -					elem.Value = null;
</I>&gt;&gt;<i> -					br.BaseStream.Position++;
</I>&gt;&gt;<i> -				} else {
</I>&gt;&gt;<i> -					int next, length = 
</I>&gt;&gt;<i> Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, out 
</I>&gt;&gt;<i> next);
</I>&gt;&gt;<i> -					br.BaseStream.Position = next;
</I>&gt;&gt;<i> -					// COMPACT FRAMEWORK NOTE: 
</I>&gt;&gt;<i> Encoding.GetString(byte[]) is not supported.
</I>&gt;&gt;<i> -					byte [] bytes = br.ReadBytes 
</I>&gt;&gt;<i> (length);
</I>&gt;&gt;<i> -					elem.Value = Encoding.UTF8.GetString 
</I>&gt;&gt;<i> (bytes, 0, bytes.Length);
</I>&gt;&gt;<i> -				}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -				return elem;
</I>&gt;&gt;<i> -			}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -			elem.String = elem.Type = elem.BoxedValueType = 
</I>&gt;&gt;<i> false;
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -			switch (elemType) {
</I>&gt;&gt;<i> -			case ElementType.Boolean :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.Boolean);
</I>&gt;&gt;<i> -				elem.Value = br.ReadByte () == 1;
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.Char :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.Char);
</I>&gt;&gt;<i> -				elem.Value = (char) br.ReadUInt16 ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.R4 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.Single);
</I>&gt;&gt;<i> -				elem.Value = br.ReadSingle ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.R8 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.Double);
</I>&gt;&gt;<i> -				elem.Value = br.ReadDouble ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.I1 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.SByte);
</I>&gt;&gt;<i> -				elem.Value = br.ReadSByte ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.I2 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.Int16);
</I>&gt;&gt;<i> -				elem.Value = br.ReadInt16 ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.I4 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.Int32);
</I>&gt;&gt;<i> -				elem.Value = br.ReadInt32 ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.I8 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.Int64);
</I>&gt;&gt;<i> -				elem.Value = br.ReadInt64 ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.U1 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.Byte);
</I>&gt;&gt;<i> -				elem.Value = br.ReadByte ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.U2 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.UInt16);
</I>&gt;&gt;<i> -				elem.Value = br.ReadUInt16 ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.U4 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.UInt32);
</I>&gt;&gt;<i> -				elem.Value = br.ReadUInt32 ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.U8 :
</I>&gt;&gt;<i> -				elem.ElemType = 
</I>&gt;&gt;<i> m_reflectReader.SearchCoreType (Constants.UInt64);
</I>&gt;&gt;<i> -				elem.Value = br.ReadUInt64 ();
</I>&gt;&gt;<i> -				break;
</I>&gt;&gt;<i> -			case ElementType.Enum :
</I>&gt;&gt;<i> -				read = false;
</I>&gt;&gt;<i> -				return elem;
</I>&gt;&gt;<i> -			default :
</I>&gt;&gt;<i> -				throw new MetadataFormatException (&quot;Non valid 
</I>&gt;&gt;<i> type in CustomAttrib.Elem: 0x{0}&quot;,
</I>&gt;&gt;<i> -					((byte) elemType).ToString(&quot;x2&quot;));
</I>&gt;&gt;<i> -			}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i> -			read = true;
</I>&gt;&gt;<i> -			elem.Simple = true;
</I>&gt;&gt;<i> -			return elem;
</I>&gt;&gt;<i> -		}
</I>&gt;&gt;<i> -
</I>&gt;&gt;<i>  		MarshalSig ReadMarshalSig (byte [] data)
</I>&gt;&gt;<i>  		{
</I>&gt;&gt;<i>  			int start;
</I>&gt;&gt;<i> @@ -905,14 +895,21 @@
</I>&gt;&gt;<i>  			return ms;
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>  +		static internal string ReadUTF8String (byte [] data, 
</I>&gt;&gt;<i> BinaryReader br)
</I>&gt;&gt;<i> +		{
</I>&gt;&gt;<i> +			int start = (int)br.BaseStream.Position;
</I>&gt;&gt;<i> +			string val = ReadUTF8String (data, start, out start);
</I>&gt;&gt;<i> +			br.BaseStream.Position = start;
</I>&gt;&gt;<i> +			return val;
</I>&gt;&gt;<i> +		}
</I>&gt;&gt;<i> +
</I>&gt;&gt;<i>  		static internal string ReadUTF8String (byte [] data, int pos, 
</I>&gt;&gt;<i> out int start)
</I>&gt;&gt;<i>  		{
</I>&gt;&gt;<i>  			int length = Utilities.ReadCompressedInteger (data, 
</I>&gt;&gt;<i> pos, out start);
</I>&gt;&gt;<i> -			byte [] str = new byte [length];
</I>&gt;&gt;<i> -			Buffer.BlockCopy (data, start, str, 0, length);
</I>&gt;&gt;<i> +			pos = start;
</I>&gt;&gt;<i>  			start += length;
</I>&gt;&gt;<i> -			// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) 
</I>&gt;&gt;<i> is not supported.
</I>&gt;&gt;<i> -			return Encoding.UTF8.GetString (str, 0, str.Length);
</I>&gt;&gt;<i> +			// COMPACT FRAMEWORK NOTE: Encoding.GetString 
</I>&gt;&gt;<i> (byte[]) is not supported.
</I>&gt;&gt;<i> +			return Encoding.UTF8.GetString (data, pos, length);
</I>&gt;&gt;<i>  		}
</I>&gt;&gt;<i>  	}
</I>&gt;&gt;<i>  }
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> ------------------------------------------------------------------------
</I>&gt;&gt;<i> 
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>-------------- next part --------------
Index: Mono.Cecil/CustomAttribute.cs

===================================================================

--- Mono.Cecil/CustomAttribute.cs	(revision 66447)

+++ Mono.Cecil/CustomAttribute.cs	(working copy)

@@ -102,6 +102,19 @@

 			set { m_blob = value; }
 		}
 
+		public bool ForceRead ()
+		{
+			if (IsReadable)
+				return true;
+
+			ReflectionReader r = m_ctor.DeclaringType.Module.Controller.Reader;
+			CustomAttribute newCa = r.GetCustomAttribute (m_ctor, Blob, true);
+			if (!newCa.IsReadable)
+				return false;
+			newCa.CopyTo (this);
+			return true;
+		}
+
 		public CustomAttribute (MethodReference ctor)
 		{
 			m_ctor = ctor;
@@ -135,6 +148,7 @@

 
 		static void Clone (IDictionary original, IDictionary target)
 		{
+			target.Clear ();
 			foreach (DictionaryEntry entry in original)
 				target.Add (entry.Key, entry.Value);
 		}
@@ -142,19 +156,24 @@

 		internal static CustomAttribute Clone (CustomAttribute custattr, ImportContext context)
 		{
 			CustomAttribute ca = new CustomAttribute (context.Import (custattr.Constructor));
-			if (!custattr.IsReadable) {
-				ca.IsReadable = false;
-				ca.Blob = custattr.Blob;
-				return ca;
+			custattr.CopyTo(ca);
+			return ca;
+		}
+
+		private void CopyTo (CustomAttribute target)
+		{
+			target.IsReadable = IsReadable;
+			if (!IsReadable) {
+				target.Blob = Blob;
+				return;
 			}
 
-			foreach (object o in custattr.ConstructorParameters)
-				ca.ConstructorParameters.Add (o);
-			Clone (custattr.Fields, ca.Fields);
-			Clone (custattr.FieldTypes, ca.FieldTypes);
-			Clone (custattr.Properties, ca.Properties);
-			Clone (custattr.PropertyTypes, ca.PropertyTypes);
-			return ca;
+			foreach (object o in ConstructorParameters)
+				target.ConstructorParameters.Add (o);
+			Clone (Fields, target.Fields);
+			Clone (FieldTypes, target.FieldTypes);
+			Clone (Properties, target.Properties);
+			Clone (PropertyTypes, target.PropertyTypes);
 		}
 
 		public void Accept (IReflectionVisitor visitor)
Index: Mono.Cecil/ReflectionReader.cs

===================================================================

--- Mono.Cecil/ReflectionReader.cs	(revision 66447)

+++ Mono.Cecil/ReflectionReader.cs	(working copy)

@@ -65,7 +65,24 @@

 		protected CodeReader m_codeReader;
 		protected ISymbolReader m_symbolReader;
 
-		public ModuleDefinition Module {
+		internal AssemblyNameReference Corlib
+		{
+			get 
+			{
+				if (m_corlib == null) {
+					foreach (AssemblyNameReference ar in m_module.AssemblyReferences) {
+						if (ar.Name == Constants.Corlib) {
+							m_corlib = ar;
+							break;
+						}
+					}
+				}
+				return m_corlib;
+			}			
+		}
+
+		public ModuleDefinition Module 
+		{
 			get { return m_module; }
 		}
 
@@ -295,19 +312,11 @@

 
 			TypeReference coreType =  m_module.TypeReferences [fullName];
 			if (coreType == null) {
-				if (m_corlib == null) {
-					foreach (AssemblyNameReference ar in m_module.AssemblyReferences) {
-						if (ar.Name == Constants.Corlib) {
-							m_corlib = ar;
-							break;
-						}
-					}
-				}
 
 				string [] parts = fullName.Split ('.');
 				if (parts.Length != 2)
 					throw new ReflectionException (&quot;Unvalid core type name&quot;);
-				coreType = new TypeReference (parts [1], parts [0], m_corlib);
+				coreType = new TypeReference (parts [1], parts [0], Corlib);
 				m_module.TypeReferences.Add (coreType);
 			}
 			if (!coreType.IsValueType) {
@@ -355,12 +364,20 @@

 			}
 		}
 
-		public CustomAttribute GetCustomAttribute (MethodReference ctor, byte [] data)
+		public CustomAttribute GetCustomAttribute (MethodReference ctor, byte [] data, bool forceResolving)
 		{
+			bool keepForceResolving = m_sigReader.ForceResolving;
+			m_sigReader.ForceResolving = forceResolving;
 			CustomAttrib sig = m_sigReader.GetCustomAttrib (data, ctor);
+			m_sigReader.ForceResolving = keepForceResolving;
 			return BuildCustomAttribute (ctor, sig);
 		}
 
+		public CustomAttribute GetCustomAttribute (MethodReference ctor, byte [] data)
+		{
+			return GetCustomAttribute (ctor, data, false);
+		}
+
 		public override void VisitModuleDefinition (ModuleDefinition mod)
 		{
 			VisitTypeDefinitionCollection (mod.Types);
Index: ChangeLog

===================================================================

--- ChangeLog	(revision 66447)

+++ ChangeLog	(working copy)

@@ -1,3 +1,17 @@

+2006-10-09  Eyal Alaluf  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">eyala at mainsoft.com</A>&gt;
+
+	Mono.Cecil.Signatures/SignatureReader.cs:
+		Added support for enums in custom attributes ctors, properties and
+		fields.
+	Mono.Cecil/CustomAttribute.cs:
+		Add support for rereading custom attributes that contain references
+		to enum in other assemblies.
+	Mono.Cecil/ReflectionReader.cs:
+		Add support for reading custom attributes while resolving enums from
+		other assemblies then the current one.
+	Mono.Cecil/ReflectionReader.cs:
+		Expose Corlib assembly refereice so SignatureReader can ise it.
+		
 2006-10-09  Jb Evain  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jbevain at gmail.com</A>&gt;
 
 	* Mono.Cecil/SecurityDeclarationReader.cs:
@@ -8,7 +22,6 @@

 
 	* Mono.Cecil/StructureReader.cs:
 		Visit the module we load when a DLL has more then 1 module.
-			Visit the module we load when a DLL has more then 1 module.
 	  Mono.Cecil/AssemblyNameReference.cs:
 	  	Allow &quot;PublicToken=null&quot; when parsing an assembly full name.
 
Index: Mono.Cecil.Signatures/SignatureReader.cs

===================================================================

--- Mono.Cecil.Signatures/SignatureReader.cs	(revision 66447)

+++ Mono.Cecil.Signatures/SignatureReader.cs	(working copy)

@@ -41,6 +41,7 @@

 		MetadataRoot m_root;
 		ReflectionReader m_reflectReader;
 		byte [] m_blobData;
+		bool m_forceResolving = false;
 
 		IDictionary m_signatures;
 
@@ -54,6 +55,12 @@

 			m_signatures = new Hashtable ();
 		}
 
+		public bool ForceResolving
+		{
+			get { return m_forceResolving; }
+			set { m_forceResolving = value; }
+		}
+
 		public FieldSig GetFieldSig (uint index)
 		{
 			FieldSig f = m_signatures [index] as FieldSig;
@@ -587,7 +594,7 @@

 		}
 
 		CustomAttrib.FixedArg ReadFixedArg (byte [] data, BinaryReader br,
-			bool array, object param, ref bool read)
+			bool array, TypeReference param, ref bool read)
 		{
 			CustomAttrib.FixedArg fa = new CustomAttrib.FixedArg ();
 			if (array) {
@@ -596,6 +603,7 @@

 
 				if (fa.NumElem == 0 || fa.NumElem == 0xffffffff) {
 					fa.Elems = new CustomAttrib.Elem [0];
+					fa.NumElem = 0;
 					return fa;
 				}
 
@@ -611,6 +619,95 @@

 			return fa;
 		}
 
+		TypeReference CreateEnumTypeReference (string enumName)
+		{
+			string asmName = null;
+			int asmStart = enumName.IndexOf (',');
+			if (asmStart != -1) {
+				asmName = enumName.Substring (asmStart + 1);
+				enumName = enumName.Substring (0, asmStart);
+			}
+			// Inner class style is reflection style.
+			enumName = enumName.Replace ('+', '/');
+			AssemblyNameReference asm = null;
+			if (asmName == null) {
+				// If no assembly is given then the ECMA standard says the
+				// assembly is either the current one or mscorlib.
+				if (m_reflectReader.Module.Types[enumName] != null)
+					return m_reflectReader.Module.Types[enumName];
+				asm = m_reflectReader.Corlib;
+			}
+			else
+				asm = AssemblyNameReference.Parse (asmName);
+
+			string[] outers = enumName.Split ('/');
+			string outerfullname = outers[0];
+			string ns = null;
+			int nsIndex = outerfullname.LastIndexOf ('.');
+			if (nsIndex != -1)
+				ns = outerfullname.Substring(0, nsIndex);
+			string name = outerfullname.Substring (nsIndex + 1);
+			TypeReference decType = new TypeReference (name, ns, asm);
+			for (int i = 1; i &lt; outers.Length; i++)
+			{
+				TypeReference t = new TypeReference (outers[i], null, asm);
+				t.DeclaringType = decType;
+				decType = t;
+			}
+			decType.IsValueType = true;
+
+			return decType;
+		}
+
+		TypeReference ReadTypeReference (byte[] data, BinaryReader br, out ElementType elemType, out bool array)
+		{
+			array = false;
+			elemType = (ElementType) br.ReadByte ();
+			if (elemType == ElementType.SzArray) 
+			{
+				elemType = (ElementType) br.ReadByte ();
+				array = true;
+			}
+
+			switch (elemType) {
+			case ElementType.Enum :
+				return CreateEnumTypeReference (ReadUTF8String (data, br));
+			case ElementType.Boxed :
+				return m_reflectReader.SearchCoreType (Constants.Object);
+			case ElementType.String :
+				return m_reflectReader.SearchCoreType (Constants.String);
+			case ElementType.Type :
+				return m_reflectReader.SearchCoreType (Constants.Type);
+			case ElementType.Boolean :
+				return m_reflectReader.SearchCoreType (Constants.Boolean);
+			case ElementType.Char :
+				return m_reflectReader.SearchCoreType (Constants.Char);
+			case ElementType.R4 :
+				return m_reflectReader.SearchCoreType (Constants.Single);
+			case ElementType.R8 :
+				return m_reflectReader.SearchCoreType (Constants.Double);
+			case ElementType.I1 :
+				return m_reflectReader.SearchCoreType (Constants.SByte);
+			case ElementType.I2 :
+				return m_reflectReader.SearchCoreType (Constants.Int16);
+			case ElementType.I4 :
+				return m_reflectReader.SearchCoreType (Constants.Int32);
+			case ElementType.I8 :
+				return m_reflectReader.SearchCoreType (Constants.Int64);
+			case ElementType.U1 :
+				return m_reflectReader.SearchCoreType (Constants.Byte);
+			case ElementType.U2 :
+				return m_reflectReader.SearchCoreType (Constants.UInt16);
+			case ElementType.U4 :
+				return m_reflectReader.SearchCoreType (Constants.UInt32);
+			case ElementType.U8 :
+				return m_reflectReader.SearchCoreType (Constants.UInt64);
+			default :
+				throw new MetadataFormatException (&quot;Non valid type in CustomAttrib.Elem: 0x{0}&quot;,
+					((byte) elemType).ToString(&quot;x2&quot;));
+			}
+		}
+
 		internal CustomAttrib.NamedArg ReadNamedArg (byte [] data, BinaryReader br, ref bool read)
 		{
 			CustomAttrib.NamedArg na = new CustomAttrib.NamedArg ();
@@ -625,42 +722,15 @@

 				throw new MetadataFormatException (&quot;Wrong kind of namedarg found: 0x&quot; + kind.ToString(&quot;x2&quot;));
 
 			bool array = false;
-			na.FieldOrPropType = (ElementType) br.ReadByte ();
-			if (na.FieldOrPropType == ElementType.SzArray) {
-				na.FieldOrPropType = (ElementType) br.ReadByte ();
-				array = true;
-			}
 
-			int next, length;
+			TypeReference elemType = ReadTypeReference (data, br, out na.FieldOrPropType, out array);
 
-			if (na.FieldOrPropType == ElementType.Enum) {
-				read = false;
-				return na;
-			}
+			na.FieldOrPropName = ReadUTF8String (data, br);
+			na.FixedArg = ReadFixedArg (data, br, array, elemType, ref read);
 
-			length = Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, out next);
-			br.BaseStream.Position = next;
-
-			// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is not supported.
-			byte [] bytes = br.ReadBytes (length);
-			na.FieldOrPropName = Encoding.UTF8.GetString (bytes, 0, bytes.Length);
-
-			na.FixedArg = ReadFixedArg (data, br, array, na.FieldOrPropType, ref read);
-
 			return na;
 		}
 
-		// i hate this construction, should find something better
-		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, object param, ref bool read)
-		{
-			if (param is TypeReference)
-				return ReadElem (data, br, param as TypeReference, ref read);
-			else if (param is ElementType)
-				return ReadElem (data, br, (ElementType) param, ref read);
-			else
-				throw new MetadataFormatException (&quot;Wrong parameter for ReadElem: &quot; + param.GetType ().FullName);
-		}
-
 		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, TypeReference elemType, ref bool read)
 		{
 			CustomAttrib.Elem elem = new CustomAttrib.Elem ();
@@ -668,11 +738,20 @@

 			string elemName = elemType.FullName;
 
 			if (elemName == Constants.Object) {
-				ElementType elementType = (ElementType) br.ReadByte ();
-				elem = ReadElem (data, br, elementType, ref read);
+				bool array;
+				elemType = ReadTypeReference (data, br, out elem.FieldOrPropType, out array);
+
+				if (array) {
+					read = false; // Don't know how to represent arrays as an object value.
+					return elem;
+				}
+				else if (elemType.FullName == Constants.Object)
+					throw new MetadataFormatException (&quot;Non valid type in CustomAttrib.Elem after boxed prefix: 0x{0}&quot;,
+						((byte) elem.FieldOrPropType).ToString(&quot;x2&quot;));
+
+				elem = ReadElem (data, br, elemType, ref read);
 				elem.String = elem.Simple = elem.Type = false;
 				elem.BoxedValueType = true;
-				elem.FieldOrPropType = elementType;
 				return elem;
 			}
 
@@ -694,19 +773,45 @@

 					elem.Value = null;
 					br.BaseStream.Position++;
 				} else {
-					int next, length = Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, out next);
-					br.BaseStream.Position = next;
-					// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is not supported.
-					byte [] bytes = br.ReadBytes (length);
-					elem.Value = Encoding.UTF8.GetString (bytes, 0, bytes.Length);
+					elem.Value = ReadUTF8String (data, br);
 				}
-
 				return elem;
 			}
 
 			elem.String = elem.Type = elem.BoxedValueType = false;
+			if (!readSimpleValue (br, ref elem, elem.ElemType)) {
+				TypeReference typeRef = GetEnumUnderlyingType (elem.ElemType);
+				if (typeRef == null || !readSimpleValue (br, ref elem, typeRef))
+					read = false;
+			}
 
-			switch (elemName) {
+			return elem;
+		}
+
+		private IAssemblyResolver AssemblyResolver
+		{
+			get 
+			{ 
+				return m_reflectReader.Module.Assembly.Resolver;
+			}
+		}
+
+		private TypeReference GetEnumUnderlyingType (TypeReference enumType)
+		{
+			TypeDefinition type = enumType as TypeDefinition;
+			if (type == null &amp;&amp; ForceResolving &amp;&amp; AssemblyResolver != null) 
+			{
+				AssemblyDefinition asm = AssemblyResolver.Resolve (enumType.Scope.Name);
+				type = asm.MainModule.Types[enumType.FullName];
+			}
+			if (type != null &amp;&amp; type.IsEnum)
+				return type.Fields.GetField (&quot;value__&quot;).FieldType;
+			return null;
+		}
+
+		bool readSimpleValue (BinaryReader br, ref CustomAttrib.Elem elem, TypeReference type)
+		{
+			switch (type.FullName) {
 			case Constants.Boolean :
 				elem.Value = br.ReadByte () == 1;
 				break;
@@ -744,120 +849,12 @@

 				elem.Value = br.ReadUInt64 ();
 				break;
 			default : // enum
-				read = false;
-				return elem;
+				return false;
 			}
-
 			elem.Simple = true;
-			return elem;
+			return true;
 		}
 
-		// elem in named args, only have an ElementType
-		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, ElementType elemType, ref bool read)
-		{
-			CustomAttrib.Elem elem = new CustomAttrib.Elem ();
-
-			if (elemType == ElementType.Boxed) {
-				ElementType elementType = (ElementType) br.ReadByte ();
-				elem = ReadElem (data, br, elementType, ref read);
-				elem.String = elem.Simple = elem.Type = false;
-				elem.BoxedValueType = true;
-				elem.FieldOrPropType = elementType;
-				return elem;
-			}
-
-			if (elemType == ElementType.Type || elemType == ElementType.String) { // type or string
-				switch (elemType) {
-				case ElementType.String :
-					elem.String = true;
-					elem.BoxedValueType = elem.Simple = elem.Type = false;
-					elem.ElemType = m_reflectReader.SearchCoreType (Constants.String);
-					break;
-				case ElementType.Type :
-					elem.Type = true;
-					elem.BoxedValueType = elem.Simple = elem.String = false;
-					elem.ElemType = m_reflectReader.SearchCoreType (Constants.Type);
-					break;
-				}
-
-				if (data [br.BaseStream.Position] == 0xff) { // null
-					elem.Value = null;
-					br.BaseStream.Position++;
-				} else {
-					int next, length = Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, out next);
-					br.BaseStream.Position = next;
-					// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is not supported.
-					byte [] bytes = br.ReadBytes (length);
-					elem.Value = Encoding.UTF8.GetString (bytes, 0, bytes.Length);
-				}
-
-				return elem;
-			}
-
-			elem.String = elem.Type = elem.BoxedValueType = false;
-
-			switch (elemType) {
-			case ElementType.Boolean :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Boolean);
-				elem.Value = br.ReadByte () == 1;
-				break;
-			case ElementType.Char :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Char);
-				elem.Value = (char) br.ReadUInt16 ();
-				break;
-			case ElementType.R4 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Single);
-				elem.Value = br.ReadSingle ();
-				break;
-			case ElementType.R8 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Double);
-				elem.Value = br.ReadDouble ();
-				break;
-			case ElementType.I1 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.SByte);
-				elem.Value = br.ReadSByte ();
-				break;
-			case ElementType.I2 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Int16);
-				elem.Value = br.ReadInt16 ();
-				break;
-			case ElementType.I4 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Int32);
-				elem.Value = br.ReadInt32 ();
-				break;
-			case ElementType.I8 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Int64);
-				elem.Value = br.ReadInt64 ();
-				break;
-			case ElementType.U1 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Byte);
-				elem.Value = br.ReadByte ();
-				break;
-			case ElementType.U2 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.UInt16);
-				elem.Value = br.ReadUInt16 ();
-				break;
-			case ElementType.U4 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.UInt32);
-				elem.Value = br.ReadUInt32 ();
-				break;
-			case ElementType.U8 :
-				elem.ElemType = m_reflectReader.SearchCoreType (Constants.UInt64);
-				elem.Value = br.ReadUInt64 ();
-				break;
-			case ElementType.Enum :
-				read = false;
-				return elem;
-			default :
-				throw new MetadataFormatException (&quot;Non valid type in CustomAttrib.Elem: 0x{0}&quot;,
-					((byte) elemType).ToString(&quot;x2&quot;));
-			}
-
-			read = true;
-			elem.Simple = true;
-			return elem;
-		}
-
 		MarshalSig ReadMarshalSig (byte [] data)
 		{
 			int start;
@@ -905,14 +902,21 @@

 			return ms;
 		}
 
+		static internal string ReadUTF8String (byte [] data, BinaryReader br)
+		{
+			int start = (int)br.BaseStream.Position;
+			string val = ReadUTF8String (data, start, out start);
+			br.BaseStream.Position = start;
+			return val;
+		}
+
 		static internal string ReadUTF8String (byte [] data, int pos, out int start)
 		{
 			int length = Utilities.ReadCompressedInteger (data, pos, out start);
-			byte [] str = new byte [length];
-			Buffer.BlockCopy (data, start, str, 0, length);
+			pos = start;
 			start += length;
-			// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is not supported.
-			return Encoding.UTF8.GetString (str, 0, str.Length);
+			// COMPACT FRAMEWORK NOTE: Encoding.GetString (byte[]) is not supported.
+			return Encoding.UTF8.GetString (data, pos, length);
 		}
 	}
 }
-------------- next part --------------
A non-text attachment was scrubbed...
Name: mytests.zip
Type: application/zip
Size: 1716 bytes
Desc: 
Url : <A HREF="http://lists.ximian.com/pipermail/mono-devel-list/attachments/20061009/288a139a/attachment.zip">http://lists.ximian.com/pipermail/mono-devel-list/attachments/20061009/288a139a/attachment.zip</A> 
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020786.html">[Mono-dev] Parch for Enum support in Custom attributes
</A></li>
	<LI>Next message: <A HREF="020834.html">[Mono-dev] Parch for Enum support in Custom attributes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20833">[ date ]</a>
              <a href="thread.html#20833">[ thread ]</a>
              <a href="subject.html#20833">[ subject ]</a>
              <a href="author.html#20833">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
