<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Parch for Enum support in Custom attributes
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Parch%20for%20Enum%20support%20in%20Custom%20attributes&In-Reply-To=Pine.GSO.4.60.0610091416320.18006%40yen">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020833.html">
   <LINK REL="Next"  HREF="020843.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Parch for Enum support in Custom attributes</H1>
    <B>Jb Evain</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Parch%20for%20Enum%20support%20in%20Custom%20attributes&In-Reply-To=Pine.GSO.4.60.0610091416320.18006%40yen"
       TITLE="[Mono-dev] Parch for Enum support in Custom attributes">mono at evain.net
       </A><BR>
    <I>Mon Oct  9 09:03:26 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="020833.html">[Mono-dev] Parch for Enum support in Custom attributes
</A></li>
        <LI>Next message: <A HREF="020843.html">[Mono-dev] Parch for Enum support in Custom attributes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20834">[ date ]</a>
              <a href="thread.html#20834">[ thread ]</a>
              <a href="subject.html#20834">[ subject ]</a>
              <a href="author.html#20834">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Eyal,

The patch looks mostly good. Please use the new interface 
IRequireResolving I've just commited for the changes in CustomAttribute.

Please also follow the coding guideline used in Cecil.

I would also prefer a patch using a parameter instead of the 
ForceResolving property.

Also please send me the patch once it's done instead of commiting, I 
have to check that everything works fine on the writing part.

Thanks a lot,

Jb

Eyal Alaluf wrote:
&gt;<i> Hi, JB.
</I>&gt;<i> 
</I>&gt;<i> I worked a bit further on the patch and implemented the ForceRead logic
</I>&gt;<i> for custom attributes.
</I>&gt;<i> I aded a ForceResolving property to SignatureReader (it was the easiest way
</I>&gt;<i> with the previous patch I made). If the patch if acceptable I'll prepare a
</I>&gt;<i> separate and smaller patch to simplify SignatureReader abit and remove this
</I>&gt;<i> property (pass it as a parameter).
</I>&gt;<i> Attached is the patch and slightly modified test case.
</I>&gt;<i> 
</I>&gt;<i> Eyal.
</I>&gt;<i> 
</I>&gt;<i> On Thu, 5 Oct 2006, Jb Evain wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i> Date: Thu, 05 Oct 2006 19:16:47 +0200
</I>&gt;&gt;<i> From: Jb Evain &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono at evain.net</A>&gt;
</I>&gt;&gt;<i> To: Eyal Alaluf &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">eyala at mainsoft.com</A>&gt;
</I>&gt;&gt;<i> Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> Subject: Re: [Mono-dev] Parch for Enum support in Custom attributes
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hi Eyal,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thanks for working on this. I don't want to commit it as it is, but 
</I>&gt;&gt;<i> I'll surely use part of it. I don't want to load the assembly 
</I>&gt;&gt;<i> referenced only for reading a custom attribute body. Instead, I'll 
</I>&gt;&gt;<i> create an interface that CustomAttribute and SecurityDeclaration will 
</I>&gt;&gt;<i> share, and will allow one to load the content of something that needs 
</I>&gt;&gt;<i> to load a reference.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Something like:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> CustomAttribute ca = ...;
</I>&gt;&gt;<i> if (!ca.Read) {
</I>&gt;&gt;<i>     ca.ForceRead ();
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Otherwise, for a lot of assemblies, Cecil will have to load the 
</I>&gt;&gt;<i> corelib while the user don't necessary need to read the content of the 
</I>&gt;&gt;<i> custom attribute.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Jb
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Eyal Alaluf wrote:
</I>&gt;&gt;&gt;<i> Hi, JB.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Attached is patch for supporting enums in cutom attributes. Support 
</I>&gt;&gt;&gt;<i> is added
</I>&gt;&gt;&gt;<i> for enums as ctor parameters as fields and as properties.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> The main problem with Enums is to identify their underlying integral 
</I>&gt;&gt;&gt;<i> type.
</I>&gt;&gt;&gt;<i> Without this integral type the custom attribute cannot be read. The 
</I>&gt;&gt;&gt;<i> patch
</I>&gt;&gt;&gt;<i> uses the assembly resolver for this purpose.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I have attached a simple test scenraio with 3 C# files.
</I>&gt;&gt;&gt;<i>     * Test1.cs is a DLL defining enums and an attribute that has 
</I>&gt;&gt;&gt;<i> enums as
</I>&gt;&gt;&gt;<i>       field properties and ctor params.
</I>&gt;&gt;&gt;<i>     * Test2.cs is another DLL that uses the attribute and enums from 
</I>&gt;&gt;&gt;<i> Test1.
</I>&gt;&gt;&gt;<i>       This exercise the new code that resolves enum types from 
</I>&gt;&gt;&gt;<i> another DLL.
</I>&gt;&gt;&gt;<i>     * ReadTest2.cs is an EXE written using Cecil that parses 
</I>&gt;&gt;&gt;<i> test2.dll and
</I>&gt;&gt;&gt;<i>       prints the custom attributes of its types. It gets as argument 
</I>&gt;&gt;&gt;<i> the path
</I>&gt;&gt;&gt;<i>       to the dll it parses.
</I>&gt;&gt;&gt;<i> Note that Test1 uses ClassUsageAttaribute from mscorlib. For some 
</I>&gt;&gt;&gt;<i> reason the
</I>&gt;&gt;&gt;<i> assembly resolver didn't find mscorlib.dll from the GAC when I ran 
</I>&gt;&gt;&gt;<i> ReadTest2
</I>&gt;&gt;&gt;<i> on Test2 until I put mscorlib.dll in the same dir as Test2 &amp; ReadTest2.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Eyal.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> ------------------------------------------------------------------------
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Index: Mono.Cecil/ReflectionReader.cs
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> --- Mono.Cecil/ReflectionReader.cs    (revision 66216)
</I>&gt;&gt;&gt;<i> +++ Mono.Cecil/ReflectionReader.cs    (working copy)
</I>&gt;&gt;&gt;<i> @@ -65,7 +65,24 @@
</I>&gt;&gt;&gt;<i>          protected CodeReader m_codeReader;
</I>&gt;&gt;&gt;<i>          protected ISymbolReader m_symbolReader;
</I>&gt;&gt;&gt;<i>  -        public ModuleDefinition Module {
</I>&gt;&gt;&gt;<i> +        internal AssemblyNameReference Corlib
</I>&gt;&gt;&gt;<i> +        {
</I>&gt;&gt;&gt;<i> +            get +            {
</I>&gt;&gt;&gt;<i> +                if (m_corlib == null) {
</I>&gt;&gt;&gt;<i> +                    foreach (AssemblyNameReference ar in 
</I>&gt;&gt;&gt;<i> m_module.AssemblyReferences) {
</I>&gt;&gt;&gt;<i> +                        if (ar.Name == Constants.Corlib) {
</I>&gt;&gt;&gt;<i> +                            m_corlib = ar;
</I>&gt;&gt;&gt;<i> +                            break;
</I>&gt;&gt;&gt;<i> +                        }
</I>&gt;&gt;&gt;<i> +                    }
</I>&gt;&gt;&gt;<i> +                }
</I>&gt;&gt;&gt;<i> +                return m_corlib;
</I>&gt;&gt;&gt;<i> +            }            +        }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +        public ModuleDefinition Module +        {
</I>&gt;&gt;&gt;<i>              get { return m_module; }
</I>&gt;&gt;&gt;<i>          }
</I>&gt;&gt;&gt;<i>  @@ -295,19 +312,11 @@
</I>&gt;&gt;&gt;<i>               TypeReference coreType =  m_module.TypeReferences 
</I>&gt;&gt;&gt;<i> [fullName];
</I>&gt;&gt;&gt;<i>              if (coreType == null) {
</I>&gt;&gt;&gt;<i> -                if (m_corlib == null) {
</I>&gt;&gt;&gt;<i> -                    foreach (AssemblyNameReference ar in 
</I>&gt;&gt;&gt;<i> m_module.AssemblyReferences) {
</I>&gt;&gt;&gt;<i> -                        if (ar.Name == Constants.Corlib) {
</I>&gt;&gt;&gt;<i> -                            m_corlib = ar;
</I>&gt;&gt;&gt;<i> -                            break;
</I>&gt;&gt;&gt;<i> -                        }
</I>&gt;&gt;&gt;<i> -                    }
</I>&gt;&gt;&gt;<i> -                }
</I>&gt;&gt;&gt;<i>                   string [] parts = fullName.Split ('.');
</I>&gt;&gt;&gt;<i>                  if (parts.Length != 2)
</I>&gt;&gt;&gt;<i>                      throw new ReflectionException (&quot;Unvalid core 
</I>&gt;&gt;&gt;<i> type name&quot;);
</I>&gt;&gt;&gt;<i> -                coreType = new TypeReference (parts [1], parts [0], 
</I>&gt;&gt;&gt;<i> m_corlib);
</I>&gt;&gt;&gt;<i> +                coreType = new TypeReference (parts [1], parts [0], 
</I>&gt;&gt;&gt;<i> Corlib);
</I>&gt;&gt;&gt;<i>                  m_module.TypeReferences.Add (coreType);
</I>&gt;&gt;&gt;<i>              }
</I>&gt;&gt;&gt;<i>              if (!coreType.IsValueType) {
</I>&gt;&gt;&gt;<i> Index: ChangeLog
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> --- ChangeLog    (revision 66226)
</I>&gt;&gt;&gt;<i> +++ ChangeLog    (working copy)
</I>&gt;&gt;&gt;<i> @@ -1,3 +1,11 @@
</I>&gt;&gt;&gt;<i> +2006-10-05  Eyal Alaluf  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">eyala at mainsoft.com</A>&gt;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +    Mono.Cecil/ReflectionReader.cs:
</I>&gt;&gt;&gt;<i> +        Expose Corlib assembly refereice so SignatureReader can ise it.
</I>&gt;&gt;&gt;<i> +    Mono.Cecil.Signatures/SignatureReader.cs:
</I>&gt;&gt;&gt;<i> +        Added support for enums in custom attributes ctors, 
</I>&gt;&gt;&gt;<i> properties and
</I>&gt;&gt;&gt;<i> +        fields.
</I>&gt;&gt;&gt;<i> +         2006-10-04  Eyal Alaluf  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">eyala at mainsoft.com</A>&gt;
</I>&gt;&gt;&gt;<i>       * Mono.Cecil/StructureReader.cs:
</I>&gt;&gt;&gt;<i> @@ -2,3 +10,2 @@
</I>&gt;&gt;&gt;<i>          Visit the module we load when a DLL has more then 1 module.
</I>&gt;&gt;&gt;<i> -            Visit the module we load when a DLL has more then 1 module.
</I>&gt;&gt;&gt;<i>        Mono.Cecil/AssemblyNameReference.cs:
</I>&gt;&gt;&gt;<i> Index: Mono.Cecil.Signatures/SignatureReader.cs
</I>&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;<i> --- Mono.Cecil.Signatures/SignatureReader.cs    (revision 66216)
</I>&gt;&gt;&gt;<i> +++ Mono.Cecil.Signatures/SignatureReader.cs    (working copy)
</I>&gt;&gt;&gt;<i> @@ -587,7 +587,7 @@
</I>&gt;&gt;&gt;<i>          }
</I>&gt;&gt;&gt;<i>           CustomAttrib.FixedArg ReadFixedArg (byte [] data, 
</I>&gt;&gt;&gt;<i> BinaryReader br,
</I>&gt;&gt;&gt;<i> -            bool array, object param, ref bool read)
</I>&gt;&gt;&gt;<i> +            bool array, TypeReference param, ref bool read)
</I>&gt;&gt;&gt;<i>          {
</I>&gt;&gt;&gt;<i>              CustomAttrib.FixedArg fa = new CustomAttrib.FixedArg ();
</I>&gt;&gt;&gt;<i>              if (array) {
</I>&gt;&gt;&gt;<i> @@ -596,6 +596,7 @@
</I>&gt;&gt;&gt;<i>                   if (fa.NumElem == 0 || fa.NumElem == 0xffffffff) {
</I>&gt;&gt;&gt;<i>                      fa.Elems = new CustomAttrib.Elem [0];
</I>&gt;&gt;&gt;<i> +                    fa.NumElem = 0;
</I>&gt;&gt;&gt;<i>                      return fa;
</I>&gt;&gt;&gt;<i>                  }
</I>&gt;&gt;&gt;<i>  @@ -611,6 +612,95 @@
</I>&gt;&gt;&gt;<i>              return fa;
</I>&gt;&gt;&gt;<i>          }
</I>&gt;&gt;&gt;<i>  +        TypeReference CreateEnumTypeReference (string enumName)
</I>&gt;&gt;&gt;<i> +        {
</I>&gt;&gt;&gt;<i> +            string asmName = null;
</I>&gt;&gt;&gt;<i> +            int asmStart = enumName.IndexOf (',');
</I>&gt;&gt;&gt;<i> +            if (asmStart != -1) {
</I>&gt;&gt;&gt;<i> +                asmName = enumName.Substring (asmStart + 1);
</I>&gt;&gt;&gt;<i> +                enumName = enumName.Substring (0, asmStart);
</I>&gt;&gt;&gt;<i> +            }
</I>&gt;&gt;&gt;<i> +            // Inner class style is reflection style.
</I>&gt;&gt;&gt;<i> +            enumName = enumName.Replace ('+', '/');
</I>&gt;&gt;&gt;<i> +            AssemblyNameReference asm = null;
</I>&gt;&gt;&gt;<i> +            if (asmName == null) {
</I>&gt;&gt;&gt;<i> +                // If no assembly is given then the ECMA standard 
</I>&gt;&gt;&gt;<i> says the
</I>&gt;&gt;&gt;<i> +                // assembly is either the current one or mscorlib.
</I>&gt;&gt;&gt;<i> +                if (m_reflectReader.Module.Types[enumName] != null)
</I>&gt;&gt;&gt;<i> +                    return m_reflectReader.Module.Types[enumName];
</I>&gt;&gt;&gt;<i> +                asm = m_reflectReader.Corlib;
</I>&gt;&gt;&gt;<i> +            }
</I>&gt;&gt;&gt;<i> +            else
</I>&gt;&gt;&gt;<i> +                asm = AssemblyNameReference.Parse (asmName);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +            string[] outers = enumName.Split ('/');
</I>&gt;&gt;&gt;<i> +            string outerfullname = outers[0];
</I>&gt;&gt;&gt;<i> +            string ns = null;
</I>&gt;&gt;&gt;<i> +            int nsIndex = outerfullname.LastIndexOf ('.');
</I>&gt;&gt;&gt;<i> +            if (nsIndex != -1)
</I>&gt;&gt;&gt;<i> +                ns = outerfullname.Substring(0, nsIndex);
</I>&gt;&gt;&gt;<i> +            string name = outerfullname.Substring (nsIndex + 1);
</I>&gt;&gt;&gt;<i> +            TypeReference decType = new TypeReference (name, ns, asm);
</I>&gt;&gt;&gt;<i> +            for (int i = 1; i &lt; outers.Length; i++)
</I>&gt;&gt;&gt;<i> +            {
</I>&gt;&gt;&gt;<i> +                TypeReference t = new TypeReference (outers[i], 
</I>&gt;&gt;&gt;<i> null, asm);
</I>&gt;&gt;&gt;<i> +                t.DeclaringType = decType;
</I>&gt;&gt;&gt;<i> +                decType = t;
</I>&gt;&gt;&gt;<i> +            }
</I>&gt;&gt;&gt;<i> +            decType.IsValueType = true;
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +            return decType;
</I>&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +        TypeReference ReadTypeReference (byte[] data, BinaryReader 
</I>&gt;&gt;&gt;<i> br, out ElementType elemType, out bool array)
</I>&gt;&gt;&gt;<i> +        {
</I>&gt;&gt;&gt;<i> +            array = false;
</I>&gt;&gt;&gt;<i> +            elemType = (ElementType) br.ReadByte ();
</I>&gt;&gt;&gt;<i> +            if (elemType == ElementType.SzArray) + {
</I>&gt;&gt;&gt;<i> +                elemType = (ElementType) br.ReadByte ();
</I>&gt;&gt;&gt;<i> +                array = true;
</I>&gt;&gt;&gt;<i> +            }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +            switch (elemType) {
</I>&gt;&gt;&gt;<i> +            case ElementType.Enum :
</I>&gt;&gt;&gt;<i> +                return CreateEnumTypeReference (ReadUTF8String 
</I>&gt;&gt;&gt;<i> (data, br));
</I>&gt;&gt;&gt;<i> +            case ElementType.Boxed :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Object);
</I>&gt;&gt;&gt;<i> +            case ElementType.String :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.String);
</I>&gt;&gt;&gt;<i> +            case ElementType.Type :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType (Constants.Type);
</I>&gt;&gt;&gt;<i> +            case ElementType.Boolean :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Boolean);
</I>&gt;&gt;&gt;<i> +            case ElementType.Char :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType (Constants.Char);
</I>&gt;&gt;&gt;<i> +            case ElementType.R4 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Single);
</I>&gt;&gt;&gt;<i> +            case ElementType.R8 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Double);
</I>&gt;&gt;&gt;<i> +            case ElementType.I1 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.SByte);
</I>&gt;&gt;&gt;<i> +            case ElementType.I2 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Int16);
</I>&gt;&gt;&gt;<i> +            case ElementType.I4 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Int32);
</I>&gt;&gt;&gt;<i> +            case ElementType.I8 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Int64);
</I>&gt;&gt;&gt;<i> +            case ElementType.U1 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType (Constants.Byte);
</I>&gt;&gt;&gt;<i> +            case ElementType.U2 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.UInt16);
</I>&gt;&gt;&gt;<i> +            case ElementType.U4 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.UInt32);
</I>&gt;&gt;&gt;<i> +            case ElementType.U8 :
</I>&gt;&gt;&gt;<i> +                return m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.UInt64);
</I>&gt;&gt;&gt;<i> +            default :
</I>&gt;&gt;&gt;<i> +                throw new MetadataFormatException (&quot;Non valid type 
</I>&gt;&gt;&gt;<i> in CustomAttrib.Elem: 0x{0}&quot;,
</I>&gt;&gt;&gt;<i> +                    ((byte) elemType).ToString(&quot;x2&quot;));
</I>&gt;&gt;&gt;<i> +            }
</I>&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i>          internal CustomAttrib.NamedArg ReadNamedArg (byte [] data, 
</I>&gt;&gt;&gt;<i> BinaryReader br, ref bool read)
</I>&gt;&gt;&gt;<i>          {
</I>&gt;&gt;&gt;<i>              CustomAttrib.NamedArg na = new CustomAttrib.NamedArg ();
</I>&gt;&gt;&gt;<i> @@ -625,42 +715,15 @@
</I>&gt;&gt;&gt;<i>                  throw new MetadataFormatException (&quot;Wrong kind of 
</I>&gt;&gt;&gt;<i> namedarg found: 0x&quot; + kind.ToString(&quot;x2&quot;));
</I>&gt;&gt;&gt;<i>               bool array = false;
</I>&gt;&gt;&gt;<i> -            na.FieldOrPropType = (ElementType) br.ReadByte ();
</I>&gt;&gt;&gt;<i> -            if (na.FieldOrPropType == ElementType.SzArray) {
</I>&gt;&gt;&gt;<i> -                na.FieldOrPropType = (ElementType) br.ReadByte ();
</I>&gt;&gt;&gt;<i> -                array = true;
</I>&gt;&gt;&gt;<i> -            }
</I>&gt;&gt;&gt;<i>  -            int next, length;
</I>&gt;&gt;&gt;<i> +            TypeReference elemType = ReadTypeReference (data, br, 
</I>&gt;&gt;&gt;<i> out na.FieldOrPropType, out array);
</I>&gt;&gt;&gt;<i>  -            if (na.FieldOrPropType == ElementType.Enum) {
</I>&gt;&gt;&gt;<i> -                read = false;
</I>&gt;&gt;&gt;<i> -                return na;
</I>&gt;&gt;&gt;<i> -            }
</I>&gt;&gt;&gt;<i> +            na.FieldOrPropName = ReadUTF8String (data, br);
</I>&gt;&gt;&gt;<i> +            na.FixedArg = ReadFixedArg (data, br, array, elemType, 
</I>&gt;&gt;&gt;<i> ref read);
</I>&gt;&gt;&gt;<i>  -            length = Utilities.ReadCompressedInteger (data, (int) 
</I>&gt;&gt;&gt;<i> br.BaseStream.Position, out next);
</I>&gt;&gt;&gt;<i> -            br.BaseStream.Position = next;
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i> -            // COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is 
</I>&gt;&gt;&gt;<i> not supported.
</I>&gt;&gt;&gt;<i> -            byte [] bytes = br.ReadBytes (length);
</I>&gt;&gt;&gt;<i> -            na.FieldOrPropName = Encoding.UTF8.GetString (bytes, 0, 
</I>&gt;&gt;&gt;<i> bytes.Length);
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i> -            na.FixedArg = ReadFixedArg (data, br, array, 
</I>&gt;&gt;&gt;<i> na.FieldOrPropType, ref read);
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i>              return na;
</I>&gt;&gt;&gt;<i>          }
</I>&gt;&gt;&gt;<i>  -        // i hate this construction, should find something better
</I>&gt;&gt;&gt;<i> -        CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, 
</I>&gt;&gt;&gt;<i> object param, ref bool read)
</I>&gt;&gt;&gt;<i> -        {
</I>&gt;&gt;&gt;<i> -            if (param is TypeReference)
</I>&gt;&gt;&gt;<i> -                return ReadElem (data, br, param as TypeReference, 
</I>&gt;&gt;&gt;<i> ref read);
</I>&gt;&gt;&gt;<i> -            else if (param is ElementType)
</I>&gt;&gt;&gt;<i> -                return ReadElem (data, br, (ElementType) param, ref 
</I>&gt;&gt;&gt;<i> read);
</I>&gt;&gt;&gt;<i> -            else
</I>&gt;&gt;&gt;<i> -                throw new MetadataFormatException (&quot;Wrong parameter 
</I>&gt;&gt;&gt;<i> for ReadElem: &quot; + param.GetType ().FullName);
</I>&gt;&gt;&gt;<i> -        }
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i>          CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, 
</I>&gt;&gt;&gt;<i> TypeReference elemType, ref bool read)
</I>&gt;&gt;&gt;<i>          {
</I>&gt;&gt;&gt;<i>              CustomAttrib.Elem elem = new CustomAttrib.Elem ();
</I>&gt;&gt;&gt;<i> @@ -668,11 +731,20 @@
</I>&gt;&gt;&gt;<i>              string elemName = elemType.FullName;
</I>&gt;&gt;&gt;<i>               if (elemName == Constants.Object) {
</I>&gt;&gt;&gt;<i> -                ElementType elementType = (ElementType) br.ReadByte ();
</I>&gt;&gt;&gt;<i> -                elem = ReadElem (data, br, elementType, ref read);
</I>&gt;&gt;&gt;<i> +                bool array;
</I>&gt;&gt;&gt;<i> +                elemType = ReadTypeReference (data, br, out 
</I>&gt;&gt;&gt;<i> elem.FieldOrPropType, out array);
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +                if (array) {
</I>&gt;&gt;&gt;<i> +                    read = false; // Don't know how to represent 
</I>&gt;&gt;&gt;<i> arrays as an object value.
</I>&gt;&gt;&gt;<i> +                    return elem;
</I>&gt;&gt;&gt;<i> +                }
</I>&gt;&gt;&gt;<i> +                else if (elemType.FullName == Constants.Object)
</I>&gt;&gt;&gt;<i> +                    throw new MetadataFormatException (&quot;Non valid 
</I>&gt;&gt;&gt;<i> type in CustomAttrib.Elem after boxed prefix: 0x{0}&quot;,
</I>&gt;&gt;&gt;<i> +                        ((byte) elem.FieldOrPropType).ToString(&quot;x2&quot;));
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +                elem = ReadElem (data, br, elemType, ref read);
</I>&gt;&gt;&gt;<i>                  elem.String = elem.Simple = elem.Type = false;
</I>&gt;&gt;&gt;<i>                  elem.BoxedValueType = true;
</I>&gt;&gt;&gt;<i> -                elem.FieldOrPropType = elementType;
</I>&gt;&gt;&gt;<i>                  return elem;
</I>&gt;&gt;&gt;<i>              }
</I>&gt;&gt;&gt;<i>  @@ -694,19 +766,45 @@
</I>&gt;&gt;&gt;<i>                      elem.Value = null;
</I>&gt;&gt;&gt;<i>                      br.BaseStream.Position++;
</I>&gt;&gt;&gt;<i>                  } else {
</I>&gt;&gt;&gt;<i> -                    int next, length = 
</I>&gt;&gt;&gt;<i> Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, 
</I>&gt;&gt;&gt;<i> out next);
</I>&gt;&gt;&gt;<i> -                    br.BaseStream.Position = next;
</I>&gt;&gt;&gt;<i> -                    // COMPACT FRAMEWORK NOTE: 
</I>&gt;&gt;&gt;<i> Encoding.GetString(byte[]) is not supported.
</I>&gt;&gt;&gt;<i> -                    byte [] bytes = br.ReadBytes (length);
</I>&gt;&gt;&gt;<i> -                    elem.Value = Encoding.UTF8.GetString (bytes, 0, 
</I>&gt;&gt;&gt;<i> bytes.Length);
</I>&gt;&gt;&gt;<i> +                    elem.Value = ReadUTF8String (data, br);
</I>&gt;&gt;&gt;<i>                  }
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i>                  return elem;
</I>&gt;&gt;&gt;<i>              }
</I>&gt;&gt;&gt;<i>               elem.String = elem.Type = elem.BoxedValueType = false;
</I>&gt;&gt;&gt;<i> +            if (!readSimpleValue (br, ref elem, elem.ElemType)) {
</I>&gt;&gt;&gt;<i> +                TypeReference typeRef = GetEnumUnderlyingType 
</I>&gt;&gt;&gt;<i> (elem.ElemType);
</I>&gt;&gt;&gt;<i> +                if (typeRef == null || !readSimpleValue (br, ref 
</I>&gt;&gt;&gt;<i> elem, typeRef))
</I>&gt;&gt;&gt;<i> +                    read = false;
</I>&gt;&gt;&gt;<i> +            }
</I>&gt;&gt;&gt;<i>  -            switch (elemName) {
</I>&gt;&gt;&gt;<i> +            return elem;
</I>&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +        private IAssemblyResolver AssemblyResolver
</I>&gt;&gt;&gt;<i> +        {
</I>&gt;&gt;&gt;<i> +            get +            { + return 
</I>&gt;&gt;&gt;<i> m_reflectReader.Module.Assembly.Resolver;
</I>&gt;&gt;&gt;<i> +            }
</I>&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +        private TypeReference GetEnumUnderlyingType (TypeReference 
</I>&gt;&gt;&gt;<i> enumType)
</I>&gt;&gt;&gt;<i> +        {
</I>&gt;&gt;&gt;<i> +            TypeDefinition type = enumType as TypeDefinition;
</I>&gt;&gt;&gt;<i> +            if (type == null &amp;&amp; AssemblyResolver != null) + {
</I>&gt;&gt;&gt;<i> +                AssemblyDefinition asm = AssemblyResolver.Resolve 
</I>&gt;&gt;&gt;<i> (enumType.Scope.Name);
</I>&gt;&gt;&gt;<i> +                type = asm.MainModule.Types[enumType.FullName];
</I>&gt;&gt;&gt;<i> +            }
</I>&gt;&gt;&gt;<i> +            if (type != null &amp;&amp; type.IsEnum)
</I>&gt;&gt;&gt;<i> +                return type.Fields.GetField (&quot;value__&quot;).FieldType;
</I>&gt;&gt;&gt;<i> +            return null;
</I>&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i> +        bool readSimpleValue (BinaryReader br, ref CustomAttrib.Elem 
</I>&gt;&gt;&gt;<i> elem, TypeReference type)
</I>&gt;&gt;&gt;<i> +        {
</I>&gt;&gt;&gt;<i> +            switch (type.FullName) {
</I>&gt;&gt;&gt;<i>              case Constants.Boolean :
</I>&gt;&gt;&gt;<i>                  elem.Value = br.ReadByte () == 1;
</I>&gt;&gt;&gt;<i>                  break;
</I>&gt;&gt;&gt;<i> @@ -744,120 +842,12 @@
</I>&gt;&gt;&gt;<i>                  elem.Value = br.ReadUInt64 ();
</I>&gt;&gt;&gt;<i>                  break;
</I>&gt;&gt;&gt;<i>              default : // enum
</I>&gt;&gt;&gt;<i> -                read = false;
</I>&gt;&gt;&gt;<i> -                return elem;
</I>&gt;&gt;&gt;<i> +                return false;
</I>&gt;&gt;&gt;<i>              }
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i>              elem.Simple = true;
</I>&gt;&gt;&gt;<i> -            return elem;
</I>&gt;&gt;&gt;<i> +            return true;
</I>&gt;&gt;&gt;<i>          }
</I>&gt;&gt;&gt;<i>  -        // elem in named args, only have an ElementType
</I>&gt;&gt;&gt;<i> -        CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, 
</I>&gt;&gt;&gt;<i> ElementType elemType, ref bool read)
</I>&gt;&gt;&gt;<i> -        {
</I>&gt;&gt;&gt;<i> -            CustomAttrib.Elem elem = new CustomAttrib.Elem ();
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i> -            if (elemType == ElementType.Boxed) {
</I>&gt;&gt;&gt;<i> -                ElementType elementType = (ElementType) br.ReadByte ();
</I>&gt;&gt;&gt;<i> -                elem = ReadElem (data, br, elementType, ref read);
</I>&gt;&gt;&gt;<i> -                elem.String = elem.Simple = elem.Type = false;
</I>&gt;&gt;&gt;<i> -                elem.BoxedValueType = true;
</I>&gt;&gt;&gt;<i> -                elem.FieldOrPropType = elementType;
</I>&gt;&gt;&gt;<i> -                return elem;
</I>&gt;&gt;&gt;<i> -            }
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i> -            if (elemType == ElementType.Type || elemType == 
</I>&gt;&gt;&gt;<i> ElementType.String) { // type or string
</I>&gt;&gt;&gt;<i> -                switch (elemType) {
</I>&gt;&gt;&gt;<i> -                case ElementType.String :
</I>&gt;&gt;&gt;<i> -                    elem.String = true;
</I>&gt;&gt;&gt;<i> -                    elem.BoxedValueType = elem.Simple = elem.Type = 
</I>&gt;&gt;&gt;<i> false;
</I>&gt;&gt;&gt;<i> -                    elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.String);
</I>&gt;&gt;&gt;<i> -                    break;
</I>&gt;&gt;&gt;<i> -                case ElementType.Type :
</I>&gt;&gt;&gt;<i> -                    elem.Type = true;
</I>&gt;&gt;&gt;<i> -                    elem.BoxedValueType = elem.Simple = elem.String 
</I>&gt;&gt;&gt;<i> = false;
</I>&gt;&gt;&gt;<i> -                    elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Type);
</I>&gt;&gt;&gt;<i> -                    break;
</I>&gt;&gt;&gt;<i> -                }
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i> -                if (data [br.BaseStream.Position] == 0xff) { // null
</I>&gt;&gt;&gt;<i> -                    elem.Value = null;
</I>&gt;&gt;&gt;<i> -                    br.BaseStream.Position++;
</I>&gt;&gt;&gt;<i> -                } else {
</I>&gt;&gt;&gt;<i> -                    int next, length = 
</I>&gt;&gt;&gt;<i> Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, 
</I>&gt;&gt;&gt;<i> out next);
</I>&gt;&gt;&gt;<i> -                    br.BaseStream.Position = next;
</I>&gt;&gt;&gt;<i> -                    // COMPACT FRAMEWORK NOTE: 
</I>&gt;&gt;&gt;<i> Encoding.GetString(byte[]) is not supported.
</I>&gt;&gt;&gt;<i> -                    byte [] bytes = br.ReadBytes (length);
</I>&gt;&gt;&gt;<i> -                    elem.Value = Encoding.UTF8.GetString (bytes, 0, 
</I>&gt;&gt;&gt;<i> bytes.Length);
</I>&gt;&gt;&gt;<i> -                }
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i> -                return elem;
</I>&gt;&gt;&gt;<i> -            }
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i> -            elem.String = elem.Type = elem.BoxedValueType = false;
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i> -            switch (elemType) {
</I>&gt;&gt;&gt;<i> -            case ElementType.Boolean :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Boolean);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadByte () == 1;
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.Char :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Char);
</I>&gt;&gt;&gt;<i> -                elem.Value = (char) br.ReadUInt16 ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.R4 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Single);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadSingle ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.R8 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Double);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadDouble ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.I1 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.SByte);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadSByte ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.I2 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Int16);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadInt16 ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.I4 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Int32);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadInt32 ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.I8 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Int64);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadInt64 ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.U1 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.Byte);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadByte ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.U2 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.UInt16);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadUInt16 ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.U4 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.UInt32);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadUInt32 ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.U8 :
</I>&gt;&gt;&gt;<i> -                elem.ElemType = m_reflectReader.SearchCoreType 
</I>&gt;&gt;&gt;<i> (Constants.UInt64);
</I>&gt;&gt;&gt;<i> -                elem.Value = br.ReadUInt64 ();
</I>&gt;&gt;&gt;<i> -                break;
</I>&gt;&gt;&gt;<i> -            case ElementType.Enum :
</I>&gt;&gt;&gt;<i> -                read = false;
</I>&gt;&gt;&gt;<i> -                return elem;
</I>&gt;&gt;&gt;<i> -            default :
</I>&gt;&gt;&gt;<i> -                throw new MetadataFormatException (&quot;Non valid type 
</I>&gt;&gt;&gt;<i> in CustomAttrib.Elem: 0x{0}&quot;,
</I>&gt;&gt;&gt;<i> -                    ((byte) elemType).ToString(&quot;x2&quot;));
</I>&gt;&gt;&gt;<i> -            }
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i> -            read = true;
</I>&gt;&gt;&gt;<i> -            elem.Simple = true;
</I>&gt;&gt;&gt;<i> -            return elem;
</I>&gt;&gt;&gt;<i> -        }
</I>&gt;&gt;&gt;<i> -
</I>&gt;&gt;&gt;<i>          MarshalSig ReadMarshalSig (byte [] data)
</I>&gt;&gt;&gt;<i>          {
</I>&gt;&gt;&gt;<i>              int start;
</I>&gt;&gt;&gt;<i> @@ -905,14 +895,21 @@
</I>&gt;&gt;&gt;<i>              return ms;
</I>&gt;&gt;&gt;<i>          }
</I>&gt;&gt;&gt;<i>  +        static internal string ReadUTF8String (byte [] data, 
</I>&gt;&gt;&gt;<i> BinaryReader br)
</I>&gt;&gt;&gt;<i> +        {
</I>&gt;&gt;&gt;<i> +            int start = (int)br.BaseStream.Position;
</I>&gt;&gt;&gt;<i> +            string val = ReadUTF8String (data, start, out start);
</I>&gt;&gt;&gt;<i> +            br.BaseStream.Position = start;
</I>&gt;&gt;&gt;<i> +            return val;
</I>&gt;&gt;&gt;<i> +        }
</I>&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;<i>          static internal string ReadUTF8String (byte [] data, int 
</I>&gt;&gt;&gt;<i> pos, out int start)
</I>&gt;&gt;&gt;<i>          {
</I>&gt;&gt;&gt;<i>              int length = Utilities.ReadCompressedInteger (data, pos, 
</I>&gt;&gt;&gt;<i> out start);
</I>&gt;&gt;&gt;<i> -            byte [] str = new byte [length];
</I>&gt;&gt;&gt;<i> -            Buffer.BlockCopy (data, start, str, 0, length);
</I>&gt;&gt;&gt;<i> +            pos = start;
</I>&gt;&gt;&gt;<i>              start += length;
</I>&gt;&gt;&gt;<i> -            // COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is 
</I>&gt;&gt;&gt;<i> not supported.
</I>&gt;&gt;&gt;<i> -            return Encoding.UTF8.GetString (str, 0, str.Length);
</I>&gt;&gt;&gt;<i> +            // COMPACT FRAMEWORK NOTE: Encoding.GetString (byte[]) 
</I>&gt;&gt;&gt;<i> is not supported.
</I>&gt;&gt;&gt;<i> +            return Encoding.UTF8.GetString (data, pos, length);
</I>&gt;&gt;&gt;<i>          }
</I>&gt;&gt;&gt;<i>      }
</I>&gt;&gt;&gt;<i>  }
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> ------------------------------------------------------------------------
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> Index: Mono.Cecil/CustomAttribute.cs
</I>&gt;<i> 
</I>&gt;<i> ===================================================================
</I>&gt;<i> 
</I>&gt;<i> --- Mono.Cecil/CustomAttribute.cs	(revision 66447)
</I>&gt;<i> 
</I>&gt;<i> +++ Mono.Cecil/CustomAttribute.cs	(working copy)
</I>&gt;<i> 
</I>&gt;<i> @@ -102,6 +102,19 @@
</I>&gt;<i> 
</I>&gt;<i>  			set { m_blob = value; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public bool ForceRead ()
</I>&gt;<i> +		{
</I>&gt;<i> +			if (IsReadable)
</I>&gt;<i> +				return true;
</I>&gt;<i> +
</I>&gt;<i> +			ReflectionReader r = m_ctor.DeclaringType.Module.Controller.Reader;
</I>&gt;<i> +			CustomAttribute newCa = r.GetCustomAttribute (m_ctor, Blob, true);
</I>&gt;<i> +			if (!newCa.IsReadable)
</I>&gt;<i> +				return false;
</I>&gt;<i> +			newCa.CopyTo (this);
</I>&gt;<i> +			return true;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public CustomAttribute (MethodReference ctor)
</I>&gt;<i>  		{
</I>&gt;<i>  			m_ctor = ctor;
</I>&gt;<i> @@ -135,6 +148,7 @@
</I>&gt;<i> 
</I>&gt;<i>  
</I>&gt;<i>  		static void Clone (IDictionary original, IDictionary target)
</I>&gt;<i>  		{
</I>&gt;<i> +			target.Clear ();
</I>&gt;<i>  			foreach (DictionaryEntry entry in original)
</I>&gt;<i>  				target.Add (entry.Key, entry.Value);
</I>&gt;<i>  		}
</I>&gt;<i> @@ -142,19 +156,24 @@
</I>&gt;<i> 
</I>&gt;<i>  		internal static CustomAttribute Clone (CustomAttribute custattr, ImportContext context)
</I>&gt;<i>  		{
</I>&gt;<i>  			CustomAttribute ca = new CustomAttribute (context.Import (custattr.Constructor));
</I>&gt;<i> -			if (!custattr.IsReadable) {
</I>&gt;<i> -				ca.IsReadable = false;
</I>&gt;<i> -				ca.Blob = custattr.Blob;
</I>&gt;<i> -				return ca;
</I>&gt;<i> +			custattr.CopyTo(ca);
</I>&gt;<i> +			return ca;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		private void CopyTo (CustomAttribute target)
</I>&gt;<i> +		{
</I>&gt;<i> +			target.IsReadable = IsReadable;
</I>&gt;<i> +			if (!IsReadable) {
</I>&gt;<i> +				target.Blob = Blob;
</I>&gt;<i> +				return;
</I>&gt;<i>  			}
</I>&gt;<i>  
</I>&gt;<i> -			foreach (object o in custattr.ConstructorParameters)
</I>&gt;<i> -				ca.ConstructorParameters.Add (o);
</I>&gt;<i> -			Clone (custattr.Fields, ca.Fields);
</I>&gt;<i> -			Clone (custattr.FieldTypes, ca.FieldTypes);
</I>&gt;<i> -			Clone (custattr.Properties, ca.Properties);
</I>&gt;<i> -			Clone (custattr.PropertyTypes, ca.PropertyTypes);
</I>&gt;<i> -			return ca;
</I>&gt;<i> +			foreach (object o in ConstructorParameters)
</I>&gt;<i> +				target.ConstructorParameters.Add (o);
</I>&gt;<i> +			Clone (Fields, target.Fields);
</I>&gt;<i> +			Clone (FieldTypes, target.FieldTypes);
</I>&gt;<i> +			Clone (Properties, target.Properties);
</I>&gt;<i> +			Clone (PropertyTypes, target.PropertyTypes);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public void Accept (IReflectionVisitor visitor)
</I>&gt;<i> Index: Mono.Cecil/ReflectionReader.cs
</I>&gt;<i> 
</I>&gt;<i> ===================================================================
</I>&gt;<i> 
</I>&gt;<i> --- Mono.Cecil/ReflectionReader.cs	(revision 66447)
</I>&gt;<i> 
</I>&gt;<i> +++ Mono.Cecil/ReflectionReader.cs	(working copy)
</I>&gt;<i> 
</I>&gt;<i> @@ -65,7 +65,24 @@
</I>&gt;<i> 
</I>&gt;<i>  		protected CodeReader m_codeReader;
</I>&gt;<i>  		protected ISymbolReader m_symbolReader;
</I>&gt;<i>  
</I>&gt;<i> -		public ModuleDefinition Module {
</I>&gt;<i> +		internal AssemblyNameReference Corlib
</I>&gt;<i> +		{
</I>&gt;<i> +			get 
</I>&gt;<i> +			{
</I>&gt;<i> +				if (m_corlib == null) {
</I>&gt;<i> +					foreach (AssemblyNameReference ar in m_module.AssemblyReferences) {
</I>&gt;<i> +						if (ar.Name == Constants.Corlib) {
</I>&gt;<i> +							m_corlib = ar;
</I>&gt;<i> +							break;
</I>&gt;<i> +						}
</I>&gt;<i> +					}
</I>&gt;<i> +				}
</I>&gt;<i> +				return m_corlib;
</I>&gt;<i> +			}			
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public ModuleDefinition Module 
</I>&gt;<i> +		{
</I>&gt;<i>  			get { return m_module; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> @@ -295,19 +312,11 @@
</I>&gt;<i> 
</I>&gt;<i>  
</I>&gt;<i>  			TypeReference coreType =  m_module.TypeReferences [fullName];
</I>&gt;<i>  			if (coreType == null) {
</I>&gt;<i> -				if (m_corlib == null) {
</I>&gt;<i> -					foreach (AssemblyNameReference ar in m_module.AssemblyReferences) {
</I>&gt;<i> -						if (ar.Name == Constants.Corlib) {
</I>&gt;<i> -							m_corlib = ar;
</I>&gt;<i> -							break;
</I>&gt;<i> -						}
</I>&gt;<i> -					}
</I>&gt;<i> -				}
</I>&gt;<i>  
</I>&gt;<i>  				string [] parts = fullName.Split ('.');
</I>&gt;<i>  				if (parts.Length != 2)
</I>&gt;<i>  					throw new ReflectionException (&quot;Unvalid core type name&quot;);
</I>&gt;<i> -				coreType = new TypeReference (parts [1], parts [0], m_corlib);
</I>&gt;<i> +				coreType = new TypeReference (parts [1], parts [0], Corlib);
</I>&gt;<i>  				m_module.TypeReferences.Add (coreType);
</I>&gt;<i>  			}
</I>&gt;<i>  			if (!coreType.IsValueType) {
</I>&gt;<i> @@ -355,12 +364,20 @@
</I>&gt;<i> 
</I>&gt;<i>  			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public CustomAttribute GetCustomAttribute (MethodReference ctor, byte [] data)
</I>&gt;<i> +		public CustomAttribute GetCustomAttribute (MethodReference ctor, byte [] data, bool forceResolving)
</I>&gt;<i>  		{
</I>&gt;<i> +			bool keepForceResolving = m_sigReader.ForceResolving;
</I>&gt;<i> +			m_sigReader.ForceResolving = forceResolving;
</I>&gt;<i>  			CustomAttrib sig = m_sigReader.GetCustomAttrib (data, ctor);
</I>&gt;<i> +			m_sigReader.ForceResolving = keepForceResolving;
</I>&gt;<i>  			return BuildCustomAttribute (ctor, sig);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public CustomAttribute GetCustomAttribute (MethodReference ctor, byte [] data)
</I>&gt;<i> +		{
</I>&gt;<i> +			return GetCustomAttribute (ctor, data, false);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public override void VisitModuleDefinition (ModuleDefinition mod)
</I>&gt;<i>  		{
</I>&gt;<i>  			VisitTypeDefinitionCollection (mod.Types);
</I>&gt;<i> Index: ChangeLog
</I>&gt;<i> 
</I>&gt;<i> ===================================================================
</I>&gt;<i> 
</I>&gt;<i> --- ChangeLog	(revision 66447)
</I>&gt;<i> 
</I>&gt;<i> +++ ChangeLog	(working copy)
</I>&gt;<i> 
</I>&gt;<i> @@ -1,3 +1,17 @@
</I>&gt;<i> 
</I>&gt;<i> +2006-10-09  Eyal Alaluf  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">eyala at mainsoft.com</A>&gt;
</I>&gt;<i> +
</I>&gt;<i> +	Mono.Cecil.Signatures/SignatureReader.cs:
</I>&gt;<i> +		Added support for enums in custom attributes ctors, properties and
</I>&gt;<i> +		fields.
</I>&gt;<i> +	Mono.Cecil/CustomAttribute.cs:
</I>&gt;<i> +		Add support for rereading custom attributes that contain references
</I>&gt;<i> +		to enum in other assemblies.
</I>&gt;<i> +	Mono.Cecil/ReflectionReader.cs:
</I>&gt;<i> +		Add support for reading custom attributes while resolving enums from
</I>&gt;<i> +		other assemblies then the current one.
</I>&gt;<i> +	Mono.Cecil/ReflectionReader.cs:
</I>&gt;<i> +		Expose Corlib assembly refereice so SignatureReader can ise it.
</I>&gt;<i> +		
</I>&gt;<i>  2006-10-09  Jb Evain  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jbevain at gmail.com</A>&gt;
</I>&gt;<i>  
</I>&gt;<i>  	* Mono.Cecil/SecurityDeclarationReader.cs:
</I>&gt;<i> @@ -8,7 +22,6 @@
</I>&gt;<i> 
</I>&gt;<i>  
</I>&gt;<i>  	* Mono.Cecil/StructureReader.cs:
</I>&gt;<i>  		Visit the module we load when a DLL has more then 1 module.
</I>&gt;<i> -			Visit the module we load when a DLL has more then 1 module.
</I>&gt;<i>  	  Mono.Cecil/AssemblyNameReference.cs:
</I>&gt;<i>  	  	Allow &quot;PublicToken=null&quot; when parsing an assembly full name.
</I>&gt;<i>  
</I>&gt;<i> Index: Mono.Cecil.Signatures/SignatureReader.cs
</I>&gt;<i> 
</I>&gt;<i> ===================================================================
</I>&gt;<i> 
</I>&gt;<i> --- Mono.Cecil.Signatures/SignatureReader.cs	(revision 66447)
</I>&gt;<i> 
</I>&gt;<i> +++ Mono.Cecil.Signatures/SignatureReader.cs	(working copy)
</I>&gt;<i> 
</I>&gt;<i> @@ -41,6 +41,7 @@
</I>&gt;<i> 
</I>&gt;<i>  		MetadataRoot m_root;
</I>&gt;<i>  		ReflectionReader m_reflectReader;
</I>&gt;<i>  		byte [] m_blobData;
</I>&gt;<i> +		bool m_forceResolving = false;
</I>&gt;<i>  
</I>&gt;<i>  		IDictionary m_signatures;
</I>&gt;<i>  
</I>&gt;<i> @@ -54,6 +55,12 @@
</I>&gt;<i> 
</I>&gt;<i>  			m_signatures = new Hashtable ();
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		public bool ForceResolving
</I>&gt;<i> +		{
</I>&gt;<i> +			get { return m_forceResolving; }
</I>&gt;<i> +			set { m_forceResolving = value; }
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public FieldSig GetFieldSig (uint index)
</I>&gt;<i>  		{
</I>&gt;<i>  			FieldSig f = m_signatures [index] as FieldSig;
</I>&gt;<i> @@ -587,7 +594,7 @@
</I>&gt;<i> 
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		CustomAttrib.FixedArg ReadFixedArg (byte [] data, BinaryReader br,
</I>&gt;<i> -			bool array, object param, ref bool read)
</I>&gt;<i> +			bool array, TypeReference param, ref bool read)
</I>&gt;<i>  		{
</I>&gt;<i>  			CustomAttrib.FixedArg fa = new CustomAttrib.FixedArg ();
</I>&gt;<i>  			if (array) {
</I>&gt;<i> @@ -596,6 +603,7 @@
</I>&gt;<i> 
</I>&gt;<i>  
</I>&gt;<i>  				if (fa.NumElem == 0 || fa.NumElem == 0xffffffff) {
</I>&gt;<i>  					fa.Elems = new CustomAttrib.Elem [0];
</I>&gt;<i> +					fa.NumElem = 0;
</I>&gt;<i>  					return fa;
</I>&gt;<i>  				}
</I>&gt;<i>  
</I>&gt;<i> @@ -611,6 +619,95 @@
</I>&gt;<i> 
</I>&gt;<i>  			return fa;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		TypeReference CreateEnumTypeReference (string enumName)
</I>&gt;<i> +		{
</I>&gt;<i> +			string asmName = null;
</I>&gt;<i> +			int asmStart = enumName.IndexOf (',');
</I>&gt;<i> +			if (asmStart != -1) {
</I>&gt;<i> +				asmName = enumName.Substring (asmStart + 1);
</I>&gt;<i> +				enumName = enumName.Substring (0, asmStart);
</I>&gt;<i> +			}
</I>&gt;<i> +			// Inner class style is reflection style.
</I>&gt;<i> +			enumName = enumName.Replace ('+', '/');
</I>&gt;<i> +			AssemblyNameReference asm = null;
</I>&gt;<i> +			if (asmName == null) {
</I>&gt;<i> +				// If no assembly is given then the ECMA standard says the
</I>&gt;<i> +				// assembly is either the current one or mscorlib.
</I>&gt;<i> +				if (m_reflectReader.Module.Types[enumName] != null)
</I>&gt;<i> +					return m_reflectReader.Module.Types[enumName];
</I>&gt;<i> +				asm = m_reflectReader.Corlib;
</I>&gt;<i> +			}
</I>&gt;<i> +			else
</I>&gt;<i> +				asm = AssemblyNameReference.Parse (asmName);
</I>&gt;<i> +
</I>&gt;<i> +			string[] outers = enumName.Split ('/');
</I>&gt;<i> +			string outerfullname = outers[0];
</I>&gt;<i> +			string ns = null;
</I>&gt;<i> +			int nsIndex = outerfullname.LastIndexOf ('.');
</I>&gt;<i> +			if (nsIndex != -1)
</I>&gt;<i> +				ns = outerfullname.Substring(0, nsIndex);
</I>&gt;<i> +			string name = outerfullname.Substring (nsIndex + 1);
</I>&gt;<i> +			TypeReference decType = new TypeReference (name, ns, asm);
</I>&gt;<i> +			for (int i = 1; i &lt; outers.Length; i++)
</I>&gt;<i> +			{
</I>&gt;<i> +				TypeReference t = new TypeReference (outers[i], null, asm);
</I>&gt;<i> +				t.DeclaringType = decType;
</I>&gt;<i> +				decType = t;
</I>&gt;<i> +			}
</I>&gt;<i> +			decType.IsValueType = true;
</I>&gt;<i> +
</I>&gt;<i> +			return decType;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		TypeReference ReadTypeReference (byte[] data, BinaryReader br, out ElementType elemType, out bool array)
</I>&gt;<i> +		{
</I>&gt;<i> +			array = false;
</I>&gt;<i> +			elemType = (ElementType) br.ReadByte ();
</I>&gt;<i> +			if (elemType == ElementType.SzArray) 
</I>&gt;<i> +			{
</I>&gt;<i> +				elemType = (ElementType) br.ReadByte ();
</I>&gt;<i> +				array = true;
</I>&gt;<i> +			}
</I>&gt;<i> +
</I>&gt;<i> +			switch (elemType) {
</I>&gt;<i> +			case ElementType.Enum :
</I>&gt;<i> +				return CreateEnumTypeReference (ReadUTF8String (data, br));
</I>&gt;<i> +			case ElementType.Boxed :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Object);
</I>&gt;<i> +			case ElementType.String :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.String);
</I>&gt;<i> +			case ElementType.Type :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Type);
</I>&gt;<i> +			case ElementType.Boolean :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Boolean);
</I>&gt;<i> +			case ElementType.Char :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Char);
</I>&gt;<i> +			case ElementType.R4 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Single);
</I>&gt;<i> +			case ElementType.R8 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Double);
</I>&gt;<i> +			case ElementType.I1 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.SByte);
</I>&gt;<i> +			case ElementType.I2 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Int16);
</I>&gt;<i> +			case ElementType.I4 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Int32);
</I>&gt;<i> +			case ElementType.I8 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Int64);
</I>&gt;<i> +			case ElementType.U1 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.Byte);
</I>&gt;<i> +			case ElementType.U2 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.UInt16);
</I>&gt;<i> +			case ElementType.U4 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.UInt32);
</I>&gt;<i> +			case ElementType.U8 :
</I>&gt;<i> +				return m_reflectReader.SearchCoreType (Constants.UInt64);
</I>&gt;<i> +			default :
</I>&gt;<i> +				throw new MetadataFormatException (&quot;Non valid type in CustomAttrib.Elem: 0x{0}&quot;,
</I>&gt;<i> +					((byte) elemType).ToString(&quot;x2&quot;));
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		internal CustomAttrib.NamedArg ReadNamedArg (byte [] data, BinaryReader br, ref bool read)
</I>&gt;<i>  		{
</I>&gt;<i>  			CustomAttrib.NamedArg na = new CustomAttrib.NamedArg ();
</I>&gt;<i> @@ -625,42 +722,15 @@
</I>&gt;<i> 
</I>&gt;<i>  				throw new MetadataFormatException (&quot;Wrong kind of namedarg found: 0x&quot; + kind.ToString(&quot;x2&quot;));
</I>&gt;<i>  
</I>&gt;<i>  			bool array = false;
</I>&gt;<i> -			na.FieldOrPropType = (ElementType) br.ReadByte ();
</I>&gt;<i> -			if (na.FieldOrPropType == ElementType.SzArray) {
</I>&gt;<i> -				na.FieldOrPropType = (ElementType) br.ReadByte ();
</I>&gt;<i> -				array = true;
</I>&gt;<i> -			}
</I>&gt;<i>  
</I>&gt;<i> -			int next, length;
</I>&gt;<i> +			TypeReference elemType = ReadTypeReference (data, br, out na.FieldOrPropType, out array);
</I>&gt;<i>  
</I>&gt;<i> -			if (na.FieldOrPropType == ElementType.Enum) {
</I>&gt;<i> -				read = false;
</I>&gt;<i> -				return na;
</I>&gt;<i> -			}
</I>&gt;<i> +			na.FieldOrPropName = ReadUTF8String (data, br);
</I>&gt;<i> +			na.FixedArg = ReadFixedArg (data, br, array, elemType, ref read);
</I>&gt;<i>  
</I>&gt;<i> -			length = Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, out next);
</I>&gt;<i> -			br.BaseStream.Position = next;
</I>&gt;<i> -
</I>&gt;<i> -			// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is not supported.
</I>&gt;<i> -			byte [] bytes = br.ReadBytes (length);
</I>&gt;<i> -			na.FieldOrPropName = Encoding.UTF8.GetString (bytes, 0, bytes.Length);
</I>&gt;<i> -
</I>&gt;<i> -			na.FixedArg = ReadFixedArg (data, br, array, na.FieldOrPropType, ref read);
</I>&gt;<i> -
</I>&gt;<i>  			return na;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		// i hate this construction, should find something better
</I>&gt;<i> -		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, object param, ref bool read)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (param is TypeReference)
</I>&gt;<i> -				return ReadElem (data, br, param as TypeReference, ref read);
</I>&gt;<i> -			else if (param is ElementType)
</I>&gt;<i> -				return ReadElem (data, br, (ElementType) param, ref read);
</I>&gt;<i> -			else
</I>&gt;<i> -				throw new MetadataFormatException (&quot;Wrong parameter for ReadElem: &quot; + param.GetType ().FullName);
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i>  		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, TypeReference elemType, ref bool read)
</I>&gt;<i>  		{
</I>&gt;<i>  			CustomAttrib.Elem elem = new CustomAttrib.Elem ();
</I>&gt;<i> @@ -668,11 +738,20 @@
</I>&gt;<i> 
</I>&gt;<i>  			string elemName = elemType.FullName;
</I>&gt;<i>  
</I>&gt;<i>  			if (elemName == Constants.Object) {
</I>&gt;<i> -				ElementType elementType = (ElementType) br.ReadByte ();
</I>&gt;<i> -				elem = ReadElem (data, br, elementType, ref read);
</I>&gt;<i> +				bool array;
</I>&gt;<i> +				elemType = ReadTypeReference (data, br, out elem.FieldOrPropType, out array);
</I>&gt;<i> +
</I>&gt;<i> +				if (array) {
</I>&gt;<i> +					read = false; // Don't know how to represent arrays as an object value.
</I>&gt;<i> +					return elem;
</I>&gt;<i> +				}
</I>&gt;<i> +				else if (elemType.FullName == Constants.Object)
</I>&gt;<i> +					throw new MetadataFormatException (&quot;Non valid type in CustomAttrib.Elem after boxed prefix: 0x{0}&quot;,
</I>&gt;<i> +						((byte) elem.FieldOrPropType).ToString(&quot;x2&quot;));
</I>&gt;<i> +
</I>&gt;<i> +				elem = ReadElem (data, br, elemType, ref read);
</I>&gt;<i>  				elem.String = elem.Simple = elem.Type = false;
</I>&gt;<i>  				elem.BoxedValueType = true;
</I>&gt;<i> -				elem.FieldOrPropType = elementType;
</I>&gt;<i>  				return elem;
</I>&gt;<i>  			}
</I>&gt;<i>  
</I>&gt;<i> @@ -694,19 +773,45 @@
</I>&gt;<i> 
</I>&gt;<i>  					elem.Value = null;
</I>&gt;<i>  					br.BaseStream.Position++;
</I>&gt;<i>  				} else {
</I>&gt;<i> -					int next, length = Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, out next);
</I>&gt;<i> -					br.BaseStream.Position = next;
</I>&gt;<i> -					// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is not supported.
</I>&gt;<i> -					byte [] bytes = br.ReadBytes (length);
</I>&gt;<i> -					elem.Value = Encoding.UTF8.GetString (bytes, 0, bytes.Length);
</I>&gt;<i> +					elem.Value = ReadUTF8String (data, br);
</I>&gt;<i>  				}
</I>&gt;<i> -
</I>&gt;<i>  				return elem;
</I>&gt;<i>  			}
</I>&gt;<i>  
</I>&gt;<i>  			elem.String = elem.Type = elem.BoxedValueType = false;
</I>&gt;<i> +			if (!readSimpleValue (br, ref elem, elem.ElemType)) {
</I>&gt;<i> +				TypeReference typeRef = GetEnumUnderlyingType (elem.ElemType);
</I>&gt;<i> +				if (typeRef == null || !readSimpleValue (br, ref elem, typeRef))
</I>&gt;<i> +					read = false;
</I>&gt;<i> +			}
</I>&gt;<i>  
</I>&gt;<i> -			switch (elemName) {
</I>&gt;<i> +			return elem;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		private IAssemblyResolver AssemblyResolver
</I>&gt;<i> +		{
</I>&gt;<i> +			get 
</I>&gt;<i> +			{ 
</I>&gt;<i> +				return m_reflectReader.Module.Assembly.Resolver;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		private TypeReference GetEnumUnderlyingType (TypeReference enumType)
</I>&gt;<i> +		{
</I>&gt;<i> +			TypeDefinition type = enumType as TypeDefinition;
</I>&gt;<i> +			if (type == null &amp;&amp; ForceResolving &amp;&amp; AssemblyResolver != null) 
</I>&gt;<i> +			{
</I>&gt;<i> +				AssemblyDefinition asm = AssemblyResolver.Resolve (enumType.Scope.Name);
</I>&gt;<i> +				type = asm.MainModule.Types[enumType.FullName];
</I>&gt;<i> +			}
</I>&gt;<i> +			if (type != null &amp;&amp; type.IsEnum)
</I>&gt;<i> +				return type.Fields.GetField (&quot;value__&quot;).FieldType;
</I>&gt;<i> +			return null;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		bool readSimpleValue (BinaryReader br, ref CustomAttrib.Elem elem, TypeReference type)
</I>&gt;<i> +		{
</I>&gt;<i> +			switch (type.FullName) {
</I>&gt;<i>  			case Constants.Boolean :
</I>&gt;<i>  				elem.Value = br.ReadByte () == 1;
</I>&gt;<i>  				break;
</I>&gt;<i> @@ -744,120 +849,12 @@
</I>&gt;<i> 
</I>&gt;<i>  				elem.Value = br.ReadUInt64 ();
</I>&gt;<i>  				break;
</I>&gt;<i>  			default : // enum
</I>&gt;<i> -				read = false;
</I>&gt;<i> -				return elem;
</I>&gt;<i> +				return false;
</I>&gt;<i>  			}
</I>&gt;<i> -
</I>&gt;<i>  			elem.Simple = true;
</I>&gt;<i> -			return elem;
</I>&gt;<i> +			return true;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		// elem in named args, only have an ElementType
</I>&gt;<i> -		CustomAttrib.Elem ReadElem (byte [] data, BinaryReader br, ElementType elemType, ref bool read)
</I>&gt;<i> -		{
</I>&gt;<i> -			CustomAttrib.Elem elem = new CustomAttrib.Elem ();
</I>&gt;<i> -
</I>&gt;<i> -			if (elemType == ElementType.Boxed) {
</I>&gt;<i> -				ElementType elementType = (ElementType) br.ReadByte ();
</I>&gt;<i> -				elem = ReadElem (data, br, elementType, ref read);
</I>&gt;<i> -				elem.String = elem.Simple = elem.Type = false;
</I>&gt;<i> -				elem.BoxedValueType = true;
</I>&gt;<i> -				elem.FieldOrPropType = elementType;
</I>&gt;<i> -				return elem;
</I>&gt;<i> -			}
</I>&gt;<i> -
</I>&gt;<i> -			if (elemType == ElementType.Type || elemType == ElementType.String) { // type or string
</I>&gt;<i> -				switch (elemType) {
</I>&gt;<i> -				case ElementType.String :
</I>&gt;<i> -					elem.String = true;
</I>&gt;<i> -					elem.BoxedValueType = elem.Simple = elem.Type = false;
</I>&gt;<i> -					elem.ElemType = m_reflectReader.SearchCoreType (Constants.String);
</I>&gt;<i> -					break;
</I>&gt;<i> -				case ElementType.Type :
</I>&gt;<i> -					elem.Type = true;
</I>&gt;<i> -					elem.BoxedValueType = elem.Simple = elem.String = false;
</I>&gt;<i> -					elem.ElemType = m_reflectReader.SearchCoreType (Constants.Type);
</I>&gt;<i> -					break;
</I>&gt;<i> -				}
</I>&gt;<i> -
</I>&gt;<i> -				if (data [br.BaseStream.Position] == 0xff) { // null
</I>&gt;<i> -					elem.Value = null;
</I>&gt;<i> -					br.BaseStream.Position++;
</I>&gt;<i> -				} else {
</I>&gt;<i> -					int next, length = Utilities.ReadCompressedInteger (data, (int) br.BaseStream.Position, out next);
</I>&gt;<i> -					br.BaseStream.Position = next;
</I>&gt;<i> -					// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is not supported.
</I>&gt;<i> -					byte [] bytes = br.ReadBytes (length);
</I>&gt;<i> -					elem.Value = Encoding.UTF8.GetString (bytes, 0, bytes.Length);
</I>&gt;<i> -				}
</I>&gt;<i> -
</I>&gt;<i> -				return elem;
</I>&gt;<i> -			}
</I>&gt;<i> -
</I>&gt;<i> -			elem.String = elem.Type = elem.BoxedValueType = false;
</I>&gt;<i> -
</I>&gt;<i> -			switch (elemType) {
</I>&gt;<i> -			case ElementType.Boolean :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Boolean);
</I>&gt;<i> -				elem.Value = br.ReadByte () == 1;
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.Char :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Char);
</I>&gt;<i> -				elem.Value = (char) br.ReadUInt16 ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.R4 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Single);
</I>&gt;<i> -				elem.Value = br.ReadSingle ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.R8 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Double);
</I>&gt;<i> -				elem.Value = br.ReadDouble ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.I1 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.SByte);
</I>&gt;<i> -				elem.Value = br.ReadSByte ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.I2 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Int16);
</I>&gt;<i> -				elem.Value = br.ReadInt16 ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.I4 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Int32);
</I>&gt;<i> -				elem.Value = br.ReadInt32 ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.I8 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Int64);
</I>&gt;<i> -				elem.Value = br.ReadInt64 ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.U1 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.Byte);
</I>&gt;<i> -				elem.Value = br.ReadByte ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.U2 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.UInt16);
</I>&gt;<i> -				elem.Value = br.ReadUInt16 ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.U4 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.UInt32);
</I>&gt;<i> -				elem.Value = br.ReadUInt32 ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.U8 :
</I>&gt;<i> -				elem.ElemType = m_reflectReader.SearchCoreType (Constants.UInt64);
</I>&gt;<i> -				elem.Value = br.ReadUInt64 ();
</I>&gt;<i> -				break;
</I>&gt;<i> -			case ElementType.Enum :
</I>&gt;<i> -				read = false;
</I>&gt;<i> -				return elem;
</I>&gt;<i> -			default :
</I>&gt;<i> -				throw new MetadataFormatException (&quot;Non valid type in CustomAttrib.Elem: 0x{0}&quot;,
</I>&gt;<i> -					((byte) elemType).ToString(&quot;x2&quot;));
</I>&gt;<i> -			}
</I>&gt;<i> -
</I>&gt;<i> -			read = true;
</I>&gt;<i> -			elem.Simple = true;
</I>&gt;<i> -			return elem;
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i>  		MarshalSig ReadMarshalSig (byte [] data)
</I>&gt;<i>  		{
</I>&gt;<i>  			int start;
</I>&gt;<i> @@ -905,14 +902,21 @@
</I>&gt;<i> 
</I>&gt;<i>  			return ms;
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		static internal string ReadUTF8String (byte [] data, BinaryReader br)
</I>&gt;<i> +		{
</I>&gt;<i> +			int start = (int)br.BaseStream.Position;
</I>&gt;<i> +			string val = ReadUTF8String (data, start, out start);
</I>&gt;<i> +			br.BaseStream.Position = start;
</I>&gt;<i> +			return val;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		static internal string ReadUTF8String (byte [] data, int pos, out int start)
</I>&gt;<i>  		{
</I>&gt;<i>  			int length = Utilities.ReadCompressedInteger (data, pos, out start);
</I>&gt;<i> -			byte [] str = new byte [length];
</I>&gt;<i> -			Buffer.BlockCopy (data, start, str, 0, length);
</I>&gt;<i> +			pos = start;
</I>&gt;<i>  			start += length;
</I>&gt;<i> -			// COMPACT FRAMEWORK NOTE: Encoding.GetString(byte[]) is not supported.
</I>&gt;<i> -			return Encoding.UTF8.GetString (str, 0, str.Length);
</I>&gt;<i> +			// COMPACT FRAMEWORK NOTE: Encoding.GetString (byte[]) is not supported.
</I>&gt;<i> +			return Encoding.UTF8.GetString (data, pos, length);
</I>&gt;<i>  		}
</I>&gt;<i>  	}
</I>&gt;<i>  }
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020833.html">[Mono-dev] Parch for Enum support in Custom attributes
</A></li>
	<LI>Next message: <A HREF="020843.html">[Mono-dev] Parch for Enum support in Custom attributes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20834">[ date ]</a>
              <a href="thread.html#20834">[ thread ]</a>
              <a href="subject.html#20834">[ subject ]</a>
              <a href="author.html#20834">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
