<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] [PATCH] GetFolderPath improvements
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20GetFolderPath%20improvements&In-Reply-To=1087343235.2902.18.camel%40164-99-120-44.boston.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006485.html">
   <LINK REL="Next"  HREF="006487.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] [PATCH] GetFolderPath improvements</H1>
    <B>Todd Berman</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20%5BPATCH%5D%20GetFolderPath%20improvements&In-Reply-To=1087343235.2902.18.camel%40164-99-120-44.boston.ximian.com"
       TITLE="[Mono-devel-list] [PATCH] GetFolderPath improvements">tberman at sevenl.net
       </A><BR>
    <I>Tue Jun 15 19:56:54 EDT 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="006485.html">[Mono-devel-list] [PATCH] GetFolderPath improvements
</A></li>
        <LI>Next message: <A HREF="006487.html">[Mono-devel-list] [PATCH] GetFolderPath improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6486">[ date ]</a>
              <a href="thread.html#6486">[ thread ]</a>
              <a href="subject.html#6486">[ subject ]</a>
              <a href="author.html#6486">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Why is this becoming an icall?

--Todd

Ben Maurer wrote:
&gt;<i> Hey guys,
</I>&gt;<i> 
</I>&gt;<i> GetFolderPath was returning paths that are not really consistent with
</I>&gt;<i> the Linux background. The attached path will make us do the following
</I>&gt;<i> mappings:
</I>&gt;<i> 
</I>&gt;<i> Desktop
</I>&gt;<i> DesktopDirectory
</I>&gt;<i>         ~/Desktop -- Luis says that this is the default on all GNOME and
</I>&gt;<i>         KDE systems. That should pretty much cover us for Linux.
</I>&gt;<i> Personal
</I>&gt;<i>         ~ -- as before
</I>&gt;<i> ApplicationData
</I>&gt;<i>         The config directory as per fd.o's XDG spec. This defaults to
</I>&gt;<i>         ~/.config
</I>&gt;<i> LocalApplicationData
</I>&gt;<i>         The data folder per XDG. Defaults to ~/.local/share
</I>&gt;<i> CommonApplicationData
</I>&gt;<i>         /etc. Should this be /usr/share.
</I>&gt;<i> System
</I>&gt;<i>         /etc. Maybe /bin is more correct?
</I>&gt;<i> Program Files
</I>&gt;<i> 	/usr/bin
</I>&gt;<i> CommonApplicationData
</I>&gt;<i> 	/usr/share
</I>&gt;<i> 
</I>&gt;<i> All other folders return &quot;&quot;. Per the MSDN docs, if a folder has not been
</I>&gt;<i> created on the computer, the method should return String.Empty. Before
</I>&gt;<i> we would return a semi-related folder for things.
</I>&gt;<i> 
</I>&gt;<i> Another open issue is if we should probe for the existence of the folder
</I>&gt;<i> before returning it. In the windows code, it looks like we even try to
</I>&gt;<i> create the file before giving up. I would appreciate comments on this.
</I>&gt;<i> 
</I>&gt;<i> -- Ben
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> Index: Environment.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> RCS file: /cvs/public/mcs/class/corlib/System/Environment.cs,v
</I>&gt;<i> retrieving revision 1.76
</I>&gt;<i> diff -u -r1.76 Environment.cs
</I>&gt;<i> --- Environment.cs	11 Jun 2004 01:59:23 -0000	1.76
</I>&gt;<i> +++ Environment.cs	15 Jun 2004 22:41:06 -0000
</I>&gt;<i> @@ -90,6 +90,8 @@
</I>&gt;<i>  			MyPictures = 0x27,
</I>&gt;<i>  			CommonProgramFiles = 0x2b,
</I>&gt;<i>  		}
</I>&gt;<i> +		
</I>&gt;<i> +		const SpecialFolder MAX_SPECIAL_FOLDER = SpecialFolder.CommonProgramFiles;
</I>&gt;<i>  
</I>&gt;<i>  		// TODO: Make sure the security attributes do what I expect
</I>&gt;<i>  			
</I>&gt;<i> @@ -367,96 +369,24 @@
</I>&gt;<i>  
</I>&gt;<i>  
</I>&gt;<i>  		[MethodImplAttribute (MethodImplOptions.InternalCall)]
</I>&gt;<i> -		private extern static string GetWindowsFolderPath (int folder);
</I>&gt;<i> +		private extern static string GetFolderPathInternal (int folder);
</I>&gt;<i>  
</I>&gt;<i> +		static string [] get_folder_path_cache;
</I>&gt;<i>  		/// &lt;summary&gt;
</I>&gt;<i>  		/// Returns the fully qualified path of the
</I>&gt;<i>  		/// folder specified by the &quot;folder&quot; parameter
</I>&gt;<i>  		/// &lt;/summary&gt;
</I>&gt;<i>  		public static string GetFolderPath (SpecialFolder folder)
</I>&gt;<i>  		{
</I>&gt;<i> -			if ((int) Platform != 128)
</I>&gt;<i> -				return GetWindowsFolderPath ((int) folder);
</I>&gt;<i> -
</I>&gt;<i> -			// we can do this in managed code for non-Windows environments
</I>&gt;<i> -			string path = String.Empty;
</I>&gt;<i> -
</I>&gt;<i> -			string home = GetEnvironmentVariable (&quot;HOME&quot;);
</I>&gt;<i> -
</I>&gt;<i> -			// <A HREF="http://freedesktop.org/Standards/basedir-spec/basedir-spec-0.6.html">http://freedesktop.org/Standards/basedir-spec/basedir-spec-0.6.html</A>
</I>&gt;<i> -			string data = GetEnvironmentVariable (&quot;XDG_DATA_HOME&quot;);
</I>&gt;<i> -			if ((data == null) || (data == String.Empty)) {
</I>&gt;<i> -				data = Path.Combine (home, &quot;.local&quot;);
</I>&gt;<i> -				data = Path.Combine (data, &quot;share&quot;);
</I>&gt;<i> -			}
</I>&gt;<i> -
</I>&gt;<i> -			string config = GetEnvironmentVariable (&quot;XDG_CONFIG_HOME&quot;);
</I>&gt;<i> -			if ((config == null) || (config == String.Empty)) {
</I>&gt;<i> -				config = Path.Combine (home, &quot;.config&quot;);
</I>&gt;<i> -			}
</I>&gt;<i> -
</I>&gt;<i> -			string cache = GetEnvironmentVariable (&quot;XDG_CACHE_HOME&quot;);
</I>&gt;<i> -			if ((cache == null) || (cache == String.Empty)) {
</I>&gt;<i> -				cache = Path.Combine (home, &quot;.cache&quot;);
</I>&gt;<i> +			if (get_folder_path_cache != null) {
</I>&gt;<i> +				string s = get_folder_path_cache [(int) folder];
</I>&gt;<i> +				if (s != null)
</I>&gt;<i> +					return s;
</I>&gt;<i> +			} else {
</I>&gt;<i> +				get_folder_path_cache = new string [(int)MAX_SPECIAL_FOLDER + 1];
</I>&gt;<i>  			}
</I>&gt;<i> -
</I>&gt;<i> -			switch (folder) {
</I>&gt;<i> -#if NET_1_1
</I>&gt;<i> -			case SpecialFolder.MyComputer: // MyComputer is a virtual directory
</I>&gt;<i> -				path = &quot;&quot;;
</I>&gt;<i> -				break;
</I>&gt;<i> -#endif				      
</I>&gt;<i> -
</I>&gt;<i> -			case SpecialFolder.Personal:
</I>&gt;<i> -				path = home;
</I>&gt;<i> -				break;
</I>&gt;<i> -
</I>&gt;<i> -			// data related
</I>&gt;<i> -			case SpecialFolder.ApplicationData:
</I>&gt;<i> -			case SpecialFolder.LocalApplicationData:
</I>&gt;<i> -			case SpecialFolder.MyMusic:
</I>&gt;<i> -			case SpecialFolder.MyPictures:
</I>&gt;<i> -			case SpecialFolder.Templates:
</I>&gt;<i> -				path = data;
</I>&gt;<i> -				break;
</I>&gt;<i> -
</I>&gt;<i> -			// configuration related
</I>&gt;<i> -#if NET_1_1
</I>&gt;<i> -			case SpecialFolder.Desktop:
</I>&gt;<i> -#endif
</I>&gt;<i> -			case SpecialFolder.DesktopDirectory:
</I>&gt;<i> -			case SpecialFolder.Favorites:
</I>&gt;<i> -			case SpecialFolder.Programs:
</I>&gt;<i> -			case SpecialFolder.SendTo:
</I>&gt;<i> -			case SpecialFolder.StartMenu:
</I>&gt;<i> -			case SpecialFolder.Startup:
</I>&gt;<i> -				path = config;
</I>&gt;<i> -				break;
</I>&gt;<i> -
</I>&gt;<i> -			// cache related (could disappear)
</I>&gt;<i> -			case SpecialFolder.Cookies:
</I>&gt;<i> -			case SpecialFolder.History:
</I>&gt;<i> -			case SpecialFolder.InternetCache:
</I>&gt;<i> -			case SpecialFolder.Recent:
</I>&gt;<i> -				path = cache;
</I>&gt;<i> -				break;
</I>&gt;<i> -
</I>&gt;<i> -			// programs
</I>&gt;<i> -			case SpecialFolder.CommonProgramFiles:
</I>&gt;<i> -			case SpecialFolder.ProgramFiles:
</I>&gt;<i> -			case SpecialFolder.System:
</I>&gt;<i> -				break;
</I>&gt;<i> -
</I>&gt;<i> -			// Directories shared by all users
</I>&gt;<i> -			case SpecialFolder.CommonApplicationData:
</I>&gt;<i> -				path = Path.GetDirectoryName (GetMachineConfigPath ());
</I>&gt;<i> -				break;
</I>&gt;<i> -
</I>&gt;<i> -			default:
</I>&gt;<i> -				throw new ArgumentException (&quot;Invalid SpecialFolder&quot;);
</I>&gt;<i> -                        }
</I>&gt;<i> -
</I>&gt;<i> -			return path;
</I>&gt;<i> +			
</I>&gt;<i> +			return get_folder_path_cache [(int) folder] = GetFolderPathInternal ((int) folder);
</I>&gt;<i>                  }
</I>&gt;<i>  
</I>&gt;<i>  		public static string[] GetLogicalDrives ()
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> ? t
</I>&gt;<i> Index: icall.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> RCS file: /cvs/public/mono/mono/metadata/icall.c,v
</I>&gt;<i> retrieving revision 1.498
</I>&gt;<i> diff -u -r1.498 icall.c
</I>&gt;<i> --- icall.c	12 Jun 2004 11:32:35 -0000	1.498
</I>&gt;<i> +++ icall.c	15 Jun 2004 22:39:30 -0000
</I>&gt;<i> @@ -4443,13 +4443,38 @@
</I>&gt;<i>  	return mono_string_new (mono_domain_get (), mono_assembly_getrootdir ());
</I>&gt;<i>  }
</I>&gt;<i>  
</I>&gt;<i> +typedef enum {
</I>&gt;<i> +	MONO_FOLDER_PATH_DESKTOP = 0x00,
</I>&gt;<i> +	MONO_FOLDER_PATH_MYCOMPUTER = 0x11,
</I>&gt;<i> +	MONO_FOLDER_PATH_PROGRAMS = 0x02,
</I>&gt;<i> +	MONO_FOLDER_PATH_PERSONAL = 0x05,
</I>&gt;<i> +	MONO_FOLDER_PATH_FAVORITES = 0x06,
</I>&gt;<i> +	MONO_FOLDER_PATH_STARTUP = 0x07,
</I>&gt;<i> +	MONO_FOLDER_PATH_RECENT = 0x08,
</I>&gt;<i> +	MONO_FOLDER_PATH_SENDTO = 0x09,
</I>&gt;<i> +	MONO_FOLDER_PATH_STARTMENU = 0x0b,
</I>&gt;<i> +	MONO_FOLDER_PATH_MYMUSIC = 0x0d,
</I>&gt;<i> +	MONO_FOLDER_PATH_DESKTOPDIRECTORY = 0x10,
</I>&gt;<i> +	MONO_FOLDER_PATH_TEMPLATES = 0x15,
</I>&gt;<i> +	MONO_FOLDER_PATH_APPLICATIONDATA	= 0x1a,
</I>&gt;<i> +	MONO_FOLDER_PATH_LOCALAPPLICATIONDATA = 0x1c,
</I>&gt;<i> +	MONO_FOLDER_PATH_INTERNETCACHE = 0x20,
</I>&gt;<i> +	MONO_FOLDER_PATH_COOKIES = 0x21,
</I>&gt;<i> +	MONO_FOLDER_PATH_HISTORY = 0x22,
</I>&gt;<i> +	MONO_FOLDER_PATH_COMMONAPPLICATIONDATA	= 0x23,
</I>&gt;<i> +	MONO_FOLDER_PATH_SYSTEM = 0x25,
</I>&gt;<i> +	MONO_FOLDER_PATH_PROGRAMFILES = 0x26,
</I>&gt;<i> +	MONO_FOLDER_PATH_MYPICTURES = 0x27,
</I>&gt;<i> +	MONO_FOLDER_PATH_COMMONPROGRAMFILES = 0x2b
</I>&gt;<i> +} MonoFolderPathEnum;
</I>&gt;<i> +
</I>&gt;<i>  static MonoString*
</I>&gt;<i> -ves_icall_System_Environment_GetWindowsFolderPath (int folder)
</I>&gt;<i> +ves_icall_System_Environment_GetFolderPathInternal (int folder)
</I>&gt;<i>  {
</I>&gt;<i> -#if defined (PLATFORM_WIN32)
</I>&gt;<i> -	#ifndef CSIDL_FLAG_CREATE
</I>&gt;<i> -		#define CSIDL_FLAG_CREATE	0x8000
</I>&gt;<i> -	#endif
</I>&gt;<i> +#ifdef PLATFORM_WIN32
</I>&gt;<i> +#	ifndef CSIDL_FLAG_CREATE
</I>&gt;<i> +#		define CSIDL_FLAG_CREATE	0x8000
</I>&gt;<i> +#	endif
</I>&gt;<i>  
</I>&gt;<i>  	WCHAR path [MAX_PATH];
</I>&gt;<i>  	/* Create directory if no existing */
</I>&gt;<i> @@ -4460,7 +4485,81 @@
</I>&gt;<i>  		return mono_string_new_utf16 (mono_domain_get (), path, len);
</I>&gt;<i>  	}
</I>&gt;<i>  #else
</I>&gt;<i> -	g_warning (&quot;ves_icall_System_Environment_GetWindowsFolderPath should only be called on Windows!&quot;);
</I>&gt;<i> +	char* path;
</I>&gt;<i> +	MonoString* ret;
</I>&gt;<i> +	switch (folder) {
</I>&gt;<i> +	case MONO_FOLDER_PATH_DESKTOP:
</I>&gt;<i> +	case MONO_FOLDER_PATH_DESKTOPDIRECTORY:
</I>&gt;<i> +		path = g_strconcat (g_get_home_dir (), &quot;/Desktop&quot;, NULL);
</I>&gt;<i> +		ret = mono_string_new (mono_domain_get (), path);
</I>&gt;<i> +		g_free (path);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case MONO_FOLDER_PATH_MYCOMPUTER:
</I>&gt;<i> +		/* this is a virtual folder, we return &quot;&quot; as does MS */
</I>&gt;<i> +		ret = NULL;
</I>&gt;<i> +		break;
</I>&gt;<i> +	case MONO_FOLDER_PATH_PERSONAL:
</I>&gt;<i> +		ret = mono_string_new (mono_domain_get (), g_get_home_dir ());
</I>&gt;<i> +		break;
</I>&gt;<i> +	case MONO_FOLDER_PATH_PROGRAMS:
</I>&gt;<i> +	case MONO_FOLDER_PATH_FAVORITES:
</I>&gt;<i> +	case MONO_FOLDER_PATH_STARTUP:
</I>&gt;<i> +	case MONO_FOLDER_PATH_RECENT:
</I>&gt;<i> +	case MONO_FOLDER_PATH_SENDTO:
</I>&gt;<i> +	case MONO_FOLDER_PATH_STARTMENU:
</I>&gt;<i> +	case MONO_FOLDER_PATH_MYMUSIC:
</I>&gt;<i> +	case MONO_FOLDER_PATH_INTERNETCACHE:
</I>&gt;<i> +	case MONO_FOLDER_PATH_COOKIES:
</I>&gt;<i> +	case MONO_FOLDER_PATH_HISTORY:
</I>&gt;<i> +	case MONO_FOLDER_PATH_TEMPLATES:
</I>&gt;<i> +	case MONO_FOLDER_PATH_MYPICTURES:
</I>&gt;<i> +		/* all of these either a) dont exist on linux, or b) are not
</I>&gt;<i> +		 * standard enough to be worth giving here
</I>&gt;<i> +		 */
</I>&gt;<i> +		ret = NULL;
</I>&gt;<i> +		break;
</I>&gt;<i> +	
</I>&gt;<i> +	case MONO_FOLDER_PATH_APPLICATIONDATA:
</I>&gt;<i> +		/* use FDO's CONFIG_HOME. This data will be synced across a
</I>&gt;<i> +		 * network like the windows counterpart.
</I>&gt;<i> +		 */
</I>&gt;<i> +		 
</I>&gt;<i> +		path = g_getenv (&quot;XDG_CONFIG_HOME&quot;);
</I>&gt;<i> +		if (!path)
</I>&gt;<i> +			path = g_strconcat (g_get_home_dir (), &quot;/.config&quot;, NULL);
</I>&gt;<i> +		
</I>&gt;<i> +		ret = mono_string_new (mono_domain_get (), path);
</I>&gt;<i> +		g_free (path);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case MONO_FOLDER_PATH_LOCALAPPLICATIONDATA:
</I>&gt;<i> +		/* use FDO's DATA_HOME. This is *NOT* synced. */
</I>&gt;<i> +		 
</I>&gt;<i> +		path = g_getenv (&quot;XDG_DATA_HOME&quot;);
</I>&gt;<i> +		if (!path)
</I>&gt;<i> +			path = g_strconcat (g_get_home_dir (), &quot;/.local/share&quot;, NULL);
</I>&gt;<i> +		
</I>&gt;<i> +		ret = mono_string_new (mono_domain_get (), path);
</I>&gt;<i> +		g_free (path);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case MONO_FOLDER_PATH_COMMONAPPLICATIONDATA:
</I>&gt;<i> +		ret = mono_string_new (mono_domain_get (), &quot;/etc&quot;);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case MONO_FOLDER_PATH_SYSTEM:
</I>&gt;<i> +		ret = mono_string_new (mono_domain_get (), &quot;/etc&quot;);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case MONO_FOLDER_PATH_PROGRAMFILES:
</I>&gt;<i> +		ret = mono_string_new (mono_domain_get (), &quot;/usr/bin&quot;);
</I>&gt;<i> +		break;
</I>&gt;<i> +	case MONO_FOLDER_PATH_COMMONPROGRAMFILES:
</I>&gt;<i> +		ret = mono_string_new (mono_domain_get (), &quot;/usr/share&quot;);
</I>&gt;<i> +		break;
</I>&gt;<i> +	default:
</I>&gt;<i> +		g_assert_not_reached ();
</I>&gt;<i> +	}
</I>&gt;<i> +	
</I>&gt;<i> +	/* should we test that the file exists? */
</I>&gt;<i> +	if (ret)
</I>&gt;<i> +		return ret;
</I>&gt;<i>  #endif
</I>&gt;<i>  	return mono_string_new (mono_domain_get (), &quot;&quot;);
</I>&gt;<i>  }
</I>&gt;<i> @@ -5128,10 +5227,10 @@
</I>&gt;<i>  	{&quot;GetCommandLineArgs&quot;, mono_runtime_get_main_args},
</I>&gt;<i>  	{&quot;GetEnvironmentVariable&quot;, ves_icall_System_Environment_GetEnvironmentVariable},
</I>&gt;<i>  	{&quot;GetEnvironmentVariableNames&quot;, ves_icall_System_Environment_GetEnvironmentVariableNames},
</I>&gt;<i> +	{&quot;GetFolderPathInternal&quot;, ves_icall_System_Environment_GetFolderPathInternal},
</I>&gt;<i>  	{&quot;GetLogicalDrivesInternal&quot;, ves_icall_System_Environment_GetLogicalDrives },
</I>&gt;<i>   	{&quot;GetMachineConfigPath&quot;, ves_icall_System_Configuration_DefaultConfig_get_machine_config_path},
</I>&gt;<i>   	{&quot;GetOSVersionString&quot;, ves_icall_System_Environment_GetOSVersionString},
</I>&gt;<i> -	{&quot;GetWindowsFolderPath&quot;, ves_icall_System_Environment_GetWindowsFolderPath},
</I>&gt;<i>  	{&quot;get_ExitCode&quot;, mono_environment_exitcode_get},
</I>&gt;<i>  	{&quot;get_HasShutdownStarted&quot;, ves_icall_System_Environment_get_HasShutdownStarted},
</I>&gt;<i>  	{&quot;get_MachineName&quot;, ves_icall_System_Environment_get_MachineName},
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006485.html">[Mono-devel-list] [PATCH] GetFolderPath improvements
</A></li>
	<LI>Next message: <A HREF="006487.html">[Mono-devel-list] [PATCH] GetFolderPath improvements
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6486">[ date ]</a>
              <a href="thread.html#6486">[ thread ]</a>
              <a href="subject.html#6486">[ subject ]</a>
              <a href="author.html#6486">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
