<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] SslStream implementation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20SslStream%20implementation&In-Reply-To=46CD3197.4000906%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024652.html">
   <LINK REL="Next"  HREF="024663.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] SslStream implementation</H1>
    <B>Sebastien Pouliot</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20SslStream%20implementation&In-Reply-To=46CD3197.4000906%40ximian.com"
       TITLE="[Mono-dev] SslStream implementation">sebastien.pouliot at gmail.com
       </A><BR>
    <I>Thu Aug 23 07:48:46 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="024652.html">[Mono-dev] SslStream implementation
</A></li>
        <LI>Next message: <A HREF="024663.html">[Mono-dev] SslStream implementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24661">[ date ]</a>
              <a href="thread.html#24661">[ thread ]</a>
              <a href="subject.html#24661">[ subject ]</a>
              <a href="author.html#24661">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello Atsushi,

On Thu, 2007-08-23 at 16:04 +0900, Atsushi Eno wrote:
&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;<i> I have created a System.Net.Security.SslStream implementation, which
</I>&gt;<i> is based on Mono.Security.Protocol.Tls.
</I>
Nice work :)

&gt;<i> It requires some Makefile changes (due to cyclic dependency foo).
</I>
This is kind of strange as System.dll (v2) already depends on
Mono.Security.dll

&gt;<i> I have also created a few port of Mono.Security sample tools (which
</I>&gt;<i> are found in Mono.Security/Test/tools) to verify SslStream behavior.
</I>&gt;<i> 
</I>&gt;<i> There are some issues (grep MonoTODO and FIXME) e.g. it requires
</I>&gt;<i> X509Certificate2 due to certificate population in Mono.Security
</I>&gt;<i> (I doubt that it could be solved without changing Mono.Security
</I>&gt;<i> internals).
</I>
a few things inline

&gt;<i> If it looks good I'll check it in svn (probably port of those
</I>&gt;<i> &quot;tools&quot; as well).
</I>&gt;<i> 
</I>&gt;<i> Atsushi Eno
</I>&gt;<i> plain text document attachment (sslstream.patch)
</I>&gt;<i> Index: Makefile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- Makefile	(revision 84522)
</I>&gt;<i> +++ Makefile	(working copy)
</I>&gt;<i> @@ -40,6 +40,8 @@
</I>&gt;<i>  SECURITY_DEP_FILE := $(wildcard ../lib/$(PROFILE)/$(SECURITY_DEP))
</I>&gt;<i>  CONFIGURATION_DEP := System.Configuration.dll
</I>&gt;<i>  CONFIGURATION_DEP_FILE := $(wildcard ../lib/$(PROFILE)/$(CONFIGURATION_DEP))
</I>&gt;<i> +PREBUILT_DEP := System.dll
</I>&gt;<i> +PREBUILT_DEP_FILE := $(wildcard ../lib/$(PROFILE)/$(PREBUILT_DEP))
</I>&gt;<i>  CYCLIC_DEPS += $(SECURITY_DEP) $(CONFIGURATION_DEP)
</I>&gt;<i>  CYCLIC_DEP_FILES += $(SECURITY_DEP_FILE) $(CONFIGURATION_DEP_FILE)
</I>&gt;<i>  LIB_MCS_FLAGS = -nowarn:618 -d:CONFIGURATION_2_0 -unsafe $(RESOURCE_FILES:%=-resource:%)
</I>&gt;<i> @@ -95,10 +97,14 @@
</I>&gt;<i>  endif
</I>&gt;<i>  
</I>&gt;<i>  ifdef CONFIGURATION_DEP_FILE
</I>&gt;<i> -LIB_MCS_FLAGS += -define:CONFIGURATION_DEP -r:$(CONFIGURATION_DEP) -r:PrebuiltSystem=$(topdir)/class/lib/$(PROFILE)/System.dll
</I>&gt;<i> +LIB_MCS_FLAGS += -define:CONFIGURATION_DEP -r:$(CONFIGURATION_DEP)
</I>&gt;<i>  $(the_lib): $(CONFIGURATION_DEP_FILE)
</I>&gt;<i>  endif
</I>&gt;<i>  
</I>&gt;<i> +ifdef PREBUILT_DEP_FILE
</I>&gt;<i> +LIB_MCS_FLAGS += -r:PrebuiltSystem=$(topdir)/class/lib/$(PROFILE)/System.dll
</I>&gt;<i> +endif
</I>&gt;<i> +
</I>&gt;<i>  $(test_lib): $(test_lib).config $(TEST_RESOURCES)
</I>&gt;<i>  
</I>&gt;<i>  $(test_lib).config: Test/test-config-file
</I>&gt;<i> Index: System.Net.Security/SslStream.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- System.Net.Security/SslStream.cs	(revision 84522)
</I>&gt;<i> +++ System.Net.Security/SslStream.cs	(working copy)
</I>&gt;<i> @@ -3,9 +3,10 @@
</I>&gt;<i>  //
</I>&gt;<i>  // Authors:
</I>&gt;<i>  //	Tim Coleman (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">tim at timcoleman.com</A>)
</I>&gt;<i> +//	Atsushi Enomoto (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>)
</I>&gt;<i>  //
</I>&gt;<i>  // Copyright (C) Tim Coleman, 2004
</I>&gt;<i> -// (c) 2004 Novell, Inc. (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> +// (c) 2004,2007 Novell, Inc. (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i>  //
</I>&gt;<i>  
</I>&gt;<i>  //
</I>&gt;<i> @@ -29,7 +30,8 @@
</I>&gt;<i>  // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</I>&gt;<i>  //
</I>&gt;<i>  
</I>&gt;<i> -#if NET_2_0 
</I>&gt;<i> +#if NET_2_0 &amp;&amp; SECURITY_DEP
</I>&gt;<i> +extern alias PrebuiltSystem;
</I>&gt;<i>  
</I>&gt;<i>  using System;
</I>&gt;<i>  using System.IO;
</I>&gt;<i> @@ -37,44 +39,61 @@
</I>&gt;<i>  using System.Security.Authentication;
</I>&gt;<i>  using System.Security.Cryptography.X509Certificates;
</I>&gt;<i>  using System.Security.Principal;
</I>&gt;<i> +using System.Security.Cryptography;
</I>&gt;<i> +using Mono.Security.Protocol.Tls;
</I>&gt;<i>  
</I>&gt;<i> +using CipherAlgorithmType = System.Security.Authentication.CipherAlgorithmType;
</I>&gt;<i> +using HashAlgorithmType = System.Security.Authentication.HashAlgorithmType;
</I>&gt;<i> +using ExchangeAlgorithmType = System.Security.Authentication.ExchangeAlgorithmType;
</I>&gt;<i> +
</I>&gt;<i> +using MonoCipherAlgorithmType = Mono.Security.Protocol.Tls.CipherAlgorithmType;
</I>&gt;<i> +using MonoHashAlgorithmType = Mono.Security.Protocol.Tls.HashAlgorithmType;
</I>&gt;<i> +using MonoExchangeAlgorithmType = Mono.Security.Protocol.Tls.ExchangeAlgorithmType;
</I>&gt;<i> +using MonoSecurityProtocolType = Mono.Security.Protocol.Tls.SecurityProtocolType;
</I>&gt;<i> +
</I>&gt;<i> +using X509CertificateCollection = PrebuiltSystem::System.Security.Cryptography.X509Certificates.X509CertificateCollection;
</I>&gt;<i> +
</I>&gt;<i>  namespace System.Net.Security 
</I>&gt;<i>  {
</I>&gt;<i> +	[MonoLimitation (&quot;Non-X509Certificate2 certificate is not supported&quot;)]
</I>
The original X509Certificate is busted, design-wise, wrt to the private
key.

&gt;<i>  	public class SslStream : AuthenticatedStream
</I>&gt;<i>  	{
</I>&gt;<i>  		#region Fields
</I>&gt;<i>  
</I>&gt;<i> -		int readTimeout;
</I>&gt;<i> -		int writeTimeout;
</I>&gt;<i> +		int read_timeout;
</I>&gt;<i> +		int write_timeout;
</I>&gt;<i> +		SslStreamBase ssl_stream;
</I>&gt;<i> +		RemoteCertificateValidationCallback validation_callback;
</I>&gt;<i> +		LocalCertificateSelectionCallback selection_callback;
</I>&gt;<i>  
</I>&gt;<i>  		#endregion // Fields
</I>&gt;<i>  
</I>&gt;<i>  		#region Constructors
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public SslStream (Stream innerStream)
</I>&gt;<i> -			: base (innerStream, false)
</I>&gt;<i> +			: this (innerStream, false)
</I>&gt;<i>  		{
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public SslStream (Stream innerStream, bool leaveStreamOpen)
</I>&gt;<i>  			: base (innerStream, leaveStreamOpen)
</I>&gt;<i>  		{
</I>&gt;<i>  		}
</I>&gt;<i> -#if SECURITY_DEP
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> +
</I>&gt;<i> +		[MonoTODO (&quot;certValidationCallback is not passed X509Chain and SslPolicyErrors correctly&quot;)]
</I>&gt;<i>  		public SslStream (Stream innerStream, bool leaveStreamOpen, RemoteCertificateValidationCallback certValidationCallback)
</I>&gt;<i> -			: base (innerStream, leaveStreamOpen)
</I>&gt;<i> +			: this (innerStream, leaveStreamOpen, certValidationCallback, null)
</I>&gt;<i>  		{
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> +		[MonoTODO (&quot;certValidationCallback is not passed X509Chain and SslPolicyErrors correctly&quot;)]
</I>&gt;<i>  		public SslStream (Stream innerStream, bool leaveStreamOpen, RemoteCertificateValidationCallback certValidationCallback, LocalCertificateSelectionCallback certSelectionCallback)
</I>&gt;<i>  			: base (innerStream, leaveStreamOpen)
</I>&gt;<i>  		{
</I>&gt;<i> +			// they are nullable.
</I>&gt;<i> +			validation_callback = certValidationCallback;
</I>&gt;<i> +			selection_callback = certSelectionCallback;
</I>&gt;<i>  		}
</I>&gt;<i> -#endif
</I>&gt;<i>  		#endregion // Constructors
</I>&gt;<i>  
</I>&gt;<i>  		#region Properties
</I>&gt;<i> @@ -87,231 +106,420 @@
</I>&gt;<i>  			get { return InnerStream.CanSeek; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override bool CanTimeout {
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +			get { return InnerStream.CanTimeout; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public override bool CanWrite {
</I>&gt;<i>  			get { return InnerStream.CanWrite; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public virtual bool CheckCertRevocationStatus {
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +		public override long Length {
</I>&gt;<i> +			get { return InnerStream.Length; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public virtual CipherAlgorithmType CipherAlgorithm  {
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +		public override long Position {
</I>&gt;<i> +			get { return InnerStream.Position; }
</I>&gt;<i> +			set {
</I>&gt;<i> +				throw new NotSupportedException (&quot;This stream does not support seek operations&quot;);
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public virtual int CipherStrength  {
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> -		}
</I>&gt;<i> +		// AuthenticatedStream overrides
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public virtual HashAlgorithmType HashAlgorithm  {
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public virtual int HashStrength  {
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override bool IsAuthenticated { 
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +			get { return ssl_stream != null; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override bool IsEncrypted { 
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +			get { return IsAuthenticated; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override bool IsMutuallyAuthenticated { 
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +			get { return IsAuthenticated &amp;&amp; (IsServer ? RemoteCertificate != null : LocalCertificate != null); }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override bool IsServer { 
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +			get { return ssl_stream is SslServerStream; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override bool IsSigned { 
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +			get { return IsAuthenticated; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public virtual ExchangeAlgorithmType KeyExchangeAlgorithm { 
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +		[MonoTODO (&quot;The property exists but not supported&quot;)]
</I>
Since it's an override over Stream.ReadTimeout can't the original (base)
do the job ?

&gt;<i> +		public override int ReadTimeout {
</I>&gt;<i> +			get { return read_timeout; }
</I>&gt;<i> +			set { read_timeout = value; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public virtual int KeyExchangeStrength { 
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +		[MonoTODO (&quot;The property exists but not supported&quot;)]
</I>
same

&gt;<i> +		public override int WriteTimeout {
</I>&gt;<i> +			get { return write_timeout; }
</I>&gt;<i> +			set { write_timeout = value; }
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public override long Length {
</I>&gt;<i> -			get { return InnerStream.Length; }
</I>&gt;<i> +		// SslStream
</I>&gt;<i> +
</I>&gt;<i> +		public virtual bool CheckCertRevocationStatus {
</I>&gt;<i> +			get {
</I>&gt;<i> +				if (!IsAuthenticated)
</I>&gt;<i> +					return false;
</I>&gt;<i> +
</I>&gt;<i> +				return ssl_stream.CheckCertRevocationStatus;
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public virtual X509Certificate LocalCertificate {
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +		public virtual CipherAlgorithmType CipherAlgorithm  {
</I>&gt;<i> +			get {
</I>&gt;<i> +				CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +				switch (ssl_stream.CipherAlgorithm) {
</I>&gt;<i> +				case MonoCipherAlgorithmType.Des:
</I>&gt;<i> +					return CipherAlgorithmType.Des;
</I>&gt;<i> +				case MonoCipherAlgorithmType.None:
</I>&gt;<i> +					return CipherAlgorithmType.None;
</I>&gt;<i> +				case MonoCipherAlgorithmType.Rc2:
</I>&gt;<i> +					return CipherAlgorithmType.Rc2;
</I>&gt;<i> +				case MonoCipherAlgorithmType.Rc4:
</I>&gt;<i> +					return CipherAlgorithmType.Rc4;
</I>&gt;<i> +				case MonoCipherAlgorithmType.SkipJack:
</I>&gt;<i> +					break;
</I>&gt;<i> +				case MonoCipherAlgorithmType.TripleDes:
</I>&gt;<i> +					return CipherAlgorithmType.TripleDes;
</I>&gt;<i> +				case MonoCipherAlgorithmType.Rijndael:
</I>&gt;<i> +					switch (ssl_stream.CipherStrength) {
</I>&gt;<i> +					case 128:
</I>&gt;<i> +						return CipherAlgorithmType.Aes128;
</I>&gt;<i> +					case 192:
</I>&gt;<i> +						return CipherAlgorithmType.Aes192;
</I>&gt;<i> +					case 256:
</I>&gt;<i> +						return CipherAlgorithmType.Aes256;
</I>&gt;<i> +					}
</I>&gt;<i> +					break;
</I>&gt;<i> +				}
</I>&gt;<i> +
</I>&gt;<i> +				throw new InvalidOperationException (&quot;Not supported cipher algorithm is in use. It is likely a bug in SslStream.&quot;);
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public override long Position {
</I>&gt;<i> -			get { return InnerStream.Position; }
</I>&gt;<i> -			set { InnerStream.Position = value; }
</I>&gt;<i> +		public virtual int CipherStrength  {
</I>&gt;<i> +			get {
</I>&gt;<i> +				CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +				return ssl_stream.CipherStrength;
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		public override int ReadTimeout {
</I>&gt;<i> -			get { return readTimeout; }
</I>&gt;<i> -			set { readTimeout = value; }
</I>&gt;<i> +		public virtual HashAlgorithmType HashAlgorithm  {
</I>&gt;<i> +			get {
</I>&gt;<i> +				CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +				switch (ssl_stream.HashAlgorithm) {
</I>&gt;<i> +				case MonoHashAlgorithmType.Md5:
</I>&gt;<i> +					return HashAlgorithmType.Md5;
</I>&gt;<i> +				case MonoHashAlgorithmType.None:
</I>&gt;<i> +					return HashAlgorithmType.None;
</I>&gt;<i> +				case MonoHashAlgorithmType.Sha1:
</I>&gt;<i> +					return HashAlgorithmType.Sha1;
</I>&gt;<i> +				}
</I>&gt;<i> +
</I>&gt;<i> +				throw new InvalidOperationException (&quot;Not supported hash algorithm is in use. It is likely a bug in SslStream.&quot;);
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> +		public virtual int HashStrength  {
</I>&gt;<i> +			get {
</I>&gt;<i> +				CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +				return ssl_stream.HashStrength;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public virtual ExchangeAlgorithmType KeyExchangeAlgorithm { 
</I>&gt;<i> +			get {
</I>&gt;<i> +				CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +				switch (ssl_stream.KeyExchangeAlgorithm) {
</I>&gt;<i> +				case MonoExchangeAlgorithmType.DiffieHellman:
</I>&gt;<i> +					return ExchangeAlgorithmType.DiffieHellman;
</I>&gt;<i> +				case MonoExchangeAlgorithmType.Fortezza:
</I>&gt;<i> +					break;
</I>&gt;<i> +				case MonoExchangeAlgorithmType.None:
</I>&gt;<i> +					return ExchangeAlgorithmType.None;
</I>&gt;<i> +				case MonoExchangeAlgorithmType.RsaKeyX:
</I>&gt;<i> +					return ExchangeAlgorithmType.RsaKeyX;
</I>&gt;<i> +				case MonoExchangeAlgorithmType.RsaSign:
</I>&gt;<i> +					return ExchangeAlgorithmType.RsaSign;
</I>&gt;<i> +				}
</I>&gt;<i> +
</I>&gt;<i> +				throw new InvalidOperationException (&quot;Not supported exchange algorithm is in use. It is likely a bug in SslStream.&quot;);
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public virtual int KeyExchangeStrength { 
</I>&gt;<i> +			get {
</I>&gt;<i> +				CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +				return ssl_stream.KeyExchangeStrength;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		public virtual X509Certificate LocalCertificate {
</I>&gt;<i> +			get {
</I>&gt;<i> +				CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +				return IsServer ? ssl_stream.ServerCertificate : ((SslClientStream) ssl_stream).SelectedClientCertificate;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public virtual X509Certificate RemoteCertificate {
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> +			get {
</I>&gt;<i> +				CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +				return !IsServer ? ssl_stream.ServerCertificate : ((SslServerStream) ssl_stream).ClientCertificate;
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public virtual SslProtocols SslProtocol {
</I>&gt;<i> -			get { throw new NotImplementedException (); }
</I>&gt;<i> -		}
</I>&gt;<i> +			get {
</I>&gt;<i> +				CheckConnectionAuthenticated ();
</I>&gt;<i>  
</I>&gt;<i> -		public override int WriteTimeout {
</I>&gt;<i> -			get { return writeTimeout; }
</I>&gt;<i> -			set { writeTimeout = value; }
</I>&gt;<i> +				switch (ssl_stream.SecurityProtocol) {
</I>&gt;<i> +				case MonoSecurityProtocolType.Default:
</I>&gt;<i> +					return SslProtocols.Default;
</I>&gt;<i> +				case MonoSecurityProtocolType.Ssl2:
</I>&gt;<i> +					return SslProtocols.Ssl2;
</I>&gt;<i> +				case MonoSecurityProtocolType.Ssl3:
</I>&gt;<i> +					return SslProtocols.Ssl3;
</I>&gt;<i> +				case MonoSecurityProtocolType.Tls:
</I>&gt;<i> +					return SslProtocols.Tls;
</I>&gt;<i> +				}
</I>&gt;<i> +
</I>&gt;<i> +				throw new InvalidOperationException (&quot;Not supported SSL/TLS protocol is in use. It is likely a bug in SslStream.&quot;);
</I>&gt;<i> +			}
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		#endregion // Properties
</I>&gt;<i>  
</I>&gt;<i>  		#region Methods
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> +		AsymmetricAlgorithm GetPrivateKey (X509Certificate cert, string targetHost)
</I>&gt;<i> +		{
</I>&gt;<i> +			// FIXME: what can I do for non-X509Certificate2 ?
</I>nothing, MS can't do much either. It will find a private key *if* the
X509Certificate exists in the CryptoAPI key store (associated to the
certificate store) but the X509Store class (2.0) deals with
X509Certificate2 so...
&gt;<i> +			X509Certificate2 cert2 = cert as X509Certificate2;
</I>&gt;<i> +			return cert2 != null ? cert2.PrivateKey : null;
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		X509Certificate OnCertificateSelection (X509CertificateCollection clientCerts, X509Certificate serverCert, string targetHost, X509CertificateCollection serverRequestedCerts)
</I>&gt;<i> +		{
</I>&gt;<i> +			string [] acceptableIssuers = new string [serverRequestedCerts != null ? serverRequestedCerts.Count : 0];
</I>&gt;<i> +			for (int i = 0; i &lt; acceptableIssuers.Length; i++)
</I>&gt;<i> +				acceptableIssuers [i] = serverRequestedCerts [i].GetIssuerName ();
</I>&gt;<i> +			return selection_callback (this, targetHost, clientCerts, serverCert, acceptableIssuers);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, AsyncCallback asyncCallback, object asyncState)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			return BeginAuthenticateAsClient (targetHost, new X509CertificateCollection (), SslProtocols.Tls, false, asyncCallback, asyncState);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, X509CertificateCollection clientCertificates, SslProtocols sslProtocolType, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			if (IsAuthenticated)
</I>&gt;<i> +				throw new InvalidOperationException (&quot;This SslStream is already authenticated&quot;);
</I>&gt;<i> +
</I>&gt;<i> +			SslClientStream s = new SslClientStream (InnerStream,  targetHost, !LeaveInnerStreamOpen, GetMonoSslProtocol (sslProtocolType), clientCertificates);
</I>&gt;<i> +			s.CheckCertRevocationStatus = checkCertificateRevocation;
</I>&gt;<i> +
</I>&gt;<i> +			// Due to the Mono.Security internal, it cannot reuse
</I>&gt;<i> +			// the delegated argument, as Mono.Security creates 
</I>&gt;<i> +			// another instance of X509Certificate which lacks 
</I>&gt;<i> +			// private key but is filled the private key via this
</I>&gt;<i> +			// delegate.
</I>this could be changed, in the 2.0 profile, as the Mono.Security version
of X509Certificate is private-key aware.
&gt;<i> 
</I>&gt;<i> +			s.PrivateKeyCertSelectionDelegate = delegate (X509Certificate cert, string host) {
</I>&gt;<i> +				string hash = cert.GetCertHashString ();
</I>&gt;<i> +				// ... so, we cannot use the delegate argument.
</I>&gt;<i> +				foreach (X509Certificate cc in clientCertificates) {
</I>&gt;<i> +					if (cc.GetCertHashString () != hash)
</I>&gt;<i> +						continue;
</I>&gt;<i> +					X509Certificate2 cert2 = cc as X509Certificate2;
</I>&gt;<i> +					cert2 = cert2 ?? new X509Certificate2 (cc);
</I>&gt;<i> +					return cert2.PrivateKey;
</I>&gt;<i> +				}
</I>&gt;<i> +				return null;
</I>&gt;<i> +			};
</I>&gt;<i> +
</I>&gt;<i> +			if (validation_callback != null)
</I>
The X509Chain inside System.dll is more RFC3280 compliant than the
(older) one provided in Mono.Security.dll and should be used.

&gt;<i> +				s.ServerCertValidationDelegate = delegate (X509Certificate cert, int [] certErrors) {
</I>&gt;<i> +					// FIXME: X509Chain is not provided
</I>&gt;<i> +					// FIXME: SslPolicyErrors is incomplete
</I>&gt;<i> +					SslPolicyErrors errors = certErrors.Length &gt; 0 ? SslPolicyErrors.RemoteCertificateChainErrors : SslPolicyErrors.None;
</I>&gt;<i> +					return validation_callback (this, cert, null, errors);
</I>&gt;<i> +				};
</I>&gt;<i> +			if (selection_callback != null)
</I>&gt;<i> +				s.ClientCertSelectionDelegate = OnCertificateSelection;
</I>&gt;<i> +
</I>&gt;<i> +			ssl_stream = s;
</I>&gt;<i> +
</I>&gt;<i> +			return BeginWrite (new byte [0], 0, 0, asyncCallback, asyncState);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +			return ssl_stream.BeginRead (buffer, offset, count, asyncCallback, asyncState);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public virtual IAsyncResult BeginAuthenticateAsServer (X509Certificate serverCertificate, AsyncCallback callback, object asyncState)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			return BeginAuthenticateAsServer (serverCertificate, false, SslProtocols.Tls, false, callback, asyncState);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public virtual IAsyncResult BeginAuthenticateAsServer (X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols sslProtocolType, bool checkCertificateRevocation, AsyncCallback callback, object asyncState)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			if (IsAuthenticated)
</I>&gt;<i> +				throw new InvalidOperationException (&quot;This SslStream is already authenticated&quot;);
</I>&gt;<i> +
</I>&gt;<i> +			SslServerStream s = new SslServerStream (InnerStream, serverCertificate, clientCertificateRequired, !LeaveInnerStreamOpen, GetMonoSslProtocol (sslProtocolType));
</I>&gt;<i> +			s.CheckCertRevocationStatus = checkCertificateRevocation;
</I>&gt;<i> +			// Due to the Mono.Security internal, it cannot reuse
</I>&gt;<i> +			// the delegated argument, as Mono.Security creates 
</I>&gt;<i> +			// another instance of X509Certificate which lacks 
</I>&gt;<i> +			// private key but is filled the private key via this
</I>&gt;<i> +			// delegate.
</I>same
&gt;<i> +			s.PrivateKeyCertSelectionDelegate = delegate (X509Certificate cert, string targetHost) {
</I>&gt;<i> +				// ... so, we cannot use the delegate argument.
</I>&gt;<i> +				X509Certificate2 cert2 = serverCertificate as X509Certificate2 ?? new X509Certificate2 (serverCertificate);
</I>&gt;<i> +				return cert2 != null ? cert2.PrivateKey : null;
</I>&gt;<i> +			};
</I>&gt;<i> +
</I>&gt;<i> +			if (validation_callback != null)
</I>&gt;<i> +				s.ClientCertValidationDelegate = delegate (X509Certificate cert, int [] certErrors) {
</I>&gt;<i> +					// FIXME: X509Chain is not provided
</I>&gt;<i> +					// FIXME: SslPolicyErrors is incomplete
</I>&gt;<i> +					SslPolicyErrors errors = certErrors.Length &gt; 0 ? SslPolicyErrors.RemoteCertificateChainErrors : SslPolicyErrors.None;
</I>&gt;<i> +					return validation_callback (this, cert, null, errors);
</I>&gt;<i> +				};
</I>&gt;<i> +
</I>&gt;<i> +			ssl_stream = s;
</I>&gt;<i> +
</I>&gt;<i> +			return BeginRead (new byte [0], 0, 0, callback, asyncState);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> +		MonoSecurityProtocolType GetMonoSslProtocol (SslProtocols ms)
</I>&gt;<i> +		{
</I>&gt;<i> +			switch (ms) {
</I>&gt;<i> +			case SslProtocols.Ssl2:
</I>&gt;<i> +				return MonoSecurityProtocolType.Ssl2;
</I>&gt;<i> +			case SslProtocols.Ssl3:
</I>&gt;<i> +				return MonoSecurityProtocolType.Ssl3;
</I>&gt;<i> +			case SslProtocols.Tls:
</I>&gt;<i> +				return MonoSecurityProtocolType.Tls;
</I>&gt;<i> +			default:
</I>&gt;<i> +				return MonoSecurityProtocolType.Default;
</I>&gt;<i> +			}
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +			return ssl_stream.BeginWrite (buffer, offset, count, asyncCallback, asyncState);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public virtual void AuthenticateAsClient (string targetHost)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			AuthenticateAsClient (targetHost, new X509CertificateCollection (), SslProtocols.Tls, false);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public virtual void AuthenticateAsClient (string targetHost, X509CertificateCollection clientCertificates, SslProtocols sslProtocolType, bool checkCertificateRevocation)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			EndAuthenticateAsClient (BeginAuthenticateAsClient (
</I>&gt;<i> +				targetHost, clientCertificates, sslProtocolType, checkCertificateRevocation, null, null));
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public virtual void AuthenticateAsServer (X509Certificate serverCertificate)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			AuthenticateAsServer (serverCertificate, false, SslProtocols.Tls, false);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public virtual void AuthenticateAsServer (X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols sslProtocolType, bool checkCertificateRevocation)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			EndAuthenticateAsServer (BeginAuthenticateAsServer (
</I>&gt;<i> +				serverCertificate, clientCertificateRequired, sslProtocolType, checkCertificateRevocation, null, null));
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		protected override void Dispose (bool disposing)
</I>&gt;<i>  		{
</I>&gt;<i> +			if (disposing) {
</I>&gt;<i> +				if (ssl_stream != null)
</I>&gt;<i> +					ssl_stream.Dispose ();
</I>&gt;<i> +				ssl_stream = null;
</I>&gt;<i> +			}
</I>&gt;<i>  			base.Dispose (disposing);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +			if (CanRead)
</I>&gt;<i> +				ssl_stream.EndRead (asyncResult);
</I>&gt;<i> +			else
</I>&gt;<i> +				ssl_stream.EndWrite (asyncResult);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public override int EndRead (IAsyncResult asyncResult)
</I>&gt;<i> +		public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +			if (CanRead)
</I>&gt;<i> +				ssl_stream.EndRead (asyncResult);
</I>&gt;<i> +			else
</I>&gt;<i> +				ssl_stream.EndWrite (asyncResult);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i> -		public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult)
</I>&gt;<i> +		public override int EndRead (IAsyncResult asyncResult)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +			return ssl_stream.EndRead (asyncResult);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override void EndWrite (IAsyncResult asyncResult)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i> +			ssl_stream.EndWrite (asyncResult);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override void Flush ()
</I>&gt;<i>  		{
</I>&gt;<i> +			CheckConnectionAuthenticated ();
</I>&gt;<i> +
</I>&gt;<i>  			InnerStream.Flush ();
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override int Read (byte[] buffer, int offset, int count)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			return EndRead (BeginRead (buffer, offset, count, null, null));
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override long Seek (long offset, SeekOrigin origin)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			throw new NotSupportedException (&quot;This stream does not support seek operations&quot;);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override void SetLength (long value)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			InnerStream.SetLength (value);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> -		[MonoTODO]
</I>&gt;<i>  		public override void Write (byte[] buffer, int offset, int count)
</I>&gt;<i>  		{
</I>&gt;<i> -			throw new NotImplementedException ();
</I>&gt;<i> +			EndWrite (BeginWrite (buffer, offset, count, null, null));
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i>  		public void Write (byte[] buffer)
</I>&gt;<i> @@ -319,6 +527,12 @@
</I>&gt;<i>  			Write (buffer, 0, buffer.Length);
</I>&gt;<i>  		}
</I>&gt;<i>  
</I>&gt;<i> +		void CheckConnectionAuthenticated ()
</I>&gt;<i> +		{
</I>&gt;<i> +			if (!IsAuthenticated)
</I>&gt;<i> +				throw new InvalidOperationException (&quot;This operation is invalid until it is successfully authenticated&quot;);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i>  		#endregion // Methods
</I>&gt;<i>  	}
</I>&gt;<i>  }
</I>&gt;<i> Index: System.Net.Security/LocalCertificateSelectionCallback.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- System.Net.Security/LocalCertificateSelectionCallback.cs	(revision 84522)
</I>&gt;<i> +++ System.Net.Security/LocalCertificateSelectionCallback.cs	(working copy)
</I>&gt;<i> @@ -29,10 +29,13 @@
</I>&gt;<i>  // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</I>&gt;<i>  //
</I>&gt;<i>  
</I>&gt;<i> -#if NET_2_0 
</I>&gt;<i> +#if NET_2_0 &amp;&amp; SECURITY_DEP
</I>&gt;<i> +extern alias PrebuiltSystem;
</I>&gt;<i>  
</I>&gt;<i>  using System.Security.Cryptography.X509Certificates;
</I>&gt;<i>  
</I>&gt;<i> +using X509CertificateCollection = PrebuiltSystem::System.Security.Cryptography.X509Certificates.X509CertificateCollection;
</I>&gt;<i> +
</I>&gt;<i>  namespace System.Net.Security 
</I>&gt;<i>  {
</I>&gt;<i>  	public delegate X509Certificate LocalCertificateSelectionCallback (
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024652.html">[Mono-dev] SslStream implementation
</A></li>
	<LI>Next message: <A HREF="024663.html">[Mono-dev] SslStream implementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24661">[ date ]</a>
              <a href="thread.html#24661">[ thread ]</a>
              <a href="subject.html#24661">[ subject ]</a>
              <a href="author.html#24661">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
