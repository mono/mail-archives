<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] FW: RealTimeSignal patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20FW%3A%20RealTimeSignal%20patch&In-Reply-To=E961123C01E7E94AA29163941172913E0722BBBB%40mail1.dundee.realtimeworlds.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030232.html">
   <LINK REL="Next"  HREF="030269.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] FW: RealTimeSignal patch</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20FW%3A%20RealTimeSignal%20patch&In-Reply-To=E961123C01E7E94AA29163941172913E0722BBBB%40mail1.dundee.realtimeworlds.com"
       TITLE="[Mono-dev] FW: RealTimeSignal patch">jonpryor at vt.edu
       </A><BR>
    <I>Wed Dec 17 13:05:20 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="030232.html">[Mono-dev] FW: RealTimeSignal patch
</A></li>
        <LI>Next message: <A HREF="030269.html">[Mono-dev] FW: RealTimeSignal patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30239">[ date ]</a>
              <a href="thread.html#30239">[ thread ]</a>
              <a href="subject.html#30239">[ subject ]</a>
              <a href="author.html#30239">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Looking good, but three issues need fixing before we can commit:

1. Formatting.  There are still numerous cases where there isn't a space
before the opening parenthesis.

2. UnixSignal tests that use RealTimeSignum should remain in the
UnixSignalTest class, as these are still testing UnixSignal
functionality, not RealTimeSignum functionality.

3. mono/support/map.h needs to be updated to provide prototypes for the
new functions in mono/support/signal.c.  Installing mono-tools (to get
create-native-map) and running `make refresh` from mono/support will
update mono/support/map.h for you.

BTW, do you have commit access to svn?  If not, I can handle (3) for you
when I commit the patches.

 - Jon

On Wed, 2008-12-17 at 11:19 +0000, <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">tim.jenks at realtimeworlds.com</A> wrote:
&gt;<i> Index: class/Mono.Posix/Mono.Unix.Native/Stdlib.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- class/Mono.Posix/Mono.Unix.Native/Stdlib.cs (revision 121281)
</I>&gt;<i> +++ class/Mono.Posix/Mono.Unix.Native/Stdlib.cs (working copy)
</I>&gt;<i> @@ -504,6 +504,16 @@
</I>&gt;<i>  
</I>&gt;<i>                 public static int SetSignalAction (Signum signal, SignalAction action)
</I>&gt;<i>                 {
</I>&gt;<i> +                       return SetSignalAction(NativeConvert.FromSignum(signal), action);
</I>
Missing space before opening parenthesis (2x).

&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               public static int SetSignalAction (RealTimeSignum rts, SignalAction action)
</I>&gt;<i> +               {
</I>&gt;<i> +                       return SetSignalAction(NativeConvert.FromRealTimeSignum(rts), action);
</I>
&#65279;Missing space before opening parenthesis (2x).

&gt;<i> +               }
</I>&gt;<i> +               
</I>&gt;<i> +               private static int SetSignalAction (int signum, SignalAction action)
</I>&gt;<i> +               {
</I>&gt;<i>                         IntPtr handler = IntPtr.Zero;
</I>&gt;<i>                         switch (action) {
</I>&gt;<i>                                 case SignalAction.Default:
</I>&gt;<i> @@ -518,7 +528,7 @@
</I>&gt;<i>                                 default:
</I>&gt;<i>                                         throw new ArgumentException (&quot;Invalid action value.&quot;, &quot;action&quot;);
</I>&gt;<i>                         }
</I>&gt;<i> -                       IntPtr r = sys_signal (NativeConvert.FromSignum (signal), handler);
</I>&gt;<i> +                       IntPtr r = sys_signal (signum, handler);
</I>&gt;<i>                         if (r == _SIG_ERR)
</I>&gt;<i>                                 return -1;
</I>&gt;<i>                         return 0;
</I>&gt;<i> @@ -530,10 +540,14 @@
</I>&gt;<i>                 [CLSCompliant (false)]
</I>&gt;<i>                 public static int raise (Signum sig)
</I>&gt;<i>                 {
</I>&gt;<i> -                       int _sig = NativeConvert.FromSignum (sig);
</I>&gt;<i> -                       return sys_raise (_sig);
</I>&gt;<i> +                       return sys_raise(NativeConvert.FromSignum(sig));
</I>
&#65279;Missing space before opening parenthesis.

&gt;<i>                 }
</I>&gt;<i>  
</I>&gt;<i> +               public static int raise(RealTimeSignum rts)
</I>&gt;<i> +               {
</I>&gt;<i> +                       return sys_raise(NativeConvert.FromRealTimeSignum(rts));
</I>
&#65279;Missing space before opening parenthesis (2x).

&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i>                 //
</I>&gt;<i>                 // &lt;stdio.h&gt; -- COMPLETE except for :
</I>&gt;<i>                 //    - the scanf(3) family .
</I>&gt;<i> Index: class/Mono.Posix/Mono.Unix.Native/RealTimeSignum.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- class/Mono.Posix/Mono.Unix.Native/RealTimeSignum.cs (revision 0)
</I>&gt;<i> +++ class/Mono.Posix/Mono.Unix.Native/RealTimeSignum.cs (revision 0)
</I>&gt;<i> @@ -0,0 +1,83 @@
</I>&gt;<i> +//
</I>&gt;<i> +// Authors:
</I>&gt;<i> +//   Tim Jenks (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">tim.jenks at realtimeworlds.com</A>)
</I>&gt;<i> +//
</I>&gt;<i> +// (C) 2008 Realtime Worlds Ltd
</I>&gt;<i> +//
</I>&gt;<i> +// Permission is hereby granted, free of charge, to any person obtaining
</I>&gt;<i> +// a copy of this software and associated documentation files (the
</I>&gt;<i> +// &quot;Software&quot;), to deal in the Software without restriction, including
</I>&gt;<i> +// without limitation the rights to use, copy, modify, merge, publish,
</I>&gt;<i> +// distribute, sublicense, and/or sell copies of the Software, and to
</I>&gt;<i> +// permit persons to whom the Software is furnished to do so, subject to
</I>&gt;<i> +// the following conditions:
</I>&gt;<i> +//
</I>&gt;<i> +// The above copyright notice and this permission notice shall be
</I>&gt;<i> +// included in all copies or substantial portions of the Software.
</I>&gt;<i> +//
</I>&gt;<i> +// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
</I>&gt;<i> +// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
</I>&gt;<i> +// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
</I>&gt;<i> +// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
</I>&gt;<i> +// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
</I>&gt;<i> +// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
</I>&gt;<i> +// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</I>&gt;<i> +//
</I>&gt;<i> +
</I>&gt;<i> +using System;
</I>&gt;<i> +using System.Runtime.InteropServices;
</I>&gt;<i> +using System.Threading;
</I>&gt;<i> +
</I>&gt;<i> +namespace Mono.Unix.Native {
</I>&gt;<i> +
</I>&gt;<i> +       public struct RealTimeSignum
</I>&gt;<i> +#if NET_2_0
</I>&gt;<i> +               : IEquatable &lt;RealTimeSignum&gt;
</I>&gt;<i> +#endif
</I>&gt;<i> +       {
</I>&gt;<i> +               private int rt_offset;
</I>&gt;<i> +               private static readonly int MaxOffset = UnixSignal.GetSIGRTMAX()-UnixSignal.GetSIGRTMIN()-1;
</I>&gt;<i> +               public static readonly RealTimeSignum MinValue = new RealTimeSignum(0);
</I>&gt;<i> +               public static readonly RealTimeSignum MaxValue = new RealTimeSignum(MaxOffset);
</I>
&#65279;Missing space before opening parenthesis.

Offhand, does C# guarantee the order of initialization of members?  I
don't remember, and if the order isn't guaranteed then we'll need to use
a static constructor to ensure that MaxOffset is set before setting
MaxValue.

&gt;<i> +               public RealTimeSignum(int offset)
</I>
&#65279;Missing space before opening parenthesis.

&gt;<i> +               {
</I>&gt;<i> +                       if (offset &lt; 0)
</I>&gt;<i> +                               throw new ArgumentOutOfRangeException(&quot;Offset cannot be negative&quot;);
</I>
&#65279;Missing space before opening parenthesis.

&gt;<i> +                       if (offset &gt; MaxOffset)
</I>&gt;<i> +                               throw new ArgumentOutOfRangeException(&quot;Offset greater than maximum supported SIGRT&quot;);
</I>
&#65279;Missing space before opening parenthesis.

&gt;<i> +                       rt_offset = offset;
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               public int Offset {
</I>&gt;<i> +                       get { return rt_offset; }
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               public override int GetHashCode()
</I>
&#65279;Missing space before opening parenthesis.

I'll stop mentioning these, but there are lots of such spots...

&gt;<i> +               {
</I>&gt;<i> +                       return rt_offset.GetHashCode();
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               public override bool Equals(object obj)
</I>&gt;<i> +               {
</I>&gt;<i> +                       if ((obj == null) || (obj.GetType() != GetType()))
</I>&gt;<i> +                               return false;
</I>&gt;<i> +                       return Equals((RealTimeSignum)obj);
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               public bool Equals(RealTimeSignum value)
</I>&gt;<i> +               {
</I>&gt;<i> +                       return Offset == value.Offset;
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               public static bool operator==(RealTimeSignum lhs, RealTimeSignum rhs)
</I>&gt;<i> +               {
</I>&gt;<i> +                       return lhs.Equals(rhs);
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               public static bool operator!=(RealTimeSignum lhs, RealTimeSignum rhs)
</I>&gt;<i> +               {
</I>&gt;<i> +                       return !lhs.Equals(rhs);
</I>&gt;<i> +               }
</I>&gt;<i> +       }
</I>&gt;<i> +}
</I>&gt;<i> Index: class/Mono.Posix/Mono.Unix.Native/NativeConvert.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- class/Mono.Posix/Mono.Unix.Native/NativeConvert.cs  (revision 121281)
</I>&gt;<i> +++ class/Mono.Posix/Mono.Unix.Native/NativeConvert.cs  (working copy)
</I>&gt;<i> @@ -18,6 +18,24 @@
</I>&gt;<i>                 // Non-generated exports
</I>&gt;<i>                 //
</I>&gt;<i>  
</I>&gt;<i> +               [DllImport (LIB, EntryPoint=&quot;Mono_Posix_FromRealTimeSignum&quot;)]
</I>&gt;<i> +               private static extern int FromRealTimeSignum(Int32 offset, out Int32 rval);
</I>&gt;<i> +
</I>&gt;<i> +               // convert a realtime signal to os signal
</I>&gt;<i> +               public static int FromRealTimeSignum(RealTimeSignum sig)
</I>&gt;<i> +               {
</I>&gt;<i> +                       int sigNum;
</I>&gt;<i> +                       if (FromRealTimeSignum(sig.Offset, out sigNum) == -1)
</I>&gt;<i> +                               ThrowArgumentException(sig.Offset);
</I>&gt;<i> +                       return sigNum;
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               // convert an offset to an rt signum
</I>&gt;<i> +               public static RealTimeSignum ToRealTimeSignum(int offset)
</I>&gt;<i> +               {
</I>&gt;<i> +                       return new RealTimeSignum(offset);
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i>                 // convert from octal representation.
</I>&gt;<i>                 public static FilePermissions FromOctalPermissionString (string value)
</I>&gt;<i>                 {
</I>&gt;<i> Index: class/Mono.Posix/Test/Mono.Unix.Native/RealTimeSignumTests.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- class/Mono.Posix/Test/Mono.Unix.Native/RealTimeSignumTests.cs       (revision 0)
</I>&gt;<i> +++ class/Mono.Posix/Test/Mono.Unix.Native/RealTimeSignumTests.cs       (revision 0)
</I>&gt;<i> @@ -0,0 +1,180 @@
</I>&gt;<i> +//
</I>&gt;<i> +// RealTimeSignumTests.cs - NUnit Test Cases for Mono.Unix.Native.RealTimeSignum
</I>&gt;<i> +//
</I>&gt;<i> +// Authors:
</I>&gt;<i> +//     Tim Jenks  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">tim.jenks at realtimeworlds.com</A>&gt;
</I>&gt;<i> +//
</I>&gt;<i> +// (C) 2008 Realtime Worlds Ltd
</I>&gt;<i> +//
</I>&gt;<i> +
</I>&gt;<i> +using NUnit.Framework;
</I>&gt;<i> +using NUnit.Framework.SyntaxHelpers;
</I>&gt;<i> +using System;
</I>&gt;<i> +using System.Text;
</I>&gt;<i> +using System.Threading;
</I>&gt;<i> +using Mono.Unix;
</I>&gt;<i> +using Mono.Unix.Native;
</I>&gt;<i> +
</I>&gt;<i> +namespace MonoTests.Mono.Unix.Native {
</I>&gt;<i> +
</I>&gt;<i> +       [TestFixture]
</I>&gt;<i> +       public class RealTimeSignumTest 
</I>&gt;<i> +       {
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestRealTimeCstor()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts = new RealTimeSignum(0);
</I>&gt;<i> +                       using (UnixSignal s = new UnixSignal(rts))
</I>&gt;<i> +                       {
</I>&gt;<i> +                               Assert.That(s.IsRealTimeSignal);
</I>&gt;<i> +                               Assert.That(s.RealTimeSignum, Is.EqualTo(rts));
</I>&gt;<i> +                       }
</I>
This is really testing the UnixSignal constructor, so move this test
into UnixSignalTest.

&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               [ExpectedException(typeof(ArgumentOutOfRangeException))]
</I>&gt;<i> +               public void TestRealTimeOutOfRange()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts = new RealTimeSignum(int.MaxValue);
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>
CreateWaitSignalThread() and MultiThreadTest() should be moved to
UnixSignalTest.

&gt;<i> +               // helper method to create a thread waiting on a UnixSignal
</I>&gt;<i> +               static Thread CreateWaitSignalThread(UnixSignal signal, int timeout)
</I>&gt;<i> +               {
</I>&gt;<i> +                       Thread t1 = new Thread(delegate() {
</I>&gt;<i> +                                               DateTime start = DateTime.Now;
</I>&gt;<i> +                                               bool r = signal.WaitOne (timeout, false);
</I>&gt;<i> +                                               DateTime end = DateTime.Now;
</I>&gt;<i> +                                               Assert.AreEqual (signal.Count, 1);
</I>&gt;<i> +                                               Assert.AreEqual (r, true);
</I>&gt;<i> +                                               if ((end - start) &gt; new TimeSpan (0, 0, timeout/1000))
</I>&gt;<i> +                                                       throw new InvalidOperationException (&quot;Signal slept too long&quot;);
</I>&gt;<i> +                                       });
</I>&gt;<i> +                       return t1;
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               // helper method to create a two-thread test
</I>&gt;<i> +               static void MultiThreadTest(UnixSignal signal, int timeout, ThreadStart tstart)
</I>&gt;<i> +               {
</I>&gt;<i> +                       Thread t1 = CreateWaitSignalThread(signal, timeout);
</I>&gt;<i> +                       Thread t2 = new Thread(tstart);
</I>&gt;<i> +                       t1.Start();
</I>&gt;<i> +                       t2.Start();
</I>&gt;<i> +                       t1.Join();
</I>&gt;<i> +                       t2.Join();
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               [ExpectedException(typeof(ArgumentOutOfRangeException))]
</I>&gt;<i> +               public void TestRealTimeSignumNegativeOffset()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts1 = new RealTimeSignum(-1);
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestRTSignalEquality()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts1 = new RealTimeSignum(0);
</I>&gt;<i> +                       RealTimeSignum rts2 = new RealTimeSignum(0);
</I>&gt;<i> +                       Assert.That(rts1 == rts2, Is.True);
</I>&gt;<i> +                       Assert.That(rts1 != rts2, Is.False);
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestRTSignalInequality()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts1 = new RealTimeSignum(0);
</I>&gt;<i> +                       RealTimeSignum rts2 = new RealTimeSignum(1);
</I>&gt;<i> +                       Assert.That(rts1 == rts2, Is.False);
</I>&gt;<i> +                       Assert.That(rts1 != rts2, Is.True);
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestRTSignalGetHashCodeEquality()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts1 = new RealTimeSignum(0);
</I>&gt;<i> +                       RealTimeSignum rts2 = new RealTimeSignum(0);
</I>&gt;<i> +                       Assert.That(rts1.GetHashCode(), Is.EqualTo(rts2.GetHashCode()));
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestRTSignalGetHashCodeInequality()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts1 = new RealTimeSignum(0);
</I>&gt;<i> +                       RealTimeSignum rts2 = new RealTimeSignum(1);
</I>&gt;<i> +                       Assert.That(rts1.GetHashCode(), Is.Not.EqualTo(rts2.GetHashCode()));
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestIsRTSignalPropertyForRTSignum()
</I>&gt;<i> +               {
</I>&gt;<i> +                       UnixSignal signal1 = new UnixSignal(new RealTimeSignum(0));
</I>&gt;<i> +                       Assert.That(signal1.IsRealTimeSignal, Is.True);
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestIsRTSignalPropertyForSignum()
</I>&gt;<i> +               {
</I>&gt;<i> +                       UnixSignal signal1 = new UnixSignal(Signum.SIGSEGV);
</I>&gt;<i> +                       Assert.That(signal1.IsRealTimeSignal, Is.False);
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestSignumProperty()
</I>&gt;<i> +               {
</I>&gt;<i> +                       UnixSignal signal1 = new UnixSignal(Signum.SIGSEGV);
</I>&gt;<i> +                       Assert.That(signal1.Signum, Is.EqualTo(Signum.SIGSEGV));
</I>&gt;<i> +               }
</I>&gt;<i> +       
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               [ExpectedException]
</I>&gt;<i> +               public void TestSignumPropertyThrows()
</I>&gt;<i> +               {
</I>&gt;<i> +                       UnixSignal signal1 = new UnixSignal(new RealTimeSignum(0));
</I>&gt;<i> +                       Signum s = signal1.Signum;
</I>
This should be in UnixSignalTest.

&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestRealTimeSignumProperty()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts = new RealTimeSignum(0);
</I>&gt;<i> +                       UnixSignal signal1 = new UnixSignal(rts);
</I>&gt;<i> +                       Assert.That(signal1.RealTimeSignum, Is.EqualTo(rts));
</I>
&#65279;This should be in UnixSignalTest.

&gt;<i> +               }
</I>&gt;<i> +       
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               [ExpectedException]
</I>&gt;<i> +               public void TestRealTimePropertyThrows()
</I>&gt;<i> +               {
</I>&gt;<i> +                       UnixSignal signal1 = new UnixSignal(Signum.SIGSEGV);
</I>&gt;<i> +                       RealTimeSignum s = signal1.RealTimeSignum;
</I>
&#65279;This should be in UnixSignalTest.

&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestRaiseRTMINSignal()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts = new RealTimeSignum(0);
</I>&gt;<i> +                       using (UnixSignal signal = new UnixSignal(rts))
</I>&gt;<i> +                       {
</I>&gt;<i> +                               MultiThreadTest(signal, 5000, delegate() {
</I>&gt;<i> +                                       Thread.Sleep(1000);
</I>&gt;<i> +                                       Stdlib.raise(rts);
</I>&gt;<i> +                                       });
</I>
&#65279;This should be in UnixSignalTest.

&gt;<i> +                       }
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               [Test]
</I>&gt;<i> +               public void TestRaiseRTMINPlusOneSignal()
</I>&gt;<i> +               {
</I>&gt;<i> +                       RealTimeSignum rts = new RealTimeSignum(1);
</I>&gt;<i> +                       using (UnixSignal signal = new UnixSignal(rts))
</I>&gt;<i> +                       {
</I>&gt;<i> +                               MultiThreadTest(signal, 5000, delegate() {
</I>&gt;<i> +                                       Thread.Sleep(1000);
</I>&gt;<i> +                                       Stdlib.raise(rts);
</I>&gt;<i> +                                       });
</I>
&#65279;This should be in UnixSignalTest.

&gt;<i> +                       }
</I>&gt;<i> +               }
</I>&gt;<i> +       }
</I>&gt;<i> +}
</I>&gt;<i> Index: class/Mono.Posix/Mono.Posix_test.dll.sources
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- class/Mono.Posix/Mono.Posix_test.dll.sources        (revision 121281)
</I>&gt;<i> +++ class/Mono.Posix/Mono.Posix_test.dll.sources        (working copy)
</I>&gt;<i> @@ -5,4 +5,5 @@
</I>&gt;<i>  Mono.Unix/UnixPathTest.cs
</I>&gt;<i>  Mono.Unix/UnixSignalTest.cs
</I>&gt;<i>  Mono.Unix/UnixUserTest.cs
</I>&gt;<i> +Mono.Unix.Native/RealTimeSignumTests.cs
</I>&gt;<i>  Mono.Unix.Native/StdlibTest.cs
</I>&gt;<i> Index: class/Mono.Posix/Mono.Posix.dll.sources
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- class/Mono.Posix/Mono.Posix.dll.sources     (revision 121281)
</I>&gt;<i> +++ class/Mono.Posix/Mono.Posix.dll.sources     (working copy)
</I>&gt;<i> @@ -34,6 +34,7 @@
</I>&gt;<i>  ./Mono.Unix.Native/MapAttribute.cs
</I>&gt;<i>  ./Mono.Unix.Native/NativeConvert.cs
</I>&gt;<i>  ./Mono.Unix.Native/NativeConvert.generated.cs
</I>&gt;<i> +./Mono.Unix.Native/RealTimeSignum.cs
</I>&gt;<i>  ./Mono.Unix.Native/Stdlib.cs
</I>&gt;<i>  ./Mono.Unix.Native/Syscall.cs
</I>&gt;<i>  ./Mono.Unix.Native/TypeAttributes.cs
</I>&gt;<i> Index: class/Mono.Posix/Mono.Unix/UnixSignal.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- class/Mono.Posix/Mono.Unix/UnixSignal.cs    (revision 121281)
</I>&gt;<i> +++ class/Mono.Posix/Mono.Unix/UnixSignal.cs    (working copy)
</I>&gt;<i> @@ -3,6 +3,7 @@
</I>&gt;<i>  //
</I>&gt;<i>  // Authors:
</I>&gt;<i>  //   Jonathan Pryor (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">jpryor at novell.com</A>)
</I>&gt;<i> +//   Tim Jenks (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">tim.jenks at realtimeworlds.com</A>)
</I>&gt;<i>  //
</I>&gt;<i>  // (C) 2008 Novell, Inc.
</I>&gt;<i>  //
</I>&gt;<i> @@ -33,28 +34,55 @@
</I>&gt;<i>  using Mono.Unix.Native;
</I>&gt;<i>  
</I>&gt;<i>  namespace Mono.Unix {
</I>&gt;<i> +
</I>&gt;<i>         public class UnixSignal : WaitHandle {
</I>&gt;<i> -               private Signum signum;
</I>&gt;<i> +               private int signum;
</I>&gt;<i>                 private IntPtr signal_info;
</I>&gt;<i>  
</I>&gt;<i>                 public UnixSignal (Signum signum)
</I>&gt;<i>                 {
</I>&gt;<i> -                       this.signum = signum;
</I>&gt;<i> -                       // ensure signum is a valid signal
</I>&gt;<i> -                       int _signum = NativeConvert.FromSignum (signum);
</I>&gt;<i> -                       this.signal_info = install (_signum);
</I>&gt;<i> +                       this.signum = NativeConvert.FromSignum(signum);
</I>&gt;<i> +                       this.signal_info = install(this.signum);
</I>&gt;<i>                         if (this.signal_info == IntPtr.Zero) {
</I>&gt;<i> -                               throw new ArgumentException (&quot;Unable to handle signal&quot;, &quot;signum&quot;);
</I>&gt;<i> +                               throw new ArgumentException(&quot;Unable to handle signal&quot;, &quot;signum&quot;);
</I>&gt;<i>                         }
</I>&gt;<i>                 }
</I>&gt;<i>  
</I>&gt;<i> +               public UnixSignal (Mono.Unix.Native.RealTimeSignum rtsig)
</I>&gt;<i> +               {
</I>&gt;<i> +                       signum = NativeConvert.FromRealTimeSignum(rtsig);
</I>&gt;<i> +                        this.signal_info = install(this.signum);
</I>
Why is there a space before `this' on this line?

&gt;<i> +                       if (this.signal_info == IntPtr.Zero) {
</I>&gt;<i> +                               throw new ArgumentException(&quot;Unable to handle signal&quot;, &quot;signum&quot;);
</I>&gt;<i> +                       }
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i>                 public Signum Signum {
</I>&gt;<i>                         get {
</I>&gt;<i> +                               if (IsRealTimeSignal)
</I>&gt;<i> +                                       throw new InvalidOperationException(&quot;This signal is a RealTimeSignum&quot;);
</I>&gt;<i>                                 AssertValid ();
</I>
Remove the AssertValid call, and add it to IsRealTimeSignal.

&gt;<i> -                               return signum; 
</I>&gt;<i> +                               return NativeConvert.ToSignum(signum); 
</I>&gt;<i>                         }
</I>&gt;<i>                 }
</I>&gt;<i>  
</I>&gt;<i> +               public RealTimeSignum RealTimeSignum {
</I>&gt;<i> +                       get {
</I>&gt;<i> +                               if (!IsRealTimeSignal)
</I>&gt;<i> +                                       throw new InvalidOperationException(&quot;This signal is not a RealTimeSignum&quot;);
</I>&gt;<i> +                               return NativeConvert.ToRealTimeSignum(signum-GetSIGRTMIN());
</I>&gt;<i> +                       }
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i> +               public bool IsRealTimeSignal {
</I>&gt;<i> +                       get {
</I>
Add an AssertValid(); call here.

&gt;<i> +                               int sigrtmin = GetSIGRTMIN();
</I>&gt;<i> +                               if (sigrtmin == -1)
</I>&gt;<i> +                                       return false;
</I>&gt;<i> +                               return signum &gt;= sigrtmin;
</I>&gt;<i> +                       }
</I>&gt;<i> +               }
</I>&gt;<i> +
</I>&gt;<i>                 [DllImport (Stdlib.MPH, CallingConvention=CallingConvention.Cdecl,
</I>&gt;<i>                                 EntryPoint=&quot;Mono_Unix_UnixSignal_install&quot;)]
</I>&gt;<i>                 private static extern IntPtr install (int signum);
</I>&gt;<i> @@ -67,6 +95,14 @@
</I>&gt;<i>                                 EntryPoint=&quot;Mono_Unix_UnixSignal_WaitAny&quot;)]
</I>&gt;<i>                 private static extern int WaitAny (IntPtr[] infos, int count, int timeout);
</I>&gt;<i>  
</I>&gt;<i> +               [DllImport (Stdlib.MPH, CallingConvention=CallingConvention.Cdecl,
</I>&gt;<i> +                                EntryPoint=&quot;Mono_Posix_SIGRTMIN&quot;)]
</I>&gt;<i> +               internal static extern int GetSIGRTMIN();
</I>&gt;<i> +
</I>&gt;<i> +               [DllImport (Stdlib.MPH, CallingConvention=CallingConvention.Cdecl,
</I>&gt;<i> +                                EntryPoint=&quot;Mono_Posix_SIGRTMAX&quot;)]
</I>&gt;<i> +               internal static extern int GetSIGRTMAX();
</I>&gt;<i> +
</I>&gt;<i>                 private void AssertValid ()
</I>&gt;<i>                 {
</I>&gt;<i>                         if (signal_info == IntPtr.Zero)
</I>&gt;<i> 
</I>
</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030232.html">[Mono-dev] FW: RealTimeSignal patch
</A></li>
	<LI>Next message: <A HREF="030269.html">[Mono-dev] FW: RealTimeSignal patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30239">[ date ]</a>
              <a href="thread.html#30239">[ thread ]</a>
              <a href="subject.html#30239">[ subject ]</a>
              <a href="author.html#30239">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
