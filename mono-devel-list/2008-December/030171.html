<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] JIT: MonoReg to replace gssize for registers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20JIT%3A%20MonoReg%20to%20replace%20gssize%20for%20registers&In-Reply-To=67BF5790-2888-4F67-9749-FCC5BC0BE9FA%40web.de">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030170.html">
   <LINK REL="Next"  HREF="030178.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] JIT: MonoReg to replace gssize for registers</H1>
    <B>Mark Mason</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20JIT%3A%20MonoReg%20to%20replace%20gssize%20for%20registers&In-Reply-To=67BF5790-2888-4F67-9749-FCC5BC0BE9FA%40web.de"
       TITLE="[Mono-dev] JIT: MonoReg to replace gssize for registers">mmason at upwardaccess.com
       </A><BR>
    <I>Sat Dec 13 16:12:31 EST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="030170.html">[Mono-dev] JIT: MonoReg to replace gssize for registers
</A></li>
        <LI>Next message: <A HREF="030178.html">[Mono-dev] JIT: MonoReg to replace gssize for registers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30171">[ date ]</a>
              <a href="thread.html#30171">[ thread ]</a>
              <a href="subject.html#30171">[ subject ]</a>
              <a href="author.html#30171">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

Yes. Sparcv9 had something similar as well - at least on a few  
embedded systems (I did the VxWorks port for that ABI, and some of the  
gcc work - ages ago now).

The mips/n32 ABI is growing in popularity, both in the embedded space  
and at the higher end (As I understand it, the SiCortex systems are  
n32). It's higher performance, and it allows the compiler to take  
advantage of the 64-bit register file and ALU without having to port  
the code to a full 64-bit API (w/ 64 bit pointers and such). Even code  
that doesn't generally use 64-bit ints will run faster due to the  
changes in the calling convention[*]. Most (embedded) systems don't  
need the extended addressing of 64-bits, but if they're on a MIPS64  
device they want access to the full 64-bit ALU and register set (yes,  
there are some embedded systems that would like pointers to be 64-bit,  
but they're few in number so far).

So, n32 is a generally useful middle ground between the strict 32-bit  
ABI (o32) and the full 64-bit ABI (n64) - probably more so than SPE is  
for ppc. That last bit is speculation on my part, as ppc is one of the  
modern instruction sets I'm less than familiar with. This is despite  
the fact that a lot of the MIPS JIT for Mono was written by reverse  
engineering the PPC port ;).

Andreas - the way I'm handling the code generation differences on MIPS  
is through a set of macros (basically pseudo-ops) that either produce  
the 32 or 64-bit versions of opcodes depending on which ABI we're  
compiling for. It's the same basic technique that's been in use on  
MIPS for writing ABI independent assembly code since the first 64-bit  
MIPS chips were introduced (back around '90 or so). It requires  
keeping a bit more context in your head when reading/writing the code,  
but it keeps from polluting the mini-mips.c file with a lot of extra  
#ifdef tests.

The main thing I'm working through right now is finding and fixing a  
few of the macros in ir-emit.h to keep them 'doing the right thing'  
without warnings when inst_p0 and inst_p1 are MonoReg (an integral  
type) rather than a gpointer. Due to the way that OP_PCONST and a few  
other opcodes are handled, there's an assumption that inst_p* and  
inst_c* are type punned through the union. It's close to working, and  
I'm trying to keep the changes as small as possible. There's probably  
another day or two of spare-time work on it before I'm ready to post  
it for review.

/Mark

[*] the trade off is that on o64, n32 and n64 stack slots are 64-bits  
- which means that for any given call stack you tend to burn through  
your D-cache faster. On the plus side, n32 and n64 (1) provide for  
passing the first 8 arguments in registers (instead of the first  
four), and (2) doesn't require the caller allocating backing space in  
the stack frame for register arguments (which cuts down on the stack  
footprint and gets you back some of the performance loss due to the  
larger stack slots). The o32-&gt;o64 transition however tends to cost  
~5-7% in performance for otherwise 32-bit code because you're still  
limited to 4 arguments in registers and backing stack slots allocated  
by the caller. I don't suggest we support o64 - it was never an  
official ABI, never was supported under Linux and is in the process of  
being phased out from the embedded systems that supported in (in favor  
of n32).

On Dec 13, 2008, at 12:27 PM, Andreas F&#228;rber wrote:

&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i> On ppc there is a similar feature, SPE, which allows some 64-bit ops  
</I>&gt;<i> on a 32-bit machine.
</I>&gt;<i>
</I>&gt;<i> There, the general-purpose registers appear to be all 64-bit but  
</I>&gt;<i> regular instructions only access the lower 32 bits. Special  
</I>&gt;<i> instructions are used to access full 64-bit registers, similar to  
</I>&gt;<i> Altivec instructions using (separate) 128-bit registers on an  
</I>&gt;<i> otherwise 32- or 64-bit system.
</I>&gt;<i>
</I>&gt;<i> From that point of view, technically the MonoReg distinction makes  
</I>&gt;<i> sense, to allow sizeof(MonoReg) &gt;= sizeof(gssize).
</I>&gt;<i>
</I>&gt;<i> But as pointed out below, changing the variable type is only a  
</I>&gt;<i> start. Should anyone want to make Mono use SPE on ppc, probably all  
</I>&gt;<i> places that save and restore registers would need to be reworked,  
</I>&gt;<i> introducing a special code path for those systems that support it.  
</I>&gt;<i> The only Mono feature benefitting would probably be System.Int64, so  
</I>&gt;<i> I'm not sure if this is really needed.
</I>&gt;<i>
</I>&gt;<i> Andreas
</I>&gt;<i>
</I>&gt;<i> Am 13.12.2008 um 19:55 schrieb Mark Mason:
</I>&gt;<i>
</I>&gt;&gt;<i> Hello,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Not ... necessarily.  The mips/n32 abi is one example.  Code runs  
</I>&gt;&gt;<i> in a
</I>&gt;&gt;<i> 32-bit address space (so pointers, and sizeof(void *) are 32-bits),
</I>&gt;&gt;<i> but with 64-bit registers and 64-bit operations available.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> This is distinct from n64, which does have 64-bit pointers.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> /Mark
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Dec 13, 2008, at 7:01 AM, Zoltan Varga wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Hi,
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> gssize is the size needed to hold a memory address, if the machine
</I>&gt;&gt;&gt;<i> has 64 bit registers,
</I>&gt;&gt;&gt;<i> this is 64 bits. On that mips machine, this is 32 bits ?
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>                Zoltan
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On Thu, Dec 11, 2008 at 8:40 PM, Mark Mason
</I>&gt;&gt;&gt;<i> &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mmason at upwardaccess.com</A>&gt; wrote:
</I>&gt;&gt;&gt;&gt;<i> Hello all,
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Along the same lines as the SIZEOF_VOID_P change, I'd like to offer
</I>&gt;&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;&gt;<i> following new type to replace to use of 'gssize' when referring  
</I>&gt;&gt;&gt;&gt;<i> to a
</I>&gt;&gt;&gt;&gt;<i> machine register. 'gssize' comes from glib, and simply represents  
</I>&gt;&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;&gt;<i> size of an integer -- which is not necessarily always the same as  
</I>&gt;&gt;&gt;&gt;<i> the
</I>&gt;&gt;&gt;&gt;<i> size of the underlying integer registers.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> There are some other uses of gssize in mini/ that will need to be
</I>&gt;&gt;&gt;&gt;<i> updated as well, but this is a start.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Comments most welcome.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Thanks in advance,
</I>&gt;&gt;&gt;&gt;<i> Mark
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Index: mini.h
</I>&gt;&gt;&gt;&gt;<i> ===================================================================
</I>&gt;&gt;&gt;&gt;<i> --- mini.h      (revision 121269)
</I>&gt;&gt;&gt;&gt;<i> +++ mini.h      (working copy)
</I>&gt;&gt;&gt;&gt;<i> @@ -400,6 +400,13 @@
</I>&gt;&gt;&gt;&gt;<i>     int size, align;
</I>&gt;&gt;&gt;&gt;<i> } MonoMemcpyArgs;
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> +/* C type matching the size of a machine register. Not always the
</I>&gt;&gt;&gt;&gt;<i> same
</I>&gt;&gt;&gt;&gt;<i> as 'int' */
</I>&gt;&gt;&gt;&gt;<i> +#if SIZEOF_REGISTER == 4
</I>&gt;&gt;&gt;&gt;<i> +typedef gint32 MonoReg;
</I>&gt;&gt;&gt;&gt;<i> +#elif SIZEOF_REGISTER == 8
</I>&gt;&gt;&gt;&gt;<i> +typedef gint64 MonoReg;
</I>&gt;&gt;&gt;&gt;<i> +#endif
</I>&gt;&gt;&gt;&gt;<i> +
</I>&gt;&gt;&gt;&gt;<i> struct MonoInst {
</I>&gt;&gt;&gt;&gt;<i>     guint16 opcode;
</I>&gt;&gt;&gt;&gt;<i>     guint8  type; /* stack type */
</I>&gt;&gt;&gt;&gt;<i> @@ -415,7 +422,7 @@
</I>&gt;&gt;&gt;&gt;<i>             union {
</I>&gt;&gt;&gt;&gt;<i>                     MonoInst *src;
</I>&gt;&gt;&gt;&gt;<i>                     MonoMethodVar *var;
</I>&gt;&gt;&gt;&gt;<i> -                       gssize const_val;
</I>&gt;&gt;&gt;&gt;<i> +                       MonoReg const_val;
</I>&gt;&gt;&gt;&gt;<i>                     gpointer p;
</I>&gt;&gt;&gt;&gt;<i>                     MonoMethod *method;
</I>&gt;&gt;&gt;&gt;<i>                     MonoMethodSignature *signature;
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>
</PRE>





















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030170.html">[Mono-dev] JIT: MonoReg to replace gssize for registers
</A></li>
	<LI>Next message: <A HREF="030178.html">[Mono-dev] JIT: MonoReg to replace gssize for registers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30171">[ date ]</a>
              <a href="thread.html#30171">[ thread ]</a>
              <a href="subject.html#30171">[ subject ]</a>
              <a href="author.html#30171">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
