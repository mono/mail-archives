<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-dev] Unmanaged Component Interop in Mono
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Unmanaged%20Component%20Interop%20in%20Mono&In-Reply-To=BDBFCADE470D2B4A841D51412D2D915D03FE5572%40canonsburgexch2.win.ansys.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017736.html">
   <LINK REL="Next"  HREF="017737.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-dev] Unmanaged Component Interop in Mono</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-dev%5D%20Unmanaged%20Component%20Interop%20in%20Mono&In-Reply-To=BDBFCADE470D2B4A841D51412D2D915D03FE5572%40canonsburgexch2.win.ansys.com"
       TITLE="[Mono-dev] Unmanaged Component Interop in Mono">lupus at ximian.com
       </A><BR>
    <I>Mon Mar 27 08:06:49 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="017736.html">[Mono-dev] Unmanaged Component Interop in Mono
</A></li>
        <LI>Next message: <A HREF="017737.html">[Mono-dev] _wapi_handle_update_refs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17796">[ date ]</a>
              <a href="thread.html#17796">[ thread ]</a>
              <a href="subject.html#17796">[ subject ]</a>
              <a href="author.html#17796">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/23/06 Jonathan S. Chambers wrote:
&gt;<i> So, this additional attribute takes a type that specifies the manager
</I>&gt;<i> for this type of component. If we don't find this attribute we assume
</I>&gt;<i> normal COM Interop, else we use this manager. At this point, the manager
</I>&gt;<i> has a very simple role. It has to implement the methods on the class
</I>&gt;<i> (it would probably also store a lot of utility methods). Right now
</I>&gt;<i> in the runtime, I handle ComImport objects specially. When a method
</I>&gt;<i> needs implemented, I emit the wrapper code needed to call the unmanaged
</I>&gt;<i> object. My proposal is to move this to managed, and allow the various
</I>&gt;<i> component managers to emit this code.
</I>&gt;<i> 
</I>&gt;<i> If I look at my changes to the runtime, I only really need 2/3 hooks in
</I>&gt;<i> there; the rest of the code could be managed. The UNO work uses objects
</I>&gt;<i> derived from MarshalByRef object and works via a proxy; they handle
</I>&gt;<i> the method calls in the Invoke method via messages. This is very close
</I>&gt;<i> to what I'm proposing except remove the Message layer for performance
</I>&gt;<i> reasons. Give people a hook to directly emit code for the methods,
</I>&gt;<i> rather than having to handle a message.
</I>&gt;<i> 
</I>&gt;<i> So, the manager object has a method that takes a method info and
</I>&gt;<i> returns the emitted method. The is pretty much possible right now using
</I>&gt;<i> the DynamicMethod class (or we could create a very simlar class in the
</I>&gt;<i> component namespace). So, when the FastMethod class is created, the .ctor
</I>
DynamicMethod won't be duplicated, it may only be enhanced if needed
with some internal functions.

&gt;<i> code is emitted by the manager. The manager emits code for the constructor
</I>&gt;<i> to create the unmanaged object and store it. Subsequent method calls are
</I>&gt;<i> similarly resolved by the manager emitting code to invoke the methods on
</I>&gt;<i> the underlying unmanaged objects. Deriving from MarshalByRef object and
</I>&gt;<i> using a proxy object is what allows for 'late' casting (allow casting
</I>&gt;<i> to succeed depending on a QueryInterface call). We could continue to use
</I>&gt;<i> this method, or provide another hook for casting calls. If they succeed
</I>&gt;<i> the methods would again be dynamically emitted by the manager.
</I>
The JIT must know about the cast or it can't be done efficiently.

&gt;<i> In short, this gets a lot of component interop code out of the
</I>&gt;<i> runtime. It also opens up a way for mono to support a variety of component
</I>&gt;<i> systems without people having to modify the runtime.
</I>
I'm all for having code written on the managed side when it makes
sense, but just moving code to managed is not going to make it better as
the last review of the COM support showed. I guess we'd need to see how
the code looks like.
I suggest first completing the COM support so it can be put in svn and
then taking a look at how we can better integrate also other object
systems.

Thanks.

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">lupus at ximian.com</A>                             Monkeys do it better

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017736.html">[Mono-dev] Unmanaged Component Interop in Mono
</A></li>
	<LI>Next message: <A HREF="017737.html">[Mono-dev] _wapi_handle_update_refs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17796">[ date ]</a>
              <a href="thread.html#17796">[ thread ]</a>
              <a href="subject.html#17796">[ subject ]</a>
              <a href="author.html#17796">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
