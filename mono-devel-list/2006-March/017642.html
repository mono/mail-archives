<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> String performance boost (Re: [Mono-dev] Patch to boost	speedofUnicodeEncoding)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=String%20performance%20boost%20%28Re%3A%20%5BMono-dev%5D%20Patch%20to%20boost%0A%09speedofUnicodeEncoding%29&In-Reply-To=003801c649bd%248ffa7400%246464a8c0%40ansirua">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017629.html">
   <LINK REL="Next"  HREF="017643.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>String performance boost (Re: [Mono-dev] Patch to boost	speedofUnicodeEncoding)</H1>
    <B>Zac Bowling</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=String%20performance%20boost%20%28Re%3A%20%5BMono-dev%5D%20Patch%20to%20boost%0A%09speedofUnicodeEncoding%29&In-Reply-To=003801c649bd%248ffa7400%246464a8c0%40ansirua"
       TITLE="String performance boost (Re: [Mono-dev] Patch to boost	speedofUnicodeEncoding)">zac at zacbowling.com
       </A><BR>
    <I>Fri Mar 17 17:55:17 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="017629.html">String performance boost (Re: [Mono-dev] Patch to	boost	speedofUnicodeEncoding)
</A></li>
        <LI>Next message: <A HREF="017643.html">[Mono-dev] New (faster) Implementaiton for managed CharCopy
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17642">[ date ]</a>
              <a href="thread.html#17642">[ thread ]</a>
              <a href="subject.html#17642">[ subject ]</a>
              <a href="author.html#17642">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Yeah. Thats what I was thinking myself earlier until I ran though some tests.

I just setup a test where I would print the number of strings that stay 
below or go above 4096 chars while an app runs. Only about 1% of all 
the strings I tested ever get larger inside our own libraries 
(corelib/System.XML/etc) and also with some of the tests.

However when I tested some real world desktop apps (like a little 
winform notepad app I have) and some asp.net apps (asp.net forums was 
one big one), I was getting a lot of strings larger then that 4096 
chars. Nearly 15% of all the strings where that large in those apps. 
It's not an accurate number as many strings get copied and counted 
twice in some ways but it is safe to say we work with some large 
strings that slow us down a hair.

One big one I found though is with a library I have that was ran 
through some obfusticator. The obfusticator makes use of a few massive 
strings to store all the embedded strings in your code and runs through 
doing some really huge substrings on them to split out each of the 
smaller embedded strings around a ton of fake data in little chunks and 
then appends everything together, all at runtime. I think it's more the 
obfusticator's problem then anything since I don't think that would run 
nicely on any runtime.

Since string sizes can very so much for different applications, I think 
the best solution is to test where we start to hurt ourselves using 
each string method and each of its operatations (substring, copy, trim, 
etc) and find all the breaking points where each method gets slower 
(unmanaged vs managed, buffer.copyarray, memcpy coping in 16/8/4/2 
chunks etc..). Then we write in with some logic that decides which 
method to use based on the size of the string we are working on.

-- 
Zac Bowling
<A HREF="http://zacbowling.com/">http://zacbowling.com/</A>


----- Message from <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ClassDevelopment at A-SoftTech.com</A> ---------
    Date: Fri, 17 Mar 2006 13:23:11 +0100
    From: Andreas Nahr &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ClassDevelopment at A-SoftTech.com</A>&gt;
Reply-To: Andreas Nahr &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ClassDevelopment at A-SoftTech.com</A>&gt;
Subject: Re: String performance boost (Re: [Mono-dev] Patch to boost 
speedofUnicodeEncoding)
      To: Zac Bowling &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">zac at zacbowling.com</A>&gt;, <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>


&gt;<i> Basically this also were my findings back then (you can even see some 
</I>&gt;<i> functions where I did check if e.g. the length was &gt; 10000 and then 
</I>&gt;<i> did a fallback to native). (By the way: I believe in a huge number of 
</I>&gt;<i> real-world cases strings will be rather short)
</I>&gt;<i> Did you test using the current memcpy function? I think that it is 
</I>&gt;<i> possible to do something notably faster than this method. If you are 
</I>&gt;<i> using it just for copying chars I don't even think that these could 
</I>&gt;<i> possibly be 1 or 3 byte aligned (Well at least I can't think of any 
</I>&gt;<i> situation where they would be ;)
</I>&gt;<i> But as I wrote the optimum would likely be to replace this method 
</I>&gt;<i> with assembly on the most important platforms in the JIT.
</I>&gt;<i>
</I>&gt;<i> Another thing that I found back then is that running the managed 
</I>&gt;<i> implementations on MS .Net usually gave another significant speedup, 
</I>&gt;<i> so there is still potential for there as the mono runtime gets faster 
</I>&gt;<i> (Maybe better Register Allocator?) while the unmanaged versions are 
</I>&gt;<i> not likely to improve much.
</I>&gt;<i>
</I>&gt;<i> Also most of the implementations I wrote rely on inlining of the used 
</I>&gt;<i> Char Methodcalls or they will be notably slower than native.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ----- Original Message ----- From: &quot;Zac Bowling&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">zac at zacbowling.com</A>&gt;
</I>&gt;<i> To: &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">mono-devel-list at lists.ximian.com</A>&gt;
</I>&gt;<i> Sent: Friday, March 17, 2006 12:11 PM
</I>&gt;<i> Subject: Re: String performance boost (Re: [Mono-dev] Patch to boost 
</I>&gt;<i> speedofUnicodeEncoding)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Wow!!!
</I>&gt;<i>
</I>&gt;<i> I dispeared for a few days to work on this and came back to find I
</I>&gt;<i> wasn't alone. :-P
</I>&gt;<i>
</I>&gt;<i> I was testing some similar concepts myself. I've also been testing
</I>&gt;<i> moving things back and forth to unamanged internal calls to see if I
</I>&gt;<i> could speed it up and so far I've got mixed results. Some things
</I>&gt;<i> faster; some things slower. Mostly slower for most of the functions,
</I>&gt;<i> but it really depended on the size of the string I was working with
</I>&gt;<i> which was the deciding factor if it was faster to be unmanged or not.
</I>&gt;<i>
</I>&gt;<i> One thing I found is that NUnit itself can't be trusted 100% with
</I>&gt;<i> testing some of this :-P It calls corelib use these same functions we
</I>&gt;<i> are tweaking are slowing it down or speeding it up in some cases. It's
</I>&gt;<i> fine because the test suite is a test in of itself in a way. Just
</I>&gt;<i> something interesting I noticed when I was testing, when I managed to
</I>&gt;<i> slow down strings so much in one test (lovely printf on each char) that
</I>&gt;<i> it took NUnit about 30 seconds to initialize before my test even ran :-)
</I>&gt;<i>
</I>&gt;<i> I'll post all my benchmarks and patches in the morning when I can
</I>&gt;<i> assembly them in some readable format.
</I>&gt;<i>
</I>&gt;<i> -- 
</I>&gt;<i> Zac Bowling
</I>&gt;<i> <A HREF="http://zacbowling.com/">http://zacbowling.com/</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ----- Message from <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A> ---------
</I>&gt;<i>    Date: Fri, 17 Mar 2006 19:02:50 +0900
</I>&gt;<i>    From: Atsushi Eno &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i> Reply-To: Atsushi Eno &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i> Subject: Re: String performance boost (Re: [Mono-dev] Patch to boost
</I>&gt;<i> speed ofUnicodeEncoding)
</I>&gt;<i>      To: Andreas Nahr &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ClassDevelopment at A-SoftTech.com</A>&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Your patch is based on pretty old code(!) ;-) I tried it for
</I>&gt;&gt;<i> each functionality:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> - CopyTo():
</I>&gt;&gt;<i>   The patch makes it faster. But I guess CopyChar() functionality
</I>&gt;&gt;<i>   overlaps Paolo's memcpy() implementation in the latest code,
</I>&gt;&gt;<i>   though it was not simply replaceable.
</I>&gt;&gt;<i> - ToCharArray():
</I>&gt;&gt;<i>   ditto. The improvement rate is like you showed, about 5%.
</I>&gt;&gt;<i> - Trim():
</I>&gt;&gt;<i>   The patch resulted much better, as you showed. I think it is
</I>&gt;&gt;<i>   the best improvement.
</I>&gt;&gt;<i> - GetHashCode(), Insert(), Remove(),
</I>&gt;&gt;<i>   ToUpperInvariant(), ToLowerInvariant():
</I>&gt;&gt;<i>   We already have managed implementation like yours.
</I>&gt;&gt;<i> - ToUpper(), ToLower():
</I>&gt;&gt;<i>   Based on your patch, I rather made TextInfo.ToUpper() and
</I>&gt;&gt;<i>   ToLower() based on pointer implementation, so the mind is already
</I>&gt;&gt;<i>   checked in svn :-)
</I>&gt;&gt;<i> - Replace():
</I>&gt;&gt;<i>   There was a one-liner bug in the implementation. Even after
</I>&gt;&gt;<i>   fixing it, the result became much worse than existing one, about
</I>&gt;&gt;<i>   1.5x slower :-(
</I>&gt;&gt;<i> - IndexOf():
</I>&gt;&gt;<i>   It didn't make improvement - I think it is because we already
</I>&gt;&gt;<i>   have managed implementation by now.
</I>&gt;&gt;<i> - IndexOfAny():
</I>&gt;&gt;<i>   The patch made results much worse :-( It doubled execution time.
</I>&gt;&gt;<i> - Join():
</I>&gt;&gt;<i>   The patch was a bit worse, about 7-8% loss.
</I>&gt;&gt;<i> - PadLeft(), PadRight():
</I>&gt;&gt;<i>   Almost no difference - and seems like it still has bugs (some
</I>&gt;&gt;<i>   NUnit tests fail).
</I>&gt;&gt;<i> - Split():
</I>&gt;&gt;<i>   It looks pretty fast but it is too buggy to fix right now :(
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm attaching a patch based on the original source, so anyone can
</I>&gt;&gt;<i> try them handy. Those which is buggy or makes performance worse
</I>&gt;&gt;<i> are commented out.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I think Trim() can be checked in, with a few changes
</I>&gt;&gt;<i> (changing CharCopy() to InternalStrcpy()). For CharCopy(),
</I>&gt;&gt;<i> I'd wait for further review. ToCharArray() is also nicer
</I>&gt;&gt;<i> to have, but it depends on CharCopy().
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Thanks a bunch, Andreas.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Atsushi Eno
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Andreas Nahr wrote:
</I>&gt;&gt;&gt;<i> It's just bad naming ;)
</I>&gt;&gt;&gt;<i> The String.cs.old contains the managed implementations. Please note 
</I>&gt;&gt;&gt;<i> that there are usually multiple implementation-tries for each 
</I>&gt;&gt;&gt;<i> method and all but one is just commented out. Its extremely 
</I>&gt;&gt;&gt;<i> unlikely that the ones currently &quot;active&quot; are the best ones.
</I>&gt;&gt;&gt;<i> Also I can remember that at least one of the stats is completely 
</I>&gt;&gt;&gt;<i> wrong because there was a bug in the implemenation that copied only 
</I>&gt;&gt;&gt;<i> half the data.
</I>&gt;&gt;&gt;<i> If looking at the numbers I guess it is Replace because the 
</I>&gt;&gt;&gt;<i> difference is really huge
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I'll also attach the file I used for the microbenchmarks. But it is 
</I>&gt;&gt;&gt;<i> a complete mess and I doubt anyone could use anything from it.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Andreas
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Wow, the numbers are quite impressive. Can you please attach your
</I>&gt;&gt;&gt;&gt;<i> String.cs(.new) ? :-)
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Atsushi Eno
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Andreas Nahr wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i> Hi Zac, Hi Korn&#233;l,
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> I've been working quite some time on improving the existing 
</I>&gt;&gt;&gt;&gt;&gt;<i> String class a
</I>&gt;&gt;&gt;&gt;&gt;<i> long time ago (about 2-3 years), but as I got a new job back then 
</I>&gt;&gt;&gt;&gt;&gt;<i> never had
</I>&gt;&gt;&gt;&gt;&gt;<i> the time to finish anything. My findings back then were that 
</I>&gt;&gt;&gt;&gt;&gt;<i> purely managed
</I>&gt;&gt;&gt;&gt;&gt;<i> implementations basically always outperformed the internalcalls 
</I>&gt;&gt;&gt;&gt;&gt;<i> (And I guess
</I>&gt;&gt;&gt;&gt;&gt;<i> the JIT is now even more evolved than it was 3 years ago).
</I>&gt;&gt;&gt;&gt;&gt;<i> However as I sayed it was never finished and contains bugs. Moreover it
</I>&gt;&gt;&gt;&gt;&gt;<i> doesn't care at all for alignment issues.
</I>&gt;&gt;&gt;&gt;&gt;<i> If anyone want's to look at it - I attach my String-Testing class. You'll
</I>&gt;&gt;&gt;&gt;&gt;<i> find lots of different tries to optimize the Methods. But beware, 
</I>&gt;&gt;&gt;&gt;&gt;<i> the code
</I>&gt;&gt;&gt;&gt;&gt;<i> is in horrible shape, far from being usable.
</I>&gt;&gt;&gt;&gt;&gt;<i> Some optimizations use specific string-domain knowlege (like &quot;equals&quot;
</I>&gt;&gt;&gt;&gt;&gt;<i> testing first for the first char and after that from the end of 
</I>&gt;&gt;&gt;&gt;&gt;<i> the string)
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> My conclusion was: We should have a few managed functions to do the work
</I>&gt;&gt;&gt;&gt;&gt;<i> (MemoryCopy, MemoryCompare, possibly for Byte* and Char*). They should be
</I>&gt;&gt;&gt;&gt;&gt;<i> managed so that optimizers and optimizing compilers are able to do
</I>&gt;&gt;&gt;&gt;&gt;<i> optimizations even on IL level. Whenever possible the JIT should replace
</I>&gt;&gt;&gt;&gt;&gt;<i> these at runtime (provided they aren't optimized away) with
</I>&gt;&gt;&gt;&gt;&gt;<i> architecture-specific assembly versions with the managed version 
</I>&gt;&gt;&gt;&gt;&gt;<i> as fallback
</I>&gt;&gt;&gt;&gt;&gt;<i> mechanism.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Here are some findings from microbenchmarks made back then (the 
</I>&gt;&gt;&gt;&gt;&gt;<i> first number
</I>&gt;&gt;&gt;&gt;&gt;<i> is always the time in milliseconds for the existing unmanaged 
</I>&gt;&gt;&gt;&gt;&gt;<i> implementation
</I>&gt;&gt;&gt;&gt;&gt;<i> (internalcall), the second for a tested managed implementation, 
</I>&gt;&gt;&gt;&gt;&gt;<i> the Number
</I>&gt;&gt;&gt;&gt;&gt;<i> in () is the length of the string tested):
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Some Methods still need internalcalls to create new Strings, but 
</I>&gt;&gt;&gt;&gt;&gt;<i> were still
</I>&gt;&gt;&gt;&gt;&gt;<i> faster than the native implementations (The optimum would be to 
</I>&gt;&gt;&gt;&gt;&gt;<i> internalize
</I>&gt;&gt;&gt;&gt;&gt;<i> InternalAllocateStr calls).
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> CopyTo (000): 810 -&gt; 381
</I>&gt;&gt;&gt;&gt;&gt;<i> CopyTo (010): 832 -&gt; 441
</I>&gt;&gt;&gt;&gt;&gt;<i> CopyTo (100): 1352 -&gt; 881
</I>&gt;&gt;&gt;&gt;&gt;<i> CopyTo (512): 3395 -&gt; 3014
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> ToCharArray (000): 5067 -&gt; 4466
</I>&gt;&gt;&gt;&gt;&gt;<i> ToCharArray (002): 5317 -&gt; 4857
</I>&gt;&gt;&gt;&gt;&gt;<i> ToCharArray (015): 8041 -&gt; 7691
</I>&gt;&gt;&gt;&gt;&gt;<i> ToCharArray (960): 2915 -&gt; 2894
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> ToCharArray (with parameters): Similar to above
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Trim (): 6930 -&gt; 6760
</I>&gt;&gt;&gt;&gt;&gt;<i> Trim (custom search Chars): 10596 -&gt; 9413
</I>&gt;&gt;&gt;&gt;&gt;<i> Trim (default search Chars): 10455 -&gt; 7210
</I>&gt;&gt;&gt;&gt;&gt;<i> Trim (no trimmed chars, long string): 1893 -&gt; 661
</I>&gt;&gt;&gt;&gt;&gt;<i> Trim (no trimmed chars, short string): 1893 -&gt; 631
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Replace (004 - one replace): 37264 -&gt; 3135
</I>&gt;&gt;&gt;&gt;&gt;<i> Replace (004 - nothing to replace): 3735 -&gt; 310
</I>&gt;&gt;&gt;&gt;&gt;<i> Replace (961 - everything replaced): 2584 -&gt; 501
</I>&gt;&gt;&gt;&gt;&gt;<i> Replace (961 - only last char replaced): 2463 -&gt; 481
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Split (default split Chars, long string, lots splitted): 42421 -&gt; 8523
</I>&gt;&gt;&gt;&gt;&gt;<i> Split (custom split Chars, long string, non found): 2944 -&gt; 2263
</I>&gt;&gt;&gt;&gt;&gt;<i> Split (custom split Chars, long string, lots found): 22062 -&gt; 7330
</I>&gt;&gt;&gt;&gt;&gt;<i> Split (default split Chars, short string, non found): 2093 -&gt; 761
</I>&gt;&gt;&gt;&gt;&gt;<i> Split (default split Chars, short string, nearly only 
</I>&gt;&gt;&gt;&gt;&gt;<i> splitChars): 8002 -&gt;
</I>&gt;&gt;&gt;&gt;&gt;<i> 5067
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> IndexOf (17): 1132 -&gt; 791
</I>&gt;&gt;&gt;&gt;&gt;<i> IndexOf (2162): 10576 -&gt; 7862
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> LastIndexOf (similar to above)
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> IndexOfAny (long string, nothing found): 25867 -&gt; 2984 (Break 
</I>&gt;&gt;&gt;&gt;&gt;<i> even bei ca.
</I>&gt;&gt;&gt;&gt;&gt;<i> 75chars)
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> LastIndexOfAny  (similar to above)
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> PadLeft/ PadRight: slightly slower that current (Should get faster once
</I>&gt;&gt;&gt;&gt;&gt;<i> optimized CharCopy is available): 1012 -&gt; 1031
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Remove: slightly slower that current (Should get faster once optimized
</I>&gt;&gt;&gt;&gt;&gt;<i> CharCopy is available): 2153 -&gt; 2283
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> If somebody is interesting in picking this up I might be able to help a
</I>&gt;&gt;&gt;&gt;&gt;<i> litte.
</I>&gt;&gt;&gt;&gt;&gt;<i> Andreas
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;&gt;&gt;<i> Mono-devel-list mailing list
</I>&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;&gt;&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ----- End message from <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A> -----
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">Mono-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">http://lists.ximian.com/mailman/listinfo/mono-devel-list</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>

----- End message from <A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">ClassDevelopment at A-SoftTech.com</A> -----



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017629.html">String performance boost (Re: [Mono-dev] Patch to	boost	speedofUnicodeEncoding)
</A></li>
	<LI>Next message: <A HREF="017643.html">[Mono-dev] New (faster) Implementaiton for managed CharCopy
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17642">[ date ]</a>
              <a href="thread.html#17642">[ thread ]</a>
              <a href="subject.html#17642">[ subject ]</a>
              <a href="author.html#17642">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
