<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] Patch for full-featured mcs /doc support
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20full-featured%20mcs%20/doc%20support&In-Reply-To=41ADA022.5080605%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009161.html">
   <LINK REL="Next"  HREF="009176.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] Patch for full-featured mcs /doc support</H1>
    <B>Marek Safar</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20Patch%20for%20full-featured%20mcs%20/doc%20support&In-Reply-To=41ADA022.5080605%40ximian.com"
       TITLE="[Mono-devel-list] Patch for full-featured mcs /doc support">marek.safar at seznam.cz
       </A><BR>
    <I>Wed Dec  1 07:39:39 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="009161.html">[Mono-devel-list] Patch for full-featured mcs /doc support
</A></li>
        <LI>Next message: <A HREF="009176.html">[Mono-devel-list] Patch for full-featured mcs /doc support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9164">[ date ]</a>
              <a href="thread.html#9164">[ thread ]</a>
              <a href="subject.html#9164">[ subject ]</a>
              <a href="author.html#9164">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

&gt;<i>Hi,
</I>&gt;<i>
</I>&gt;<i>Miguel asked me to extract /doc specific stuff from large sources,
</I>&gt;<i>so I did that. Now we have new doc.cs and I added some static methods
</I>&gt;<i>that handles the bodies of GenerateDocument() logic. The added members
</I>&gt;<i>are still in class.cs etc, but they are just wrappers (I needed them
</I>&gt;<i>not to make method overrides into complicated code).
</I>&gt;<i>  
</I>&gt;<i>
</I>I don't like classes where all methods are static, especially when they
accept same arguments.

Marek

&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;<i>------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>Index: cs-tokenizer.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- cs-tokenizer.cs	(revision 36885)
</I>&gt;<i>+++ cs-tokenizer.cs	(working copy)
</I>&gt;<i>@@ -42,6 +42,17 @@
</I>&gt;<i> 		bool handle_assembly = false;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i>+		// XML documentation buffer. The save point is used to divide
</I>&gt;<i>+		// comments on types and comments on members.
</I>&gt;<i>+		//
</I>&gt;<i>+		StringBuilder xml_comment_buffer;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// See comment on XmlCommentState enumeration.
</I>&gt;<i>+		//
</I>&gt;<i>+		XmlCommentState xmlDocState = XmlCommentState.Allowed;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i> 		// Whether tokens have been seen on this line
</I>&gt;<i> 		//
</I>&gt;<i> 		bool tokens_seen = false;
</I>&gt;<i>@@ -132,6 +143,18 @@
</I>&gt;<i> 				handle_remove_add = value;
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		public XmlCommentState doc_state {
</I>&gt;<i>+			get { return xmlDocState; }
</I>&gt;<i>+			set {
</I>&gt;<i>+				if (value == XmlCommentState.Allowed) {
</I>&gt;<i>+					check_incorrect_doc_comment ();
</I>&gt;<i>+					consume_doc_comment ();
</I>&gt;<i>+				}
</I>&gt;<i>+				xmlDocState = value;
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		
</I>&gt;<i> 		//
</I>&gt;<i> 		// Class variables
</I>&gt;<i>@@ -362,6 +385,8 @@
</I>&gt;<i> 					define (def);
</I>&gt;<i> 			}
</I>&gt;<i> 
</I>&gt;<i>+			xml_comment_buffer = new StringBuilder ();
</I>&gt;<i>+
</I>&gt;<i> 			//
</I>&gt;<i> 			// FIXME: This could be `Location.Push' but we have to
</I>&gt;<i> 			// find out why the MS compiler allows this
</I>&gt;<i>@@ -411,6 +436,9 @@
</I>&gt;<i> 			case '}':
</I>&gt;<i> 				return Token.CLOSE_BRACE;
</I>&gt;<i> 			case '[':
</I>&gt;<i>+				// To block doccomment inside attribute declaration.
</I>&gt;<i>+				if (doc_state == XmlCommentState.Allowed)
</I>&gt;<i>+					doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i> 				return Token.OPEN_BRACKET;
</I>&gt;<i> 			case ']':
</I>&gt;<i> 				return Token.CLOSE_BRACKET;
</I>&gt;<i>@@ -1741,6 +1769,15 @@
</I>&gt;<i> 		{
</I>&gt;<i> 			int res = consume_identifier (s, false);
</I>&gt;<i> 
</I>&gt;<i>+			if (doc_state == XmlCommentState.Allowed)
</I>&gt;<i>+				doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i>+			switch (res) {
</I>&gt;<i>+			case Token.USING:
</I>&gt;<i>+			case Token.NAMESPACE:
</I>&gt;<i>+				check_incorrect_doc_comment ();
</I>&gt;<i>+				break;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i> 			if (res == Token.PARTIAL) {
</I>&gt;<i> 				// Save current position and parse next token.
</I>&gt;<i> 				int old = reader.Position;
</I>&gt;<i>@@ -1862,6 +1899,13 @@
</I>&gt;<i> 				
</I>&gt;<i> 					if (d == '/'){
</I>&gt;<i> 						getChar ();
</I>&gt;<i>+						if (RootContext.Documentation != null &amp;&amp; peekChar () == '/') {
</I>&gt;<i>+							getChar ();
</I>&gt;<i>+							if (doc_state == XmlCommentState.Allowed)
</I>&gt;<i>+								handle_one_line_xml_comment ();
</I>&gt;<i>+							else if (doc_state == XmlCommentState.NotAllowed)
</I>&gt;<i>+								warn_incorrect_doc_comment ();
</I>&gt;<i>+						}
</I>&gt;<i> 						while ((d = getChar ()) != -1 &amp;&amp; (d != '\n') &amp;&amp; d != '\r')
</I>&gt;<i> 							col++;
</I>&gt;<i> 						if (d == '\n'){
</I>&gt;<i>@@ -1874,13 +1918,35 @@
</I>&gt;<i> 						continue;
</I>&gt;<i> 					} else if (d == '*'){
</I>&gt;<i> 						getChar ();
</I>&gt;<i>+						bool docAppend = false;
</I>&gt;<i>+						if (RootContext.Documentation != null &amp;&amp; peekChar () == '*') {
</I>&gt;<i>+							getChar ();
</I>&gt;<i>+							// But when it is /**/, just do nothing.
</I>&gt;<i>+							if (peekChar () == '/') {
</I>&gt;<i>+								getChar ();
</I>&gt;<i>+								continue;
</I>&gt;<i>+							}
</I>&gt;<i>+							if (doc_state == XmlCommentState.Allowed)
</I>&gt;<i>+								docAppend = true;
</I>&gt;<i>+							else if (doc_state == XmlCommentState.NotAllowed)
</I>&gt;<i>+								warn_incorrect_doc_comment ();
</I>&gt;<i>+						}
</I>&gt;<i> 
</I>&gt;<i>+						int currentCommentStart = 0;
</I>&gt;<i>+						if (docAppend) {
</I>&gt;<i>+							currentCommentStart = xml_comment_buffer.Length;
</I>&gt;<i>+							xml_comment_buffer.Append (Environment.NewLine);
</I>&gt;<i>+						}
</I>&gt;<i>+
</I>&gt;<i> 						while ((d = getChar ()) != -1){
</I>&gt;<i> 							if (d == '*' &amp;&amp; peekChar () == '/'){
</I>&gt;<i> 								getChar ();
</I>&gt;<i> 								col++;
</I>&gt;<i> 								break;
</I>&gt;<i> 							}
</I>&gt;<i>+							if (docAppend)
</I>&gt;<i>+								xml_comment_buffer.Append ((char) d);
</I>&gt;<i>+							
</I>&gt;<i> 							if (d == '\n'){
</I>&gt;<i> 								line++;
</I>&gt;<i> 								ref_line++;
</I>&gt;<i>@@ -1889,6 +1955,8 @@
</I>&gt;<i> 								tokens_seen = false;
</I>&gt;<i> 							}
</I>&gt;<i> 						}
</I>&gt;<i>+						if (docAppend)
</I>&gt;<i>+							update_formatted_doc_comment (currentCommentStart);
</I>&gt;<i> 						continue;
</I>&gt;<i> 					}
</I>&gt;<i> 					goto is_punct_label;
</I>&gt;<i>@@ -2037,6 +2105,97 @@
</I>&gt;<i> 			return Token.EOF;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		// Handles one line xml comment
</I>&gt;<i>+		//
</I>&gt;<i>+		private void handle_one_line_xml_comment ()
</I>&gt;<i>+		{
</I>&gt;<i>+			int c;
</I>&gt;<i>+			while ((c = peekChar ()) == ' ')
</I>&gt;<i>+				getChar (); // skip heading whitespaces.
</I>&gt;<i>+			while ((c = peekChar ()) != -1 &amp;&amp; (c != '\n') &amp;&amp; c != '\r') {
</I>&gt;<i>+				col++;
</I>&gt;<i>+				xml_comment_buffer.Append ((char) getChar ());
</I>&gt;<i>+			}
</I>&gt;<i>+			if (c == '\r') {
</I>&gt;<i>+				getChar ();
</I>&gt;<i>+				xml_comment_buffer.Append ('\r');
</I>&gt;<i>+				if (peekChar () == '\n')
</I>&gt;<i>+					xml_comment_buffer.Append ('\n');
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (c == '\n')
</I>&gt;<i>+				xml_comment_buffer.Append ('\n');
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Remove heading &quot;*&quot; in Javadoc-like xml documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		private void update_formatted_doc_comment (int currentCommentStart)
</I>&gt;<i>+		{
</I>&gt;<i>+			int length = xml_comment_buffer.Length - currentCommentStart;
</I>&gt;<i>+			string [] lines = xml_comment_buffer.ToString (
</I>&gt;<i>+				currentCommentStart,
</I>&gt;<i>+				length).Split ('\n');
</I>&gt;<i>+			// The first line starts with /**, thus it is not target
</I>&gt;<i>+			// for the format check.
</I>&gt;<i>+			for (int i = 1; i &lt; lines.Length; i++) {
</I>&gt;<i>+				string s = lines [i];
</I>&gt;<i>+				int idx = s.IndexOf ('*');
</I>&gt;<i>+				string head = null;
</I>&gt;<i>+				if (idx &lt; 0) {
</I>&gt;<i>+					if (i &lt; lines.Length - 1)
</I>&gt;<i>+						return;
</I>&gt;<i>+					head = s;
</I>&gt;<i>+				}
</I>&gt;<i>+				else
</I>&gt;<i>+					head = s.Substring (0, idx);
</I>&gt;<i>+				foreach (char c in head)
</I>&gt;<i>+					if (c != ' ')
</I>&gt;<i>+						return;
</I>&gt;<i>+				lines [i] = s.Substring (idx + 1);
</I>&gt;<i>+			}
</I>&gt;<i>+			xml_comment_buffer.Remove (currentCommentStart, length);
</I>&gt;<i>+			xml_comment_buffer.Insert (
</I>&gt;<i>+				currentCommentStart,
</I>&gt;<i>+				String.Join (&quot;\n&quot;, lines));
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Checks if there was incorrect doc comments and raise
</I>&gt;<i>+		// warnings.
</I>&gt;<i>+		//
</I>&gt;<i>+		public void check_incorrect_doc_comment ()
</I>&gt;<i>+		{
</I>&gt;<i>+			if (xml_comment_buffer.Length &gt; 0)
</I>&gt;<i>+				warn_incorrect_doc_comment ();
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Raises a warning when tokenizer found incorrect doccomment
</I>&gt;<i>+		// markup.
</I>&gt;<i>+		//
</I>&gt;<i>+		private void warn_incorrect_doc_comment ()
</I>&gt;<i>+		{
</I>&gt;<i>+			doc_state = XmlCommentState.Error;
</I>&gt;<i>+			// in csc, it is 'XML comment is not placed on a valid 
</I>&gt;<i>+			// language element'. But that does not make sense.
</I>&gt;<i>+			Report.Warning (1587, 2, Location, &quot;XML comment is placed on an invalid language element which can not accept it.&quot;);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Consumes the saved xml comment lines (if any)
</I>&gt;<i>+		// as for current target member or type.
</I>&gt;<i>+		//
</I>&gt;<i>+		public string consume_doc_comment ()
</I>&gt;<i>+		{
</I>&gt;<i>+			if (xml_comment_buffer.Length &gt; 0) {
</I>&gt;<i>+				string ret = xml_comment_buffer.ToString ();
</I>&gt;<i>+				xml_comment_buffer.Length = 0;
</I>&gt;<i>+				return ret;
</I>&gt;<i>+			}
</I>&gt;<i>+			return null;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		public void cleanup ()
</I>&gt;<i> 		{
</I>&gt;<i> 			if (ifstack != null &amp;&amp; ifstack.Count &gt;= 1) {
</I>&gt;<i>@@ -2049,4 +2208,18 @@
</I>&gt;<i> 				
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i>+
</I>&gt;<i>+	//
</I>&gt;<i>+	// Indicates whether it accepts XML documentation or not.
</I>&gt;<i>+	//
</I>&gt;<i>+	public enum XmlCommentState {
</I>&gt;<i>+		// comment is allowed in this state.
</I>&gt;<i>+		Allowed,
</I>&gt;<i>+		// comment is not allowed in this state.
</I>&gt;<i>+		NotAllowed,
</I>&gt;<i>+		// once comments appeared when it is NotAllowed, then the
</I>&gt;<i>+		// state is changed to it, until the state is changed to
</I>&gt;<i>+		// .Allowed.
</I>&gt;<i>+		Error
</I>&gt;<i>+	}
</I>&gt;<i> }
</I>&gt;<i>Index: mcs.exe.sources
</I>&gt;<i>===================================================================
</I>&gt;<i>--- mcs.exe.sources	(revision 36885)
</I>&gt;<i>+++ mcs.exe.sources	(working copy)
</I>&gt;<i>@@ -12,6 +12,7 @@
</I>&gt;<i> convert.cs
</I>&gt;<i> decl.cs
</I>&gt;<i> delegate.cs
</I>&gt;<i>+doc.cs
</I>&gt;<i> enum.cs
</I>&gt;<i> ecore.cs
</I>&gt;<i> expression.cs
</I>&gt;<i>Index: rootcontext.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- rootcontext.cs	(revision 36885)
</I>&gt;<i>+++ rootcontext.cs	(working copy)
</I>&gt;<i>@@ -13,6 +13,7 @@
</I>&gt;<i> using System.Reflection;
</I>&gt;<i> using System.Reflection.Emit;
</I>&gt;<i> using System.Diagnostics;
</I>&gt;<i>+using System.Xml;
</I>&gt;<i> 
</I>&gt;<i> namespace Mono.CSharp {
</I>&gt;<i> 
</I>&gt;<i>@@ -80,6 +81,11 @@
</I>&gt;<i> 		public static bool StrongNameDelaySign = false;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i>+		// If set, enable XML documentation generation
</I>&gt;<i>+		//
</I>&gt;<i>+		public static Documentation Documentation;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i> 		// Constructor
</I>&gt;<i> 		//
</I>&gt;<i> 		static RootContext ()
</I>&gt;<i>Index: class.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- class.cs	(revision 36885)
</I>&gt;<i>+++ class.cs	(working copy)
</I>&gt;<i>@@ -40,6 +40,7 @@
</I>&gt;<i> using System.Security;
</I>&gt;<i> using System.Security.Permissions;
</I>&gt;<i> using System.Text;
</I>&gt;<i>+using System.Xml;
</I>&gt;<i> 
</I>&gt;<i> using Mono.CompilerServices.SymbolWriter;
</I>&gt;<i> 
</I>&gt;<i>@@ -432,7 +433,7 @@
</I>&gt;<i> 		// Pointers to the default constructor and the default static constructor
</I>&gt;<i> 		//
</I>&gt;<i> 		protected Constructor default_constructor;
</I>&gt;<i>-		protected Constructor default_static_constructor;
</I>&gt;<i>+		public Constructor default_static_constructor;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i> 		// Whether we have at least one non-static field
</I>&gt;<i>@@ -2396,6 +2397,19 @@
</I>&gt;<i> 			return FindMembers (mt, bf | BindingFlags.DeclaredOnly, null, null);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		// Generates xml doc comments (if any), and if required,
</I>&gt;<i>+		// handle warning report.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal override void GenerateDocComment (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			DocUtil.GenerateTypeDocComment (this, ds);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;T:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		public virtual MemberCache ParentCache {
</I>&gt;<i> 			get {
</I>&gt;<i> 				return parent_cache;
</I>&gt;<i>@@ -3296,6 +3310,34 @@
</I>&gt;<i> 			return true;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		// Returns a string that represents the signature for this 
</I>&gt;<i>+		// member which should be used in XML documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string GetDocCommentName (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			return DocUtil.GetMethodDocCommentName (this, ds);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Raised (and passed an XmlElement that contains the comment)
</I>&gt;<i>+		// when GenerateDocComment is writing documentation expectedly.
</I>&gt;<i>+		//
</I>&gt;<i>+		// FIXME: with a few effort, it could be done with XmlReader,
</I>&gt;<i>+		// that means removal of DOM use.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal override void OnGenerateDocComment (DeclSpace ds, XmlElement el)
</I>&gt;<i>+		{
</I>&gt;<i>+			DocUtil.OnMethodGenerateDocComment (this, ds, el);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;M:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		protected override void VerifyObsoleteAttribute()
</I>&gt;<i> 		{
</I>&gt;<i> 			base.VerifyObsoleteAttribute ();
</I>&gt;<i>@@ -5224,6 +5266,13 @@
</I>&gt;<i> 
</I>&gt;<i> 			base.Emit ();
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;F:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	//
</I>&gt;<i>@@ -5532,6 +5581,13 @@
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { throw new InvalidOperationException (&quot;Unexpected attempt to get doc comment from &quot; + this.GetType () + &quot;.&quot;); }
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		protected override void VerifyObsoleteAttribute()
</I>&gt;<i> 		{
</I>&gt;<i> 		}
</I>&gt;<i>@@ -5982,6 +6038,13 @@
</I>&gt;<i> 				return attribute_targets;
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;P:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 			
</I>&gt;<i> 	public class Property : PropertyBase, IIteratorContainer {
</I>&gt;<i>@@ -6626,6 +6689,13 @@
</I>&gt;<i> 
</I>&gt;<i> 			return TypeManager.GetFullNameSignature (EventBuilder);
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;E:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>Index: decl.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- decl.cs	(revision 36885)
</I>&gt;<i>+++ decl.cs	(working copy)
</I>&gt;<i>@@ -16,6 +16,7 @@
</I>&gt;<i> using System.Globalization;
</I>&gt;<i> using System.Reflection.Emit;
</I>&gt;<i> using System.Reflection;
</I>&gt;<i>+using System.Xml;
</I>&gt;<i> 
</I>&gt;<i> namespace Mono.CSharp {
</I>&gt;<i> 
</I>&gt;<i>@@ -138,6 +139,17 @@
</I>&gt;<i> 		/// &lt;/summary&gt;
</I>&gt;<i> 		public readonly Location Location;
</I>&gt;<i> 
</I>&gt;<i>+		/// &lt;summary&gt;
</I>&gt;<i>+		///   XML documentation comment
</I>&gt;<i>+		/// &lt;/summary&gt;
</I>&gt;<i>+		public string DocComment;
</I>&gt;<i>+
</I>&gt;<i>+		/// &lt;summary&gt;
</I>&gt;<i>+		///   Represents header string for documentation comment 
</I>&gt;<i>+		///   for each member types.
</I>&gt;<i>+		/// &lt;/summary&gt;
</I>&gt;<i>+		public abstract string DocCommentHeader { get; }
</I>&gt;<i>+
</I>&gt;<i> 		[Flags]
</I>&gt;<i> 		public enum Flags {
</I>&gt;<i> 			Obsolete_Undetected = 1,		// Obsolete attribute has not been detected yet
</I>&gt;<i>@@ -292,7 +304,7 @@
</I>&gt;<i> 		/// &lt;summary&gt;
</I>&gt;<i> 		/// Returns true when MemberCore is exposed from assembly.
</I>&gt;<i> 		/// &lt;/summary&gt;
</I>&gt;<i>-		protected bool IsExposedFromAssembly (DeclSpace ds)
</I>&gt;<i>+		public bool IsExposedFromAssembly (DeclSpace ds)
</I>&gt;<i> 		{
</I>&gt;<i> 			if ((ModFlags &amp; (Modifiers.PUBLIC | Modifiers.PROTECTED)) == 0)
</I>&gt;<i> 				return false;
</I>&gt;<i>@@ -364,6 +376,34 @@
</I>&gt;<i> 
</I>&gt;<i> 		protected abstract void VerifyObsoleteAttribute ();
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		// Raised (and passed an XmlElement that contains the comment)
</I>&gt;<i>+		// when GenerateDocComment is writing documentation expectedly.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal virtual void OnGenerateDocComment (DeclSpace ds, XmlElement intermediateNode)
</I>&gt;<i>+		{
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Returns a string that represents the signature for this 
</I>&gt;<i>+		// member which should be used in XML documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		public virtual string GetDocCommentName (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (ds == null || this is DeclSpace)
</I>&gt;<i>+				return DocCommentHeader + Name;
</I>&gt;<i>+			else
</I>&gt;<i>+				return String.Concat (DocCommentHeader, ds.Name, &quot;.&quot;, Name);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Generates xml doc comments (if any), and if required,
</I>&gt;<i>+		// handle warning report.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal virtual void GenerateDocComment (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			DocUtil.GenerateDocComment (this, ds);
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i>@@ -1326,7 +1366,7 @@
</I>&gt;<i> 			IDictionaryEnumerator it = parent.member_hash.GetEnumerator ();
</I>&gt;<i> 			while (it.MoveNext ()) {
</I>&gt;<i> 				hash [it.Key] = ((ArrayList) it.Value).Clone ();
</I>&gt;<i>-                        }
</I>&gt;<i>+			 }
</I>&gt;<i>                                 
</I>&gt;<i> 			return hash;
</I>&gt;<i> 		}
</I>&gt;<i>Index: delegate.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- delegate.cs	(revision 36885)
</I>&gt;<i>+++ delegate.cs	(working copy)
</I>&gt;<i>@@ -643,6 +643,13 @@
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;T:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		protected override void VerifyObsoleteAttribute()
</I>&gt;<i> 		{
</I>&gt;<i> 			CheckUsageOfObsoleteAttribute (ret_type);
</I>&gt;<i>Index: cs-parser.jay
</I>&gt;<i>===================================================================
</I>&gt;<i>--- cs-parser.jay	(revision 36885)
</I>&gt;<i>+++ cs-parser.jay	(working copy)
</I>&gt;<i>@@ -81,6 +81,14 @@
</I>&gt;<i> 		/// The current file.
</I>&gt;<i> 		///
</I>&gt;<i> 		SourceFile file;
</I>&gt;<i>+
</I>&gt;<i>+		///
</I>&gt;<i>+		/// Temporary Xml documentation cache.
</I>&gt;<i>+		/// For enum types, we need one more temporary store.
</I>&gt;<i>+		///
</I>&gt;<i>+		string tmpComment;
</I>&gt;<i>+		string enumTypeComment;
</I>&gt;<i>+
</I>&gt;<i> 		
</I>&gt;<i> 		
</I>&gt;<i> 		/// Current attribute target
</I>&gt;<i>@@ -284,7 +292,13 @@
</I>&gt;<i> 	
</I>&gt;<i> opt_EOF
</I>&gt;<i> 	: /* empty */
</I>&gt;<i>+	{
</I>&gt;<i>+		Lexer.check_incorrect_doc_comment ();
</I>&gt;<i>+	}
</I>&gt;<i> 	| EOF
</I>&gt;<i>+	{
</I>&gt;<i>+		Lexer.check_incorrect_doc_comment ();
</I>&gt;<i>+	}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> outer_declarations
</I>&gt;<i>@@ -304,7 +318,15 @@
</I>&gt;<i> 
</I>&gt;<i> using_directive
</I>&gt;<i> 	: using_alias_directive
</I>&gt;<i>+	{
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	}
</I>&gt;<i> 	| using_namespace_directive
</I>&gt;<i>+	{
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	}
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> using_alias_directive
</I>&gt;<i>@@ -375,6 +397,10 @@
</I>&gt;<i> 
</I>&gt;<i> namespace_body
</I>&gt;<i> 	: OPEN_BRACE
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i> 	  opt_using_directives
</I>&gt;<i> 	  opt_namespace_member_declarations
</I>&gt;<i> 	  CLOSE_BRACE
</I>&gt;<i>@@ -491,6 +517,13 @@
</I>&gt;<i> 			} else {
</I>&gt;<i> 				$$ = new Attributes (sect);
</I>&gt;<i> 			}
</I>&gt;<i>+			if ($$ == null) {
</I>&gt;<i>+				if (RootContext.Documentation != null) {
</I>&gt;<i>+					Lexer.check_incorrect_doc_comment ();
</I>&gt;<i>+					Lexer.doc_state =
</I>&gt;<i>+						XmlCommentState.Allowed;
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i> 		} else {
</I>&gt;<i> 			$$ = new Attributes (sect);
</I>&gt;<i> 		}		
</I>&gt;<i>@@ -746,9 +779,16 @@
</I>&gt;<i> 		if ($7 != null)
</I>&gt;<i> 			current_class.Bases = (ArrayList) $7;
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			current_class.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+
</I>&gt;<i> 		current_class.Register ();
</I>&gt;<i> 	  }
</I>&gt;<i> 	  struct_body
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i> 	  opt_semicolon
</I>&gt;<i> 	  {
</I>&gt;<i> 		$$ = current_class;
</I>&gt;<i>@@ -762,7 +802,12 @@
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> struct_body
</I>&gt;<i>-	: OPEN_BRACE opt_struct_member_declarations CLOSE_BRACE
</I>&gt;<i>+	: OPEN_BRACE
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i>+	  opt_struct_member_declarations CLOSE_BRACE
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> opt_struct_member_declarations
</I>&gt;<i>@@ -814,6 +859,10 @@
</I>&gt;<i> 				(Expression) constant.expression_or_array_initializer, modflags, 
</I>&gt;<i> 				(Attributes) $1, l);
</I>&gt;<i> 
</I>&gt;<i>+			if (RootContext.Documentation != null) {
</I>&gt;<i>+				c.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+			}
</I>&gt;<i> 			current_container.AddConstant (c);
</I>&gt;<i> 		}
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -866,6 +915,10 @@
</I>&gt;<i> 						 var.expression_or_array_initializer, 
</I>&gt;<i> 						 (Attributes) $1, l);
</I>&gt;<i> 
</I>&gt;<i>+			if (RootContext.Documentation != null) {
</I>&gt;<i>+				field.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+			}
</I>&gt;<i> 			current_container.AddField (field);
</I>&gt;<i> 		}
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -927,6 +980,8 @@
</I>&gt;<i> method_declaration
</I>&gt;<i> 	: method_header {
</I>&gt;<i> 		iterator_container = (IIteratorContainer) $1;
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	  method_body
</I>&gt;<i> 	  {
</I>&gt;<i>@@ -953,6 +1008,9 @@
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = null;
</I>&gt;<i> 		iterator_container = null;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -989,6 +1047,9 @@
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = (Parameters) $6;
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			method.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+
</I>&gt;<i> 		$$ = method;
</I>&gt;<i> 	  }
</I>&gt;<i> 	| opt_attributes
</I>&gt;<i>@@ -1003,6 +1064,10 @@
</I>&gt;<i> 					    (Attributes) $1, lexer.Location);
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = (Parameters) $6;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			method.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+
</I>&gt;<i> 		$$ = method;
</I>&gt;<i> 	  }
</I>&gt;<i> 	| opt_attributes
</I>&gt;<i>@@ -1020,6 +1085,10 @@
</I>&gt;<i> 					    lexer.Location);
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = (Parameters) $7;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			method.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+
</I>&gt;<i> 		$$ = method;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i>@@ -1163,7 +1232,12 @@
</I>&gt;<i> property_declaration
</I>&gt;<i> 	: opt_attributes
</I>&gt;<i> 	  opt_modifiers
</I>&gt;<i>-	  type namespace_or_type_name
</I>&gt;<i>+	  type
</I>&gt;<i>+	  namespace_or_type_name
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+	  }
</I>&gt;<i> 	  OPEN_BRACE 
</I>&gt;<i> 	  {
</I>&gt;<i> 		implicit_value_parameter_type = (Expression) $3;
</I>&gt;<i>@@ -1181,11 +1255,11 @@
</I>&gt;<i> 	  CLOSE_BRACE
</I>&gt;<i> 	  { 
</I>&gt;<i> 		Property prop;
</I>&gt;<i>-		Pair pair = (Pair) $7;
</I>&gt;<i>+		Pair pair = (Pair) $8;
</I>&gt;<i> 		Accessor get_block = (Accessor) pair.First;
</I>&gt;<i> 		Accessor set_block = (Accessor) pair.Second;
</I>&gt;<i> 
</I>&gt;<i>-		Location loc = (Location) $6;
</I>&gt;<i>+		Location loc = (Location) $7;
</I>&gt;<i> 		MemberName name = (MemberName) $4;
</I>&gt;<i> 
</I>&gt;<i> 		prop = new Property (current_class, (Expression) $3, (int) $2, false,
</I>&gt;<i>@@ -1196,6 +1270,10 @@
</I>&gt;<i> 		current_container.AddProperty (prop);
</I>&gt;<i> 		implicit_value_parameter_type = null;
</I>&gt;<i> 		iterator_container = null;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			prop.DocComment = ConsumeStoredComment ();
</I>&gt;<i>+
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1236,6 +1314,10 @@
</I>&gt;<i> 		$$ = new Accessor ((ToplevelBlock) $5, (int) $2, (Attributes) $1, lexer.Location);
</I>&gt;<i> 		current_local_parameters = null;
</I>&gt;<i> 		lexer.PropertyParsing = true;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			if (Lexer.doc_state == XmlCommentState.Error)
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1273,6 +1355,10 @@
</I>&gt;<i> 		$$ = new Accessor ((ToplevelBlock) $5, (int) $2, (Attributes) $1, lexer.Location);
</I>&gt;<i> 		current_local_parameters = null;
</I>&gt;<i> 		lexer.PropertyParsing = true;
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null
</I>&gt;<i>+			&amp;&amp; Lexer.doc_state == XmlCommentState.Error)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1310,6 +1396,11 @@
</I>&gt;<i> 	  {
</I>&gt;<i> 		current_class.Bases = (ArrayList) $7;
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			current_class.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		current_class.Register ();
</I>&gt;<i> 	  }
</I>&gt;<i> 	  interface_body 
</I>&gt;<i>@@ -1470,6 +1561,8 @@
</I>&gt;<i> 				  new MemberName (TypeContainer.DefaultIndexerName),
</I>&gt;<i> 				  (int) $2, true, (Parameters) $6, (Attributes) $1,
</I>&gt;<i> 				  info.Get, info.Set, lexer.Location);
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			((Indexer) $$).DocComment = ConsumeStoredComment ();
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1493,6 +1586,9 @@
</I>&gt;<i> 			new Parameters (param_list, null, decl.location),
</I>&gt;<i> 			(ToplevelBlock) $5, (Attributes) $1, decl.location);
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			op.DocComment = ConsumeStoredComment ();
</I>&gt;<i>+
</I>&gt;<i> 		if (SimpleIteratorContainer.Simple.Yields)
</I>&gt;<i> 			op.SetYields ();
</I>&gt;<i> 
</I>&gt;<i>@@ -1522,12 +1618,18 @@
</I>&gt;<i> 			op = Operator.OpType.UnaryNegation;
</I>&gt;<i> 
</I>&gt;<i> 		Parameter [] pars = new Parameter [1];
</I>&gt;<i>+		Expression type = (Expression) $5;
</I>&gt;<i> 
</I>&gt;<i>-		pars [0] = new Parameter ((Expression) $5, (string) $6, Parameter.Modifier.NONE, null);
</I>&gt;<i>+		pars [0] = new Parameter (type, (string) $6, Parameter.Modifier.NONE, null);
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = new Parameters (pars, null, lexer.Location);
</I>&gt;<i> 
</I>&gt;<i>-		$$ = new OperatorDeclaration (op, (Expression) $1, (Expression) $5, (string) $6,
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		$$ = new OperatorDeclaration (op, (Expression) $1, type, (string) $6,
</I>&gt;<i> 					      null, null, lexer.Location);
</I>&gt;<i> 	}
</I>&gt;<i> 	| type OPERATOR overloadable_operator
</I>&gt;<i>@@ -1536,18 +1638,26 @@
</I>&gt;<i> 	  	type IDENTIFIER 
</I>&gt;<i> 	  CLOSE_PARENS
</I>&gt;<i>         {
</I>&gt;<i>-	       CheckBinaryOperator ((Operator.OpType) $3);
</I>&gt;<i>+		CheckBinaryOperator ((Operator.OpType) $3);
</I>&gt;<i> 
</I>&gt;<i>-	       Parameter [] pars = new Parameter [2];
</I>&gt;<i>+		Parameter [] pars = new Parameter [2];
</I>&gt;<i> 
</I>&gt;<i>-	       pars [0] = new Parameter ((Expression) $5, (string) $6, Parameter.Modifier.NONE, null);
</I>&gt;<i>-	       pars [1] = new Parameter ((Expression) $8, (string) $9, Parameter.Modifier.NONE, null);
</I>&gt;<i>+		Expression typeL = (Expression) $5;
</I>&gt;<i>+		Expression typeR = (Expression) $8;
</I>&gt;<i> 
</I>&gt;<i>+	       pars [0] = new Parameter (typeL, (string) $6, Parameter.Modifier.NONE, null);
</I>&gt;<i>+	       pars [1] = new Parameter (typeR, (string) $9, Parameter.Modifier.NONE, null);
</I>&gt;<i>+
</I>&gt;<i> 	       current_local_parameters = new Parameters (pars, null, lexer.Location);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i> 	       
</I>&gt;<i> 	       $$ = new OperatorDeclaration ((Operator.OpType) $3, (Expression) $1, 
</I>&gt;<i>-					     (Expression) $5, (string) $6,
</I>&gt;<i>-					     (Expression) $8, (string) $9, lexer.Location);
</I>&gt;<i>+					     typeL, (string) $6,
</I>&gt;<i>+					     typeR, (string) $9, lexer.Location);
</I>&gt;<i>         }
</I>&gt;<i> 	| conversion_operator_declarator
</I>&gt;<i> 	;
</I>&gt;<i>@@ -1624,6 +1734,9 @@
</I>&gt;<i> 		c.OptAttributes = (Attributes) $1;
</I>&gt;<i> 		c.ModFlags = (int) $2;
</I>&gt;<i> 	
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			c.DocComment = ConsumeStoredComment ();
</I>&gt;<i>+
</I>&gt;<i> 		if (c.Name == current_container.Basename){
</I>&gt;<i> 			if ((c.ModFlags &amp; Modifiers.STATIC) != 0){
</I>&gt;<i> 				if ((c.ModFlags &amp; Modifiers.Accessibility) != 0){
</I>&gt;<i>@@ -1657,22 +1770,30 @@
</I>&gt;<i> 		current_container.AddConstructor (c);
</I>&gt;<i> 
</I>&gt;<i> 		current_local_parameters = null;
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> constructor_declarator
</I>&gt;<i>-	: IDENTIFIER 
</I>&gt;<i>+	: IDENTIFIER
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+	  }
</I>&gt;<i> 	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS 
</I>&gt;<i> 	  {
</I>&gt;<i> 		oob_stack.Push (lexer.Location);
</I>&gt;<i> 
</I>&gt;<i>-		current_local_parameters = (Parameters) $3;
</I>&gt;<i>+		current_local_parameters = (Parameters) $4;
</I>&gt;<i> 	  }
</I>&gt;<i> 	  opt_constructor_initializer
</I>&gt;<i> 	  {
</I>&gt;<i> 		Location l = (Location) oob_stack.Pop ();
</I>&gt;<i>-		$$ = new Constructor (current_class, (string) $1, 0, (Parameters) $3,
</I>&gt;<i>-				      (ConstructorInitializer) $6, l);
</I>&gt;<i>+		$$ = new Constructor (current_class, (string) $1, 0, (Parameters) $4,
</I>&gt;<i>+				      (ConstructorInitializer) $7, l);
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1708,9 +1829,16 @@
</I>&gt;<i>         ;
</I>&gt;<i>         
</I>&gt;<i> destructor_declaration
</I>&gt;<i>-	: opt_attributes opt_finalizer TILDE IDENTIFIER OPEN_PARENS CLOSE_PARENS block
</I>&gt;<i>+	: opt_attributes opt_finalizer TILDE 
</I>&gt;<i> 	  {
</I>&gt;<i>-		if ((string) $4 != current_container.Basename){
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i>+		}
</I>&gt;<i>+	  }
</I>&gt;<i>+	  IDENTIFIER OPEN_PARENS CLOSE_PARENS block
</I>&gt;<i>+	  {
</I>&gt;<i>+		if ((string) $5 != current_container.Basename){
</I>&gt;<i> 			Report.Error (574, lexer.Location, &quot;Name of destructor must match name of class&quot;);
</I>&gt;<i> 		} else if (!(current_container is Class)){
</I>&gt;<i> 			Report.Error (575, lexer.Location, &quot;Destructors are only allowed in class types&quot;);
</I>&gt;<i>@@ -1734,8 +1862,10 @@
</I>&gt;<i> 			Method d = new Destructor (
</I>&gt;<i> 				current_class, TypeManager.system_void_expr, m, &quot;Finalize&quot;, 
</I>&gt;<i> 				new Parameters (null, null, l), (Attributes) $1, l);
</I>&gt;<i>+			if (RootContext.Documentation != null)
</I>&gt;<i>+				d.DocComment = ConsumeStoredComment ();
</I>&gt;<i> 		  
</I>&gt;<i>-			d.Block = (ToplevelBlock) $7;
</I>&gt;<i>+			d.Block = (ToplevelBlock) $8;
</I>&gt;<i> 			current_container.AddMethod (d);
</I>&gt;<i> 		}
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -1756,7 +1886,11 @@
</I>&gt;<i> 				lexer.Location);
</I>&gt;<i> 
</I>&gt;<i> 			current_container.AddEvent (e);
</I>&gt;<i>-				       
</I>&gt;<i>+
</I>&gt;<i>+			if (RootContext.Documentation != null) {
</I>&gt;<i>+				e.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+			}
</I>&gt;<i> 		}
</I>&gt;<i> 	  }
</I>&gt;<i> 	| opt_attributes
</I>&gt;<i>@@ -1788,7 +1922,11 @@
</I>&gt;<i> 				current_class, (Expression) $4, (int) $2, false, name, null,
</I>&gt;<i> 				(Attributes) $1, (Accessor) pair.First, (Accessor) pair.Second,
</I>&gt;<i> 				loc);
</I>&gt;<i>-			
</I>&gt;<i>+			if (RootContext.Documentation != null) {
</I>&gt;<i>+				e.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+				Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i> 			current_container.AddEvent (e);
</I>&gt;<i> 			implicit_value_parameter_type = null;
</I>&gt;<i> 		}
</I>&gt;<i>@@ -1800,6 +1938,9 @@
</I>&gt;<i> 			Report.Error (71, lexer.Location, &quot;Explicit implementation of events requires property syntax&quot;);
</I>&gt;<i> 		else 
</I>&gt;<i> 			Report.Error (71, lexer.Location, &quot;Event declaration should use property syntax&quot;);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1910,6 +2051,8 @@
</I>&gt;<i> 		indexer = new Indexer (current_class, decl.type, name,
</I>&gt;<i> 				       (int) $2, false, decl.param_list, (Attributes) $1,
</I>&gt;<i> 				       get_block, set_block, loc);
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			indexer.DocComment = ConsumeStoredComment ();
</I>&gt;<i> 
</I>&gt;<i> 		current_container.AddIndexer (indexer);
</I>&gt;<i> 		
</I>&gt;<i>@@ -1929,6 +2072,10 @@
</I>&gt;<i> 		} else if (pars.FixedParameters == null &amp;&amp; pars.ArrayParameter == null){
</I>&gt;<i> 			Report.Error (1551, lexer.Location, &quot;Indexers must have at least one parameter&quot;);
</I>&gt;<i> 		}
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i> 
</I>&gt;<i> 		$$ = new IndexerDeclaration ((Expression) $1, null, pars);
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -1942,8 +2089,14 @@
</I>&gt;<i> 		} else if (pars.FixedParameters == null &amp;&amp; pars.ArrayParameter == null){
</I>&gt;<i> 			Report.Error (1551, lexer.Location, &quot;Indexers must have at least one parameter&quot;);
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i> 		MemberName name = (MemberName) $2;
</I>&gt;<i> 		$$ = new IndexerDeclaration ((Expression) $1, name, pars);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -1951,7 +2104,10 @@
</I>&gt;<i> 	: opt_attributes
</I>&gt;<i> 	  opt_modifiers
</I>&gt;<i> 	  ENUM IDENTIFIER 
</I>&gt;<i>-	  opt_enum_base
</I>&gt;<i>+	  opt_enum_base {
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			enumTypeComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+	  }
</I>&gt;<i> 	  enum_body
</I>&gt;<i> 	  opt_semicolon
</I>&gt;<i> 	  { 
</I>&gt;<i>@@ -1961,10 +2117,14 @@
</I>&gt;<i> 		Enum e = new Enum (current_namespace, current_container, (Expression) $5, (int) $2,
</I>&gt;<i> 				   full_name, (Attributes) $1, enum_location);
</I>&gt;<i> 		
</I>&gt;<i>-		foreach (VariableDeclaration ev in (ArrayList) $6) {
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			e.DocComment = enumTypeComment;
</I>&gt;<i>+
</I>&gt;<i>+		foreach (VariableDeclaration ev in (ArrayList) $7) {
</I>&gt;<i> 			e.AddEnumMember (ev.identifier, 
</I>&gt;<i> 					 (Expression) ev.expression_or_array_initializer,
</I>&gt;<i>-					 ev.Location, ev.OptAttributes);
</I>&gt;<i>+					 ev.Location, ev.OptAttributes,
</I>&gt;<i>+					 ev.DocComment);
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i> 		string name = full_name.GetName ();
</I>&gt;<i>@@ -1980,10 +2140,21 @@
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> enum_body
</I>&gt;<i>-	: OPEN_BRACE opt_enum_member_declarations CLOSE_BRACE
</I>&gt;<i>+	: OPEN_BRACE
</I>&gt;<i> 	  {
</I>&gt;<i>-		$$ = $2;
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i> 	  }
</I>&gt;<i>+	  opt_enum_member_declarations
</I>&gt;<i>+	  {
</I>&gt;<i>+	  	// here will be evaluated after CLOSE_BLACE is consumed.
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i>+	  CLOSE_BRACE
</I>&gt;<i>+	  {
</I>&gt;<i>+		$$ = $3;
</I>&gt;<i>+	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i> opt_enum_member_declarations
</I>&gt;<i>@@ -2012,15 +2183,31 @@
</I>&gt;<i> enum_member_declaration
</I>&gt;<i> 	: opt_attributes IDENTIFIER 
</I>&gt;<i> 	  {
</I>&gt;<i>-		$$ = new VariableDeclaration ((string) $2, null, lexer.Location, (Attributes) $1);
</I>&gt;<i>+		VariableDeclaration vd = new VariableDeclaration ((string) $2, null, lexer.Location, (Attributes) $1);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			vd.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		$$ = vd;
</I>&gt;<i> 	  }
</I>&gt;<i> 	| opt_attributes IDENTIFIER
</I>&gt;<i> 	  {
</I>&gt;<i>-		  $$ = lexer.Location;
</I>&gt;<i>+		$$ = lexer.Location;
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			tmpComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.NotAllowed;
</I>&gt;<i>+		}
</I>&gt;<i> 	  }
</I>&gt;<i>           ASSIGN expression
</I>&gt;<i> 	  { 
</I>&gt;<i>-		$$ = new VariableDeclaration ((string) $2, $5, lexer.Location, (Attributes) $1);
</I>&gt;<i>+		VariableDeclaration vd = new VariableDeclaration ((string) $2, $5, lexer.Location, (Attributes) $1);
</I>&gt;<i>+
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			vd.DocComment = ConsumeStoredComment ();
</I>&gt;<i>+
</I>&gt;<i>+		$$ = vd;
</I>&gt;<i> 	  }
</I>&gt;<i> 	;
</I>&gt;<i> 
</I>&gt;<i>@@ -2036,6 +2223,11 @@
</I>&gt;<i> 		Delegate del = new Delegate (current_namespace, current_container, (Expression) $4,
</I>&gt;<i> 					     (int) $2, name, (Parameters) $7, (Attributes) $1, l);
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			del.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		current_container.AddDelegate (del);
</I>&gt;<i> 		RootContext.Tree.RecordDecl (name.GetName (true), del);
</I>&gt;<i> 	  }	
</I>&gt;<i>@@ -2052,6 +2244,11 @@
</I>&gt;<i> 			TypeManager.system_void_expr, (int) $2, name,
</I>&gt;<i> 			(Parameters) $7, (Attributes) $1, l);
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			del.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		current_container.AddDelegate (del);
</I>&gt;<i> 		RootContext.Tree.RecordDecl (name.GetName (true), del);
</I>&gt;<i> 	  }
</I>&gt;<i>@@ -3055,9 +3252,18 @@
</I>&gt;<i> 			current_class.Bases = (ArrayList) $7;
</I>&gt;<i> 		}
</I>&gt;<i> 
</I>&gt;<i>+		if (RootContext.Documentation != null) {
</I>&gt;<i>+			current_class.DocComment = Lexer.consume_doc_comment ();
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i> 		current_class.Register ();
</I>&gt;<i> 	  }
</I>&gt;<i>-	  class_body 
</I>&gt;<i>+	  class_body
</I>&gt;<i>+	  {
</I>&gt;<i>+		if (RootContext.Documentation != null)
</I>&gt;<i>+			Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	  }
</I>&gt;<i> 	  opt_semicolon 
</I>&gt;<i> 	  {
</I>&gt;<i> 		$$ = current_class;
</I>&gt;<i>@@ -4138,6 +4344,7 @@
</I>&gt;<i> 	public object expression_or_array_initializer;
</I>&gt;<i> 	public Location Location;
</I>&gt;<i> 	public Attributes OptAttributes;
</I>&gt;<i>+	public string DocComment;
</I>&gt;<i> 
</I>&gt;<i> 	public VariableDeclaration (string id, object eoai, Location l, Attributes opt_attrs)
</I>&gt;<i> 	{
</I>&gt;<i>@@ -4482,5 +4689,13 @@
</I>&gt;<i> 	CheckToken (1041, yyToken, &quot;Identifier expected&quot;);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i>+string ConsumeStoredComment ()
</I>&gt;<i>+{
</I>&gt;<i>+	string s = tmpComment;
</I>&gt;<i>+	tmpComment = null;
</I>&gt;<i>+	Lexer.doc_state = XmlCommentState.Allowed;
</I>&gt;<i>+	return s;
</I>&gt;<i>+}
</I>&gt;<i>+
</I>&gt;<i> /* end end end */
</I>&gt;<i> }
</I>&gt;<i>Index: ChangeLog
</I>&gt;<i>===================================================================
</I>&gt;<i>--- ChangeLog	(revision 36885)
</I>&gt;<i>+++ ChangeLog	(working copy)
</I>&gt;<i>@@ -1,3 +1,35 @@
</I>&gt;<i>+2004-11-30  Atsushi Enomoto  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i>+
</I>&gt;<i>+	all things are for /doc support:
</I>&gt;<i>+
</I>&gt;<i>+	* driver.cs:
</I>&gt;<i>+	  Handle /doc command line option.
</I>&gt;<i>+	  Report error 2006 instead of 5 for missing file name for /doc.
</I>&gt;<i>+	  Added call to RootContext.GenerateDocComment() after type resolution.
</I>&gt;<i>+	* cs-tokenizer.cs:
</I>&gt;<i>+	  Added support for picking up documentation (/// and /** ... */),
</I>&gt;<i>+	  including a new XmlCommentState enumeration.
</I>&gt;<i>+	* cs-parser.jay:
</I>&gt;<i>+	  Added lines to fill Documentation element for field, constant,
</I>&gt;<i>+	  property, indexer, method, constructor, destructor, operator, event
</I>&gt;<i>+	  and class, struct, interface, delegate, enum.
</I>&gt;<i>+	  Added lines to warn incorrect comment.
</I>&gt;<i>+	* rootcontext.cs :
</I>&gt;<i>+	  Added NeedDocument, XmlCommentOutput and XmlDocumentation (values
</I>&gt;<i>+	  are passed only when /doc was specified).
</I>&gt;<i>+	  Added StoredDocuments() to cache &lt;include&gt;d xml comment documents.
</I>&gt;<i>+	  Added static GenerateDocComment().
</I>&gt;<i>+	* decl.cs:
</I>&gt;<i>+	  Added DocComment, DocCommentHeader, GenerateDocComment() and
</I>&gt;<i>+	  OnGenerateDocComment() and some supporting private members for
</I>&gt;<i>+	  /doc feature to MemberCore.
</I>&gt;<i>+	* class.cs:
</I>&gt;<i>+	  Added GenerateDocComment() on TypeContainer, MethodCore and Operator.
</I>&gt;<i>+	* delegate.cs:
</I>&gt;<i>+	  Added overriden DocCommentHeader.
</I>&gt;<i>+	* enum.cs:
</I>&gt;<i>+	  Added overriden DocCommentHeader and GenerateDocComment().
</I>&gt;<i>+
</I>&gt;<i> 2004-11-30  Raja R Harinath  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">rharinath at novell.com</A>&gt;
</I>&gt;<i> 
</I>&gt;<i> 	* Makefile (mcs.exe) [PROFILE=default]: Keep a copy of mcs.exe in
</I>&gt;<i>Index: driver.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- driver.cs	(revision 36885)
</I>&gt;<i>+++ driver.cs	(working copy)
</I>&gt;<i>@@ -17,6 +17,7 @@
</I>&gt;<i> 	using System.IO;
</I>&gt;<i> 	using System.Text;
</I>&gt;<i> 	using System.Globalization;
</I>&gt;<i>+	using System.Xml;
</I>&gt;<i> 	using System.Diagnostics;
</I>&gt;<i> 
</I>&gt;<i> 	public enum Target {
</I>&gt;<i>@@ -98,6 +99,11 @@
</I>&gt;<i> 		static Encoding encoding;
</I>&gt;<i> 
</I>&gt;<i> 		//
</I>&gt;<i>+		// XML Comment documentation
</I>&gt;<i>+		//
</I>&gt;<i>+		static string xml_documentation_file;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i> 		// Whether the user has specified a different encoder manually
</I>&gt;<i> 		//
</I>&gt;<i> 		static bool using_default_encoder = true;
</I>&gt;<i>@@ -220,6 +226,7 @@
</I>&gt;<i> 				&quot;   -nostdlib[+|-]     Does not load core libraries\n&quot; +
</I>&gt;<i> 				&quot;   -nowarn:W1[,W2]    Disables one or more warnings\n&quot; + 
</I>&gt;<i> 				&quot;   -out:FNAME         Specifies output file\n&quot; +
</I>&gt;<i>+				&quot;   -doc:XMLFILE         Generates xml documentation into specified file\n&quot; +
</I>&gt;<i> 				&quot;   -pkg:P1[,Pn]       References packages P1..Pn\n&quot; + 
</I>&gt;<i> 				&quot;   --expect-error X   Expect that error X will be encountered\n&quot; +
</I>&gt;<i> 				&quot;   -recurse:SPEC      Recursively compiles the files in SPEC ([dir]/file)\n&quot; + 
</I>&gt;<i>@@ -1101,10 +1108,11 @@
</I>&gt;<i> 			}
</I>&gt;<i> 			case &quot;/doc&quot;: {
</I>&gt;<i> 				if (value == &quot;&quot;){
</I>&gt;<i>-					Report.Error (5, arg + &quot; requires an argument&quot;);
</I>&gt;<i>+					Report.Error (2006, arg + &quot; requires an argument&quot;);
</I>&gt;<i> 					Environment.Exit (1);
</I>&gt;<i> 				}
</I>&gt;<i>-				// TODO handle the /doc argument to generate xml doc
</I>&gt;<i>+				xml_documentation_file = value;
</I>&gt;<i>+				RootContext.Documentation = new Documentation ();
</I>&gt;<i> 				return true;
</I>&gt;<i> 			}
</I>&gt;<i> 			case &quot;/lib&quot;: {
</I>&gt;<i>@@ -1536,6 +1544,7 @@
</I>&gt;<i> 			if (timestamps)
</I>&gt;<i> 				ShowTime (&quot;Resolving tree&quot;);
</I>&gt;<i> 			RootContext.ResolveTree ();
</I>&gt;<i>+
</I>&gt;<i> 			if (Report.Errors &gt; 0)
</I>&gt;<i> 				return false;
</I>&gt;<i> 			if (timestamps)
</I>&gt;<i>@@ -1546,6 +1555,13 @@
</I>&gt;<i> 			RootContext.PopulateTypes ();
</I>&gt;<i> 			RootContext.DefineTypes ();
</I>&gt;<i> 			
</I>&gt;<i>+			if (RootContext.Documentation != null &amp;&amp;
</I>&gt;<i>+				!RootContext.Documentation.OutputDocComment (
</I>&gt;<i>+					RootContext.Tree.Types,
</I>&gt;<i>+					output_file,
</I>&gt;<i>+					xml_documentation_file))
</I>&gt;<i>+				return false;
</I>&gt;<i>+
</I>&gt;<i> 			TypeManager.InitCodeHelpers ();
</I>&gt;<i> 
</I>&gt;<i> 			//
</I>&gt;<i>@@ -1735,7 +1751,6 @@
</I>&gt;<i> #endif
</I>&gt;<i> 			return (Report.Errors == 0);
</I>&gt;<i> 		}
</I>&gt;<i>-
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	//
</I>&gt;<i>Index: enum.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- enum.cs	(revision 36885)
</I>&gt;<i>+++ enum.cs	(working copy)
</I>&gt;<i>@@ -14,6 +14,7 @@
</I>&gt;<i> using System.Reflection;
</I>&gt;<i> using System.Reflection.Emit;
</I>&gt;<i> using System.Globalization;
</I>&gt;<i>+using System.Xml;
</I>&gt;<i> 
</I>&gt;<i> namespace Mono.CSharp {
</I>&gt;<i> 
</I>&gt;<i>@@ -100,13 +101,17 @@
</I>&gt;<i> 		protected override void VerifyObsoleteAttribute()
</I>&gt;<i> 		{
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;F:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	/// &lt;summary&gt;
</I>&gt;<i> 	///   Enumeration container
</I>&gt;<i> 	/// &lt;/summary&gt;
</I>&gt;<i> 	public class Enum : DeclSpace {
</I>&gt;<i>-		ArrayList ordered_enums;
</I>&gt;<i>+		public ArrayList ordered_enums;
</I>&gt;<i> 		
</I>&gt;<i> 		public Expression BaseType;
</I>&gt;<i> 		
</I>&gt;<i>@@ -152,7 +157,7 @@
</I>&gt;<i> 		///   Adds @name to the enumeration space, with @expr
</I>&gt;<i> 		///   being its definition.  
</I>&gt;<i> 		/// &lt;/summary&gt;
</I>&gt;<i>-		public void AddEnumMember (string name, Expression expr, Location loc, Attributes opt_attrs)
</I>&gt;<i>+		public void AddEnumMember (string name, Expression expr, Location loc, Attributes opt_attrs, string documentation)
</I>&gt;<i> 		{
</I>&gt;<i> 			if (name == &quot;value__&quot;) {
</I>&gt;<i> 				Report.Error (76, loc, &quot;An item in an enumeration can't have an identifier `value__'&quot;);
</I>&gt;<i>@@ -160,6 +165,7 @@
</I>&gt;<i> 			}
</I>&gt;<i> 
</I>&gt;<i> 			EnumMember em = new EnumMember (this, expr, name, loc, opt_attrs);
</I>&gt;<i>+			em.DocComment = documentation;
</I>&gt;<i> 			if (!AddToContainer (em, false, name, &quot;&quot;))
</I>&gt;<i> 				return;
</I>&gt;<i> 
</I>&gt;<i>@@ -784,5 +790,21 @@
</I>&gt;<i> 		{
</I>&gt;<i> 			// UnderlyingType is never obsolete
</I>&gt;<i> 		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Generates xml doc comments (if any), and if required,
</I>&gt;<i>+		// handle warning report.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal override void GenerateDocComment (DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			DocUtil.GenerateEnumDocComment (this, ds);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		//   Represents header string for documentation comment.
</I>&gt;<i>+		//
</I>&gt;<i>+		public override string DocCommentHeader {
</I>&gt;<i>+			get { return &quot;T:&quot;; }
</I>&gt;<i>+		}
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i>Index: doc.cs
</I>&gt;<i>===================================================================
</I>&gt;<i>--- doc.cs	(revision 0)
</I>&gt;<i>+++ doc.cs	(revision 0)
</I>&gt;<i>@@ -0,0 +1,703 @@
</I>&gt;<i>+//
</I>&gt;<i>+// doc.cs: Support for XML documentation comment.
</I>&gt;<i>+//
</I>&gt;<i>+// Author:
</I>&gt;<i>+//	Atsushi Enomoto &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-devel-list">atsushi at ximian.com</A>&gt;
</I>&gt;<i>+//
</I>&gt;<i>+// Licensed under the terms of the GNU GPL
</I>&gt;<i>+//
</I>&gt;<i>+// (C) 2001, 2002, 2003 Ximian, Inc (<A HREF="http://www.ximian.com">http://www.ximian.com</A>)
</I>&gt;<i>+//
</I>&gt;<i>+//
</I>&gt;<i>+using System;
</I>&gt;<i>+using System.Collections;
</I>&gt;<i>+using System.IO;
</I>&gt;<i>+using System.Reflection;
</I>&gt;<i>+using System.Reflection.Emit;
</I>&gt;<i>+using System.Runtime.CompilerServices;
</I>&gt;<i>+using System.Runtime.InteropServices;
</I>&gt;<i>+using System.Security;
</I>&gt;<i>+using System.Security.Permissions;
</I>&gt;<i>+using System.Text;
</I>&gt;<i>+using System.Xml;
</I>&gt;<i>+
</I>&gt;<i>+using Mono.CompilerServices.SymbolWriter;
</I>&gt;<i>+
</I>&gt;<i>+namespace Mono.CSharp {
</I>&gt;<i>+
</I>&gt;<i>+	//
</I>&gt;<i>+	// Support class for XML documentation.
</I>&gt;<i>+	//
</I>&gt;<i>+	public class DocUtil
</I>&gt;<i>+	{
</I>&gt;<i>+		// TypeContainer
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Generates xml doc comments (if any), and if required,
</I>&gt;<i>+		// handle warning report.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal static void GenerateTypeDocComment (TypeContainer t,
</I>&gt;<i>+			DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			GenerateDocComment (t, ds);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.default_static_constructor != null)
</I>&gt;<i>+				t.default_static_constructor.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.InstanceConstructors != null)
</I>&gt;<i>+				foreach (Constructor c in t.InstanceConstructors)
</I>&gt;<i>+					c.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.Types != null)
</I>&gt;<i>+				foreach (TypeContainer tc in t.Types)
</I>&gt;<i>+					tc.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.Enums != null)
</I>&gt;<i>+				foreach (Enum en in t.Enums)
</I>&gt;<i>+					en.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.Constants != null)
</I>&gt;<i>+				foreach (Const c in t.Constants)
</I>&gt;<i>+					c.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.Fields != null)
</I>&gt;<i>+				foreach (Field f in t.Fields)
</I>&gt;<i>+					f.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.Events != null)
</I>&gt;<i>+				foreach (Event e in t.Events)
</I>&gt;<i>+					e.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.Indexers != null)
</I>&gt;<i>+				foreach (Indexer ix in t.Indexers)
</I>&gt;<i>+					ix.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.Properties != null)
</I>&gt;<i>+				foreach (Property p in t.Properties)
</I>&gt;<i>+					p.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.Methods != null)
</I>&gt;<i>+				foreach (Method m in t.Methods)
</I>&gt;<i>+					m.GenerateDocComment (t);
</I>&gt;<i>+
</I>&gt;<i>+			if (t.Operators != null)
</I>&gt;<i>+				foreach (Operator o in t.Operators)
</I>&gt;<i>+					o.GenerateDocComment (t);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		// MemberCore
</I>&gt;<i>+
</I>&gt;<i>+		private static XmlNode GetDocCommentNode (MemberCore mc,
</I>&gt;<i>+			string name)
</I>&gt;<i>+		{
</I>&gt;<i>+			// FIXME: It could be even optimizable as not
</I>&gt;<i>+			// to use XmlDocument. But anyways the nodes
</I>&gt;<i>+			// are not kept in memory.
</I>&gt;<i>+			XmlDocument doc = RootContext.Documentation.XmlDocumentation;
</I>&gt;<i>+			try {
</I>&gt;<i>+				XmlElement el = doc.CreateElement (&quot;member&quot;);
</I>&gt;<i>+				el.SetAttribute (&quot;name&quot;, name);
</I>&gt;<i>+				string normalized = mc.DocComment;
</I>&gt;<i>+				el.InnerXml = normalized;
</I>&gt;<i>+				// csc keeps lines as written in the sources
</I>&gt;<i>+				// and inserts formatting indentation (which 
</I>&gt;<i>+				// is different from XmlTextWriter.Formatting
</I>&gt;<i>+				// one), but when a start tag contains an 
</I>&gt;<i>+				// endline, it joins the next line. We don't
</I>&gt;<i>+				// have to follow such a hacky behavior.
</I>&gt;<i>+				string [] split =
</I>&gt;<i>+					mc.DocComment.Split ('\n');
</I>&gt;<i>+				int j = 0;
</I>&gt;<i>+				for (int i = 0; i &lt; split.Length; i++) {
</I>&gt;<i>+					string s = split [i].TrimEnd ();
</I>&gt;<i>+					if (s.Length &gt; 0)
</I>&gt;<i>+						split [j++] = s;
</I>&gt;<i>+				}
</I>&gt;<i>+				el.InnerXml = String.Join (
</I>&gt;<i>+					&quot;\n            &quot;, split, 0, j);
</I>&gt;<i>+				return el;
</I>&gt;<i>+			} catch (XmlException ex) {
</I>&gt;<i>+				Report.Warning (1570, 1, mc.Location, &quot;XML comment on '{0}' has non-well-formed XML ({1}).&quot;, name, ex.Message);
</I>&gt;<i>+				XmlComment com = doc.CreateComment (String.Format (&quot;FIXME: Invalid documentation markup was found for member {0}&quot;, name));
</I>&gt;<i>+				return com;
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Generates xml doc comments (if any), and if required,
</I>&gt;<i>+		// handle warning report.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal static void GenerateDocComment (MemberCore mc,
</I>&gt;<i>+			DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (mc.DocComment != null) {
</I>&gt;<i>+				string name = mc.GetDocCommentName (ds);
</I>&gt;<i>+
</I>&gt;<i>+				XmlNode n = GetDocCommentNode (mc, name);
</I>&gt;<i>+
</I>&gt;<i>+				XmlElement el = n as XmlElement;
</I>&gt;<i>+				if (el != null) {
</I>&gt;<i>+					mc.OnGenerateDocComment (ds, el);
</I>&gt;<i>+
</I>&gt;<i>+					// FIXME: it could be done with XmlReader
</I>&gt;<i>+					foreach (XmlElement inc in n.SelectNodes (&quot;.//include&quot;))
</I>&gt;<i>+						HandleInclude (mc, inc);
</I>&gt;<i>+
</I>&gt;<i>+					// FIXME: it could be done with XmlReader
</I>&gt;<i>+					DeclSpace dsTarget = mc as DeclSpace;
</I>&gt;<i>+					if (dsTarget == null)
</I>&gt;<i>+						dsTarget = ds;
</I>&gt;<i>+
</I>&gt;<i>+					foreach (XmlElement see in n.SelectNodes (&quot;.//see&quot;))
</I>&gt;<i>+						HandleSee (mc, dsTarget, name, see);
</I>&gt;<i>+					foreach (XmlElement seealso in n.SelectNodes (&quot;.//seealso&quot;))
</I>&gt;<i>+						HandleSeeAlso (mc, dsTarget, name, seealso);
</I>&gt;<i>+				}
</I>&gt;<i>+
</I>&gt;<i>+				n.WriteTo (RootContext.Documentation.XmlCommentOutput);
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (mc.IsExposedFromAssembly (ds) &amp;&amp;
</I>&gt;<i>+				// There are no warnings when the container also
</I>&gt;<i>+				// misses documentations.
</I>&gt;<i>+				(ds == null || ds.DocComment != null))
</I>&gt;<i>+			{
</I>&gt;<i>+				Report.Warning (1591, 4, mc.Location,
</I>&gt;<i>+					&quot;Missing XML comment for publicly visible type or member '{0}'&quot;, mc.GetSignatureForError ());
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Processes &quot;include&quot; element. Check included file and
</I>&gt;<i>+		// embed the document content inside this documentation node.
</I>&gt;<i>+		//
</I>&gt;<i>+		private static void HandleInclude (MemberCore mc, XmlElement el)
</I>&gt;<i>+		{
</I>&gt;<i>+			string file = el.GetAttribute (&quot;file&quot;);
</I>&gt;<i>+			string path = el.GetAttribute (&quot;path&quot;);
</I>&gt;<i>+			if (file == &quot;&quot;) {
</I>&gt;<i>+				Report.Warning (1590, 1, mc.Location, &quot;Invalid XML 'include' element; Missing 'file' attribute.&quot;);
</I>&gt;<i>+				el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (&quot; Include tag is invalid &quot;), el);
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (path == &quot;&quot;) {
</I>&gt;<i>+				Report.Warning (1590, 1, mc.Location, &quot;Invalid XML 'include' element; Missing 'path' attribute.&quot;);
</I>&gt;<i>+				el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (&quot; Include tag is invalid &quot;), el);
</I>&gt;<i>+			}
</I>&gt;<i>+			else {
</I>&gt;<i>+				XmlDocument doc = RootContext.Documentation.StoredDocuments [file] as XmlDocument;
</I>&gt;<i>+				if (doc == null) {
</I>&gt;<i>+					try {
</I>&gt;<i>+						doc = new XmlDocument ();
</I>&gt;<i>+						doc.Load (file);
</I>&gt;<i>+						RootContext.Documentation.StoredDocuments.Add (file, doc);
</I>&gt;<i>+					} catch (Exception) {
</I>&gt;<i>+						el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (String.Format (&quot; Badly formed XML in at comment file '{0}': cannot be included &quot;, file)), el);
</I>&gt;<i>+						Report.Warning (1592, 1, mc.Location, &quot;Badly formed XML in included comments file -- '{0}'&quot;, file);
</I>&gt;<i>+					}
</I>&gt;<i>+				}
</I>&gt;<i>+				bool keepIncludeNode = false;
</I>&gt;<i>+				if (doc != null) {
</I>&gt;<i>+					try {
</I>&gt;<i>+						XmlNodeList nl = doc.SelectNodes (path);
</I>&gt;<i>+						if (nl.Count == 0) {
</I>&gt;<i>+							el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (&quot; No matching elements were found for the include tag embedded here. &quot;), el);
</I>&gt;<i>+					
</I>&gt;<i>+							keepIncludeNode = true;
</I>&gt;<i>+						}
</I>&gt;<i>+						foreach (XmlNode n in nl)
</I>&gt;<i>+							el.ParentNode.InsertBefore (el.OwnerDocument.ImportNode (n, true), el);
</I>&gt;<i>+					} catch (Exception ex) {
</I>&gt;<i>+						el.ParentNode.InsertBefore (el.OwnerDocument.CreateComment (&quot; Failed to insert some or all of included XML &quot;), el);
</I>&gt;<i>+						Report.Warning (1589, 1, mc.Location, &quot;Unable to include XML fragment '{0}' of file {1} -- {2}.&quot;, path, file, ex.Message);
</I>&gt;<i>+					}
</I>&gt;<i>+				}
</I>&gt;<i>+				if (!keepIncludeNode)
</I>&gt;<i>+					el.ParentNode.RemoveChild (el);
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Handles &lt;see&gt; elements.
</I>&gt;<i>+		//
</I>&gt;<i>+		private static void HandleSee (MemberCore mc,
</I>&gt;<i>+			DeclSpace ds, string name, XmlElement see)
</I>&gt;<i>+		{
</I>&gt;<i>+			HandleXrefCommon (mc, ds, name, see);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Handles &lt;seealso&gt; elements.
</I>&gt;<i>+		//
</I>&gt;<i>+		private static void HandleSeeAlso (MemberCore mc,
</I>&gt;<i>+			DeclSpace ds, string name, XmlElement seealso)
</I>&gt;<i>+		{
</I>&gt;<i>+			HandleXrefCommon (mc, ds, name, seealso);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		static readonly char [] wsChars =
</I>&gt;<i>+			new char [] {' ', '\t', '\n', '\r'};
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// returns a full runtime type name from a name which might
</I>&gt;<i>+		// be C# specific type name.
</I>&gt;<i>+		//
</I>&gt;<i>+		private static Type FindDocumentedType (MemberCore mc,
</I>&gt;<i>+			string identifier, DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			switch (identifier) {
</I>&gt;<i>+			case &quot;int&quot;:
</I>&gt;<i>+				return typeof (int);
</I>&gt;<i>+			case &quot;uint&quot;:
</I>&gt;<i>+				return typeof (uint);
</I>&gt;<i>+			case &quot;short&quot;:
</I>&gt;<i>+				return typeof (short);
</I>&gt;<i>+			case &quot;ushort&quot;:
</I>&gt;<i>+				return typeof (ushort);
</I>&gt;<i>+			case &quot;long&quot;:
</I>&gt;<i>+				return typeof (long);
</I>&gt;<i>+			case &quot;ulong&quot;:
</I>&gt;<i>+				return typeof (ulong);
</I>&gt;<i>+			case &quot;float&quot;:
</I>&gt;<i>+				return typeof (float);
</I>&gt;<i>+			case &quot;double&quot;:
</I>&gt;<i>+				return typeof (double);
</I>&gt;<i>+			case &quot;char&quot;:
</I>&gt;<i>+				return typeof (char);
</I>&gt;<i>+			case &quot;decimal&quot;:
</I>&gt;<i>+				return typeof (decimal);
</I>&gt;<i>+			case &quot;byte&quot;:
</I>&gt;<i>+				return typeof (byte);
</I>&gt;<i>+			case &quot;sbyte&quot;:
</I>&gt;<i>+				return typeof (sbyte);
</I>&gt;<i>+			case &quot;object&quot;:
</I>&gt;<i>+				return typeof (object);
</I>&gt;<i>+			case &quot;bool&quot;:
</I>&gt;<i>+				return typeof (bool);
</I>&gt;<i>+			case &quot;string&quot;:
</I>&gt;<i>+				return typeof (string);
</I>&gt;<i>+			case &quot;void&quot;:
</I>&gt;<i>+				return typeof (void);
</I>&gt;<i>+			}
</I>&gt;<i>+			return ds.FindType (mc.Location, identifier);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Returns a MemberInfo that is referenced in XML documentation
</I>&gt;<i>+		// (by &quot;see&quot; or &quot;seealso&quot; elements).
</I>&gt;<i>+		//
</I>&gt;<i>+		private static MemberInfo FindDocumentedMember (MemberCore mc,
</I>&gt;<i>+			Type type, string memberName, Type [] paramList, 
</I>&gt;<i>+			DeclSpace ds, out int warningType, string cref)
</I>&gt;<i>+		{
</I>&gt;<i>+			warningType = 0;
</I>&gt;<i>+			MethodSignature msig = new MethodSignature (memberName, null, paramList);
</I>&gt;<i>+			MemberInfo [] mis = type.FindMembers (
</I>&gt;<i>+				MemberTypes.All,
</I>&gt;<i>+				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
</I>&gt;<i>+				MethodSignature.method_signature_filter,
</I>&gt;<i>+				msig);
</I>&gt;<i>+			if (mis.Length &gt; 0)
</I>&gt;<i>+				return mis [0];
</I>&gt;<i>+
</I>&gt;<i>+			if (paramList.Length == 0) {
</I>&gt;<i>+				// search for fields/events etc.
</I>&gt;<i>+				mis = type.FindMembers (
</I>&gt;<i>+					MemberTypes.All,
</I>&gt;<i>+					BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance,
</I>&gt;<i>+					Type.FilterName,
</I>&gt;<i>+					memberName);
</I>&gt;<i>+				return (mis.Length &gt; 0) ? mis [0] : null;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			// search for operators (whose parameters exactly
</I>&gt;<i>+			// matches with the list) and possibly report CS1581.
</I>&gt;<i>+			string oper = null;
</I>&gt;<i>+			string returnTypeName = null;
</I>&gt;<i>+			if (memberName.StartsWith (&quot;implicit operator &quot;)) {
</I>&gt;<i>+				oper = &quot;op_Implicit&quot;;
</I>&gt;<i>+				returnTypeName = memberName.Substring (18).Trim (wsChars);
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (memberName.StartsWith (&quot;explicit operator &quot;)) {
</I>&gt;<i>+				oper = &quot;op_Explicit&quot;;
</I>&gt;<i>+				returnTypeName = memberName.Substring (18).Trim (wsChars);
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (memberName.StartsWith (&quot;operator &quot;)) {
</I>&gt;<i>+				oper = memberName.Substring (9).Trim (wsChars);
</I>&gt;<i>+				switch (oper) {
</I>&gt;<i>+				// either unary or binary
</I>&gt;<i>+				case &quot;+&quot;:
</I>&gt;<i>+					oper = paramList.Length == 2 ?
</I>&gt;<i>+						Binary.oper_names [(int) Binary.Operator.Addition] :
</I>&gt;<i>+						Unary.oper_names [(int) Unary.Operator.UnaryPlus];
</I>&gt;<i>+					break;
</I>&gt;<i>+				case &quot;-&quot;:
</I>&gt;<i>+					oper = paramList.Length == 2 ?
</I>&gt;<i>+						Binary.oper_names [(int) Binary.Operator.Subtraction] :
</I>&gt;<i>+						Unary.oper_names [(int) Unary.Operator.UnaryNegation];
</I>&gt;<i>+					break;
</I>&gt;<i>+				// unary
</I>&gt;<i>+				case &quot;!&quot;:
</I>&gt;<i>+					oper = Unary.oper_names [(int) Unary.Operator.LogicalNot]; break;
</I>&gt;<i>+				case &quot;~&quot;:
</I>&gt;<i>+					oper = Unary.oper_names [(int) Unary.Operator.OnesComplement]; break;
</I>&gt;<i>+					
</I>&gt;<i>+				case &quot;++&quot;:
</I>&gt;<i>+					oper = &quot;op_Increment&quot;; break;
</I>&gt;<i>+				case &quot;--&quot;:
</I>&gt;<i>+					oper = &quot;op_Decrement&quot;; break;
</I>&gt;<i>+				case &quot;true&quot;:
</I>&gt;<i>+					oper = &quot;op_True&quot;; break;
</I>&gt;<i>+				case &quot;false&quot;:
</I>&gt;<i>+					oper = &quot;op_False&quot;; break;
</I>&gt;<i>+				// binary
</I>&gt;<i>+				case &quot;*&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Multiply]; break;
</I>&gt;<i>+				case &quot;/&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Division]; break;
</I>&gt;<i>+				case &quot;%&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Modulus]; break;
</I>&gt;<i>+				case &quot;&amp;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.BitwiseAnd]; break;
</I>&gt;<i>+				case &quot;|&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.BitwiseOr]; break;
</I>&gt;<i>+				case &quot;^&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.ExclusiveOr]; break;
</I>&gt;<i>+				case &quot;&lt;&lt;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.LeftShift]; break;
</I>&gt;<i>+				case &quot;&gt;&gt;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.RightShift]; break;
</I>&gt;<i>+				case &quot;==&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Equality]; break;
</I>&gt;<i>+				case &quot;!=&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.Inequality]; break;
</I>&gt;<i>+				case &quot;&lt;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.LessThan]; break;
</I>&gt;<i>+				case &quot;&gt;&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.GreaterThan]; break;
</I>&gt;<i>+				case &quot;&lt;=&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.LessThanOrEqual]; break;
</I>&gt;<i>+				case &quot;&gt;=&quot;:
</I>&gt;<i>+					oper = Binary.oper_names [(int) Binary.Operator.GreaterThanOrEqual]; break;
</I>&gt;<i>+				default:
</I>&gt;<i>+					warningType = 1584;
</I>&gt;<i>+					Report.Warning (1020, 1, mc.Location, &quot;Overloadable {0} operator is expected&quot;, paramList.Length == 2 ? &quot;binary&quot; : &quot;unary&quot;);
</I>&gt;<i>+					Report.Warning (1584, 1, mc.Location, &quot;XML comment on '{0}' has syntactically incorrect attribute '{1}'&quot;, mc.GetSignatureForError (), cref);
</I>&gt;<i>+					return null;
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+			// here we still does not consider return type (to
</I>&gt;<i>+			// detect CS1581 or CS1002+CS1584).
</I>&gt;<i>+			msig = new MethodSignature (oper, null, paramList);
</I>&gt;<i>+			mis = type.FindMembers (
</I>&gt;<i>+				MemberTypes.Method,
</I>&gt;<i>+				BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static,
</I>&gt;<i>+				MethodSignature.method_signature_filter,
</I>&gt;<i>+				msig);
</I>&gt;<i>+			if (mis.Length == 0)
</I>&gt;<i>+				return null; // CS1574
</I>&gt;<i>+			MemberInfo mi = mis [0];
</I>&gt;<i>+			Type expected = mi is MethodInfo ?
</I>&gt;<i>+				((MethodInfo) mi).ReturnType :
</I>&gt;<i>+				mi is PropertyInfo ?
</I>&gt;<i>+				((PropertyInfo) mi).PropertyType :
</I>&gt;<i>+				null;
</I>&gt;<i>+			if (returnTypeName != null) {
</I>&gt;<i>+				Type returnType = FindDocumentedType (mc, returnTypeName, ds);
</I>&gt;<i>+				if (returnType == null || returnType != expected) {
</I>&gt;<i>+					warningType = 1581;
</I>&gt;<i>+					Report.Warning (1581, 1, mc.Location, &quot;Invalid return type in XML comment cref attribute '{0}'&quot;, cref);
</I>&gt;<i>+					return null;
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+			return mis [0];
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		private static Type [] emptyParamList = new Type [0];
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Processes &quot;see&quot; or &quot;seealso&quot; elements.
</I>&gt;<i>+		// Checks cref attribute.
</I>&gt;<i>+		//
</I>&gt;<i>+		private static void HandleXrefCommon (MemberCore mc,
</I>&gt;<i>+			DeclSpace ds, string name, XmlElement xref)
</I>&gt;<i>+		{
</I>&gt;<i>+			string cref = xref.GetAttribute (&quot;cref&quot;).Trim (wsChars);
</I>&gt;<i>+			// when, XmlReader, &quot;if (cref == null)&quot;
</I>&gt;<i>+			if (!xref.HasAttribute (&quot;cref&quot;))
</I>&gt;<i>+				return;
</I>&gt;<i>+			if (cref.Length == 0)
</I>&gt;<i>+				Report.Warning (1001, 1, mc.Location, &quot;Identifier expected&quot;);
</I>&gt;<i>+				// ... and continue until CS1584.
</I>&gt;<i>+
</I>&gt;<i>+			string signature, identifier, parameters;
</I>&gt;<i>+
</I>&gt;<i>+			// strip 'T:' 'M:' 'F:' 'P:' 'E:' etc.
</I>&gt;<i>+			// Here, MS ignores its member kind. No idea why.
</I>&gt;<i>+			if (cref.Length &gt; 2 &amp;&amp; cref [1] == ':')
</I>&gt;<i>+				signature = cref.Substring (2).Trim (wsChars);
</I>&gt;<i>+			else
</I>&gt;<i>+				signature = cref;
</I>&gt;<i>+
</I>&gt;<i>+			int parensPos = signature.IndexOf ('(');
</I>&gt;<i>+			if (parensPos &gt; 0 &amp;&amp; signature [signature.Length - 1] == ')') {
</I>&gt;<i>+				identifier = signature.Substring (0, parensPos).Trim (wsChars);
</I>&gt;<i>+				parameters = signature.Substring (parensPos + 1, signature.Length - parensPos - 2);
</I>&gt;<i>+			}
</I>&gt;<i>+			else {
</I>&gt;<i>+				identifier = signature;
</I>&gt;<i>+				parameters = String.Empty;
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			string alias = ds.LookupAlias (identifier);
</I>&gt;<i>+			if (alias != null)
</I>&gt;<i>+				identifier = alias;
</I>&gt;<i>+
</I>&gt;<i>+			// Check if identifier is valid.
</I>&gt;<i>+			// This check is not necessary to mark as error, but
</I>&gt;<i>+			// csc specially reports CS1584 for wrong identifiers.
</I>&gt;<i>+			foreach (string nameElem in identifier.Split ('.')) {
</I>&gt;<i>+				if (!Tokenizer.IsValidIdentifier (nameElem) &amp;&amp; nameElem.IndexOf (&quot;operator&quot;) &lt; 0) {
</I>&gt;<i>+					Report.Warning (1584, 1, mc.Location, &quot;XML comment on '{0}' has syntactically incorrect attribute '{1}'&quot;, mc.GetSignatureForError (), cref);
</I>&gt;<i>+					xref.SetAttribute (&quot;cref&quot;, &quot;!:&quot; + signature);
</I>&gt;<i>+					return;
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			// check if parameters are valid
</I>&gt;<i>+			Type [] parameterTypes = emptyParamList;
</I>&gt;<i>+			if (parameters.Length &gt; 0) {
</I>&gt;<i>+				string [] paramList = parameters.Split (',');
</I>&gt;<i>+				ArrayList plist = new ArrayList ();
</I>&gt;<i>+				for (int i = 0; i &lt; paramList.Length; i++) {
</I>&gt;<i>+					string paramTypeName = paramList [i].Trim (wsChars);
</I>&gt;<i>+					alias = ds.LookupAlias (paramTypeName);
</I>&gt;<i>+					if (alias != null)
</I>&gt;<i>+						paramTypeName = alias;
</I>&gt;<i>+					Type paramType = FindDocumentedType (mc, paramTypeName, ds);
</I>&gt;<i>+					if (paramType == null) {
</I>&gt;<i>+						Report.Warning (1580, 1, mc.Location, &quot;Invalid type for parameter '{0}' in XML comment cref attribute '{1}'&quot;, i + 1, cref);
</I>&gt;<i>+						return;
</I>&gt;<i>+					}
</I>&gt;<i>+					plist.Add (paramType);
</I>&gt;<i>+				}
</I>&gt;<i>+				parameterTypes = plist.ToArray (typeof (Type)) as Type [];
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			Type type = FindDocumentedType (mc, identifier, ds);
</I>&gt;<i>+			if (type != null) {
</I>&gt;<i>+				xref.SetAttribute (&quot;cref&quot;, &quot;T:&quot; + type.FullName.Replace (&quot;+&quot;, &quot;.&quot;));
</I>&gt;<i>+				return; // a type
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			int period = identifier.LastIndexOf ('.');
</I>&gt;<i>+			if (period &gt; 0) {
</I>&gt;<i>+				string typeName = identifier.Substring (0, period);
</I>&gt;<i>+				string memberName = identifier.Substring (period + 1);
</I>&gt;<i>+				type = FindDocumentedType (mc, typeName, ds);
</I>&gt;<i>+				int warnResult;
</I>&gt;<i>+				if (type != null) {
</I>&gt;<i>+					MemberInfo mi = FindDocumentedMember (mc, type, memberName, parameterTypes, ds, out warnResult, cref);
</I>&gt;<i>+					if (warnResult &gt; 0)
</I>&gt;<i>+						return;
</I>&gt;<i>+					if (mi != null) {
</I>&gt;<i>+						xref.SetAttribute (&quot;cref&quot;, GetMemberDocHead (mi.MemberType) + type.FullName.Replace (&quot;+&quot;, &quot;.&quot;) + &quot;.&quot; + memberName);
</I>&gt;<i>+						return; // a member of a type
</I>&gt;<i>+					}
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+			else {
</I>&gt;<i>+				int warnResult;
</I>&gt;<i>+				MemberInfo mi = FindDocumentedMember (mc, ds.TypeBuilder, identifier, parameterTypes, ds, out warnResult, cref);
</I>&gt;<i>+				if (warnResult &gt; 0)
</I>&gt;<i>+					return;
</I>&gt;<i>+				if (mi != null) {
</I>&gt;<i>+					xref.SetAttribute (&quot;cref&quot;, GetMemberDocHead (mi.MemberType) + ds.TypeBuilder.FullName.Replace (&quot;+&quot;, &quot;.&quot;) + &quot;.&quot; + identifier);
</I>&gt;<i>+					return; // local member name
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+
</I>&gt;<i>+			Report.Warning (1574, 1, mc.Location, &quot;XML comment on '{0}' has cref attribute '{1}' that could not be resolved in '{2}'.&quot;, mc.GetSignatureForError (), cref, ds.GetSignatureForError ());
</I>&gt;<i>+
</I>&gt;<i>+			xref.SetAttribute (&quot;cref&quot;, &quot;!:&quot; + identifier);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Get a prefix from member type for XML documentation (used
</I>&gt;<i>+		// to formalize cref target name).
</I>&gt;<i>+		//
</I>&gt;<i>+		static string GetMemberDocHead (MemberTypes type)
</I>&gt;<i>+		{
</I>&gt;<i>+			switch (type) {
</I>&gt;<i>+			case MemberTypes.Constructor:
</I>&gt;<i>+			case MemberTypes.Method:
</I>&gt;<i>+				return &quot;M:&quot;;
</I>&gt;<i>+			case MemberTypes.Event:
</I>&gt;<i>+				return &quot;E:&quot;;
</I>&gt;<i>+			case MemberTypes.Field:
</I>&gt;<i>+				return &quot;F:&quot;;
</I>&gt;<i>+			case MemberTypes.NestedType:
</I>&gt;<i>+			case MemberTypes.TypeInfo:
</I>&gt;<i>+				return &quot;T:&quot;;
</I>&gt;<i>+			case MemberTypes.Property:
</I>&gt;<i>+				return &quot;P:&quot;;
</I>&gt;<i>+			}
</I>&gt;<i>+			return &quot;!:&quot;;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		// MethodCore
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Returns a string that represents the signature for this 
</I>&gt;<i>+		// member which should be used in XML documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		public static string GetMethodDocCommentName (MethodCore mc, DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			Parameter [] plist = mc.Parameters.FixedParameters;
</I>&gt;<i>+			Parameter parr = mc.Parameters.ArrayParameter;
</I>&gt;<i>+			string paramSpec = String.Empty;
</I>&gt;<i>+			if (plist != null) {
</I>&gt;<i>+				StringBuilder psb = new StringBuilder ();
</I>&gt;<i>+				foreach (Parameter p in plist) {
</I>&gt;<i>+					psb.Append (psb.Length != 0 ? &quot;,&quot; : &quot;(&quot;);
</I>&gt;<i>+					psb.Append (p.ParameterType.FullName.Replace (&quot;+&quot;, &quot;.&quot;));
</I>&gt;<i>+				}
</I>&gt;<i>+				psb.Append (&quot;)&quot;);
</I>&gt;<i>+				paramSpec = psb.ToString ();
</I>&gt;<i>+			}
</I>&gt;<i>+			else if (parr != null)
</I>&gt;<i>+				paramSpec = String.Concat (
</I>&gt;<i>+					&quot;(&quot;,
</I>&gt;<i>+					parr.ParameterType.FullName.Replace (&quot;+&quot;, &quot;.&quot;),
</I>&gt;<i>+					&quot;)&quot;);
</I>&gt;<i>+
</I>&gt;<i>+			string name = mc is Constructor ? &quot;#ctor&quot; : mc.Name;
</I>&gt;<i>+			return String.Concat (mc.DocCommentHeader, ds.Name, &quot;.&quot;, name, paramSpec);
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Raised (and passed an XmlElement that contains the comment)
</I>&gt;<i>+		// when GenerateDocComment is writing documentation expectedly.
</I>&gt;<i>+		//
</I>&gt;<i>+		// FIXME: with a few effort, it could be done with XmlReader,
</I>&gt;<i>+		// that means removal of DOM use.
</I>&gt;<i>+		//
</I>&gt;<i>+		internal static void OnMethodGenerateDocComment (
</I>&gt;<i>+			MethodCore mc, DeclSpace ds, XmlElement el)
</I>&gt;<i>+		{
</I>&gt;<i>+			Hashtable paramTags = new Hashtable ();
</I>&gt;<i>+			foreach (XmlElement pelem in el.SelectNodes (&quot;param&quot;)) {
</I>&gt;<i>+				int i;
</I>&gt;<i>+				string xname = pelem.GetAttribute (&quot;name&quot;);
</I>&gt;<i>+				if (xname == &quot;&quot;)
</I>&gt;<i>+					continue; // really? but MS looks doing so
</I>&gt;<i>+				if (xname != &quot;&quot; &amp;&amp; mc.Parameters.GetParameterByName (xname, out i) == null)
</I>&gt;<i>+					Report.Warning (1572, 2, mc.Location, &quot;XML comment on '{0}' has a 'param' tag for '{1}', but there is no such parameter.&quot;, mc.Name, xname);
</I>&gt;<i>+				else if (paramTags [xname] != null)
</I>&gt;<i>+					Report.Warning (1571, 2, mc.Location, &quot;XML comment on '{0}' has a duplicate param tag for '{1}'&quot;, mc.Name, xname);
</I>&gt;<i>+				paramTags [xname] = xname;
</I>&gt;<i>+			}
</I>&gt;<i>+			Parameter [] plist = mc.Parameters.FixedParameters;
</I>&gt;<i>+			Parameter parr = mc.Parameters.ArrayParameter;
</I>&gt;<i>+			if (plist != null) {
</I>&gt;<i>+				foreach (Parameter p in plist) {
</I>&gt;<i>+					if (paramTags.Count &gt; 0 &amp;&amp; paramTags [p.Name] == null)
</I>&gt;<i>+						Report.Warning (1573, 4, mc.Location, &quot;Parameter '{0}' has no matching param tag in the XML comment for '{1}' (but other parameters do)&quot;, mc.Name, p.Name);
</I>&gt;<i>+				}
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		// Enum
</I>&gt;<i>+		public static void GenerateEnumDocComment (Enum e, DeclSpace ds)
</I>&gt;<i>+		{
</I>&gt;<i>+			GenerateDocComment (e, ds);
</I>&gt;<i>+			foreach (string name in e.ordered_enums) {
</I>&gt;<i>+				MemberCore mc = e.GetDefinition (name);
</I>&gt;<i>+				GenerateDocComment (mc, e);
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+	}
</I>&gt;<i>+
</I>&gt;<i>+	//
</I>&gt;<i>+	// Implements XML documentation generation.
</I>&gt;<i>+	//
</I>&gt;<i>+	public class Documentation
</I>&gt;<i>+	{
</I>&gt;<i>+		public Documentation ()
</I>&gt;<i>+		{
</I>&gt;<i>+			XmlDocumentation = new XmlDocument ();
</I>&gt;<i>+			XmlDocumentation.PreserveWhitespace = false;
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Used to create element which helps well-formedness checking.
</I>&gt;<i>+		//
</I>&gt;<i>+		public XmlDocument XmlDocumentation;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// The output for XML documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		public XmlWriter XmlCommentOutput;
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Stores XmlDocuments that are included in XML documentation.
</I>&gt;<i>+		//
</I>&gt;<i>+		public Hashtable StoredDocuments = new Hashtable ();
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Outputs XML documentation comment from tokenized comments.
</I>&gt;<i>+		//
</I>&gt;<i>+		public bool OutputDocComment (
</I>&gt;<i>+			TypeContainer root,
</I>&gt;<i>+			string asmfilename,
</I>&gt;<i>+			string docfilename)
</I>&gt;<i>+		{
</I>&gt;<i>+			XmlTextWriter w = null;
</I>&gt;<i>+			try {
</I>&gt;<i>+				w = new XmlTextWriter (docfilename, null);
</I>&gt;<i>+				w.Indentation = 4;
</I>&gt;<i>+				w.Formatting = Formatting.Indented;
</I>&gt;<i>+				w.WriteStartDocument ();
</I>&gt;<i>+				w.WriteStartElement (&quot;doc&quot;);
</I>&gt;<i>+				w.WriteStartElement (&quot;assembly&quot;);
</I>&gt;<i>+				w.WriteStartElement (&quot;name&quot;);
</I>&gt;<i>+				w.WriteString (Path.ChangeExtension (asmfilename, null));
</I>&gt;<i>+				w.WriteEndElement (); // name
</I>&gt;<i>+				w.WriteEndElement (); // assembly
</I>&gt;<i>+				w.WriteStartElement (&quot;members&quot;);
</I>&gt;<i>+				XmlCommentOutput = w;
</I>&gt;<i>+				GenerateDocComment (root);
</I>&gt;<i>+				w.WriteFullEndElement (); // members
</I>&gt;<i>+				w.WriteEndElement ();
</I>&gt;<i>+				w.WriteWhitespace (Environment.NewLine);
</I>&gt;<i>+				w.WriteEndDocument ();
</I>&gt;<i>+				return true;
</I>&gt;<i>+			} catch (Exception ex) {
</I>&gt;<i>+				Report.Error (1569, &quot;Error generating XML documentation file '{0}' ('{1}')&quot;, docfilename, ex.Message);
</I>&gt;<i>+				return false;
</I>&gt;<i>+			} finally {
</I>&gt;<i>+				if (w != null)
</I>&gt;<i>+					w.Close ();
</I>&gt;<i>+			}
</I>&gt;<i>+		}
</I>&gt;<i>+
</I>&gt;<i>+		//
</I>&gt;<i>+		// Fixes full type name of each documented types/members up.
</I>&gt;<i>+		//
</I>&gt;<i>+		public void GenerateDocComment (TypeContainer root)
</I>&gt;<i>+		{
</I>&gt;<i>+			if (root.Interfaces != null)
</I>&gt;<i>+				foreach (Interface i in root.Interfaces) 
</I>&gt;<i>+					DocUtil.GenerateTypeDocComment (i, null);
</I>&gt;<i>+
</I>&gt;<i>+			foreach (TypeContainer tc in root.Types)
</I>&gt;<i>+				DocUtil.GenerateTypeDocComment (tc, null);
</I>&gt;<i>+
</I>&gt;<i>+			if (root.Delegates != null)
</I>&gt;<i>+				foreach (Delegate d in root.Delegates) 
</I>&gt;<i>+					DocUtil.GenerateDocComment (d, null);
</I>&gt;<i>+
</I>&gt;<i>+			if (root.Enums != null)
</I>&gt;<i>+				foreach (Enum e in root.Enums)
</I>&gt;<i>+					DocUtil.GenerateEnumDocComment (e, null);
</I>&gt;<i>+		}
</I>&gt;<i>+	}
</I>&gt;<i>+}
</I>&gt;<i>
</I>&gt;<i>Property changes on: doc.cs
</I>&gt;<i>___________________________________________________________________
</I>&gt;<i>Name: svn:executable
</I>&gt;<i>   + *
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009161.html">[Mono-devel-list] Patch for full-featured mcs /doc support
</A></li>
	<LI>Next message: <A HREF="009176.html">[Mono-devel-list] Patch for full-featured mcs /doc support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9164">[ date ]</a>
              <a href="thread.html#9164">[ thread ]</a>
              <a href="subject.html#9164">[ subject ]</a>
              <a href="author.html#9164">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
