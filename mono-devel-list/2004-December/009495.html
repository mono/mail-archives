<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] using mono to write a linux gui
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20using%20mono%20to%20write%20a%20linux%20gui&In-Reply-To=20041218012946.5771.qmail%40web51904.mail.yahoo.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009492.html">
   <LINK REL="Next"  HREF="009509.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] using mono to write a linux gui</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20using%20mono%20to%20write%20a%20linux%20gui&In-Reply-To=20041218012946.5771.qmail%40web51904.mail.yahoo.com"
       TITLE="[Mono-devel-list] using mono to write a linux gui">jonpryor at vt.edu
       </A><BR>
    <I>Sat Dec 18 09:08:26 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="009492.html">[Mono-devel-list] using mono to write a linux gui
</A></li>
        <LI>Next message: <A HREF="009509.html">[Mono-devel-list] using mono to write a linux gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9495">[ date ]</a>
              <a href="thread.html#9495">[ thread ]</a>
              <a href="subject.html#9495">[ subject ]</a>
              <a href="author.html#9495">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, 2004-12-17 at 17:29 -0800, Michael Geis wrote:
&gt;<i> Thanks, Jon that was a lot of useful info.
</I>&gt;<i> Let me try to put this together terms of the options this boils down
</I>&gt;<i> to.
</I>&gt;<i>  
</I>&gt;<i> 1) The simple option to stay within C++ and use gtkmm. 
</I>&gt;<i>  
</I>&gt;<i> 2) If I wanted to use mono for gtk# or Qt#, there seem to be two ways:
</I>&gt;<i>  
</I>&gt;<i> a) Keep it all under linux. This means wrapping with swig and using
</I>&gt;<i> DllImport in C#. It may be some effort but pretty much seems to be
</I>&gt;<i> guaranteed to work.
</I>&gt;<i>  
</I>&gt;<i> b)Compile my code into CIL under Windows. Problem: It might contain
</I>&gt;<i> sections of native code, that might not run under linux. Is that still
</I>&gt;<i> possible if my code does not contain any VC++ features (it
</I>&gt;<i> does compile under gcc)? This difficulty would be solved by Whidbey,
</I>&gt;<i> though. Is that correct?
</I>
Ensuring that all your code compiles under both VC++ and GCC is the best
way to make this approach *not* work.  Fail dismally, in fact.

The key idea behind approach (2.b) is that you create a managed assembly
in C++ which is then used by C# for the GUI.  Seems simple enough.  The
unfortunate reality is that even if your code compiles down to pure IL
(no native code, etc.), the default visibility for all types created by
VC are &quot;internal&quot;.

Translation: sure, you can create a purely managed assembly, but your C#
code wouldn't be able to use that assembly since no types would be
exported.  Oops.

If you want the types to be exported from the assembly, you need to
explicitly specify that, such as with a &quot;public class&quot; declaration.  You
could make the &quot;public&quot; conditional on VC to maintain portability with
GCC.

However, you'll likely also want to simplify your C# code, by
integrating the C++ assembly into the CLI as much as possible (by using
the standard collection interfaces, IDisposable idiom, etc.).  This will
require dropping portability with GCC, since GCC can't do any of that.

You could structure your code so that you have C++/CLI wrapping the
standard C++ code which remains portable between VC and GCC.  I've done
this before, it's not very difficult.  This may or may not be an option
for you, though.

Then you'll have the decision of whether to stick with the currently
shipping Managed Extensions for C++ (ugly as sin), or get a hold of one
of the VS betas and use C++/CLI (which I like the more I read about it).

Also, just because your code doesn't use any VC-specific functionality
doesn't mean that it can be compiled to pure IL.  It's purely dependent
upon how you use the language -- certain language constructs may require
unmanaged code, or use of printf(3).  I'm not an expert, though, and can
only conjecture on this issue.
 
&gt;<i> Suppose I made it that far. If I wanted to develop with C#, both
</I>&gt;<i> Windows and mono are candidates. But mono does not support C++/CIL, so
</I>&gt;<i> if I wanted to stay with C++ only, I
</I>&gt;<i> would have to code under Windows.
</I>
This is correct.  If you want managed C++ code, you're stuck on Windows.
 
&gt;<i> Did I understand you properly?
</I>&gt;<i>  
</I>&gt;<i> A final point: Are gtk# and qt# still an option in C++/CIL. In
</I>&gt;<i> otherwords, does that sharp imply that they can only be used withon
</I>&gt;<i> C#?
</I>
No, the '#' means &quot;managed&quot;.  Gtk# can be used from any managed language
-- C#, VB.NET, Nermerle, JavaScript.NET, etc...  C++/CLI should be able
to use it as well as any other managed language.
 
 - Jon



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009492.html">[Mono-devel-list] using mono to write a linux gui
</A></li>
	<LI>Next message: <A HREF="009509.html">[Mono-devel-list] using mono to write a linux gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9495">[ date ]</a>
              <a href="thread.html#9495">[ thread ]</a>
              <a href="subject.html#9495">[ subject ]</a>
              <a href="author.html#9495">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
