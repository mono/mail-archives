<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-devel-list] RAPGO Proposal
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20RAPGO%20Proposal&In-Reply-To=20041130145225.GY2153%40debian.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009181.html">
   <LINK REL="Next"  HREF="009168.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-devel-list] RAPGO Proposal</H1>
    <B>Willibald Krenn</B> 
    <A HREF="mailto:mono-devel-list%40lists.ximian.com?Subject=%5BMono-devel-list%5D%20RAPGO%20Proposal&In-Reply-To=20041130145225.GY2153%40debian.org"
       TITLE="[Mono-devel-list] RAPGO Proposal">Willibald.Krenn at gmx.at
       </A><BR>
    <I>Wed Dec  1 10:23:07 EST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="009181.html">[Mono-devel-list] SSAPRE news
</A></li>
        <LI>Next message: <A HREF="009168.html">[Mono-devel-list] Question vtable
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9167">[ date ]</a>
              <a href="thread.html#9167">[ thread ]</a>
              <a href="subject.html#9167">[ subject ]</a>
              <a href="author.html#9167">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Paolo Molaro schrieb:
&gt;<i> On 11/29/04 Willibald Krenn wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i>Paolo Molaro schrieb:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>Described in the summit notes: the code is not in cvs yet.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Any idea when this code will hit cvs? (I was aware of the notes, but 
</I>&gt;&gt;<i>that doesn't show me how it is done, etc. ..)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> As soon as it's ready.
</I>
Ok - standard answer. Could you possibly post a small message on this 
list, when you've checked it in? Would be very much appreciated... Thanks.


&gt;<i> A lot, note you'll need atomic counters to be thread safe etc.
</I>
Yes, that's the crux. On non-smp machines it would be marvellous if 
there were some process-shared register set, so you'd just have to 
inc/dec one register.. :-)


&gt;<i> Well, there are two ways to deal with branches here:
</I>&gt;<i> *) sampling the ip will find that the basic blocks executed will have samples
</I>&gt;<i> (or many more samples), while the not taken branch will end up in basic blocks
</I>&gt;<i> that don't have or have few hits.
</I>
Yes, but you need to be careful in choosing the sampling frq. (AFAIK it 
should also be kinda random, to improve measurements) in order to narrow 
the error-margin and get usable results.
Plus: Too much sampling data will slow down calculations too, so some 
careful design has to be made here.
I'd prefer to instrument one method at once for optimizations like 
this.. (But that's just a feeling, of course I can be wrong)

&gt;<i> *) using the performance counters in modern processors may provide the info
</I>&gt;<i> directly
</I>
I'll look into this a bit more, but AFAIK performance counters are 
somewhat limited (in size and number) and you need a patched Linux 
kernel in order to get process-only perfctrs. (There are some other 
issues as well, IIRC; privileged instructions?)
At last you get unwanted side-effects with other profilers when using 
perfctrs for your own measurements if the kernel doesn't know how to 
'share' these counters.
BTW: For interrup-on-overflow you certainly need a kernel module.

&gt;<i> As for access patterns, the second solution may help as well. I agree
</I>&gt;<i> for some things some embedded code may need to be emitted: it's just that 
</I>&gt;<i> in general I think we should avoid it.
</I>
I guess it's like in economy: Only if the possible achievable benefit 
outreaches the investment, it should be considered to be done at all.
(And perhaps only one method per thread at once, or so)

  BTW, there is people who did already
&gt;<i> that sort of optimization with mono (optimizing the code based on the
</I>&gt;<i> access patterns to arrays): I don't know if the paper has been already 
</I>&gt;<i> published, though.
</I>
That's news to me.. Any idea of the title/who did it?

&gt;&gt;<i>AFAIK the peephole optimizer works on a small set of opcodes. So adding 
</I>&gt;&gt;<i>a peephole pass would still be possible.. But of course you end up 
</I>&gt;&gt;<i>having a small memory buffer for it and touching each opcode twice again..
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Yes, and thus make the code unreadable and unmaintainable which we don't 
</I>&gt;<i> want to do.
</I>
Yea :-&gt;
Mono already has enough code like this in it's code base...

(e.g. Macros that implicitely assume to be placed in some special block 
of code, field names that have misleading names, files that are stuffed 
up with all sorts of functions, directories cluttered with files that 
belong to different libraries...)


&gt;<i> The 'basic set' as you call it is:
</I>&gt;<i> $ ls -s /usr/lib/libstdc++.so.5.0.7 
</I>&gt;<i> 728 /usr/lib/libstdc++.so.5.0.7
</I>&gt;<i> 
</I>&gt;<i> That's in kilobytes.
</I>
Well, on desktop computers that doesn't do much. (And as it's on disk in 
any case on these machines, only free-RAM would 'suffer'.)

&gt;<i> It also forces mono to depend on the C++ ABI, so it breaks each time
</I>&gt;<i> the C++ ABI changes. So it's a lot of baggage for very little benefit.
</I>
As I know habits of Linux developers a little bit by now, I would say 
that's a very valid point. :-)


&gt;&gt;<i>Doesn't like that, but'll stick to it.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Note: if you prefer writing the code in C++ for your thesis it's fine,
</I>&gt;<i> it's just that we can't add it to the main tree.
</I>
That would not be very constructive, would it? No, I'll do some sort of 
objective C. Virtual methods are gonna be fun:

#define NonPolyMethodCall(c,a,b, ...) c##b (a, ##__VA_ARGS__)
#define AnObjectMethodCall(a,b, ...) NonPolyMethodCall(AnObject_,a,b, 
##__VA_ARGS__)
#define VirtualMethodCall(a,b, ...) ((a)-&gt;b)(a, ##__VA_ARGS__)

VirtualMethodCall(pMyObject,AMethod,params);
calls: (pMyObject-&gt;AMethod)(pMyObject,params);

AnObjectMethodCall(pMyObject,AnotherMethod,params);
calls: AnObject_AnotherMethod(pMyObject,params);


Would that be ok?


Thanks,
   Willi


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009181.html">[Mono-devel-list] SSAPRE news
</A></li>
	<LI>Next message: <A HREF="009168.html">[Mono-devel-list] Question vtable
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9167">[ date ]</a>
              <a href="thread.html#9167">[ thread ]</a>
              <a href="subject.html#9167">[ subject ]</a>
              <a href="author.html#9167">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-devel-list">More information about the Mono-devel-list
mailing list</a><br>
</body></html>
