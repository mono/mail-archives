<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-devel] Working on the monodevelop dom after 2.2
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Working%20on%20the%20monodevelop%20dom%20after%202.2&In-Reply-To=1253969844.7331.56.camel%40linux-2fwj.site">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000220.html">
   <LINK REL="Next"  HREF="000223.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-devel] Working on the monodevelop dom after 2.2</H1>
    <B>Lluis Sanchez Gual</B> 
    <A HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Working%20on%20the%20monodevelop%20dom%20after%202.2&In-Reply-To=1253969844.7331.56.camel%40linux-2fwj.site"
       TITLE="[Monodevelop-devel] Working on the monodevelop dom after 2.2">lluis at novell.com
       </A><BR>
    <I>Mon Sep 28 07:47:31 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000220.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
        <LI>Next message: <A HREF="000223.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#222">[ date ]</a>
              <a href="thread.html#222">[ thread ]</a>
              <a href="subject.html#222">[ subject ]</a>
              <a href="author.html#222">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>See comments inline.

El ds 26 de 09 de 2009 a les 14:57 +0200, en/na Mike Kr&#252;ger va escriure:
&gt;<i> Hi
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> &gt; The current situation is that if a non .NET language wants to provide
</I>&gt;<i> &gt; support for 1), we are forcing the use of the MD DOM, even when it
</I>&gt;<i> &gt; really doesn't fit. And there isn't much gain with that, because that
</I>&gt;<i> &gt; language won't be really able to leverage 2) and 3). The type
</I>&gt;<i> &gt; resolution
</I>&gt;<i> &gt; rules of the MD DOM strictly follow the .NET semantics, so it won't be
</I>&gt;<i> &gt; of much use for non .NET languages. Also, as a general purpose DOM for
</I>&gt;<i> &gt; the language it won't be really useful because it won't allow
</I>&gt;<i> &gt; expressing
</I>&gt;<i> &gt; the particularities of the language.
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> Type resolution isn't done in the MD DOM most resolving is done by the
</I>&gt;<i> backends. 
</I>
I know most of the work is done by the backends, but still the parser
service does .NET specific resolution work which is useless to other
languages. See ProjectDom.SearchType for example.

&gt;<i> Our DOM it can be a bit better at genericity than the current one. But
</I>&gt;<i> we won't never get a 'general purpose' dom. It should just describe the
</I>&gt;<i> most basic language structures we likely encounter.
</I>&gt;<i> 
</I>&gt;<i> &gt; My ideas for improving the situation are the following:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;       * Create a new DOM, which would be very high level, with just
</I>&gt;<i> &gt; the
</I>&gt;<i> &gt;         information required to support 1). It would be a simple DOM,
</I>&gt;<i> &gt;         intended only for displaying information to the user, not for
</I>&gt;<i> &gt;         type resolution or other operations.
</I>&gt;<i> 
</I>&gt;<i> I don't think a new DOM is required the current one represents the .NET
</I>&gt;<i> reflection API and that's a good sharing point across all .NET
</I>&gt;<i> languages.
</I>
That's OK for .NET languages, but we are talking about improving support
for non-.NET languages.

&gt;<i> I would change the current one a bit so that it's more mighty
</I>&gt;<i> than the reflection API. Some languages that are a bit different can be
</I>&gt;<i> wrapped to .NET classes by their compiler and it would be nice if we can
</I>&gt;<i> support those languages.
</I>&gt;<i> 
</I>&gt;<i> &#65279;Type resolution is done in the language backends. It does have some
</I>&gt;<i> operations but these are common accross all languages that use .NET
</I>&gt;<i> (like give all types in a namespace). When building a non .NET binding
</I>&gt;<i> there is no need to use these .NET specific features. 
</I>
Also, there is no need to be unnecessarily constrained by them. For
example, to show the current method in the members combo box, the
following interface would be enough:

interface INewMethod
{
	string GetDescription (SomeContext ctx);
	string Icon { get; }
	Region BodyRegion { get; }
}

That would be very easy to implement by a non .net language, and it is
not constraining the implementation in any way. The current IMethod
interface constraints the implementation to use a specific set of
modifiers, implement stuff like TypeParameters which won't be used, and
force the use of a parameters collection which also have .net specific
modifiers. And all this for just being able to build a string describing
a method.

My idea of new DOM is to create a set of interfaces which can be
implemented by non-.net language DOMs. Those interfaces would provide
just the enough information that usually has to be shown to the user.
They would be very generic, and could have a tree-like structure like
the one you are proposing. But the main idea is that those interfaces
are not meant to be used as part of any resolution process, or
refactoring, or any other operation that requires rich information about
the types. We already have language-specific DOMs to do that. Instead,
these would be used only for displaying information to the user.

The current DOM would also implement those interfaces, so .NET languages
(for which the current DOM works great) wouldn't need to implement them.

&gt;<i> 
</I>&gt;<i> My suggestion for making the DOM more general:
</I>&gt;<i> Doing anything with a tree node as base and have some types of tree
</I>&gt;<i> nodes (file/namespace/class/method etc). All tree nodes have:
</I>&gt;<i> 
</I>&gt;<i> * Link to their parent
</I>&gt;<i> * Know their childrin
</I>&gt;<i> * Have connections to their siblings
</I>&gt;<i> 
</I>&gt;<i> Accessing the children/parents is the same for all these DOM nodes. Some
</I>&gt;<i> operations on the current DOM have become a bit too difficult and they
</I>&gt;<i> would be easier with a general tree as underlying data structure.
</I>&gt;<i> 
</I>&gt;<i> It has limits to build a general DOM - I would draw the line
</I>&gt;<i> between .NET/non .NET language. The output done by the ambiences limits
</I>&gt;<i> a bit the flexibility of the DOM. But I think that ambiences are a good
</I>&gt;<i> idea.
</I>&gt;<i> 
</I>&gt;<i> Some examples .NET specific things that we use but will clash with
</I>&gt;<i> non .NET languages and there isn't anything we can do about:
</I>&gt;<i> 
</I>&gt;<i> * Method paramater modifiers out/ref/params - no 'per name' modifier
</I>&gt;<i> * General modifiers (public/protected etc.) - no c++ 'inline' modifier
</I>&gt;<i> or others
</I>&gt;<i> * Just file -&gt; namespace -&gt; type -&gt; member model - no 'pascal units' or
</I>&gt;<i> declaration/implementation models (#include) or any other form of
</I>&gt;<i> representation
</I>&gt;<i> * Just the .NET constructs (no 'typedef' for example).
</I>&gt;<i> 
</I>&gt;<i> ... and maybe more
</I>&gt;<i> 
</I>&gt;<i> Things we currently support but .NET doesn't:
</I>&gt;<i> 
</I>&gt;<i> * Multiple inheritance
</I>&gt;<i> 
</I>&gt;<i> Things we can support with some DOM refactorings but currently we don't:
</I>&gt;<i> 
</I>&gt;<i> * file -&gt; member models (would useful for the c# language too)
</I>&gt;<i> * method -&gt; method will be allowed (local methods are supported by some
</I>&gt;<i> languages)
</I>&gt;<i> * Other constructs ('typedef') which can be supported in a language
</I>&gt;<i> specific ambience. This is a strong point theoretical it would be
</I>&gt;<i> possible that a language brings their own tree.
</I>&gt;<i> 
</I>&gt;<i> ----
</I>&gt;<i> Other operations: 
</I>&gt;<i> If we want to have central support for code completion through a code
</I>&gt;<i> completion database the DOM needs support for some operations. 
</I>&gt;<i> 
</I>&gt;<i> The problem with these operations is now to determine if an operation
</I>&gt;<i> is:
</I>&gt;<i> 
</I>&gt;<i> * Language specific
</I>&gt;<i> * .NET centric
</I>&gt;<i> * General. 
</I>&gt;<i> 
</I>&gt;<i> I don't think that .NET centric operations like IsMemberAcessible or the
</I>&gt;<i> ResolveResults shouldn't be inside the central dom, because it can be re
</I>&gt;<i> used accross some .NET language bindings and if we can make the life
</I>&gt;<i> easier for .NET language bindings - why not. Other languages (if they
</I>&gt;<i> fit in our DOM model) don't need to call/use these features.
</I>
If we can generalize a bit the DOM, so some non-.NET languages can reuse
it, that's OK to me. But reusing the full DOM (with all its features and
constraints) should be optional.


&gt;<i> &gt;       * Each .NET language would implement its own DOM to support code
</I>&gt;<i> &gt;         completion.
</I>&gt;<i> 
</I>&gt;<i> It's already required, otherwise resolving won't work - there is no way
</I>&gt;<i> around it. But retieving the .NET code completion information should
</I>&gt;<i> work with our general DOM - otherwise it won't give any access to our
</I>&gt;<i> code completion database. (But language bindings can bring their own
</I>&gt;<i> code completion infrastructure if they want)
</I>
All that is OK to me.

&gt;<i> 
</I>&gt;<i> &gt;       * Generalize a bit the parser service, so we can share some of
</I>&gt;<i> &gt; its
</I>&gt;<i> &gt;         logic. We can keep the parser database as it is right now, but
</I>&gt;<i> &gt;         it would be used only for .NET languages. Non .NET languages
</I>&gt;<i> &gt;         would use its own DOM storage model. Maybe we wouldn't be able
</I>&gt;<i> &gt;         to share much, but at least we could share the thread that
</I>&gt;<i> &gt;         checks for changes and triggers parse operations or something
</I>&gt;<i> &gt;         like that.
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> I wouldn't give access for custom (binary)database plugins, because the
</I>&gt;<i> database exposes a model and other languages that don't fit into the
</I>&gt;<i> model won't share the same logic/models. Our database uses a custom
</I>&gt;<i> binary format and some tables to speed up some operations.
</I>
That's not what I'm proposing.

&gt;<i> 
</I>&gt;<i> I would just add support for binary serialization of custom DOM nodes. 
</I>&gt;<i> 
</I>&gt;<i> Bringing other models into our 'database' (which isn't a real database)
</I>&gt;<i> would require that they write their own data storage and logic/models
</I>&gt;<i> and not interfere with the current binary format (depending on what the
</I>&gt;<i> plugins want to do). I think if they don't support our DOM model they
</I>&gt;<i> should bring their own 'database' implementation. 
</I>
And that's just what I'm proposing. Notice that I talked about
generalizing the parser *service*, not the parser *database*. The parser
service is in charge of driving the parse operations of project files
and referenced assemblies. It can be generalized a bit to allow plugging
other parsing systems on it, with their own database systems.

&gt;<i> Another point is that
</I>&gt;<i> the database is accessible only through DOM models - that'll make it
</I>&gt;<i> even more unlikely that a language can put some plugin into it.
</I>&gt;<i> 
</I>&gt;<i> Therefore I don't see a good reason for this (But this will depend on
</I>&gt;<i> the user requests - I think some work can be done by the language
</I>&gt;<i> implementors).
</I>&gt;<i> 
</I>&gt;<i> btw. how about switching to SQLite for the parser database ?
</I>
If a SQLite based database provides equal or faster access times, with a
reasonable memory use, we can consider it.

Lluis.


</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000220.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
	<LI>Next message: <A HREF="000223.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#222">[ date ]</a>
              <a href="thread.html#222">[ thread ]</a>
              <a href="subject.html#222">[ subject ]</a>
              <a href="author.html#222">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">More information about the Monodevelop-devel-list
mailing list</a><br>
</body></html>
