<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-devel] Working on the monodevelop dom after 2.2
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Working%20on%20the%20monodevelop%20dom%20after%202.2&In-Reply-To=1254183152.29894.489.camel%40linux-nesp.site">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000236.html">
   <LINK REL="Next"  HREF="000238.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-devel] Working on the monodevelop dom after 2.2</H1>
    <B>Mike Kr&#252;ger</B> 
    <A HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Working%20on%20the%20monodevelop%20dom%20after%202.2&In-Reply-To=1254183152.29894.489.camel%40linux-nesp.site"
       TITLE="[Monodevelop-devel] Working on the monodevelop dom after 2.2">mkrueger at novell.com
       </A><BR>
    <I>Tue Sep 29 07:19:27 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000236.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
        <LI>Next message: <A HREF="000238.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#237">[ date ]</a>
              <a href="thread.html#237">[ thread ]</a>
              <a href="subject.html#237">[ subject ]</a>
              <a href="author.html#237">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi

&gt;<i> I feel there is some misunderstanding here. If we introduce a new set of
</I>&gt;<i> INew* interfaces we'll certainly have to track the changes in
</I>&gt;<i> MethodNodeBuilder and all the builders. And those changes will include
</I>&gt;<i> rendering child nodes, since any node can have child nodes.
</I>&gt;<i> 
</I>
Don't solve the case, where the DOM goes deeper than methods. I'm sure
you're coming up with an interface: IClassBrowserProvider { bool
IncludeInClassBrowser { get; }} that 'just' needs to be provided for
every dom. 
The class browser works better when non .NET languages don't re-use our
DOM, if they use their own one they can add their node builders to the
class browser and the thing works.

&gt;<i> &gt; 
</I>&gt;<i> &gt; Quick Member navigation - it's not so easy to set the rules:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 'showing first level items of the file' means:
</I>&gt;<i> &gt; + Showing only the namespaces -&gt; no containing types (they're first
</I>&gt;<i> &gt; level, and will be part of the DOM as nodes)
</I>&gt;<i> &gt; + Don't show inner types (they're second level at best)
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 'children of the active first level item' means:
</I>&gt;<i> &gt; + Show the current inner type (should be in the type selector).
</I>&gt;<i> &gt; + Show the current statement, if the DOM is extended and more specific
</I>&gt;<i> &gt; than the monodevelop DOM.
</I>&gt;<i> 
</I>&gt;<i> This has a very simple solution:
</I>&gt;<i> 
</I>&gt;<i> interface IQuickMemberNavigationProvider
</I>&gt;<i> {
</I>&gt;<i> 	IEnumerable&lt;INode&gt; GetTypes ();
</I>&gt;<i> 	IEnumerable&lt;INode&gt; GetMembers (INode type);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> to be implemented by language bindings.
</I>&gt;<i> 
</I>
Doesn't solve the issue with more than one panel or three panels. You
need something like:
interface IQuickMemberNavigationProvider
{
	IEnumerable&lt;IQuickNavigationPanel&gt; GetPanels ();
}
-&gt; then the quick navigation code has nothing to do with any dom. 

&gt;<i> &gt; 
</I>&gt;<i> &gt; btw. another thing: All pads/output function currently build on ambience
</I>&gt;<i> &gt; flags - but for other languages there may be different sets of flags
</I>&gt;<i> &gt; required for displaying the information at that point. 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; Yes, that's currently possible (with some tweaks). But it means that the
</I>&gt;<i> &gt; &gt; language has to implement all the DOM interfaces: IField, IMethod,
</I>&gt;<i> &gt; &gt; IType, etc, which are full of .NET specific stuff. Yes, you can just
</I>&gt;<i> &gt; &gt; throw NotSupportedException of all .NET specific methods and properties,
</I>&gt;<i> &gt; &gt; but that's just unnecessary bloat. If anything, it would be better to
</I>&gt;<i> &gt; &gt; have:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; We've classes that implement the interfaces, no .NET specific
</I>&gt;<i> &gt; implementation is required. But the other thing is that a new languages
</I>&gt;<i> &gt; now would ALWAYS require to implement all DOM interfaces that are full
</I>&gt;<i> &gt; of .NET specific stuff. (ok could use the same base class)
</I>&gt;<i> &gt; You've still not told how to display a VB output, Boo output and c#
</I>&gt;<i> &gt; output of a reflection source when putting the output code inside the
</I>&gt;<i> &gt; DOM objects. I think that's not easily possible.
</I>&gt;<i> 
</I>&gt;<i> I showed it some posts ago:
</I>&gt;<i> 
</I>&gt;<i> class DomField: IMember, INewField
</I>&gt;<i> {
</I>&gt;<i>         public string GetDescription (SomeContext ctx)
</I>&gt;<i>         {
</I>&gt;<i>                 return ctx.Ambience.GetString (this, ctx.AmbienceOptions);
</I>&gt;<i>         }
</I>&gt;<i>         ...
</I>&gt;<i> }
</I>
Doesn't solve what I'm describing, because it doesn't solve the problem
for the reflection source. Or you're saying that we use a same set of
classes for every .NET language - that is what we currently have. 

You're coming up with a design that isn't better than the thing we
already have, it's just the same. The discussion is about visitors vs.
member methods - this is pointless.

&gt;<i> I think we have to look at this case by case. For the tooltip case,
</I>&gt;<i> maybe this is enough:
</I>&gt;<i> 
</I>&gt;<i> interface ITooltipProvider
</I>&gt;<i> {
</I>&gt;<i> 	string GetMarkup (INode node);
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> to be implemented in every non-.net language binding.
</I>&gt;<i> 
</I>
Just another DOM extender interface - you see the design gets more and
more complicated this way ? It's generally not possible to handle every
possible language output/model in a single GetString() - you'll get
scaling problems. If you try this you basically come up with:

INode { 
	GetDescription (CaseEnum, SomeContext ctx); 
}

CaseEnum { CompletionList, CompletionListTooltip, ParameterTooltip,
ParameterDescription, ClassBrowser, QuickNavigationList, ... }

SomeContext { ... } 
ClassBrowserContext : SomeContext { ... }
CompletionContext : SomeContext { ... }
ParameterListContext : SomeContext { ... } 
..

Is that really an option ? What are the others saying ? (The problem
will be adding new controls that display DOM stuff - currently we've a
set of display options where the controls choose from).

&gt;<i> &gt; 
</I>&gt;<i> &gt; I tend to make the monodevelop DOM stuff .NET dependent in the type
</I>&gt;<i> &gt; model, generalize the object model so that other .NET languages can be
</I>&gt;<i> &gt; supported that are more far from C#/VB.NET and have a way to do
</I>&gt;<i> &gt; something like the IOutlinedDocument for each component. I don't want to
</I>&gt;<i> &gt; make the life harder for .NET language implementors when the non .NET
</I>&gt;<i> &gt; language implementors get little to no gain (See above - they need to
</I>&gt;<i> &gt; implement their own widgets/infrastructure - regardless of what we try,
</I>&gt;<i> &gt; more worse they can run into dead ends when trying to re-use the
</I>&gt;<i> &gt; monodevelop DOM - see the class output pad method example).
</I>&gt;<i> 
</I>&gt;<i> No, what I'm proposing does not involve implementing additional
</I>&gt;<i> widgets/infrastructure. See above.
</I>&gt;<i> 
</I>
But to change every widget/infrastructure with an interface that may not
work for the case the language implementor needs, doesn't add
functionality and makes the life more difficult implementing standard
language bindings isn't a solution.

Again what I wanted:

Extend the MD DOM to make it EASIER to implement .NET based languages -
and MAYBE being able to map non .NET languages to it. I don't intend to 
make anything HARDER to implement for .NET languages.

What I learned from our discussion:

a) Don't provide too much infrastructure for trees you don't yet know
how they look like.
b) Make every component of monodevelop extendable without sticking to a
specific DOM - provide defaults for the .NET based DOM.

Reagds
Mike

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000236.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
	<LI>Next message: <A HREF="000238.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#237">[ date ]</a>
              <a href="thread.html#237">[ thread ]</a>
              <a href="subject.html#237">[ subject ]</a>
              <a href="author.html#237">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">More information about the Monodevelop-devel-list
mailing list</a><br>
</body></html>
