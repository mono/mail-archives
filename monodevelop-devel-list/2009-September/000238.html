<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-devel] Working on the monodevelop dom after 2.2
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Working%20on%20the%20monodevelop%20dom%20after%202.2&In-Reply-To=1254223167.2238.30.camel%40celestis">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000237.html">
   <LINK REL="Next"  HREF="000216.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-devel] Working on the monodevelop dom after 2.2</H1>
    <B>Lluis Sanchez Gual</B> 
    <A HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Working%20on%20the%20monodevelop%20dom%20after%202.2&In-Reply-To=1254223167.2238.30.camel%40celestis"
       TITLE="[Monodevelop-devel] Working on the monodevelop dom after 2.2">lluis at novell.com
       </A><BR>
    <I>Wed Sep 30 18:08:39 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000237.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
        <LI>Next message: <A HREF="000216.html">[Monodevelop-devel] MonoDevelop 2.2b1 wont start on Windows
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#238">[ date ]</a>
              <a href="thread.html#238">[ thread ]</a>
              <a href="subject.html#238">[ subject ]</a>
              <a href="author.html#238">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>El dt 29 de 09 de 2009 a les 13:19 +0200, en/na Mike Kr&#252;ger va
escriure: 
&gt;<i> Hi
</I>&gt;<i> 
</I>&gt;<i> &gt; I feel there is some misunderstanding here. If we introduce a new set of
</I>&gt;<i> &gt; INew* interfaces we'll certainly have to track the changes in
</I>&gt;<i> &gt; MethodNodeBuilder and all the builders. And those changes will include
</I>&gt;<i> &gt; rendering child nodes, since any node can have child nodes.
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> Don't solve the case, where the DOM goes deeper than methods. 
</I>
I don't know why you say that. If an IMethod is an INode, and an INode
can have child INodes. MethodNodeBuilder can be a subclass of
INodeBuilder, which by default renders child INodes.

&gt;<i> I'm sure
</I>&gt;<i> you're coming up with an interface: IClassBrowserProvider { bool
</I>&gt;<i> IncludeInClassBrowser { get; }} that 'just' needs to be provided for
</I>&gt;<i> every dom. 
</I>&gt;<i> The class browser works better when non .NET languages don't re-use our
</I>&gt;<i> DOM, if they use their own one they can add their node builders to the
</I>&gt;<i> class browser and the thing works.
</I>
Agreed, in this case using node builders bound to the particular
language dom is an easy solution.

&gt;<i> 
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Quick Member navigation - it's not so easy to set the rules:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 'showing first level items of the file' means:
</I>&gt;<i> &gt; &gt; + Showing only the namespaces -&gt; no containing types (they're first
</I>&gt;<i> &gt; &gt; level, and will be part of the DOM as nodes)
</I>&gt;<i> &gt; &gt; + Don't show inner types (they're second level at best)
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 'children of the active first level item' means:
</I>&gt;<i> &gt; &gt; + Show the current inner type (should be in the type selector).
</I>&gt;<i> &gt; &gt; + Show the current statement, if the DOM is extended and more specific
</I>&gt;<i> &gt; &gt; than the monodevelop DOM.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; This has a very simple solution:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; interface IQuickMemberNavigationProvider
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; 	IEnumerable&lt;INode&gt; GetTypes ();
</I>&gt;<i> &gt; 	IEnumerable&lt;INode&gt; GetMembers (INode type);
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; to be implemented by language bindings.
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> Doesn't solve the issue with more than one panel or three panels. 
</I>
It does solve the problems you asked for.

&gt;<i> You
</I>&gt;<i> need something like:
</I>&gt;<i> interface IQuickMemberNavigationProvider
</I>&gt;<i> {
</I>&gt;<i> 	IEnumerable&lt;IQuickNavigationPanel&gt; GetPanels ();
</I>&gt;<i> }
</I>&gt;<i> -&gt; then the quick navigation code has nothing to do with any dom. 
</I>
Agreed, that's the most generic solution (well, the most generic would
be just returning a gtk.widget).

In any case we can have both interfaces. The first interface could be
used by language bindings which don't want to implement its own custom
panel. MD would use the default panel in this case, filling the data
retrieved from the interface. Language bindings with more advanced needs
could implement the second interface and provide a full custom set of
panels.

The Properties Pad already works in this way. You can implement
IPropertyPadProvider, which has a GetActiveComponent() method. When
using this interface, MD will create a standard PropertyGrid and fill it
up with the data of the active component (retrieved using the
System.ComponentModel classes). On the other hand, you can implement
ICustomPropertyPadProvider, which has a GetCustomPropertyWidget(). When
finding this interface, MD will just create the custom widget and embed
it in the properties pad, replacing the default property grid.

&gt;<i> 
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; btw. another thing: All pads/output function currently build on ambience
</I>&gt;<i> &gt; &gt; flags - but for other languages there may be different sets of flags
</I>&gt;<i> &gt; &gt; required for displaying the information at that point. 
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &gt; Yes, that's currently possible (with some tweaks). But it means that the
</I>&gt;<i> &gt; &gt; &gt; language has to implement all the DOM interfaces: IField, IMethod,
</I>&gt;<i> &gt; &gt; &gt; IType, etc, which are full of .NET specific stuff. Yes, you can just
</I>&gt;<i> &gt; &gt; &gt; throw NotSupportedException of all .NET specific methods and properties,
</I>&gt;<i> &gt; &gt; &gt; but that's just unnecessary bloat. If anything, it would be better to
</I>&gt;<i> &gt; &gt; &gt; have:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; We've classes that implement the interfaces, no .NET specific
</I>&gt;<i> &gt; &gt; implementation is required. But the other thing is that a new languages
</I>&gt;<i> &gt; &gt; now would ALWAYS require to implement all DOM interfaces that are full
</I>&gt;<i> &gt; &gt; of .NET specific stuff. (ok could use the same base class)
</I>&gt;<i> &gt; &gt; You've still not told how to display a VB output, Boo output and c#
</I>&gt;<i> &gt; &gt; output of a reflection source when putting the output code inside the
</I>&gt;<i> &gt; &gt; DOM objects. I think that's not easily possible.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I showed it some posts ago:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; class DomField: IMember, INewField
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt;         public string GetDescription (SomeContext ctx)
</I>&gt;<i> &gt;         {
</I>&gt;<i> &gt;                 return ctx.Ambience.GetString (this, ctx.AmbienceOptions);
</I>&gt;<i> &gt;         }
</I>&gt;<i> &gt;         ...
</I>&gt;<i> &gt; }
</I>&gt;<i> 
</I>&gt;<i> Doesn't solve what I'm describing, because it doesn't solve the problem
</I>&gt;<i> for the reflection source. Or you're saying that we use a same set of
</I>&gt;<i> classes for every .NET language - that is what we currently have. 
</I>
Yes, that's what I've been saying since the beginning. The current DOM
is OK for .NET languages and I'm not proposing the change it. I just
proposed creating a higher level set of interfaces (which would not
replace the ones we have now, only complement them). Those interfaces
would allow using the current set of navigation/information widgets
without having to use the .NET specific DOM.

&gt;<i> 
</I>&gt;<i> You're coming up with a design that isn't better than the thing we
</I>&gt;<i> already have, it's just the same. The discussion is about visitors vs.
</I>&gt;<i> member methods - this is pointless.
</I>
No, this is not the discussion. I hope my previous paragraph clarifies
it.

&gt;<i> 
</I>&gt;<i> &gt; I think we have to look at this case by case. For the tooltip case,
</I>&gt;<i> &gt; maybe this is enough:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; interface ITooltipProvider
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt; 	string GetMarkup (INode node);
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; to be implemented in every non-.net language binding.
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> Just another DOM extender interface - you see the design gets more and
</I>&gt;<i> more complicated this way ? It's generally not possible to handle every
</I>&gt;<i> possible language output/model in a single GetString() - you'll get
</I>&gt;<i> scaling problems. If you try this you basically come up with:
</I>&gt;<i> 
</I>&gt;<i> INode { 
</I>&gt;<i> 	GetDescription (CaseEnum, SomeContext ctx); 
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> CaseEnum { CompletionList, CompletionListTooltip, ParameterTooltip,
</I>&gt;<i> ParameterDescription, ClassBrowser, QuickNavigationList, ... }
</I>&gt;<i> 
</I>&gt;<i> SomeContext { ... } 
</I>&gt;<i> ClassBrowserContext : SomeContext { ... }
</I>&gt;<i> CompletionContext : SomeContext { ... }
</I>&gt;<i> ParameterListContext : SomeContext { ... } 
</I>&gt;<i> ...
</I>&gt;<i> 
</I>&gt;<i> Is that really an option ? What are the others saying ? (The problem
</I>&gt;<i> will be adding new controls that display DOM stuff - currently we've a
</I>&gt;<i> set of display options where the controls choose from).
</I>
The problem is that those display options are .NET specific:
UseFullName, IncludeBaseTypes, IncludeGenerics, HideArrayBrackets,
HideExtensionsParameter, UseNETTypeNames, UseFullInnerTypeName.

So, a non-.net language won't make any use of those properties, and it
will have a hard time figuring out which information to show. On the
other hand, there is no doubt about how to implement ITooltipProvider:
it is very clear that the markup is going to be used to show a tooltip
to the user, so the language can decide what needs to be shown.

I'm not saying however that ITooltipProvider is the best solution, it
was just an example of high level interface which could be used to avoid
a DOM dependency.

&gt;<i> 
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; I tend to make the monodevelop DOM stuff .NET dependent in the type
</I>&gt;<i> &gt; &gt; model, generalize the object model so that other .NET languages can be
</I>&gt;<i> &gt; &gt; supported that are more far from C#/VB.NET and have a way to do
</I>&gt;<i> &gt; &gt; something like the IOutlinedDocument for each component. I don't want to
</I>&gt;<i> &gt; &gt; make the life harder for .NET language implementors when the non .NET
</I>&gt;<i> &gt; &gt; language implementors get little to no gain (See above - they need to
</I>&gt;<i> &gt; &gt; implement their own widgets/infrastructure - regardless of what we try,
</I>&gt;<i> &gt; &gt; more worse they can run into dead ends when trying to re-use the
</I>&gt;<i> &gt; &gt; monodevelop DOM - see the class output pad method example).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; No, what I'm proposing does not involve implementing additional
</I>&gt;<i> &gt; widgets/infrastructure. See above.
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> But to change every widget/infrastructure with an interface that may not
</I>&gt;<i> work for the case the language implementor needs, doesn't add
</I>&gt;<i> functionality and makes the life more difficult implementing standard
</I>&gt;<i> language bindings isn't a solution.
</I>&gt;<i> 
</I>&gt;<i> Again what I wanted:
</I>&gt;<i> 
</I>&gt;<i> Extend the MD DOM to make it EASIER to implement .NET based languages -
</I>&gt;<i> and MAYBE being able to map non .NET languages to it. I don't intend to 
</I>&gt;<i> make anything HARDER to implement for .NET languages.
</I>
And I'm OK with that. Now, what I want is to make it EASIER to implement
non .NET languages, without making it HARDER to implement the .NET
languages (no changes should be required in the existing .NET language
bindings). That's the whole point of my proposal.

&gt;<i> 
</I>&gt;<i> What I learned from our discussion:
</I>&gt;<i> 
</I>&gt;<i> a) Don't provide too much infrastructure for trees you don't yet know
</I>&gt;<i> how they look like.
</I>&gt;<i> b) Make every component of monodevelop extendable without sticking to a
</I>&gt;<i> specific DOM - provide defaults for the .NET based DOM.
</I>
Agreed. The document outline component is a good example of this. I
think however that there must be a middle-ground solution between
getting the document outline automatically filled from the .NET DOM
(using the default component), and having to write your custom widget
from scratch. I'd like to make it easier to support non .net languages
by providing this kind of middle-ground solution (whatever it is).

Lluis.




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000237.html">[Monodevelop-devel] Working on the monodevelop dom after 2.2
</A></li>
	<LI>Next message: <A HREF="000216.html">[Monodevelop-devel] MonoDevelop 2.2b1 wont start on Windows
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#238">[ date ]</a>
              <a href="thread.html#238">[ thread ]</a>
              <a href="subject.html#238">[ subject ]</a>
              <a href="author.html#238">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">More information about the Monodevelop-devel-list
mailing list</a><br>
</body></html>
