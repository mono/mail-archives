<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-devel] [PATCH] SdiWorkspaceWindow
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20%5BPATCH%5D%20SdiWorkspaceWindow&In-Reply-To=4A7ABB63.4050308%40carlo-kok.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000173.html">
   <LINK REL="Next"  HREF="000174.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-devel] [PATCH] SdiWorkspaceWindow</H1>
    <B>Lluis Sanchez Gual</B> 
    <A HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20%5BPATCH%5D%20SdiWorkspaceWindow&In-Reply-To=4A7ABB63.4050308%40carlo-kok.com"
       TITLE="[Monodevelop-devel] [PATCH] SdiWorkspaceWindow">lluis at novell.com
       </A><BR>
    <I>Mon Aug 10 06:35:14 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000173.html">[Monodevelop-devel] [PATCH] SdiWorkspaceWindow
</A></li>
        <LI>Next message: <A HREF="000174.html">[Monodevelop-devel] [patch]IDonNetLanguageBinding.cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#185">[ date ]</a>
              <a href="thread.html#185">[ thread ]</a>
              <a href="subject.html#185">[ subject ]</a>
              <a href="author.html#185">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I kept the original #D code since it was relicensed to LGPL in #D 2.0.

El dj 06 de 08 de 2009 a les 13:15 +0200, en/na Carlo Kok va escriure:
&gt;<i> Same method as usual. We went through and compared to the original, it
</I>&gt;<i> *should* be good, but we couldn't test the subview support (we develop
</I>&gt;<i> on windows).
</I>&gt;<i> 
</I>&gt;<i> fitxer adjunt document de text pla (SdiWorkspaceWindow.patch)
</I>&gt;<i> Index: main/src/core/MonoDevelop.Ide/ChangeLog
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- main/src/core/MonoDevelop.Ide/ChangeLog	(revision 139397)
</I>&gt;<i> +++ main/src/core/MonoDevelop.Ide/ChangeLog	(working copy)
</I>&gt;<i> @@ -1,3 +1,8 @@
</I>&gt;<i> +2009-07-02  Viktoria Dudka  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">viktoriad at remobjects.com</A>&gt;
</I>&gt;<i> +
</I>&gt;<i> +	* MonoDevelop.Ide.Gui/SdiWorkspaceWindow.cs: Rewritten from scratch
</I>&gt;<i> +	  to make it non-GPL. 
</I>&gt;<i> +
</I>&gt;<i>  2009-08-05  Lluis Sanchez Gual  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">lluis at novell.com</A>&gt;
</I>&gt;<i>  
</I>&gt;<i>  	* MonoDevelop.Ide.FindInFiles/SearchResultWidget.cs: Don't
</I>&gt;<i> Index: main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.Gui/SdiWorkspaceWindow.cs
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.Gui/SdiWorkspaceWindow.cs	(revision 139397)
</I>&gt;<i> +++ main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.Gui/SdiWorkspaceWindow.cs	(working copy)
</I>&gt;<i> @@ -1,634 +1,637 @@
</I>&gt;<i> -//  SdiWorkspaceWindow.cs
</I>&gt;<i> -//
</I>&gt;<i> -//  This file was derived from a file from #Develop. 
</I>&gt;<i> -//
</I>&gt;<i> -//  Copyright (C) 2001-2007 Mike Kr&#252;ger &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">mkrueger at novell.com</A>&gt;
</I>&gt;<i> -// 
</I>&gt;<i> -//  This program is free software; you can redistribute it and/or modify
</I>&gt;<i> -//  it under the terms of the GNU General Public License as published by
</I>&gt;<i> -//  the Free Software Foundation; either version 2 of the License, or
</I>&gt;<i> -//  (at your option) any later version.
</I>&gt;<i> -// 
</I>&gt;<i> -//  This program is distributed in the hope that it will be useful,
</I>&gt;<i> -//  but WITHOUT ANY WARRANTY; without even the implied warranty of
</I>&gt;<i> -//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
</I>&gt;<i> -//  GNU General Public License for more details.
</I>&gt;<i> -//  
</I>&gt;<i> -//  You should have received a copy of the GNU General Public License
</I>&gt;<i> -//  along with this program; if not, write to the Free Software
</I>&gt;<i> -//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
</I>&gt;<i> -
</I>&gt;<i> -using System;
</I>&gt;<i> -using System.Collections;
</I>&gt;<i> -using System.IO;
</I>&gt;<i> -using Gtk;
</I>&gt;<i> -
</I>&gt;<i> -using MonoDevelop.Core;
</I>&gt;<i> -using MonoDevelop.Core.Gui;
</I>&gt;<i> -using MonoDevelop.Components;
</I>&gt;<i> -using MonoDevelop.Ide.Commands;
</I>&gt;<i> -using MonoDevelop.Components.Commands;
</I>&gt;<i> -
</I>&gt;<i> -namespace MonoDevelop.Ide.Gui
</I>&gt;<i> -{
</I>&gt;<i> -	internal class SdiWorkspaceWindow : Frame, IWorkbenchWindow, ICommandDelegatorRouter
</I>&gt;<i> -	{
</I>&gt;<i> -		IWorkbench workbench;
</I>&gt;<i> -		IViewContent content;
</I>&gt;<i> -		
</I>&gt;<i> -		ArrayList subViewContents = null;
</I>&gt;<i> -		Notebook subViewNotebook = null;
</I>&gt;<i> -		Toolbar subViewToolbar = null;
</I>&gt;<i> -		HBox pathBox = null;
</I>&gt;<i> -		HBox toolbarBox = null;
</I>&gt;<i> -		
</I>&gt;<i> -		VBox box;
</I>&gt;<i> -		TabLabel tabLabel;
</I>&gt;<i> -		Widget    tabPage;
</I>&gt;<i> -		Notebook  tabControl;
</I>&gt;<i> -		SeparatorToolItem separatorItem;
</I>&gt;<i> -		
</I>&gt;<i> -		string myUntitledTitle     = null;
</I>&gt;<i> -		string _titleHolder = &quot;&quot;;
</I>&gt;<i> -		
</I>&gt;<i> -		string documentType;
</I>&gt;<i> -		MonoDevelop.Ide.Gui.Content.IPathedDocument pathDoc;
</I>&gt;<i> -		
</I>&gt;<i> -		bool show_notification = false;
</I>&gt;<i> -		
</I>&gt;<i> -		ViewCommandHandlers commandHandler;
</I>&gt;<i> -		
</I>&gt;<i> -		public SdiWorkspaceWindow (IWorkbench workbench, IViewContent content, Notebook tabControl, TabLabel tabLabel) : base ()
</I>&gt;<i> -		{
</I>&gt;<i> -			this.workbench = workbench;
</I>&gt;<i> -			this.tabControl = tabControl;
</I>&gt;<i> -			this.content = content;
</I>&gt;<i> -			this.tabLabel = tabLabel;
</I>&gt;<i> -			this.tabPage = content.Control;
</I>&gt;<i> -			
</I>&gt;<i> -			content.WorkbenchWindow = this;
</I>&gt;<i> -			
</I>&gt;<i> -			content.ContentNameChanged += new EventHandler(SetTitleEvent);
</I>&gt;<i> -			content.DirtyChanged       += new EventHandler(SetTitleEvent);
</I>&gt;<i> -			content.BeforeSave         += new EventHandler(BeforeSave);
</I>&gt;<i> -			content.ContentChanged     += new EventHandler (OnContentChanged);
</I>&gt;<i> -			
</I>&gt;<i> -			ShadowType = ShadowType.None;
</I>&gt;<i> -			box = new VBox ();
</I>&gt;<i> -			box.Add (content.Control);
</I>&gt;<i> -			Add (box);
</I>&gt;<i> -			
</I>&gt;<i> -			Show ();
</I>&gt;<i> -			box.Show ();
</I>&gt;<i> -			content.Control.Show ();
</I>&gt;<i> -			SetTitleEvent(null, null);
</I>&gt;<i> -			
</I>&gt;<i> -			commandHandler = new ViewCommandHandlers (this);
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		protected SdiWorkspaceWindow (IntPtr p): base (p)
</I>&gt;<i> -		{
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public Widget TabPage {
</I>&gt;<i> -			get {
</I>&gt;<i> -				return tabPage;
</I>&gt;<i> -			}
</I>&gt;<i> -			set {
</I>&gt;<i> -				tabPage = value;
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		internal TabLabel TabLabel {
</I>&gt;<i> -			get { return tabLabel; }
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		public Document Document {
</I>&gt;<i> -			get;
</I>&gt;<i> -			set;
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public bool ShowNotification {
</I>&gt;<i> -			get {
</I>&gt;<i> -				return show_notification;
</I>&gt;<i> -			}
</I>&gt;<i> -			set {
</I>&gt;<i> -				if (show_notification != value) {
</I>&gt;<i> -					show_notification = value;
</I>&gt;<i> -					OnTitleChanged (null);
</I>&gt;<i> -				}
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public string Title {
</I>&gt;<i> -			get {
</I>&gt;<i> -				//FIXME: This breaks, Why? --Todd
</I>&gt;<i> -				//_titleHolder = tabControl.GetTabLabelText (tabPage);
</I>&gt;<i> -				return _titleHolder;
</I>&gt;<i> -			}
</I>&gt;<i> -			set {
</I>&gt;<i> -				_titleHolder = value;
</I>&gt;<i> -				string fileName = content.ContentName;
</I>&gt;<i> -				if (fileName == null) {
</I>&gt;<i> -					fileName = content.UntitledName;
</I>&gt;<i> -				}
</I>&gt;<i> -				
</I>&gt;<i> -				OnTitleChanged(null);
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public ArrayList SubViewContents {
</I>&gt;<i> -			get {
</I>&gt;<i> -				return subViewContents;
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		// caution use activeView with care !!
</I>&gt;<i> -		IBaseViewContent activeView = null;
</I>&gt;<i> -		public IBaseViewContent ActiveViewContent {
</I>&gt;<i> -			get {
</I>&gt;<i> -				if (activeView != null)
</I>&gt;<i> -					return activeView;
</I>&gt;<i> -				if (subViewNotebook != null &amp;&amp; subViewNotebook.CurrentPage &gt; 0) {
</I>&gt;<i> -					return (IBaseViewContent)subViewContents[subViewNotebook.CurrentPage - 1];
</I>&gt;<i> -				}
</I>&gt;<i> -				return content;
</I>&gt;<i> -			}
</I>&gt;<i> -			set {
</I>&gt;<i> -				this.activeView = value;
</I>&gt;<i> -				this.OnActiveViewContentChanged (new ActiveViewContentEventArgs (value));
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public void SwitchView (int viewNumber)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (subViewNotebook != null)
</I>&gt;<i> -				ShowPage (viewNumber);
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public void SelectWindow()	
</I>&gt;<i> -		{
</I>&gt;<i> -			if (this.Parent == null)
</I>&gt;<i> -				return;
</I>&gt;<i> -			int toSelect = tabControl.PageNum (this);
</I>&gt;<i> -			tabControl.CurrentPage = toSelect;
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -
</I>&gt;<i> -		void BeforeSave(object sender, EventArgs e)
</I>&gt;<i> -		{
</I>&gt;<i> -			IAttachableViewContent secondaryViewContent = ActiveViewContent as IAttachableViewContent;
</I>&gt;<i> -			if (secondaryViewContent != null) {
</I>&gt;<i> -				secondaryViewContent.BeforeSave ();
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public IViewContent ViewContent {
</I>&gt;<i> -			get {
</I>&gt;<i> -				return content;
</I>&gt;<i> -			}
</I>&gt;<i> -			set {
</I>&gt;<i> -				content = value;
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		public MonoDevelop.Ide.Gui.ViewCommandHandlers CommandHandler {
</I>&gt;<i> -			get {
</I>&gt;<i> -				return commandHandler;
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		public string DocumentType {
</I>&gt;<i> -			get {
</I>&gt;<i> -				return documentType;
</I>&gt;<i> -			}
</I>&gt;<i> -			set {
</I>&gt;<i> -				documentType = value;
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public void SetTitleEvent(object sender, EventArgs e)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (content == null) {
</I>&gt;<i> -				return;
</I>&gt;<i> -			}
</I>&gt;<i> -		
</I>&gt;<i> -			string newTitle = &quot;&quot;;
</I>&gt;<i> -			if (content.ContentName == null) {
</I>&gt;<i> -				if (myUntitledTitle == null) {
</I>&gt;<i> -					string baseName  = System.IO.Path.GetFileNameWithoutExtension(content.UntitledName);
</I>&gt;<i> -					int number = 1;
</I>&gt;<i> -					bool found = true;
</I>&gt;<i> -					myUntitledTitle = baseName + System.IO.Path.GetExtension (content.UntitledName);
</I>&gt;<i> -					while (found) {
</I>&gt;<i> -						found = false;
</I>&gt;<i> -						foreach (IViewContent windowContent in workbench.ViewContentCollection) {
</I>&gt;<i> -							string title = windowContent.WorkbenchWindow.Title;
</I>&gt;<i> -							if (title.EndsWith(&quot;*&quot;) || title.EndsWith(&quot;+&quot;)) {
</I>&gt;<i> -								title = title.Substring(0, title.Length - 1);
</I>&gt;<i> -							}
</I>&gt;<i> -							if (title == myUntitledTitle) {
</I>&gt;<i> -								myUntitledTitle = baseName + number + System.IO.Path.GetExtension (content.UntitledName);
</I>&gt;<i> -								found = true;
</I>&gt;<i> -								++number;
</I>&gt;<i> -								break;
</I>&gt;<i> -							}
</I>&gt;<i> -						}
</I>&gt;<i> -					}
</I>&gt;<i> -				}
</I>&gt;<i> -				newTitle = myUntitledTitle;
</I>&gt;<i> -			} else {
</I>&gt;<i> -				newTitle = System.IO.Path.GetFileName(content.ContentName);
</I>&gt;<i> -			}
</I>&gt;<i> -			
</I>&gt;<i> -			if (content.IsDirty) {
</I>&gt;<i> -				newTitle += &quot;*&quot;;
</I>&gt;<i> -				IdeApp.ProjectOperations.MarkFileDirty (content.ContentName);
</I>&gt;<i> -			} else if (content.IsReadOnly) {
</I>&gt;<i> -				newTitle += &quot;+&quot;;
</I>&gt;<i> -			}
</I>&gt;<i> -			
</I>&gt;<i> -			if (newTitle != Title) {
</I>&gt;<i> -				Title = newTitle;
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public void OnContentChanged (object o, EventArgs e)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (subViewContents != null) {
</I>&gt;<i> -				foreach (IAttachableViewContent subContent in subViewContents)
</I>&gt;<i> -				{
</I>&gt;<i> -					subContent.BaseContentChanged ();
</I>&gt;<i> -				}
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		public bool CloseWindow (bool force, bool fromMenu, int pageNum)
</I>&gt;<i> -		{
</I>&gt;<i> -			bool wasActive = workbench.WorkbenchLayout.ActiveWorkbenchwindow == this;
</I>&gt;<i> -			WorkbenchWindowEventArgs args = new WorkbenchWindowEventArgs (force, wasActive);
</I>&gt;<i> -			args.Cancel = false;
</I>&gt;<i> -			OnClosing (args);
</I>&gt;<i> -			if (args.Cancel)
</I>&gt;<i> -				return false;
</I>&gt;<i> -			if (fromMenu == true) {
</I>&gt;<i> -				workbench.WorkbenchLayout.RemoveTab (tabControl.PageNum(this));
</I>&gt;<i> -			} else {
</I>&gt;<i> -				workbench.WorkbenchLayout.RemoveTab (pageNum);
</I>&gt;<i> -			}
</I>&gt;<i> -			
</I>&gt;<i> -			content.ContentNameChanged -= new EventHandler(SetTitleEvent);
</I>&gt;<i> -			content.DirtyChanged       -= new EventHandler(SetTitleEvent);
</I>&gt;<i> -			content.BeforeSave         -= new EventHandler(BeforeSave);
</I>&gt;<i> -			content.ContentChanged     -= new EventHandler (OnContentChanged);
</I>&gt;<i> -			content.WorkbenchWindow = null;
</I>&gt;<i> -			
</I>&gt;<i> -			if (subViewContents != null) {
</I>&gt;<i> -				foreach (IAttachableViewContent sv in subViewContents) {
</I>&gt;<i> -					subViewNotebook.Remove (sv.Control);
</I>&gt;<i> -					sv.Dispose ();
</I>&gt;<i> -				}
</I>&gt;<i> -				this.subViewContents = null;
</I>&gt;<i> -				subViewNotebook.Remove (content.Control);
</I>&gt;<i> -			} else {
</I>&gt;<i> -				box.Remove (content.Control);
</I>&gt;<i> -			}
</I>&gt;<i> -			content.Dispose ();
</I>&gt;<i> -			tabLabel.Dispose ();
</I>&gt;<i> -			
</I>&gt;<i> -			this.subViewToolbar = null;
</I>&gt;<i> -			this.separatorItem = null;
</I>&gt;<i> -			DetachFromPathedDocument ();
</I>&gt;<i> -
</I>&gt;<i> -			OnClosed (args);
</I>&gt;<i> -			
</I>&gt;<i> -			this.content = null;
</I>&gt;<i> -			this.subViewNotebook = null;
</I>&gt;<i> -			this.tabControl = null;
</I>&gt;<i> -			this.tabLabel = null;
</I>&gt;<i> -			this.tabPage = null;
</I>&gt;<i> -			Destroy ();
</I>&gt;<i> -			return true;
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		#region lazy UI element creation
</I>&gt;<i> -		
</I>&gt;<i> -		void CheckCreateSubViewToolbar ()
</I>&gt;<i> -		{
</I>&gt;<i> -			if (subViewToolbar != null)
</I>&gt;<i> -				return;
</I>&gt;<i> -			
</I>&gt;<i> -			subViewToolbar = new Toolbar ();
</I>&gt;<i> -			subViewToolbar.IconSize = IconSize.SmallToolbar;
</I>&gt;<i> -			subViewToolbar.ToolbarStyle = ToolbarStyle.BothHoriz;
</I>&gt;<i> -			subViewToolbar.ShowArrow = false;
</I>&gt;<i> -			subViewToolbar.Show ();
</I>&gt;<i> -			
</I>&gt;<i> -			CheckCreateToolbarBox ();
</I>&gt;<i> -			toolbarBox.PackStart (subViewToolbar, false, false, 0);
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		void EnsureToolbarBoxSeparator ()
</I>&gt;<i> -		{
</I>&gt;<i> -			if (toolbarBox == null || subViewToolbar == null)
</I>&gt;<i> -				return;
</I>&gt;<i> -
</I>&gt;<i> -			if (separatorItem != null &amp;&amp; pathBox == null) {
</I>&gt;<i> -				subViewToolbar.Remove (separatorItem);
</I>&gt;<i> -				separatorItem = null;
</I>&gt;<i> -			} else if (separatorItem == null &amp;&amp; pathBox != null) {
</I>&gt;<i> -				separatorItem = new SeparatorToolItem ();
</I>&gt;<i> -				subViewToolbar.Insert (separatorItem, -1);
</I>&gt;<i> -			} else if (separatorItem != null &amp;&amp; pathBox != null) {
</I>&gt;<i> -				if (subViewToolbar.GetItemIndex(separatorItem) != subViewToolbar.NumChildren - 1) {
</I>&gt;<i> -					subViewToolbar.Remove (separatorItem);
</I>&gt;<i> -					subViewToolbar.Insert (separatorItem, -1);
</I>&gt;<i> -				}
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		void CheckCreateToolbarBox ()
</I>&gt;<i> -		{
</I>&gt;<i> -			if (toolbarBox != null)
</I>&gt;<i> -				return;
</I>&gt;<i> -			toolbarBox = new HBox (false, 6);
</I>&gt;<i> -			toolbarBox.Show ();
</I>&gt;<i> -			box.PackEnd (toolbarBox, false, false, 3);
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		void CheckCreateSubViewContents ()
</I>&gt;<i> -		{
</I>&gt;<i> -			if (subViewContents != null)
</I>&gt;<i> -				return;
</I>&gt;<i> -			
</I>&gt;<i> -			subViewContents = new ArrayList ();
</I>&gt;<i> -			
</I>&gt;<i> -			box.Remove (this.ViewContent.Control);
</I>&gt;<i> -			
</I>&gt;<i> -			subViewNotebook = new Notebook ();
</I>&gt;<i> -			subViewNotebook.TabPos = PositionType.Bottom;
</I>&gt;<i> -			subViewNotebook.ShowTabs = false;
</I>&gt;<i> -			subViewNotebook.ShowBorder = false;
</I>&gt;<i> -			subViewNotebook.Show ();
</I>&gt;<i> -			subViewNotebook.SwitchPage += subViewNotebookIndexChanged;
</I>&gt;<i> -			
</I>&gt;<i> -			//add existing ViewContent
</I>&gt;<i> -			AddButton (this.ViewContent.TabPageLabel, this.ViewContent.Control).Active = true;
</I>&gt;<i> -			
</I>&gt;<i> -			//pack them in a box
</I>&gt;<i> -			box.PackStart (subViewNotebook, true, true, 0);
</I>&gt;<i> -			box.ShowAll ();
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		#endregion
</I>&gt;<i> -		
</I>&gt;<i> -			
</I>&gt;<i> -		public void AttachViewContent (IAttachableViewContent subViewContent)
</I>&gt;<i> -		{
</I>&gt;<i> -			// need to create child Notebook when first IAttachableViewContent is added
</I>&gt;<i> -			CheckCreateSubViewContents ();
</I>&gt;<i> -			
</I>&gt;<i> -			subViewContents.Add (subViewContent);
</I>&gt;<i> -			subViewContent.WorkbenchWindow = this;
</I>&gt;<i> -			AddButton (subViewContent.TabPageLabel, subViewContent.Control);
</I>&gt;<i> -			
</I>&gt;<i> -			OnContentChanged (null, null);
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		bool updating = false;
</I>&gt;<i> -		protected ToggleToolButton AddButton (string label, Gtk.Widget page)
</I>&gt;<i> -		{
</I>&gt;<i> -			CheckCreateSubViewToolbar ();
</I>&gt;<i> -			updating = true;
</I>&gt;<i> -			ToggleToolButton button = new ToggleToolButton ();
</I>&gt;<i> -			button.Label = label;
</I>&gt;<i> -			button.IsImportant = true;
</I>&gt;<i> -			button.Clicked += new EventHandler (OnButtonToggled);
</I>&gt;<i> -			button.ShowAll ();
</I>&gt;<i> -			subViewToolbar.Insert (button, -1);
</I>&gt;<i> -			subViewNotebook.AppendPage (page, new Gtk.Label ());
</I>&gt;<i> -			page.ShowAll ();
</I>&gt;<i> -			EnsureToolbarBoxSeparator ();
</I>&gt;<i> -			updating = false;
</I>&gt;<i> -			return button;
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		#region Track and display document's &quot;path&quot;
</I>&gt;<i> -		
</I>&gt;<i> -		internal void AttachToPathedDocument (MonoDevelop.Ide.Gui.Content.IPathedDocument pathDoc)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (this.pathDoc != pathDoc)
</I>&gt;<i> -				DetachFromPathedDocument ();
</I>&gt;<i> -			if (pathDoc == null)
</I>&gt;<i> -				return;
</I>&gt;<i> -			PathWidgetEnabled = true;
</I>&gt;<i> -			pathDoc.PathChanged += HandlePathChange;
</I>&gt;<i> -			this.pathDoc = pathDoc;
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		internal void DetachFromPathedDocument ()
</I>&gt;<i> -		{
</I>&gt;<i> -			if (pathDoc == null)
</I>&gt;<i> -				return;
</I>&gt;<i> -			PathWidgetEnabled = false;
</I>&gt;<i> -			pathDoc.PathChanged -= HandlePathChange;
</I>&gt;<i> -			pathDoc = null;
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		void HandlePathChange (object sender, MonoDevelop.Ide.Gui.Content.DocumentPathChangedEventArgs args)
</I>&gt;<i> -		{
</I>&gt;<i> -			MonoDevelop.Ide.Gui.Content.IPathedDocument pathDoc = (MonoDevelop.Ide.Gui.Content.IPathedDocument) sender;
</I>&gt;<i> -			
</I>&gt;<i> -			while (pathBox.Children.Length &gt; 0)
</I>&gt;<i> -				pathBox.Remove (pathBox.Children[0]);
</I>&gt;<i> -			
</I>&gt;<i> -			if (pathDoc.CurrentPath == null || pathDoc.CurrentPath.Length == 0)
</I>&gt;<i> -				return;
</I>&gt;<i> -			
</I>&gt;<i> -			for (int i = 0; i &lt; pathDoc.CurrentPath.Length; i++) {
</I>&gt;<i> -				PathMenuButton button = new PathMenuButton (pathDoc, i);
</I>&gt;<i> -				button.ArrowType = (i + 1 &lt; pathDoc.CurrentPath.Length)? ArrowType.Right : (ArrowType?) null;
</I>&gt;<i> -				
</I>&gt;<i> -				if (i == pathDoc.SelectedIndex) {
</I>&gt;<i> -					string escaped = GLib.Markup.EscapeText (pathDoc.CurrentPath[i]);
</I>&gt;<i> -					button.Markup = string.Concat (&quot;&lt;b&gt;&quot;, escaped ,&quot;&lt;/b&gt;&quot;);
</I>&gt;<i> -				} else {
</I>&gt;<i> -					button.Label = pathDoc.CurrentPath[i];
</I>&gt;<i> -				}
</I>&gt;<i> -				pathBox.PackStart (button, false, false, 0);
</I>&gt;<i> -			}
</I>&gt;<i> -			pathBox.PackEnd (new Label (string.Empty), true, true, 0);
</I>&gt;<i> -			pathBox.ShowAll ();
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		bool PathWidgetEnabled {
</I>&gt;<i> -			get { return (pathBox != null); }
</I>&gt;<i> -			set {
</I>&gt;<i> -				if (PathWidgetEnabled == value)
</I>&gt;<i> -					return;
</I>&gt;<i> -				if (value) {
</I>&gt;<i> -					CheckCreateToolbarBox ();
</I>&gt;<i> -					
</I>&gt;<i> -					pathBox = new HBox ();
</I>&gt;<i> -					pathBox.Spacing = 0;
</I>&gt;<i> -					
</I>&gt;<i> -					toolbarBox.PackEnd (pathBox, true, true, 0);
</I>&gt;<i> -					toolbarBox.ShowAll ();
</I>&gt;<i> -				} else {
</I>&gt;<i> -					toolbarBox.Remove (pathBox);
</I>&gt;<i> -					toolbarBox.Destroy ();
</I>&gt;<i> -				}
</I>&gt;<i> -				EnsureToolbarBoxSeparator ();
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		private class PathMenuButton : MenuButton
</I>&gt;<i> -		{
</I>&gt;<i> -			MonoDevelop.Ide.Gui.Content.IPathedDocument pathDoc;
</I>&gt;<i> -			int index;
</I>&gt;<i> -			
</I>&gt;<i> -			public PathMenuButton (MonoDevelop.Ide.Gui.Content.IPathedDocument pathDoc, int index)
</I>&gt;<i> -			{
</I>&gt;<i> -				this.pathDoc = pathDoc;
</I>&gt;<i> -				this.index = index;
</I>&gt;<i> -				this.MenuCreator = PathMenuCreator;
</I>&gt;<i> -				this.Relief = Gtk.ReliefStyle.None;
</I>&gt;<i> -			}
</I>&gt;<i> -			
</I>&gt;<i> -			Menu PathMenuCreator (MenuButton button)	
</I>&gt;<i> -			{
</I>&gt;<i> -				Menu menu = new Menu ();
</I>&gt;<i> -				MenuItem mi = new MenuItem (GettextCatalog.GetString (&quot;Select&quot;));
</I>&gt;<i> -				mi.Activated += delegate {
</I>&gt;<i> -					pathDoc.SelectPath (index);
</I>&gt;<i> -				};
</I>&gt;<i> -				menu.Add (mi);
</I>&gt;<i> -				mi = new MenuItem (GettextCatalog.GetString (&quot;Select contents&quot;));
</I>&gt;<i> -				mi.Activated += delegate {
</I>&gt;<i> -					pathDoc.SelectPathContents (index);
</I>&gt;<i> -				};
</I>&gt;<i> -				menu.Add (mi);
</I>&gt;<i> -				menu.ShowAll ();
</I>&gt;<i> -				return menu;
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		#endregion
</I>&gt;<i> -		
</I>&gt;<i> -		protected void ShowPage (int npage)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (updating) return;
</I>&gt;<i> -			updating = true;
</I>&gt;<i> -			
</I>&gt;<i> -			subViewNotebook.CurrentPage = npage;
</I>&gt;<i> -			Gtk.Widget[] buttons = subViewToolbar.Children;
</I>&gt;<i> -			for (int n=0; n&lt;buttons.Length; n++) {
</I>&gt;<i> -				if (buttons [n] is ToggleToolButton) {
</I>&gt;<i> -					ToggleToolButton b = (ToggleToolButton) buttons [n];
</I>&gt;<i> -					b.Active = (n == npage);
</I>&gt;<i> -				}
</I>&gt;<i> -			}
</I>&gt;<i> -
</I>&gt;<i> -			updating = false;
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		void OnButtonToggled (object s, EventArgs args)
</I>&gt;<i> -		{
</I>&gt;<i> -			int i = Array.IndexOf (subViewToolbar.Children, s);
</I>&gt;<i> -			if (i != -1)
</I>&gt;<i> -				ShowPage (i);
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		int oldIndex = -1;
</I>&gt;<i> -		protected void subViewNotebookIndexChanged(object sender, SwitchPageArgs e)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (oldIndex &gt; 0) {
</I>&gt;<i> -				IAttachableViewContent secondaryViewContent = subViewContents[oldIndex - 1] as IAttachableViewContent;
</I>&gt;<i> -				if (secondaryViewContent != null) {
</I>&gt;<i> -					secondaryViewContent.Deselected();
</I>&gt;<i> -				}
</I>&gt;<i> -			}
</I>&gt;<i> -			
</I>&gt;<i> -			if (subViewNotebook.CurrentPage &gt; 0) {
</I>&gt;<i> -				IAttachableViewContent secondaryViewContent = subViewContents[subViewNotebook.CurrentPage - 1] as IAttachableViewContent;
</I>&gt;<i> -				if (secondaryViewContent != null) {
</I>&gt;<i> -					secondaryViewContent.Selected();
</I>&gt;<i> -				}
</I>&gt;<i> -			}
</I>&gt;<i> -			oldIndex = subViewNotebook.CurrentPage;
</I>&gt;<i> -			
</I>&gt;<i> -			OnActiveViewContentChanged (new ActiveViewContentEventArgs (this.ActiveViewContent));
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		object ICommandDelegatorRouter.GetNextCommandTarget ()
</I>&gt;<i> -		{
</I>&gt;<i> -			return Parent;
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		object ICommandDelegatorRouter.GetDelegatedCommandTarget ()
</I>&gt;<i> -		{
</I>&gt;<i> -			Gtk.Widget w = content as Gtk.Widget;
</I>&gt;<i> -			if (w != this.tabPage) {
</I>&gt;<i> -				// Route commands to the view
</I>&gt;<i> -				return content;
</I>&gt;<i> -			} else
</I>&gt;<i> -				return null;
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		protected virtual void OnTitleChanged(EventArgs e)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (show_notification) {
</I>&gt;<i> -				tabLabel.Label.Markup = &quot;&lt;span foreground=\&quot;blue\&quot;&gt;&quot; + Title + &quot;&lt;/span&gt;&quot;;
</I>&gt;<i> -				tabLabel.Label.UseMarkup = true;
</I>&gt;<i> -			} else {
</I>&gt;<i> -				tabLabel.Label.Text = Title;
</I>&gt;<i> -				tabLabel.Label.UseMarkup = false;
</I>&gt;<i> -			}
</I>&gt;<i> -			
</I>&gt;<i> -			if (content.ContentName != null &amp;&amp; content.ContentName != &quot;&quot;) {
</I>&gt;<i> -				tabLabel.SetTooltip (content.ContentName, content.ContentName);
</I>&gt;<i> -			}
</I>&gt;<i> -
</I>&gt;<i> -			try {
</I>&gt;<i> -				if (content.StockIconId != null ) {
</I>&gt;<i> -					tabLabel.Icon = new Gtk.Image ( content.StockIconId, IconSize.Menu );
</I>&gt;<i> -				}
</I>&gt;<i> -				else if (content.ContentName != null &amp;&amp; content.ContentName.IndexOfAny (new char[] { '*', '+'}) == -1) {
</I>&gt;<i> -					tabLabel.Icon.Pixbuf = DesktopService.GetPixbufForFile (content.ContentName, Gtk.IconSize.Menu);
</I>&gt;<i> -				}
</I>&gt;<i> -			} catch (Exception ex) {
</I>&gt;<i> -				LoggingService.LogError (ex.ToString ());
</I>&gt;<i> -				tabLabel.Icon.Pixbuf = DesktopService.GetPixbufForType (&quot;gnome-fs-regular&quot;, Gtk.IconSize.Menu);
</I>&gt;<i> -			}
</I>&gt;<i> -
</I>&gt;<i> -			if (TitleChanged != null) {
</I>&gt;<i> -				TitleChanged(this, e);
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		protected virtual void OnClosing (WorkbenchWindowEventArgs e)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (Closing != null) {
</I>&gt;<i> -				Closing (this, e);
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		protected virtual void OnClosed (WorkbenchWindowEventArgs e)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (Closed != null) {
</I>&gt;<i> -				Closed (this, e);
</I>&gt;<i> -			}
</I>&gt;<i> -		}
</I>&gt;<i> -		
</I>&gt;<i> -		protected virtual void OnActiveViewContentChanged (ActiveViewContentEventArgs e)
</I>&gt;<i> -		{
</I>&gt;<i> -			if (ActiveViewContentChanged != null)
</I>&gt;<i> -				ActiveViewContentChanged (this, e);
</I>&gt;<i> -		}
</I>&gt;<i> -
</I>&gt;<i> -		public event EventHandler TitleChanged;
</I>&gt;<i> -		public event WorkbenchWindowEventHandler Closed;
</I>&gt;<i> -		public event WorkbenchWindowEventHandler Closing;
</I>&gt;<i> -		public event ActiveViewContentEventHandler ActiveViewContentChanged;
</I>&gt;<i> -	}
</I>&gt;<i> -}
</I>&gt;<i> +&#65279;// SdiWorkspaceWindow.cs
</I>&gt;<i> +//
</I>&gt;<i> +// Author:
</I>&gt;<i> +//   Viktoria Dudka (<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">viktoriad at remobjects.com</A>)
</I>&gt;<i> +//
</I>&gt;<i> +// Copyright (c) 2009 RemObjects Software
</I>&gt;<i> +//
</I>&gt;<i> +// Permission is hereby granted, free of charge, to any person obtaining a copy
</I>&gt;<i> +// of this software and associated documentation files (the &quot;Software&quot;), to deal
</I>&gt;<i> +// in the Software without restriction, including without limitation the rights
</I>&gt;<i> +// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
</I>&gt;<i> +// copies of the Software, and to permit persons to whom the Software is
</I>&gt;<i> +// furnished to do so, subject to the following conditions:
</I>&gt;<i> +//
</I>&gt;<i> +// The above copyright notice and this permission notice shall be included in
</I>&gt;<i> +// all copies or substantial portions of the Software.
</I>&gt;<i> +//
</I>&gt;<i> +// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
</I>&gt;<i> +// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
</I>&gt;<i> +// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
</I>&gt;<i> +// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
</I>&gt;<i> +// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
</I>&gt;<i> +// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
</I>&gt;<i> +// THE SOFTWARE.
</I>&gt;<i> +//
</I>&gt;<i> +//
</I>&gt;<i> +
</I>&gt;<i> +using System;
</I>&gt;<i> +using System.Collections.Generic;
</I>&gt;<i> +using System.Linq;
</I>&gt;<i> +using System.Text;
</I>&gt;<i> +using Gtk;
</I>&gt;<i> +using MonoDevelop.Components.Commands;
</I>&gt;<i> +using MonoDevelop.Components;
</I>&gt;<i> +using System.Collections;
</I>&gt;<i> +using MonoDevelop.Core.Gui;
</I>&gt;<i> +using MonoDevelop.Core;
</I>&gt;<i> +using MonoDevelop.Ide.Gui.Content;
</I>&gt;<i> +
</I>&gt;<i> +namespace MonoDevelop.Ide.Gui
</I>&gt;<i> +{
</I>&gt;<i> +    class SdiWorkspaceWindow : Frame, IWorkbenchWindow, ICommandDelegatorRouter
</I>&gt;<i> +	{
</I>&gt;<i> +        private VBox vBox = null;
</I>&gt;<i> +        private IWorkbench workbench = null;
</I>&gt;<i> +        private IViewContent content = null;
</I>&gt;<i> +        private Notebook tabControl = null;
</I>&gt;<i> +
</I>&gt;<i> +        private ViewCommandHandlers viewCommandHandlers = null;
</I>&gt;<i> +
</I>&gt;<i> +        private Notebook subViewNotebook = null;
</I>&gt;<i> +
</I>&gt;<i> +        private bool updating = false;
</I>&gt;<i> +
</I>&gt;<i> +        private Toolbar subViewToolbar = null;
</I>&gt;<i> +
</I>&gt;<i> +        private TabLabel tabLabel = null;
</I>&gt;<i> +        public TabLabel TabLabel
</I>&gt;<i> +        {
</I>&gt;<i> +            get { return tabLabel; }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private ViewCommandHandlers commandHandler = null;
</I>&gt;<i> +        public ViewCommandHandlers CommandHandler
</I>&gt;<i> +        {
</I>&gt;<i> +            get { return commandHandler; }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +        public SdiWorkspaceWindow (IWorkbench workbench, IViewContent content, Notebook tabControl, TabLabel tabLabel): base()
</I>&gt;<i> +        {
</I>&gt;<i> +            vBox = new VBox();
</I>&gt;<i> +            vBox.Add (content.Control);
</I>&gt;<i> +            this.Add (vBox);
</I>&gt;<i> +            Show ();
</I>&gt;<i> +            vBox.Show ();
</I>&gt;<i> +            content.Control.Show ();
</I>&gt;<i> +
</I>&gt;<i> +            this.workbench = workbench;
</I>&gt;<i> +            this.content = content;
</I>&gt;<i> +            this.tabControl = tabControl;
</I>&gt;<i> +            this.tabLabel = tabLabel;
</I>&gt;<i> +            
</I>&gt;<i> +
</I>&gt;<i> +            SetTitleEvent (null, null);
</I>&gt;<i> +
</I>&gt;<i> +            content.WorkbenchWindow = this;
</I>&gt;<i> +
</I>&gt;<i> +            content.ContentChanged += new EventHandler (OnContentChanged);
</I>&gt;<i> +            content.BeforeSave += new EventHandler (OnBeforeSave);
</I>&gt;<i> +            content.ContentNameChanged += new EventHandler (SetTitleEvent);
</I>&gt;<i> +            content.DirtyChanged += new EventHandler (SetTitleEvent);
</I>&gt;<i> +
</I>&gt;<i> +            viewCommandHandlers = new ViewCommandHandlers (this);
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        protected SdiWorkspaceWindow (IntPtr intPtr): base (intPtr)
</I>&gt;<i> +        {
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        #region ICommandDelegatorRouter Members
</I>&gt;<i> +
</I>&gt;<i> +        public object GetNextCommandTarget ()
</I>&gt;<i> +        {
</I>&gt;<i> +            return Parent;
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        public object GetDelegatedCommandTarget ()
</I>&gt;<i> +        {
</I>&gt;<i> +            return content != content.Control ? content : null;
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        #endregion
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +        #region IWorkbenchWindow Members
</I>&gt;<i> +
</I>&gt;<i> +        private string title = &quot;&quot;;
</I>&gt;<i> +        public string Title
</I>&gt;<i> +        {
</I>&gt;<i> +            get
</I>&gt;<i> +            {
</I>&gt;<i> +                return title;
</I>&gt;<i> +            }
</I>&gt;<i> +            set
</I>&gt;<i> +            {
</I>&gt;<i> +                title = value;
</I>&gt;<i> +                OnTitleChanged (EventArgs.Empty);
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private string documentType = null;
</I>&gt;<i> +        public string DocumentType
</I>&gt;<i> +        {
</I>&gt;<i> +            get
</I>&gt;<i> +            {
</I>&gt;<i> +                return documentType;
</I>&gt;<i> +            }
</I>&gt;<i> +            set
</I>&gt;<i> +            {
</I>&gt;<i> +                documentType = value;
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private bool showNotification = false;
</I>&gt;<i> +        public bool ShowNotification
</I>&gt;<i> +        {
</I>&gt;<i> +            get
</I>&gt;<i> +            {
</I>&gt;<i> +                return showNotification;
</I>&gt;<i> +            }
</I>&gt;<i> +            set
</I>&gt;<i> +            {
</I>&gt;<i> +                if (showNotification != value) {
</I>&gt;<i> +                    showNotification = value;
</I>&gt;<i> +                }
</I>&gt;<i> +
</I>&gt;<i> +                OnTitleChanged (EventArgs.Empty);
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        public IViewContent ViewContent
</I>&gt;<i> +        {
</I>&gt;<i> +            get { return content; } //maybe we need setter
</I>&gt;<i> +            set { content = value; }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private ArrayList subViewContents = null;
</I>&gt;<i> +        public ArrayList SubViewContents
</I>&gt;<i> +        {
</I>&gt;<i> +            get { return subViewContents; }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private IBaseViewContent activeViewContent = null;
</I>&gt;<i> +        public IBaseViewContent ActiveViewContent
</I>&gt;<i> +        {
</I>&gt;<i> +            get
</I>&gt;<i> +            {
</I>&gt;<i> +                if (activeViewContent != null)
</I>&gt;<i> +                    return activeViewContent;
</I>&gt;<i> +
</I>&gt;<i> +                if ((subViewNotebook != null) &amp;&amp; (subViewNotebook.CurrentPage &gt; 0))
</I>&gt;<i> +                    return (IBaseViewContent)subViewContents[subViewNotebook.CurrentPage - 1];
</I>&gt;<i> +                else
</I>&gt;<i> +                    return content;
</I>&gt;<i> +                
</I>&gt;<i> +            }
</I>&gt;<i> +            set
</I>&gt;<i> +            {
</I>&gt;<i> +                activeViewContent = value;
</I>&gt;<i> +                OnActiveViewContentChanged(new ActiveViewContentEventArgs(value));
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private Document document = null;
</I>&gt;<i> +        public Document Document
</I>&gt;<i> +        {
</I>&gt;<i> +            get
</I>&gt;<i> +            {
</I>&gt;<i> +                return document;
</I>&gt;<i> +            }
</I>&gt;<i> +            set
</I>&gt;<i> +            {
</I>&gt;<i> +                document = value;
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        public bool CloseWindow (bool force, bool fromMenu, int pageNum)
</I>&gt;<i> +        {
</I>&gt;<i> +            WorkbenchWindowEventArgs workbenchWindowEventArgs = new WorkbenchWindowEventArgs (force, (workbench.WorkbenchLayout.ActiveWorkbenchwindow == this));
</I>&gt;<i> +            OnClosing (workbenchWindowEventArgs);
</I>&gt;<i> +            if (workbenchWindowEventArgs.Cancel)
</I>&gt;<i> +                return false;
</I>&gt;<i> +
</I>&gt;<i> +            content.ContentChanged -= new EventHandler (OnContentChanged);
</I>&gt;<i> +            content.BeforeSave -= new EventHandler (OnBeforeSave);
</I>&gt;<i> +            content.ContentNameChanged -= new EventHandler (SetTitleEvent);
</I>&gt;<i> +            content.DirtyChanged -= new EventHandler (SetTitleEvent);
</I>&gt;<i> +
</I>&gt;<i> +            content.WorkbenchWindow = null;
</I>&gt;<i> +
</I>&gt;<i> +            if (subViewContents != null) {
</I>&gt;<i> +                subViewNotebook.Remove (content.Control);
</I>&gt;<i> +                foreach (IAttachableViewContent subViewContent in subViewContents)
</I>&gt;<i> +                {
</I>&gt;<i> +                    subViewContent.Dispose ();
</I>&gt;<i> +                    subViewNotebook.Remove (subViewContent.Control);
</I>&gt;<i> +                }
</I>&gt;<i> +            }
</I>&gt;<i> +            else {
</I>&gt;<i> +                vBox.Remove (content.Control);
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            content.Dispose ();
</I>&gt;<i> +            tabLabel.Dispose ();
</I>&gt;<i> +
</I>&gt;<i> +            DetachFromPathedDocument ();
</I>&gt;<i> +            OnClosed (workbenchWindowEventArgs);
</I>&gt;<i> +            Destroy ();
</I>&gt;<i> +
</I>&gt;<i> +            content = null;
</I>&gt;<i> +
</I>&gt;<i> +            return true;
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        public void SelectWindow ()
</I>&gt;<i> +        {
</I>&gt;<i> +            if (this.Parent == null)
</I>&gt;<i> +                return;
</I>&gt;<i> +            tabControl.CurrentPage = tabControl.PageNum (this);
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        public void SwitchView (int viewNumber)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (subViewNotebook == null)
</I>&gt;<i> +                return;
</I>&gt;<i> +
</I>&gt;<i> +            if (updating)
</I>&gt;<i> +                return;
</I>&gt;<i> +
</I>&gt;<i> +            updating = true;
</I>&gt;<i> +            subViewNotebook.CurrentPage = viewNumber;
</I>&gt;<i> +
</I>&gt;<i> +            int i = 0;
</I>&gt;<i> +            foreach (Widget widget in subViewToolbar.Children) {
</I>&gt;<i> +                ToggleToolButton btn = widget as ToggleToolButton;
</I>&gt;<i> +                if (btn != null) {
</I>&gt;<i> +                    btn.Active = (i == viewNumber);
</I>&gt;<i> +                }
</I>&gt;<i> +                i++;
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            updating = false;
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        public void AttachViewContent (IAttachableViewContent subViewContent)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (subViewContents == null) {
</I>&gt;<i> +                subViewContents = new ArrayList ();
</I>&gt;<i> +                vBox.Remove (ViewContent.Control);
</I>&gt;<i> +
</I>&gt;<i> +                subViewNotebook = new Notebook ();
</I>&gt;<i> +                subViewNotebook.ShowBorder = false;
</I>&gt;<i> +                subViewNotebook.ShowTabs = false;
</I>&gt;<i> +                subViewNotebook.TabPos = PositionType.Bottom;
</I>&gt;<i> +                subViewNotebook.SwitchPage += subViewNotebookIndexChanged;
</I>&gt;<i> +                subViewNotebook.Show ();
</I>&gt;<i> +
</I>&gt;<i> +                ToggleToolButton toggleToolButton = AddButton (ViewContent.TabPageLabel, ViewContent.Control);
</I>&gt;<i> +                toggleToolButton.Active = true;
</I>&gt;<i> +
</I>&gt;<i> +                vBox.PackStart (subViewNotebook, true, true, 0);
</I>&gt;<i> +                vBox.ShowAll ();
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            subViewContent.WorkbenchWindow = this;
</I>&gt;<i> +            subViewContents.Add (subViewContent);
</I>&gt;<i> +
</I>&gt;<i> +            AddButton (subViewContent.TabPageLabel, subViewContent.Control);
</I>&gt;<i> +
</I>&gt;<i> +            OnContentChanged (null, null);
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        public event EventHandler TitleChanged;
</I>&gt;<i> +
</I>&gt;<i> +        public event WorkbenchWindowEventHandler Closing;
</I>&gt;<i> +
</I>&gt;<i> +        public event WorkbenchWindowEventHandler Closed;
</I>&gt;<i> +
</I>&gt;<i> +        public event ActiveViewContentEventHandler ActiveViewContentChanged;
</I>&gt;<i> +
</I>&gt;<i> +        #endregion
</I>&gt;<i> +
</I>&gt;<i> +        private void OnTitleChanged (EventArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            tabLabel.Label.UseMarkup = showNotification;
</I>&gt;<i> +            if (showNotification)
</I>&gt;<i> +                tabLabel.Label.Markup = String.Format (&quot;&lt;span foreground=\&quot;blue\&quot;&gt;{0}&lt;/span&gt;&quot;, Title);
</I>&gt;<i> +            else
</I>&gt;<i> +                tabLabel.Label.Text = Title;
</I>&gt;<i> +
</I>&gt;<i> +            if (!String.IsNullOrEmpty (content.ContentName))
</I>&gt;<i> +                tabLabel.SetTooltip (content.ContentName, content.ContentName);
</I>&gt;<i> +
</I>&gt;<i> +            try {
</I>&gt;<i> +                if (!String.IsNullOrEmpty (content.StockIconId)) {
</I>&gt;<i> +                    tabLabel.Icon = new Gtk.Image (content.StockIconId, IconSize.Menu);
</I>&gt;<i> +                }
</I>&gt;<i> +                else if (!String.IsNullOrEmpty (content.ContentName) &amp;&amp; !(content.ContentName.Contains (&quot;+&quot;) &amp;&amp; content.ContentName.Contains (&quot;*&quot;))) {
</I>&gt;<i> +                    tabLabel.Icon.Pixbuf = DesktopService.GetPixbufForFile (content.ContentName, IconSize.Menu);
</I>&gt;<i> +                }
</I>&gt;<i> +            }
</I>&gt;<i> +            catch (Exception ex) {
</I>&gt;<i> +                LoggingService.LogError (ex.ToString ());
</I>&gt;<i> +                tabLabel.Icon.Pixbuf = DesktopService.GetPixbufForType (&quot;gnome-fs-regular&quot;, IconSize.Menu);
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            if (TitleChanged != null) 
</I>&gt;<i> +                TitleChanged(this, e);
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        protected virtual void OnActiveViewContentChanged (ActiveViewContentEventArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (ActiveViewContentChanged != null)
</I>&gt;<i> +                ActiveViewContentChanged (this, e);
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        protected virtual void OnClosing (WorkbenchWindowEventArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (Closing != null)
</I>&gt;<i> +                Closing (this, e);
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        protected virtual void OnClosed (WorkbenchWindowEventArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (Closed != null)
</I>&gt;<i> +                Closed (this, e);
</I>&gt;<i> +        }
</I>&gt;<i> +        
</I>&gt;<i> +        public void OnContentChanged (System.Object o, EventArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (subViewContents != null) {
</I>&gt;<i> +                foreach (IAttachableViewContent subViewContent in subViewContents)
</I>&gt;<i> +                    subViewContent.BaseContentChanged ();
</I>&gt;<i> +
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private void OnBeforeSave (System.Object o, EventArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (ActiveViewContent is IAttachableViewContent)
</I>&gt;<i> +                ((IAttachableViewContent)ActiveViewContent).BeforeSave ();
</I>&gt;<i> +
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private string untitledName;
</I>&gt;<i> +        public void SetTitleEvent (System.Object o, EventArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (content == null)
</I>&gt;<i> +                return;
</I>&gt;<i> +
</I>&gt;<i> +            string title = &quot;&quot;;
</I>&gt;<i> +            if (!String.IsNullOrEmpty (content.ContentName)) {
</I>&gt;<i> +                title = System.IO.Path.GetFileName (content.ContentName);
</I>&gt;<i> +                untitledName = null;
</I>&gt;<i> +            }
</I>&gt;<i> +            else {
</I>&gt;<i> +                string baseName = System.IO.Path.GetFileNameWithoutExtension (content.UntitledName);
</I>&gt;<i> +                untitledName = baseName + System.IO.Path.GetExtension (content.UntitledName);
</I>&gt;<i> +
</I>&gt;<i> +                if (!TitleExists (untitledName)) {
</I>&gt;<i> +                    int i = 1;
</I>&gt;<i> +                    while (true) {
</I>&gt;<i> +                        untitledName = baseName + i + System.IO.Path.GetExtension (content.UntitledName);
</I>&gt;<i> +                        if ( TitleExists(untitledName)) break;
</I>&gt;<i> +                        i++;
</I>&gt;<i> +                    }
</I>&gt;<i> +                }
</I>&gt;<i> +                else
</I>&gt;<i> +                    title = untitledName;
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            if (content.IsDirty) {
</I>&gt;<i> +                title = title + &quot;*&quot;;
</I>&gt;<i> +                IdeApp.ProjectOperations.MarkFileDirty (content.ContentName);
</I>&gt;<i> +            }
</I>&gt;<i> +            else if (content.IsReadOnly) {
</I>&gt;<i> +                title = title + &quot;*&quot;;
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            Title = title;
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private bool TitleExists (string titleFound)
</I>&gt;<i> +        {
</I>&gt;<i> +            foreach (IViewContent viewContent in workbench.ViewContentCollection) {
</I>&gt;<i> +                string name = viewContent.WorkbenchWindow.Title;
</I>&gt;<i> +                if (name.EndsWith (&quot;*&quot;) || name.EndsWith (&quot;+&quot;))
</I>&gt;<i> +                    name.Remove (name.Length, 1);
</I>&gt;<i> +
</I>&gt;<i> +                if (name == titleFound)
</I>&gt;<i> +                    return true;
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            return false;
</I>&gt;<i> +
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private int prevIndex = -1;
</I>&gt;<i> +        protected void subViewNotebookIndexChanged (System.Object o, SwitchPageArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (prevIndex != -1) {
</I>&gt;<i> +                if (subViewContents[prevIndex - 1] is IAttachableViewContent) {
</I>&gt;<i> +                    ((IAttachableViewContent)subViewContents[prevIndex - 1]).Deselected ();
</I>&gt;<i> +                }
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            prevIndex = subViewNotebook.CurrentPage;
</I>&gt;<i> +
</I>&gt;<i> +            if (prevIndex &gt; 0) {
</I>&gt;<i> +                if (subViewContents[prevIndex - 1] is IAttachableViewContent) {
</I>&gt;<i> +                    ((IAttachableViewContent)subViewContents[prevIndex - 1]).Selected ();
</I>&gt;<i> +                }
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            OnActiveViewContentChanged (new ActiveViewContentEventArgs (ActiveViewContent));
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private HBox toolbarBox = null;
</I>&gt;<i> +        protected ToggleToolButton AddButton (String label,  Widget page)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (subViewToolbar == null) {
</I>&gt;<i> +                subViewToolbar = new Toolbar ();
</I>&gt;<i> +                subViewToolbar.ShowArrow = false;
</I>&gt;<i> +                subViewToolbar.ToolbarStyle = ToolbarStyle.BothHoriz;
</I>&gt;<i> +                subViewToolbar.IconSize = IconSize.SmallToolbar;
</I>&gt;<i> +
</I>&gt;<i> +                subViewToolbar.Show ();
</I>&gt;<i> +                CheckCreateToolbarBox ();
</I>&gt;<i> +                toolbarBox.PackStart (subViewToolbar, false, false, 0);
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            this.updating = true;
</I>&gt;<i> +
</I>&gt;<i> +            ToggleToolButton buttonResult = new ToggleToolButton ();
</I>&gt;<i> +            buttonResult.Label = label;
</I>&gt;<i> +            buttonResult.IsImportant = true;
</I>&gt;<i> +            buttonResult.Clicked += new EventHandler (OnButtonToggled);
</I>&gt;<i> +            buttonResult.ShowAll ();
</I>&gt;<i> +
</I>&gt;<i> +            subViewToolbar.Insert (buttonResult, -1);
</I>&gt;<i> +            subViewNotebook.AppendPage (page, new Gtk.Label ());
</I>&gt;<i> +            page.ShowAll ();
</I>&gt;<i> +            EnsureToolbarBoxSeparator ();
</I>&gt;<i> +
</I>&gt;<i> +            this.updating = false;
</I>&gt;<i> +
</I>&gt;<i> +            return buttonResult;
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private void OnButtonToggled (System.Object o, EventArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            int index = 0;
</I>&gt;<i> +            foreach (Widget w in subViewToolbar.Children) {
</I>&gt;<i> +                if (w == (Widget)o) {
</I>&gt;<i> +                    SwitchView (index);
</I>&gt;<i> +                    return;
</I>&gt;<i> +                }
</I>&gt;<i> +                index++;
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private void CheckCreateToolbarBox ()
</I>&gt;<i> +        {
</I>&gt;<i> +            if (toolbarBox == null ) {
</I>&gt;<i> +                toolbarBox = new HBox(false, 6);
</I>&gt;<i> +                toolbarBox.Show ();
</I>&gt;<i> +                vBox.PackEnd (toolbarBox, false, false, 3);
</I>&gt;<i> +
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private HBox pathBox = null;
</I>&gt;<i> +        private SeparatorToolItem separatorItem = null;
</I>&gt;<i> +        private void EnsureToolbarBoxSeparator() {
</I>&gt;<i> +            if ( (subViewToolbar != null) &amp;&amp; (toolbarBox != null)) {
</I>&gt;<i> +
</I>&gt;<i> +                if (pathBox == null &amp;&amp; separatorItem != null) {
</I>&gt;<i> +                    subViewToolbar.Remove (separatorItem);
</I>&gt;<i> +                    separatorItem = null;
</I>&gt;<i> +                }
</I>&gt;<i> +
</I>&gt;<i> +                if ( (separatorItem != null) &amp;&amp; (pathBox != null) &amp;&amp; (subViewToolbar.GetItemIndex (separatorItem) != subViewToolbar.NumChildren - 1)) {
</I>&gt;<i> +                    subViewToolbar.Remove (separatorItem);
</I>&gt;<i> +                    subViewToolbar.Insert (separatorItem, -1);
</I>&gt;<i> +                }
</I>&gt;<i> +                else if ( (pathBox != null) &amp;&amp; (separatorItem == null)) {
</I>&gt;<i> +                    separatorItem = new SeparatorToolItem();
</I>&gt;<i> +                    subViewToolbar.Insert (separatorItem, -1);
</I>&gt;<i> +                }
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        public bool PathWidgetEnabled
</I>&gt;<i> +        {
</I>&gt;<i> +            get
</I>&gt;<i> +            {
</I>&gt;<i> +                return (pathBox != null);
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            set
</I>&gt;<i> +            {
</I>&gt;<i> +                if ((pathBox != null) == value)
</I>&gt;<i> +                    return;
</I>&gt;<i> +
</I>&gt;<i> +                if (value) {
</I>&gt;<i> +                    CheckCreateToolbarBox ();
</I>&gt;<i> +
</I>&gt;<i> +                    pathBox = new HBox ();
</I>&gt;<i> +                    pathBox.Spacing = 0;
</I>&gt;<i> +
</I>&gt;<i> +                    toolbarBox.PackEnd (pathBox, true, true, 0);
</I>&gt;<i> +                    toolbarBox.ShowAll ();
</I>&gt;<i> +                }
</I>&gt;<i> +                else {
</I>&gt;<i> +                    toolbarBox.Remove (pathBox);
</I>&gt;<i> +                    toolbarBox.Destroy ();
</I>&gt;<i> +                }
</I>&gt;<i> +
</I>&gt;<i> +                EnsureToolbarBoxSeparator ();
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        void HandlePathChange (System.Object o, EventArgs e)
</I>&gt;<i> +        {
</I>&gt;<i> +            for (int i = pathBox.Children.Length - 1; i &gt;= 0; i--) {
</I>&gt;<i> +                pathBox.Remove (pathBox.Children[i]);
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            IPathedDocument pathedDocument = o as IPathedDocument;
</I>&gt;<i> +            for (int i = 0; i &lt; pathedDocument.CurrentPath.Length; i++) {
</I>&gt;<i> +                PathMenuButton menuButton = new PathMenuButton (pathedDocument, i);
</I>&gt;<i> +
</I>&gt;<i> +                if (i == pathedDocument.CurrentPath.Length - 1)
</I>&gt;<i> +                    menuButton.ArrowType = ArrowType.Right;
</I>&gt;<i> +                else
</I>&gt;<i> +                    menuButton.ArrowType = null;
</I>&gt;<i> +
</I>&gt;<i> +                if (pathDoc.SelectedIndex == i)
</I>&gt;<i> +                    menuButton.Markup = String.Format (&quot;&lt;b&gt;{0}&lt;/b&gt;&quot;, GLib.Markup.EscapeText (pathedDocument.CurrentPath[i]));
</I>&gt;<i> +                else
</I>&gt;<i> +                    menuButton.Label = pathDoc.CurrentPath[i];
</I>&gt;<i> +
</I>&gt;<i> +                pathBox.PackStart (menuButton, false, false, 0);
</I>&gt;<i> +
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            pathBox.PackEnd (new Label (string.Empty), true, true, 0);
</I>&gt;<i> +            pathBox.ShowAll ();
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        private IPathedDocument pathDoc = null;
</I>&gt;<i> +        public void AttachToPathedDocument (IPathedDocument pathedDocument)
</I>&gt;<i> +        {
</I>&gt;<i> +            if (this.pathDoc != pathedDocument) {
</I>&gt;<i> +                DetachFromPathedDocument ();
</I>&gt;<i> +            }
</I>&gt;<i> +
</I>&gt;<i> +            if (pathedDocument != null) {
</I>&gt;<i> +                PathWidgetEnabled = true;
</I>&gt;<i> +                pathedDocument.PathChanged += HandlePathChange;
</I>&gt;<i> +                this.pathDoc = pathedDocument;
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        public void DetachFromPathedDocument ()
</I>&gt;<i> +        {
</I>&gt;<i> +            if (pathDoc != null) {
</I>&gt;<i> +                PathWidgetEnabled = false;
</I>&gt;<i> +                pathDoc.PathChanged -= HandlePathChange;
</I>&gt;<i> +                this.pathDoc = null;
</I>&gt;<i> +            }
</I>&gt;<i> +        }
</I>&gt;<i> +
</I>&gt;<i> +        internal class PathMenuButton : MenuButton {
</I>&gt;<i> +            private IPathedDocument pathedDocument = null;
</I>&gt;<i> +            private int index;
</I>&gt;<i> +
</I>&gt;<i> +            public PathMenuButton (IPathedDocument pathedDocument, int index)
</I>&gt;<i> +        {
</I>&gt;<i> +            this.Relief = ReliefStyle.None;
</I>&gt;<i> +
</I>&gt;<i> +            this.pathedDocument = pathedDocument;
</I>&gt;<i> +            this.index = index;
</I>&gt;<i> +
</I>&gt;<i> +            this.MenuCreator = (delegate (MenuButton menuButton) 
</I>&gt;<i> +                {
</I>&gt;<i> +                    Menu menu = new Menu();
</I>&gt;<i> +                    MenuItem menuItem = new MenuItem(GettextCatalog.GetString(&quot;Select&quot;));
</I>&gt;<i> +                    menuItem.Activated += delegate { pathedDocument.SelectPath (index); };
</I>&gt;<i> +                    menu.Add (menuItem);
</I>&gt;<i> +
</I>&gt;<i> +                    MenuItem menuItemContent = new MenuItem (GettextCatalog.GetString (&quot;Select contents&quot;));
</I>&gt;<i> +                    menuItemContent.Activated += delegate { pathedDocument.SelectPathContents (index); };
</I>&gt;<i> +                    menu.Add (menuItemContent);
</I>&gt;<i> +
</I>&gt;<i> +                    menu.ShowAll ();
</I>&gt;<i> +                    
</I>&gt;<i> +                    return menu;
</I>&gt;<i> +            });
</I>&gt;<i> +        }
</I>&gt;<i> +        }
</I>&gt;<i> +       
</I>&gt;<i> +    }
</I>&gt;<i> +
</I>&gt;<i> +    
</I>&gt;<i> +}
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Monodevelop-devel-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">Monodevelop-devel-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list</A>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000173.html">[Monodevelop-devel] [PATCH] SdiWorkspaceWindow
</A></li>
	<LI>Next message: <A HREF="000174.html">[Monodevelop-devel] [patch]IDonNetLanguageBinding.cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#185">[ date ]</a>
              <a href="thread.html#185">[ thread ]</a>
              <a href="subject.html#185">[ subject ]</a>
              <a href="author.html#185">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">More information about the Monodevelop-devel-list
mailing list</a><br>
</body></html>
