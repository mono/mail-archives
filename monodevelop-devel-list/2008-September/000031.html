<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-devel] Rethinking the IDocumentMetaInformation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Rethinking%20the%20IDocumentMetaInformation&In-Reply-To=aec34c770809101046r68e04308wf0403e0f59faaf76%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000030.html">
   <LINK REL="Next"  HREF="000034.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-devel] Rethinking the IDocumentMetaInformation</H1>
    <B>Mike Kr&#252;ger</B> 
    <A HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Rethinking%20the%20IDocumentMetaInformation&In-Reply-To=aec34c770809101046r68e04308wf0403e0f59faaf76%40mail.gmail.com"
       TITLE="[Monodevelop-devel] Rethinking the IDocumentMetaInformation">mkrueger at novell.com
       </A><BR>
    <I>Thu Sep 11 04:45:18 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000030.html">[Monodevelop-devel] Rethinking the IDocumentMetaInformation
</A></li>
        <LI>Next message: <A HREF="000034.html">[Monodevelop-devel] Rethinking the IDocumentMetaInformation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31">[ date ]</a>
              <a href="thread.html#31">[ thread ]</a>
              <a href="subject.html#31">[ subject ]</a>
              <a href="author.html#31">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi

&gt;<i> &gt; My long term vision for that was that a delta parser should take care of
</I>&gt;<i> &gt; teh document meta information. The meta information should consists only
</I>&gt;<i> &gt; on stuff that are regular expressions.
</I>&gt;<i> 
</I>&gt;<i> Couldn't an incremental/delta parser be used to /update/ the
</I>&gt;<i> CompilationUnit? At this point we don't even know if/how an
</I>&gt;<i> incremental parser could be implemented, so it seems premature to
</I>&gt;<i> design around it. This also seems rather mcs-specific.
</I>&gt;<i> 
</I>
An delta parser for a regular grammar is much more easy to do than for
an context sensitive grammar (programming languages are that type). But
I think a delta parser isn't worth it, because we may have to re-parse
the whole file. But we could optimize it a bit more, it's not
neccessarry for every case to re-parse all and then the delta parser for
the other information'll make sense too.
(In fact every time where a body is changed a re-parse is unneccessary,
just the region information of the member should be updated)
&#65279;
&gt;<i> 
</I>&gt;<i> &gt;&gt; I have some suggestions for a solution.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; I suggest we have the IParser instead return an IParsedDocument,
</I>&gt;<i> which
</I>&gt;<i> &gt;&gt; would be very generic, with the basic info used by the text editor:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; &#65279;
</I>&gt;<i> &gt;&gt; IParsedDocument
</I>&gt;<i> &gt;&gt; {
</I>&gt;<i> &gt;&gt; string FileName;
</I>&gt;<i> &gt;&gt; DateTime ParseTime { get; }
</I>&gt;<i> &gt;&gt; IEnumerable&lt;Fold&gt; GetFoldLocations (); //expected to iterate
</I>&gt;<i> &gt;&gt; over types, comments etc and generate folds
</I>&gt;<i> &gt;&gt; ICollection&lt;Error&gt; Errors { get; } //also warnings
</I>&gt;<i> &gt;&gt; bool HasErrors { get; }
</I>&gt;<i> &gt;&gt; }
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; There would then be an ICompilationUnit derived interface, with
</I>&gt;<i> &gt;&gt; generic info for things like the quick finder and document outline.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; &#65279;
</I>&gt;<i> &gt;&gt; ICompilationUnit : IParsedDocument
</I>&gt;<i> &gt;&gt; {
</I>&gt;<i> &gt;&gt; &#65279;ICollection&lt;IBaseType&gt; Types { get; }
</I>&gt;<i> &gt;&gt; ICollection&lt;IBaseMember&gt; GlobalMembers { get; }
</I>&gt;<i> &gt;&gt; &#65279;
</I>&gt;<i> &gt;&gt; IEnumerable&lt;Comment&gt; Comments { get; }
</I>&gt;<i> &gt;&gt; }
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; The .NET info would be in the derived ICompilationUnit, and would
</I>&gt;<i> be
</I>&gt;<i> &gt;&gt; returned by .NET parsers:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt; &#65279;
</I>&gt;<i> &gt;&gt; &#65279;&#65279;IDotNetCompilationUnit : ICompilationUnit
</I>&gt;<i> &gt;&gt; {
</I>&gt;<i> &gt;&gt; ICollection&lt;IUsing&gt; Usings { get; }
</I>&gt;<i> &gt;&gt; ICollection&lt;IAttribute&gt; Attributes { get; }
</I>&gt;<i> &gt;&gt; &#65279;ICollection&lt;IType&gt; Classes { get; } // foreach (IBaseType t in
</I>&gt;<i> &gt;&gt; Types) yield return (IType) t;
</I>&gt;<i> &gt;&gt; ICollection&lt;Coderegion&gt; CodeRegions { get; } //#regions
</I>&gt;<i> &gt;&gt; }
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Even better, this moves some generic logic out of the
</I>&gt;<i> SourceEditor2,
</I>&gt;<i> &gt;&gt; so that the compilationunit / parseddocument could control the fold
</I>&gt;<i> &gt;&gt; locations, i.e. GetFoldLocations () would generate regions by
</I>&gt;<i> &gt;&gt; iterating over the members, classes, comments, C #regions, etc.
</I>&gt;<i> 
</I>&gt;<i> This is one of the important points in my proposal, since IMO we have
</I>&gt;<i> been hardcoding too much .NET-specific functionality into
</I>&gt;<i> SourceEditor2 is a way that is not extensible/overridable.
</I>&gt;<i> 
</I>
Can you give some examples ? Take the quick class combo - it only makes
sense when you've classes/members and regions. It's not really designed
for non object oriented functional languages - I admit. But that's not
really troublesome I think. For these languages we should not display
the quick class combo.
I think that's the case for other .NET specific features the same case.
Your language don't have '.NET' attributes or Properties ? No problem,
leave these collections empty in the compilation unit.
MonoDevelop provides the superset (which is in fact very .NET specific,
because it's designed around .NET features). But .NET is a good
superset, because .NET was designed to match many languages.

&gt;<i> &gt;&gt; I could implement an AspNetDocument : IParsedDocument. The C/C++
</I>&gt;<i> &gt;&gt; parser could return a CCompilationUnit : ICompilationUnit
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt; Does this sound like a good plan? Should I implement it?
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Hm, I think that'll produce too many upcasts only for different levels
</I>&gt;<i> &gt; of information.
</I>&gt;<i> 
</I>&gt;<i> Why are the upcasts a problem? They are all designed/intended to be
</I>&gt;<i> used in different ways.
</I>&gt;<i> 
</I>
Not different ways, different levels of information. 
* It makes no sense to use object orientation this way, you're just
creating a complicated class hierarchy and in the end it's casted to
(&#65279;IDotNetCompilationUnit) where all informations can be accessed. Even
the source editor will do it this way. Your three interfaces could be
separated, they shouldn't need to inherit from each other.

* Having a 3-tier hierarchy like this one duplicates the entries
(&#65279;ICollection&lt;IBaseType&gt; Types { get; } and &#65279;ICollection&lt;IType&gt; Classes
{ get; }).

* &#65279;You're still mixing .NET and non .NET stuff
in &#65279;IDotNetCompilationUnit. And this is your main concern (Usings may be
in .NET languages like c++, but not attributes).

&gt;<i> I've looked at your changes in SVN, and I'm not totally happy; it
</I>&gt;<i> would have been nice to finish the discussion first. At least it's a
</I>&gt;<i> step in the right direction.
</I>&gt;<i> 
</I>
It's a proposal. I prefer to communicate over source code :).

&gt;<i> My concerns are:
</I>&gt;<i> * Still not generic enough -- .NET-centric: ConditionalRegion,
</I>&gt;<i> PreProcessorDefine, ICompilationUnit will not be needed for many
</I>&gt;<i> languages, and are not things that the text editor will use.
</I>
Yes that's true, for many 'languages' the CompilationUnit will be null.
PreProcessorDefine will only be used for defines ... that's true that
most langugages don't have something like this, but c, c++ share this
with c# as well as the conditional regions (that are the #if DEFINED ...
#else ... #endif) stuff. 

Think of the user side:
Somewhere deep in future highlighting code:

&#65279;
&#65279;IParsedDocument &#65279;&#65279;&#65279;doc = GetDoc ();
&#65279;
&#65279;&#65279;// highlight errors red

&#65279;&#65279;&#65279;INetCentricParsedDocument &#65279;&#65279;netDoc = &#65279;doc as &#65279;&#65279;INetCentricParsedDocument;
if (&#65279;&#65279;netDoc != null) {
  foreach(&#65279;ConditionalRegion r in &#65279;netDoc.&#65279;ConditionalRegion) {
    if (!&#65279;netDoc.IsDefined (r.Condition)) {
       // make gray
    }
  }
}

You would have just:

&#65279;&#65279;
&#65279;IParsedDocument &#65279;doc = GetDoc ();
&#65279;
&#65279;// highlight errors red

foreach(&#65279;ConditionalRegion r in &#65279;doc.&#65279;ConditionalRegion) {
  if (!doc.IsDefined (r.Condition)) {
    // make gray
  }
}

Your code is still .NET centric because it does the same thing but you just cast more.

&gt;<i> * Not designed around use cases -- for example, things like the quick
</I>&gt;<i> finder and document outline will still be tied to .NET. IMO the
</I>&gt;<i> ParseDocument should be &quot;decomposable&quot; into different interfaces for
</I>&gt;<i> different purposes, i.e. text editor's errors&amp;folding, quick
</I>&gt;<i> finder/outline showing structure, .NET completion DB information, etc.
</I>&gt;<i> Only a single upcast would be required for any one purpose.
</I>
See the example above, the code will still be .NET centric, but does the
upcast. If we've very domain specific information it'll make sense to
hide them, but pre processor stuff, regions, usings are shared accross
some languages. And I don't see that it hurts other languages, because
you just re-use the ParsedDocument that's available and fill in the
stuff that your language provides. From the user point of view I think
that's easier than to get comfortable with a class hierarchy. (But I may
be wrong - comments ?)

&gt;<i> * Still leaves ICompilationUnit-&gt;folds mapping code in the
</I>&gt;<i> SourceEditor2. I'd like the ParseDocument to be able to perform this
</I>&gt;<i> mapping so that it can be overridden.
</I>&gt;<i> 
</I>
That can be done, is a different aspect than the inheritance stuff.

Regards
Mike

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000030.html">[Monodevelop-devel] Rethinking the IDocumentMetaInformation
</A></li>
	<LI>Next message: <A HREF="000034.html">[Monodevelop-devel] Rethinking the IDocumentMetaInformation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31">[ date ]</a>
              <a href="thread.html#31">[ thread ]</a>
              <a href="subject.html#31">[ subject ]</a>
              <a href="author.html#31">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">More information about the Monodevelop-devel-list
mailing list</a><br>
</body></html>
