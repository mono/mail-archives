<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-devel] Rethinking the IDocumentMetaInformation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Rethinking%20the%20IDocumentMetaInformation&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000029.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-devel] Rethinking the IDocumentMetaInformation</H1>
    <B>Michael Hutchinson</B> 
    <A HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Rethinking%20the%20IDocumentMetaInformation&In-Reply-To="
       TITLE="[Monodevelop-devel] Rethinking the IDocumentMetaInformation">m.j.hutchinson at gmail.com
       </A><BR>
    <I>Wed Sep 10 00:24:27 EDT 2008</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000029.html">[Monodevelop-devel] Rethinking the IDocumentMetaInformation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28">[ date ]</a>
              <a href="thread.html#28">[ thread ]</a>
              <a href="subject.html#28">[ subject ]</a>
              <a href="author.html#28">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi all,

I'm confused about the purpose of the IDocumentMetaInformation. I
think it exists because I once complained that I had to implement a
LanguageBinding simply to add code folding and error underlining. My
exact complaint was that I had to use an ICompilationUnit to mark
folding region and errors, and that it contained a lot of
.NET-specific information which my parser didn't need to populate.
However, I did implement the language binding for ASP.NET and it works
fine, and adding a parser is easier in the C# 3 branch...

The IDocumentMetaInformation is confusing; it does not fix the
original problem at all. It's worse -- it requires a second parse and
isn't stored is a publicly shared location, so has to be reparsed by
e.g. the document outline provider, which requires the #region
locations. Also, the source editor only parses an
IDocumentMetaInformation when a CompilationUnit appears, so a
CompilationUnit still has to be generated by the parser in order for
the IDocumentMetaInformation to be used!

I have some suggestions for a solution, which will also solve a few of
the issue the C/C++ addin had when implementing a parser
scheduler/notofication system. It will hopefully make it easier to add
other parses in the future.

I suggest we have the IParser instead return an IParsedDocument, which
would be very generic, with the basic info used by the text editor:

IParsedDocument
{
  string FileName;
  DateTime ParseTime { get; }
  IEnumerable&lt;Fold&gt; GetFoldLocations ();   // expected to iterate over
types, comments etc and generate folds
  ICollection&lt;Error&gt; Errors { get; } // also warnings
  bool HasErrors { get; }
}

There would then be an ICompilationUnit derived interface, with
generic info for things like the quick finder and document outline.

ICompilationUnit : IParsedDocument
{
  ICollection&lt;IDisplayType&gt; Types { get; }
  ICollection&lt;IDisplayMember&gt; GlobalMembers { get; }
  IEnumerable&lt;Comment&gt; Comments { get; }
}

The .NET info would be in the derived ICompilationUnit, and would be
returned by .NET parsers:

IDotNetCompilationUnit : ICompilationUnit
{
  ICollection&lt;IUsing&gt; Usings { get; }
  ICollection&lt;IAttribute&gt; Attributes { get; }
  ICollection&lt;IType&gt; Classes { get; }   // foreach (IBaseType t in
Types) yield return (IType) t;
  ICollection&lt;Coderegion&gt; CodeRegions { get; }   //#regions
}

I could implement an AspNetDocument : IParsedDocument. The C/C++
parser could return a CCompilationUnit : ICompilationUnit.

Even better, this moves some generic logic out of the SourceEditor2,
so that the compilationunit / parseddocument could control the fold
locations, i.e. GetFoldLocations () would generate regions by
iterating over the members, classes, comments, C #regions, etc. Other
such things should be implemented in a similar manner rather than
being in SourceEditor2, so that it's easier to implement other
editors. This is also, perhaps, a step being able to store and query
C/C++ (ad other non-.NET languages) type information effectively in
the pidb system.

Does this sound like a good plan? Should I implement it? Any suggested
changes to the above interfaces, in order to work better with other
languages?

--
Michael Hutchinson
<A HREF="http://mjhutchinson.com">http://mjhutchinson.com</A>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000029.html">[Monodevelop-devel] Rethinking the IDocumentMetaInformation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28">[ date ]</a>
              <a href="thread.html#28">[ thread ]</a>
              <a href="subject.html#28">[ subject ]</a>
              <a href="author.html#28">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">More information about the Monodevelop-devel-list
mailing list</a><br>
</body></html>
