<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Monodevelop-devel] Rethinking the IDocumentMetaInformation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Rethinking%20the%20IDocumentMetaInformation&In-Reply-To=1221122718.4730.80.camel%40undercity">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000031.html">
   <LINK REL="Next"  HREF="000032.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Monodevelop-devel] Rethinking the IDocumentMetaInformation</H1>
    <B>Michael Hutchinson</B> 
    <A HREF="mailto:monodevelop-devel-list%40lists.ximian.com?Subject=%5BMonodevelop-devel%5D%20Rethinking%20the%20IDocumentMetaInformation&In-Reply-To=1221122718.4730.80.camel%40undercity"
       TITLE="[Monodevelop-devel] Rethinking the IDocumentMetaInformation">m.j.hutchinson at gmail.com
       </A><BR>
    <I>Thu Sep 25 22:56:38 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000031.html">[Monodevelop-devel] Rethinking the IDocumentMetaInformation
</A></li>
        <LI>Next message: <A HREF="000032.html">[Monodevelop-devel] Potential crash when using	MonoDevelop.Components.DockToolbars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34">[ date ]</a>
              <a href="thread.html#34">[ thread ]</a>
              <a href="subject.html#34">[ subject ]</a>
              <a href="author.html#34">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, Sep 11, 2008 at 4:45 AM, Mike Kr&#252;ger &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">mkrueger at novell.com</A>&gt; wrote:
&gt;<i> Hi
</I>&gt;<i>
</I>&gt;&gt;<i> &gt; My long term vision for that was that a delta parser should take care of
</I>&gt;&gt;<i> &gt; teh document meta information. The meta information should consists only
</I>&gt;&gt;<i> &gt; on stuff that are regular expressions.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Couldn't an incremental/delta parser be used to /update/ the
</I>&gt;&gt;<i> CompilationUnit? At this point we don't even know if/how an
</I>&gt;&gt;<i> incremental parser could be implemented, so it seems premature to
</I>&gt;&gt;<i> design around it. This also seems rather mcs-specific.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> An delta parser for a regular grammar is much more easy to do than for
</I>&gt;<i> an context sensitive grammar (programming languages are that type). But
</I>&gt;<i> I think a delta parser isn't worth it, because we may have to re-parse
</I>&gt;<i> the whole file. But we could optimize it a bit more, it's not
</I>&gt;<i> neccessarry for every case to re-parse all and then the delta parser for
</I>&gt;<i> the other information'll make sense too.
</I>&gt;<i> (In fact every time where a body is changed a re-parse is unneccessary,
</I>&gt;<i> just the region information of the member should be updated)
</I>
That would be really nice to have.

&gt;<i> Can you give some examples ? Take the quick class combo - it only makes
</I>&gt;<i> sense when you've classes/members and regions. It's not really designed
</I>&gt;<i> for non object oriented functional languages - I admit. But that's not
</I>&gt;<i> really troublesome I think. For these languages we should not display
</I>&gt;<i> the quick class combo.
</I>
It could apply to C++, and other non-.NET (but OO) langauges....

&gt;<i> I think that's the case for other .NET specific features the same case.
</I>&gt;<i> Your language don't have '.NET' attributes or Properties ? No problem,
</I>&gt;<i> leave these collections empty in the compilation unit.
</I>&gt;<i> MonoDevelop provides the superset (which is in fact very .NET specific,
</I>&gt;<i> because it's designed around .NET features). But .NET is a good
</I>&gt;<i> superset, because .NET was designed to match many languages.
</I>
I guess that can be made to work, but it's less than ideal from the
point of view of the code completion DB. Anyway, I guess we can solve
that problem when we have a concrete example.


&gt;&gt;<i> &gt; Hm, I think that'll produce too many upcasts only for different levels
</I>&gt;&gt;<i> &gt; of information.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Why are the upcasts a problem? They are all designed/intended to be
</I>&gt;&gt;<i> used in different ways.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Not different ways, different levels of information.
</I>&gt;<i> * It makes no sense to use object orientation this way, you're just
</I>&gt;<i> creating a complicated class hierarchy and in the end it's casted to
</I>&gt;<i> (&#65279;IDotNetCompilationUnit) where all informations can be accessed. Even
</I>&gt;<i> the source editor will do it this way. Your three interfaces could be
</I>&gt;<i> separated, they shouldn't need to inherit from each other.
</I>&gt;<i>
</I>&gt;<i> * Having a 3-tier hierarchy like this one duplicates the entries
</I>&gt;<i> (&#65279;ICollection&lt;IBaseType&gt; Types { get; } and &#65279;ICollection&lt;IType&gt; Classes
</I>&gt;<i> { get; }).
</I>&gt;<i>
</I>&gt;<i> * &#65279;You're still mixing .NET and non .NET stuff
</I>&gt;<i> in &#65279;IDotNetCompilationUnit. And this is your main concern (Usings may be
</I>&gt;<i> in .NET languages like c++, but not attributes).
</I>&gt;<i>
</I>&gt;&gt;<i> I've looked at your changes in SVN, and I'm not totally happy; it
</I>&gt;&gt;<i> would have been nice to finish the discussion first. At least it's a
</I>&gt;&gt;<i> step in the right direction.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It's a proposal. I prefer to communicate over source code :).
</I>&gt;<i>
</I>&gt;&gt;<i> My concerns are:
</I>&gt;&gt;<i> * Still not generic enough -- .NET-centric: ConditionalRegion,
</I>&gt;&gt;<i> PreProcessorDefine, ICompilationUnit will not be needed for many
</I>&gt;&gt;<i> languages, and are not things that the text editor will use.
</I>&gt;<i>
</I>&gt;<i> Yes that's true, for many 'languages' the CompilationUnit will be null.
</I>&gt;<i> PreProcessorDefine will only be used for defines ... that's true that
</I>&gt;<i> most langugages don't have something like this, but c, c++ share this
</I>&gt;<i> with c# as well as the conditional regions (that are the #if DEFINED ...
</I>&gt;<i> #else ... #endif) stuff.
</I>&gt;<i>
</I>&gt;<i> Think of the user side:
</I>&gt;<i> Somewhere deep in future highlighting code:
</I>&gt;<i>
</I>&gt;<i> &#65279;
</I>&gt;<i> &#65279;IParsedDocument &#65279;&#65279;&#65279;doc = GetDoc ();
</I>&gt;<i> &#65279;
</I>&gt;<i> &#65279;&#65279;// highlight errors red
</I>&gt;<i>
</I>&gt;<i> &#65279;&#65279;&#65279;INetCentricParsedDocument &#65279;&#65279;netDoc = &#65279;doc as &#65279;&#65279;INetCentricParsedDocument;
</I>&gt;<i> if (&#65279;&#65279;netDoc != null) {
</I>&gt;<i>  foreach(&#65279;ConditionalRegion r in &#65279;netDoc.&#65279;ConditionalRegion) {
</I>&gt;<i>    if (!&#65279;netDoc.IsDefined (r.Condition)) {
</I>&gt;<i>       // make gray
</I>&gt;<i>    }
</I>&gt;<i>  }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> You would have just:
</I>&gt;<i>
</I>&gt;<i> &#65279;&#65279;
</I>&gt;<i> &#65279;IParsedDocument &#65279;doc = GetDoc ();
</I>&gt;<i> &#65279;
</I>&gt;<i> &#65279;// highlight errors red
</I>&gt;<i>
</I>&gt;<i> foreach(&#65279;ConditionalRegion r in &#65279;doc.&#65279;ConditionalRegion) {
</I>&gt;<i>  if (!doc.IsDefined (r.Condition)) {
</I>&gt;<i>    // make gray
</I>&gt;<i>  }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Your code is still .NET centric because it does the same thing but you just cast more.
</I>
Well, now that you pointed out how conditional regions can be used in
the text editor I'd move them to a non-.NET interface...

&gt;&gt;<i> * Not designed around use cases -- for example, things like the quick
</I>&gt;&gt;<i> finder and document outline will still be tied to .NET. IMO the
</I>&gt;&gt;<i> ParseDocument should be &quot;decomposable&quot; into different interfaces for
</I>&gt;&gt;<i> different purposes, i.e. text editor's errors&amp;folding, quick
</I>&gt;&gt;<i> finder/outline showing structure, .NET completion DB information, etc.
</I>&gt;&gt;<i> Only a single upcast would be required for any one purpose.
</I>&gt;<i>
</I>&gt;<i> See the example above, the code will still be .NET centric, but does the
</I>&gt;<i> upcast. If we've very domain specific information it'll make sense to
</I>&gt;<i> hide them, but pre processor stuff, regions, usings are shared accross
</I>&gt;<i> some languages. And I don't see that it hurts other languages, because
</I>&gt;<i> you just re-use the ParsedDocument that's available and fill in the
</I>&gt;<i> stuff that your language provides. From the user point of view I think
</I>&gt;<i> that's easier than to get comfortable with a class hierarchy. (But I may
</I>&gt;<i> be wrong - comments ?)
</I>&gt;<i>
</I>&gt;&gt;<i> * Still leaves ICompilationUnit-&gt;folds mapping code in the
</I>&gt;&gt;<i> SourceEditor2. I'd like the ParseDocument to be able to perform this
</I>&gt;&gt;<i> mapping so that it can be overridden.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> That can be done, is a different aspect than the inheritance stuff.
</I>
Hey, I noticed you did that already :-)

I've refactored it into interators/extension methods along with some
other changes (FoldingRegion -&gt; Fold / UserRegion). I'd also be
tempted to make it on-demand too so that folds are only calculated for
visible files. I'll take a look at moving the remaining C#-specific
stuff (#if etc) into the C# binding, and removing the need for a
CompilationUnit.

I'm not sure how to move the comments stuff out of the source editor,
since it depends on editor settings.

On the whole I'm just going to let it evolve, since forward planing is
hard to do without concrete examples.

-- 
Michael Hutchinson
<A HREF="http://mjhutchinson.com">http://mjhutchinson.com</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000031.html">[Monodevelop-devel] Rethinking the IDocumentMetaInformation
</A></li>
	<LI>Next message: <A HREF="000032.html">[Monodevelop-devel] Potential crash when using	MonoDevelop.Components.DockToolbars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34">[ date ]</a>
              <a href="thread.html#34">[ thread ]</a>
              <a href="subject.html#34">[ subject ]</a>
              <a href="author.html#34">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-devel-list">More information about the Monodevelop-devel-list
mailing list</a><br>
</body></html>
