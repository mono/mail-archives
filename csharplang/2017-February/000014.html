<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [csharplang] C# should provide better interop with unmanaged	function pointers.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:csharplang%40lists.dot.net?Subject=Re%3A%20%5Bcsharplang%5D%20C%23%20should%20provide%20better%20interop%20with%20unmanaged%0A%09function%20pointers.&In-Reply-To=%3CDM5PR03MB2666966DFD9F5244D3153171B34F0%40DM5PR03MB2666.namprd03.prod.outlook.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000013.html">
   <LINK REL="Next"  HREF="000095.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[csharplang] C# should provide better interop with unmanaged	function pointers.</H1>
    <B>Tanner Gooding</B> 
    <A HREF="mailto:csharplang%40lists.dot.net?Subject=Re%3A%20%5Bcsharplang%5D%20C%23%20should%20provide%20better%20interop%20with%20unmanaged%0A%09function%20pointers.&In-Reply-To=%3CDM5PR03MB2666966DFD9F5244D3153171B34F0%40DM5PR03MB2666.namprd03.prod.outlook.com%3E"
       TITLE="[csharplang] C# should provide better interop with unmanaged	function pointers.">tagoo at microsoft.com
       </A><BR>
    <I>Fri Feb  3 00:01:11 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="000013.html">[csharplang] For static extern methods, C# should support passing `null` to any `out` or `ref` parameters marked with `[Optional]`.
</A></li>
        <LI>Next message (by thread): <A HREF="000095.html">[csharplang] C# should provide better interop with	unmanaged	function pointers.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14">[ date ]</a>
              <a href="thread.html#14">[ thread ]</a>
              <a href="subject.html#14">[ subject ]</a>
              <a href="author.html#14">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Copied From: <A HREF="https://github.com/dotnet/roslyn/issues/13240">https://github.com/dotnet/roslyn/issues/13240</A>
Issue
C# has no mechanism for declaring unmanaged function pointers.
While there are a couple of mechanisms designed to work with and call unmanaged function pointers, these mechanisms may:

  *   Incur a higher level of overhead
  *   Require caching of the managed delegate
  *   Emit sub-optimal instructions for invoking the unmanaged function pointer
  *   Have issues when working with other unsafe/unmanaged code
Workaround
Declare the function pointer using IntPtr and then use the Marshal.GetDelegateForFunctionPointermethod to convert to a managed Delegate. Such as:
[UnmanagedFunctionPointer(CallingConvention.StdCall)]
public delegate void _D();

public struct S
{
    private IntPtr pD;

    public void D()
    {
        var funcptr = Marshal.GetDelegateForFunctionPointer&lt;_D&gt;(pD);
        funcptr();
    }
}

public static class C
{
    [DllImport(&quot;SomeBinary.dll&quot;)]
    public static extern void CreateS(out S pS);
}
-or-
Declare a managed delegate and rely on the marshalling behavior to convert as appropriate. Such As:
[UnmanagedFunctionPointer(CallingConvention.StdCall)]
public delegate void _D();

public struct S
{
    [MarshalAs(UnmanagedType.FunctionPtr)]
    public _D D;
}

public static class C
{
    [DllImport(&quot;SomeBinary.dll&quot;)]
    public static extern void CreateS(out S pS);
}
Proposal
The C# language should be extended to support function pointers in an unsafe context. Such as:
unsafe public struct S
{
    public void (*D)();
}
The compilation should fail if unsafe is missing.
Advantages
The compiler could take advantage of the fact this is an unsafe function pointer and emit the calliinstruction when invoking.
The compiler could provide some level of type safety when invoking the function pointer (ensuring the arguments passed in match the types required).
This would allow better interop with unmanaged languages and types that use function pointers.
This would allow a user to more readily implement VTBLs for unmanaged interop when required.

-Tanner Gooding
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.dot.net/pipermail/csharplang/attachments/20170203/5bf1806f/attachment-0001.html">http://lists.dot.net/pipermail/csharplang/attachments/20170203/5bf1806f/attachment-0001.html</A>&gt;
</PRE>






















































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="000013.html">[csharplang] For static extern methods, C# should support passing `null` to any `out` or `ref` parameters marked with `[Optional]`.
</A></li>
	<LI>Next message (by thread): <A HREF="000095.html">[csharplang] C# should provide better interop with	unmanaged	function pointers.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14">[ date ]</a>
              <a href="thread.html#14">[ thread ]</a>
              <a href="subject.html#14">[ subject ]</a>
              <a href="author.html#14">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.dot.net/mailman/listinfo/csharplang">More information about the csharplang
mailing list</a><br>
</body></html>
