<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [csharplang] [Proposal]: Support generics and generic type	parameters in aliases
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:csharplang%40lists.dot.net?Subject=Re%3A%20%5Bcsharplang%5D%20%5BProposal%5D%3A%20Support%20generics%20and%20generic%20type%0A%09parameters%20in%20aliases&In-Reply-To=%3CCAGu8fCp4V38kBNiU%2BXS5DCv0deehiDm9qa47g%2BhXbUacR1Hgew%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000045.html">
   <LINK REL="Next"  HREF="000018.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[csharplang] [Proposal]: Support generics and generic type	parameters in aliases</H1>
    <B>Justin Spindler</B> 
    <A HREF="mailto:csharplang%40lists.dot.net?Subject=Re%3A%20%5Bcsharplang%5D%20%5BProposal%5D%3A%20Support%20generics%20and%20generic%20type%0A%09parameters%20in%20aliases&In-Reply-To=%3CCAGu8fCp4V38kBNiU%2BXS5DCv0deehiDm9qa47g%2BhXbUacR1Hgew%40mail.gmail.com%3E"
       TITLE="[csharplang] [Proposal]: Support generics and generic type	parameters in aliases">justin.spindler at gmail.com
       </A><BR>
    <I>Fri Feb  3 00:46:29 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="000045.html">[csharplang] Proposal: Shorthand for simple expression lambdas
</A></li>
        <LI>Next message (by thread): <A HREF="000018.html">[csharplang] Proposal: Infer generic type based on target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17">[ date ]</a>
              <a href="thread.html#17">[ thread ]</a>
              <a href="subject.html#17">[ subject ]</a>
              <a href="author.html#17">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE><A HREF="https://github.com/dotnet/roslyn/issues/3993">https://github.com/dotnet/roslyn/issues/3993</A>

I propose the following changes to aliases to support generics:

using-alias-directive:
   using identifier = namespace-or-type-name ;
   using identifier type-parameter-list *opt* = class-type* ;

* There's probably a better item in the spec for this.

The purpose of this proposal is to allow aliases to be defined for unbound
or partially bound generic types where the alias is then treated as a
generic type that must be closed at the point at which it is used.

For example the following is legal in C# today:

using IntList = System.Collections.Generic.List&lt;int&gt;;

This expansion would permit the following:

// unboundusing MyList&lt;T&gt; = System.Collections.Generic.List&lt;T&gt;;//
partially boundusing StringDictionary&lt;TValue&gt; =
System.Collections.Generic.Dictionary&lt;String, TValue&gt;;

The name of the generic type parameter can be anything. The arguments are
matched by their position in the aliased type.

using FooList&lt;FOO&gt; = System.Collections.Generic.List&lt;FOO&gt;;using
ReorderedParameterDictionary&lt;TValue, TKey&gt; =
System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;;

When consuming the alias the rules would apply the same as when consuming a
generic type:

MyList&lt;int&gt; list = new MyList&lt;int&gt;();Debug.Assert(list is
System.Collections.Generic.List&lt;int&gt;);
StringDictionary&lt;bool&gt; dict = new
StringDictionary&lt;bool&gt;();Debug.Assert(dict is
System.Collections.Generic.Dictionary&lt;string, bool&gt;);
ReorderedParameterDictionary&lt;int, string&gt; dict2 = new
ReorderedParameterDictionary&lt;int, string&gt;();Debug.Assert(dict2 is
System.Collections.Generic.Dictionary&lt;string, int&gt;);

Arguments:

   1.

   This syntax cannot be assembled from existing syntax within the
   specification thus requiring additional work.

   This is true. Even though I provide a syntax above it is likely
   incorrect and the feature probably requires some new syntax. I believe that
   this is worth it for the functionality that the feature provides and I also
   feel that this syntax is more intuitive to the developer than the
   alternatives.
   2.

   Requiring the developer to name the generic type arguments is confusing.

   Naming generic type arguments is a very common task for anyone who has
   to write a generic type or generic method today. This should be somewhat
   second nature. This proposed syntax is very similar to the same syntax that
   would be required to define a new generic class with a generic subclass.
   3.

   Requiring the developer to name the generic type argument requires more
   keystrokes.

   This would require more keystrokes than simply using the existing
   unbound type syntax. However, the developer is not bound to using the same
   generic type parameter names as the type that is being aliased making the
   required number of additional keystrokes only one per generic type
   parameter. Given the common convention for generic type parameters is a
   single character, e.g. T, I don't think that this places an undue burden
   on the developer defining the alias nor any developer who must read and
   maintain that alias. It also represent a very small price to pay for the
   keystroke benefits that the feature would provide.

Complications:

   1. Generic aliasing could lead to recursion, e.g. using MyList&lt;T&gt; =
   System.Collections.Generic.List&lt;MyList&lt;T&gt;&gt;;.

The rules for aliases today already solves this problem by not permitting
an alias to refer to itself or another alias. If that weren't the case this
scenario would already be problematic: using MyList =
System.Collections.Generic.List&lt;MyList&gt;;
2. The alias can represent a partially open generic type which is
problematic if the developer attempts to obtain a Type instance from the
alias via typeof().

This is true. Given the StringDictionary&lt;T&gt; alias defined above it would be
a problem to attempt to obtain a Type reference using
typeof(StringDictionary&lt;&gt;). In my opinion this could be solved in one of
two possible ways:

   1.

   Make it illegal to use the unbound type definition of the alias. The
   expression typeof(StringDictionary&lt;&gt;) would be a compile-time error,
   however the expression typeof(StringDictionary&lt;bool&gt;) would be valid and
   equivalent to typeof(Dictionary&lt;String, bool&gt;). This might be confusing
   if aliases to an unbound type were supported, e.g. typeof(MyList&lt;&gt;).
   2.

   Support partially open Type references. This requires a little more code
   generation but is perfectly legal:

   Type type = typeof(StringDictionary&lt;bool&gt;);// equivalent to:Type
$temp1 = typeof(Dictionary&lt;,&gt;);Type[] $temp2 =
$temp1.GetGenericArguments();Type type =
$temp1.MakeGenericType(typeof(string), $temp2[1]);

   I am including this potential solution for the sake of argument. While
   being able to support syntax typeof(StringDictionary&lt;&gt;) would reduce the
   confusion for the developer I think that same developer would be more
   confused if the result is a partially open generic type.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.dot.net/pipermail/csharplang/attachments/20170202/f757ded9/attachment-0001.html">http://lists.dot.net/pipermail/csharplang/attachments/20170202/f757ded9/attachment-0001.html</A>&gt;
</PRE>

























































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="000045.html">[csharplang] Proposal: Shorthand for simple expression lambdas
</A></li>
	<LI>Next message (by thread): <A HREF="000018.html">[csharplang] Proposal: Infer generic type based on target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17">[ date ]</a>
              <a href="thread.html#17">[ thread ]</a>
              <a href="subject.html#17">[ subject ]</a>
              <a href="author.html#17">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.dot.net/mailman/listinfo/csharplang">More information about the csharplang
mailing list</a><br>
</body></html>
