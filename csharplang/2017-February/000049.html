<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [csharplang] Operators should be exposed for `System.IntPtr`	and `System.UIntPtr`
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:csharplang%40lists.dot.net?Subject=Re%3A%20%5Bcsharplang%5D%20Operators%20should%20be%20exposed%20for%0A%20%60System.IntPtr%60%09and%20%60System.UIntPtr%60&In-Reply-To=%3CMWHPR03MB26210C49F606FC1397C39C02954F0%40MWHPR03MB2621.namprd03.prod.outlook.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000048.html">
   <LINK REL="Next"  HREF="000050.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[csharplang] Operators should be exposed for `System.IntPtr`	and `System.UIntPtr`</H1>
    <B>Mads Torgersen</B> 
    <A HREF="mailto:csharplang%40lists.dot.net?Subject=Re%3A%20%5Bcsharplang%5D%20Operators%20should%20be%20exposed%20for%0A%20%60System.IntPtr%60%09and%20%60System.UIntPtr%60&In-Reply-To=%3CMWHPR03MB26210C49F606FC1397C39C02954F0%40MWHPR03MB2621.namprd03.prod.outlook.com%3E"
       TITLE="[csharplang] Operators should be exposed for `System.IntPtr`	and `System.UIntPtr`">Mads.Torgersen at microsoft.com
       </A><BR>
    <I>Fri Feb  3 16:06:21 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="000048.html">[csharplang] Operators should be exposed for	`System.IntPtr`	and `System.UIntPtr`
</A></li>
        <LI>Next message (by thread): <A HREF="000050.html">[csharplang] Operators should be exposed for `System.IntPtr`	and `System.UIntPtr`
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49">[ date ]</a>
              <a href="thread.html#49">[ thread ]</a>
              <a href="subject.html#49">[ subject ]</a>
              <a href="author.html#49">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I don't think Cyrus position is extreme, but maybe it is not getting across. As I understand it:


*       The operators for IntPtr ship as part of the library

*       They are implemented directly in IL with a one-instruction body

*       Per today's functionality, the compiler translates application of the operator to a static method call

*       Per today's functionality (presumably), the JIT inlines the operator

So there's no compiler and no runtime work, just library work.

In general, if you can do something in a library, that's less invasive than doing it in the compiler. As Miguel pointed out, though, it also comes with drawbacks. But it is not ludicrous, and even if it was, I'd encourage a choice of words that's more conducive to creative discourse.

Personally I wouldn't mind this being implemented in the compiler. There's a difference between &quot;This isn't right for the language&quot;, and &quot;this isn't worth spending effort on, compared to other things&quot;. I agree that this is not a feature that is likely to be prioritized by Microsoft's compiler team.

However, it is also not a feature that in any way adds to the complexity of the language. In fact, the language spec today pretty much pretends that IntPtr doesn't exist, and the compiler's special treatment of it is sort of seen as an implementation-specific extension.

In that light, I'd be fine with this as an up-for-grabs feature that could be implemented by the community.

From: Justin Spindler [mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>]
Sent: Friday, February 3, 2017 7:49 AM
To: Mads Torgersen &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">Mads.Torgersen at microsoft.com</A>&gt;; Cyrus Najmabadi &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&gt;
Cc: <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>
Subject: RE: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

I think that it's a perfectly valid response.

To clarify, I'm not arguing for or against whether the feature is worth effort on the part of the compiler team.  That is up to the compiler team to consider.

My response is specifically targeted towards the notion that the CLR, which has always supported arithmetic operations on the native int primitive, should have to do extra work to support the C#-convention of overloaded operators simply to allow for the C# language to support said operations without the C# team having to do any work of their own.  The argument that having the C# compiler support native int arithmetically sets a precedent doesn't hold as the C# compiler already set that precedent by correctly supporting arithmetic with the other numeric types.

I think that Cyrus' position here is quite extreme and quite unproductive for the conversation, especially since it serves only to shut down discussion of the feature in question by redirection.

From: Mads Torgersen [mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">Mads.Torgersen at microsoft.com</A>]
Sent: Friday, February 3, 2017 10:33 AM
To: Justin Spindler &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&gt;&gt;; Cyrus Najmabadi &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&gt;&gt;
Cc: <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
Subject: RE: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

How about we keep it civil.

Sent from my Windows 10 phone

From: Justin Spindler&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&gt;
Sent: Friday, February 3, 2017 1:19 AM
To: Cyrus Najmabadi&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&gt;
Cc: <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
Subject: Re: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

That's a ludicrous position.  The CLR only permits the arithmetic opcodes to be used directly against an incredibly small list of potential operands, int32, int64, native int, &amp; and float.  There is no precedent to be set other than that compiler omissions should be resolved by compiler changes.

On Fri, Feb 3, 2017 at 3:17 AM, Cyrus Najmabadi &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&gt;&gt; wrote:
&gt;<i> or a new library that is being shipped.
</I>
Sure.  I'd much rather ship a new library versus rev the language just to make working with IntPtrs nicer.  We're talking about a feature for an absolutely tiny subset of our users.  I think we should be thinking about features that bring about large value to much larger groups.

In other words: I don't doubt the value of the feature to you (and a small number of others).  What I question is why we'd work on this instead of a larger feature that can benefit more situations.  For example, when we built Linq we didn't just create the 'Linq' feature.  We did an aggregate of many different features, including:


  1.  Anonymous types.
  2.  Lambdas
  3.  Inferred types
  4.  Extension methods
  5.  Expression trees

All of these combine to make Linq, as a whole, really good.  But each of them also provides lots of value in isolation, making them worthwhile contributions to the language.  We're seeing similar broad benefits with things like pattern matching, deconstruction, and tuples in C#7.

I would much rather take a broader view here and ask what *larger* value we can be delivering at the language level that also ends up solving this niche case for you and others who care about it.  That way we're solving other problems that people have at the same time.

&gt;<i> It may require specific handling in the runtime to ensure it is optimized in the best possible manner (treated as an intrinsic rather than a normal method inline).
</I>
Ok.  So do that :).  I don't want us to just throw things into the language because we're worried about getting other groups to do work.  The C# language is not the 'catch all' place to do things just because :)

At the very least, I'd want to know what the state of the CLR is today.  If you create an assembly with IL that exports a static function that just has this single op-code in it, what does the actual CLR do with it?  Can it inline it?  If it can't, is the perf hit here actually something that affects the scenarios that we care about here?  If so, how much of a hit do we get between using the intrinsic directly, vs calling the intrinsic through a static method?

--

I'm sympathetic to the request.  It's always annoying when something impacts you and you wish it could just go away with a little change somewhere.  I'm not opposed to a solution coming for your problem. I'd just rather us provide a more general solution that can be more widely applicable.  Think of it as an efficiency problem.  We're going to have to spent some amount of cycles on anything here.  If those cycles can produce something more valuable, then that's a better utilization of our resources :)

         -- Cyrus

From: Tanner Gooding
Sent: Thursday, February 2, 2017 11:43 PM

To: Cyrus Najmabadi &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&gt;&gt;; Justin Spindler &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&gt;&gt;
Cc: <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
Subject: RE: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

It requires users to take a dependency on a new version of the framework/runtime or a new library that is being shipped.

It requires porting the changes from CoreCLR/CoreFX back into the desktop framework.

It may require specific handling in the runtime to ensure it is optimized in the best possible manner (treated as an intrinsic rather than a normal method inline).

-Tanner

From: Cyrus Najmabadi
Sent: Thursday, February 2, 2017 10:30 PM
To: Tanner Gooding &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">tagoo at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">tagoo at microsoft.com</A>&gt;&gt;; Justin Spindler &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&gt;&gt;
Cc: <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
Subject: RE: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

I'm still not exactly sure why a library that does what you want would not be sufficient in these cases.  Such a thing can be provided already today, without needing to take language design cycles away from other features that would be much more broadly valuable.

I'm not stating that this couldn't be done in the C# language.  I'm stating that spending effort on it is suboptimal and would certainly take away from other features that would provide a much larger benefit to a much larger set of developers out there.

&gt;<i> This is very suboptimal and involves emitting a method call, which may or may not be optimized.
</I>
If the runtime isn't optimizing away a single static function that is implemented as a single opcode on the two arguments, then that sounds like an issue to take up with the runtime :).

           -- Cyrus

From: Tanner Gooding
Sent: Thursday, February 2, 2017 9:52 PM
To: Cyrus Najmabadi &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&gt;&gt;; Justin Spindler &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&gt;&gt;
Cc: <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
Subject: RE: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

It's not that the runtime has a special opcode, it is that the runtime declares a set of primitive types, which C# follows for everything except `System.IntPtr` and `System.UIntPtr`.

Each of the primitive types defines a set of operators that are applicable to it. These all have intrinsic support in the compiler to directly emit the appropriate IL instructions, except for `System.IntPtr` and `System.UIntPtr`.

These types, regardless of how often they are mentioned in the C# spec, are used quite frequently: in Roslyn, in CoreFX, in CoreCLR, in 3rd party libraries, in Interop Code, etc...

Anytime the user needs to perform one of the primitive operations around one of these types (operations that are defined by the runtime) they currently need to either:

  *   Write unsafe code (generally involves calling IntPtr.ToPointer(), performing straight pointer arithmetic and then casting back) -or-
  *   To avoid writing unsafe code, they need to cast to an integer the same size as IntPtr (so Int64 on x64 and Int32 on x86), perform the arithmetic and then cast back

This is very suboptimal and involves emitting a method call, which may or may not be optimized.

However, if the compiler has built in support for the operators then it gets emitted as a single IL instruction (rather than a call) for each operation (same as with every other primitive type) and it requires no downstream work by the runtime or framework for the benefit.

-Tanner

From: Cyrus Najmabadi
Sent: Thursday, February 2, 2017 8:19 PM
To: Justin Spindler &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&gt;&gt;
Cc: Tanner Gooding &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">tagoo at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">tagoo at microsoft.com</A>&gt;&gt;; <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
Subject: RE: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

Yes.   That the runtime has this special opcode seems to about the runtime, and completely unrelated to the language.

It seems like this could also be provided by someone with their own dll with an extension method exposed that gives you this.  You'd have to write the dll with some other language (or straight IL).  This could then be packaged though any of our library distribution mechanisms.

--

Or, in other words, I'm seeing *extremely* low value in actually putting this in the language.  All that would be buying you would be usage of operator syntax.  But that seems like a very minor boost.
          -- Cyrus

From: Justin Spindler [mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>]
Sent: Thursday, February 2, 2017 6:48 PM
To: Cyrus Najmabadi &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&gt;&gt;
Cc: Tanner Gooding &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">tagoo at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">tagoo at microsoft.com</A>&gt;&gt;; <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
Subject: Re: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

So you're recommending that the CLR be modified and the JIT be forced to do more work so that the compiler doesn't have to support and emit a single IL opcode which the CLR has supported since 1.0?

On Thu, Feb 2, 2017 at 9:44 PM, Cyrus Najmabadi &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&gt;&gt; wrote:
Why can't the implementation of those operators just be implemented in terms of those opcodes.  Certainly the JIT/runtime would then inline all of that effectively?

          -- Cyrus

From: Justin Spindler [mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">justin.spindler at gmail.com</A>&gt;]
Sent: Thursday, February 2, 2017 6:22 PM
To: Cyrus Najmabadi &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">cyrusn at microsoft.com</A>&gt;&gt;
Cc: Tanner Gooding &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">tagoo at microsoft.com</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">tagoo at microsoft.com</A>&gt;&gt;; <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
Subject: Re: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

Primitive arithmetic operations are a concern of the compiler, which needs to emit the appropriate opcodes to perform the operation.  C#-style overloaded operators aren't declared on these types.  There is no Int32.op_Addition, etc.

On Thu, Feb 2, 2017 at 9:14 PM, Cyrus Najmabadi via csharplang &lt;<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;&gt; wrote:
Why not just add the actual operators to the System.IntPtr and System.UIntPtr structs?  It's unclear to me why we'd need anything specific in C# for these types.

           -- Cyrus

From: csharplang [mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang-bounces at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang-bounces at lists.dot.net</A>&gt;] On Behalf Of Tanner Gooding via csharplang
Sent: Thursday, February 2, 2017 3:58 PM
To: <A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
Subject: [csharplang] Operators should be exposed for `System.IntPtr` and `System.UIntPtr`

Copied from: <A HREF="https://github.com/dotnet/roslyn/issues/12836&lt;https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fdotnet%2Froslyn%2Fissues%2F12836&amp;data=02%7C01%7Ccyrusn%40microsoft.com%7C6d6a112dd88541693c2208d44bdb7819%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636216853371146110&amp;sdata=IGZbU13gY11ew%2BPWfeVawC4tW2NGhqa9ScSR7P4vh98%3D&amp;reserved=0">https://github.com/dotnet/roslyn/issues/12836&lt;https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fdotnet%2Froslyn%2Fissues%2F12836&amp;data=02%7C01%7Ccyrusn%40microsoft.com%7C6d6a112dd88541693c2208d44bdb7819%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636216853371146110&amp;sdata=IGZbU13gY11ew%2BPWfeVawC4tW2NGhqa9ScSR7P4vh98%3D&amp;reserved=0</A>&gt;
Issue:
The CLR supports a set of operators for the System.IntPtr and System.UIntPtr types (native int). These operators can be seen in III.1.5 of the Command Language Infrastructure specification. However, these operators are not supported by the C#.
Workaround:
Either directly emit IL or write non-optimal code that does not directly translate to the appropriate IL instructions.
Request:
Language support should be provided for the full set of operators supported by System.IntPtr and System.UIntPtr. These operators are: Add, Divide, Multiply, Remainder, Subtract, Negate, Equals, Compare, And, Not, Or, XOr, ShiftLeft, ShiftRight.
Other Thoughts:
C# seems to treat both IntPtr and UIntPtr as a type only used for interop and for representing pointers in a 'safe' manner, when it is really just:
an integer whose size is platform-specific.
It should be possible for a user to treat the IntPtr and UIntPtr types as an equivalent to the native size_t type. However, in order to do that, one must may have to deal with one or more of the following:

  *   Perform multiple levels of casting
  *   Use integers whose size is larger than their platform's native size
  *   Have branching to use integers that are platform-specific
  *   Work with unsafe code and do pointer arithmetic

-Tanner Gooding

_______________________________________________
csharplang mailing list
<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/csharplang">csharplang at lists.dot.net</A>&gt;
<A HREF="http://lists.dot.net/mailman/listinfo/csharplang&lt;https://na01.safelinks.protection.outlook.com/?url=http%3A%2F%2Flists.dot.net%2Fmailman%2Flistinfo%2Fcsharplang&amp;data=02%7C01%7Ccyrusn%40microsoft.com%7C6d6a112dd88541693c2208d44bdb7819%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636216853371146110&amp;sdata=Rbn5dxTPxjfQNXPs8UFBR69jS8xdsUM751bLptURhvI%3D&amp;reserved=0">http://lists.dot.net/mailman/listinfo/csharplang&lt;https://na01.safelinks.protection.outlook.com/?url=http%3A%2F%2Flists.dot.net%2Fmailman%2Flistinfo%2Fcsharplang&amp;data=02%7C01%7Ccyrusn%40microsoft.com%7C6d6a112dd88541693c2208d44bdb7819%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636216853371146110&amp;sdata=Rbn5dxTPxjfQNXPs8UFBR69jS8xdsUM751bLptURhvI%3D&amp;reserved=0</A>&gt;



-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.dot.net/pipermail/csharplang/attachments/20170203/7265269d/attachment-0001.html">http://lists.dot.net/pipermail/csharplang/attachments/20170203/7265269d/attachment-0001.html</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="000048.html">[csharplang] Operators should be exposed for	`System.IntPtr`	and `System.UIntPtr`
</A></li>
	<LI>Next message (by thread): <A HREF="000050.html">[csharplang] Operators should be exposed for `System.IntPtr`	and `System.UIntPtr`
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49">[ date ]</a>
              <a href="thread.html#49">[ thread ]</a>
              <a href="subject.html#49">[ subject ]</a>
              <a href="author.html#49">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.dot.net/mailman/listinfo/csharplang">More information about the csharplang
mailing list</a><br>
</body></html>
