<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [csharplang] [FUN] Support DestructableAttribution for	deconstructors
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:csharplang%40lists.dot.net?Subject=Re%3A%20%5Bcsharplang%5D%20%5BFUN%5D%20Support%20DestructableAttribution%20for%0A%09deconstructors&In-Reply-To=%3CCAOZNEpVO3BiR-saC1n8iE4chfqfy9%2BsxaBya0c8N%2BRUeQL9gPA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000093.html">
   <LINK REL="Next"  HREF="000078.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[csharplang] [FUN] Support DestructableAttribution for	deconstructors</H1>
    <B>Steve Fan</B> 
    <A HREF="mailto:csharplang%40lists.dot.net?Subject=Re%3A%20%5Bcsharplang%5D%20%5BFUN%5D%20Support%20DestructableAttribution%20for%0A%09deconstructors&In-Reply-To=%3CCAOZNEpVO3BiR-saC1n8iE4chfqfy9%2BsxaBya0c8N%2BRUeQL9gPA%40mail.gmail.com%3E"
       TITLE="[csharplang] [FUN] Support DestructableAttribution for	deconstructors">cia48621793 at gmail.com
       </A><BR>
    <I>Sat Feb  4 09:33:01 UTC 2017</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="000093.html">[csharplang] Specs in the csharplang repo
</A></li>
        <LI>Next message (by thread): <A HREF="000078.html">[csharplang] Ref/out parameters in operators
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#87">[ date ]</a>
              <a href="thread.html#87">[ thread ]</a>
              <a href="subject.html#87">[ subject ]</a>
              <a href="author.html#87">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>**NOTICE: THIS IS A TROLL PROPOSAL, AND THEREFORE THIS PROPOSAL IS
MEANINGLESS. DON'T BE SERIOUS ABOUT IT.**

Just because I cannot accept the `Deconstruction` going out of nowhere, I
therefore propose the `DestructableAttribution`

```
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
class DestructableAttribute : Attribute {} // Yep, simple as that
```

Before adding the `Destructable`
```
class Point {
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) { X = x; Y = y; }
    public void Deconstruct(out int x, out int y) { x = X; y = Y; } //
What's it gonna do? Can I call this method?
}
var (x, y) = new Point(1, 2);
```
After adding the `Destructable`
```
[Destructable]
class Point {
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) { X = x; Y = y; }
    public Deconstruct(out int x, out int y) { x = X; y = Y; } // notice
how the 'void is removed
    // now the 'Deconstruct' is a reserved word
}
var (x, y) = new Point(1, 2);
```
If a `Deconstruct` was added without attaching `Destructable` attribute, a
compiler error will occur:
```
class Point {
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) { X = x; Y = y; }
    public Deconstruct(out int x, out int y) { x = X; y = Y; }
}
var (x, y) = new Point(1, 2);
```
```
error CSXXXX: Class 'Foo' is not allowed to deconstruct
```

Syntax:
```
&lt;deconstruct&gt; ::= &quot;Deconstruct&quot;
&lt;deconstruct-decl&gt; ::= &lt;method-accessor&gt; &lt;deconstruct&gt; &lt;parameter&gt;
&lt;method-stmt&gt;
&lt;class-decl&gt; ::= ...
               | &lt;deconstruct-decl&gt;*
```
I'm sorry. I don't know much about computer science/EBNF/blah blah blah,
But I'm still a student tho, so don't make it serious man, I was trying to
act funny. (and stupid as well)

Why did I 'propose' this? **Have you considered that older libraries, older
classes may contain the `Deconstruct` method as well? Should they be
`Deconstructable` at all?** Even though the chance with the exact 'current'
syntax is extremely rare, I don't think we should neglect this chance. By
adding a `Destructable` attribute this kind of situation can easily, be
avoided.

In addition it can make the code more intuitive by hinting the developer
and the IDE/compile which class supports tuple destruction, instead of
looking around for the `Deconstruct` method, which can be anywhere inside
the class, it can be time-costing finding it.

Since the C# 7.0 is not forming its shapes yet, and we can still change the
mechanics of 'Valued tuples' before it was cooked, before the VS2017 final
came out.

#longlivethecsharp
#csharpsuperiority
#fuckjava
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.dot.net/pipermail/csharplang/attachments/20170204/041ae878/attachment-0001.html">http://lists.dot.net/pipermail/csharplang/attachments/20170204/041ae878/attachment-0001.html</A>&gt;
</PRE>



















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="000093.html">[csharplang] Specs in the csharplang repo
</A></li>
	<LI>Next message (by thread): <A HREF="000078.html">[csharplang] Ref/out parameters in operators
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#87">[ date ]</a>
              <a href="thread.html#87">[ thread ]</a>
              <a href="subject.html#87">[ subject ]</a>
              <a href="author.html#87">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.dot.net/mailman/listinfo/csharplang">More information about the csharplang
mailing list</a><br>
</body></html>
