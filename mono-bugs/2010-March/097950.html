<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 522748] InvalidCastException in DynamicInvoke call
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20522748%5D%20InvalidCastException%20in%20DynamicInvoke%20call&In-Reply-To=bug-522748-28286%40http.bugzilla.novell.com/">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="097975.html">
   <LINK REL="Next"  HREF="097951.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 522748] InvalidCastException in DynamicInvoke call</H1>
    <B>bugzilla_noreply at novell.com</B> 
    <A HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20522748%5D%20InvalidCastException%20in%20DynamicInvoke%20call&In-Reply-To=bug-522748-28286%40http.bugzilla.novell.com/"
       TITLE="[Mono-bugs] [Bug 522748] InvalidCastException in DynamicInvoke call">bugzilla_noreply at novell.com
       </A><BR>
    <I>Tue Mar  2 13:36:18 EST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="097975.html">[Mono-bugs] [Bug 584736] Decimal to double conversion very slow
</A></li>
        <LI>Next message: <A HREF="097951.html">[Mono-bugs] [Bug 575598] Softdebugging this program crashes the	mono runtime
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#97950">[ date ]</a>
              <a href="thread.html#97950">[ thread ]</a>
              <a href="subject.html#97950">[ subject ]</a>
              <a href="author.html#97950">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE><A HREF="http://bugzilla.novell.com/show_bug.cgi?id=522748">http://bugzilla.novell.com/show_bug.cgi?id=522748</A>

<A HREF="http://bugzilla.novell.com/show_bug.cgi?id=522748#c2">http://bugzilla.novell.com/show_bug.cgi?id=522748#c2</A>


andrus moor &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">kobruleht2 at hot.ee</A>&gt; changed:

           What    |Removed                     |Added
----------------------------------------------------------------------------
                 CC|                            |<A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">kobruleht2 at hot.ee</A>

--- Comment #2 from andrus moor &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">kobruleht2 at hot.ee</A>&gt; 2010-03-02 18:36:16 UTC ---
Below is testcase which does not have dblinq dependency. Exception occurs in
MONO 2.6.1/Windows and in 2.4/Linux
using VCS 2008 created exe file. In .NET it runs OK.

Andrus.

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Linq.Mapping;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Npgsql;

class Program
{
    public const string connstr = &quot;SERVER=localhost;USER=postgres;PASSWORD=a&quot;;

    static void Main()
    {

        Kontekst kontekst;
        kontekst = MyDataContext.ExecQuery&lt;Kontekst&gt;(@&quot;
CREATE temp TABLE kontekst(  akuupaev date ) on commit drop;
insert into kontekst ( akuupaev ) values ( null );
SELECT * FROM kontekst&quot;
).SingleOrDefault();
        Console.WriteLine(&quot;Kontekst &quot; + (kontekst == null).ToString());
        Console.ReadLine();
    }
}

class ArrayComparer&lt;T&gt; : IEqualityComparer&lt;T[]&gt;
{
    private readonly IEqualityComparer&lt;T&gt; comparer;
    public ArrayComparer() : this(null) { }
    public ArrayComparer(IEqualityComparer&lt;T&gt; comparer)
    {
        this.comparer = comparer ?? EqualityComparer&lt;T&gt;.Default;
    }

    public int GetHashCode(T[] values)
    {
        if (values == null) return 0;
        int hashCode = 1;
        for (int i = 0; i &lt; values.Length; i++)
        {
            hashCode = (hashCode * 13) + comparer.GetHashCode(values[i]);
        }
        return hashCode;
    }
    public bool Equals(T[] lhs, T[] rhs)
    {
        if (ReferenceEquals(lhs, rhs)) return true;
        if (lhs == null || rhs == null || lhs.Length != rhs.Length) return
false;
        for (int i = 0; i &lt; lhs.Length; i++)
        {
            if (!comparer.Equals(lhs[i], rhs[i])) return false;
        }
        return true;
    }
}

internal class BindingInfo
{
    public bool CanBeNull { get; private set; }
    public MemberInfo StorageMember { get; private set; }
    public MemberInfo BindingMember { get; private set; }
    public BindingInfo(bool canBeNull, MemberInfo bindingMember, MemberInfo
storageMember)
    {
        CanBeNull = canBeNull;
        BindingMember = bindingMember;
        StorageMember = storageMember;
    }

    public Type StorageType
    {
        get
        {
            switch (StorageMember.MemberType)
            {
                case MemberTypes.Field:
                    return ((FieldInfo)StorageMember).FieldType;
                case MemberTypes.Property:
                    return ((PropertyInfo)StorageMember).PropertyType;
                default:
                    throw new NotSupportedException(string.Format(&quot;Unexpected
member-type: {0}&quot;, StorageMember.Name));
            }
        }
    }
}

static class InitializerCache&lt;T&gt;
{
    static readonly Dictionary&lt;string[], Func&lt;IDataRecord, MyDataContext, T&gt;&gt;
convertReaders
        = new Dictionary&lt;string[], Func&lt;IDataRecord, MyDataContext, T&gt;&gt;(
            new
ArrayComparer&lt;string&gt;(StringComparer.InvariantCultureIgnoreCase)),
       vanillaReaders = new Dictionary&lt;string[], Func&lt;IDataRecord,
MyDataContext, T&gt;&gt;(
            new
ArrayComparer&lt;string&gt;(StringComparer.InvariantCultureIgnoreCase));

    static readonly SortedList&lt;string, BindingInfo&gt; dataMembers
        = new SortedList&lt;string,
BindingInfo&gt;(StringComparer.InvariantCultureIgnoreCase);

    static bool TryGetBinding(string columnName, out BindingInfo binding)
    {
        return dataMembers.TryGetValue(columnName, out binding);
    }

    const BindingFlags FLAGS = BindingFlags.Instance | BindingFlags.Public |
BindingFlags.NonPublic;
    const MemberTypes PROP_FIELD = MemberTypes.Property | MemberTypes.Field;

    static MemberInfo GetBindingMember(string name)
    {
        Type type = typeof(T);
        return FirstMember(type.GetMember(name, PROP_FIELD, FLAGS)) ??
                FirstMember(type.GetMember(name, PROP_FIELD, FLAGS |
BindingFlags.IgnoreCase));
    }

    static InitializerCache()
    {
        Type type = typeof(T);
        foreach (MemberInfo member in type.GetMembers(FLAGS))
        {
            if ((member.MemberType &amp; PROP_FIELD) == 0) continue; // only
applies to prop/fields
            ColumnAttribute col = Attribute.GetCustomAttribute(member,
typeof(ColumnAttribute)) as ColumnAttribute;
            if (col == null) continue; // not a column
            string name = col.Name;
            if (string.IsNullOrEmpty(name))
            { // default to self
                name = member.Name;
            }
            string storage = col.Storage;
            MemberInfo storageMember;
            if (string.IsNullOrEmpty(storage) || storage == name)
            { // default to self
                storageMember = member;
            }
            else
            {
                // locate prop/field: case-sensitive first, then insensitive
                storageMember = GetBindingMember(storage);
                if (storageMember == null)
                {
                    throw new InvalidOperationException(&quot;Storage member not
found: &quot; + storage);
                }
            }
            if (storageMember.MemberType == MemberTypes.Property &amp;&amp;
!((PropertyInfo)storageMember).CanWrite)
            { // write to a r/o prop?
                throw new InvalidOperationException(&quot;Cannot write to readonly
storage property: &quot; + storage);
            }
            // log it...
            dataMembers.Add(name, new BindingInfo(col.CanBeNull, member,
storageMember));
        }
    }

    static MemberInfo FirstMember(MemberInfo[] members)
    {
        return members != null &amp;&amp; members.Length &gt; 0 ? members[0] : null;
    }

    public static Func&lt;IDataRecord, MyDataContext, T&gt; GetInitializer(string[]
names, bool useConversion)
    {
        if (names == null) throw new ArgumentNullException();
        Func&lt;IDataRecord, MyDataContext, T&gt; initializer;
        Dictionary&lt;string[], Func&lt;IDataRecord, MyDataContext, T&gt;&gt; cache =
            useConversion ? convertReaders : vanillaReaders;
        lock (cache)
        {
            if (!cache.TryGetValue(names, out initializer))
            {
                initializer = CreateInitializer(names, useConversion);
                cache.Add((string[])names.Clone(), initializer);
            }
        }
        return initializer;
    }

    static Func&lt;IDataRecord, MyDataContext, T&gt; CreateInitializer(string[]
names, bool useConversion)
    {
        //Trace.WriteLine(&quot;Creating initializer for: &quot; + typeof(T).Name);
        if (names == null) throw new ArgumentNullException(&quot;names&quot;);

        ParameterExpression readerParam =
Expression.Parameter(typeof(IDataRecord), &quot;record&quot;),
            ctxParam = Expression.Parameter(typeof(MyDataContext), &quot;ctx&quot;);

        Type entityType = typeof(T),
            underlyingEntityType = Nullable.GetUnderlyingType(entityType) ??
entityType,
            readerType = typeof(IDataRecord);
        List&lt;MemberBinding&gt; bindings = new List&lt;MemberBinding&gt;();

        Type[] byOrdinal = { typeof(int) };
        MethodInfo defaultMethod = readerType.GetMethod(&quot;GetValue&quot;, byOrdinal),
            isNullMethod = readerType.GetMethod(&quot;IsDBNull&quot;, byOrdinal),
            convertMethod = typeof(MyDataContext).GetMethod(&quot;OnConvertValue&quot;,
BindingFlags.Instance | BindingFlags.NonPublic);

        NewExpression ctor = Expression.New(underlyingEntityType); // try this
first...
        for (int ordinal = 0; ordinal &lt; names.Length; ordinal++)
        {
            string name = names[ordinal];
            BindingInfo bindingInfo;
            if (!TryGetBinding(name, out bindingInfo))
            { // try implicit binding
                MemberInfo member = GetBindingMember(name);
                if (member == null) continue; // not bound
                bindingInfo = new BindingInfo(true, member, member);
            }
            Type valueType = bindingInfo.StorageType;
            Type underlyingType = Nullable.GetUnderlyingType(valueType) ??
valueType;

            // get the rhs of a binding
            MethodInfo method = readerType.GetMethod(&quot;Get&quot; +
underlyingType.Name, byOrdinal);
            Expression rhs;
            ConstantExpression ordinalExp = Expression.Constant(ordinal,
typeof(int));
            if (method != null &amp;&amp; method.ReturnType == underlyingType)
            {
                rhs = Expression.Call(readerParam, method, ordinalExp);
            }
            else
            {
                rhs = Expression.Convert(Expression.Call(readerParam,
defaultMethod, ordinalExp), underlyingType);
            }

            if (underlyingType != valueType)
            {   // Nullable&lt;T&gt;; convert underlying T to T?
                rhs = Expression.Convert(rhs, valueType);
            }

            if (bindingInfo.CanBeNull &amp;&amp; (underlyingType.IsClass ||
underlyingType != valueType))
            {
                // reference-type of Nullable&lt;T&gt;; check for null
                // (conditional ternary operator)
                rhs = Expression.Condition(
                    Expression.Call(readerParam, isNullMethod, ordinalExp),
                    Expression.Constant(null, valueType), rhs);
            }
            if (useConversion)
            {
                rhs = Expression.Convert(Expression.Call(ctxParam,
convertMethod, ordinalExp, readerParam,
                    Expression.Convert(rhs, typeof(object))), valueType);
            }
            bindings.Add(Expression.Bind(bindingInfo.StorageMember, rhs));
        }
        Expression body = Expression.MemberInit(ctor, bindings);
        if (entityType != underlyingEntityType)
        { // entity itself was T? - so convert
            body = Expression.Convert(body, entityType);
        }
        return Expression.Lambda&lt;Func&lt;IDataRecord, MyDataContext, T&gt;&gt;(body,
readerParam, ctxParam).Compile();
    }
}

public class ValueConversionEventArgs : EventArgs
{
    internal void Init(int ordinal, IDataRecord record, object value)
    {
        Ordinal = ordinal;
        Record = record;
        Value = value;
    }

    internal ValueConversionEventArgs() { }

    public ValueConversionEventArgs(int ordinal, IDataRecord record, object
value)
    {
        Init(ordinal, record, value);
    }

    public int Ordinal { get; private set; }
    public object Value { get; set; }
    public IDataRecord Record { get; private set; }
}

public class MyDataContext
{
    public static List&lt;TEntity&gt; ExecQuery&lt;TEntity&gt;(string command, params
object[] prm)
where TEntity : class, new()
    {
        IEnumerable&lt;TEntity&gt; res;
        var db = new MyDataContext();
        res = db.ExecuteQuery&lt;TEntity&gt;(command, prm);
        if (res == null)
            throw new ArgumentException(command);

        List&lt;TEntity&gt; res2;
        //try
        //{
        res2 = res.ToList();
        //}
        //catch (InvalidCastException ex)
        //{
        //    throw new ArgumentException(&quot;Cast error on query &quot; + command,
&quot;command&quot;, ex);
        //}
        return res2;
    }

    readonly ValueConversionEventArgs conversionArgs = new
ValueConversionEventArgs();
    public event EventHandler&lt;ValueConversionEventArgs&gt; ConvertValue;

    internal object OnConvertValue(int ordinal, IDataRecord record, object
value)
    {
        if (ConvertValue == null)
        {
            return value;
        }
        else
        {
            conversionArgs.Init(ordinal, record, value);
            ConvertValue(this, conversionArgs);
            return conversionArgs.Value;
        }
    }

    public IEnumerable&lt;T&gt; ExecuteQuery&lt;T&gt;(string command, params object[]
parameters)
    {

        if (parameters == null) throw new ArgumentNullException(&quot;parameters&quot;);

        using (IDbConnection conn = new NpgsqlConnection(Program.connstr))
        using (IDbCommand cmd = conn.CreateCommand())
        {
            string[] paramNames = new string[parameters.Length];

            for (int i = 0; i &lt; parameters.Length; i++)
            {
                paramNames[i] = &quot;@p&quot; + i.ToString();
                IDbDataParameter param = cmd.CreateParameter();
                param.ParameterName = paramNames[i];
                param.Value = parameters[i] ?? DBNull.Value;
                cmd.Parameters.Add(param);
            }
            cmd.CommandType = CommandType.Text;
            cmd.CommandText = string.Format(command, paramNames);
            conn.Open();
            using (IDataReader reader =
cmd.ExecuteReader(CommandBehavior.CloseConnection |
CommandBehavior.SingleResult))
            {
                if (reader.Read())
                {
                    string[] names = new string[reader.FieldCount];
                    for (int i = 0; i &lt; names.Length; i++)
                    {
                        names[i] = reader.GetName(i);
                    }
                    Func&lt;IDataRecord, MyDataContext, T&gt; objInit =
InitializerCache&lt;T&gt;.GetInitializer(names, ConvertValue != null);
                    do
                    { // walk the data 
                        yield return objInit(reader, this);
                    } while (reader.Read());
                }
                while (reader.NextResult()) { } // ensure any trailing errors
caught 
            }
        }
    }
}

[Table(Name = &quot;kontekst&quot;)]
public class Kontekst
{
    System.DateTime? akuupaev;
    [Column(Storage = &quot;akuupaev&quot;, Name = &quot;akuupaev&quot;, DbType = &quot;date&quot;,
Expression = null)]
    public System.DateTime? Akuupaev
    {
        get
        {
            return akuupaev;
        }
        set
        {
            if (value != akuupaev)
            {
                akuupaev = value;
            }
        }
    }
}

-- 
Configure bugmail: <A HREF="http://bugzilla.novell.com/userprefs.cgi?tab=email">http://bugzilla.novell.com/userprefs.cgi?tab=email</A>
------- You are receiving this mail because: -------
You are the QA contact for the bug.
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="097975.html">[Mono-bugs] [Bug 584736] Decimal to double conversion very slow
</A></li>
	<LI>Next message: <A HREF="097951.html">[Mono-bugs] [Bug 575598] Softdebugging this program crashes the	mono runtime
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#97950">[ date ]</a>
              <a href="thread.html#97950">[ thread ]</a>
              <a href="subject.html#97950">[ subject ]</a>
              <a href="author.html#97950">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-bugs">More information about the mono-bugs
mailing list</a><br>
</body></html>
