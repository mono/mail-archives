<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 349449] New: LocalEndPoint and RemoteEndPointer properties are null for socket connected in non-blocking mode
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20349449%5D%20New%3A%20LocalEndPoint%20and%20RemoteEndPointer%0A%20properties%20are%20null%20for%20socket%20connected%20in%20non-blocking%20mode&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="067046.html">
   <LINK REL="Next"  HREF="067048.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 349449] New: LocalEndPoint and RemoteEndPointer properties are null for socket connected in non-blocking mode</H1>
    <B>bugzilla_noreply at novell.com</B> 
    <A HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20349449%5D%20New%3A%20LocalEndPoint%20and%20RemoteEndPointer%0A%20properties%20are%20null%20for%20socket%20connected%20in%20non-blocking%20mode&In-Reply-To="
       TITLE="[Mono-bugs] [Bug 349449] New: LocalEndPoint and RemoteEndPointer properties are null for socket connected in non-blocking mode">bugzilla_noreply at novell.com
       </A><BR>
    <I>Tue Dec 18 02:20:11 EST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="067046.html">[Mono-bugs] [Bug 337401] Monodoc will list a property as &quot;Protected&quot; if one of its accessors is protected
</A></li>
        <LI>Next message: <A HREF="067048.html">[Mono-bugs] [Bug 349449] LocalEndPoint and RemoteEndPointer properties are null for socket connected in non-blocking mode
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#67047">[ date ]</a>
              <a href="thread.html#67047">[ thread ]</a>
              <a href="subject.html#67047">[ subject ]</a>
              <a href="author.html#67047">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE><A HREF="https://bugzilla.novell.com/show_bug.cgi?id=349449">https://bugzilla.novell.com/show_bug.cgi?id=349449</A>


           Summary: LocalEndPoint and RemoteEndPointer properties are null
                    for socket connected in non-blocking mode
           Product: Mono: Class Libraries
           Version: 1.2.6
          Platform: 64bit
        OS/Version: Ubuntu
            Status: NEW
          Severity: Normal
          Priority: P5 - None
         Component: System
        AssignedTo: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at ximian.com</A>
        ReportedBy: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">michi at zeroc.com</A>
         QAContact: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at ximian.com</A>
          Found By: Customer


Below is an example program that fails under Mono 1.2.6 but works with earlier
versions. The problem is that, for a socket that is connected non-blocking,
IPEndpoint.LocalEndPoint and IPEndPoint.RemoteEndpoint return null.

It can be argued that this change is actually a bug fix rather than a bug
because Windows does the same thing for sockets that are connected non-blocking
(even though that seems non-sensical).

So, prior to 1.2.6, my solution was to, for Windows, use P/Invoke into
wsock32.dll to call getsockname() and getpeername(). The same thing works for
Mono 1.2.6. However, the added difficulty is that the library name is
platform-dependent, which makes it difficult for us to ship code that will work
for differnet Linunx distributions.

I would very much appreciate any suggestions you might have as to how I can get
the local and remote endpoint from a socket that was connected non-blocking
without having to use P/Invoke. (I've attached a section of code that
illustrates my dilemma following the test case.)

The code below fails on Mono 1.2.6, but works on 1.2.5 and earlier version. To
test, run a server on 127.0.0.1 that accepts connections on port 12010.

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;

class Test
{
    public static void Main(string[] args)
    {
        Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
ProtocolType.Tcp);
        s.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, 1);
        s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive,
1);

        s.Blocking = false;

        IPEndPoint e = new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), 12010);
        try
        {
            s.Connect(e);
        }
        catch(SocketException ex)
        {
            if(ex.NativeErrorCode != 10035) // WSAEWOULDBLOCK
            {
                System.Console.Error.WriteLine(&quot;Non-blocking connect failed&quot;);
                Environment.Exit(1);
            }
        }

        List&lt;Socket&gt; rl = new List&lt;Socket&gt;();
        rl.Add(s);
        List&lt;Socket&gt; wl = new List&lt;Socket&gt;();
        wl.Add(s);
        List&lt;Socket&gt; el = new List&lt;Socket&gt;();
        el.Add(s);
        Socket.Select(rl, wl, el, 10000000);
        if(el.Count != 0)
        {
            System.Console.Error.WriteLine(&quot;Select error&quot;);
        }
        if((int)s.GetSocketOption(SocketOptionLevel.Socket,
SocketOptionName.Error) &gt; 0)
        {
            System.Console.Error.WriteLine(&quot;Connect failed&quot;);
            Environment.Exit(1);
        }

        IPEndPoint localEndpoint = (IPEndPoint)s.LocalEndPoint;
        if(localEndpoint == null)
        {
            System.Console.Error.WriteLine(&quot;local endpoint of connected socket
is null?!!!&quot;);
        }

        IPEndPoint remoteEndpoint = (IPEndPoint)s.RemoteEndPoint;
        if(remoteEndpoint == null)
        {
            System.Console.Error.WriteLine(&quot;remote endpoint of connected socket
is null?!!!&quot;);
        }
        if(localEndpoint == null || remoteEndpoint == null)
        {
            Environment.Exit(1);
        }

        Environment.Exit(0);
    }
}

Here is how I'm working around the problem at the moment, but I would really
like to have something that avoids having to use P/Invoke:

        [StructLayout(LayoutKind.Sequential)]
        private struct in_addr
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=4)]
            public byte[] sin_addr;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct sockaddr
        {
            public short sin_family;
            public ushort sin_port;
            public in_addr sin_addr;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=8)]
            public byte[] sin_zero;
        }

// The problem is the DllImport(&quot;libc-2.3.6.so&quot;) because that's
// platform-dependent.
// ...

#if __MonoCS__
        [DllImport(&quot;libc-2.3.6.so&quot;)]
#else
        [DllImport(&quot;wsock32.dll&quot;)]
#endif
        private static extern int getpeername(IntPtr s, ref sockaddr name, ref
int namelen);

// More definitions here like the previous one for getsockname(), inet_ntoa(),
and ntohs().
// ...

// The code below uses P/Invoke to call getpeername() to get the
// remote endpoint. As such, that's OK, but the problem
// is that the DllImport above is not portable.

        public static IPEndPoint
        getRemoteAddress(Socket socket)
        {
            //
            // .Net BUG: The LocalEndPoint and RemoteEndPoint properties
            // are null for a socket that was connected in non-blocking
            // mode. As of Mono 1.2.6, Mono behaves the same way.
            // The only way to make this work is to step down to
            // the native API and use platform invoke :-(
            //
            IPEndPoint remoteEndpoint = null;
            sockaddr addr = new sockaddr();
            int addrLen = 16;

            if(getpeername(socket.Handle, ref addr, ref addrLen) == 0)
            {
                string ip = Marshal.PtrToStringAnsi(inet_ntoa(addr.sin_addr));
                int port = ntohs(addr.sin_port);
                remoteEndpoint = new IPEndPoint(IPAddress.Parse(ip), port);
            }
            return remoteEndpoint;
        }


-- 
Configure bugmail: <A HREF="https://bugzilla.novell.com/userprefs.cgi?tab=email">https://bugzilla.novell.com/userprefs.cgi?tab=email</A>
------- You are receiving this mail because: -------
You are the QA contact for the bug.
You are the assignee for the bug.
</PRE>








































































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="067046.html">[Mono-bugs] [Bug 337401] Monodoc will list a property as &quot;Protected&quot; if one of its accessors is protected
</A></li>
	<LI>Next message: <A HREF="067048.html">[Mono-bugs] [Bug 349449] LocalEndPoint and RemoteEndPointer properties are null for socket connected in non-blocking mode
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#67047">[ date ]</a>
              <a href="thread.html#67047">[ thread ]</a>
              <a href="subject.html#67047">[ subject ]</a>
              <a href="author.html#67047">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-bugs">More information about the mono-bugs
mailing list</a><br>
</body></html>
