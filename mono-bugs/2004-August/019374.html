<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 62369][Wis] New - memory leak garbage problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:bugzilla-daemon%40bugzilla.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="019373.html">
   <LINK REL="Next"  HREF="019375.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 62369][Wis] New - memory leak garbage problem
   </H1>
    <B>bugzilla-daemon@bugzilla.ximian.com
    </B> 
    <A HREF="mailto:bugzilla-daemon%40bugzilla.ximian.com"
       TITLE="[Mono-bugs] [Bug 62369][Wis] New - memory leak garbage problem">bugzilla-daemon@bugzilla.ximian.com
       </A><BR>
    <I>Tue,  3 Aug 2004 12:42:21 -0400 (EDT)</I>
    <P><UL>
        <LI> Previous message: <A HREF="019373.html">[Mono-bugs] [Bug 62364][Wis] Changed - numerous GC warnings are reported when using NAnt on Mono/Linux
</A></li>
        <LI> Next message: <A HREF="019375.html">[Mono-bugs] [Bug 62360][Min] Changed - Automatic reference of assemblies
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19374">[ date ]</a>
              <a href="thread.html#19374">[ thread ]</a>
              <a href="subject.html#19374">[ subject ]</a>
              <a href="author.html#19374">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please do not reply to this email- if you want to comment on the bug, go to the
URL shown below and enter your comments there.

Changed by <A HREF="mailto:kaya@kayaweed.net.">kaya@kayaweed.net.</A>

<A HREF="http://bugzilla.ximian.com/show_bug.cgi?id=62369">http://bugzilla.ximian.com/show_bug.cgi?id=62369</A>

--- shadow/62369	2004-08-03 12:42:21.000000000 -0400
+++ shadow/62369.tmp.10760	2004-08-03 12:42:21.000000000 -0400
@@ -0,0 +1,245 @@
+Bug#: 62369
+Product: Mono: Runtime
+Version: unspecified
+OS: 
+OS Details: WinXP SP1 US AND Linux DEBIAN UNSTABLE
+Status: NEW   
+Resolution: 
+Severity: 
+Priority: Wishlist
+Component: packaging
+AssignedTo: <A HREF="mailto:duncan@ximian.com">duncan@ximian.com</A>                            
+ReportedBy: <A HREF="mailto:kaya@kayaweed.net">kaya@kayaweed.net</A>               
+QAContact: <A HREF="mailto:mono-bugs@ximian.com">mono-bugs@ximian.com</A>
+TargetMilestone: ---
+URL: 
+Cc: 
+Summary: memory leak garbage problem
+
+Please fill in this template when reporting a bug, unless you know what you
+are doing.
+Description of Problem:
+
+At a end of a process i seek into a file, read from it, and write it back
+to an another file, using a byte[] variable as buffer.
+My routine is working but i memory leak.
+
+I made a test program to check where the memory leak came from.
+
+Steps to reproduce the problem:
+1. 
+2. 
+3. 
+
+Actual Results:
+
+
+Expected Results:
+the memory should go up and down.
+Actually this just goes up.
+
+How often does this happen? 
+every time
+
+Additional Information:
+
+the main.cs
+		public static void Main(string[] args)
+		{
+			IsoClass	iso = new IsoClass();
+			iso.extractiso();
+			
+		}
+
+here is the source file &quot;xiso.cs&quot;.
+
+namespace Xiso
+{
+using System;
+using System.IO;
+using System.Text;
+using System.Data;
+using System.Net;
+using System.Net.Sockets;
+using System.Collections;
+	
+	class IsoClass
+	{
+	
+		public struct dirent
+		{
+		 public long	ltable;				//left entry
+		 public long	rtable;				//right entry
+		 public long	sector;				//sector of file
+		 public long	size;				//size of file
+		 public int		attribs;			//file attributes
+		 public int		fnamelen;			//filename lenght
+		 public string 	fname;				//filename
+		 public long	pad;				//padding (unused)
+		}
+
+		const string HEADERDATA = &quot;MICROSOFT*XBOX*MEDIA&quot;;
+		const int	 HEADERSIZE	= 20;
+		const int	 HEADEROFF	= 0x10000;
+		const int	 BUFFERSIZE	= 0x40000; //256k buffer
+		
+		FileStream fs; //File Handling
+		StreamReader w; //Stream
+		
+		public byte[] buffer = new byte[0];
+		
+		public void extractiso()
+		{
+			Console.WriteLine(&quot;Hello World!&quot;);
+			Console.WriteLine(&quot;Start of archive&quot;);
+	        fs  = new FileStream(@&quot;D:\xbox\Xbox WhiteOut.iso&quot;, FileMode.Open,
+	                             FileAccess.Read);
+	        // Create a character reader.
+	        w = new StreamReader(fs);
+
+			// Create and change to Game directory
+			Directory.CreateDirectory(&quot;WhiteOut&quot;);
+			Directory.SetCurrentDirectory(&quot;WhiteOut&quot;);
+			
+	        // Set the StreamReader file pointer to the end.
+	        w.BaseStream.Seek( HEADEROFF, SeekOrigin.Begin);
+			byte[] bufheader = new byte[20];
+			int size = w.BaseStream.Read(bufheader, 0, bufheader.Length);
+			//Console.WriteLine(&quot;Size lu &quot; + size);
+			if(size != 0)
+			{					
+				string s=System.Text.Encoding.ASCII.GetString(bufheader,0,HEADERSIZE);
+				bufheader = null;
+				if (s.Equals(&quot;MICROSOFT*XBOX*MEDIA&quot;))
+				{					 
+					Console.WriteLine(&quot;Is a xbox iso&quot;);
+					//Error file doesnt appear to be a xbox iso image
+				}
+				//Sector that root directory table resides in
+				byte[] buf = new byte[4];
+				size = w.BaseStream.Read(buf, 0, 4);
+				long sectorroot = ((buf[3]&lt;&lt;24)+(buf[2]&lt;&lt;16)+(buf[1]&lt;&lt;8)+(buf[0]&lt;&lt; 0 ));
+				Console.WriteLine(&quot;Sector root directory [&quot;+ sectorroot + &quot;]&quot;);
+				//Size of root directory table in bytes
+				buf = new byte[4];
+				size = w.BaseStream.Read(buf, 0, 4);
+				int sizeroot = ((buf[3]&lt;&lt;24)+(buf[2]&lt;&lt;16)+(buf[1]&lt;&lt;8)+(buf[0]&lt;&lt; 0 ));
+				Console.WriteLine(&quot;Size root directory [&quot;+ sizeroot + &quot;]&quot;);
+				//discard FILETIME structure representing image creation time
+				w.BaseStream.Seek( 8, SeekOrigin.Current);
+				//discard unused
+				w.BaseStream.Seek( 0x7c8, SeekOrigin.Current);
+				buf = new byte[20];
+				size = w.BaseStream.Read(buf, 0, buf.Length);
+				s = System.Text.Encoding.ASCII.GetString(buf,0,buf.Length);
+				if (s.Equals(&quot;MICROSOFT*XBOX*MEDIA&quot;))
+				{					 
+					Console.WriteLine(&quot;Is a xbox iso 2&quot;);
+					//Error possible corruption?
+				}
+				//Done With HEADER
+				buf = null;
+				s = null;
+				handling(sectorroot*2048, (int)sectorroot);
+			}
+			Console.WriteLine(&quot;End of archive&quot;);
+			w.Close();
+			fs.Close();
+			w = null;
+			fs = null;
+		// End extractiso
+		}
+		
+		private void handling(long offset, int dtable)
+		{
+			dirent cur = new dirent();
+			
+			// Start from the beginning 
+			w.BaseStream.Seek(offset, SeekOrigin.Begin);
+			Console.WriteLine(&quot;Next Offset [&quot; + offset + &quot;]&quot;);
+				
+			//time to fill the structure
+			byte[] buf = new byte[2];
+			//ltable offset from current
+			int size = w.BaseStream.Read(buf, 0, buf.Length);
+			cur.ltable = ((buf[1]&lt;&lt;8) | (buf[0]));
+			Console.WriteLine(&quot;ltable offset [&quot;+ cur.ltable + &quot;]&quot;);
+			
+			//rtable offset from current
+			size = w.BaseStream.Read(buf, 0, buf.Length);
+			cur.rtable = ((buf[1]&lt;&lt;8) | (buf[0]));	
+			Console.WriteLine(&quot;rtable offset [&quot;+ cur.rtable + &quot;]&quot;);
+			
+			buf = new byte[4];
+			//sector of file
+			size = w.BaseStream.Read(buf, 0, buf.Length);
+			cur.sector = ((buf[3]&lt;&lt;24) | (buf[2]&lt;&lt;16) | (buf[1]&lt;&lt;8) | buf[0]);
+			Console.WriteLine(&quot;Sector of file [&quot;+ cur.sector + &quot;]&quot;);
+			//file size
+			size = w.BaseStream.Read(buf, 0, buf.Length);
+			cur.size = ((buf[3]&lt;&lt;24) | (buf[2]&lt;&lt;16) | (buf[1]&lt;&lt;8) | buf[0]);
+			Console.WriteLine(&quot;Size of file [&quot;+ cur.size + &quot;]&quot;);
+				
+			buf = new byte[1];
+			//file attributes
+			size = w.BaseStream.Read(buf, 0, buf.Length);
+			cur.attribs = ((buf[0]&lt;&lt;0));
+			Console.WriteLine(&quot;file attributes [&quot;+ cur.attribs + &quot;]&quot;);
+			//filename length
+			size = w.BaseStream.Read(buf, 0, buf.Length);
+			cur.fnamelen = ((buf[0]&lt;&lt;0));
+			Console.WriteLine(&quot;length of filename [&quot;+ cur.fnamelen + &quot;]&quot;);
+			
+			// Filename
+			buf = new byte[cur.fnamelen];
+			size = w.BaseStream.Read(buf, 0, buf.Length);
+			cur.fname = System.Text.Encoding.ASCII.GetString(buf, 0, cur.fnamelen);
+			Console.WriteLine(&quot;Filename [&quot;+ cur.fname + &quot;]\n&quot;);
+			buf = null;
+			if((cur.fname != null) &amp;&amp; (cur.attribs == 16)) // attribs is a DIR
+				{
+					Console.WriteLine(&quot;Creating directory [&quot;  + cur.fname + &quot;]&quot;);
+					Directory.CreateDirectory(cur.fname);
+					Directory.SetCurrentDirectory(cur.fname);
+					//Call back handling
+					handling(cur.sector*2048, (int)cur.sector);
+					Directory.SetCurrentDirectory(@&quot;..&quot;);
+				}
+			else
+			{
+				//So now we have to extract
+				extract(cur);
+			}	
+		    if(cur.rtable != 0)
+		    {
+		    	Console.WriteLine(&quot;rtable&quot; + cur.sector + &quot;==&quot; + cur.rtable);
+		         handling(dtable*2048+(cur.rtable*4), dtable);
+		    }
+		    if (cur.ltable != 0)
+		    {
+		    	Console.WriteLine(&quot;ltable&quot; + cur.sector + &quot;==&quot; + cur.ltable);
+		      	handling(dtable*2048+(cur.ltable*4), dtable);			
+		    }
+		    
+		  //End handling
+		}
+		
+		private void extract(dirent cur)
+		{
+            // Create a new stream to load this photo into
+            System.IO.FileStream stream = new System.IO.FileStream(cur.fname, 
+                                                    System.IO.FileMode.Create);
+			
+			w.BaseStream.Seek(cur.sector*2048, SeekOrigin.Begin);
+            // Create a buffer to hold the stream bytes
+            byte[] buffer = new byte[cur.size];
+			w.BaseStream.Read(buffer, 0, buffer.Length);
+            // Read the bytes from this stream
+            stream.Write(buffer, 0, (int)buffer.Length);
+            // Now we can close the stream
+            stream.Close();	
+			buffer = null;
+			return;
+		}
+	}
+}

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="019373.html">[Mono-bugs] [Bug 62364][Wis] Changed - numerous GC warnings are reported when using NAnt on Mono/Linux
</A></li>
	<LI> Next message: <A HREF="019375.html">[Mono-bugs] [Bug 62360][Min] Changed - Automatic reference of assemblies
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19374">[ date ]</a>
              <a href="thread.html#19374">[ thread ]</a>
              <a href="subject.html#19374">[ subject ]</a>
              <a href="author.html#19374">[ author ]</a>
         </LI>
       </UL>
</body></html>
