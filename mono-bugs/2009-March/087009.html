<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 485416] New: Anonymous delegate closure functionality may cause serious leaks
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20485416%5D%20New%3A%20Anonymous%20delegate%20closure%0A%20functionality%20may%20cause%20serious%20leaks&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="087081.html">
   <LINK REL="Next"  HREF="087045.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 485416] New: Anonymous delegate closure functionality may cause serious leaks</H1>
    <B>bugzilla_noreply at novell.com</B> 
    <A HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20485416%5D%20New%3A%20Anonymous%20delegate%20closure%0A%20functionality%20may%20cause%20serious%20leaks&In-Reply-To="
       TITLE="[Mono-bugs] [Bug 485416] New: Anonymous delegate closure functionality may cause serious leaks">bugzilla_noreply at novell.com
       </A><BR>
    <I>Sat Mar 14 11:49:27 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="087081.html">[Mono-bugs] [Bug 485378] Cannot resolve method overload
</A></li>
        <LI>Next message: <A HREF="087045.html">[Mono-bugs] [Bug 485416] Anonymous delegate closure functionality may cause serious leaks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#87009">[ date ]</a>
              <a href="thread.html#87009">[ thread ]</a>
              <a href="subject.html#87009">[ subject ]</a>
              <a href="author.html#87009">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE><A HREF="https://bugzilla.novell.com/show_bug.cgi?id=485416">https://bugzilla.novell.com/show_bug.cgi?id=485416</A>


           Summary: Anonymous delegate closure functionality may cause
                    serious leaks
    Classification: Mono
           Product: Mono: Compilers
           Version: 2.0.x
          Platform: All
        OS/Version: All
            Status: NEW
          Severity: Normal
          Priority: P5 - None
         Component: C#
        AssignedTo: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at lists.ximian.com</A>
        ReportedBy: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">cdhowie at gmail.com</A>
         QAContact: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at lists.ximian.com</A>
          Found By: ---


User-Agent:       Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.0.6)
Gecko/2009020407 Iceweasel/3.0.6 (Debian-3.0.6-1)

If two anonymous delegates are declared in the same method, the variables in
the method scope that are referenced by either delegate magically become
members on a hidden class to implement proper closure functionality. 
Unfortunately, only one class is ever used, carrying the potential of a serious
memory leak if the developer is not careful.  Consider:

--------8&lt;--------
using System;

public class Test {
    public static void Main() {
        object somethingBig = new object();
        int i = 0;

        EventHandler a = delegate {
            somethingBig.GetType();
        };

        EventHandler b = delegate {
            i++;
        };
    }   

    public static void Main2() {
        object somethingBig = new object();

        int i1 = 0;
        int i2 = 0;

        EventHandler a = delegate {
            somethingBig.GetType();
            i1++;
        };

        EventHandler b = delegate {
            i1++;
            i2++;
        };
    }
}
--------8&lt;--------

In the Main method, the set of locals used in the delegates do not intersect at
all.  However, the two locals will both be moved to the same hidden class to
implement the closure.  If something like a large Dictionary&lt;,&gt; is used instead
of a simple object, it will not be garbage collected until either the &quot;local&quot;
is set to null or both delegates are released.  If the second one lives for a
while, it could cause a serious memory overhead, even though this fact is not
obvious, nor intuitive, from reading the code, without understanding how
anonymous delegates are implemented.

The Main2 method is a tad more complex since the intersection of the set of
locals used in each delegate is not empty (they share one local in common). 
Still, it would not be intuitive that keeping the reference stored in the &quot;b&quot;
local alive should keep the object local alive as well.

Reproducible: Always

-- 
Configure bugmail: <A HREF="https://bugzilla.novell.com/userprefs.cgi?tab=email">https://bugzilla.novell.com/userprefs.cgi?tab=email</A>
------- You are receiving this mail because: -------
You are the QA contact for the bug.
You are the assignee for the bug.
</PRE>


















































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="087081.html">[Mono-bugs] [Bug 485378] Cannot resolve method overload
</A></li>
	<LI>Next message: <A HREF="087045.html">[Mono-bugs] [Bug 485416] Anonymous delegate closure functionality may cause serious leaks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#87009">[ date ]</a>
              <a href="thread.html#87009">[ thread ]</a>
              <a href="subject.html#87009">[ subject ]</a>
              <a href="author.html#87009">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-bugs">More information about the mono-bugs
mailing list</a><br>
</body></html>
