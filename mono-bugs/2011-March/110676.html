<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 684316] New: WebRequest consistently dies with memory leak (iPhone3G) or Mprotect crash (iPhone4)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20684316%5D%20New%3A%20WebRequest%20consistently%20dies%20with%0A%20memory%20leak%20%28iPhone3G%29%20or%20Mprotect%20crash%20%28iPhone4%29&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="110674.html">
   <LINK REL="Next"  HREF="110677.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 684316] New: WebRequest consistently dies with memory leak (iPhone3G) or Mprotect crash (iPhone4)</H1>
    <B>bugzilla_noreply at novell.com</B> 
    <A HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20684316%5D%20New%3A%20WebRequest%20consistently%20dies%20with%0A%20memory%20leak%20%28iPhone3G%29%20or%20Mprotect%20crash%20%28iPhone4%29&In-Reply-To="
       TITLE="[Mono-bugs] [Bug 684316] New: WebRequest consistently dies with memory leak (iPhone3G) or Mprotect crash (iPhone4)">bugzilla_noreply at novell.com
       </A><BR>
    <I>Thu Mar 31 18:22:07 EDT 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="110674.html">[Mono-bugs] [Bug 684281] Section index text is not shown for	UITableView
</A></li>
        <LI>Next message: <A HREF="110677.html">[Mono-bugs] [Bug 684316] WebRequest consistently dies with memory leak (iPhone3G) or Mprotect crash (iPhone4)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#110676">[ date ]</a>
              <a href="thread.html#110676">[ thread ]</a>
              <a href="subject.html#110676">[ subject ]</a>
              <a href="author.html#110676">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
<A HREF="https://bugzilla.novell.com/show_bug.cgi?id=684316">https://bugzilla.novell.com/show_bug.cgi?id=684316</A>

<A HREF="https://bugzilla.novell.com/show_bug.cgi?id=684316#c0">https://bugzilla.novell.com/show_bug.cgi?id=684316#c0</A>


           Summary: WebRequest consistently dies with memory leak
                    (iPhone3G) or Mprotect crash (iPhone4)
    Classification: Mono
           Product: MonoTouch
           Version: unspecified
          Platform: iPhone
        OS/Version: All
            Status: NEW
          Severity: Critical
          Priority: P5 - None
         Component: Runtime
        AssignedTo: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">gnorton at novell.com</A>
        ReportedBy: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mike.biz at dussault.org</A>
         QAContact: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at lists.ximian.com</A>
          Found By: ---
           Blocker: ---


User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US)
AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.151 Safari/534.16

I've got a MonoTouch app that does a 3.5MB HTTP POST. It seems to leak memory
every time I upload. On an iPhone 3G (OS 3.1.2), the app is jettisoned with a
LowMemory report after 6-10 uploads. On an iPhone 4 (OS 4.2.1), the app gets an
Mprotect error after about 14 uploads.

This is a big showstopper issue for our app because uploading Facebook videos
is a major feature for us.


A few data points:

- Instruments does NOT show the memory increasing as the app continues to
upload.

- Instruments doesn't show any significant leaks (maybe 1 kilobyte total).

- It doesn't matter whether I write the post data in 8k chunks, 64k chunks, or
all at once with one Stream.Write() call.

- It doesn't matter whether I wait for a response (HttpWebRequest.HaveResponse)
or not before starting the next upload.

- It doesn't matter if the POST data is even valid. I've tried using valid POST
data and I've tried sending 3MB of zeros.

- It doesn't matter if I use the async versions of the WebRequest calls from my
main thread vs creating a thread of my own and using the synchronous versions
of the WebRrequest and stream calls.

- If the app is not allocating any data each frame (in SimulateAppAllocations),
then the app still dies eventually but it takes longer to run out of memory.
(BUT: as mentioned before, the memory that I'm allocating each frame is not
referenced after the frame it was allocated on, so it should always be
available for the garbage collector to cleanup).




Reproducible: Always

Steps to Reproduce:
1. Create a new MonoTouch iPhone OpenGL ES project.

2. Paste the following code into the EAGLView class and call UpdateCrashTest()
from OnRenderFrame(). (Note that I've also attached the complete EAGLView.cs
file to this bug report).



void UpdateCrashTest()
        {
            SimulateAppAllocations();
            UpdatePost();
        }



        AsyncHttpPost m_Post;
        int m_nPosts = 1;

        void UpdatePost()
        {
            if ( m_Post == null || m_Post.PostStatus !=
AsyncHttpPostStatus.InProgress )
            {
                System.Console.WriteLine( string.Format( &quot;Starting post {0}&quot;,
m_nPosts++ ) );

                m_Post = new AsyncHttpPost(
                    &quot;<A HREF="https://api-video.facebook.com/restserver.php&quot;,">https://api-video.facebook.com/restserver.php&quot;,</A>
                    &quot;multipart/form-data; boundary=&quot; + &quot;8cdbcdf18ab6640&quot; );
            }
        }


        //
        // Stuff to randomly allocate in order to simulate a normal app's
behavior.
        //
        Random m_Random = new Random(0);
        List&lt; byte [] &gt; m_Allocations;
        List&lt; byte[] &gt; m_InitialAllocations;

        void SimulateAppAllocations()
        {
            // First time through, allocate a bunch of data that the app would
allocate.
            // We'll keep our pointers to this stuff so it doesn't get garbage
collected.
            if ( m_InitialAllocations == null )
            {
                m_InitialAllocations = new List&lt;byte[]&gt;();
                int nInitialBytes = 6 * 1024 * 1024;
                int nBlockSize = 30000;
                for ( int nCurBytes = 0; nCurBytes &lt; nInitialBytes; nCurBytes
+= nBlockSize )
                {
                    m_InitialAllocations.Add( new byte[nBlockSize] );
                }
            }

            // Also, each frame, allocate up to 100k of data. We don't hang
onto these pointers after the next
            // frame so it should get garbage collected.
            m_Allocations = new List&lt;byte[]&gt;();
            for ( int i=0; i &lt; 10; i++ )
            {
                int nAllocationSize = m_Random.Next( 10000 ) + 10;
                m_Allocations.Add( new byte[nAllocationSize] );
            }
        }
    }


    public enum AsyncHttpPostStatus
    {
        InProgress,
        Success,
        Fail
    }

    public class AsyncHttpPost
    {
        public AsyncHttpPost( string sURL, string sContentType )
        {
            m_PostStatus = AsyncHttpPostStatus.InProgress;
            m_sContentType = sContentType;
            m_sURL = sURL;

            m_UploadThread = new Thread( new ThreadStart( UploadThread ) );
            m_UploadThread.Start();
        }

        void UploadThread()
        {
            using ( MonoTouch.Foundation.NSAutoreleasePool pool = new
MonoTouch.Foundation.NSAutoreleasePool() )
            {
                try
                {
                    HttpWebRequest request = WebRequest.Create( m_sURL ) as
HttpWebRequest;
                    request.Method = &quot;POST&quot;;
                    request.ContentType = m_sContentType;
                    request.CachePolicy = new
System.Net.Cache.RequestCachePolicy(
System.Net.Cache.RequestCacheLevel.NoCacheNoStore );

                    int nBytesToWrite = 1024 * 1024 * 3; // m_PostData.Length;
                    request.ContentLength = nBytesToWrite;

                    // Write the post data.
                    using ( Stream stream = request.GetRequestStream() )
                    {
                        int nBlockSize = 1024 * 8;
                        for ( int nBytesWritten=0; nBytesWritten &lt;
nBytesToWrite; nBytesWritten += nBlockSize )
                        {
                            int nBytes = Math.Min( nBytesToWrite -
nBytesWritten, nBlockSize );
                            byte [] bytes = new byte[nBytes];
                            stream.Write( bytes, 0, bytes.Length );
                        }

                        stream.Close();
                    }

                    // Wait for the response.
                    while ( !request.HaveResponse )
                    {
                        MonoTouch.Foundation.NSThread.SleepFor( 0.1f );
                    }
                    System.Console.WriteLine( &quot;Finished!&quot; );

                    // Finished!
                    m_PostStatus = AsyncHttpPostStatus.Success;
                }
                catch ( System.Exception e )
                {
                    System.Console.WriteLine( &quot;Error in
AsyncHttpPost.UploadThread:\n&quot; + e.Message );
                    m_PostStatus = AsyncHttpPostStatus.Fail;
                }
            }
        }

        public AsyncHttpPostStatus PostStatus
        {
            get
            {
                return m_PostStatus;
            }
        }


        Thread m_UploadThread;
        AsyncHttpPostStatus m_PostStatus;
        string m_sContentType;
        string m_sURL;
    } 
Actual Results:  
iPhone 3G Result: The app gets through 6 to 10 uploads and then the OS kills
it. There is no crash log, but there is a LowMemory log showing that the app
was jettisoned.

iPhone 4 Result: It gets an Mprotect error around the 11th upload.

Expected Results:  
Since we're not keeping references to old objects here, the app should run
forever without crashing or running out of memory.

-- 
Configure bugmail: <A HREF="https://bugzilla.novell.com/userprefs.cgi?tab=email">https://bugzilla.novell.com/userprefs.cgi?tab=email</A>
------- You are receiving this mail because: -------
You are the QA contact for the bug.
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="110674.html">[Mono-bugs] [Bug 684281] Section index text is not shown for	UITableView
</A></li>
	<LI>Next message: <A HREF="110677.html">[Mono-bugs] [Bug 684316] WebRequest consistently dies with memory leak (iPhone3G) or Mprotect crash (iPhone4)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#110676">[ date ]</a>
              <a href="thread.html#110676">[ thread ]</a>
              <a href="subject.html#110676">[ subject ]</a>
              <a href="author.html#110676">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-bugs">More information about the mono-bugs
mailing list</a><br>
</body></html>
