<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 79893][Maj] New - FSW not working properly
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%2079893%5D%5BMaj%5D%20New%20-%20FSW%20not%20working%20properly&In-Reply-To=bug-79893%40chernobyl.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="049874.html">
   <LINK REL="Next"  HREF="049876.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 79893][Maj] New - FSW not working properly</H1>
    <B>bugzilla-daemon at bugzilla.ximian.com</B> 
    <A HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%2079893%5D%5BMaj%5D%20New%20-%20FSW%20not%20working%20properly&In-Reply-To=bug-79893%40chernobyl.ximian.com"
       TITLE="[Mono-bugs] [Bug 79893][Maj] New - FSW not working properly">bugzilla-daemon at bugzilla.ximian.com
       </A><BR>
    <I>Fri Nov 10 11:39:20 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="049874.html">[Mono-bugs] [Bug 79867][Nor] Changed - TabControl: Focus stuck at	tab page
</A></li>
        <LI>Next message: <A HREF="049876.html">[Mono-bugs] [Bug 79893][Maj] Changed - FSW not working properly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49875">[ date ]</a>
              <a href="thread.html#49875">[ thread ]</a>
              <a href="subject.html#49875">[ subject ]</a>
              <a href="author.html#49875">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please do not reply to this email- if you want to comment on the bug, go to the
URL shown below and enter your comments there.

Changed by <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mickaelpic at yahoo.fr.</A>

<A HREF="http://bugzilla.ximian.com/show_bug.cgi?id=79893">http://bugzilla.ximian.com/show_bug.cgi?id=79893</A>

--- shadow/79893	2006-11-10 11:39:20.000000000 -0500
+++ shadow/79893.tmp.9985	2006-11-10 11:39:20.000000000 -0500
@@ -0,0 +1,340 @@
+Bug#: 79893
+Product: Mono: Runtime
+Version: unspecified
+OS: other
+OS Details: RedHat EL 4
+Status: NEW   
+Resolution: 
+Severity: 008 One day
+Priority: Major
+Component: io-layer
+AssignedTo: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">dick at ximian.com</A>                            
+ReportedBy: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mickaelpic at yahoo.fr</A>               
+QAContact: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at ximian.com</A>
+TargetMilestone: ---
+URL: 
+Cc: 
+Summary: FSW not working properly
+
+Please fill in this template when reporting a bug, unless you know what 
+you are doing.
+Description of Problem:
+The FileSystemWatcher does not get all the events.
+Somtime it even ignore all event.
+It seems to be related to the number of files/directories allready in the 
+watched folder.
+The less files/directories there are in a watch folder, the better the FSW 
+performs.
+The strangest thing is that the problem seems to affect more than one 
+watch. If one watch has a lot of files/directories, there is a high 
+probability to not get events from it, and the next watch with no 
+files/directory will send no events at all.
+
+
+Steps to reproduce the problem:
+1. Compile and start the code I join to this report.
+2. Copy directories and files (50000 files in 340 directories) to a watch 
+folder, and check the output of the application
+3. Delete the folders and check the output
+
+Actual Results:
+(first number is number of events received, second number is number of 
+files/directories that raised an event)
+
+Copy the directories/files
+/home/user1/watch1/ Create: 25041 25041
+/home/user1/watch1/ Change: 329 215
+/home/user1/watch1/ Delete: 0 0
+/home/user1/watch1/ Rename: 0 0
+/home/user1/watch1/ Error: 0 0
+Delete the directories files
+/home/user1/watch1/ Create: 25041 25041
+/home/user1/watch1/ Change: 329 215
+/home/user1/watch1/ Delete: 0 0
+/home/user1/watch1/ Rename: 0 0
+/home/user1/watch1/ Error: 0 0
+
+Expected Results:
+Copy the directories/files
+/home/user1/watch1/ Create: 50340 50340
+/home/user1/watch1/ Change: 50340 50340
+/home/user1/watch1/ Delete: 0 0
+/home/user1/watch1/ Rename: 0 0
+/home/user1/watch1/ Error: 0 0
+Delete the directories files
+/home/user1/watch1/ Create: 50340 50340
+/home/user1/watch1/ Change: 50340 50340
+/home/user1/watch1/ Delete: 50340 50340
+/home/user1/watch1/ Rename: 0 0
+/home/user1/watch1/ Error: 0 0
+
+How often does this happen? 
+Every time, but the number of events received is different everytime.
+But never the good amount.
+
+Additional Information:
+Following is the code for the test application
+
+-----
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Collections;
+
+namespace FSWtester
+{
+	class MainClass
+	{
+		public static void Main(string[] args)
+		{
+			try
+			{
+				if(args.Length == 0)
+				{
+					Console.WriteLine(&quot;FSWTester 
+directories&quot;);
+					return;
+				}
+				
+				Thread[] threadArray = null;
+				Processing processing = null;
+				string[] directories = null;
+				
+				directories = new string[args.Length];
+				for(int i = 0; i &lt; directories.Length; i 
+++)
+				{
+					directories[i] = args[i];
+				}
+
+				threadArray = new Thread
+[directories.Length];
+				
+				int minWorker, minIOC;
+				ThreadPool.GetMinThreads(out minWorker, 
+out minIOC);
+				Console.WriteLine(minWorker + &quot; &quot; + 
+minIOC);
+				
+				ThreadPool.GetMaxThreads(out minWorker, 
+out minIOC);
+				Console.WriteLine(minWorker + &quot; &quot; + 
+minIOC);
+
+				ThreadPool.SetMinThreads(10, 10);
+
+				ThreadPool.GetMinThreads(out minWorker, 
+out minIOC);
+				Console.WriteLine(minWorker + &quot; &quot; + 
+minIOC);
+				
+				for(int i = 0; i &lt; threadArray.Length; i 
+++)
+				{
+					processing = new Processing
+(directories[i]);
+					threadArray[i] = new Thread
+(processing.Watching);
+                	threadArray[i].Name = &quot;Processing &quot; + i.ToString
+(&quot;D2&quot;);
+                }
+				for (int i = 0; i &lt; threadArray.Length; 
+i++)
+				{
+					threadArray[i].Start();
+				}
+				
+				while(true)
+				{
+					Thread.Sleep(new TimeSpan(0,0,5));
+				}
+			}
+			catch(Exception ex)
+			{
+				Console.WriteLine(&quot;Exception! System 
+reports: &quot; + ex.ToString());
+			}
+		}
+		
+		public class Processing
+		{
+			private FileSystemWatcher fSW = new 
+FileSystemWatcher();
+			private int deleteCount = 0;
+			private Hashtable hashtableDelete = new Hashtable
+();
+			private int createCount = 0;
+			private Hashtable hashtableCreate = new Hashtable
+();
+			private int changeCount = 0;
+			private Hashtable hashtableChange = new Hashtable
+();
+			private int renameCount = 0;
+			private Hashtable hashtableRename = new Hashtable
+();
+			private int errorCount = 0;
+			private string directory = string.Empty;
+
+			public Processing(string directory)
+			{
+				this.directory = directory;
+			}			
+		
+			public void Watching()
+			{
+				try
+				{
+					//fSW.BeginInit();
+
+					Console.WriteLine(&quot;Monitoring 
+directory: &quot; + directory);
+
+					try
+					{
+						fSW.Path = directory;
+					}
+					catch (System.Exception ex)
+					{
+						// directory to watch is 
+bad or offline
+						Console.WriteLine(&quot;Could 
+not start File System Watch on directory &quot; + directory  + &quot;. Directory 
+does not exist or is corrupted. System reports: &quot; + ex.ToString());
+						return;
+					}
+					
+					fSW.IncludeSubdirectories = true;
+				
+					fSW.NotifyFilter = 
+NotifyFilters.CreationTime | NotifyFilters.LastWrite | 
+NotifyFilters.FileName | NotifyFilters.DirectoryName;			
+			
+
+					fSW.InternalBufferSize = 
+125829120; // 120MB
+
+					fSW.Changed += new 
+FileSystemEventHandler(OnChanged);
+					fSW.Created += new 
+FileSystemEventHandler(OnCreated);
+					fSW.Deleted += new 
+FileSystemEventHandler(OnDeleted);
+					fSW.Renamed += new 
+RenamedEventHandler(OnRename);
+
+					fSW.Error	+= new 
+ErrorEventHandler(OnError);
+					
+					fSW.EnableRaisingEvents = true;
+
+					Thread.CurrentThread.Priority = 
+System.Threading.ThreadPriority.AboveNormal;
+					//fSW.EndInit();
+					
+					while(true)
+					{
+						Thread.Sleep(new TimeSpan
+(0,0,5));
+						Console.WriteLine
+(directory + &quot; Create: &quot; + createCount + &quot; &quot; + hashtableCreate.Count);
+						Console.WriteLine
+(directory + &quot; Change: &quot; + changeCount + &quot; &quot; + hashtableChange.Count);
+						Console.WriteLine
+(directory + &quot; Delete: &quot; + deleteCount + &quot; &quot; + hashtableDelete.Count);
+						Console.WriteLine
+(directory + &quot; Rename: &quot; + renameCount + &quot; &quot; + hashtableRename.Count);
+						Console.WriteLine
+(directory + &quot; Error : &quot; + errorCount);
+						Console.WriteLine(&quot;-------
+&quot;);
+					}
+				}
+				catch(Exception ex)
+				{
+					Console.WriteLine(&quot;Exception! 
+System reports: &quot; + ex.ToString());
+				}
+			}
+			
+			public void OnCreated(object source, 
+FileSystemEventArgs e)
+			{
+				createCount ++;
+				//Console.WriteLine(&quot;Create event for 
+file &quot; + e.FullPath);
+				if(hashtableCreate.ContainsKey(e.FullPath) 
+== false)
+				{
+					hashtableCreate.Add(e.FullPath, 1);
+				}
+				else
+				{
+					hashtableCreate[e.FullPath] = (int)
+hashtableCreate[e.FullPath] + 1; 
+				}
+			}
+
+			public void OnChanged(object source, 
+FileSystemEventArgs e)
+			{		
+				changeCount ++;	
+				//Console.WriteLine(&quot;Change event for 
+file &quot; + e.FullPath);
+				if(hashtableChange.ContainsKey(e.FullPath) 
+== false)
+				{
+					hashtableChange.Add(e.FullPath, 1);
+				}
+				else
+				{
+					hashtableChange[e.FullPath] = (int)
+hashtableChange[e.FullPath] + 1; 
+				}
+			}
+
+			public void OnDeleted(object source, 
+FileSystemEventArgs e)
+			{
+				deleteCount ++;
+				//Console.WriteLine(&quot;Delete event for 
+file &quot; + e.FullPath);
+				if(hashtableDelete.ContainsKey(e.FullPath) 
+== false)
+				{
+					hashtableDelete.Add(e.FullPath, 1);
+				}
+				else
+				{
+					hashtableDelete[e.FullPath] = (int)
+hashtableDelete[e.FullPath] + 1; 
+				}
+			}
+			
+			public void OnRename(object source, 
+RenamedEventArgs e)
+			{
+				renameCount ++;
+				//Console.WriteLine(&quot;Rename event for 
+file &quot; + e.FullPath);
+				if(hashtableRename.ContainsKey(e.FullPath) 
+== false)
+				{
+					hashtableRename.Add(e.FullPath, 1);
+				}
+				else
+				{
+					hashtableRename[e.FullPath] = (int)
+hashtableRename[e.FullPath] + 1; 
+				}
+			}
+
+			public void OnError(object source, ErrorEventArgs  
+e)
+			{
+				errorCount ++;
+				//Console.WriteLine(&quot;Error event&quot;);
+			}
+		}
+	}
+}
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="049874.html">[Mono-bugs] [Bug 79867][Nor] Changed - TabControl: Focus stuck at	tab page
</A></li>
	<LI>Next message: <A HREF="049876.html">[Mono-bugs] [Bug 79893][Maj] Changed - FSW not working properly
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49875">[ date ]</a>
              <a href="thread.html#49875">[ thread ]</a>
              <a href="subject.html#49875">[ subject ]</a>
              <a href="author.html#49875">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-bugs">More information about the mono-bugs
mailing list</a><br>
</body></html>
