<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 42303][Nor] Changed - Path.GetFullPath () does not handle '.' and '..'
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:bugzilla-daemon%40rocky.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="005068.html">
   <LINK REL="Next"  HREF="005070.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 42303][Nor] Changed - Path.GetFullPath () does not handle '.' and '..'
   </H1>
    <B>bugzilla-daemon@rocky.ximian.com
    </B> 
    <A HREF="mailto:bugzilla-daemon%40rocky.ximian.com"
       TITLE="[Mono-bugs] [Bug 42303][Nor] Changed - Path.GetFullPath () does not handle '.' and '..'">bugzilla-daemon@rocky.ximian.com
       </A><BR>
    <I>Tue,  6 May 2003 06:40:28 -0400 (EDT)</I>
    <P><UL>
        <LI> Previous message: <A HREF="005068.html">[Mono-bugs] [Bug 42393][Nor] Changed - UDP Multicast fail on SetSocketOption
</A></li>
        <LI> Next message: <A HREF="005070.html">[Mono-bugs] [Bug 42316][Nor] Changed - The runtime does not free strings passed to P/Invoked functions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5069">[ date ]</a>
              <a href="thread.html#5069">[ thread ]</a>
              <a href="subject.html#5069">[ subject ]</a>
              <a href="author.html#5069">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please do not reply to this email- if you want to comment on the bug, go to the
URL shown below and enter your comments there.

Changed by <A HREF="mailto:gfr@skynet.be.">gfr@skynet.be.</A>

<A HREF="http://bugzilla.ximian.com/show_bug.cgi?id=42303">http://bugzilla.ximian.com/show_bug.cgi?id=42303</A>

--- shadow/42303	Mon May  5 19:02:17 2003
+++ shadow/42303.tmp.13411	Tue May  6 06:40:28 2003
@@ -1,13 +1,13 @@
 Bug#: 42303
 Product: Mono/Class Libraries
 Version: unspecified
 OS: unknown
 OS Details: Red Hat 9 + libgc,mono,mcs up-to-date from cvs
-Status: RESOLVED   
-Resolution: FIXED
+Status: REOPENED   
+Resolution: 
 Severity: Unknown
 Priority: Normal
 Component: CORLIB
 AssignedTo: <A HREF="mailto:bmaurer@users.sf.net">bmaurer@users.sf.net</A>                            
 ReportedBy: <A HREF="mailto:gfr@skynet.be">gfr@skynet.be</A>               
 QAContact: <A HREF="mailto:mono-bugs@ximian.com">mono-bugs@ximian.com</A>
@@ -141,6 +141,249 @@
 ------- Additional Comments From <A HREF="mailto:bmaurer@users.sf.net">bmaurer@users.sf.net</A>  2003-05-05 18:25 -------
 Ok, function written. Now I need to write NUnit tests before this gets
 checked in.
 
 ------- Additional Comments From <A HREF="mailto:bmaurer@users.sf.net">bmaurer@users.sf.net</A>  2003-05-05 19:02 -------
 Fixed in CVS
+
+------- Additional Comments From <A HREF="mailto:gfr@skynet.be">gfr@skynet.be</A>  2003-05-06 06:40 -------
+Hello Ben,
+
+I don't know how to write a test unit with NUnit (i've not yet the 
+time to look coorectly to NUnit).
+
+Some case are not yet supported by the new implementation.
+
+I've write yesterday a more powerfull sample with one examples which
+fake the Path.GetFullPath () from microsoft and compare the result 
+from the fake method ant the microsoft method.
+
+Only the test L38 to L39 are not yet resolved and could create some 
+probleme for a full compatibility.
+
+This case is '//servername/path' ... MS assume than if the path start
+with // then the path is an UNC path.
+
+If you desire, i can try to fix my method code this week in order to 
+be fully compliant with the MS method and allow a correct 
+implementation under Unix with support for UNC.
+
+This is my test code. All test return success under MS Dotnet Window.
+
+Best Regards,
+Gilles
+
+&gt;&gt;&gt; SOT &gt;&gt;&gt;
+using System;
+using System.Text;
+using System.IO;
+using System.Collections;
+
+namespace Test6
+{
+	public class Test6
+	{
+		public static System.String GetFullPath 
+(System.String path)
+		{
+			Stack			  stack   = new 
+Stack         ();
+			StringBuilder	  builder = new 
+StringBuilder ();
+			System.String     volume  = null;
+			System.String  [] split;
+
+			if (Path.IsPathRooted (path) == false)
+			{
+				path = Path.Combine 
+(Directory.GetCurrentDirectory (), path);
+			}
+
+			if (Path.VolumeSeparatorChar != 
+Path.DirectorySeparatorChar &amp;&amp;
+			    Path.VolumeSeparatorChar != 
+Path.AltDirectorySeparatorChar)
+			{
+				split = path.Split   
+(Path.VolumeSeparatorChar);
+				if (split.Length == 2)
+				{
+					volume  = split[0];
+					path    = split[1];
+				}
+				else
+				{
+					split  = Path.GetPathRoot 
+(Directory.GetCurrentDirectory ()).Split (Path.VolumeSeparatorChar);
+					volume = split.Length == 2 ? 
+split[0] : null;
+				}
+			}
+
+			foreach (System.String directoryName in 
+path.Split (Path.AltDirectorySeparatorChar, 
+Path.DirectorySeparatorChar))
+			{
+				if (directoryName.Length == 0)
+				{
+					continue;
+				}
+
+#if             MS_NOT_BUGGED
+				System.String directory = 
+directoryName;
+#else           
+				System.String directory = 
+directoryName.Trim (' ');
+#endif
+
+				if (directory.Length == 0)
+				{
+					throw new ArgumentException 
+(&quot;The path is not of a legal form.&quot;);
+				}
+
+				if (directory == &quot;.&quot;)
+				{
+					continue;
+				}
+
+				if (directory == &quot;..&quot;)
+				{
+					if (stack.Count &gt; 0)
+					{
+						stack.Pop ();
+					}
+
+					continue;
+				}
+
+				stack.Push (directory);
+			}
+
+			System.Object [] rst = stack.ToArray ();
+			stack.Clear ();
+
+			if (volume != null)
+			{
+				builder.Append (volume)
+					   .Append 
+(Path.VolumeSeparatorChar)
+					   .Append 
+(Path.DirectorySeparatorChar);
+			}
+			else
+			{
+				builder.Append 
+(Path.DirectorySeparatorChar);
+			}
+
+			for (System.Int32 i=rst.Length-1; i&gt;=0; i--)
+			{
+				builder.Append ((System.String) rst
+[i]);
+
+				if (i != 0)
+				{
+					builder.Append 
+(Path.DirectorySeparatorChar);
+				}
+			}
+
+			if (path.Length &gt; 0 &amp;&amp;
+				builder.Length &gt; 0 &amp;&amp;
+				builder[builder.Length-1] != 
+Path.DirectorySeparatorChar &amp;&amp;
+				(path[path.Length-1] == 
+Path.AltDirectorySeparatorChar ||
+				 path[path.Length-1] == 
+Path.DirectorySeparatorChar))
+			{
+				builder.Append 
+(Path.DirectorySeparatorChar);
+			}
+
+			return builder.ToString ();
+		}
+    
+		public static void Test (System.String label, 
+System.String Expanded)
+		{
+			System.String compacted = GetFullPath 
+(Expanded);
+			System.String expanded  = Path.GetFullPath 
+(Expanded);
+
+			if (expanded == compacted)
+			{
+				System.Console.Out.WriteLine (&quot;Test -
+ {0, -3} - success : expanded = compacted = '{1}'&quot;, label, expanded);
+			}
+			else
+			{
+				System.Console.Out.WriteLine (&quot;Test -
+ {0, -3} - fail    : expanded '{1}' and compacted = '{2}'&quot;, 
+					label, expanded, compacted);
+			}
+		}
+    
+		public static void Main ()
+		{
+			System.Console.WriteLine (&quot;Current Directory 
+is {0}&quot;, Directory.GetCurrentDirectory());
+
+			Test 
+(&quot;L1&quot;,  &quot;/root/././././././../root/././../root&quot;);
+			Test 
+(&quot;L2&quot;,  &quot;c:/windows/././././././../windows/././../windows&quot;);
+			Test (&quot;L3&quot;,  &quot;/root/&quot;);
+			Test (&quot;L4&quot;,  &quot;/root/./&quot;);
+			Test (&quot;L5&quot;,  &quot;/root/./&quot;);
+			Test (&quot;L6&quot;,  &quot;/root/../&quot;);
+			Test (&quot;L7&quot;,  &quot;../&quot;);
+			Test (&quot;L8&quot;,  &quot;./&quot;);
+			Test (&quot;L9&quot;,  &quot;/root/../&quot;);
+			Test (&quot;L10&quot;, &quot;/root/../..&quot;);
+			Test (&quot;L11&quot;, &quot;c:/windows/../..&quot;);
+			Test (&quot;L12&quot;, &quot;c:/windows/../..&quot;);
+			Test (&quot;L13&quot;, &quot;/root/.hiddenfile&quot;);
+			Test (&quot;L14&quot;, &quot;/root/. /&quot;);
+			Test (&quot;L15&quot;, &quot;/root/.. /&quot;);
+			Test (&quot;L16&quot;, &quot;/root/..weirdname&quot;);
+			Test (&quot;L17&quot;, &quot;/root/..&quot;);
+			Test (&quot;L18&quot;, &quot;/root/../a/b/../../..&quot;);
+			Test (&quot;L19&quot;, &quot;/root/./..&quot;);
+			Test (&quot;L20&quot;,  &quot;c:/../&quot;);
+			Test (&quot;L21&quot;,  &quot;c:/..&quot;);
+			Test (&quot;L22&quot;,  &quot;c:/./&quot;);
+			Test (&quot;L23&quot;,  &quot;c:/.&quot;);
+			Test (&quot;L24&quot;,  &quot;c:/&quot;);
+			Test (&quot;L25&quot;,  &quot;/..&quot;);
+			Test (&quot;L26&quot;,  &quot;/.&quot;);
+			Test (&quot;L27&quot;, &quot;c:/windows//dir&quot;);
+			Test (&quot;L28&quot;, &quot;/root//dir&quot;);
+			Test (&quot;L29&quot;, &quot;/root/.              /&quot;);
+			Test (&quot;L30&quot;, &quot;/root/..             /&quot;);
+			Test (&quot;L31&quot;, &quot;/root/      .              /&quot;);
+			Test (&quot;L32&quot;, &quot;/root/      ..             /&quot;);
+			Test (&quot;L33&quot;, &quot;/root/			
+	  .						   /&quot;);
+			Test (&quot;L34&quot;, &quot;/root/			
+		 ..	  			   /&quot;);
+			Test (&quot;L35&quot;, &quot;/root/.			
+		/&quot;);
+			Test (&quot;L36&quot;, &quot;/root/..\t\t\t/&quot;);
+			Test (&quot;L37&quot;, &quot;/.//&quot;);
+			// Test (&quot;L38&quot;, &quot;/  /&quot;); Exception : The UNC 
+path should be of the form \\server\share.
+			// Test (&quot;L39&quot;, &quot; &quot;); Exception : The path 
+is not of a legal form.
+			// Test (&quot;L40&quot;, &quot;  &quot;); Exception : The path 
+is not of a legal form.
+			// Test (&quot;L38&quot;, &quot;//&quot;); Exception : The UNC 
+path should be of the form \\server\share.
+
+			System.Console.WriteLine ();
+		}
+	}
+}
+&gt;&gt;&gt; EOT &gt;&gt;&gt;

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="005068.html">[Mono-bugs] [Bug 42393][Nor] Changed - UDP Multicast fail on SetSocketOption
</A></li>
	<LI> Next message: <A HREF="005070.html">[Mono-bugs] [Bug 42316][Nor] Changed - The runtime does not free strings passed to P/Invoked functions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5069">[ date ]</a>
              <a href="thread.html#5069">[ thread ]</a>
              <a href="subject.html#5069">[ subject ]</a>
              <a href="author.html#5069">[ author ]</a>
         </LI>
       </UL>
</body></html>
