<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 54946][Cri] New - Remotinf with ChannelSink Interop with Microsoft
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:bugzilla-daemon%40bugzilla.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="012912.html">
   <LINK REL="Next"  HREF="012914.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 54946][Cri] New - Remotinf with ChannelSink Interop with Microsoft
   </H1>
    <B>bugzilla-daemon@bugzilla.ximian.com
    </B> 
    <A HREF="mailto:bugzilla-daemon%40bugzilla.ximian.com"
       TITLE="[Mono-bugs] [Bug 54946][Cri] New - Remotinf with ChannelSink Interop with Microsoft">bugzilla-daemon@bugzilla.ximian.com
       </A><BR>
    <I>Fri, 27 Feb 2004 13:24:55 -0500 (EST)</I>
    <P><UL>
        <LI> Previous message: <A HREF="012912.html">[Mono-bugs] [Bug 54945][Nor] Changed - GetCustomAttributes failing for fields defined in a base class
</A></li>
        <LI> Next message: <A HREF="012914.html">[Mono-bugs] [Bug 54939][Min] Changed - Convert.FromBase64String doesn't accept NL and LF in the string
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12913">[ date ]</a>
              <a href="thread.html#12913">[ thread ]</a>
              <a href="subject.html#12913">[ subject ]</a>
              <a href="author.html#12913">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please do not reply to this email- if you want to comment on the bug, go to the
URL shown below and enter your comments there.

Changed by <A HREF="mailto:jluciani@novell.com.">jluciani@novell.com.</A>

<A HREF="http://bugzilla.ximian.com/show_bug.cgi?id=54946">http://bugzilla.ximian.com/show_bug.cgi?id=54946</A>

--- shadow/54946	2004-02-27 13:24:55.000000000 -0500
+++ shadow/54946.tmp.10383	2004-02-27 13:24:55.000000000 -0500
@@ -0,0 +1,1171 @@
+Bug#: 54946
+Product: Mono/Runtime
+Version: unspecified
+OS: 
+OS Details: 
+Status: NEW   
+Resolution: 
+Severity: 
+Priority: Critical
+Component: misc
+AssignedTo: <A HREF="mailto:mono-bugs@ximian.com">mono-bugs@ximian.com</A>                            
+ReportedBy: <A HREF="mailto:jluciani@novell.com">jluciani@novell.com</A>               
+QAContact: <A HREF="mailto:mono-bugs@ximian.com">mono-bugs@ximian.com</A>
+TargetMilestone: ---
+URL: 
+Cc: 
+Summary: Remotinf with ChannelSink Interop with Microsoft
+
+Please fill in this template when reporting a bug, unless you know what you
+are doing.
+Description of Problem:
+
+I have Client and Server ChannelSink components that exchange messages that
+contain empty streams, these channel sinks are configured into the channel
+sink chain by the Client and Server applications. When I execute the client
+ under Mono and the server under .NET, I get the following exception:
+
+Unhandled Exception: System.NotSupportedException: Unknown header code: 2
+ 
+Server stack trace:
+in &lt;0x00132&gt;
+System.Runtime.Remoting.Channels.Tcp.TcpMessageIO:ReceiveHeaders
+(System.IO.Stream,byte[])
+in &lt;0x00196&gt;
+System.Runtime.Remoting.Channels.Tcp.TcpMessageIO:ReceiveMessageStream
+(System.IO.Stream,System.Runtime.Remoting.Channels.ITransportHeaders&amp;,byte[])
+in &lt;0x0011e&gt;
+System.Runtime.Remoting.Channels.Tcp.TcpClientTransportSink:ProcessMessage
+(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Channels.ITransportHeaders,System.IO.Stream,System.Runtime.Remoting.Channels.ITransportHeaders&amp;,System.IO.Stream&amp;)
+in &lt;0x000c8&gt; ChannelSinkTest.ClientSink:ProcessMessage
+(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Channels.ITransportHeaders,System.IO.Stream,System.Runtime.Remoting.Channels.ITransportHeaders&amp;,System.IO.Stream&amp;)
+in &lt;0x0019b&gt;
+System.Runtime.Remoting.Channels.BinaryClientFormatterSink:SyncProcessMessage
+(System.Runtime.Remoting.Messaging.IMessage)
+ 
+ 
+Exception rethrown at [0]:
+ 
+in (unmanaged) /usr/lib/libmono.so.0(mono_raise_exception+0x1c) [0x400ae34c]
+in (unmanaged) /usr/lib/libmono.so.0 [0x400c0f2c]
+in &lt;0x00042&gt; (wrapper remoting-invoke) ChannelSinkTest.LinePrinter:print
+(string)
+in &lt;0x00032&gt; (wrapper remoting-invoke-with-check)
+ChannelSinkTest.LinePrinter:print (string)
+in &lt;0x000e7&gt; ChannelSinkTest.Client:Main (string[])
+
+Comparing Lan traces of the server being accessed from a Windows client
+with the traces of the server being accessed from a Mono client show that
+the Mono client requests are missing the url when the request stream is
+empty, when this happens, the Windows server returns a message indicating
+that it has encountered an internal error.
+
+Steps to reproduce the problem:
+1. Build the following: ChannelSink, LinePrinter, Client, Server.
+
+The code for ChannelSink is:
+
+using System;
+
+using System.IO;
+
+using System.Collections;
+
+using System.Runtime.Remoting.Channels;
+
+using System.Runtime.Remoting;
+
+using System.Runtime.Remoting.Messaging;
+
+
+
+namespace ChannelSinkTest
+
+{
+
+   /// &lt;summary&gt;
+
+   /// ClientSink implementation.
+
+   /// &lt;/summary&gt;
+
+   public class ClientSink: BaseChannelSinkWithProperties, IClientChannelSink
+
+   {
+
+      #region Class Members and Defines
+
+
+
+      private IClientChannelSink m_nextSink;
+
+
+
+      #endregion
+
+
+
+      /// &lt;summary&gt;
+
+      /// Constructor.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;next&quot;&gt;The next sink in the chain&lt;/param&gt;
+
+      public ClientSink(IClientChannelSink next)
+
+      {
+
+         Console.WriteLine(&quot;ClientSink instantiated&quot;);
+
+
+
+         m_nextSink = next;
+
+      }
+
+
+
+
+
+      /// &lt;summary&gt;
+
+      /// Processes message to be sent to the peer.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;requestMsg&quot;&gt;Request message&lt;/param&gt;
+
+      /// &lt;param name=&quot;requestHeaders&quot;&gt;Request transport headers&lt;/param&gt;
+
+      /// &lt;param name=&quot;requestStream&quot;&gt;Request stream&lt;/param&gt;
+
+      /// &lt;param name=&quot;responseHeaders&quot;&gt;Response transport headers&lt;/param&gt;
+
+      /// &lt;param name=&quot;responseStream&quot;&gt;Response stream&lt;/param&gt;
+
+      public void ProcessMessage(IMessage msg,
+
+         ITransportHeaders requestHeaders,
+
+         Stream requestStream,
+
+         out ITransportHeaders responseHeaders,
+
+         out Stream responseStream)
+
+      {
+
+         Console.WriteLine(&quot;ClientSink.ProcessMessage- Enter&quot;);
+
+
+
+         // Initialize output parameters
+
+         responseHeaders = null;
+
+         responseStream = null;
+
+
+
+         // Send primer message to the server
+
+         ITransportHeaders primerReqHeaders = new TransportHeaders();
+
+         primerReqHeaders[&quot;Content-Type&quot;] = &quot;text/xml; charset=\&quot;utf-8\&quot;&quot;;
+
+         primerReqHeaders[&quot;Primer&quot;] = &quot;PrimerMsg&quot;;
+
+         Stream primerReqStream = new MemoryStream();
+
+
+
+         // Forward the call to the next sink
+
+         m_nextSink.ProcessMessage(msg,
+
+            primerReqHeaders,
+
+            primerReqStream,
+
+            out responseHeaders,
+
+            out responseStream);
+
+
+
+         // Re-Initialize output parameters
+
+         responseHeaders = null;
+
+         responseStream = null;
+
+
+
+         // Set request header
+
+         requestHeaders[&quot;Primer&quot;] = &quot;NotPrimerMsg&quot;;
+
+         //requestHeaders[&quot;Content-Type&quot;] = &quot;text/xml; charset=\&quot;utf-8\&quot;&quot;;
+
+
+
+         // Forward the call to the next sink
+
+         m_nextSink.ProcessMessage(msg,
+
+            requestHeaders,
+
+            requestStream,
+
+            out responseHeaders,
+
+            out responseStream);
+
+
+
+         Console.WriteLine(&quot;ClientSink.ProcessMessage- Exit&quot;);
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Asynchronously process message to be sent to the peer.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;sinkStack&quot;&gt;Client channel sink stack&lt;/param&gt;
+
+      /// &lt;param name=&quot;msg&quot;&gt;Request message&lt;/param&gt;
+
+      /// &lt;param name=&quot;headers&quot;&gt;Request transport headers&lt;/param&gt;
+
+      /// &lt;param name=&quot;stream&quot;&gt;Request stream&lt;/param&gt;
+
+      public void AsyncProcessRequest(IClientChannelSinkStack sinkStack,
+
+         IMessage msg,
+
+         ITransportHeaders headers,
+
+         Stream stream)
+
+      {
+
+         Console.WriteLine(&quot;ClientSink:AsyncProcessRequest- Enter&quot;);
+
+
+
+         // We do not have support for this yet
+
+         throw new Exception(&quot;SecureClientSink:AsyncProcessMessage: Async
+Remoting Not Supported Yet&quot;);
+
+
+
+         // Push onto stack and forward the request
+
+         //sinkStack.Push(this, asyncContext);
+
+         //m_nextSink.AsyncProcessRequest(sinkStack, msg, headers,
+streamProxy);
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Process response to message that was sent asynchronously to message.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;sinkStack&quot;&gt;Client response channel sink stack&lt;/param&gt;
+
+      /// &lt;param name=&quot;contextObject&quot;&gt;Context object&lt;/param&gt;
+
+      /// &lt;param name=&quot;headers&quot;&gt;Response transport headers&lt;/param&gt;
+
+      /// &lt;param name=&quot;stream&quot;&gt;Response stream&lt;/param&gt;
+
+      public void AsyncProcessResponse(IClientResponseChannelSinkStack
+sinkStack,
+
+         object contextObject,
+
+         ITransportHeaders headers,
+
+         Stream stream)
+
+      {
+
+         Console.WriteLine(&quot;ClientSink:AsyncProcessResponse- Enter&quot;);
+
+
+
+         // We do not have support for this yet
+
+         throw new Exception(&quot;SecureClientSink:AsyncProcessResponse: Async
+Remoting Not Supported Yet&quot;);
+
+
+
+         // Forward the request
+
+         //sinkStack.AsyncProcessResponse(headers,stream);
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Requests a request stream from the next sink in the channel sink
+chain.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;msg&quot;&gt;Message&lt;/param&gt;
+
+      /// &lt;param name=&quot;headers&quot;&gt;Transport Headers&lt;/param&gt;
+
+      /// &lt;returns&gt;Request stream&lt;/returns&gt;
+
+      public Stream GetRequestStream(IMessage msg,
+
+         ITransportHeaders headers)
+
+      {
+
+         Console.WriteLine(&quot;ClientSink:GetRequestStream- Enter&quot;);
+
+
+
+         Stream stream = m_nextSink.GetRequestStream(msg, headers);
+
+
+
+         Console.WriteLine(&quot;ClientSink:GetRequestStream- Exit&quot;);
+
+
+
+         return stream;
+
+      }
+
+
+
+
+
+      /// &lt;summary&gt;
+
+      /// Returns the next sink in the channel chain.
+
+      /// &lt;/summary&gt;
+
+      public IClientChannelSink NextChannelSink {get {return m_nextSink;}}
+
+   }
+
+
+
+   /// &lt;summary&gt;
+
+   /// ClientSinkProvider implementation.
+
+   /// &lt;/summary&gt;
+
+   public class ClientSinkProvider: IClientChannelSinkProvider
+
+   {
+
+      #region Class Members and Defines
+
+
+
+      private IClientChannelSinkProvider m_nextProvider;
+
+
+
+      #endregion
+
+
+
+      /// &lt;summary&gt;
+
+      /// Constructor.
+
+      /// &lt;/summary&gt;
+
+      public ClientSinkProvider()
+
+      {
+
+         Console.WriteLine(&quot;ClientSinkProvider instantiated&quot;);
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// get - Return the next channel sink provider in the chain.
+
+      /// set - Specifies the next channel sink provider in the chain.
+
+      /// &lt;/summary&gt;
+
+      public IClientChannelSinkProvider Next
+
+      {
+
+         get {return m_nextProvider;}
+
+         set {m_nextProvider = value;}
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Creates ClientSink and chains it to channel sink chain.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;channel&quot;&gt;Channel provider chain&lt;/param&gt;
+
+      /// &lt;param name=&quot;url&quot;&gt;Url&lt;/param&gt;
+
+      /// &lt;param name=&quot;remoteChannelData&quot;&gt;Remote channel data&lt;/param&gt;
+
+      /// &lt;returns&gt;SecureClientSink&lt;/returns&gt;
+
+      public IClientChannelSink CreateSink(IChannelSender channel,
+
+         string url,
+
+         object remoteChannelData)
+
+      {
+
+         Console.WriteLine(&quot;ClientSinkProvider:CreateSink- Enter&quot;);
+
+
+
+         // Create other sinks in the chain
+
+         IClientChannelSink next = m_nextProvider.CreateSink(channel,
+
+            url,
+
+            remoteChannelData);
+
+
+
+         // Allocate SecureClientSink chained to the chain
+
+         ClientSink sink = new ClientSink(next);
+
+
+
+         Console.WriteLine(&quot;ClientSinkProvider:CreateSink- Exit&quot;);
+
+
+
+         return sink;
+
+      }
+
+   }
+
+
+
+
+
+   /// &lt;summary&gt;
+
+   /// ServerSink implementation.
+
+   /// &lt;/summary&gt;
+
+   public class ServerSink: BaseChannelSinkWithProperties, IServerChannelSink
+
+   {
+
+      #region Class Members and Defines
+
+
+
+      private IServerChannelSink m_nextSink;
+
+
+
+      #endregion
+
+      /// &lt;summary&gt;
+
+      /// Constructor.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;next&quot;&gt;The next sink in the chain&lt;/param&gt;
+
+      /// &lt;param name=&quot;secServerFactory&quot;&gt;The factory that we must use for
+creating SecurityServers&lt;/param&gt;
+
+      /// &lt;param name=&quot;minMsgSecLevel&quot;&gt;The minimum message security level
+to allow&lt;/param&gt;
+
+      public ServerSink(IServerChannelSink next)
+
+      {
+
+         Console.WriteLine(&quot;ServerSink instantiated&quot;);
+
+
+
+         m_nextSink = next;
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Processes message received from peer.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;sinkStack&quot;&gt;Server channel sink stack&lt;/param&gt;
+
+      /// &lt;param name=&quot;requestMsg&quot;&gt;Request message&lt;/param&gt;
+
+      /// &lt;param name=&quot;requestHeaders&quot;&gt;Request transport headers&lt;/param&gt;
+
+      /// &lt;param name=&quot;requestStream&quot;&gt;Request stream&lt;/param&gt;
+
+      /// &lt;param name=&quot;responseMsg&quot;&gt;Response message&lt;/param&gt;
+
+      /// &lt;param name=&quot;responseHeaders&quot;&gt;Response transport headers&lt;/param&gt;
+
+      /// &lt;param name=&quot;responseStream&quot;&gt;Response stream&lt;/param&gt;
+
+      /// &lt;returns&gt;Indication of whether the message was processed&lt;/returns&gt;
+
+      public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
+
+         IMessage requestMsg,
+
+         ITransportHeaders requestHeaders,
+
+         Stream requestStream,
+
+         out IMessage responseMsg,
+
+         out ITransportHeaders responseHeaders,
+
+         out Stream responseStream) 
+
+      {
+
+         Console.WriteLine(&quot;SecureServerSink.ProcessMessage- Enter&quot;);
+
+
+
+         // Initialize the output parameters
+
+         responseMsg = null;
+
+         responseHeaders = null;
+
+         responseStream = null;
+
+
+
+         // Proceed based on the contents of the &quot;Primer&quot; header
+
+         string primerHeaderValue = requestHeaders[&quot;Primer&quot;] as string;
+
+         if (primerHeaderValue == &quot;PrimerMsg&quot;)
+
+         {
+
+            // Just allocate necessary return structures
+
+            responseHeaders = (ITransportHeaders) new TransportHeaders();
+
+            responseStream = new MemoryStream();
+
+         }
+
+         else
+
+         {
+
+            // Process the message
+
+            sinkStack.Push(this, null);
+
+            ServerProcessing srvProc = m_nextSink.ProcessMessage(sinkStack,
+
+               requestMsg,
+
+               requestHeaders,
+
+               requestStream,
+
+               out responseMsg,
+
+               out responseHeaders,
+
+               out responseStream);
+
+            sinkStack.Pop(this);
+
+         }
+
+
+
+         // Add response headers
+
+         responseHeaders[&quot;TestHeader&quot;] = &quot;Test header value&quot;;
+
+         responseHeaders[&quot;Content-Type&quot;] = &quot;text/xml; charset=\&quot;utf-8\&quot;&quot;;
+
+
+
+         Console.WriteLine(&quot;ServerSink.ProcessMessage- Exit&quot;);
+
+
+
+         return ServerProcessing.Complete;
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Processes an asynchronous message destined for a peer.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;sinkStack&quot;&gt;Server response channel sink stack&lt;/param&gt;
+
+      /// &lt;param name=&quot;state&quot;&gt;????&lt;/param&gt;
+
+      /// &lt;param name=&quot;msg&quot;&gt;Response message&lt;/param&gt;
+
+      /// &lt;param name=&quot;headers&quot;&gt;Response transport headers&lt;/param&gt;
+
+      /// &lt;param name=&quot;stream&quot;&gt;Response stream&lt;/param&gt;
+
+      public void AsyncProcessResponse(IServerResponseChannelSinkStack
+sinkStack,
+
+         object state,
+
+         IMessage msg,
+
+         ITransportHeaders headers,
+
+         Stream stream)
+
+      {
+
+         Console.WriteLine(&quot;ServerSink.AsyncProcessResponse- Enter&quot;);
+
+
+
+         // Not implemented
+
+
+
+         // Forwarding to the stack for further processIng
+
+         sinkStack.AsyncProcessResponse(msg, headers, stream);
+
+
+
+         Console.WriteLine(&quot;ServerSink.AsyncProcessResponse- Exit&quot;);
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Requests a response stream from the next sink in the channel sink
+chain.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;sinkStack&quot;&gt;Channel sink stack&lt;/param&gt;
+
+      /// &lt;param name=&quot;contextObject&quot;&gt;Context object&lt;/param&gt;
+
+      /// &lt;param name=&quot;msg&quot;&gt;Message&lt;/param&gt;
+
+      /// &lt;param name=&quot;headers&quot;&gt;Transport Headers&lt;/param&gt;
+
+      /// &lt;returns&gt;Response stream&lt;/returns&gt;
+
+      public Stream GetResponseStream(IServerResponseChannelSinkStack
+sinkStack,
+
+         object contextObject,
+
+         IMessage msg,
+
+         ITransportHeaders headers)
+
+      {
+
+         Console.WriteLine(&quot;ServerSink.GetResponseStream- Enter&quot;);
+
+
+
+         // tbd
+
+         Stream stream = null;
+
+
+
+         Console.WriteLine(&quot;ServerSink.GetResponseStream- Exit&quot;);
+
+
+
+         return stream;
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Returns the next sink in the channel chain.
+
+      /// &lt;/summary&gt;
+
+      public IServerChannelSink NextChannelSink {get {return m_nextSink;}}
+
+   }
+
+
+
+
+
+   /// &lt;summary&gt;
+
+   /// ServerSinkProvider implementation.
+
+   /// &lt;/summary&gt;
+
+   public class ServerSinkProvider: IServerChannelSinkProvider
+
+   {
+
+      #region Class Members and Defines
+
+
+
+      private IServerChannelSinkProvider m_nextProvider;
+
+
+
+      #endregion
+
+
+
+      /// &lt;summary&gt;
+
+      /// Constructor.
+
+      /// &lt;/summary&gt;
+
+      public ServerSinkProvider()
+
+      {
+
+         Console.WriteLine(&quot;ServerSinkProvider instantiated&quot;);
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// get - Return the next channel sink provider in the chain.
+
+      /// set - Specifies the next channel sink provider in the chain.
+
+      /// &lt;/summary&gt;
+
+      public IServerChannelSinkProvider Next
+
+      {
+
+         get {return m_nextProvider;}
+
+         set {m_nextProvider = value;}
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Creates ServerSink and chains it to channel sink chain.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;channel&quot;&gt;Channel provider chain&lt;/param&gt;
+
+      /// &lt;returns&gt;ServerSink&lt;/returns&gt;
+
+      public IServerChannelSink CreateSink(IChannelReceiver channel)
+
+      {
+
+         Console.WriteLine(&quot;ServerSinkProvider.CreateSink- Enter&quot;);
+
+
+
+         // Create other sinks in the chain
+
+         IServerChannelSink next = m_nextProvider.CreateSink(channel);
+
+
+
+         // Allocate ServerSink chained to the chain
+
+         ServerSink sink = new ServerSink(next);
+
+
+
+         Console.WriteLine(&quot;ServerSinkProvider.CreateSink- Exit&quot;);
+
+
+
+         return sink;
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Does nothing.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;channelData&quot;&gt;&lt;/param&gt;
+
+      public void GetChannelData(IChannelDataStore channelData)
+
+      {
+
+         Console.WriteLine(&quot;ServerSinkProvider.GetChannelData- Enter&quot;);
+
+
+
+         // No need to implement
+
+
+
+         Console.WriteLine(&quot;ServerSinkProvider.GetChannelData- Exit&quot;);
+
+      }
+
+   }
+
+}
+
+
+
+The code for LinePrinter is:
+
+using System;
+
+
+
+namespace ChannelSinkTest
+
+{
+
+   /// &lt;summary&gt;
+
+   /// Represents a line printer.
+
+   /// &lt;/summary&gt;
+
+   public class LinePrinter: MarshalByRefObject
+
+   {
+
+      /// &lt;summary&gt;
+
+      /// Constructor.
+
+      /// &lt;/summary&gt;
+
+      public LinePrinter()
+
+      {
+
+         Console.WriteLine(&quot;LinePrinter instantiated&quot;);
+
+      }
+
+
+
+      /// &lt;summary&gt;
+
+      /// Prints line to console.
+
+      /// &lt;/summary&gt;
+
+      /// &lt;param name=&quot;line&quot;&gt;Line to be printed&lt;/param&gt;
+
+      public void print(string line)
+
+      {
+
+         Console.WriteLine(&quot;LinePrinter.print- called&quot;);
+
+
+
+         // Process the request
+
+         Console.WriteLine(line);
+
+      }
+
+   }
+
+}
+
+
+
+The code for Client is:
+
+using System;
+
+using System.Runtime.Remoting;
+using System.Runtime.Remoting.Channels;
+using System.Runtime.Remoting.Channels.Tcp;
+using System.Collections;
+using System.Collections.Specialized;
+
+
+namespace ChannelSinkTest
+
+{
+
+	/// &lt;summary&gt;
+
+	/// Summary description for Class1.
+
+	/// &lt;/summary&gt;
+
+	class Client
+
+	{
+
+      /// &lt;summary&gt;
+
+      /// Creates channel sink provider chain
+
+      /// &lt;/summary&gt;
+
+      /// &lt;returns&gt;&lt;/returns&gt;
+
+      static IClientChannelSinkProvider CreateClientProviderChain()
+
+      {
+
+         IClientChannelSinkProvider chain = (IClientChannelSinkProvider)
+new BinaryClientFormatterSinkProvider();
+
+         IClientChannelSinkProvider sink = chain;
+
+         sink.Next = (IClientChannelSinkProvider) new ClientSinkProvider();
+
+         sink = sink.Next;
+
+         return chain;
+
+      }
+
+      /// &lt;summary&gt;
+
+		/// The main entry point for the application.
+
+		/// &lt;/summary&gt;
+
+		[STAThread]
+
+		static void Main(string[] args)
+
+		{
+
+         Console.WriteLine (&quot;Client.Main(): Client started&quot;);
+
+         // Setup a channel to request LinePrinter objects from the server
+         ListDictionary channelProperties = new ListDictionary();
+
+         IClientChannelSinkProvider clientChannelSinkProvider =
+CreateClientProviderChain();
+
+         TcpChannel channel = new TcpChannel(channelProperties,
+
+            clientChannelSinkProvider,
+
+            new BinaryServerFormatterSinkProvider());
+
+         ChannelServices.RegisterChannel(channel);
+
+         // Obtain LinePrinter object
+         Console.WriteLine(&quot;Client.Main(): Acquiring LinePrinter object&quot;);
+         LinePrinter linePrinter = (LinePrinter)
+Activator.GetObject(typeof(LinePrinter),
+            &quot;<A HREF="tcp://servername:8090/LinePrinter"">tcp://servername:8090/LinePrinter&quot;</A>);
+
+         // Send line to the line printer
+         linePrinter.print(&quot;This is a test line&quot;);
+
+         // Keep running until Enter is pressed
+         Console.WriteLine(&quot;Press Enter to exit...&quot;);
+         Console.ReadLine();
+		}
+
+	}
+
+}
+
+
+
+The code for Server is:
+
+using System;
+
+using System.Runtime.Remoting;
+using System.Runtime.Remoting.Channels;
+using System.Runtime.Remoting.Channels.Tcp;
+using System.Collections;
+using System.Collections.Specialized;
+
+
+namespace ChannelSinkTest
+
+{
+
+	/// &lt;summary&gt;
+
+	/// Summary description for Class1.
+
+	/// &lt;/summary&gt;
+
+	class Server
+
+	{
+
+      /// &lt;summary&gt;
+
+      /// Creates channel sink provider chain
+
+      /// &lt;/summary&gt;
+
+      /// &lt;returns&gt;&lt;/returns&gt;
+
+      static IServerChannelSinkProvider CreateServerProviderChain()
+
+      {
+
+         IServerChannelSinkProvider chain = (IServerChannelSinkProvider)
+new ServerSinkProvider();
+
+         IServerChannelSinkProvider sink = chain;
+
+         sink.Next = (IServerChannelSinkProvider) new
+BinaryServerFormatterSinkProvider();            
+
+         sink = sink.Next;
+
+         return chain;
+
+      }
+
+      /// &lt;summary&gt;
+
+		/// The main entry point for the application.
+
+		/// &lt;/summary&gt;
+
+		[STAThread]
+
+		static void Main(string[] args)
+
+		{
+
+         Console.WriteLine (&quot;Server.Main(): Server started&quot;);
+
+         // Setup a channel to listen for LinePrinter requests
+         ListDictionary channelProperties = new ListDictionary();
+
+         channelProperties.Add(&quot;port&quot;, 8090);
+
+         IServerChannelSinkProvider serverChannelSinkProvider =
+CreateServerProviderChain();
+
+         TcpChannel channel = new TcpChannel(channelProperties,
+
+            new BinaryClientFormatterSinkProvider(),
+
+            serverChannelSinkProvider);
+
+         ChannelServices.RegisterChannel(channel);
+
+         // Register the LinePrinterFactory class with the remoting sub-system
+        
+RemotingConfiguration.RegisterWellKnownServiceType(typeof(LinePrinter),
+            &quot;LinePrinter&quot;,
+            WellKnownObjectMode.Singleton);
+
+         // Keep running until Enter is pressed
+         Console.WriteLine(&quot;Listening for requests. Press Enter to exit...&quot;);
+         Console.ReadLine();
+		}
+
+	}
+
+}
+
+
+
+2. Start the Server on a Windows .NET machine, wait for it to say that it
+is listening for requests.
+ 
+3. Start the Client on a Linux box with the command &quot;mono Client.exe&quot;
+
+Actual Results:
+
+The Client excepts.
+
+Expected Results:
+
+The Client should print a line on the Server Console and wait for input to
+terminate.
+
+How often does this happen? 
+
+Everytime.
+
+Additional Information:
+
+eMail me if you want me to send you the code and the assemblies to the
+sample code.

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="012912.html">[Mono-bugs] [Bug 54945][Nor] Changed - GetCustomAttributes failing for fields defined in a base class
</A></li>
	<LI> Next message: <A HREF="012914.html">[Mono-bugs] [Bug 54939][Min] Changed - Convert.FromBase64String doesn't accept NL and LF in the string
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12913">[ date ]</a>
              <a href="thread.html#12913">[ thread ]</a>
              <a href="subject.html#12913">[ subject ]</a>
              <a href="author.html#12913">[ author ]</a>
         </LI>
       </UL>
</body></html>
