<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 71203][Wis] Changed - Many Socket Methods Fail when &gt; 1024 File descriptors are Open
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:bugzilla-daemon%40bugzilla.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="024027.html">
   <LINK REL="Next"  HREF="024034.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 71203][Wis] Changed - Many Socket Methods Fail when &gt; 1024 File descriptors are Open
   </H1>
    <B>bugzilla-daemon@bugzilla.ximian.com
    </B> 
    <A HREF="mailto:bugzilla-daemon%40bugzilla.ximian.com"
       TITLE="[Mono-bugs] [Bug 71203][Wis] Changed - Many Socket Methods Fail when &gt; 1024 File descriptors are Open">bugzilla-daemon@bugzilla.ximian.com
       </A><BR>
    <I>Wed, 12 Jan 2005 16:49:41 -0500 (EST)</I>
    <P><UL>
        <LI> Previous message: <A HREF="024027.html">[Mono-bugs] [Bug 71073][Wis] Changed - unfixable warning cs0067 &quot;event not used&quot;
</A></li>
        <LI> Next message: <A HREF="024034.html">[Mono-bugs] [Bug 59623][Nor] Changed - Regex.Matches method does not return correct results.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24050">[ date ]</a>
              <a href="thread.html#24050">[ thread ]</a>
              <a href="subject.html#24050">[ subject ]</a>
              <a href="author.html#24050">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please do not reply to this email- if you want to comment on the bug, go to the
URL shown below and enter your comments there.

Changed by <A HREF="mailto:scott@imeem.com.">scott@imeem.com.</A>

<A HREF="http://bugzilla.ximian.com/show_bug.cgi?id=71203">http://bugzilla.ximian.com/show_bug.cgi?id=71203</A>

--- shadow/71203	2005-01-12 11:21:33.000000000 -0500
+++ shadow/71203.tmp.19716	2005-01-12 16:49:41.000000000 -0500
@@ -2,13 +2,13 @@
 Product: Mono: Class Libraries
 Version: 1.1
 OS: Red Hat 9.0
 OS Details: 
 Status: NEW   
 Resolution: 
-Severity: 
+Severity: Unknown
 Priority: Wishlist
 Component: CORLIB
 AssignedTo: <A HREF="mailto:mono-bugs@ximian.com">mono-bugs@ximian.com</A>                            
 ReportedBy: <A HREF="mailto:scott@imeem.com">scott@imeem.com</A>               
 QAContact: <A HREF="mailto:mono-bugs@ximian.com">mono-bugs@ximian.com</A>
 TargetMilestone: ---
@@ -44,6 +44,191 @@
 which provides similar functionality without the limit. Mono should detect at build time whether 
 poll() will be available on the target platform and use it instead of select().
 
 This limit makes it surprisingly hard to write servers which handle thousands of connections (and 
 if you ask any .Net guru they'll chastise you for not using the Async methods - on every mono 
 install I've tried they lock up with &gt; 25 pending operations)
+
+------- Additional Comments From <A HREF="mailto:scott@imeem.com">scott@imeem.com</A>  2005-01-12 16:49 -------
+Here's some code which demonstrates the issue (and some others)
+
+using System;
+using System.Collections;
+using System.Net;
+using System.Net.Sockets;
+using System.Threading;
+
+namespace TestMono
+{
+	/// &lt;summary&gt;
+	/// Summary description for Class1.
+	/// &lt;/summary&gt;
+	class Class1
+	{
+
+		static int portNo = 9999;
+		static bool keepWorking = false;
+		static ArrayList sockList = new ArrayList();
+
+		/// &lt;summary&gt;
+		/// The main entry point for the application.
+		/// &lt;/summary&gt;
+		[STAThread]
+		static void Main(string[] args)
+		{
+			//
+			// TODO: Add code to start application here
+			//
+
+			Thread serverThread = new Thread(new ThreadStart(ServerThread));
+			serverThread.Start();
+			Thread connectThread = new Thread(new ThreadStart(ConnectThread));
+			connectThread.Start();
+
+			SelectThread();
+
+		}
+
+
+		static void ServerThread() 
+		{
+
+			Socket sock = new
+Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);
+			IPEndPoint iep = new IPEndPoint(IPAddress.Any,portNo);
+			sock.Bind(iep);
+			sock.Listen(500);
+			// workphase1 = other thread connects 
+			keepWorking = true;
+			while (keepWorking) 
+			{
+				Socket newSock = sock.Accept();
+				sockList.Add(newSock);
+				//Console.WriteLine(&quot;Server accepting Socket&quot;);
+			}
+			Console.WriteLine(&quot;closing server Socket&quot;);
+			// done test - close them all
+			sock.Close();
+		}
+
+
+		static void ConnectThread() 
+		{
+			for(int i = 0;i&lt;500;i++)
+			{
+				try 
+				{
+					Socket sock = new
+Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);
+					IPEndPoint iep = new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;),portNo);
+					sock.Connect(iep);
+					if(sock.Connected) 
+					{
+						//Console.WriteLine(&quot;Added Socket &quot; + i);
+						sockList.Add(sock);
+					} 
+					else 
+					{
+						Console.WriteLine(&quot;Socket &quot; + i + &quot; did not get connected&quot;);
+					}
+					Thread.Sleep(10);
+				} 
+				catch (Exception e) 
+				{
+					Console.WriteLine(&quot;Socket &quot; + i + &quot; threw exception&quot; +e.ToString());
+				}
+
+			}			
+			keepWorking = false;
+		}
+
+		static void DoSelectTest() 
+		{
+			try 
+			{
+				IList readList = new ArrayList(sockList);
+				//IList writeList = new ArrayList(sockList);
+				//IList errList = new ArrayList(sockList);
+				Socket.Select(readList,null,null,1000000);
+				Console.WriteLine(readList.Count );
+			}
+			catch (Exception e) 
+			{
+				Console.WriteLine(&quot;Exception while performing Select() &quot; +
+e.ToString());
+			}
+		}
+
+		static void DoPollTest() 
+		{
+			// first load up a chunk of data on the wire
+			Console.WriteLine(&quot;Starting Poll test&quot;);
+			foreach (Socket sock in sockList) 
+			{
+				byte[] buffer = new byte[16];
+				sock.Send(buffer);
+			}
+			foreach (Socket sock in sockList) 
+			{
+				try 
+				{
+					if(sock.Poll(0,SelectMode.SelectRead) != true ) 
+					{
+						Console.WriteLine(&quot;Poll.Read returned False on socket &quot; +
+sock.Handle.ToString());
+					}
+				} 
+				catch 
+				{
+					Console.WriteLine(&quot;Poll.Read threw exception on socket &quot; +
+sock.Handle.ToString());
+				}
+				try 
+				{
+					if(sock.Poll(0,SelectMode.SelectWrite) != true ) 
+					{
+						Console.WriteLine(&quot;Poll.Write returned False on socket &quot; +
+sock.Handle.ToString());
+					}
+				} 
+				catch 
+				{
+					Console.WriteLine(&quot;Poll.Write threw exception on socket &quot; +
+sock.Handle.ToString());
+				}
+			}
+			Console.WriteLine(&quot;Poll test finished&quot;);
+		}
+
+		// see if we have a problem when calling select on large numbers of
+sockets
+		static void SelectThread() 
+		{
+			Thread.Sleep(1000);
+			while (keepWorking) 
+			{
+				Console.WriteLine(sockList.Count + &quot; sockets connected&quot;);
+				Thread.Sleep(1000);
+			}
+			Console.WriteLine(sockList.Count + &quot; sockets connected&quot;);
+			Thread.Sleep(1000);
+			keepWorking = false;
+	
+			// now do something with this mass of sockets
+			DoPollTest();
+
+			Console.WriteLine(&quot;Closing Socket List&quot;);
+			foreach(Socket sock in sockList) 
+			{
+				try 
+				{
+					sock.Close();
+				} 
+				catch (Exception e) 
+				{
+					Console.WriteLine(&quot;Exception while closing socket &quot; + e.ToString());
+				}
+			}
+		}
+
+	}
+}

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="024027.html">[Mono-bugs] [Bug 71073][Wis] Changed - unfixable warning cs0067 &quot;event not used&quot;
</A></li>
	<LI> Next message: <A HREF="024034.html">[Mono-bugs] [Bug 59623][Nor] Changed - Regex.Matches method does not return correct results.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24050">[ date ]</a>
              <a href="thread.html#24050">[ thread ]</a>
              <a href="subject.html#24050">[ subject ]</a>
              <a href="author.html#24050">[ author ]</a>
         </LI>
       </UL>
</body></html>
