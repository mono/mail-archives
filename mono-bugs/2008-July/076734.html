<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 409090] New: Setting ScrollableControl.. AutoScrollMinSize does not update Scrollbars
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20409090%5D%20New%3A%20Setting%20ScrollableControl..%0A%20AutoScrollMinSize%20does%20not%20update%20Scrollbars&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="076731.html">
   <LINK REL="Next"  HREF="076739.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 409090] New: Setting ScrollableControl.. AutoScrollMinSize does not update Scrollbars</H1>
    <B>bugzilla_noreply at novell.com</B> 
    <A HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%20409090%5D%20New%3A%20Setting%20ScrollableControl..%0A%20AutoScrollMinSize%20does%20not%20update%20Scrollbars&In-Reply-To="
       TITLE="[Mono-bugs] [Bug 409090] New: Setting ScrollableControl.. AutoScrollMinSize does not update Scrollbars">bugzilla_noreply at novell.com
       </A><BR>
    <I>Mon Jul 14 19:59:57 EDT 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="076731.html">[Mono-bugs] [Bug 399583] TabControl: tab buttons all over the place with FillToRight with Left/Right alignment
</A></li>
        <LI>Next message: <A HREF="076739.html">[Mono-bugs] [Bug 409090] Setting ScrollableControl.. AutoScrollMinSize does not update Scrollbars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#76734">[ date ]</a>
              <a href="thread.html#76734">[ thread ]</a>
              <a href="subject.html#76734">[ subject ]</a>
              <a href="author.html#76734">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE><A HREF="https://bugzilla.novell.com/show_bug.cgi?id=409090">https://bugzilla.novell.com/show_bug.cgi?id=409090</A>


           Summary: Setting ScrollableControl..AutoScrollMinSize does not
                    update Scrollbars
           Product: Mono: Class Libraries
           Version: 1.9.0
          Platform: i386
               URL: <A HREF="http://limada.sourceforge.net/Limaki/">http://limada.sourceforge.net/Limaki/</A>
        OS/Version: Windows XP
            Status: NEW
          Severity: Blocker
          Priority: P5 - None
         Component: Windows.Forms
        AssignedTo: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at lists.ximian.com</A>
        ReportedBy: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">lytico at users.sourceforge.net</A>
         QAContact: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at lists.ximian.com</A>
          Found By: DeveloperNet


If you have an UserControl and set AutoScrollMinSize to a value bigger than the
ClientArea of the Control, the behavior under

- MS-NET is, that the Scrollbars show up automatically, and a
Control.Invalidate(?) is fired;

- Mono is, that nothing happens; neither the Scrollbars get visible nor a
Invalidate(?) is fired. If you resize the whole form in which the control
resides, the Scrollbars show up.

This bug (or: different behavior) is critical because it stops UserControls
depending on AutoScroll to work under Mono.

Example tested on Windows XP with .NET 2.0 (works), Windows XP with mono 1.9
(error)

***** Example Test-Case:


using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Drawing2D;

namespace MonoWinformTests {

    public class TestAutoScrollControl : UserControl {
        private Rectangle rect = Rectangle.Empty;

        protected override void OnPaint(PaintEventArgs e) {
            base.OnPaint(e);
            if (rect != Rectangle.Empty) {
                Graphics g = e.Graphics;

                g.TranslateTransform(this.AutoScrollPosition.X,
this.AutoScrollPosition.Y);

                g.FillRectangle(SystemBrushes.Window, rect);


                string s = &quot;no scrollbar&quot;;
                if (this.VScroll || this.HScroll)
                    s = &quot;scrollbar visible&quot;;
                else if (this.ClientRectangle.Bottom &lt; rect.Bottom ||
this.ClientRectangle.Right &lt; rect.Right) {
                    s += &quot; error&quot;;
                }
                s += &quot;\nS:&quot; + this.AutoScrollMinSize + &quot;\nC:&quot; +
this.ClientRectangle.Size;

                g.DrawString(s, SystemFonts.MenuFont, SystemBrushes.WindowText,
new PointF(10, 10));
            }
        }

        public void Execute(int testCase) {
            Rectangle oldRect = new Rectangle(rect.Location, rect.Size);
            rect.Size = new Size(250, 100);


            switch (testCase) {
                case 1: {
                        // set the rectangle location to the right bottom
corner
                        // scrollbars should be visible
                        rect.Location = new Point(
                            this.Bounds.Right - rect.Size.Width / 2,
                            this.Bounds.Bottom - rect.Size.Height / 2);
                        break;
                    }
                case 2: {
                        // set the rectangle location to the left top corner
                        rect.Location = new Point(5, 5);
                        break;
                    }
            }

            this.AutoScrollMinSize = new Size(rect.Right, rect.Bottom);

            Rectangle invRect = Rectangle.Union(rect, oldRect);
            this.Invalidate(invRect);
        }

        public TestAutoScrollControl() {
            this.AutoScroll = true;
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
        }

    }

    #region Test-Environment
    public class TestForm : Form {
        public TestForm() {
            InitializeComponent();
            autoScrollControl.Execute(2);

        }

        private void button1_Click(object sender, EventArgs e) {
            this.autoScrollControl.Execute(1);
        }

        private void button2_Click(object sender, EventArgs e) {
            this.autoScrollControl.Execute(2);
        }

        protected override void Dispose(bool disposing) {
            if (disposing &amp;&amp; (components != null)) {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        private void InitializeComponent() {
            this.panel1 = new System.Windows.Forms.Panel();
            this.button2 = new System.Windows.Forms.Button();
            this.button1 = new System.Windows.Forms.Button();
            this.autoScrollControl = new
MonoWinformTests.TestAutoScrollControl();
            this.panel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // panel1
            // 
            this.panel1.Controls.Add(this.button2);
            this.panel1.Controls.Add(this.button1);
            this.panel1.Dock = System.Windows.Forms.DockStyle.Left;
            this.panel1.Location = new System.Drawing.Point(0, 0);
            this.panel1.Name = &quot;panel1&quot;;
            this.panel1.Size = new System.Drawing.Size(66, 266);
            this.panel1.TabIndex = 0;
            // 
            // button2
            // 
            this.button2.Dock = System.Windows.Forms.DockStyle.Top;
            this.button2.Location = new System.Drawing.Point(0, 23);
            this.button2.Name = &quot;button2&quot;;
            this.button2.Size = new System.Drawing.Size(66, 23);
            this.button2.TabIndex = 1;
            this.button2.Text = &quot;Near&quot;;
            this.button2.UseVisualStyleBackColor = true;
            this.button2.Click += new System.EventHandler(this.button2_Click);
            // 
            // button1
            // 
            this.button1.Dock = System.Windows.Forms.DockStyle.Top;
            this.button1.Location = new System.Drawing.Point(0, 0);
            this.button1.Name = &quot;button1&quot;;
            this.button1.Size = new System.Drawing.Size(66, 23);
            this.button1.TabIndex = 0;
            this.button1.Text = &quot;Far&quot;;
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // autoScrollControl
            // 
            this.autoScrollControl.AutoScroll = true;
            this.autoScrollControl.Dock = System.Windows.Forms.DockStyle.Fill;
            this.autoScrollControl.Location = new System.Drawing.Point(66, 0);
            this.autoScrollControl.Name = &quot;autoScrollControl&quot;;
            this.autoScrollControl.Size = new System.Drawing.Size(300, 200);
            this.autoScrollControl.TabIndex = 1;
            // 
            // TestEnvironmentForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(400, 200);
            this.Controls.Add(this.autoScrollControl);
            this.Controls.Add(this.panel1);
            this.Name = &quot;TestEnvironmentForm&quot;;
            this.Text = &quot;Test AutoScroll&quot;;
            this.panel1.ResumeLayout(false);
            this.ResumeLayout(false);
        }

        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Button button2;
        private System.Windows.Forms.Button button1;
        private TestAutoScrollControl autoScrollControl;
    }

    static class TestProgram {
        [STAThread]
        static void Main() {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new TestForm());
        }
    }

    #endregion
}

***** End Test-Case

As a side-result, this example shows another (non-critical) bug: if you play
around with resizing the form, you'll see that VScroll and HScroll doesn't give
the right value: they always give back false, with scrollbars visible or not.

cheers,
lytico
on trying to get Limaki.WidgetDisplay to run on mono


-- 
Configure bugmail: <A HREF="https://bugzilla.novell.com/userprefs.cgi?tab=email">https://bugzilla.novell.com/userprefs.cgi?tab=email</A>
------- You are receiving this mail because: -------
You are the QA contact for the bug.
You are the assignee for the bug.
</PRE>

































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="076731.html">[Mono-bugs] [Bug 399583] TabControl: tab buttons all over the place with FillToRight with Left/Right alignment
</A></li>
	<LI>Next message: <A HREF="076739.html">[Mono-bugs] [Bug 409090] Setting ScrollableControl.. AutoScrollMinSize does not update Scrollbars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#76734">[ date ]</a>
              <a href="thread.html#76734">[ thread ]</a>
              <a href="subject.html#76734">[ subject ]</a>
              <a href="author.html#76734">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-bugs">More information about the mono-bugs
mailing list</a><br>
</body></html>
