<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-bugs] [Bug 75263][Nor] New - OdbcDataReader.cs bug in
	GetPrimaryKeys() method
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%2075263%5D%5BNor%5D%20New%20-%20OdbcDataReader.cs%20bug%20in%0A%09GetPrimaryKeys%28%29%20method&In-Reply-To=bug-75263%40chernobyl.ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030428.html">
   <LINK REL="Next"  HREF="030430.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-bugs] [Bug 75263][Nor] New - OdbcDataReader.cs bug in
	GetPrimaryKeys() method</H1>
    <B>bugzilla-daemon at bugzilla.ximian.com</B> 
    <A HREF="mailto:mono-bugs%40lists.ximian.com?Subject=%5BMono-bugs%5D%20%5BBug%2075263%5D%5BNor%5D%20New%20-%20OdbcDataReader.cs%20bug%20in%0A%09GetPrimaryKeys%28%29%20method&In-Reply-To=bug-75263%40chernobyl.ximian.com"
       TITLE="[Mono-bugs] [Bug 75263][Nor] New - OdbcDataReader.cs bug in
	GetPrimaryKeys() method">bugzilla-daemon at bugzilla.ximian.com
       </A><BR>
    <I>Tue Jun 14 12:30:31 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="030428.html">[Mono-bugs] [Bug 75261][Wis] New - [GMCS] a little bit more type
	inference should be performed by gmcs
</A></li>
        <LI>Next message: <A HREF="030430.html">[Mono-bugs] [Bug 75214][Maj] Changed - assembly load failure on
	64bit with bundle
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30429">[ date ]</a>
              <a href="thread.html#30429">[ thread ]</a>
              <a href="subject.html#30429">[ subject ]</a>
              <a href="author.html#30429">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Please do not reply to this email- if you want to comment on the bug, go to the
URL shown below and enter your comments there.

Changed by <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">ndo at rockwellcollins.com.</A>

<A HREF="http://bugzilla.ximian.com/show_bug.cgi?id=75263">http://bugzilla.ximian.com/show_bug.cgi?id=75263</A>

--- shadow/75263	2005-06-14 12:30:31.000000000 -0400
+++ shadow/75263.tmp.4237	2005-06-14 12:30:31.000000000 -0400
@@ -0,0 +1,412 @@
+Bug#: 75263
+Product: Mono: Class Libraries
+Version: 1.0
+OS: 
+OS Details: SuSE 9.2
+Status: NEW   
+Resolution: 
+Severity: 
+Priority: Normal
+Component: Sys.Data
+AssignedTo: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at ximian.com</A>                            
+ReportedBy: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">ndo at rockwellcollins.com</A>               
+QAContact: <A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">mono-bugs at ximian.com</A>
+TargetMilestone: ---
+URL: 
+Cc: 
+Summary: OdbcDataReader.cs bug in GetPrimaryKeys() method
+
+Please fill in this template when reporting a bug, unless you know what 
+you are doing. 
+Description of Problem: 
+ 
+The bug in GetPrimaryKeys() for the following scenario: 
+ 
+1) A database table has a compound primary keys (two db columns make a row 
+unique). 
+2) Exercise Select query where the selected column in the query is not one 
+of the primary key combination. There is only one column is selected in 
+the query. 
+3) The bug in the GetPrimaryKeys() was allocated the returned keys string 
+array based on the number of returned columns in the Select statement up 
+front. In this scenario, the returned column is one, and the number of 
+primary keys in the table is two. The bug is in the while(true) section 
+while retrieving the number of primary fields from backend database. On 
+the second fetch of the second primary key, the keys[] array string crash 
+since it only being allocated one slot at the beginning. 
+4) attached is the diff -u of the OdbcDataReader.cs from tarball 1.1.7 
+with the latest from svn (retrieved about 11am June 13th 05). The fix was 
+not to make an assumption of keys[] string array to be allocated up front 
+based on the returned columns of the Select statement. There is a local 
+ArrayList object being introduced to dynamic add the primary keys fetched 
+from backend database. As the completion of the fetch, then the ArrayList 
+will convert and return an array of string. The signature of method 
+doesn't change. 
+5) here is the diff -u 
+5c5 
+&lt; //   Brian Ritchie (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">brianlritchie at hotmail.com</A>) 
+--- 
+&gt; //   Brian Ritchie (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-bugs">brianlritchie at hotmail.com</A>)  
+23c23 
+&lt; // 
+--- 
+&gt; //  
+26c26 
+&lt; // 
+--- 
+&gt; //  
+92c92 
+&lt;                 private CommandBehavior CommandBehavior 
+--- 
+&gt;                 private CommandBehavior CommandBehavior  
+107c107 
+&lt;                 protected override bool IsValidRow 
+--- 
+&gt;                 protected override bool IsValidRow  
+225,226c225,226 
+&lt; 				OdbcReturn 
+ret=libodbc.SQLDescribeCol(hstmt, Convert.ToUInt16(ordinal+1), 
+&lt; 					colname_buffer, bufsize, ref 
+colname_size, ref dt, ref ColSize, 
+--- 
+&gt; 				OdbcReturn 
+ret=libodbc.SQLDescribeCol(hstmt, Convert.ToUInt16(ordinal+1),  
+&gt; 					colname_buffer, bufsize, ref 
+colname_size, ref dt, ref ColSize,  
+228c228 
+&lt; 				if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo)) 
+--- 
+&gt; 				if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo))  
+250c250 
+&lt; 			if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo)) 
+--- 
+&gt; 			if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo))  
+256,257c256,257 
+&lt; 			ret = libodbc.SQLFreeHandle( (ushort) 
+OdbcHandleType.Stmt, hstmt); 
+&lt; 			if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo)) 
+--- 
+&gt; 			ret = libodbc.SQLFreeHandle( (ushort) 
+OdbcHandleType.Stmt, hstmt); 
+&gt; 			if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo))  
+270c270 
+&lt; 		public 
+--- 
+&gt; 		public  
+279c279 
+&lt; 		public 
+--- 
+&gt; 		public  
+288c288 
+&lt; 		public 
+--- 
+&gt; 		public  
+300c300 
+&lt;                         ret=libodbc.SQLGetData (hstmt, (ushort) 
+(ordinal+1), SQL_C_TYPE.BINARY, tbuff, length, 
+--- 
+&gt;                         ret=libodbc.SQLGetData (hstmt, (ushort) 
+(ordinal+1), SQL_C_TYPE.BINARY, tbuff, length,  
+306c306 
+&lt;                         if ( (ret != OdbcReturn.Success) &amp;&amp; (ret != 
+OdbcReturn.SuccessWithInfo)) 
+--- 
+&gt;                         if ( (ret != OdbcReturn.Success) &amp;&amp; (ret != 
+OdbcReturn.SuccessWithInfo))  
+325c325 
+&lt;                                         if (sqlstate != 
+libodbc.SQLSTATE_RIGHT_TRUNC) 
+--- 
+&gt;                                         if (sqlstate != 
+libodbc.SQLSTATE_RIGHT_TRUNC)  
+346c346 
+&lt; 		public 
+--- 
+&gt; 		public  
+356c356 
+&lt; 		public 
+--- 
+&gt; 		public  
+367c367 
+&lt; 		public 
+--- 
+&gt; 		public  
+376c376 
+&lt; 		public 
+--- 
+&gt; 		public  
+389c389 
+&lt; 		public 
+--- 
+&gt; 		public  
+399c399 
+&lt; 		public 
+--- 
+&gt; 		public  
+408c408 
+&lt; 		public 
+--- 
+&gt; 		public  
+417c417 
+&lt; 		public 
+--- 
+&gt; 		public  
+426c426 
+&lt; 		public 
+--- 
+&gt; 		public  
+436c436 
+&lt; 		public 
+--- 
+&gt; 		public  
+445c445 
+&lt; 		public 
+--- 
+&gt; 		public  
+454c454 
+&lt; 		public 
+--- 
+&gt; 		public  
+463c463 
+&lt; 		public 
+--- 
+&gt; 		public  
+472c472 
+&lt; 		public 
+--- 
+&gt; 		public  
+481c481 
+&lt; 		public 
+--- 
+&gt; 		public  
+500c500 
+&lt;                 DataTable GetSchemaTable() 
+--- 
+&gt;                 DataTable GetSchemaTable()  
+502c502 
+&lt;                         // FIXME : 
+--- 
+&gt;                         // FIXME :  
+506c506 
+&lt;                         // * Cache this DataTable so that it is not 
+contacting 
+--- 
+&gt;                         // * Cache this DataTable so that it is not 
+contacting  
+510c510 
+&lt; 			// Only Results from SQL SELECT Queries 
+--- 
+&gt; 			// Only Results from SQL SELECT Queries  
+513c513 
+&lt; 			if(cols.Length &gt; 0) 
+--- 
+&gt; 			if(cols.Length &gt; 0)  
+546c546 
+&lt; 				for (int i = 0; i &lt; cols.Length; i += 1 ) 
+--- 
+&gt; 				for (int i = 0; i &lt; cols.Length; i += 1 )  
+599c599 
+&lt; 					// FIXME: according to Brian, 
+--- 
+&gt; 					// FIXME: according to Brian,  
+601c601 
+&lt; 					// however, we need it for Mono 
+--- 
+&gt; 					// however, we need it for Mono  
+611c611 
+&lt; 		public 
+--- 
+&gt; 		public  
+626c626 
+&lt; 		public 
+--- 
+&gt; 		public  
+651a652 
+&gt; 					case OdbcType.Numeric: 
+654,655c655 
+&lt; 						buffer=new 
+byte[bufsize];  // According to sqlext.h, use SQL_CHAR for decima. 
+&lt;                                                 // 2005 03 10 : this now 
+works with unixodbc with numeric c type. 
+--- 
+&gt; 						buffer=new 
+byte[bufsize];  // According to sqlext.h, use SQL_CHAR for decimal.  
+657,661c657,660 
+&lt; 						byte[] temp = new 
+byte[outsize]; 
+&lt;                                                 for (int 
+i=0;i&lt;outsize;i++) 
+&lt;                                                         
+temp[i]=buffer[i]; 
+&lt;  
+&lt; 						if (outsize!=-1) 
+--- 
+&gt; 						if (outsize!=-1) { 
+&gt; 							byte[] temp = new 
+byte[outsize]; 
+&gt; 							for (int 
+i=0;i&lt;outsize;i++) 
+&gt; 								
+temp[i]=buffer[i]; 
+662a662 
+&gt; 						} 
+716c716 
+&lt;                                                 if (outsize!=-1) // This 
+means SQL_NULL_DATA 
+--- 
+&gt;                                                 if (outsize!=-1) // This 
+means SQL_NULL_DATA  
+739c739 
+&lt; 				if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo)) 
+--- 
+&gt; 				if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo))  
+742c742 
+&lt; 				if (outsize==-1) // This means 
+SQL_NULL_DATA 
+--- 
+&gt; 				if (outsize==-1) // This means 
+SQL_NULL_DATA  
+750c750 
+&lt; 		public 
+--- 
+&gt; 		public  
+823c823 
+&lt; 			} 
+--- 
+&gt; 			}	 
+854,855c854,855 
+&lt;                         ret = libodbc.SQLColAttribute (hstmt, column, 
+fieldId, 
+&lt;                                                        buffer, 
+buffer.Length, 
+--- 
+&gt;                         ret = libodbc.SQLColAttribute (hstmt, column, 
+fieldId,  
+&gt;                                                        buffer, 
+buffer.Length,  
+872,873c872,873 
+&lt;                         ret = libodbc.SQLColAttribute (hstmt, column, 
+fieldId, 
+&lt;                                                        buffer, 
+buffer.Length, 
+--- 
+&gt;                         ret = libodbc.SQLColAttribute (hstmt, column, 
+fieldId,  
+&gt;                                                        buffer, 
+buffer.Length,  
+891,892c891 
+&lt;                         //string [] keys = new string [cols.Length]; 
+&lt; 						string [] keys = null; 
+--- 
+&gt;                         string [] keys = new string [cols.Length]; 
+894c893 
+&lt;                         OdbcReturn ret = OdbcReturn.Error; 
+--- 
+&gt;                         OdbcReturn ret = OdbcReturn.Error;                   
+896c895 
+&lt;                                 
+ret=libodbc.SQLAllocHandle(OdbcHandleType.Stmt, 
+--- 
+&gt;                                 
+ret=libodbc.SQLAllocHandle(OdbcHandleType.Stmt,  
+898c897 
+&lt; 				if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo)) 
+--- 
+&gt; 				if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo))  
+906,907c905,906 
+&lt;                                 ret = libodbc.SQLPrimaryKeys (handle, 
+catalogName, -3, 
+&lt;                                                               
+schemaName, -3, 
+--- 
+&gt;                                 ret = libodbc.SQLPrimaryKeys (handle, 
+catalogName, -3,   
+&gt;                                                               
+schemaName, -3,  
+919,922c918,919 
+&lt;                                 //int i = 0; 
+&lt; 								ArrayList 
+keysList = new ArrayList(); 
+&lt; 						 
+&lt; 								while 
+(true) { 
+--- 
+&gt;                                 int i = 0;                               
+&gt;                                 while (true) { 
+927,937c924,926 
+&lt;                                          
+&lt; 
+										//keys 
+[i++] = pkey; 
+&lt; 										
+keysList.Add(pkey); 
+&lt; 								} 
+&lt; 								 
+&lt; 								
+if(keysList.Count &gt; 0) { 
+&lt; 									
+keys = new string[keysList.Count]; 
+&lt; 									
+keysList.CopyTo(keys); 
+&lt; 								} 
+&lt; 						 
+&lt; 						} catch (OdbcException){ 
+--- 
+&gt;                                         keys [i++] = pkey; 
+&gt;                                 } 
+&gt;                         } catch (OdbcException){ 
+940,941d928 
+&lt; 								if(keys == 
+null) keys = new string[0]; 
+&lt; 						 
+944c931 
+&lt;                                         if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo)) 
+--- 
+&gt;                                         if ((ret!=OdbcReturn.Success) &amp;&amp; 
+(ret!=OdbcReturn.SuccessWithInfo))  
+948c935 
+&lt;                                                 if 
+((ret!=OdbcReturn.Success) &amp;&amp; (ret!=OdbcReturn.SuccessWithInfo)) 
+--- 
+&gt;                                                 if 
+((ret!=OdbcReturn.Success) &amp;&amp; (ret!=OdbcReturn.SuccessWithInfo))  
+950c937 
+&lt;                                 } 
+--- 
+&gt;                                 }                              
+ 
+ 
+ 
+ 
+ 
+Steps to reproduce the problem: 
+1. A database table has a compound primary keys (in this case, two 
+database columns make a row unique). 
+2. Create an OdbcConnection, OdbcCommand and OdbcDataReader using UnixODBC 
+and MySQL-ODBC bridge to access MySQL database. Prepare a select statement 
+with returned column is not one of the primary key combination. There is 
+only column field retrieve in Select statement. 
+3. Execute OdbcDataReader(). 
+ 
+Actual Results: 
+keys[i++]=pkey on the second fetch causes keys[i++] overwrite memory since 
+keys[] is only being allocated one at beginning of the method. 
+ 
+Expected Results: 
+ 
+ 
+How often does this happen? 
+ 
+ 
+Additional Information:
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030428.html">[Mono-bugs] [Bug 75261][Wis] New - [GMCS] a little bit more type
	inference should be performed by gmcs
</A></li>
	<LI>Next message: <A HREF="030430.html">[Mono-bugs] [Bug 75214][Maj] Changed - assembly load failure on
	64bit with bundle
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30429">[ date ]</a>
              <a href="thread.html#30429">[ thread ]</a>
              <a href="subject.html#30429">[ subject ]</a>
              <a href="author.html#30429">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-bugs">More information about the mono-bugs
mailing list</a><br>
</body></html>
