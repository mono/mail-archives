<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [android-devel] Runtime crashes on Android
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:android-devel%40lists.dot.net?Subject=Re%3A%20%5Bandroid-devel%5D%20Runtime%20crashes%20on%20Android&In-Reply-To=%3C9C3BC47C-C7DA-4EAF-B7FC-F1988F0F7135%40microsoft.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=utf-8">
   <LINK REL="Previous"  HREF="000027.html">
   <LINK REL="Next"  HREF="000029.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[android-devel] Runtime crashes on Android</H1>
    <B>Bernhard Urban</B> 
    <A HREF="mailto:android-devel%40lists.dot.net?Subject=Re%3A%20%5Bandroid-devel%5D%20Runtime%20crashes%20on%20Android&In-Reply-To=%3C9C3BC47C-C7DA-4EAF-B7FC-F1988F0F7135%40microsoft.com%3E"
       TITLE="[android-devel] Runtime crashes on Android">beurba at microsoft.com
       </A><BR>
    <I>Tue Dec 13 17:52:10 UTC 2016</I>
    <P><UL>
        <LI>Previous message (by thread): <A HREF="000027.html">[android-devel] Runtime crashes on Android
</A></li>
        <LI>Next message (by thread): <A HREF="000029.html">[android-devel] Runtime crashes on Android
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28">[ date ]</a>
              <a href="thread.html#28">[ thread ]</a>
              <a href="subject.html#28">[ subject ]</a>
              <a href="author.html#28">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Reply inline -&gt;

On Dec 13, 2016, at 6:37 PM, Jonathan Pryor &lt;<A HREF="http://lists.dot.net/mailman/listinfo/android-devel">jonpryor at vt.edu</A>&lt;mailto:<A HREF="http://lists.dot.net/mailman/listinfo/android-devel">jonpryor at vt.edu</A>&gt;&gt; wrote:

Let me go back one step. In general the signal chain looks like this on Android:

(1) SIGSEGV happens, the ART handler catches it and does some stuff (e.g. &quot;is it caused by my managed code&quot;?).
(2) if ART doesn't know what to do, it will chain into remaining handlers.
(3) now it's the mono runtimes handler turn, we do our business, figure out it's a native crash, etc.
(4) (in case we do *NOT* crash) we return to the ART handler
(5) the ART handler now chains into the next SIGSEGV handler, which was setup by the linker of bionic.
(6) the libc/bionic handler communicates with debuggerd which ptraces our process and delivers further information (e.g. register dump, native stack trace)
...
Looking at this, I have this conclusion: How about we do not even attempt to do a native stack trace in mono, but just let debuggerd do its business?

What do we want? The managed callstack. Yes, a SIGSEGV happened in native code, but mono is the only one that can produce a *managed* callstack leading up to the SIGSEGV, and Android certainly isn’t going to print out the managed stack frames…

Of course we still have to print the managed stack trace ourselves.


My recollection is that we *don’t* reliably print the managed stack trace during native SIGSEGV. (Am I wrong?)

Yes. There was an issue with exceeding the altstack limit: This was especially a problem on ARM32 because we used a pretty large struct in our unwinding code. It’s fixed by this PR: <A HREF="https://github.com/mono/mono/pull/4106">https://github.com/mono/mono/pull/4106</A>

However, this is only a workaround.  Zoltan is experimenting with something similar what we are doing for exception handling already: get out of the signal handler via overriding the PC in the sigctx structure and then do the heavy lifting later (that is, on a normal stack).



So long as the managed callstack is *reliably* dumped, I don’t really care what code prints the native callstack, just that we get reliable managed and native callstacks *somewhere*, preferably in some form that will make it back to Google and developers…

However, that raises an added wrinkle: IIRC, debuggerd only attaches and dumps the stack traces for *debuggable* applications (`AndroidManifest.xml` has `//application/@android:debuggable=‘true’`). This *is not true* for Release apps, meaning we might not be able to rely on debuggerd to provide native stack traces in Release apps.

Is that a problem? (Maybe?) Are native stack dumps when Release crashes something desirable? (I’d think so…?)


That’s indeed correct, and setting it in the manifest for release builds isn’t something you should do due to security reasons. Hence this PR: <A HREF="https://github.com/mono/mono/pull/4131">https://github.com/mono/mono/pull/4131</A>


-Bernhard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://lists.dot.net/pipermail/android-devel/attachments/20161213/1f12d2a8/attachment-0001.html">http://lists.dot.net/pipermail/android-devel/attachments/20161213/1f12d2a8/attachment-0001.html</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message (by thread): <A HREF="000027.html">[android-devel] Runtime crashes on Android
</A></li>
	<LI>Next message (by thread): <A HREF="000029.html">[android-devel] Runtime crashes on Android
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28">[ date ]</a>
              <a href="thread.html#28">[ thread ]</a>
              <a href="subject.html#28">[ subject ]</a>
              <a href="author.html#28">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.dot.net/mailman/listinfo/android-devel">More information about the android-devel
mailing list</a><br>
</body></html>
