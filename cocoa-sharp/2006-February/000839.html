<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Cocoa-sharp] Mach thread and AppKit exit behavior revealed
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Mach%20thread%20and%20AppKit%20exit%20behavior%20revealed&In-Reply-To=A007B9C8-4458-4596-BF2E-EED697683C76%40sublimeintervention.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000830.html">
   <LINK REL="Next"  HREF="000831.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cocoa-sharp] Mach thread and AppKit exit behavior revealed</H1>
    <B>Andreas F&#228;rber</B> 
    <A HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Mach%20thread%20and%20AppKit%20exit%20behavior%20revealed&In-Reply-To=A007B9C8-4458-4596-BF2E-EED697683C76%40sublimeintervention.com"
       TITLE="[Cocoa-sharp] Mach thread and AppKit exit behavior revealed">andreas.faerber at web.de
       </A><BR>
    <I>Wed Feb  8 20:23:28 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000830.html">[Cocoa-sharp] Mach thread and AppKit exit behavior revealed
</A></li>
        <LI>Next message: <A HREF="000831.html">[Cocoa-sharp] Mach exception handling issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#839">[ date ]</a>
              <a href="thread.html#839">[ thread ]</a>
              <a href="subject.html#839">[ subject ]</a>
              <a href="author.html#839">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>kangaroo schrieb:
&gt;&gt;<i> Recent I reported some Mach exception handling issues, especially
</I>&gt;&gt;<i> that the thread is never stopped in command line applications
</I>&gt;&gt;<i> (including NUnit tests). Having managed to get my application running
</I>&gt;&gt;<i> on my new implementation (without the previously observed failures
</I>&gt;&gt;<i> with gmcs), I have now found out why a Cocoa# AppKit application
</I>&gt;&gt;<i> exits nontheless, and it is quite disturbing...:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> By calling [[NSApplication sharedApplication] run]
</I>&gt;&gt;<i> (Application.Run()) we are passing control out to unmanaged code
</I>&gt;&gt;<i> which through the bridge calls back into our managed code. However
</I>&gt;&gt;<i> when the application is quit, control is not tranferred back to our
</I>&gt;&gt;<i> managed Main function that called it!
</I>&gt;&gt;<i> Instead native Cocoa is calling the C exit() function (or equivalent)
</I>&gt;&gt;<i> on its own, causing Mono to be &quot;killed&quot; without any garbage
</I>&gt;&gt;<i> collection!!!
</I>&gt;&gt;<i> This is bad.
</I>&gt;<i>
</I>&gt;<i> Why is this bad per se?  Garbage collection and finalizers are not
</I>&gt;<i> guaranteed to be run by the C# spec.
</I>Well, I tested it. If Mono exits normally, finalizers are indeed called,
same for .NET. Especially they will be called if you force a GC run and
wait for pending finalizers.
I believe strongly that this can be expected from any managed runtime
because that's what finalizers are for - cleaning up unmanaged resources
at some point. If you cannot rely on them being called there is no point
in writing them; you are using finalizers yourself in Cocoa#! Given your
argumentation you would not have needed to do so because they will never
be called in the existing implementation as they are always referenced
within a Hashtable.

If in managed code you write a try finally block around NSApplication's
run then you actually expect the finally block to be called at some
point - if the runtime is killed by Cocoa this will never happen. I have
tried to work around this problem, and it is simply not possible to call
Dispose everywhere yourself. Code gets ugly very quickly, even if I
derived ObjectiveCObject from Component and use Containers to dispose
objects. I can live with a string-argument function that needs a using
block internally to dispose a locally generated Cocoa.String but it is
not feasible to track and dispose every single object - that's where
finalizers usually come in. And doing a GC run in
applicationWillTerminate does not help as the objects will still be
referenced in managed classes and will therefore not be GC'ed.

So what I've done is to ask on cocoa-dev what NSApplication's terminate:
is actually doing (I have no idea how to debug this myself and there are
probably licensing issues as this could be conceived as
reverse-engineering by Apple); no definite reply there, but I ended up
exiting the run loop via applicationShouldTerminate and stop(?) and
closing the windows afterwards. This works in general but still results
in some _NSAutoreleaseWithoutPool(?) complaints after the Main method
has returned when my finalizers are run, I guess I need to track down
and release some more objects when my AutoreleasePool object is not yet
finalized, the NSApplication itself and possibly the bundle will be my
first candidates for this. While this is a little hacky with no official
way to get this behavior from Apple, it is much cleaner on the managed
side. I was thinking about writing a wrapper class that allows releasing
any unmanaged NSObject* (possibly similar to SRI's UnknownWrapper that
appears to wrap an IUnknown*, haven't looked at it yet though) to get
rid of this issue.

Andreas
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000830.html">[Cocoa-sharp] Mach thread and AppKit exit behavior revealed
</A></li>
	<LI>Next message: <A HREF="000831.html">[Cocoa-sharp] Mach exception handling issues
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#839">[ date ]</a>
              <a href="thread.html#839">[ thread ]</a>
              <a href="subject.html#839">[ subject ]</a>
              <a href="author.html#839">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/cocoa-sharp">More information about the Cocoa-sharp
mailing list</a><br>
</body></html>
