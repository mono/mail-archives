<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Cocoa-sharp] Future - Memory Management
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Future%20-%20Memory%20Management&In-Reply-To=B4ADC5E4-C5B6-45F8-80E5-A2C29CEC4326%40mac.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000868.html">
   <LINK REL="Next"  HREF="000870.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cocoa-sharp] Future - Memory Management</H1>
    <B>James B. Tuley</B> 
    <A HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Future%20-%20Memory%20Management&In-Reply-To=B4ADC5E4-C5B6-45F8-80E5-A2C29CEC4326%40mac.com"
       TITLE="[Cocoa-sharp] Future - Memory Management">jbtule at mac.com
       </A><BR>
    <I>Sun Feb 26 18:35:46 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000868.html">[Cocoa-sharp] Re:Future
</A></li>
        <LI>Next message: <A HREF="000870.html">[Cocoa-sharp] Future - Memory Management
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#869">[ date ]</a>
              <a href="thread.html#869">[ thread ]</a>
              <a href="subject.html#869">[ subject ]</a>
              <a href="author.html#869">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> This work isn't 100% there yet but it does compile without the need
</I>&gt;<i> for unsafe now and the other hideous mono specific hacks I had in  
</I>&gt;<i> place;
</I>
So looking at this future diff and the non patched svn trunk neither  
seem to deal with memory management.

such as if in a method I did something simple like this:


public void Test(){
	MutableArray tArray = new MutableArray()

	tArray.Add(new Image (&quot;test.img&quot;)
}


Neither would the wrapper objects get garbage collected nor the  
native objects get deallocated, because the wrapper objects would be  
stuck in a static hashtable that is trying to cache wrappers per  
native objects, and the native objects would always have a retain  
count of at least 1.

It seems to me that how native objects are created from c# is fine,  
and when any native object is wrapped it needs to receive a retain  
message, and when any wrapper object is garbage collected it should  
send that native object a release message and there shouldn't be any   
long term caching of the wrappers.


namespace Cocoa {

	public class Object : ID
	{
		public Object () {
			native_class = ToObjCClass ();
			NativeObject = (IntPtr) ObjCMessaging.objc_msgSend (native_class,  
&quot;alloc&quot;, typeof (IntPtr));
		}

		public Object (IntPtr native_object) {
			NativeObject = native_object;
			Retain();
		}

		~ Object () {
			Release();
		}

		protected void Retain () {
			ObjCMessaging.objc_msgSend (this, &quot;retain&quot;, typeof (void));
		}
		
		protected void Release () {
			ObjCMessaging.objc_msgSend (this, &quot;release&quot;, typeof (void));
		}

		public IntPtr NativeObject {
			get
			{
				return objc_object;
			}
			set
			{
				if (value == IntPtr.Zero)
					throw new InvalidOperationException (&quot;A native object cannot be  
null&quot;);
				objc_object = value;
			}
		}

		public static Object FromIntPtr (IntPtr from) {
			Type type = ObjCClass.TypeForIntPtr (from);
			
			if (type == typeof (void))
				return null;

			return (Object) Activator.CreateInstance (type, new object []  
{from});
		}


	}
}

That way there won't be objects lingering around forever, and they  
shouldn't disappear from either the C# or Obj-C while either of the  
runtimes are using them.  To anyone implementing from Cocoa#  
everything they write will work as if it's being garbage collected.  
There may end up being multiple wrapper instances for the same native  
object, but the reference counting should keep the garbage collection  
of the native object in sync and the wrappers all seem to be strictly  
method implementations anyway without any extract instance variables.

-Jay
<A HREF="http://indyjt.com">http://indyjt.com</A>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 3601 bytes
Desc: not available
Url : <A HREF="http://lists.ximian.com/pipermail/cocoa-sharp/attachments/20060226/92ced80f/smime.bin">http://lists.ximian.com/pipermail/cocoa-sharp/attachments/20060226/92ced80f/smime.bin</A>
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000868.html">[Cocoa-sharp] Re:Future
</A></li>
	<LI>Next message: <A HREF="000870.html">[Cocoa-sharp] Future - Memory Management
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#869">[ date ]</a>
              <a href="thread.html#869">[ thread ]</a>
              <a href="subject.html#869">[ subject ]</a>
              <a href="author.html#869">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/cocoa-sharp">More information about the Cocoa-sharp
mailing list</a><br>
</body></html>
