<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Cocoa-sharp] binding/glue problem with overwriting methods and calling super
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:umuff%40QUARK.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000090.html">
   <LINK REL="Next"  HREF="000084.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cocoa-sharp] binding/glue problem with overwriting methods and calling super
   </H1>
    <B>Urs Muff
    </B> 
    <A HREF="mailto:umuff%40QUARK.com"
       TITLE="[Cocoa-sharp] binding/glue problem with overwriting methods and calling super">umuff@QUARK.com
       </A><BR>
    <I>Tue, 15 Jun 2004 21:11:00 -0600</I>
    <P><UL>
        <LI> Previous message: <A HREF="000090.html">[Cocoa-sharp] Compiler support for MacOS.
</A></li>
        <LI> Next message: <A HREF="000084.html">[Cocoa-sharp] binding/glue problem with overwriting methods and calling super
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#83">[ date ]</a>
              <a href="thread.html#83">[ thread ]</a>
              <a href="subject.html#83">[ subject ]</a>
              <a href="author.html#83">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C4534F.8C231E10
Content-Type: text/plain

Ok the problem is the following:

To make it possible to have the objective-c runtime calling back into .Net
we did the following:
-	We generate a class on the fly that is named like the .Net class and
derived from the class named as parent class in .Net
-	We have an instance variable called mDelegate which can be set with
the @selector(initWithDelegate:) message
-	That delegate can be used to call back into the manage runtime from
unmanaged code, allowing to implement the two other messages each
dynamically created class implements
(@selector(methodSignatureFromSelector:), and @selector(forwardInvocation:))
-	To know how it is possible to handle objective-c messages you need
to understand low-level detail: the core message dispatcher will try
dispatching a message to it's given base, but if that base does not respond
to the given selector, it will send @selector(methodSignatureFromSelector:)
which will return the method signature including exact argument and return
type and size information to create an NSInvocation object that then will be
passed to @selector(forwardInvocation:) message.  If the former message
returns nil, the message is consider not implemented and an
doesNotRespondToSelector exception is thrown.
-	This implementation has been proven successful in the POC, but
reflecting deeper about what other cases are possible I found two problem
with this approach:  First, it does not allow overwriting an existing
message of a parent class, since that message will be found and the
@selector(forwardInvocation:) message will never be sent, since the original
message succeeded, ending up in the parents implementation rather then the
.Net implementation.  (This is very obvious when looking at some very common
initialization code

- (void) init {
	self = [super init];
	mMember = [[NSWhatEver alloc] init];
}

-	There are two problem with this code when translating into .Net
o	First if we call base.init() we will end up calling ourselves again
since base.init() is implemented by sending @selector(init) to this (the raw
objc pointer), which of course should end up calling our init function and
not the 'super's' init, since you need a special message dispatch to be able
to send a message to it's super.  (there is objc_msgSend, and
objc_superMsgSend).
o	The second problem is that if another piece of objective-c code
calls [[MyClass alloc] init] I would expects as implementer that my .Net
gets called, but since the above described problem the MyClass's parent's
init message is called. 

The solution to this problem might be the following:
	Making use of the knowledge gained by the above described exercise
done I came up with an alternative approach:

-	When dynamically creating the class we also add methods for each
.Net method that is implemented in the class to be registered.  When adding
a method dynamically we have to implement that method with C-style varargs
that are not supported by .Net's pinvoke engine.  That would either mean
that we would have to parse the method signature and process the varargs
like printf of the C standard library does, which could be very painful.
However I had a better idea.  There is a 'objc_msgSendV' that allows to send
message with a va_list, making it possible to forward the stack.  The idea
now is the following:
o	The caller send the message @selector(init) to the dynamically
created class MyClass, which is handled by the generic C handler function
'glue_detectAndForwardMessage'
o	That function looks at the given selector and if the selector is one
of it's registered selectors it prefixes that selector with something like
%dotNet% making it @selector(%dotNet%init) and forwarding the message using
objc_msgSendV.  This selector is not implemented and therefore the above
described @selector(methodSignatureForSelector) is called and we can handle
@selector(init) by removing the prefix.
o	With the same trick we can also handle super calls, since we just
change the selector to something like @selector(%super%init), in which case
we forward the call to objc_superMsgSendV (which I hope does exist :-)).

I hope this was not too low level, but your input is appreciated!

- Urs

------_=_NextPart_001_01C4534F.8C231E10
Content-Type: text/html
Content-Transfer-Encoding: quoted-printable

&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2//EN&quot;&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV=3D&quot;Content-Type&quot; CONTENT=3D&quot;text/html; =
charset=3Dus-ascii&quot;&gt;
&lt;META NAME=3D&quot;Generator&quot; CONTENT=3D&quot;MS Exchange Server version =
5.5.2657.73&quot;&gt;
&lt;TITLE&gt;binding/glue problem with overwriting methods and calling =
super&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;

&lt;P ALIGN=3DLEFT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;Ok the problem is the =
following:&lt;/FONT&gt;&lt;/P&gt;

&lt;P ALIGN=3DLEFT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;To make it possible to =
have the objective-c runtime calling back into .Net we did the =
following:&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;We generate a class on the fly that is named =
like the .Net class and derived from the class named as parent class in =
.Net&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;We have an instance variable called mDelegate =
which can be set with the @selector(initWithDelegate:) message&lt;/FONT&gt;
&lt;BR&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;That delegate can be used to call back into the =
manage runtime from unmanaged code, allowing to implement the two other =
messages each dynamically created class implements =
(@selector(methodSignatureFromSelector:), and =
@selector(forwardInvocation:))&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;To know how it is possible to handle =
objective-c messages you need to understand low-level detail: the core =
message dispatcher will try dispatching a message to it's given base, =
but if that base does not respond to the given selector, it will send =
@selector(methodSignatureFromSelector:) which will return the method =
signature including exact argument and return type and size information =
to create an NSInvocation object that then will be passed to =
@selector(forwardInvocation:) message.&amp;nbsp; If the former message =
returns nil, the message is consider not implemented and an =
doesNotRespondToSelector exception is thrown.&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;This implementation has been proven successful =
in the POC, but reflecting deeper about what other cases are possible I =
found two problem with this approach:&amp;nbsp; First, it does not allow =
overwriting an existing message of a parent class, since that message =
will be found and the @selector(forwardInvocation:) message will never =
be sent, since the original message succeeded, ending up in the parents =
implementation rather then the .Net implementation.&amp;nbsp; (This is very =
obvious when looking at some very common initialization code&lt;/FONT&gt;&lt;/P&gt;

&lt;P ALIGN=3DLEFT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;- (void) init =
{&lt;/FONT&gt;&lt;/P&gt;

&lt;P ALIGN=3DLEFT&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;self =3D [super init];&lt;/FONT&gt;&lt;/P&gt;

&lt;P ALIGN=3DLEFT&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;mMember =3D&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;[&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;[NS&lt;/FONT&gt;&lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;WhatEver alloc] init]&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;;&lt;/FONT&gt;&lt;/P&gt;

&lt;P ALIGN=3DLEFT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;}&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;There are two problem with this&lt;/FONT&gt;&lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt; code when translating into .Net&lt;/FONT&gt;
&lt;BR&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Courier =
New&quot;&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;First if we call base.init() we will end up calling =
ourselves again since base.init() is implemented by sending =
@selector(init) to&lt;/FONT&gt; &lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;this (the raw =
objc pointer)&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;, which of course =
should end up calling our init function and not the&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;super&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;s&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt; init, since you =
need a special message dispatch to be able to send a message to =
it&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;s super.&amp;nbsp; (there is objc_msgSend, and =
objc_superMsgSend).&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Courier =
New&quot;&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;The second problem is that&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;if another piece of objective-c code calls [[MyClass =
alloc] init]&lt;/FONT&gt; &lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;I would&lt;/FONT&gt;&lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt; ex&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;p&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;ects&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;as implementer&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;that&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt; my .Net gets =
called&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;, but since the above =
described problem the MyClass&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;s =
parent&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;s init message is called.&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;&lt;/FONT&gt; &lt;/P&gt;

&lt;P ALIGN=3DLEFT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;The solution to this =
problem might be the following:&lt;/FONT&gt;&lt;/P&gt;

&lt;P ALIGN=3DLEFT&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;Making use of the&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;knowledge&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt; gained by =
the above&lt;/FONT&gt; &lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;described&lt;/FONT&gt;&lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;exercise&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;&lt;/FONT&gt; =
&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;done I came up with an alternative =
approach:&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;-&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;When dynamically creating the class =
we&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt; also add methods for each .Net =
method that is implemented in the class to be registered.&amp;nbsp; When =
adding a method dynamically we have to implement that method with =
C-style varargs that are not supported by .Net&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;s pinvoke =
engine.&amp;nbsp; That would either mean that we would have to parse the =
method signature and process the varargs like printf of the C standard =
library does, which could be very painful.&lt;/FONT&gt;&amp;nbsp;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt; However I had a better idea.&amp;nbsp; There is a&lt;/FONT&gt; =
&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;objc_msgSendV&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt; that allows to =
send message with a va_list, making it possible to forward the =
stack&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;.&amp;nbsp; The idea now is the =
following:&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Courier =
New&quot;&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;The caller send the message @selector(init) to the =
dynamically created class MyClass&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;, =
which is handled by the generic C handler function&lt;/FONT&gt; &lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;glue_detectAndForwardMessage&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Courier =
New&quot;&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;That function looks at the given selector and if the =
selector is one of it&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;'&lt;/FONT&gt;&lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;s registered selectors it prefixes that =
selector with something like&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;%dotNet% making it @selector(%dotNet%init) and =
forwarding the message using objc_msgSendV.&amp;nbsp; This selector is not =
implemented and therefore the above described&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;@selector(methodSignatureForSelector) is =
called&lt;/FONT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt; and we can handle =
@selector(init) by removing the prefix&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;.&lt;/FONT&gt;&lt;/P&gt;

&lt;P&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Courier New&quot;&gt;o&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;n=
bsp;&lt;/FONT&gt; &lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;With the same trick we can =
also handle super calls, since we just change the selector to =
something&lt;/FONT&gt; &lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;like&lt;/FONT&gt;&lt;FONT =
SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;@selector(%super%init), in which case we forward the =
call to objc_superMsgSendV (which I hope does exist&lt;/FONT&gt; &lt;FONT =
FACE=3D&quot;Wingdings&quot; SIZE=3D2&gt;J&lt;/FONT&gt;&lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;).&lt;/FONT&gt;&lt;/P&gt;

&lt;P ALIGN=3DLEFT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;I hope this was not too =
low level, but your input is&lt;/FONT&gt; &lt;FONT SIZE=3D2 =
FACE=3D&quot;Arial&quot;&gt;appreciated!&lt;/FONT&gt;&lt;/P&gt;

&lt;P ALIGN=3DLEFT&gt;&lt;FONT SIZE=3D2 FACE=3D&quot;Arial&quot;&gt;- Urs&lt;/FONT&gt;&lt;/P&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
------_=_NextPart_001_01C4534F.8C231E10--

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000090.html">[Cocoa-sharp] Compiler support for MacOS.
</A></li>
	<LI> Next message: <A HREF="000084.html">[Cocoa-sharp] binding/glue problem with overwriting methods and calling super
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#83">[ date ]</a>
              <a href="thread.html#83">[ thread ]</a>
              <a href="subject.html#83">[ subject ]</a>
              <a href="author.html#83">[ author ]</a>
         </LI>
       </UL>
</body></html>
