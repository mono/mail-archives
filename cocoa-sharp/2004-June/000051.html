<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Cocoa-sharp] diff
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:C.J.Collier">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000048.html">
   <LINK REL="Next"  HREF="000049.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cocoa-sharp] diff
   </H1>
    <B>C.J.Collier
    </B> 
    <A HREF="mailto:C.J.Collier"
       TITLE="[Cocoa-sharp] diff">C.J.Collier
       </A><BR>
    <I>Fri, 11 Jun 2004 19:58:27 -0700</I>
    <P><UL>
        <LI> Previous message: <A HREF="000048.html">Fixed.  Re: [Cocoa-sharp] Missing files is sample/SampleWindow
</A></li>
        <LI> Next message: <A HREF="000049.html">Fixed.  Re: [Cocoa-sharp] Missing files is sample/SampleWindo
 w
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#51">[ date ]</a>
              <a href="thread.html#51">[ thread ]</a>
              <a href="subject.html#51">[ subject ]</a>
              <a href="author.html#51">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--Apple-Mail-9--819758793
Content-Transfer-Encoding: 7bit
Content-Type: text/plain;
	charset=US-ASCII;
	format=flowed

sorry about that.  here, let me attach it this time.

--Apple-Mail-9--819758793
Content-Transfer-Encoding: 7bit
Content-Type: application/octet-stream;
	x-unix-mode=0644;
	name=&quot;genstubs.pl.diff&quot;
Content-Disposition: attachment;
	filename=genstubs.pl.diff

Index: genstubs.pl
===================================================================
RCS file: /cvs/public/cocoa-sharp/generator/genstubs.pl,v
retrieving revision 1.2
diff -b -u -r1.2 genstubs.pl
--- genstubs.pl	11 Jun 2004 04:35:41 -0000	1.2
+++ genstubs.pl	11 Jun 2004 07:56:52 -0000
@@ -3,13 +3,16 @@
 use strict;
 use File::Basename;
 
-$| = 0;
+#$| = 0;
 my %protocols = ();
+
 makeDirs();
 
 # get protocols
+print(&quot;Processing interfaces.\n&quot;);
 parseDir(&quot;/System/Library/Frameworks/AppKit.framework/Headers&quot;, &quot;appkit&quot;, 1);
 parseDir(&quot;/System/Library/Frameworks/Foundation.framework/Headers&quot;, &quot;foundation&quot;, 1);
+print(&quot;Finished processing interfaces.\n&quot;);
 
 # output interfaces
 parseDir(&quot;/System/Library/Frameworks/AppKit.framework/Headers&quot;, &quot;appkit&quot;, 0);
@@ -19,10 +22,15 @@
     my $origmethod = shift();
     my $class = shift();
     my $methodHash = shift();
+    my $objCHash = shift();
     my @return = ();
 
     chomp($origmethod);
 
+    # TODO: only overwrite to a section delimited by:
+    # /* GENERATED BY genstubs.pl     */
+    # /* END GENRATION BY genstubs.pl */
+
 #    print(&quot;$origmethod\n&quot;);
 
     # Check for unsupported methods and return commented function
@@ -43,18 +51,13 @@
     # or N arguments
     # - (RETURNTYPE)MethodName:(TYPE0)Arg0 ... ArgNName:(TYPEN)ArgN;
 
-    $origmethod =~ /^([+-])\s+\(([^\)]+)\)(.+)/;
+    $origmethod =~ /\s*([+-])\s*(?:\(([^\)]+)\))?(.+)/;
 
     my $methodType = $1;
-    my $retType = $2;
+    my $retType = ($2 ? $2 : &quot;id&quot;);
     my $remainder = $3;
-    my $isClassMethod = (defined($methodType) ? ($methodType eq &quot;+&quot;) : 0);
 
-    # Check for weird interface methods with no return
-    if(!$retType) {
-        $origmethod =~ s:/::g;
-        return &quot;/* UNSUPPORTED - no return type: \n$origmethod\n */\n\n&quot;;
-    }
+    my $isClassMethod = (defined($methodType) ? ($methodType eq &quot;+&quot;) : 0);
     
     $retType =~ s/oneway //;
 
@@ -62,8 +65,8 @@
     $remainder =~ <A HREF="s://.*::;">s://.*::;</A>
     $remainder =~ s:/\*.*\*/::;
     
-    # These are our arrays that store our args, their names and types
-    my(@methodName, @type, @name);
+    # These arrays store our method names, their arg names and types
+    my(@methodName, @name, @type);
 
     my $message;
     my $params;
@@ -74,7 +77,6 @@
     # The objc message we will be sending
     my @message;
 
-
     # If there are no arguments (only matches method name)
     if($remainder =~ /$noarg_rx/){
         push(@methodName, $1);
@@ -122,25 +124,28 @@
     }
 
     # What object will we be sending messages to?
-    my $obj;
+    my $receiver;
 
     # If the method is a class method
     if($isClassMethod){
-        $obj = $class;
+	$receiver = $class;
 
         $class .= '_';
 
     # If the method is an instance method
     }else{
         unshift(@params, &quot;$class* THIS&quot;);
-        $obj = &quot;THIS&quot;;
+	$receiver = &quot;THIS&quot;;
 
     }
 
     # The fully-qualified C function name separated by _s (:s don't work)
     my $methodName = join(&quot;_&quot;,  $class, @methodName);
     
-    return () if exists $methodHash-&gt;{$methodName};
+    if(exists $methodHash-&gt;{$methodName}){
+	print(&quot;Duplicate method name: $methodName\n&quot;);
+	return ();
+    }
     
     $methodHash-&gt;{$methodName} = &quot;1&quot;;
 
@@ -162,7 +167,7 @@
     # return the method we will be using
     return ( &quot;$retType $methodName ($params) {&quot;,
              $logLine,
-             &quot;\t${retter}[$obj $message];&quot;,
+             &quot;\t${retter}[$receiver $message];&quot;,
              &quot;}&quot;
             );             
 }
@@ -170,30 +175,33 @@
 # Parse file
 sub parseFile {
     my $filename = shift();
+
     my $getProtocols = shift();
 
     my %methods = ();
     my $addAlloc = 0;
 
+    my $genDate = scalar localtime;
+
     my @out = (&quot;/* Generated by genstubs.pl&quot;,
                &quot; * (c) 2004 kangaroo, C.J. and Urs&quot;,
-               &quot; * Generation date: &quot; . localtime,
+               &quot; * Generation date: $genDate&quot;,
                &quot; */&quot;,
                &quot;&quot;,
                &quot;&quot;,
               );
     my @protocolOut = ();
 
-    (my($class, $path, $suffix)) = fileparse($filename, &quot;.h&quot;);
+    (my($name, $path, $suffix)) = fileparse($filename, &quot;.h&quot;);
     (my (undef, undef, undef, undef, $dirpart)) = split(/\//, $filename);
     $dirpart =~ s/\.framework//;
 
     my $skip = 0;
     my $isProtocol = 0;
     my $protocol;
-    my $interface = $class;
+    my $interface = $name;
     
-    push(@out, &quot;#import &lt;$dirpart/$class.h&gt;&quot;);
+    push(@out, &quot;#import &lt;$dirpart/$name.h&gt;&quot;);
     push(@out, &quot;#import &lt;Foundation/NSString.h&gt;&quot;);
     
     open(FILE, &quot;&lt;$filename&quot;) or die &quot;Couldn't open $filename: $!&quot;;
@@ -201,10 +209,7 @@
     while(my $line = &lt;FILE&gt;) {
         chomp $line;
        
-        $skip = 1 if($line =~ /\/\*/);
-
-        if($skip == 0) {
-            my $commentRegex = '(?:/\*.*\*/|//.*$)?';
+	commentsBeGone(\$line, \*FILE);
 
             # Ignore #import lines
             next if($line =~ /#import/);
@@ -212,7 +217,7 @@
             # Determine the interface we are in
             if($line =~ /\@interface (\w+)(.*)/){
                 $interface = $1;
-                $addAlloc = 1 if ($interface eq $class);
+	    $addAlloc = 1 if ($interface eq $name);
 
                 if ($2 =~ /&lt;(\w+)&gt;/ &amp;&amp; $getProtocols == 0){
                     my $refProto = $1;
@@ -235,40 +240,90 @@
                 }
             }
 
-            # If this is a method definition, parse it
+	my($class, $super);
+
+	# Capture class and superclass names
+	if($line =~ /^\s*\@interface\s+(\w+)(?:\s*:\s*(\w+))?\s*$/)
+	{
+	    ($class, $super) = ($1, $2);
+	}
+
+	if($line =~ /^\s*\@end/){
+	    ($class, $super) = (undef, undef);
+	}
+
+	my %objC =
+	    ( class                =&gt; $class,
+	      super                =&gt; $super,
+	      &quot;method name&quot;        =&gt; undef,
+	      &quot;method parts&quot;       =&gt; [],
+	      &quot;arg names&quot;          =&gt; [],
+	      &quot;arg types&quot;          =&gt; [],
+	      &quot;is instance method&quot; =&gt; undef,
+	      receiver             =&gt; undef,
+	    );
+
+	my %c =
+	    ( &quot;function name&quot; =&gt; undef,
+	      &quot;param types&quot;   =&gt; [],
+	      &quot;param names&quot;   =&gt; [],
+	      &quot;params&quot;        =&gt; undef,
+	      &quot;return type&quot;   =&gt; undef,
+	    );
+
+	my %cSharp =
+	    ( class         =&gt; $class,
+	      super         =&gt; $super,
+	      &quot;method name&quot; =&gt; undef,
+	      &quot;arg names&quot;   =&gt; [],
+	      &quot;arg types&quot;   =&gt; [],
+	      
+	    );
+
+	# If this is a class or instance method definition
             if($line =~ /^\s*[+-]/){
-                while($line !~ /;\s*$commentRegex$/x){
-                    chomp $line;
+	    # For lines that end in a definition,
+	    # Replace { ... } with a semicolon
+	    $line =~ s/\{[^\}]*\}\s*/;/;
+
+	    # If the line doesn't end with a semicolon, whitespace, end of line
+	    # Do the following until it does
+	    while($line !~ /;\s*$ /x){ # Stupid emacs.
+		$line =~ <A HREF="s://.*::;">s://.*::;</A>
+		# Append the next line
                     $line .= &lt;FILE&gt;;
+		# Remove trailing newline
+		chomp $line;
+		# Get rid of comments
+		commentsBeGone(\$line, \*FILE);
+		# Replace { ... } with a semicolon
+		$line =~ s/\{[^\}]*\}/;/;
                 }
  
                 if($isProtocol == 1) {
                     push(@protocolOut, $line);
                 }else{
                     if ($getProtocols == 0){
-                        push(@out, &quot;&quot;, parseMethod($line, $interface, \%methods));
-                    }
+		    push(@out, &quot;&quot;, parseMethod($line, $interface, \%methods, \%objC));
                 }
             }
-        }else{
-            $skip = 0 if($line =~ /\*\//);
         }
     }
 
-    if($addAlloc &amp;&amp; ($class =~ /NSProxy/ || $class =~ /NSObject/)){
+    if($addAlloc &amp;&amp; ($name =~ /NSProxy/ || $name =~ /NSObject/)){
         push(@out,
              &quot;&quot;,
-             &quot;$class * ${class}__alloc(){&quot;,
-             &quot;\tNSLog(\@\&quot;${class}__alloc()\\n\&quot;);&quot;,
-             &quot;\treturn [$class alloc];&quot;,
+             &quot;$name * ${name}__alloc(){&quot;,
+             &quot;\tNSLog(\@\&quot;${name}__alloc()\\n\&quot;);&quot;,
+             &quot;\treturn [$name alloc];&quot;,
              &quot;}&quot;
             );
     }
 
-    my @keys;
-    @keys = keys %methods;
-    print &quot; $#keys methods.\n&quot; if ($getProtocols == 0);
+    my $numMethods = int(keys %methods);
+    print &quot; $numMethods methods.\n&quot; unless $getProtocols;
     return @out;
+
 }
 
 sub parseDir {
@@ -279,8 +334,8 @@
     opendir(my $dh, $sourcedir);
 
     my($name, $path, $suffix);
-
     print &quot;Processing $sourcedir:\n&quot; if ($getProtocols == 0);
+
     foreach my $filename (readdir($dh)) {
         next if $filename =~ /^\./;
         next unless $filename =~ /\.h$/;
@@ -298,6 +353,7 @@
             close OUT;
         }
     }
+
     print &quot;\n&quot; if ($getProtocols == 0);
 }
 
@@ -310,5 +366,60 @@
     }
     unless(-d &quot;src/foundation&quot;){
         mkdir &quot;src/foundation&quot; or die &quot;Couldn't make dir 'src/foundation': $!&quot;;
+    }
+}
+
+sub commentsBeGone()
+{
+    my $line = shift();
+    my $FH = shift();
+
+    # Rid ourselves of multi-line comments
+    if( $$line =~ m:/\*: ){
+	while( $$line !~ m:/\*.*\*/: ){
+	    $$line .= &lt;$FH&gt;;
+	    chomp $$line;
+	}
+
+	$^W = 0;
+	$$line =~ s{
+                     /\*         ##  Start of /* ... */ comment
+                     [^*]*\*+    ##  Non-* followed by 1-or-more *'s
+                     (
+                       [^/*][^*]*\*+
+                     )*          ##  0-or-more things which don't start with /
+                                 ##    but do end with '*'
+                     /           ##  End of /* ... */ comment
+
+                   |         ##     OR  various things which aren't comments:
+
+                     (
+                       &quot;           ##  Start of &quot; ... &quot; string
+                       (
+                         \\.           ##  Escaped char
+                       |               ##    OR
+                         [^&quot;\\]        ##  Non &quot;\
+                       )*
+                       &quot;           ##  End of &quot; ... &quot; string
+
+                     |         ##     OR
+
+                       '           ##  Start of ' ... ' string
+                       (
+                         \\.           ##  Escaped char
+                       |               ##    OR
+                         [^'\\]        ##  Non '\
+                       )*
+                       '           ##  End of ' ... ' string
+
+                     |         ##     OR
+
+                       .           ##  Anything other char
+                       [^/&quot;'\\]*   ##  Chars which doesn't start a comment, string or escape
+                     )
+                   }{$2}gxs;
+	$^W = 1;
+
+	$$line =~ <A HREF="s://.*::;">s://.*::;</A>
     }
 }

--Apple-Mail-9--819758793--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000048.html">Fixed.  Re: [Cocoa-sharp] Missing files is sample/SampleWindow
</A></li>
	<LI> Next message: <A HREF="000049.html">Fixed.  Re: [Cocoa-sharp] Missing files is sample/SampleWindo
 w
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#51">[ date ]</a>
              <a href="thread.html#51">[ thread ]</a>
              <a href="subject.html#51">[ subject ]</a>
              <a href="author.html#51">[ author ]</a>
         </LI>
       </UL>
</body></html>
