<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Some%20thoughts%20on%20Cocoa%23%20evolvement%20for%202006&In-Reply-To=43B8041E.4000006%40web.de">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000725.html">
   <LINK REL="Next"  HREF="000739.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006</H1>
    <B>kangaroo</B> 
    <A HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Some%20thoughts%20on%20Cocoa%23%20evolvement%20for%202006&In-Reply-To=43B8041E.4000006%40web.de"
       TITLE="[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006">grompf at sublimeintervention.com
       </A><BR>
    <I>Sun Jan  1 23:39:56 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000725.html">[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
</A></li>
        <LI>Next message: <A HREF="000739.html">[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#730">[ date ]</a>
              <a href="thread.html#730">[ thread ]</a>
              <a href="subject.html#730">[ subject ]</a>
              <a href="author.html#730">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
On 1-Jan-06, at 11:32 AM, Andreas F&#228;rber wrote:

&gt;<i> Hi everyone, and a Happy New Year,
</I>&gt;<i>
</I>&gt;<i> Cocoa# has made some big progress in 2005. A big thanks to kangaroo  
</I>&gt;<i> for his work on Cocoa# and for answering my annoying questions.
</I>&gt;<i>
</I>&gt;<i> Personally I believe that Cocoa# is on a good track right now with  
</I>&gt;<i> the new Objective-C Interop and the more CLR-style, hand-crafted  
</I>&gt;<i> classes. In simple scenarios this is already working like a charm,  
</I>&gt;<i> and if everyone contributes what he/she needs then this should add  
</I>&gt;<i> up to a relatively complete class library.
</I>&gt;<i>
</I>&gt;<i> Now, as Cocoa# is growing I have been thinking about some aspects  
</I>&gt;<i> and would like to post them here for controvertial discussion.
</I>&gt;<i>
</I>&gt;<i> I really like the new namespace structure that does not have the  
</I>&gt;<i> name Apple in it, not being written by Apple. However with more and  
</I>&gt;<i> more classes arriving I am proposing to split the classes up  
</I>&gt;<i> (again) into Cocoa (OC interop and Foundation), Cocoa.AppKit (the  
</I>&gt;<i> name says it all, equivalent of Apple.AppKit) and rename WebKit to  
</I>&gt;<i> Cocoa.WebKit (equivalent of Apple.WebKit). Possibly also move the  
</I>&gt;<i> Interop stuff to Cocoa.Interop. This could all remain inside the  
</I>&gt;<i> existing two Assemblies - cosmetics that could improve the  
</I>&gt;<i> documentation and src/Cocoa directory.
</I>
I'm adverse to renaming namespaces _again_ forcing everyones code to  
be changed _again_.  That being said; I have no problem with a  
Cocoa.Interop sub-namespace with a bunch of Interop stuff in it.   
Without a &quot;good reason&quot; I'd like to avoid renaming namespaces again.

&gt;<i>
</I>&gt;<i> I'd be interested to hear your thoughts on what Cocoa#'s position  
</I>&gt;<i> should be regarding other frameworks. I might be interested in  
</I>&gt;<i> using for instance Bonjour or Bluetooth in the future. Would I have  
</I>&gt;<i> to create my own wrapper, or would such additional frameworks be of  
</I>&gt;<i> general interest as Assemblies within Cocoa# SVN?
</I>&gt;<i>
</I>
As above; if we (people working on cocoa#) want to work on creating  
these packages and they have a logical fit into the cocoa# project;  
they can go in.  Bonjour I dont think fits in this (as it can bind to  
zeroconf on linux); but mac bluetooth integration would.  Make sense?

&gt;<i> For /users/ to more easily work with the new Cocoa# I believe it is  
</I>&gt;<i> essential to get documentation in an easy-to-view form to the  
</I>&gt;<i> users. If we are not willing to release CocoaDoc officially yet  
</I>&gt;<i> then we could release snapshots for local browsing of the official  
</I>&gt;<i> documentation. And on the Web the documentation of the latest  
</I>&gt;<i> released version of Cocoa# should be integrated into <A HREF="http://www.go-">http://www.go-</A> 
</I>&gt;<i> mono.com/docs/. There is basically no point in writing  
</I>&gt;<i> documentation that is virtually inaccessible for those for whom it  
</I>&gt;<i> is intended. Maybe we should also add a migration guide for  
</I>&gt;<i> previous users of Cocoa# to the documentation or the Wiki. Maybe  
</I>&gt;<i> even reference the Wiki from Monodoc, is that possible?
</I>&gt;<i>
</I>
CocoaDoc is close to getting ready for some sense of release what it  
needs is:

	a) Someone to wire in the edit mode
	b) To track down a object loss problem.

I'll look into getting the current documentation on go-mono.com/docs;  
if not maybe we can run a monodoc aspx for cocoadoc on  
cocoasharp.org; dru?

As for the wiki; pretty much everything there is out of date; it may  
be smart to just start again?  Thoughts?

&gt;<i> For many people to /contribute/ to Cocoa# we should make it easier  
</I>&gt;<i> for people to do so. I have started the HOWTO in the Cocoa# Wiki as  
</I>&gt;<i> one means of getting people jumpstarted with SVN build and  
</I>&gt;<i> contribution. It is not very extensive and will need our updates to  
</I>&gt;<i> be even more helpful. Some other thoughts are:
</I>&gt;<i> * add an autogen.sh launch script for general users to eliminate  
</I>&gt;<i> the need for lengthy command line options - I've written one myself  
</I>&gt;<i> and could rewrite that as a patch
</I>&gt;<i>
</I>
This is probably ok.  I'd have to see the patch.

&gt;<i> * an update-docs target in the main Makefile that calls &quot;make  
</I>&gt;<i> update&quot; within doc/ (to avoid needing to change in and out of the  
</I>&gt;<i> directory manually)
</I>&gt;<i>
</I>
I have no problem with this.

&gt;<i> * working Cocoa# documentation in CocoaDoc that can easily be  
</I>&gt;<i> updated through some Makefile target to immediately review the  
</I>&gt;<i> changes we have made
</I>&gt;<i>
</I>
This isn't hard; I've got osomething that does this buried in my  
trees somewhere.

&gt;<i> * some more verbose and .NET-style renaming:  
</I>&gt;<i> ObjCMessaging.objc_msgSend to .SendMessage; Native.*ToManaged to an  
</I>&gt;<i> overloaded .ToManaged(*); - I would volunteer for such a task
</I>&gt;<i> * maybe create a Converter or something more similar to Microsoft's  
</I>&gt;<i> Interop marshalling?
</I>&gt;<i>
</I>
No problem with these changes as long as they aren't &quot;make work&quot;  
changes.

&gt;<i> Some other areas where I see a need for /improvements/ are:
</I>&gt;<i> * solving the mysterious Main function crash and fixing it - I  
</I>&gt;<i> believe this may be related to Cocoa# initialization...
</I>&gt;<i>
</I>
Get me an example or testcase that shows this; I've never seen this.

&gt;<i> * solving the Bundle-related problems - what exactly is the problem  
</I>&gt;<i> here: is it looking in /bin/ or in /L/F/M/V/C/bin/ or somewhere  
</I>&gt;<i> else? or is not at all because we do not start as a regular Cocoa  
</I>&gt;<i> app? I would rather have this working 100% natively than starting  
</I>&gt;<i> to commit little patches that remedy some (but not all) side-effects.
</I>&gt;<i>
</I>
The issue here is the lack of documentation on how to launch like we  
want to.  CocoaSharpLoader that I wrote does work; but isn't mono- 
release portable yet as well as having other issues.  I have some  
thoughts on how we can fix this; but we need to document all the  
existing issues (its probably time to start using bugzilla again  
soon) so that we can fix them.


&gt;<i> * test arguments of our methods and make them compatible with null  
</I>&gt;<i> values where applicable - value.NativeObject or similar constructs  
</I>&gt;<i> have already been causing problems for me; can't we use  
</I>&gt;<i> Cocoa.Object parameters for objc_msgSend instead of IntPtr and have  
</I>&gt;<i> them translated (value == null) ? IntPtr.Zero : value.NativeObject  
</I>&gt;<i> in a central place?
</I>&gt;<i>
</I>
This is true; nunit test cases would be phenominal if someone wants  
to start working on them.  I thought about allowing Cocoa.Objects  
into objc_msgSend; the reason I didn't is for EVERY objc_msgSend  
invocation we would need to do a type lookup on EVERY variable to  
determine if its a Cocoa.Object and convert it; this seems like  
expensive overhead to me; more expensive than (if obj == null) in the  
caller.  If someone wants to make a change and benchmark it showing  
that we wont loose a ton of cycles on this; feel free.

&gt;<i> Then the big question: How much CLR and how much Objective-C do we  
</I>&gt;<i> want Cocoa# to be?
</I>&gt;<i>
</I>
I vote as CLR as we can be.  From my &quot;polling&quot; of the &quot;apple  
developer community.&quot;  If they want / know / do objc; they'll keep  
doing their work in objc.  If they want to leverage the CLR; thats  
what objc# is for.  I think Cocoa# has a great fit to be the &quot;easy  
path to bring my (MWF|GTK#) app to the mac&quot; because it will feel  
familiar.  I'm open to discussions on this tho;

&gt;<i> I do like the new CLR-style event handling in Control that has made  
</I>&gt;<i> it into SVN and I would appreciate if we could avoid as much  
</I>&gt;<i> Objective-C as possible in user-derived classes or instances.
</I>&gt;<i>
</I>
Your implementation is similar to what I was planning and works like  
what I wanted to do (did you read my mind?) and I think its MUCH  
better than the target/action pair and allows for the benefit of  
having multiple events fire on one action.

&gt;<i> Might it be possible to avoid needing the ExportAttribute outside  
</I>&gt;<i> the Cocoa# Assemblies for standard apps? I believe passing a  
</I>&gt;<i> delegate to a function is an improvement over passing target and  
</I>&gt;<i> selector but maybe we can improve this even further so that a  
</I>&gt;<i> delegate is called with CLR semantics only and does not need to be  
</I>&gt;<i> exported?
</I>&gt;<i>
</I>
Its totally possible; but we would need to register every single  
class/method/member of every single class in the running assembly  
with the objc runtime.  This seems like overkill to me.  What does  
everyone else think.  Should classes autoregister?  Maybe we should  
run a autoregistry if we find a unknown type?  Maybe we register  
every method in a [Register]'d class?

Thoughts?

-g

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000725.html">[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
</A></li>
	<LI>Next message: <A HREF="000739.html">[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#730">[ date ]</a>
              <a href="thread.html#730">[ thread ]</a>
              <a href="subject.html#730">[ subject ]</a>
              <a href="author.html#730">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/cocoa-sharp">More information about the Cocoa-sharp
mailing list</a><br>
</body></html>
