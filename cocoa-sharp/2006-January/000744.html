<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Some%20thoughts%20on%20Cocoa%23%20evolvement%20for%202006&In-Reply-To=22E98EC5-A839-48A6-A6C1-C716535417FA%40aaronflynt.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000743.html">
   <LINK REL="Next"  HREF="000745.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006</H1>
    <B>Andreas F&#228;rber</B> 
    <A HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Some%20thoughts%20on%20Cocoa%23%20evolvement%20for%202006&In-Reply-To=22E98EC5-A839-48A6-A6C1-C716535417FA%40aaronflynt.com"
       TITLE="[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006">andreas.faerber at web.de
       </A><BR>
    <I>Mon Jan  2 16:04:55 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000743.html">[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
</A></li>
        <LI>Next message: <A HREF="000745.html">[Cocoa-sharp] [PATCH] trunk/cocoa-sharp - revised 1/2/06
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#744">[ date ]</a>
              <a href="thread.html#744">[ thread ]</a>
              <a href="subject.html#744">[ subject ]</a>
              <a href="author.html#744">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Aaron,

&gt;&gt;&gt;&gt;<i> I do like the new CLR-style event handling in Control that has  
</I>&gt;&gt;&gt;&gt;<i> made  it into SVN and I would appreciate if we could avoid as  
</I>&gt;&gt;&gt;&gt;<i> much  Objective-C as possible in user-derived classes or instances.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Your implementation is similar to what I was planning and works  
</I>&gt;&gt;&gt;<i> like  what I wanted to do (did you read my mind?) and I think its  
</I>&gt;&gt;&gt;<i> MUCH  better than the target/action pair and allows for the  benefit 
</I>&gt;&gt;&gt;<i> of  having multiple events fire on one action.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Yeah! That's definitely the ideal way to do it. Could we maybe  
</I>&gt;<i> encapsulate some of that stuff in an abstract base class to make it  
</I>&gt;<i> less verbose for each implementation? Does the ActionReceiver class  
</I>&gt;<i> work with delegates that pass event arguments?
</I>
Something similar to ActionReceiver would have to be implemented *for 
each class* we want to support this in. In such a new class you can 
export any function you like and dispatch anyway you see fit, e.g. with 
a subclass of EventArgs or in case of non-events a custom delegate 
signature.
I saw the need for such a separate class because Control is actually 
NSControl and I thought that exporting methods within NSControl would be 
a bad idea.
When we need delegates for lots of events in one class then the way of 
doing this will be to have a Hashtable instead of multiple *EventHandler 
fields; this could easily be assisted through an abstract base class. In 
the simple case I do not see that possibility. Keep in mind that my 
Control.[Double]Action stuff was experimental, so now that you two have 
approved it we might optimize it further. One thing that could be 
improved is having the Control instance as the sender and not the 
ActionReceiver; my suggestion would be to move the EventHandlers to 
Control and add two dispatching functions within Control.

&gt;&gt;&gt;&gt;<i> Might it be possible to avoid needing the ExportAttribute  outside  
</I>&gt;&gt;&gt;&gt;<i> the Cocoa# Assemblies for standard apps? I believe  passing a  
</I>&gt;&gt;&gt;&gt;<i> delegate to a function is an improvement over passing  target and  
</I>&gt;&gt;&gt;&gt;<i> selector but maybe we can improve this even further  so that a  
</I>&gt;&gt;&gt;&gt;<i> delegate is called with CLR semantics only and does  not need to 
</I>&gt;&gt;&gt;&gt;<i> be  exported?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Its totally possible; but we would need to register every single   
</I>&gt;&gt;&gt;<i> class/method/member of every single class in the running assembly   
</I>&gt;&gt;&gt;<i> with the objc runtime.  This seems like overkill to me.  What  does  
</I>&gt;&gt;&gt;<i> everyone else think.  Should classes autoregister?  Maybe we  
</I>&gt;&gt;&gt;<i> should  run a autoregistry if we find a unknown type?  Maybe we  
</I>&gt;&gt;&gt;<i> register  every method in a [Register]'d class?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> No, on the contrary! I don't believe *any* &quot;standard&quot; CLR class  
</I>&gt;&gt;<i> should register any methods with Objective-C. I was thinking more  of 
</I>&gt;&gt;<i> catching all methods currently needing external [Export] within  such 
</I>&gt;&gt;<i> &quot;proxies&quot; like in Control and passing them on from there. This  is 
</I>&gt;&gt;<i> some more work for us and it implies more object instances  around, 
</I>&gt;&gt;<i> but it will lead to Cocoa# classes complying with CLR  semantics.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> For instance, an XXXHandler can be pretty much anything in .NET -  
</I>&gt;&gt;<i> null, a Delegate or a MulticastDelegate instance - whereas in  
</I>&gt;&gt;<i> Aaron's sheet patch, which I repeat is an improvement and can go  in, 
</I>&gt;&gt;<i> the ActionHandler just like in the old Control.DoubleClick is  being 
</I>&gt;&gt;<i> misused as mapping a selector to a single method only that  
</I>&gt;&gt;<i> additionally needs to be exported by the caller. If instead *we*  
</I>&gt;&gt;<i> exported a method in case of non-null delegate arguments we could  
</I>&gt;&gt;<i> dispatch it to any CLR delegate with the expected semantics of &quot;if  
</I>&gt;&gt;<i> (myDelegate != null) myDelegate(...);&quot;. That's what Control.Action  
</I>&gt;&gt;<i> was trying to accomplish, and I am thinking about ways of doing  this 
</I>&gt;&gt;<i> for a TableView data source too via a new abstract class.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Problem in general will be that an Objective-C protocol does not  
</I>&gt;&gt;<i> seem to map to a CLR interface, right? It appears to be more like a  
</I>&gt;&gt;<i> purely virtual class with virtual ... Method(...) = 0; in C++? I do  
</I>&gt;&gt;<i> not seem to need to implement _all_ methods of a certain protocol  
</I>&gt;&gt;<i> and the lack of some may cause some class-dependent default  
</I>&gt;&gt;<i> behavior? Wherever there are no such side-effects I vote for  
</I>&gt;&gt;<i> abstract or virtual CLR methods, for instance a protected virtual  
</I>&gt;&gt;<i> void View.OnDrawRect. Possibly additionally doing the same as in  
</I>&gt;&gt;<i> S.W.F, that is raising an event in the base implementation, e.g.  
</I>&gt;&gt;<i> View.Draw.
</I>&gt;&gt;<i> That way we could also tackle my contextInfo request. ;-)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> You mean just expose a virtual Alert.OnSheetEnd method, and don't  
</I>&gt;<i> have any delegate parameter for Alert.BeginSheet? Then just add the  
</I>&gt;<i> Export attribute to the base method and drop the ContextInfo altogether?
</I>
No, I meant passing a delegate argument similar like you did (thanks for 
the inspiration!), however not passing that to Objective-C directly like 
kangaroo and you did in the past but to something like ActionReceiver 
instead. That again could export the signature expected by Cocoa within 
that class and call the delegate in the exported method. This would make 
the exporting easier for us (no searching for ExportAttribute) and safer 
for .NET developers at the downside of some memory cost.
Especially Application is problematic as I do not see an easy way of 
subclassing it to use any OnXXX method.
In BeginSheet the contextInfo would still be part of the signature but 
we could redefine it as System.Object and convert it in the target class 
when invoking the delegate.

Andreas
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000743.html">[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
</A></li>
	<LI>Next message: <A HREF="000745.html">[Cocoa-sharp] [PATCH] trunk/cocoa-sharp - revised 1/2/06
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#744">[ date ]</a>
              <a href="thread.html#744">[ thread ]</a>
              <a href="subject.html#744">[ subject ]</a>
              <a href="author.html#744">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/cocoa-sharp">More information about the Cocoa-sharp
mailing list</a><br>
</body></html>
