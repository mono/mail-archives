<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Some%20thoughts%20on%20Cocoa%23%20evolvement%20for%202006&In-Reply-To=8C334C8F-DC83-41C2-8FB6-231AAF981AC5%40gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000768.html">
   <LINK REL="Next"  HREF="000769.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006</H1>
    <B>Andreas F&#228;rber</B> 
    <A HREF="mailto:cocoa-sharp%40lists.ximian.com?Subject=%5BCocoa-sharp%5D%20Some%20thoughts%20on%20Cocoa%23%20evolvement%20for%202006&In-Reply-To=8C334C8F-DC83-41C2-8FB6-231AAF981AC5%40gmail.com"
       TITLE="[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006">andreas.faerber at web.de
       </A><BR>
    <I>Thu Jan 12 20:35:53 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000768.html">[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
</A></li>
        <LI>Next message: <A HREF="000769.html">[Cocoa-sharp] Correct TableView Usage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#773">[ date ]</a>
              <a href="thread.html#773">[ thread ]</a>
              <a href="subject.html#773">[ subject ]</a>
              <a href="author.html#773">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Tim Davis schrieb:

&gt;<i> I just read this archived message today and wanted to add an opinion  
</I>&gt;<i> from a users perspective....
</I>
[...] :-)

&gt;<i> I did try something, I took a look at the source for Cocoa.Window, I  
</I>&gt;<i> was wanting to try and create the class Cocoa.WindowController so I  
</I>&gt;<i> could use sheets in one of my programs, I figured it can't be to  
</I>&gt;<i> hard....hrm...how the heck do you guys know what your doing,  
</I>&gt;<i> lol...none of it makes sense...I'd love to help write code but I'm  
</I>&gt;<i> afraid I'm a little dense when it comes to this kinda code, lol :)
</I>
I agree that it is quite confusing at first (feel free to expand my Wiki 
topic with any info you see fit). Most of it does make sense once you've 
learned more about the Objective-C language and runtime. However it is 
my belief that some things should be a little simpler and thus I have 
started some efforts to tackle this; for example I have been proposing 
the Cocoa.Interop.ObjectiveC class with a simplified SendMessage method 
in the other post.

There are currently some issues with deriving classes from some of the 
Cocoa# classes (constructor calls and some weird phenomenons). As for 
the construction of new classes that don't have these problems right now 
you can look up the documentation at Apple 
(<A HREF="http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/ObjC_classic/index.html">http://developer.apple.com/documentation/Cocoa/Reference/ApplicationKit/ObjC_classic/index.html</A>) 
and send the appropriate messages using ObjCMessaging.objc_msgSend. I 
have initiated some work to simplify this task for people like you and 
me with my ObjectiveC.SendMessage implementation but that is not yet a 
complete patch.


With this I have experimented a little on creating a new 
managed-to-native bridge; for testing purposes I have created a clean 
implementation of a small set of classes with the following changes:
a) the abstract Objective-C root object is Cocoa.Interop.ObjCObject 
which implements IDisposable in the same way as S.W.F
b) all my Objective-C class representations inherit from 
Cocoa.Interop.ObjCObject, in particular Cocoa.Object directly as the 
Cocoa root object NSObject
c) only classes that have a non-inheritable, not-multiple-allowed 
ObjectiveCClassAttribute on it are considered an Objective-C class 
representation
and obviously d) those classes use ObjectiveC exclusively for 
Objective-C interop

My reasons and intents are as follows:
a) + b):
i) NSObject is not necessarily the only possible root object in 
Objective-C reading Apple's OC Runtime documentation - this abstraction 
makes the OC interop more generic at little cost.
ii) An IDisposable implementation will allow to release an NSObject (or 
other OC class instance) in the standard .NET way without exposing 
non-standard methods and properties such as retain/release/autorelease.
c):
i) Allowing to create managed subclasses that are not mapped as OC 
classes enables us both to insert abstract classes into our hierarchy 
for simplification purposes that don't have an OC counterpart, such as 
for the target/action stuff (that is not actually in Control), or to 
create managed-only subclasses that don't need to be visible to OC, 
which is basically most of my subclasses - this should make Cocoa# more 
efficient.
ii) Using an Attribute instead of an unreferenced field removes the 0169 
compiler warnings for private static string ObjectiveCName.
d):
Doing all Objective-C interop through Cocoa.Interop.ObjectiveC gives us 
one central (managed) place for the generic OC functionality and will 
help limit the necessity for P/Invoke to a few core interop classes. The 
Cocoa.Interop.ObjectiveC and Cocoa.Interop.ObjectiveCMethods classes are 
designed to only depend on libobjc.dylib, while for instance 
Cocoa.Object shall only depend on the Foundation framework (plus 
Cocoa.Interop.ObjCObject and Cocoa.Interop.ObjectiveC class) and for 
instance Cocoa.AppKit.View on the AppKit umbrella framework (plus 
Cocoa.Object etc. and Cocoa.Interop.ObjectiveC classes).

I'm attaching a snapshot of my recent work. Some comments on my code:
- Cocoa.Interop.ObjectiveC.SendMessageSuper is currently non-functional 
as I did not yet change it to use my new 
Cocoa.Interop.DynamicPInvoke.InvokeMethod
- ObjCObject derived instances are not yet being tracked for 
id-to-managed-instance lookup
- ObjCObject is still experimental and most likely not yet fully working 
(and should be renamed ObjectiveCObject)

Some more areas that I am interested in improving are:
* better supporting Foundation-only console apps and unit tests :-) - 
currently an app does not exit when not using Cocoa.Application.Run
* shielding .NET users more from Objective-C interop
* ma(r)king the library CLSCompliant
* ma(r)king the library AllowPartiallyTrustedCallers? or 
Transparent/SecurityCritical?
* supporting UIPermission?

I'd be interested to hear your thoughts on these new concepts, 
especially with the lack of documentation *why* stuff is like it is.
ObjectiveC, ObjectiveCMethods and DynamicPInvoke should be in a state 
where with some enhancements they could easily be provided as a patch 
for Cocoa# if approved. As for the rest, do you see added value too in 
the changes I'm working on? And will we be able to merge such a &quot;branch&quot; 
into Cocoa# at some point later on or do they conflict with your vision 
of Cocoa#, kangaroo?
Unfortunately the latest Cocoa# is still not working for my application, 
which I want to have in a non-crashing state by the end of the month, 
and I do not know another way of fixing that apart from doing a private 
clean implementation outside SVN, from public Apple docs without any 
unsafe C# voodoo, so that I understand what the code is doing and where 
things might be going wrong... :-(

Andreas
-------------- next part --------------
using System;
using Cocoa.Interop;

namespace Cocoa {
	[ObjectiveCClass (&quot;NSObject&quot;)]
	public class Object : ObjCObject {
		public Object ()
		{
			Alloc ();
		}
		
		private void Alloc ()
		{
			id = (IntPtr)ObjectiveC.SendMessage (FindClosestObjCClass (), &quot;alloc&quot;, typeof (IntPtr));
		}
		private void Release()
		{
			ObjectiveC.SendMessage (id, &quot;release&quot;, typeof (void));
		}

		protected override void Dispose (bool disposing)
		{
			if (disposing)
				Release();
		}
	}
}
-------------- next part --------------
using System;
using System.Collections;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using System.Text;

namespace Cocoa.Interop {
	internal sealed class DynamicPInvoke {
		private static Hashtable libraries = new Hashtable();
		private static AssemblyBuilder builder;
		private static ModuleBuilder module;

		static DynamicPInvoke()
		{
			AssemblyName an = new AssemblyName();
			an.Name = &quot;DynamicPInvoke&quot;;
			builder = AppDomain.CurrentDomain.DefineDynamicAssembly(an, AssemblyBuilderAccess.Run);
			module = builder.DefineDynamicModule(&quot;DynPInvoke&quot;);
		}
		
		private DynamicPInvoke()
		{
		}
		
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode=true)]
		[ReflectionPermission(SecurityAction.Demand, ReflectionEmit=true)]
		public static object InvokeMethod (string library, string method, Type returnType, object [] args)
		{
			MethodInfo meth = GetMethod(library, method, returnType, args);
			return meth.Invoke(null, args);
		}

		private static MethodInfo GetMethod(string library, string method, Type returnType, object [] args)
		{
			if (!libraries.ContainsKey(library)) {
				libraries[library] = new Hashtable();
			}
			Hashtable methods = (Hashtable) libraries[library];
			StringBuilder sb = new StringBuilder();
			sb.Append(method);
			sb.Append('(');
			for (int i = 0; i &lt; args.Length; i++) {
				if (i &gt; 0) sb.Append(',');
				sb.Append(args [i].GetType().FullName);
			}
			sb.Append(')');
			string signature = sb.ToString();
			if (!methods.ContainsKey(signature)) {
				Type [] paramTypes = new Type [args.Length];
				for (int i = 0; i &lt; args.Length; i++) {
					paramTypes [i] = args [i].GetType ();
				}
				MethodInfo meth = DefineMethod (library, method, returnType, paramTypes);
				methods [signature] = meth;
				return meth;
			}
			return (MethodInfo)methods [signature];
		}

		private static MethodInfo DefineMethod(string library, string method, Type returnType, Type [] paramTypes)
		{
			TypeBuilder tb = module.DefineType(Guid.NewGuid().ToString());
			tb.DefinePInvokeMethod (method, library, MethodAttributes.PinvokeImpl | MethodAttributes.Static | MethodAttributes.Public, CallingConventions.Standard, returnType, paramTypes, CallingConvention.Cdecl, CharSet.Auto);
			Type type = tb.CreateType();
			return type.GetMethod(method, BindingFlags.Static|BindingFlags.Public, null, paramTypes, null);
		}
	}
}
-------------- next part --------------
using System;

namespace Cocoa.Interop {
	public abstract class ObjCObject : IDisposable {
		protected IntPtr id;
		
		protected ObjCObject ()
		{
		}
		
		protected ObjCObject (IntPtr id)
		{
			this.id = id;
		}
		
		~ObjCObject ()
		{
			Dispose (false);
		}

		public void Dispose ()
		{
			Dispose (true);
			GC.SuppressFinalize (this);
		}

		protected virtual void Dispose (bool disposing)
		{
		}
		
		protected IntPtr FindClosestObjCClass()
		{
			Type cls = this.GetType ();
			while (cls != null) {
				if (cls.IsDefined (typeof (ObjectiveCClassAttribute), false)) {
					ObjectiveCClassAttribute attr = (ObjectiveCClassAttribute)Attribute.GetCustomAttribute(cls, typeof (ObjectiveCClassAttribute));
					return ObjectiveC.GetClass (attr.Name);
				}
				cls = cls.BaseType;
			}
			throw new InvalidOperationException(&quot;This class is not an Objective-C wrapper class.&quot;);
		}
	}
}
-------------- next part --------------
//
// ObjectiveC.cs: Objective-C interop
//
// Authors:
//   Geoff Norton (<A HREF="http://lists.ximian.com/mailman/listinfo/cocoa-sharp">gnorton at customerdna.com</A>)
//   Andreas Faerber (<A HREF="http://lists.ximian.com/mailman/listinfo/cocoa-sharp">andreas.faerber at web.de</A>)
//

using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace Cocoa.Interop {
	public sealed class ObjectiveC {

		static ObjectiveC()
		{
		}

		private ObjectiveC()
		{
		}

		public static IntPtr GetSelector (string selector)
		{
			return ObjectiveCMethods.sel_registerName (selector);
		}

		public static IntPtr GetClass (string className)
		{
			return ObjectiveCMethods.objc_getClass (className);
		}

		public static object SendMessage (IntPtr receiver, string selector, Type returnType, params object [] args)
		{
			if (args == null)
				throw new ArgumentNullException(&quot;args&quot;);
			Type retType = GetReturnType (returnType);
			IntPtr sel = GetSelector(selector);
			args = ConvertArguments (args);
			object ret;
			if (IsStretNeeded (retType)) {
				IntPtr ptr = Marshal.AllocHGlobal (Marshal.SizeOf (retType));
				try {
					object [] myArgs = new object [3 + args.Length];
					myArgs [0] = ptr;
					myArgs [1] = receiver;
					myArgs [2] = sel;
					args.CopyTo(myArgs, 3);
					DynamicPInvoke.InvokeMethod (&quot;libobjc.dylib&quot;, &quot;objc_msgSend_stret&quot;, typeof(void), myArgs);
					ret = Marshal.PtrToStructure (ptr, retType);
				} finally {
					Marshal.FreeHGlobal (ptr);
				}
			} else {
				object [] myArgs = new object [2 + args.Length];
				myArgs [0] = receiver;
				myArgs [1] = sel;
				args.CopyTo(myArgs, 2);
				ret = ToReturnType ((IntPtr)DynamicPInvoke.InvokeMethod (&quot;libobjc.dylib&quot;, &quot;objc_msgSend&quot;, typeof(IntPtr), myArgs), returnType);
			}
			return ret;
		}

		public static object SendMessageToSuper (IntPtr receiver, IntPtr superclass, string selector, Type returnType, params object [] args)
		{
			Type retType = GetReturnType (returnType);
			args = ConvertArguments (args);
			object ret = null;
			IntPtr superContext = Marshal.AllocHGlobal (Marshal.SizeOf (typeof (objc_super)));
			try {
				Marshal.StructureToPtr (new objc_super (receiver, superclass), superContext, true);
				if (IsStretNeeded (retType)) {
					IntPtr ptr = Marshal.AllocHGlobal (Marshal.SizeOf (retType));
					try {
						//msgSendSuper_stret.Invoke (null, new object [] { ptr, superContext, sel_registerName (selector), args });
						//ret = Marshal.PtrToStructure (ptr, retType);
					} finally {
						Marshal.FreeHGlobal (ptr);
					}
				} //else
					//ret = ToReturnType ((IntPtr)msgSendSuper.Invoke (null, new object [] { superContext, sel_registerName (selector), args }), returnType);
			} finally {
				Marshal.FreeHGlobal (superContext);
			}
			return ret;
		}

		private static bool IsStretNeeded (Type returnType)
		{
			return returnType.IsValueType &amp;&amp; (returnType.Namespace != &quot;System&quot;);
		}

		private static object [] ConvertArguments (object [] args)
		{
			object [] arguments = (object []) args.Clone ();
			for (int i = 0; i &lt; arguments.Length; i++) {
				if (arguments [i].GetType ().IsEnum) {
					arguments [i] = Convert.ChangeType (arguments [i], Enum.GetUnderlyingType (arguments [i].GetType ()));
				} //else if (arguments [i].GetType () == typeof (string))
					//arguments [i] = Marshal.StringToHGlobalAuto((string)arguments [i]);
			}
			return arguments;
		}

		private static Type GetReturnType (Type type)
		{
			if (type == null)
				return typeof (void);
			if (type == typeof (string))
				return typeof (IntPtr);
			return type;
		}

		private static object ToReturnType (IntPtr ret, Type type)
		{
			if (type == typeof (string))
				return Marshal.PtrToStringAuto (ret);
			if (type == typeof (void))
				return null;
			return ret;
		}
	}

	internal struct objc_super {
		internal IntPtr receiver;
		internal IntPtr superclass;

		internal objc_super(IntPtr receiver, IntPtr superclass) {
			this.receiver = receiver;
			this.superclass = superclass;
		}
	}

	internal struct objc_class {
		internal IntPtr isa;
		internal IntPtr super_class;
		internal IntPtr name;
		internal int version;
		internal int info;
		internal int instance_size;
		internal IntPtr ivars;
		internal IntPtr methodLists;
		internal IntPtr cache;
		internal IntPtr protocols;
	}
}
-------------- next part --------------
using System;

namespace Cocoa.Interop {
	[AttributeUsage (AttributeTargets.Class, Inherited=false, AllowMultiple=false)]
	public sealed class ObjectiveCClassAttribute : Attribute {
		private string className;
		
		public ObjectiveCClassAttribute(string className)
		{
			this.className = className;
		}
		
		public string Name {
			get { return className; }
		}
	}
}
-------------- next part --------------
using System;
using System.Runtime.InteropServices;

namespace Cocoa.Interop {
	internal sealed class ObjectiveCMethods {
		private ObjectiveCMethods()
		{
		}
		
		[DllImport (&quot;libobjc.dylib&quot;, CharSet=CharSet.Auto, CallingConvention=CallingConvention.Cdecl)]
		internal static extern IntPtr sel_registerName (string selectorName);
		
		[DllImport (&quot;libobjc.dylib&quot;, CharSet=CharSet.Auto, CallingConvention=CallingConvention.Cdecl)]
		internal static extern IntPtr objc_getClass (string className);
		
		[DllImport (&quot;libobjc.dylib&quot;, CharSet=CharSet.Auto, CallingConvention=CallingConvention.Cdecl)]
		internal static extern IntPtr objc_getMetaClass (string className);
		
		[DllImport (&quot;libobjc.dylib&quot;, CharSet=CharSet.Auto, CallingConvention=CallingConvention.Cdecl)]
		internal static extern IntPtr objc_lookUpClass (string className);
		
		[DllImport (&quot;libobjc.dylib&quot;, CharSet=CharSet.Auto, CallingConvention=CallingConvention.Cdecl)]
		internal static extern IntPtr objc_setClassHandler (ClassHandlerDelegate callback);
	}

	internal delegate int ClassHandlerDelegate(string className);
}
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000768.html">[Cocoa-sharp] Some thoughts on Cocoa# evolvement for 2006
</A></li>
	<LI>Next message: <A HREF="000769.html">[Cocoa-sharp] Correct TableView Usage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#773">[ date ]</a>
              <a href="thread.html#773">[ thread ]</a>
              <a href="subject.html#773">[ subject ]</a>
              <a href="author.html#773">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/cocoa-sharp">More information about the Cocoa-sharp
mailing list</a><br>
</body></html>
