<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-gc-list] My arguments
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:lupus%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000024.html">
   <LINK REL="Next"  HREF="000025.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-gc-list] My arguments
   </H1>
    <B>Paolo Molaro
    </B> 
    <A HREF="mailto:lupus%40ximian.com"
       TITLE="[Mono-gc-list] My arguments">lupus@ximian.com
       </A><BR>
    <I>Wed, 13 Aug 2003 12:19:03 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="000024.html">[Mono-gc-list] My arguments
</A></li>
        <LI> Next message: <A HREF="000025.html">[Mono-gc-list] Pinned objects
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22">[ date ]</a>
              <a href="thread.html#22">[ thread ]</a>
              <a href="subject.html#22">[ subject ]</a>
              <a href="author.html#22">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 08/13/03 Fergus Henderson wrote:
&gt;<i> &gt; If we're not going to achieve that, we might as well just keep using
</I>&gt;<i> &gt; libgc.
</I>&gt;<i> 
</I>&gt;<i> I don't agree.  For many applications we ought to be able to get
</I>&gt;<i> significantly better performance than libgc using a good copying or
</I>&gt;<i> mark/compact garbage collector.  Also, there are advantages to using a
</I>&gt;<i> type-accurate collector rather than a conservative collector (e.g. more
</I>&gt;<i> predictable memory usage) which are desirable for some applications.
</I>&gt;<i> So type-accurate copying or compacting collection is desirable even
</I>&gt;<i> if it is not incremental.
</I>[...]
&gt;<i> In the short to medium term, I think implementing a type-accurate
</I>&gt;<i> collector and integrating it with the rest of the Mono implementation
</I>&gt;<i> is already a complex task, so I think we should start off simple,
</I>
I agree with Fergus here. Just doing a precise collector is hard,
specially when considering that in the CLR managed&lt;-&gt;unmanaged
transitions are quite common and need to be handled correctly.
Moving the objects around could be considered just a way to test
the pointer-tracking implementation more than anything else;-)
Tracking the pointers in the heap is very easy: the issue is with
tracking them on the stack/registers. There are papers, though, about
scanning stack/regs conservatively and avoiding copies of objects
that could be referenced from there: this might be a possible convenient
compromise.
I would also like to point out some features required by the CLR
that need to be taken into account when designing a replacement for
libgc:
*) pinning (an object may be marked as non-moving for some periods of time)
*) weak references
*) finalization issues

lupus

-- 
-----------------------------------------------------------------
<A HREF="mailto:lupus@debian.org">lupus@debian.org</A>                                     debian/rules
<A HREF="mailto:lupus@ximian.com">lupus@ximian.com</A>                             Monkeys do it better

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000024.html">[Mono-gc-list] My arguments
</A></li>
	<LI> Next message: <A HREF="000025.html">[Mono-gc-list] Pinned objects
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22">[ date ]</a>
              <a href="thread.html#22">[ thread ]</a>
              <a href="subject.html#22">[ subject ]</a>
              <a href="author.html#22">[ author ]</a>
         </LI>
       </UL>
</body></html>
