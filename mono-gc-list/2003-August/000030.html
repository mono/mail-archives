<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-gc-list] Fast allocation vs lightweight collection
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:michel.dagenais%40polymtl.ca">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000029.html">
   <LINK REL="Next"  HREF="000031.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-gc-list] Fast allocation vs lightweight collection
   </H1>
    <B>Michel Dagenais
    </B> 
    <A HREF="mailto:michel.dagenais%40polymtl.ca"
       TITLE="[Mono-gc-list] Fast allocation vs lightweight collection">michel.dagenais@polymtl.ca
       </A><BR>
    <I>25 Aug 2003 12:33:48 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000029.html">[Mono-gc-list] Fast allocation vs lightweight collection
</A></li>
        <LI> Next message: <A HREF="000031.html">[Mono-gc-list] Fast allocation vs lightweight collection
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30">[ date ]</a>
              <a href="thread.html#30">[ thread ]</a>
              <a href="subject.html#30">[ subject ]</a>
              <a href="author.html#30">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> &gt; I have a question for you again. What do you think is better a Fast
</I>&gt;<i> &gt; allocation process or a lightweight collection?
</I>
If you have not already, you may want to read the best reference on the
subject:

Garbage Collection: Algorithms for Automatic Dynamic Memory Management
by Richard Jones, Rafael Lins

&gt;<i> In appliactions where pauses are unacceptable, there is no way to
</I>&gt;<i> &quot;work around&quot; the problem.
</I>&gt;<i> 
</I>&gt;<i> Constant factor performance degredation is not relevant. Computers get
</I>&gt;<i> faster every year, it is easy to use more computers, and in the rare
</I>&gt;<i> windows of time where this is a problem for a specific application,
</I>&gt;<i> they are probably writing in C instead of C# anyhow.
</I>
The performance overhead of garbage collection is somewhere between +20%
(reference counting with lots of pointer writes) and -5% (very efficient
generational collector which reduces the allocation time, improves the
memory locality and produces an overall improvement), with perhaps +5%
being typical. When comparing to C++ you also have to account for vector
bounds checking, null pointers... adding some more.

The real problem in most cases, and in almost all interactive
applications, is indeed garbage collection pauses.

I had experience with the development of an emergency call management
system written in Modula-3 where the pause times for a large heap were
of several seconds every few minutes. When we switched to an incremental
collection algorithm the pauses became much smaller (.1 or .2 seconds).
It was probably a bit less efficient CPU wise but only by a few percent.

One very important point that did not come out in the discussion is the
interaction between garbage collection and multi-threading. Most
algorithms need special treatment or are inapplicable in multi-threaded
environments. Reference counting, for instance, needs some form of
locking when updating the reference counts, unless you rely on the
application to do its own locking and not modify a pointer from two
threads.




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000029.html">[Mono-gc-list] Fast allocation vs lightweight collection
</A></li>
	<LI> Next message: <A HREF="000031.html">[Mono-gc-list] Fast allocation vs lightweight collection
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30">[ date ]</a>
              <a href="thread.html#30">[ thread ]</a>
              <a href="subject.html#30">[ subject ]</a>
              <a href="author.html#30">[ author ]</a>
         </LI>
       </UL>
</body></html>
