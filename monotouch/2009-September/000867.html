<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoTouch] RES: XnaTouch in action
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monotouch%40lists.ximian.com?Subject=%5BMonoTouch%5D%20RES%3A%20XnaTouch%20in%20action&In-Reply-To=53D3A853-E7FC-46DE-8249-357DE163102A%40sharpgames.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000818.html">
   <LINK REL="Next"  HREF="000830.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoTouch] RES: XnaTouch in action</H1>
    <B>Christian Beaumont</B> 
    <A HREF="mailto:monotouch%40lists.ximian.com?Subject=%5BMonoTouch%5D%20RES%3A%20XnaTouch%20in%20action&In-Reply-To=53D3A853-E7FC-46DE-8249-357DE163102A%40sharpgames.net"
       TITLE="[MonoTouch] RES: XnaTouch in action">chris at foundation42.org
       </A><BR>
    <I>Thu Sep 10 13:04:56 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000818.html">[MonoTouch] RES: XnaTouch in action
</A></li>
        <LI>Next message: <A HREF="000830.html">[MonoTouch] RES: XnaTouch in action
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#867">[ date ]</a>
              <a href="thread.html#867">[ thread ]</a>
              <a href="subject.html#867">[ subject ]</a>
              <a href="author.html#867">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Umm, sorry about that.  I sent out the wrong file yesterday...  I hurt my
back the other day and my pain meds are making me a bit spacey :)

Try again...

-chris


2009/9/10 Jos&#233; Antonio Leal Farias &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">jalf at sharpgames.net</A>&gt;

&gt;<i> Thanks chris.
</I>&gt;<i> Jos&#233;.
</I>&gt;<i>
</I>&gt;<i> Em 09/09/2009, &#224;s 22:24, Christian Beaumont escreveu:
</I>&gt;<i>
</I>&gt;<i> Hey,
</I>&gt;<i> Here is the sound code we wrote for our game.  It isn't tidied up yet
</I>&gt;<i> (though it works) and it isn't a real binding of AudioQueue, rather the code
</I>&gt;<i> we needed for our particular use case.  Anyway, hopefully it can be of use
</I>&gt;<i> to people on the list in lieu of real MonoTouch AudioQueue bindings.
</I>&gt;<i>
</I>&gt;<i> Sound sound = Sound.CreateAndPlay(&quot;Foo.mp3&quot;, 1.0f, false);
</I>&gt;<i> ...
</I>&gt;<i> sound.Volume = 0.4f;
</I>&gt;<i> sound.Looping = true;
</I>&gt;<i> ...
</I>&gt;<i> sound.Stop();
</I>&gt;<i>
</I>&gt;<i> cheers,
</I>&gt;<i> -chris
</I>&gt;<i>
</I>&gt;<i> 2009/9/9 Jos&#233; Antonio Leal de Farias &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">jalf at sharpgames.net</A>&gt;
</I>&gt;<i>
</I>&gt;&gt;<i>  Thanks chris....you have another sample or some snippet code to help?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Jos&#233;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> *De:* Christian Beaumont [mailto:<A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">chris at foundation42.org</A>]
</I>&gt;&gt;<i> *Enviada em:* quarta-feira, 9 de setembro de 2009 18:38
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> *Para:* Jos&#233; Antonio Leal de Farias
</I>&gt;&gt;<i> *Cc:* Miguel de Icaza; <A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">monotouch at lists.ximian.com</A>
</I>&gt;&gt;<i> *Assunto:* Re: [MonoTouch] RES: XnaTouch in action
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hey Jose,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> That's great, it's really coming along nicely!!!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I've seen a few people complaining about OpenAL on the iPhone that the
</I>&gt;&gt;<i> stack is buggy.  I decided to avoid it and go with AudioQueue instead which
</I>&gt;&gt;<i> works fine.  AudioUnits might be another way to go since I believe that
</I>&gt;&gt;<i> allows additional features like echo and speed control but I haven't tried
</I>&gt;&gt;<i> it.  Take a look at the SpeakHere sample from the iPhone SDK on how to use
</I>&gt;&gt;<i> AudioQueue.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> One thing you'll need to watch out for is the iPhone uses a hardware CODEC
</I>&gt;&gt;<i> for MP3 and AAC audio.  The problem is (at least on the 3G) it isn't
</I>&gt;&gt;<i> possible to play two MP3 files simultaneously since you need exclusive
</I>&gt;&gt;<i> access to the hardware codec.  Currently, the way I am doing it I use MP3 or
</I>&gt;&gt;<i> AAC for the background music and .WAV for short sound effects that are
</I>&gt;&gt;<i> layered on top.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> cheers,
</I>&gt;&gt;<i> -chris
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>  2009/9/9 Jos&#233; Antonio Leal de Farias &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">jalf at sharpgames.net</A>&gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Not so great...XnaTouch don't have Audio Support yet :(
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> By the way...what is the best approach to do sound effects in IPhone
</I>&gt;&gt;<i> games?
</I>&gt;&gt;<i> OpenAL?
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Jos&#233;.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> -----Mensagem original-----
</I>&gt;&gt;<i> De: Miguel de Icaza [mailto:<A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">miguel at novell.com</A>]
</I>&gt;&gt;<i> Enviada em: quarta-feira, 9 de setembro de 2009 18:04
</I>&gt;&gt;<i> Para: Jos&#233; Antonio Leal de Farias
</I>&gt;&gt;<i> Cc: <A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">monotouch at lists.ximian.com</A>
</I>&gt;&gt;<i> Assunto: Re: [MonoTouch] XnaTouch in action
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hello Jos&#233;,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    This is amazing!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; Hi,
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Check this video to see XnaTouch in action :)
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; <A HREF="http://www.youtube.com/watch?v=8iDtHy36E5k">http://www.youtube.com/watch?v=8iDtHy36E5k</A>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Here is the actual status:
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; - Support to GameComponents
</I>&gt;&gt;<i> &gt; - Huge 2D support (SpriteBlendModes, SpriteBatch, Font, AlphaColor,
</I>&gt;&gt;<i> etc.)
</I>&gt;&gt;<i> &gt; - Input support via Virtual GamePad (and Mouse)
</I>&gt;&gt;<i> &gt; - Load textures and fonts in XNB format (thanks to SilverSprite!)
</I>&gt;&gt;<i> &gt; - Iphone support (accelerometer, battery, Storage)
</I>&gt;&gt;<i> &gt; - Core Framework (Math, ContentManager, GameTime, etc.)
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; This is video is in very low quality, but I will send another one later.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Cheers,
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; Jos&#233;.
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; _______________________________________________
</I>&gt;&gt;<i> &gt; MonoTouch mailing list
</I>&gt;&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">MonoTouch at lists.ximian.com</A>
</I>&gt;&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">http://lists.ximian.com/mailman/listinfo/monotouch</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> _______________________________________________
</I>&gt;&gt;<i> MonoTouch mailing list
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">MonoTouch at lists.ximian.com</A>
</I>&gt;&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">http://lists.ximian.com/mailman/listinfo/monotouch</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &lt;Sound.cs.zip&gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/mailman/private/monotouch/attachments/20090910/688916b0/attachment-0001.html">http://lists.ximian.com/mailman/private/monotouch/attachments/20090910/688916b0/attachment-0001.html</A> 
-------------- next part --------------
/*
	Sound.cs
	 
	Author:
	      Christian Beaumont <A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">chris at foundation42.org</A> (<A HREF="http://www.foundation42.com">http://www.foundation42.com</A>)
	
	Copyright (c) 2009 Foundation42 LLC
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the &quot;Software&quot;), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/

namespace OSX.AudioToolbox
{
	using System;
	using System.Text;
	using System.Threading;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	using System.Collections.Generic;
	using MonoTouch;
	using MonoTouch.Foundation;
	using OSStatus = System.Int32;
	using AudioFileTypeID = System.UInt32;
	using AudioFileID = System.IntPtr;
	using AudioQueue = System.Int32;
	
	internal enum CFRunLoop : uint
	{
	    Finished = 1,
	    Stopped = 2,
	    TimedOut = 3,
	    HandledSource = 4
	};

	internal enum FileType : uint
	{
		AIFF = 0x41494646, // AIFF
		AIFC = 0x41494643, // AIFC
		WAVE = 0x57415645, // WAVE
		SoundDesigner2 = 0x53643266, // Sd2f
		Next = 0x4e655854, // NeXT
		MP3 = 0x4d504733, // MPG3
		MP2 = 0x4d504732, // MPG2
		MP1 = 0x4d504731, // MPG1
		AC3 = 0x61632d33, // ac-3
		AAC_ADTS = 0x61647473, // adts
		MPEG4 = 0x6d703466, // mp4f
		M4A = 0x6d346166, // m4af
		CAF = 0x63616666, // caff
		ThreeGP = 0x33677070, // 3gpp
		ThreeGP2 = 0x33677032, // 3gp2
		AMR = 0x616d7266, // amrf
	}
	
	internal enum ErrorCodes : uint
	{
		Unspecified = 0x7768743f, // wht?
		UnsupportedFileType = 0x7479703f, // typ?
		UnsupportedDataFormat = 0x666d743f, // fmt?
		UnsupportedProperty = 0x7074793f, // pty?
		BadPropertySize = 0x2173697a, // !siz
		Permissions = 0x70726d3f, // prm?
		NotOptimized = 0x6f70746d, // optm
		InvalidChunk = 0x63686b3f, // chk?
		DoesNotAllow64BitDataSize = 0x6f66663f, // off?
		InvalidPacketOffset = 0x70636b3f, // pck?
		InvalidFile = 0x6474613f, // dta?
	};
	
	internal enum AudioFileProperty : uint
	{
		FileFormat = 0x66666d74, // ffmt
		DataFormat = 0x64666d74, // dfmt
		IsOptimized = 0x6f70746d, // optm
		MagicCookieData = 0x6d676963, // mgic
		AudioDataByteCount = 0x62636e74, // bcnt
		AudioDataPacketCount = 0x70636e74, // pcnt
		MaximumPacketSize = 0x70737a65, // psze
		DataOffset = 0x646f6666, // doff
		ChannelLayout = 0x636d6170, // cmap
		DeferSizeUpdates = 0x64737a75, // dszu
		DataFormatName = 0x666e6d65, // fnme
		MarkerList = 0x6d6b6c73, // mkls
		RegionList = 0x72676c73, // rgls
		PacketToFrame = 0x706b6672, // pkfr
		FrameToPacket = 0x6672706b, // frpk
		ChunkIDs = 0x63686964, // chid
		InfoDictionary = 0x696e666f, // info
		PacketTableInfo = 0x706e666f, // pnfo
		FormatList = 0x666c7374, // flst
		PacketSizeUpperBound = 0x706b7562, // pkub
		ReserveDuration = 0x72737276, // rsrv
		EstimatedDuration = 0x65647572, // edur
		BitRate = 0x62726174, // brat
	};
	
	internal enum AudioQueueProperty
	{
		IsRunning = 0x6171726e, // aqrn'
		SampleRate = 0x61717372, // aqsr'
		NumberChannels = 0x61716463, // aqdc'
		CurrentDevice = 0x61716364, // aqcd'
		MagicCookie = 0x61716d63, // aqmc'
		MaximumOutputPacketSize = 0x786f7073, // xops'
		StreamDescription = 0x61716674, // aqft'
		ChannelLayout = 0x6171636c, // aqcl'
		EnableLevelMetering = 0x61716d65, // aqme'
		CurrentLevelMeter = 0x61716d76, // aqmv'
		CurrentLevelMeterDB = 0x61716d64, // aqmd'
		DecodeBufferSizeFrames = 0x64636266, // dcbf
	};

	internal enum MarkerType : uint
	{
		kAudioFileMarkerType_Generic = 0,
	};
	
	internal enum RegionFlag : uint
	{
		LoopEnable = 1,
		PlayForward = 2,
		PlayBackward = 4
	};

	internal enum AudioFilePermissions : sbyte
	{
		Read = 0x01,
		Write = 0x02,
		ReadWrite = 0x03
	};
		
	internal enum AudioQueueParameter : uint
	{
	    Volume = 1
	};

	[ StructLayout(LayoutKind.Sequential) ]
	internal struct AudioFramePacketTranslation
	{
		long mFrame;
		long mPacket;
		uint mFrameOffsetInPacket;
	};
	
	[ StructLayout(LayoutKind.Sequential) ]
	internal struct AudioFilePacketTableInfo
	{
        long mNumberValidFrames;
        int mPrimingFrames;
        int mRemainderFrames;
	};

	[ StructLayout(LayoutKind.Sequential) ]
	internal struct AudioStreamBasicDescription
	{
		public double SampleRate;
		public uint FormatID;
		public uint FormatFlags;
		public uint BytesPerPacket;
		public uint FramesPerPacket;
		public uint BytesPerFrame;
		public uint ChannelsPerFrame;
		public uint BitsPerChannel;
		public uint Reserved;
		
		public override string ToString ()
		{
			StringBuilder b = new StringBuilder();
			
			b.AppendLine(&quot;Stream Description&quot;);
			b.AppendLine(&quot;==================&quot;);
			b.AppendLine(&quot;  SampleRate = &quot; + this.SampleRate);
			b.AppendLine(&quot;  FormatID = &quot; + API.ToHex(this.FormatID));
			b.AppendLine(&quot;  FormatFlags = &quot; + API.ToHex(this.FormatFlags));
			b.AppendLine(&quot;  BytesPerPacket = &quot; + this.BytesPerPacket);
			b.AppendLine(&quot;  FramesPerPacket = &quot; + this.FramesPerPacket);
			b.AppendLine(&quot;  BytesPerFrame = &quot; + this.BytesPerFrame);
			b.AppendLine(&quot;  ChannelsPerFrame = &quot; + this.ChannelsPerFrame);
			b.AppendLine(&quot;  BitsPerChannel = &quot; + this.BitsPerChannel);
			b.AppendLine(&quot;&quot;);
			
			return b.ToString();
		}

	};
		
	[ StructLayout(LayoutKind.Sequential) ]
	internal struct SMPTETime
	{
		public short Subframes;
		public short SubframeDivisor;
		public uint Counter;
		public uint Type;
		public uint Flags;
		public short Hours;
		public short Minutes;
		public short Seconds;
		public short Frames;
	};

		
	[ StructLayout(LayoutKind.Sequential) ]
	internal struct AudioTimeStamp
	{
		public double SampleTime;
		public ulong  HostTime;
		public double RateScalar;
		public ulong  WordClockTime;
		public SMPTETime SMPTETime;
		public uint Flags;
		public uint Reserved;
	};

		
	[ StructLayout(LayoutKind.Sequential) ]
	internal unsafe struct AudioQueueBuffer
	{
		public int AudioDataBytesCapacity;
		public byte* AudioData;
		public int AudioDataByteSize;
		public void* UserData;
		public int PacketDescriptionCapacity;
		public AudioStreamPacketDescription* PacketDescriptors;
		public int PacketDescriptorCount;
	};
		
	[ StructLayout(LayoutKind.Sequential) ]
	internal struct AudioStreamPacketDescription
	{
		public long StartOffset;
		public uint VariableFramesInPacket;
		public uint DataByteSize;
	};

	internal class API
	{
		public unsafe delegate void AudioQueueOutputCallback(void* pState, AudioQueue* pQueue, AudioQueueBuffer* pBuffer);
		public unsafe delegate void AudioQueuePropertyChangeCallback(void* pUserData, AudioQueue* pQueue, AudioQueueProperty id);
		internal static object StopLock = new object();
		
		public static string ToHex(uint value)
		{
			StringBuilder builder = new StringBuilder(&quot;0x&quot;);
			builder.Append(Convert.ToString(value, 16).PadLeft(8, '0'));
			return builder.ToString();
		}
		
		public static unsafe void ZeroMemory(void* pBlock, int size)
		{
			byte* p = (byte*) pBlock;
			
			for (int i = 0; i &lt; size; i++, p++)
				*p = 0;
		}
		
		[Conditional(&quot;DEBUG&quot;)]
		public static void CheckStatus(OSStatus status)
		{
			if (status == 0)
				return;
		
			Console.WriteLine(&quot;AudioStream API Failed: Status Code = &quot; + API.ToHex((uint) status));
			
//			throw new Exception(&quot;AudioStream API Failed: Status Code = &quot; + API.ToHex((uint) status));
		}

		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioFileReadPackets(AudioFileID fileID, int useCache, int* numBytesReadFromFile, AudioStreamPacketDescription* packetDesc, long startPacket, int* numPackets, void* outputBuffer);

		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueEnqueueBuffer(AudioQueue* pQueue, AudioQueueBuffer* pBuffer, int numPacketDescs, AudioStreamPacketDescription* pDescriptors);

		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueStop(AudioQueue* pQueue, int immediate);

		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioFileOpenURL(IntPtr inFileRef, AudioFilePermissions inPermissions, AudioFileTypeID inFileTypeHint, AudioFileID* outAudioFile);
			
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueAddPropertyListener(AudioQueue* pQueue, AudioQueueProperty propertyId, AudioQueuePropertyChangeCallback callback, void* pUserData);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioFileGetProperty(AudioFileID fileID, AudioFileProperty propertyId, int* dataSize, void* pResult);
			
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueGetProperty(AudioQueue* pQueue, AudioQueueProperty propertyId, void* pResult, int* dataSize);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueNewOutput(AudioStreamBasicDescription* pFormat, AudioQueueOutputCallback callback, void* pUserData, void* runLoop, void* pRunLoopMode, uint flags, AudioQueue** pQueue);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueAllocateBuffer(AudioQueue* pQueue, int byteCount, AudioQueueBuffer** ppBuffer);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueAllocateBufferWithPacketDescriptions(AudioQueue* pQueue, int byteCount, int descriptorCount, AudioQueueBuffer** ppBuffer);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueSetParameter(AudioQueue* pQueue, AudioQueueParameter paramId, float paramVal);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueStart(AudioQueue* pQueue, AudioTimeStamp* startTime);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueSetProperty(AudioQueue* pQueue, AudioQueueProperty propertyId, void* pCookie, int cookieSize);

		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioFileGetPropertyInfo(AudioFileID fileID, AudioFileProperty propertyId, int* pSize, int* isWritable);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueDispose(AudioQueue* pQueue, int immediate);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioFileClose(AudioFileID fileID);
		
		[ DllImport(Constants.AudioToolboxLibrary) ]
		public static extern unsafe OSStatus AudioQueueFreeBuffer(AudioQueue* pQueue, AudioQueueBuffer* pBuffer);
	}
	
	[ StructLayoutAttribute(LayoutKind.Sequential) ]
	internal unsafe struct AudioStream
	{
		internal AudioFileID AudioFile;
		internal bool IsRunning;
		internal int MaxPacketSize;
			
		internal int BufferByteSize;
		internal AudioQueueBuffer* Buffer0;
		internal AudioQueueBuffer* Buffer1;
		internal AudioQueueBuffer* Buffer2;
			
		internal AudioQueue* Queue;
		internal AudioStreamBasicDescription DataFormat;
		internal long CurrentPacket;
		internal int NumPacketsToRead;
		
		internal bool Looping;
		
		static API.AudioQueueOutputCallback OnReadBuffer = ReadBufferProc;
		static API.AudioQueuePropertyChangeCallback OnPropertyChange = PropertyChangeProc;
		
		[ MonoPInvokeCallback(typeof(API.AudioQueuePropertyChangeCallback)) ]
		static unsafe void PropertyChangeProc(void* pUserData, AudioQueue* pQueue, AudioQueueProperty id)
		{
			lock (API.StopLock)
			{
				try
				{
					PropertyChangeInternal(pUserData, pQueue, id);
				}
				catch (Exception e)
				{
					Console.WriteLine(e.ToString());
				}
			}
		}
			
		static unsafe void PropertyChangeInternal(void* pUserData, AudioQueue* pQueue, AudioQueueProperty id)
		{
			AudioStream* pThis = (AudioStream*) pUserData;
			
			if (pThis == null)
				Console.WriteLine(&quot;PropertyChangeProc: pThis is null&quot;);
			
			if (pQueue == null)
				Console.WriteLine(&quot;PropertyChangeProc: pQueue is null&quot;);
			
			int size = sizeof(uint);
			uint iIsRunning = 0;
			OSStatus status = API.AudioQueueGetProperty(pQueue, AudioQueueProperty.IsRunning, &amp;iIsRunning, &amp;size);
			API.CheckStatus(status);

			bool isRunning = iIsRunning != 0;
			
			if (status == 0)
			{
				if (pThis-&gt;IsRunning &amp;&amp; !isRunning)
					AudioStream.Stop(pThis);
			}
		}
		
		[ MonoPInvokeCallback(typeof(API.AudioQueueOutputCallback)) ]
		static unsafe void ReadBufferProc(void* pUserData, AudioQueue* pQueue, AudioQueueBuffer* pBuffer)
		{
			lock (API.StopLock)
			{
				try
				{
					ReadBufferInternal(pUserData, pQueue, pBuffer);
				}
				catch (Exception e)
				{
					Console.WriteLine(e.ToString());
				}
			}
		}
		
		static unsafe void ReadBufferInternal(void* pUserData, AudioQueue* pQueue, AudioQueueBuffer* pBuffer)
		{
			AudioStream* pThis = (AudioStream*) pUserData;
			
			if (pThis == null)
				Console.WriteLine(&quot;ReadBufferProc: pThis is null&quot;);
			
			if (!pThis-&gt;IsRunning)
				return;
			
			if (pQueue == null)
				Console.WriteLine(&quot;ReadBufferProc: pQueue is null&quot;);
			
			if (pBuffer == null)
				Console.WriteLine(&quot;ReadBufferProc: pBuffer is null&quot;);
			
			if (pBuffer-&gt;AudioData == null)
				Console.WriteLine(&quot;ReadBufferProc: pBuffer-&gt;AudioData is null&quot;);
			
			if (pBuffer-&gt;PacketDescriptors == null)
				Console.WriteLine(&quot;ReadBufferProc: pBuffer-&gt;PacketDescriptors is null&quot;);
			
			if (pThis-&gt;AudioFile == null)
				Console.WriteLine(&quot;ReadBufferProc: pThis-&gt;AudioFile is null&quot;);

			int numPacketsReadFromFile = pThis-&gt;NumPacketsToRead;
			int numBytesReadFromFile = 0;

			OSStatus status = API.AudioFileReadPackets(pThis-&gt;AudioFile, 0, &amp;numBytesReadFromFile, pBuffer-&gt;PacketDescriptors, pThis-&gt;CurrentPacket, &amp;numPacketsReadFromFile, pBuffer-&gt;AudioData);
			API.CheckStatus(status);
			
			if (status == 0 &amp;&amp;
			    numPacketsReadFromFile == 0 &amp;&amp;
			    pThis-&gt;Looping)
			{
				// we ran out of packets and they are
				// asking to loop, so try and reset
				pThis-&gt;CurrentPacket = 0;
				numPacketsReadFromFile = pThis-&gt;NumPacketsToRead;
				numBytesReadFromFile = 0;
				status = API.AudioFileReadPackets(pThis-&gt;AudioFile, 0, &amp;numBytesReadFromFile, pBuffer-&gt;PacketDescriptors, pThis-&gt;CurrentPacket, &amp;numPacketsReadFromFile, pBuffer-&gt;AudioData);
				API.CheckStatus(status);
			}
				
			if (numPacketsReadFromFile &gt; 0)	
			{
				pBuffer-&gt;AudioDataByteSize = numBytesReadFromFile;
				pBuffer-&gt;PacketDescriptorCount = numPacketsReadFromFile;
				
				status = API.AudioQueueEnqueueBuffer(pThis-&gt;Queue, pBuffer, (pBuffer-&gt;PacketDescriptors != null ? pBuffer-&gt;PacketDescriptorCount : 0), pBuffer-&gt;PacketDescriptors);
				API.CheckStatus(status);
				
				pThis-&gt;CurrentPacket += numPacketsReadFromFile;
			}
			else
			{
				status = API.AudioQueueStop(pThis-&gt;Queue, 0);
				API.CheckStatus(status);
			}
		}
			
		static unsafe void DeriveBufferSize(AudioStreamBasicDescription* ASBDesc, int maxPacketSize, double seconds, int* outBufferSize, int* outNumPacketsToRead)
		{
			const int maxBufferSize = 0x10000;
			const int minBufferSize = 0x4000;
			
			if (ASBDesc-&gt;FramesPerPacket != 0)
			{
				double numPacketsForTime = ASBDesc-&gt;SampleRate / ASBDesc-&gt;FramesPerPacket * seconds;
				*outBufferSize = (int) (numPacketsForTime * maxPacketSize);
			}
			else
				*outBufferSize = maxBufferSize &gt; maxPacketSize ? maxBufferSize : maxPacketSize;
			
			if (	*outBufferSize &gt; maxBufferSize &amp;&amp;
				*outBufferSize &gt; maxPacketSize)
			{
				*outBufferSize = maxBufferSize;
			}
			else
			{
				if (*outBufferSize &lt; minBufferSize)
					*outBufferSize = minBufferSize;
			}
				
			*outNumPacketsToRead = *outBufferSize / maxPacketSize;
		}
			
		private static unsafe void OpenFileAndCreateStream(AudioStream* pThis, string url)
		{
			using (NSUrl nsUrl = new NSUrl(url))
			{
				OSStatus status = API.AudioFileOpenURL(nsUrl.Handle, AudioFilePermissions.Read, 0, &amp;pThis-&gt;AudioFile);
				API.CheckStatus(status);
			}
		}
		
		private static unsafe void CreateQueue(AudioStream* pThis)
		{
			int dataFormatSize = sizeof(AudioStreamBasicDescription);
			AudioStreamBasicDescription* pDataFormat = &amp;pThis-&gt;DataFormat;
				
			OSStatus status = API.AudioFileGetProperty(pThis-&gt;AudioFile, AudioFileProperty.DataFormat, &amp;dataFormatSize, pDataFormat);
			API.CheckStatus(status);
			
			status = API.AudioQueueNewOutput(pDataFormat, OnReadBuffer, pThis, null, null, 0, &amp;pThis-&gt;Queue);
			API.CheckStatus(status);
				
			dataFormatSize = sizeof(int);
			int* pMaxPacketSize = &amp;pThis-&gt;MaxPacketSize;
			status = API.AudioFileGetProperty(pThis-&gt;AudioFile, AudioFileProperty.PacketSizeUpperBound, &amp;dataFormatSize, pMaxPacketSize);
			API.CheckStatus(status);
				
			DeriveBufferSize(&amp;pThis-&gt;DataFormat, pThis-&gt;MaxPacketSize, 0.5, &amp;pThis-&gt;BufferByteSize, &amp;pThis-&gt;NumPacketsToRead);
		}
		
		private static unsafe void AllocateAndPrimeBuffers(AudioStream* pThis)
		{
			OSStatus status = API.AudioQueueAllocateBufferWithPacketDescriptions(pThis-&gt;Queue, pThis-&gt;BufferByteSize, pThis-&gt;NumPacketsToRead, &amp;pThis-&gt;Buffer0);
			API.CheckStatus(status);
				
			status = API.AudioQueueAllocateBufferWithPacketDescriptions(pThis-&gt;Queue, pThis-&gt;BufferByteSize, pThis-&gt;NumPacketsToRead, &amp;pThis-&gt;Buffer1);
			API.CheckStatus(status);
				
			status = API.AudioQueueAllocateBufferWithPacketDescriptions(pThis-&gt;Queue, pThis-&gt;BufferByteSize, pThis-&gt;NumPacketsToRead, &amp;pThis-&gt;Buffer2);
			API.CheckStatus(status);
			
			pThis-&gt;IsRunning = true;
			
			if (pThis-&gt;Buffer0 == null)
				Console.WriteLine(&quot;AudioQueueAllocateBufferWithPacketDescriptions failed to allocate buffer0 of size &quot; + pThis-&gt;BufferByteSize);
			
			if (pThis-&gt;Buffer1 == null)
				Console.WriteLine(&quot;AudioQueueAllocateBufferWithPacketDescriptions failed to allocate buffer0 of size &quot; + pThis-&gt;BufferByteSize);
			
			if (pThis-&gt;Buffer2 == null)
				Console.WriteLine(&quot;AudioQueueAllocateBufferWithPacketDescriptions failed to allocate buffer0 of size &quot; + pThis-&gt;BufferByteSize);
			
			ReadBufferProc(pThis, pThis-&gt;Queue, pThis-&gt;Buffer0);
			ReadBufferProc(pThis, pThis-&gt;Queue, pThis-&gt;Buffer1);
			ReadBufferProc(pThis, pThis-&gt;Queue, pThis-&gt;Buffer2);
		}
		
		private static unsafe void CopyPropertyFromFileToQueue(AudioStream* pThis, AudioFileProperty fileProp, AudioQueueProperty queueProp)
		{
			int size = sizeof(uint);
			OSStatus status = API.AudioFileGetPropertyInfo(pThis-&gt;AudioFile, fileProp, &amp;size, null);
			if (status == 0 &amp;&amp; size &gt; 0)
			{
				void* pData = (void*) Marshal.AllocHGlobal(size);
				
				API.AudioFileGetProperty(pThis-&gt;AudioFile, fileProp, &amp;size, pData);
				API.AudioQueueSetProperty(pThis-&gt;Queue, queueProp, pData, size);
				
				Marshal.FreeHGlobal((IntPtr) pData);
			}
		}
		
		internal static void Play(AudioStream* pThis)
		{
			// start the queue
			OSStatus status = API.AudioQueueStart(pThis-&gt;Queue, null);
			API.CheckStatus(status);
		}
		
		internal static void Stop(AudioStream* pThis)
		{
			lock (API.StopLock)
			{
				OSStatus status = API.AudioQueueDispose(pThis-&gt;Queue, 1);
				API.CheckStatus(status);
				
				status = API.AudioFileClose(pThis-&gt;AudioFile);
				API.CheckStatus(status);
				
				Marshal.FreeHGlobal((IntPtr) pThis);
				
				Sound.OnDisposeStream(pThis);
			}
		}
		
		internal static unsafe void SetVolume(AudioStream* pThis, float volume)
		{
			OSStatus status = API.AudioQueueSetParameter(pThis-&gt;Queue, AudioQueueParameter.Volume, volume);
			API.CheckStatus(status);
		}
		
		public unsafe static AudioStream* AllocateStream()
		{
			AudioStream* pThis = (AudioStream*) Marshal.AllocHGlobal(sizeof(AudioStream));
			API.ZeroMemory(pThis, sizeof(AudioStream));
			
			return pThis;
		}
		
		public unsafe static void Create(AudioStream* pThis, string url)
		{
			OpenFileAndCreateStream(pThis, url);
			
			CreateQueue(pThis);
				
			CopyPropertyFromFileToQueue(pThis, AudioFileProperty.MagicCookieData, AudioQueueProperty.MagicCookie);
			CopyPropertyFromFileToQueue(pThis, AudioFileProperty.ChannelLayout, AudioQueueProperty.ChannelLayout);
			
			API.AudioQueueAddPropertyListener(pThis-&gt;Queue, AudioQueueProperty.IsRunning, OnPropertyChange, pThis);
				
			AllocateAndPrimeBuffers(pThis);
		}
		
	}
	
	public unsafe class Sound
	{
		private static bool Running = true;
		private static Queue&lt;Action&gt; WorkItems = new Queue&lt;Action&gt;();
		private static Dictionary&lt;IntPtr, Sound&gt; Map = new Dictionary&lt;IntPtr, Sound&gt;();
		private AudioStream* Stream;
			
		private float _Volume;
		private bool _Looping;
		
		private static void Enqueue(Action workItem)
		{
			lock (Sound.WorkItems)
			{
				Sound.WorkItems.Enqueue(workItem);
				Monitor.Pulse(Sound.WorkItems);
			}
		}
		
		private static void Worker(object state)
		{
			while (Sound.Running)
			{
				Action workItem;
				
				lock (Sound.WorkItems)
				{
					if (Sound.WorkItems.Count == 0)
						Monitor.Wait(Sound.WorkItems);
					
					workItem = Sound.WorkItems.Dequeue();
				}
				
				try
				{
					workItem();
				}
				catch
				{
					Console.WriteLine(&quot;Sound thread: Work Exception&quot;);
				}
			}
		}
		
		static Sound()
		{
			Thread workerThread = new Thread(Worker);
			workerThread.Start();
		}
		
		private Sound(AudioStream* stream)
		{
			this.Stream = stream;
		}
			
		public float Volume
		{
			get { return this._Volume; }
			set
			{
				this._Volume = value;
				
				Sound.Enqueue(() =&gt;
				    {
						lock (Sound.Map)
						{
							if (this.Stream == null)
								return;
		
							AudioStream.SetVolume(this.Stream, value);
						}
					}
				);
			}
		}
			
		public bool Looping
		{
			get { return this._Looping; }
			set
			{
				this._Looping = value;
				
				Sound.Enqueue(() =&gt;
				    {
						lock (Sound.Map)
						{
							if (this.Stream == null)
								return;
							
							this.Stream-&gt;Looping = value;
						}
					}
				);
			}
		}
		
		public void Play()
		{
			Sound.Enqueue(() =&gt;
			    {
					lock (Sound.Map)
					{
						if (this.Stream == null)
							return;
						
						AudioStream.Play(this.Stream);
					}
				}
			);
		}
		
		public void Stop()
		{
			lock (Sound.WorkItems)
			{
				AudioStream.Stop(this.Stream);
			}
		}
		
		public static Sound Create(string url, float volume, bool looping)
		{
			Sound sound = null;
			
			AudioStream* pStream;
			
			lock (Sound.Map)
			{
				pStream = AudioStream.AllocateStream();
				
				sound = new Sound(pStream);
				Sound.Map[(IntPtr) pStream] = sound;
			}
			
			sound.Looping = looping;
			
			Sound.Enqueue(() =&gt; AudioStream.Create(pStream, url));
			
			sound.Volume = volume;
			
			return sound;
		}
		
		public static Sound CreateAndPlay(string url, float volume, bool looping)
		{
			Sound sound = Sound.Create(url, volume, looping);
			
			sound.Play();
			
			return sound;
		}
		
		internal static void OnDisposeStream(AudioStream* pStream)
		{
			lock (Sound.Map)
			{
				Sound sound = null;
				bool exists = Sound.Map.TryGetValue((IntPtr) pStream, out sound);
				
				if (exists)
				{
					Sound.Map.Remove((IntPtr) pStream);
					
					if (sound != null)
						sound.Stream = null;
				}
			}
		}
	}
}
</PRE>













<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000818.html">[MonoTouch] RES: XnaTouch in action
</A></li>
	<LI>Next message: <A HREF="000830.html">[MonoTouch] RES: XnaTouch in action
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#867">[ date ]</a>
              <a href="thread.html#867">[ thread ]</a>
              <a href="subject.html#867">[ subject ]</a>
              <a href="author.html#867">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monotouch">More information about the MonoTouch
mailing list</a><br>
</body></html>
