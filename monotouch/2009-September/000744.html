<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoTouch] SQLite + Monotouch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monotouch%40lists.ximian.com?Subject=%5BMonoTouch%5D%20SQLite%20%2B%20Monotouch&In-Reply-To=46d6fe0a0909071252q59e3e327t8ada410d3ad50bbf%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000743.html">
   <LINK REL="Next"  HREF="000812.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoTouch] SQLite + Monotouch</H1>
    <B>Demis Bellot</B> 
    <A HREF="mailto:monotouch%40lists.ximian.com?Subject=%5BMonoTouch%5D%20SQLite%20%2B%20Monotouch&In-Reply-To=46d6fe0a0909071252q59e3e327t8ada410d3ad50bbf%40mail.gmail.com"
       TITLE="[MonoTouch] SQLite + Monotouch">demis.bellot at gmail.com
       </A><BR>
    <I>Mon Sep  7 16:32:22 EDT 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000743.html">[MonoTouch] SQLite + Monotouch
</A></li>
        <LI>Next message: <A HREF="000812.html">[MonoTouch] SQLite + Monotouch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#744">[ date ]</a>
              <a href="thread.html#744">[ thread ]</a>
              <a href="subject.html#744">[ subject ]</a>
              <a href="author.html#744">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Actually that's funny I also wrote a lightweight ORM wrapper around
SQLite yesterday as well :)

The code is opensource and available here:
<A HREF="http://code.google.com/p/servicestack/source/browse/#svn/trunk/Common/ServiceStack.Common/ServiceStack.OrmLite">http://code.google.com/p/servicestack/source/browse/#svn/trunk/Common/ServiceStack.Common/ServiceStack.OrmLite</A>

It wont be as fast as the example above because it uses the
Mono.Data.dll IDbConnection* abstraction layer instead of hitting the
sqlite lib directly, but it means that you could re-use existing code
that uses other databases.
I've include a complete example below:


	[TestFixture]
	public class SimpleUseCase
	{
		[TestFixtureSetUp]
		public void TestFixtureSetUp()
		{
			//Inject your database provider here
			OrmLiteExtensions.DialectProvider = new SqliteOrmLiteDialectProvider();
		}

		public class User
		{
			public long Id { get; set; }

			[Index]
			public string Name { get; set; }

			public DateTime CreatedDate { get; set; }
		}

		[Test]
		public void Simple_CRUD_example()
		{
			using (IDbConnection db = &quot;:memory:&quot;.OpenDbConnection())
			using (IDbCommand dbCmd = db.CreateCommand())
			{
				dbCmd.CreateTable&lt;User&gt;(false);

				dbCmd.Insert(new User { Id = 1, Name = &quot;A&quot;, CreatedDate = DateTime.Now });
				dbCmd.Insert(new User { Id = 2, Name = &quot;B&quot;, CreatedDate = DateTime.Now });
				dbCmd.Insert(new User { Id = 3, Name = &quot;B&quot;, CreatedDate = DateTime.Now });

				var rowsB = dbCmd.Select&lt;User&gt;(&quot;Name = {0}&quot;, &quot;B&quot;);

				Assert.That(rowsB, Has.Count(2));

				var rowIds = rowsB.ConvertAll(x =&gt; x.Id);
				Assert.That(rowIds, Is.EquivalentTo(new List&lt;long&gt; { 2, 3 }));

				rowsB.ForEach(x =&gt; dbCmd.Delete(x));

				rowsB = dbCmd.Select&lt;User&gt;(&quot;Name = {0}&quot;, &quot;B&quot;);
				Assert.That(rowsB, Has.Count(0));

				var rowsLeft = dbCmd.Select&lt;User&gt;();
				Assert.That(rowsLeft, Has.Count(1));

				Assert.That(rowsLeft[0].Name, Is.EqualTo(&quot;A&quot;));
			}
		}

	}


On Mon, Sep 7, 2009 at 8:52 PM, Frank Krueger&lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">fak at kruegersystems.com</A>&gt; wrote:
&gt;<i> I have a simple wrapper over SQLite that works well for me. You can create
</I>&gt;<i> queries with bound params, and you can perform type-specific selects.
</I>&gt;<i> For example, you can do:
</I>&gt;<i> using (var db = new SQLiteClient.SQLiteConnection(&quot;myfile&quot;)) {
</I>&gt;<i> &#160;&#160; &#160;db.Open();
</I>&gt;<i> &#160;&#160; &#160;//
</I>&gt;<i> &#160;&#160; &#160;// Perform &quot;non-queries&quot;
</I>&gt;<i> &#160;&#160; &#160;//
</I>&gt;<i> &#160;&#160; &#160;db.Execute(&quot;DELETE User WHERE Name = ?&quot;, &quot;Miguel&quot;);
</I>&gt;<i> &#160;&#160; &#160;//
</I>&gt;<i> &#160;&#160; &#160;// Perform strongly typed queries
</I>&gt;<i> &#160;&#160; &#160;//
</I>&gt;<i> &#160;&#160; &#160;var users = db.Query&lt;User&gt;(&quot;SELECT Name FROM User WHERE Id &gt; ?&quot;, 1000);
</I>&gt;<i> &#160;&#160; &#160;foreach (var user in users) {
</I>&gt;<i> &#160;&#160; &#160;&#160;&#160; &#160;Console.WriteLine(user.Name);
</I>&gt;<i> &#160;&#160; &#160;}
</I>&gt;<i> }
</I>&gt;<i> It's not perfect (no support for DateTime, etc.), but should get you
</I>&gt;<i> started.
</I>&gt;<i>
</I>&gt;<i> Here is the code. Consider it released into the public domain. If there's
</I>&gt;<i> interest, I can start a Google code project or something.
</I>&gt;<i>
</I>&gt;<i> using System;
</I>&gt;<i> using System.Runtime.InteropServices;
</I>&gt;<i> using System.Collections.Generic;
</I>&gt;<i> namespace SQLiteClient
</I>&gt;<i> {
</I>&gt;<i> public class SQLiteException : Exception
</I>&gt;<i> {
</I>&gt;<i> public SQLiteException (string message) : base(message)
</I>&gt;<i> {
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> public class SQLiteConnection : IDisposable
</I>&gt;<i> {
</I>&gt;<i> private IntPtr _db;
</I>&gt;<i> private bool _open;
</I>&gt;<i> public string Database { get; set; }
</I>&gt;<i> public SQLiteConnection (string database)
</I>&gt;<i> {
</I>&gt;<i> Database = database;
</I>&gt;<i> }
</I>&gt;<i> public void Open ()
</I>&gt;<i> {
</I>&gt;<i> if (SQLite3.Open (Database, out _db) != SQLite3.Result.OK) {
</I>&gt;<i> throw new SQLiteException (&quot;Could not open database file: &quot; + Database);
</I>&gt;<i> }
</I>&gt;<i> _open = true;
</I>&gt;<i> }
</I>&gt;<i> public SQLiteCommand CreateCommand (string cmdText, params object[] ps)
</I>&gt;<i> {
</I>&gt;<i> if (!_open) {
</I>&gt;<i> throw new SQLiteException (&quot;Cannot create commands from unopened database&quot;);
</I>&gt;<i> } else {
</I>&gt;<i> var cmd = new SQLiteCommand (_db);
</I>&gt;<i> cmd.CommandText = cmdText;
</I>&gt;<i> foreach (var o in ps) {
</I>&gt;<i> cmd.Bind (o);
</I>&gt;<i> }
</I>&gt;<i> return cmd;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> public int Execute (string query, params object[] ps)
</I>&gt;<i> {
</I>&gt;<i> var cmd = CreateCommand (query, ps);
</I>&gt;<i> Console.Error.WriteLine(&quot;Executing &quot; + cmd);
</I>&gt;<i> return cmd.ExecuteNonQuery ();
</I>&gt;<i> }
</I>&gt;<i> public IEnumerable&lt;T&gt; Query&lt;T&gt; (string query, params object[] ps) where T :
</I>&gt;<i> new()
</I>&gt;<i> {
</I>&gt;<i> var cmd = CreateCommand (query, ps);
</I>&gt;<i> return cmd.ExecuteQuery&lt;T&gt; ();
</I>&gt;<i> }
</I>&gt;<i> public void Dispose ()
</I>&gt;<i> {
</I>&gt;<i> if (_open) {
</I>&gt;<i> SQLite3.Close(_db);
</I>&gt;<i> _db = IntPtr.Zero;
</I>&gt;<i> _open = false;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> public class SQLiteCommand
</I>&gt;<i> {
</I>&gt;<i> private IntPtr _db;
</I>&gt;<i> private List&lt;Binding&gt; _bindings;
</I>&gt;<i> public string CommandText { get; set; }
</I>&gt;<i> internal SQLiteCommand (IntPtr db)
</I>&gt;<i> {
</I>&gt;<i> _db = db;
</I>&gt;<i> _bindings = new List&lt;Binding&gt; ();
</I>&gt;<i> CommandText = &quot;&quot;;
</I>&gt;<i> }
</I>&gt;<i> public int ExecuteNonQuery ()
</I>&gt;<i> {
</I>&gt;<i> var stmt = Prepare ();
</I>&gt;<i> var r = SQLite3.Step (stmt);
</I>&gt;<i> if (r == SQLite3.Result.Error) {
</I>&gt;<i> string msg = SQLite3.Errmsg (_db);
</I>&gt;<i> SQLite3.Finalize (stmt);
</I>&gt;<i> throw new SQLiteException (msg);
</I>&gt;<i> } else if (r == SQLite3.Result.Done) {
</I>&gt;<i> int rowsAffected = SQLite3.Changes (_db);
</I>&gt;<i> SQLite3.Finalize (stmt);
</I>&gt;<i> return rowsAffected;
</I>&gt;<i> } else {
</I>&gt;<i> SQLite3.Finalize (stmt);
</I>&gt;<i> throw new SQLiteException (&quot;Unknown error&quot;);
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> public IEnumerable&lt;T&gt; ExecuteQuery&lt;T&gt; () where T : new()
</I>&gt;<i> {
</I>&gt;<i> var stmt = Prepare ();
</I>&gt;<i> var props = GetProps (typeof(T));
</I>&gt;<i> var cols = new System.Reflection.PropertyInfo[SQLite3.ColumnCount (stmt)];
</I>&gt;<i> for (int i = 0; i &lt; cols.Length; i++) {
</I>&gt;<i> cols[i] = MatchColProp (SQLite3.ColumnName (stmt, i), props);
</I>&gt;<i> }
</I>&gt;<i> while (SQLite3.Step (stmt) == SQLite3.Result.Row) {
</I>&gt;<i> var obj = new T ();
</I>&gt;<i> for (int i = 0; i &lt; cols.Length; i++) {
</I>&gt;<i> if (cols[i] == null)
</I>&gt;<i> continue;
</I>&gt;<i> var val = ReadCol (stmt, i, cols[i].PropertyType);
</I>&gt;<i> cols[i].SetValue (obj, val, null);
</I>&gt;<i> }
</I>&gt;<i> yield return obj;
</I>&gt;<i> }
</I>&gt;<i> SQLite3.Finalize (stmt);
</I>&gt;<i> }
</I>&gt;<i> public void Bind (string name, object val)
</I>&gt;<i> {
</I>&gt;<i> _bindings.Add (new Binding {
</I>&gt;<i> Name = name,
</I>&gt;<i> Value = val
</I>&gt;<i> });
</I>&gt;<i> }
</I>&gt;<i> public void Bind (object val)
</I>&gt;<i> {
</I>&gt;<i> Bind (null, val);
</I>&gt;<i> }
</I>&gt;<i> public override string ToString ()
</I>&gt;<i> {
</I>&gt;<i> return CommandText;
</I>&gt;<i> }
</I>&gt;<i> IntPtr Prepare ()
</I>&gt;<i> {
</I>&gt;<i> var stmt = SQLite3.Prepare (_db, CommandText);
</I>&gt;<i> BindAll (stmt);
</I>&gt;<i> return stmt;
</I>&gt;<i> }
</I>&gt;<i> void BindAll (IntPtr stmt)
</I>&gt;<i> {
</I>&gt;<i> int nextIdx = 1;
</I>&gt;<i> foreach (var b in _bindings) {
</I>&gt;<i> if (b.Name != null) {
</I>&gt;<i> b.Index = SQLite3.BindParameterIndex (stmt, b.Name);
</I>&gt;<i> } else {
</I>&gt;<i> b.Index = nextIdx++;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> foreach (var b in _bindings) {
</I>&gt;<i> if (b.Value == null) {
</I>&gt;<i> SQLite3.BindNull (stmt, b.Index);
</I>&gt;<i> } else {
</I>&gt;<i> if (b.Value is Byte || b.Value is UInt16 || b.Value is SByte || b.Value is
</I>&gt;<i> Int16 || b.Value is Int32) {
</I>&gt;<i> SQLite3.BindInt (stmt, b.Index, Convert.ToInt32 (b.Value));
</I>&gt;<i> } else if (b.Value is UInt32 || b.Value is Int64) {
</I>&gt;<i> SQLite3.BindInt64 (stmt, b.Index, Convert.ToInt64 (b.Value));
</I>&gt;<i> } else if (b.Value is Single || b.Value is Double || b.Value is Decimal) {
</I>&gt;<i> SQLite3.BindDouble (stmt, b.Index, Convert.ToDouble (b.Value));
</I>&gt;<i> } else if (b.Value is String) {
</I>&gt;<i> SQLite3.BindText (stmt, b.Index, b.Value.ToString (), -1, new IntPtr (-1));
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> class Binding
</I>&gt;<i> {
</I>&gt;<i> public string Name { get; set; }
</I>&gt;<i> public object Value { get; set; }
</I>&gt;<i> public int Index { get; set; }
</I>&gt;<i> }
</I>&gt;<i> object ReadCol (IntPtr stmt, int index, Type clrType)
</I>&gt;<i> {
</I>&gt;<i> var type = SQLite3.ColumnType (stmt, index);
</I>&gt;<i> if (type == SQLite3.ColType.Null) {
</I>&gt;<i> return null;
</I>&gt;<i> } else {
</I>&gt;<i> if (clrType == typeof(Byte) || clrType == typeof(UInt16) || clrType ==
</I>&gt;<i> typeof(SByte) || clrType == typeof(Int16) || clrType == typeof(Int32)) {
</I>&gt;<i> return Convert.ChangeType (SQLite3.ColumnInt (stmt, index), clrType);
</I>&gt;<i> } else if (clrType == typeof(UInt32) || clrType == typeof(Int64)) {
</I>&gt;<i> return Convert.ChangeType (SQLite3.ColumnInt64 (stmt, index), clrType);
</I>&gt;<i> } else if (clrType == typeof(Single) || clrType == typeof(Double) || clrType
</I>&gt;<i> == typeof(Decimal)) {
</I>&gt;<i> return Convert.ChangeType (SQLite3.ColumnDouble (stmt, index), clrType);
</I>&gt;<i> } else if (clrType == typeof(String)) {
</I>&gt;<i> return Convert.ChangeType (SQLite3.ColumnText (stmt, index), clrType);
</I>&gt;<i> } else {
</I>&gt;<i> throw new NotSupportedException (&quot;Don't know how to read &quot; + clrType);
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> static System.Reflection.PropertyInfo[] GetProps (Type t)
</I>&gt;<i> {
</I>&gt;<i> return t.GetProperties ();
</I>&gt;<i> }
</I>&gt;<i> static System.Reflection.PropertyInfo MatchColProp (string colName,
</I>&gt;<i> System.Reflection.PropertyInfo[] props)
</I>&gt;<i> {
</I>&gt;<i> foreach (var p in props) {
</I>&gt;<i> if (p.Name == colName) {
</I>&gt;<i> return p;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> return null;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> public static class SQLite3
</I>&gt;<i> {
</I>&gt;<i> public enum Result : int
</I>&gt;<i> {
</I>&gt;<i> OK = 0,
</I>&gt;<i> Error = 1,
</I>&gt;<i> Row = 100,
</I>&gt;<i> Done = 101
</I>&gt;<i> }
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_open&quot;)]
</I>&gt;<i> public static extern Result Open (string filename, out IntPtr db);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_close&quot;)]
</I>&gt;<i> public static extern Result Close (IntPtr db);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_changes&quot;)]
</I>&gt;<i> public static extern int Changes (IntPtr db);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_prepare_v2&quot;)]
</I>&gt;<i> public static extern Result Prepare (IntPtr db, string sql, int numBytes,
</I>&gt;<i> out IntPtr stmt, IntPtr pzTail);
</I>&gt;<i> public static IntPtr Prepare (IntPtr db, string query)
</I>&gt;<i> {
</I>&gt;<i> IntPtr stmt;
</I>&gt;<i> if (Prepare (db, query, query.Length, out stmt, IntPtr.Zero) != Result.OK)
</I>&gt;<i> throw new SQLiteException (Errmsg (db));
</I>&gt;<i> return stmt;
</I>&gt;<i> }
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_step&quot;)]
</I>&gt;<i> public static extern Result Step (IntPtr stmt);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_finalize&quot;)]
</I>&gt;<i> public static extern Result Finalize (IntPtr stmt);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_errmsg&quot;)]
</I>&gt;<i> public static extern string Errmsg (IntPtr db);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_bind_parameter_index&quot;)]
</I>&gt;<i> public static extern int BindParameterIndex (IntPtr stmt, string name);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_bind_null&quot;)]
</I>&gt;<i> public static extern int BindNull (IntPtr stmt, int index);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_bind_int&quot;)]
</I>&gt;<i> public static extern int BindInt (IntPtr stmt, int index, int val);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_bind_int64&quot;)]
</I>&gt;<i> public static extern int BindInt64 (IntPtr stmt, int index, long val);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_bind_double&quot;)]
</I>&gt;<i> public static extern int BindDouble (IntPtr stmt, int index, double val);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_bind_text&quot;)]
</I>&gt;<i> public static extern int BindText (IntPtr stmt, int index, string val, int
</I>&gt;<i> n, IntPtr free);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_column_count&quot;)]
</I>&gt;<i> public static extern int ColumnCount (IntPtr stmt);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_column_name&quot;)]
</I>&gt;<i> public static extern string ColumnName (IntPtr stmt, int index);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_column_type&quot;)]
</I>&gt;<i> public static extern ColType ColumnType (IntPtr stmt, int index);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_column_int&quot;)]
</I>&gt;<i> public static extern int ColumnInt (IntPtr stmt, int index);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_column_int64&quot;)]
</I>&gt;<i> public static extern long ColumnInt64 (IntPtr stmt, int index);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_column_double&quot;)]
</I>&gt;<i> public static extern double ColumnDouble (IntPtr stmt, int index);
</I>&gt;<i> [DllImport(&quot;sqlite3&quot;, EntryPoint = &quot;sqlite3_column_text&quot;)]
</I>&gt;<i> public static extern string ColumnText (IntPtr stmt, int index);
</I>&gt;<i> public enum ColType : int
</I>&gt;<i> {
</I>&gt;<i> Integer = 1,
</I>&gt;<i> Float = 2,
</I>&gt;<i> Text = 3,
</I>&gt;<i> Blob = 4,
</I>&gt;<i> Null = 5
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> MonoTouch mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">MonoTouch at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monotouch">http://lists.ximian.com/mailman/listinfo/monotouch</A>
</I>&gt;<i>
</I>&gt;<i>
</I></PRE>













<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000743.html">[MonoTouch] SQLite + Monotouch
</A></li>
	<LI>Next message: <A HREF="000812.html">[MonoTouch] SQLite + Monotouch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#744">[ date ]</a>
              <a href="thread.html#744">[ thread ]</a>
              <a href="subject.html#744">[ subject ]</a>
              <a href="author.html#744">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monotouch">More information about the MonoTouch
mailing list</a><br>
</body></html>
