<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Moonlight-list] GChandles and native/managed interop
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:moonlight-list%40lists.ximian.com?Subject=%5BMoonlight-list%5D%20GChandles%20and%20native/managed%20interop&In-Reply-To=018601c990da%24ae5f6f10%240b1e4d30%24%40com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000246.html">
   <LINK REL="Next"  HREF="000248.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Moonlight-list] GChandles and native/managed interop</H1>
    <B>Chris Toshok</B> 
    <A HREF="mailto:moonlight-list%40lists.ximian.com?Subject=%5BMoonlight-list%5D%20GChandles%20and%20native/managed%20interop&In-Reply-To=018601c990da%24ae5f6f10%240b1e4d30%24%40com"
       TITLE="[Moonlight-list] GChandles and native/managed interop">toshok at gmail.com
       </A><BR>
    <I>Tue Feb 17 12:58:18 EST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000246.html">[Moonlight-list] GChandles and native/managed interop
</A></li>
        <LI>Next message: <A HREF="000248.html">[Moonlight-list] GChandles and native/managed interop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#247">[ date ]</a>
              <a href="thread.html#247">[ thread ]</a>
              <a href="subject.html#247">[ subject ]</a>
              <a href="author.html#247">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Dispose isn't the answer unless we have a &quot;there is only 1 ref left and it
comes from managed code&quot;, but even then there are problems and holes we can
fall into where an unmanaged object lives forever.  The bug basically shifts
from &quot;we don't know when we can delete&quot; to &quot;we don't know when we can
Dispose&quot;.  Delegates complicate things substantially.

An alternative of course is to remove the addrefs in managed land
altogether.  But that seems pretty dangerous, considering sometimes a
managed object is the only thing keeping an unmanaged object alive.

In many cases we can manage lifetime with weakrefs in managed code, there
are just specific instances where we can't (where the managed wrapper
maintains state, or is the sole place where functionality lives, as in
StackPanel.)

Chris

On Tue, Feb 17, 2009 at 12:35 AM, Rolf Bjarne Kvinge &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/moonlight-list">rolflists at ya.com</A>&gt;wrote:

&gt;<i>
</I>&gt;<i> Why can't we get to a &quot;Dispose&quot; call to break the circle?
</I>&gt;<i>
</I>&gt;<i> From what I gathered from irc you came to the conclusion that managed code
</I>&gt;<i> can't manage lifetime (using weakrefs, etc), since objects would get freed
</I>&gt;<i> too early, which only leaves native code to manage lifetime, and then
</I>&gt;<i> &quot;Dispose&quot; is a way to break the circle (and I can't think of any other way
</I>&gt;<i> which wouldn't be the same thing).
</I>&gt;<i>
</I>&gt;<i> Rolf
</I>&gt;<i>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;that involves making unmanaged code additionally deal with GCHandles in
</I>&gt;<i> all
</I>&gt;<i> cases where we accept function pointers now.  I agree we need some
</I>&gt;<i> mechanism
</I>&gt;<i> for cleaning up delegates, but I'm not sure GCHandling everything is the
</I>&gt;<i> way
</I>&gt;<i> to &gt;go. The delegate will be alive as long as the managed object or
</I>&gt;<i> unmanaged peer is alive. When the unmanaged peer dies, the GCHandle will be
</I>&gt;<i> deallocated in unmanaged.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;But see, that doesn't work.  The unmanaged peer will never die when it's
</I>&gt;<i> holding a GCHandle to a delegate which is keeping the managed instance
</I>&gt;<i> alive, which holds a ref to the unmanaged peer. We can't even get to a
</I>&gt;<i> &quot;Dispose&quot; call in order to clean up the delegates and break refs in this
</I>&gt;<i> scenario.  The instant we pass a delegate to unmanaged code (be it in
</I>&gt;<i> GCHandle form or after storing it in an instance field of the managed
</I>&gt;<i> object), we're screwed at present.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;Chris
</I>&gt;<i> &gt;&gt;On Mon, Feb 16, 2009 at 2:44 AM, Alan McGovern &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/moonlight-list">alan.mcgovern at gmail.com</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;<i> &gt;&gt;Hey,
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;So the next iteration of the idea would be to register a GCHandle which
</I>&gt;<i> holds the delegate instead of the delegate itself (or something similar).
</I>&gt;<i> Then the same principle holds true. The delegate will be alive as long as
</I>&gt;<i> the managed &gt;&gt;object or unmanaged peer is alive. When the unmanaged peer
</I>&gt;<i> dies, the GCHandle will be deallocated in unmanaged. Managed code won't
</I>&gt;<i> have
</I>&gt;<i> to care about the GCHandle as long as a unique GCHandle is passed to native
</I>&gt;<i> every time a &gt;&gt;&gt;delegate is passed to native.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;Alan.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;On Mon, Feb 16, 2009 at 6:49 AM, Chris Toshok &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/moonlight-list">toshok at gmail.com</A>&gt; wrote:
</I>&gt;<i> &gt;&gt;&gt;It really isn't that easy.  Just one of the interesting cases: we have
</I>&gt;<i> many places where unmanaged code is passed delegates which reference the
</I>&gt;<i> same object.  So we have circular refs between unmanaged and managed peers
</I>&gt;<i> which &gt;aren't &gt;&gt;direct.  We really need a system that can treat either as
</I>&gt;<i> the root.  Anything else is going to be unable to handle things properly.
</I>&gt;<i> &gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;chris
</I>&gt;<i> &gt;&gt;&gt;On Fri, Feb 13, 2009 at 3:14 AM, Alan McGovern &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/moonlight-list">alan.mcgovern at gmail.com</A>
</I>&gt;<i> &gt;
</I>&gt;<i> wrote:
</I>&gt;<i> &gt;&gt;&gt;&gt;Hey guys,
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;I've been thinking about the issue and I think one way to solve it
</I>&gt;<i> would
</I>&gt;<i> be to always have unmanaged own the handle. What I'm thinking is this:
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;1) If managed holds a reference to the object, then it'll live
</I>&gt;<i> regardless of GCHandle status
</I>&gt;<i> &gt;&gt;&gt;&gt;2) If unmanaged holds a GCHandle, unmanaged will keep it alive
</I>&gt;<i> regardless of what managed does.
</I>&gt;<i> &gt;&gt;&gt;&gt;3) If managed has no reference to the object and unmanaged drops its
</I>&gt;<i> reference, then the object is safe to be GC'ed.
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;So to implement that logic all we really need to do is to allocate a
</I>&gt;<i> GCHandle every time we pass a managed object to native and always let
</I>&gt;<i> native
</I>&gt;<i> clean up the handle. So whenever we destroy a Value * we should deallocate
</I>&gt;<i> the &gt;&gt;&gt;&gt;GCHandle if that's the last reference to the GCHandle that
</I>&gt;<i> unmanaged
</I>&gt;<i> has.
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;Does that make sense or have I missed some important case?
</I>&gt;<i> &gt;&gt;&gt;&gt;
</I>&gt;<i> &gt;&gt;&gt;&gt;Alan.
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Moonlight-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/moonlight-list">Moonlight-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/moonlight-list">http://lists.ximian.com/mailman/listinfo/moonlight-list</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> No virus found in this incoming message.
</I>&gt;<i> Checked by AVG - www.avg.com
</I>&gt;<i> Version: 8.0.234 / Virus Database: 270.10.23/1951 - Release Date: 02/13/09
</I>&gt;<i> 06:51:00
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/moonlight-list/attachments/20090217/a26d300f/attachment.html">http://lists.ximian.com/pipermail/moonlight-list/attachments/20090217/a26d300f/attachment.html</A> 
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000246.html">[Moonlight-list] GChandles and native/managed interop
</A></li>
	<LI>Next message: <A HREF="000248.html">[Moonlight-list] GChandles and native/managed interop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#247">[ date ]</a>
              <a href="thread.html#247">[ thread ]</a>
              <a href="subject.html#247">[ subject ]</a>
              <a href="author.html#247">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/moonlight-list">More information about the Moonlight-list
mailing list</a><br>
</body></html>
