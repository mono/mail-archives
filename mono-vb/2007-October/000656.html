<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [mono-vb] A tool to have MSBuild use the Mono compilers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-vb%40lists.ximian.com?Subject=%5Bmono-vb%5D%20A%20tool%20to%20have%20MSBuild%20use%20the%20Mono%20compilers&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000657.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[mono-vb] A tool to have MSBuild use the Mono compilers</H1>
    <B>Andy Hume</B> 
    <A HREF="mailto:mono-vb%40lists.ximian.com?Subject=%5Bmono-vb%5D%20A%20tool%20to%20have%20MSBuild%20use%20the%20Mono%20compilers&In-Reply-To="
       TITLE="[mono-vb] A tool to have MSBuild use the Mono compilers">andyhume32 at yahoo.co.uk
       </A><BR>
    <I>Fri Oct 12 07:18:43 EDT 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000657.html">[mono-vb] Webservice In VB.Net Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#656">[ date ]</a>
              <a href="thread.html#656">[ thread ]</a>
              <a href="subject.html#656">[ subject ]</a>
              <a href="author.html#656">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I've seen requests in the past for how to have MSBuild use the Mono compilers.  I attach a tool to allow this.  It can be useful in troubleshooting to find whether a problem is with xbuild/monodevelop or with the compiler etc.


[[
//
// Copyright (c) 2007 Andy Hume.
// No restrictions, free for any use.
//

//==============================================================================

//
// This tool configures MSBuild to use the Mono compilers.  This can be useful 
// in some situations.  For instance I had an issue where neither xbuild nor 
// monodevelop would compile a project, but on using this tool the issue was shown 
// to be a compiler issue.
// 
// Two parts are needed, firstly a .targets file to configure MSBuild to look in 
// a new location for the compilers.  The second part is an executable that fulfills 
// two purposes, firstly MSBuild still looks for compiler filenames csc.exe and 
// vbc.exe.  But secondly, neither of the Mono compilers support all the command-
// line options used by the MSFT tools, nor are all the assemblies supported, so 
// we strip or convert both these -- for details see the code below.
//
// Note the MSFT versions of the other compiler utilities are still used e.g. resgen
// etc.
//


//
// So to use this tool, compile this program creating csc.exe and vbc.exe (e.g. 
// compile it to csc.exe and copy it to vbc.exe).  Then take the xml content below, 
// update the paths and save it to e.g. Mono.Compilers.targets.
//
/*
&lt;Project 
    DefaultTargets=&quot;Build&quot; 
    xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003&quot;">http://schemas.microsoft.com/developer/msbuild/2003&quot;</A>&gt;

  &lt;!-- Based on:
	<A HREF="http://blogs.msdn.com/jomo_fisher/archive/2005/08/31/458658.aspx">http://blogs.msdn.com/jomo_fisher/archive/2005/08/31/458658.aspx</A>
   --&gt;

  &lt;!-- Use with:
        msbuild /p:CustomAfterMicrosoftCommonTargets=&quot;D:\Temp\MonoMsbuild\Mono.Compilers.targets&quot;  MySolution.sln
     Note: the targets file path must be absolute and there is no warning if the 
     file isn't found.
  --&gt;

  &lt;PropertyGroup&gt;
    &lt;CscToolPath&gt;D:\Temp\MonoMsbuild&lt;/CscToolPath&gt;
    &lt;VbcToolPath&gt;D:\Temp\MonoMsbuild&lt;/VbcToolPath&gt;
    &lt;UseHostCompilerIfAvailable&gt;false&lt;/UseHostCompilerIfAvailable&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
 */
//
// That targets file can then be included in a MSBuild project to have it use the 
// Mono compilers.  One way is to use a command-line of the following form:
//
//   Msbuild /p:CustomAfterMicrosoftCommonTargets=&quot;D:\Temp\Mono.Compilers.targets&quot;  MySolution.sln
//
// Note: the targets file path must be absolute and there is no warning if the 
// file isn't found.
//
// It is also possible to reference the file from the project file.  It is further 
// possible to always include that .targets file and make the content of the .targets 
// file itself conditional and thus the Mono compilers are used only when a certain 
// command-line flag is set -- this is how MSBee, the MSBuild FX1.1 builder from 
// <A HREF="http://www.codeplex.com/MSBee,">http://www.codeplex.com/MSBee,</A> is configured.
//
//
// * How do I know it's working?
// The tool logs the changes it makes to the compiler options, so see warnings 
// in the MSBuild output like:
//    MsBMono : warning XXX999: Was: &lt;&lt;.........&gt;&gt;
//    MsBMono : warning XXX999: Is now: &lt;&lt;.........&gt;&gt;
// And if using the up-to-date vbnc case, see below, see also:
//    VBC : warning : VBNC2009: the option doc was not recognized - ignored
//

//==============================================================================

//
// * Changes
// The three VBNC bugs mentioned below are all fixed (&gt;=r86687), so those pieces of
// functionality are unnecessary in the tool, so if using an up-to-date version
// of vbnc, then in UnsupportedOptionsVbnc you must comment-out &quot;define&quot; and may
// comment-out &quot;doc&quot;.
//



//
// What this program does.  Firstly, as noted above the compilers must be files 
// named csc.exe and vbc.exe.  Secondly it handles mapping command-line options 
// and assemblies to forms supported by Mono.
//
// The command-line passed from MSBuild is always of the simple form:
//
//  &quot;absolute\path\compiler.exe&quot;  /noconfig @&quot;absolute\path\rspfile.tmp&quot;
//
// From that we parse the compiler name, &quot;csc&quot; or &quot;vbc&quot;, and also the path to the 
// response file, and in the end I we execute e.g.
//
//  &quot;gmcs.bat&quot;  /noconfig @&quot;absolute\path\rspfile.tmp&quot;
//
// However, as noted above we need to modify the command-line options which are 
// passed in the rsp file.  For example gmcs doesn't support /errorprompt and vbnc 
// doesn't support /doc (though it says it ignores it (bug 325332).  For options 
// in this category we just cut them to the first space character, but leave them 
// in place it any quote is found.
//
// However there is also one option that needs special-case handling.  VB's &quot;Compiler 
// Constants&quot; (#defines) support values possibly including spaces, thus the command-
// line option used by MSBuild is doubly-quoted, eg:
//
//  /define:&quot;AA=\&quot;aaa\&quot;,BB=-1,CC=\&quot;ccc\&quot;
//
// However vbnc doesn't support this form (bug 325976), so we map this into a supported 
// form where possible.
//
// As well as options, we also support removing unsupprted assemblies.  The assembly 
// System.Deployment.dll is referenced by Visual Studio Windows Forms projects 
// however Mono doesn't include it, by default it isn't used and we can thus remove 
// its reference.
//
// There is one remaining feature that could be added.  In its current state vbnc 
// reports many of its errors in raw for or just as exception output and thus because 
// these are not reported in the standard error format xbuild, monodevelop, and 
// MSBuild all discard these errors and don't report them to the user (bug 328106).
// The tool could be enhanced by detecting such raw errors and prefixing them with 
// a correctly formatted error prefix such as:
//
//     MonoMsbuild: unhandled error MMB000: 
//
// See <A HREF="http://channel9.msdn.com/wiki/default.aspx/MSBuild.CanonicalErrorWarningSpec">http://channel9.msdn.com/wiki/default.aspx/MSBuild.CanonicalErrorWarningSpec</A>
// and <A HREF="http://blogs.msdn.com/msbuild/archive/2006/11/03/msbuild-visual-studio-aware-error-messages-and-message-formats.aspx">http://blogs.msdn.com/msbuild/archive/2006/11/03/msbuild-visual-studio-aware-error-messages-and-message-formats.aspx</A> 
//



//==============================================================================

using System;
using System.Diagnostics;
using System.IO;
using System.Windows.Forms;
using System.Text.RegularExpressions;


static class CscVbcCallMonoEquivalent
{
    //
    // The paths to the Mono compilers, if they're in the path then no path is needed
    // for them here just &quot;gmcs.bat&quot; etc will suffice.
    //
    const string GmcsPath = @&quot;gmcs.bat&quot;;
    const string VbncPath = @&quot;vbnc.bat&quot;;
    // TODO ?Read these from somewhere.
    //const string GmcsPath = @&quot;D:\Program Files\Mono-1.2.5\bin\gmcs.bat&quot;;
    //const string VbncPath = @&quot;D:\Program Files\Mono-1.2.5\bin\vbnc.bat&quot;;

    //
    // The command-line options not supported by each of the Mono compilers.
    //
    static readonly String[] UnsupportedOptionsGmcs = {
        // &lt;&lt;error CS2007: Unrecognized command-line option: `/errorreport:prompt'&gt;&gt;
        &quot;errorreport&quot;,
    };

    static readonly String[] UnsupportedOptionsVbnc = {
        // vbnc can't handle quoted /define values in rsp files.  With this content:
        // &lt;&lt;/define:&quot;CONFIG=\&quot;Release\&quot;,TRACE=-1,_MyType=\&quot;WindowsForms\&quot;,PLATFORM=\&quot;AnyCPU\&quot;&quot; &gt;&gt;
        // it produces
        // &lt;&lt;An error message should have been shown: 'Invalid string constant: &quot;AnyCPU&quot;&quot; /reference:..\MyAsmbly.dll&gt;&gt;
        // We strip all the quotes here.  Hope there's no spaces etc!
        &quot;define&quot;,
        // &lt;&lt;Error : VBNC2009: the option doc was not recognized - ignored&gt;&gt;
        // Says ignored but isn't!
        &quot;doc&quot;,
        // Is supported &quot;errorreport&quot;,
    };

    //
    // Any assembly references we should remove.  For example System.Deployment.dll
    // seems to be added by default for WinForms apps created in VS but it isn't used
    // by default, Mono doesn't include it so we need to remove its reference.
    //
    static readonly String[] UnsupportedAssemblies = {
        &quot;System.Deployment.dll&quot;
    };

    //----
    // The format of the command-line used by MSBuild when running the compiler.
    // Examples are
    // &lt;&lt;&quot;C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\Csc.exe&quot;  /noconfig @&quot;C:\Documents and Settings\andy\Local Settings\Temp\tmpEE.tmp&quot;&gt;&gt;
    // &lt;&lt;&quot;C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\Vbc.exe&quot;  /noconfig @&quot;C:\Documents and Settings\andy\Local Settings\Temp\tmp76.tmp&quot;&gt;&gt;
    // The real compiler options are passed in the rsp file.
    const string MsBuildExecRxStr = &quot;\&quot;.*\\\\([^\\\\]+).exe\&quot;?  /noconfig @\&quot;([^\\\&quot;]+)\&quot;&quot;;

    //----
    static string s_dbgDescr;

    //----
    static int Main()
    {
        try {
            //Info(   &quot;Iaaaaaaaa&quot;);
            //Warning(&quot;Waaaaaaaa&quot;);
            //RegexPlaying(RxStr);
            //TestCountInstances();
            //Console.WriteLine(&quot;----&quot;);

            //----
            // Parse the compiler (csc/vbc) and the rsp file passed.
            string cl = Environment.CommandLine;
            //Info(&quot;&lt;&lt;cl: &quot; + cl + &quot;&gt;&gt;&quot;);
            string compiler, rspFilePath;
            ParseCmdLine(cl, out compiler, out rspFilePath);
            s_dbgDescr = compiler + &quot;-&gt;&quot; + rspFilePath;

            // Use that information to configure ourselves.
            string compilerPath;
            string[] badOptions;
            switch (compiler.ToLowerInvariant()) {
                case &quot;csc&quot;:
                    compilerPath = GmcsPath;
                    badOptions = UnsupportedOptionsGmcs;
                    break;
                case &quot;vbc&quot;:
                    compilerPath = VbncPath;
                    badOptions = UnsupportedOptionsVbnc;
                    break;
                default:
                    Error(&quot;Unknown compiler '&quot; + compiler + &quot;'.&quot;);
                    throw new ArgumentException();
            }

            //----
            // Recreate the rsp file with options to suit the equivalent Mono compiler.
            CleanOptionsFile(badOptions, rspFilePath);

            //----
            // Now run the Mono compiler.
            string argsString = GetArgsString();
            ProcessStartInfo psi = new ProcessStartInfo(compilerPath, argsString);
            psi.UseShellExecute = false;
            try {
                using (Process proc = Process.Start(psi)) {
                    proc.WaitForExit();
                    return proc.ExitCode;
                }//using
            } catch (System.ComponentModel.Win32Exception winex) {
                // Make a better message...
                throw new System.ComponentModel.Win32Exception(&quot;Failed to run the compiler, probably exe/bat file not found.&quot;, winex);
            }
        } catch (Exception ex) {
            //ErrorNoExit(ex.ToString());
            //throw;
            Error(ExceptionToStringMessage(ex));
            throw new InvalidOperationException(&quot;Internal error -- Reached end of catch&quot;);
        }
    }
    
    /// &lt;summary&gt;
    /// Get the first line of the exception ToString -- i.e. containing the type and message,
    /// and the same for all 'inner' exceptions.
    /// &lt;/summary&gt;
    static string ExceptionToStringMessage(Exception ex)
    {
        System.Diagnostics.Debug.Assert(ex != null, &quot;ExceptionToStringMessage--ArgNullEx&quot;);
        int end = -1;
        string message = ex.ToString();
        end = message.IndexOf('\n');
        int tmp = message.IndexOf('\r');
        if (tmp != -1 &amp;&amp; tmp &lt; end) { end = tmp; }
        if (end &gt; -1) {
            message = message.Substring(0, end);
        }
        System.Diagnostics.Debug.Assert(message.IndexOfAny(new char[]{'\n','\r'}) == -1);
        return message;
    }

    enum MessageLevel
    {
        None = 0,
        // ToString'd on output, so nicer if lower case
        error, 
        warning,
        info
    }

    static void ErrorNoExit(string message)
    {
        WriteErrorMessage(MessageLevel.error, message);
    }

    static void Error(string message)
    {
        ErrorNoExit(message);
        Environment.Exit(1);
    }

    static void Warning(string message)
    {
        MessageBox.Show(message, s_dbgDescr);
        WriteErrorMessage(MessageLevel.warning, message);
    }

    static void Info(string message)
    {
        // Info level messages are not displayed, so write as Warning.
        WriteErrorMessage(MessageLevel.warning, message);
    }

    const string ToolName = &quot;MsBMono&quot;;

    static void WriteErrorMessage(MessageLevel category, string text)
    {
        WriteErrorMessage(ToolName, null, category, &quot;XXX999&quot;, text);
    }
    
    static void WriteErrorMessage(string origin, string subcategory, MessageLevel category, 
        string errorCode, string text)
    {
        System.Text.StringBuilder bldr = new System.Text.StringBuilder();
        if(!String.IsNullOrEmpty(origin)) {
            bldr.Append(origin).Append(&quot;: &quot;);
        }
        if(!String.IsNullOrEmpty(subcategory)) {
            bldr.Append(subcategory).Append(&quot; &quot;);
        }
        bldr.Append(category.ToString()).Append(&quot; &quot;);
        System.Diagnostics.Debug.Assert(!String.IsNullOrEmpty(errorCode));
        System.Diagnostics.Debug.Assert(!String.IsNullOrEmpty(errorCode.Trim()));
        bldr.Append(errorCode).Append(&quot;:&quot;);
        if(!String.IsNullOrEmpty(text)) {
            bldr.Append(&quot; &quot;).Append(text);
        }
        string msg = bldr.ToString();
        // Test for validity against MSBuild's regex.
        // (It doesn't allow 'info' etc, so only test for certain levels).
        if(category == MessageLevel.warning || category == MessageLevel.error) {
            System.Diagnostics.Debug.Assert(originCategoryCodeTextExpression.Match(msg).Success);
        }
        Console.WriteLine(msg);
    }
    
    // From the MSBuild wiki at channel9.  This is apparently the pattern MSBuild
    // uses to check if a compiler output line is a well-formed error message.
    // Defines the main pattern for matching messages.
    static private Regex originCategoryCodeTextExpression = new Regex(
        // Beginning of line and any amount of whitespace.
        @&quot;^\s*&quot;
        // Match a [optional project number prefix 'ddd&gt;'], single letter + colon + remaining filename, or
        // string with no colon followed by a colon.
        +@&quot;(((?&lt;ORIGIN&gt;(((\d+&gt;)?[a-zA-Z]?:[^:]*)|([^:]*))):)&quot;
        // Origin may also be empty. In this case there's no trailing colon.
        +&quot;|())&quot;
        // Match the empty string or a string without a colon that ends with a space
        +&quot;(?&lt;SUBCATEGORY&gt;(()|([^:]*? )))&quot;
        // Match 'error' or 'warning' followed by a space.
        +&quot;(?&lt;CATEGORY&gt;(error|warning)) &quot;
        // Match anything without a colon, followed by a colon
        +&quot;(?&lt;CODE&gt;[^:]*):&quot;
        // Whatever's left on this line, including colons.
        +&quot;(?&lt;TEXT&gt;.*)$&quot;,
        RegexOptions.IgnoreCase);


    static void CleanOptionsFile(string[] badOptionsNames, string rspPath)
    {
#if false  // test exception handling
        try {
            throw new RankException(&quot;Iiiii iiii.&quot;);
        } catch(Exception ex) {
            throw new InvalidOperationException(&quot;Eee eeee eeee.&quot;, ex);
        }
#endif
    
        string content;
        using (StreamReader rdr = File.OpenText(rspPath)) {
            content = rdr.ReadToEnd();
        }
        Info(   &quot;Was: &lt;&lt;&quot; + content + &quot;&gt;&gt;&quot;);
        content = RemoveUnsupportedArgsEtc(badOptionsNames, content);
        Info(&quot;Is now: &lt;&lt;&quot; + content + &quot;&gt;&gt;&quot;);
        using (StreamWriter wtr = File.CreateText(rspPath)) {
            wtr.Write(content);
        }
    }


    static void ParseCmdLine(string cmdLine, out string compiler,
        out string rspFilePath)
    {
        //compiler = &quot;csc&quot;;
        //rspFilePath = &quot;tmpB8.tmp.txt&quot;;
        Regex rx = new Regex(MsBuildExecRxStr);
        Match m = rx.Match(cmdLine);
        if (!m.Success) {
            Error(@&quot;Command-line not in expected &quot;
               + @&quot;{&quot;&quot;&lt;path&gt;\&lt;CCC&gt;.exe&quot;&quot;  /noconfig @&quot;&quot;&lt;rspFilePath&gt;&quot;&quot;} format.&quot;);
        }
        //DiagPrintMatch(m);
        if (m.Groups.Count != 3) {
            Error(&quot;Command-line regex didn't find two groups.&quot;);
        }
        //CaptureCollection cc = g.Captures;
        compiler = m.Groups[1].Captures[0].Value;
        rspFilePath = m.Groups[2].Captures[0].Value;
    }


    /// &lt;summary&gt;Gets the command-line argument as the original string.
    /// Uses &lt;see cref=&quot;P:System.Environment.CommandLine&quot;/&gt; but removes
    /// the program name from the front.
    /// &lt;/summary&gt;
    static string GetArgsString()
    {
        string[] cmdArray = Environment.GetCommandLineArgs();
        string cl = Environment.CommandLine;
        string argsString;
        string cmd = cmdArray[0];
        int idx = cl.IndexOf(cmd);
        //Console.WriteLine(&quot;idx: {0}&quot;, idx);
        if (idx == -1) {
            Error(&quot;cmd not in command-line&quot;);
            throw new ArgumentException();
        }
        int posArgs;
        if (idx == 0) {
            posArgs = cmd.Length + 0 + 1;
        } else if (idx == 1) {
            //Console.WriteLine(&quot;cl0: {0}, clX:{1}&quot;, cl[0], cl[cmd.Length + 2 - 1]);
            if (cl[0] == '&quot;' &amp;&amp; cl[cmd.Length + 2 - 1] == '&quot;'
                   &amp;&amp; cl[cmd.Length + 2 - 1 + 1] == ' ') {
                posArgs = cmd.Length + 2 + 2;
            } else {
                Error(&quot;GetArgsString unsupported#1&quot;);
                throw new ArgumentException();
            }
        } else {
            Error(&quot;GetArgsString unsupported#2&quot;);
            throw new ArgumentException();
        }
        // Remove the program and leave only the arguments.
        argsString = cl.Substring(posArgs) + &quot; &quot;;
        return argsString;
    }


    static string RemoveUnsupportedArgsEtc(string[] badOptionsNames,
       String argsString)
    {
        argsString = RemoveUnsupportedOptions(badOptionsNames, argsString);

        //
        // Remove absolute path to FCL assemblies...
        //
        string Windir = Environment.GetEnvironmentVariable(&quot;windir&quot;); // @&quot;C:\WINDOWS&quot;;
        string fclPath = Path.Combine(Windir,
            @&quot;Microsoft.NET\Framework\v2.0.50727\&quot;);
        // Remove this assert if your windows directory is not C:\WINDOWS.
        System.Diagnostics.Trace.Assert(fclPath
          == @&quot;C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\&quot;);
        argsString = argsString.Replace(fclPath, null);

        //
        // Remove unsupported assemblies -- not crucial hopefully...
        //
        foreach (string badAsmbly in UnsupportedAssemblies) {
            // csc: one ref per /reference: option
            argsString = argsString.Replace(&quot;/reference:&quot; + badAsmbly, null);
            // vbc: list of refs in one /reference: option
            argsString = argsString.Replace(&quot;,&quot; + badAsmbly + &quot;,&quot;, &quot;,&quot;);
        }
        //
        return argsString;
    }


    static string RemoveUnsupportedOptions(string[] badOptionsNames,
       String argsString)
    {
        // Remove unsupported options
        // First calculate what to do and finally do it.
        if (badOptionsNames != null) {
            foreach (string badOptName in badOptionsNames) {
                // Remove from /optionName to terminating space
                int idxOption = argsString.IndexOf(&quot;/&quot; + badOptName);
                if (idxOption == -1) { continue; }
                int idxEnd = argsString.IndexOf(&quot; &quot;, idxOption);
                if (idxEnd == -1) {
                    // ?Either error, or its the last option, so chop to the end.
                    Error(&quot;Strip option but no end space.&quot;);
                }
                string cut = argsString.Substring(idxOption, idxEnd - idxOption);
                string replace = null;
                //
                // Special case: /define for VB
                if (badOptName == &quot;define&quot;) {
                    // Convert /define:&quot;a=\&quot;a\&quot;,b=\&quot;b\&quot;&quot; to /define:a=a,b=b
                    // Needs to be in that simple form...
                    // First the inner backslash-quoted quotes.
                    int _countOfValueQuoting = CountInstances(cut, &quot;\\\&quot;&quot;); // a=\&quot;aaa\&quot;
                    if ((_countOfValueQuoting &amp; 1) == 1) {
                        Warning(&quot;/define, odd number of value quotings.&quot;);
                        continue;
                    }
                    replace = cut.Replace(&quot;\\\&quot;&quot;, null);
                    // Now the other quotes.
                    int countOfQuotes = CountInstances(cut, &quot;\&quot;&quot;); // /define:&quot;a=\&quot;aaa\&quot;&quot;
                    if ((countOfQuotes &amp; 1) == 1) {
                        Warning(&quot;/define, odd number of option quotes.&quot;);
                        continue;
                    }
                    replace = replace.Replace(&quot;\&quot;&quot;, null);
                } else if (cut.Contains(&quot;\&quot;&quot;)) {
                    // More work to do here?  Do we need to support general 
                    // options with spaces and quoting etc.
                    // /doc doesn't generally, so we're ok so far...
                    // 
                    Warning(&quot;Skipping removing option as its value is string delimited&quot;);
                    continue;
                }
                //
                // Now actually do the cut/replace.
                Info(&quot;gonna cut: &lt;&lt;&quot; + cut + &quot;&gt;&gt;&quot; + (replace == null ? null
                        : &quot; ** and put: &lt;&lt;&quot; + replace + &quot;&gt;&gt;&quot;));
                string join = argsString.Substring(0, idxOption)
                   + replace + argsString.Substring(idxEnd);
                argsString = join;
            }
        }
        return argsString;
    }
    
    /// &lt;summary&gt;
    /// Count the instances of a string in a given string value -- this is not otherwise
    /// supported AFAIK.
    /// &lt;/summary&gt;
    static int CountInstances(/*this*/ string thisParam, string value)
    {
        int count = 0;
        int pos = 0;
        while (true) {
            int idx = thisParam.IndexOf(value, pos);
            if (idx == -1) { break; }
            ++count;
            pos = idx + value.Length;
            if (pos &gt;= thisParam.Length) { break; }
        }//while
        return count;
    }
    static void TestCountInstances()
    {
        string[][] values = {
            new string[] { &quot;/define:\&quot;a=\\\&quot;A\\\&quot;,b=\\\&quot;B\\\&quot;,c=\\\&quot;C\\\&quot;&quot;, &quot;\\\&quot;&quot;, 6.ToString() },
            new string[] { &quot;/define:\&quot;a=A,b=\\\&quot;B\\\&quot;,c=C&quot;, &quot;\\\&quot;&quot;, 2.ToString() },
            new string[] { &quot;/define:\&quot;aaa\\\&quot;&quot;, &quot;\\\&quot;&quot;, 1.ToString() },
            new string[] { &quot;/define:\&quot;a=A,b=B,c=C\&quot;&quot;, &quot;\\\&quot;&quot;, 0.ToString() },
        };
        foreach (string[] cur in values) {
            int count = CountInstances(cur[0], cur[1]);
            Console.WriteLine(&quot;{0} {1}: {2} {3}&quot;,
            count == int.Parse(cur[2]), count, cur[0], cur[1]
            );
        }//for
    }


    static void RegexPlaying(string rxStr)
    {
        Regex rx = new Regex(rxStr);
        Console.WriteLine(&quot;rxStr: &quot; + rxStr);

        string tst = &quot;\&quot;C:\\Temp\\Csc.exe\&quot;  /noconfig @\&quot;C:\\Temp\\tmpEE.tmp\&quot;&quot;;
        Console.WriteLine(&quot;tst: &quot; + tst);
        Match m = rx.Match(tst);
        Console.WriteLine(&quot;m: &quot; + m);
        DiagPrintMatch(m);

        Console.WriteLine();
        tst = &quot;\&quot;C:\\Temp\\XXXX YYY\\Csc.exe\&quot;  /noconfig @\&quot;C:\\Temp\\tmpEE.tmp\&quot;&quot;;
        Console.WriteLine(&quot;tst: &quot; + tst);
        m = rx.Match(tst);
        Console.WriteLine(&quot;m: &quot; + m);
        DiagPrintMatch(m);

        Console.WriteLine();
        tst = &quot;Csc.exe  /noconfig @\&quot;C:\\Temp\\tmpEE.tmp\&quot;&quot;;
        Console.WriteLine(&quot;tst: &quot; + tst);
        m = rx.Match(tst);
        Console.WriteLine(&quot;m: &quot; + m);
        DiagPrintMatch(m);

        Console.WriteLine();
        tst = &quot;Csc.exe  /noconfig @\&quot;C:\\Temp\\tmpEE.tmp\&quot;&quot;;
        Console.WriteLine(&quot;tst: &quot; + tst);
        m = rx.Match(tst);
        Console.WriteLine(&quot;m: &quot; + m);
        DiagPrintMatch(m);
    }

    static void DiagPrintMatch(Match m)
    {
        Console.WriteLine(&quot;success: &quot; + m.Success);
        GroupCollection grps = m.Groups;

        for (int i = 0; i &lt; m.Groups.Count; i++) {
            Group g = m.Groups[i];
            Console.WriteLine(&quot;Group&quot; + i + &quot;='&quot; + g + &quot;'&quot;);
            CaptureCollection cc = g.Captures;
            for (int j = 0; j &lt; cc.Count; j++) {
                Capture c = cc[j];
                System.Console.WriteLine(&quot;Capture&quot; + j + &quot;='&quot; + c + &quot;', Position=&quot; + c.Index);
            }
        }
    }

}//class
]]

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000657.html">[mono-vb] Webservice In VB.Net Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#656">[ date ]</a>
              <a href="thread.html#656">[ thread ]</a>
              <a href="subject.html#656">[ subject ]</a>
              <a href="author.html#656">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-vb">More information about the Mono-vb
mailing list</a><br>
</body></html>
