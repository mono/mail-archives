<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-docs-list] Managed/Unmanaged Code Interop Documentation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   
   <LINK REL="Next"  HREF="000783.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-docs-list] Managed/Unmanaged Code Interop Documentation
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-docs-list] Managed/Unmanaged Code Interop Documentation">jonpryor@vt.edu
       </A><BR>
    <I>Mon, 01 Sep 2003 21:55:05 -0400</I>
    <P><UL>
        
        <LI> Next message: <A HREF="000783.html">[Mono-docs-list] (no subject)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#782">[ date ]</a>
              <a href="thread.html#782">[ thread ]</a>
              <a href="subject.html#782">[ subject ]</a>
              <a href="author.html#782">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--=-/ifJHgdx3wn1Zt+KL5UT
Content-Type: text/plain
Content-Transfer-Encoding: 7bit

Miguel had asked me to write this up in July after a lengthy list
discussion, so here's a summary of managed/unmanaged code interop.

I'd be interested in hearing of any suggestions for improvement, and of
how to add this file to monodoc.

Thanks,
 - Jon

--=-/ifJHgdx3wn1Zt+KL5UT
Content-Disposition: attachment; filename=interop.html
Content-Type: text/html; name=interop.html; charset=UTF-8
Content-Transfer-Encoding: 7bit

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;html xmlns=&quot;<A HREF="http://www.w3.org/1999/xhtml"">http://www.w3.org/1999/xhtml&quot;</A>
   xmlns:monodoc=&quot;<A HREF="http://www.go-mono.org/xml/monodoc"">http://www.go-mono.org/xml/monodoc&quot;</A>&gt;
&lt;head&gt;
   &lt;title&gt;Managed Code Interop&lt;/title&gt;
   &lt;meta name=&quot;DC.Description&quot; content=&quot;Managed and Unmanaged Code Integration&quot;/&gt;
   &lt;meta name=&quot;DC.Contributor&quot; content=&quot;Jonathan Pryor&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Everything You (Never?) Wanted to Know About Marshaling 
   (And Were Afraid To Ask)&lt;/h1&gt;
   &lt;p&gt;The &lt;a
   href=&quot;<A HREF="http://www.ecma-international.org/publications/standards/ecma-335.htm"">http://www.ecma-international.org/publications/standards/ecma-335.htm&quot;</A>
   &gt;Common Language Infrastructure&lt;/a&gt; 
   (&lt;acronym title=&quot;Common Language Infrastructure&quot;&gt;CLI&lt;/acronym&gt;) is
   designed to make it &quot;easy&quot; to interoperate with existing code.  In principal,
   all you need to do is create a 
   &lt;a href=&quot;T:System.Runtime.InteropServices.DllImportAttribute&quot;&gt;DllImport&lt;/a&gt;
   function declaration for the legacy
   code to invoke, and the runtime will handle the rest.  For example:&lt;/p&gt;

   &lt;monodoc:example id=&quot;simple-dllimport&quot;&gt;
      [System.Runtime.InteropServices.DllImport (&quot;libc.so&quot;)]
      private static extern int getpid ();
   &lt;/monodoc:example&gt;

   &lt;p&gt;The above C# function declaration would invoke the POSIX
   getpid(2) system call on platforms that have the libc.so library (other
   platforms would generate a 
   &lt;a href=&quot;T:System.MissingMethodException&quot;&gt;MissingMethodException&lt;/a&gt;).  
   Simple.  Straightforward.  What could be easier?&lt;/p&gt;

   &lt;p&gt;The problem is that most existing code is far more complex.  Strings will
   need to be passed, structures may need to be passed, memory management
   practices will become involved...  Existing code is a complex beast, and the
   interop layer needs to support this complexity.&lt;/p&gt;

   &lt;h2&gt;Marshaling&lt;/h2&gt;

   &lt;p&gt;How does code interop work?  Given a managed call site (the function
   call), and an unmanaged callee site (the function that's being called), each
   parameter in the call site is &quot;marshaled&quot; (converted) into an unmanaged
   equivalent.  The marshaled data is in turn placed on the runtime stack
   (along with other data), and the unmanaged function is invoked.&lt;/p&gt;

   &lt;p&gt;The complexity is due to the marshaling.  For simple types, such as 
   integers and floating-point numbers, marshaling is a bitwise-copy
   (&quot;blitting&quot;), just as would be the case for unmanaged code.  String types
   introduce additional complexity, as you need to specify the form of string
   conversion.  The runtime stores strings as UTF-16-encoded strings, and these
   will likely need to be marshaled to a more appropriate form (ANSI strings,
   UTF-8 encoded strings, etc.).  Strings get special support.&lt;/p&gt;

   &lt;p&gt;Marshaling behavior is controlled through the 
   &lt;a href=&quot;T:System.Runtime.InteropServices.DllImportAttribute&quot;&gt;DllImport&lt;/a&gt;
   and
   &lt;a href=&quot;T:System.Runtime.InteropServices.MarshalAsAttribute&quot;&gt;MarshalAs&lt;/a&gt;
   attributes.&lt;/p&gt;

   &lt;h3&gt;Strings&lt;/h3&gt;

   &lt;p&gt;Strings are special.  String marshaling behavior is also highly platform 
   dependent.&lt;/p&gt;

   &lt;p&gt;String marshaling for a function call can be specified in the function
   declaration with the DllImport attribute, by setting the 
   &lt;a href=&quot;F:System.Runtime.InteropServices.DllImportAttribute.CharSet&quot;
   &gt;CharSet&lt;/a&gt; field.  The default value for this field is 
   &lt;a href=&quot;F:System.Runtime.InteropServices.CharSet.Auto&quot;&gt;CharSet.Auto&lt;/a&gt;, 
   which implies &quot;magic.&quot;&lt;/p&gt;

   &lt;p&gt;Some background.  The Microsoft Win32 API supports two forms of strings,
   ANSI (localized) strings and Unicode strings.  It supports these string
   formats by appending an &quot;A&quot; for Ansi string APIs and a &quot;W&quot; (&quot;wide&quot;) for 
   Unicode string APIs.&lt;/p&gt;

   &lt;p&gt;Consider this Win32 API description:&lt;/p&gt;

   &lt;monodoc:example id=&quot;text-out-marshaling&quot;&gt;
      [System.Runtime.InteropServices.DllImport (&quot;gdi32.dll&quot;, 
         CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
      private static extern bool TextOut (
         System.IntPtr hdc,
         int nXStart,
         int nYStart,
         string lpString,
         int cbString);
   &lt;/monodoc:example&gt;

   &lt;p&gt;When TextOut is called, the &quot;magic&quot; properties of String marshaling
   become apparent.  The runtime will look for these functions, in this order,
   inside the gdi32.dll library:&lt;p&gt;
   &lt;ol&gt;
      &lt;li&gt;TextOutW for Unicode string marshaling&lt;/li&gt;
      &lt;li&gt;TextOutA for Ansi string marshaling&lt;/li&gt;
      &lt;li&gt;TextOut with the platform-default marshaling&lt;/li&gt;
   &lt;/ol&gt;

   &lt;p&gt;The runtime will use the first function that it finds in that list.
   Unicode marshaling is preferred, as (ideally) the System.String can be
   passed as-is to the function, as long as the function doesn't modify the
   string parameter.  Ansi marshalling will require translating the Unicode
   string into an 8-bit string (or DBCS, depending on the country) 
   in the users locale.  Most (all?) of the time,
   this WILL NOT be UTF-8, so you CAN NOT assume that CharSet.Ansi will
   generate UTF-8-encoded strings.&lt;/p&gt;

   &lt;p&gt;Perhaps in the future the CharSet enumeration will contain more choices,
   such as UnicodeLE (little-endian), UnicodeBE (big-endian), Utf7, Utf8, and
   other common choices.  Additionally, making such a change would also
   likely require changing the UnmanagedType enumeration.  However, these would 
   need to go through ECMA, so it won't happen next week.  (Unless some time 
   has passed since this was originally written, in which case it may very 
   well be next week.  But don't count on it.)&lt;/p&gt;

   &lt;h4&gt;More Control&lt;/h4&gt;

   &lt;p&gt;Using the DllImport attribute works if you want to control all the
   strings in a function, but what if you need more control?  You would need
   more control if a string is a member of a structure, or if the function
   uses multiple different types of strings as parameters.  In these
   circumstances, the MarshalAsAttribute can be used, setting the 
   &lt;a href=&quot;P:System.Runtime.InteropServices.MarshalAsAttribute.Value&quot;
   &gt;Value&lt;/a&gt; property (which is set in the constructor)
   to a value from the
   &lt;a href=&quot;E:System.Runtime.InteropServices.UnmanagedType&quot;&gt;UnmanagedType&lt;/a&gt;
   enumeration.  For example:&lt;/p&gt;

   &lt;monodoc:example id=&quot;mixed-string-marshaling&quot;&gt;
      [DllImport (&quot;does-not-exist&quot;)]
      private static extern void Foo (
         [MarshalAs(UnmanagedType.LPStr)] string ansiString,
         [MarshalAs(UnmanagedType.LPWStr)] string unicodeString,
         [MarshalAs(UnmanagedType.LPTStr)] string platformString);
   &lt;/monodoc:example&gt;

   &lt;p&gt;As you can guess by reading the example, UnmanagedType.LPStr will
   marshal the input string into an Ansi string, UnmanagedType.LPWStr will
   marshal the input string into a Unicode string (effectively doing
   nothing), and UnmanagedType.LPTStr will convert the string to the
   platform's default string encoding.  For all flavors of Windows NT (Windows
   NT 3.51 and 4.0, Windows 2000, Windows XP, Windows Server 2003) the
   platform default encoding is Unicode, while for all Windows 9x flavors
   (Windows 95, 98, ME) the platform default encoding is Ansi.&lt;/p&gt;

   &lt;p&gt;There are other UnmangedType string marshaling options, but they're
   primarily of interest in COM Interop (BStr, AnsiBStr, TBStr).&lt;/p&gt;

   &lt;p&gt;TODO: Does anybody know the default encoding for Unix platforms?  I 
   would guess Ansi as well...&lt;/p&gt;

   &lt;p&gt;If UnmanagedType doesn't provide enough flexibility for your string
   marshaling needs (for example, you're wrapping GTK+ and you need to marshal
   strings in UTF-8 format), look at the &lt;a href=&quot;#custom-marshal&quot;&gt;Custom
   Marshaling&lt;/a&gt; section.

   &lt;h4&gt;Passing Caller-Modifiable Strings&lt;/h4&gt;

   &lt;p&gt;A common C idiom is for the caller to provide the callee a buffer to
   fill.  For exmple, consider strncpy(3):&lt;/p&gt;

   &lt;monodoc:example id=&quot;strncpy-c-prototype&quot;&gt;
      char* strncpy (char *dest, const char *src, size_t n);
   &lt;/monodoc:example&gt;

   &lt;p&gt;We can't use System.String for both parameters, as strings are
   immutable.  This is OK for &quot;src&quot;, but &quot;dest&quot; will be modified, and the
   caller should be able to see the modification.&lt;/p&gt;

   &lt;p&gt;The solution is to use a 
   &lt;a href=&quot;T:System.Text.StringBuilder&quot;&gt;System.Text.StringBuilder&lt;/a&gt;, which
   gets special marshaling support from the runtime.  This would allow
   strncpy(3) to be wrapped and used as:&lt;/p&gt;

   &lt;monodoc:example id=&quot;strncpy-csharp-prototype&quot;&gt;
      [DllImport (&quot;libc.so&quot;)]
         private static extern void strncpy (StringBuilder dest, string src,
            uint n);

      private static void UseStrncpy ()
      {
         StringBuilder sb = new StringBuilder (256);
         strncpy (sb, &quot;this is the source string&quot;, sb.Capacity);
         Console.WriteLine (sb.ToString());
      }
   &lt;/monodoc:example&gt;

   &lt;p&gt;Some things to note is that the return value of strncpy(3) was changed
   to &quot;void&quot;, as there is no way to specify that the return value will be the
   same pointer address as the input &quot;dest&quot; string buffer, and thus it doesn't
   need to be marshalled.  If &quot;string&quot; were used instead, an extra copy of the
   return value would be made.  The StringBuilder is allocated with the
   correct amount of storage as a constructor parameter, and this amount of
   storage is passed to strncpy(3) to prevent buffer overflow.&lt;/p&gt;

   &lt;h4&gt;TODO&lt;/h4&gt;

   &lt;p&gt;What's the memory management policy for using &quot;string&quot; as a return
   value?  Does the runtime expect to free it?&lt;/p&gt;

   &lt;h4&gt;See Also&lt;/h4&gt;
   &lt;ul&gt;
      &lt;li&gt;&lt;a 
      href=&quot;<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpcondefaultmarshalingforstrings.asp"">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpcondefaultmarshalingforstrings.asp&quot;</A>
      &gt;MSDN: Default marshaling for Strings&lt;/a&gt;
      &lt;/li&gt;
   &lt;/ul&gt;

   &lt;h3&gt;Class and Structure Marshaling&lt;/h3&gt;

   &lt;p&gt;Conceptually, classes and structures are marshalled to native code
   by:&lt;/p&gt;

   &lt;ol&gt;
      &lt;li&gt;The runtime allocates a chunk of unmanaged memory.&lt;/li&gt;
      &lt;li&gt;The managed class data is copied into the unmanaged memory.&lt;/li&gt;
      &lt;li&gt;The unmanaged function is invoked, passing it the unmanaged memory
         information instead of the managed memory information.  This must be
         done so that if a GC occurs, the unmanaged function doesn't need to
         worry about it.  (And yes, you need to worry about GCs, as the
         unmanaged function could call back into the runtime, generating a
         GC.)&lt;/li&gt;
      &lt;li&gt;The unmanaged memory is copied into managed memory.&lt;/li&gt;
   &lt;/ol&gt;

   &lt;p&gt;The principal difference between class and structure marshaling is which
   of these conceptual steps actually occurs. :-)&lt;/p&gt;

   &lt;h4&gt;Class Marshaling&lt;/h4&gt;

   &lt;p&gt;Remember that classes are heap-allocated and garbage-collected in the
   CLI.  As such, you cannot pass classes by value to unmanaged functions,
   only by reference:&lt;/p&gt;

   &lt;monodoc:example id=&quot;class-marshal-example&quot;&gt;
      struct UnmanagedStruct {
         int a, b, c;
      };

      void WRONG (struct UnamangedStruct pass_by_value)
      {
      }

      void RIGHT (struct UnmanagedStruct *pass_by_reference)
      {
      }
   &lt;/monodoc:example&gt;

   &lt;p&gt;This means that you cannot use classes to invoke unmanaged functions
   that expect a stack-allocated variable (such as the WRONG function,
   above).&lt;/p&gt;

   &lt;p&gt;There are two other issues with classes.  First of all, classes by
   default use &lt;a
   href=&quot;F:System.Runtime.InteropServices.LayoutKind.Auto&quot;&gt;Auto&lt;/a&gt; layout.
   This means that the ordering of class data members is unknown, and won't be
   determined at runtime.  The runtime can rearrange the order of members in
   any way it chooses, to optimize for access time or data layout space.  As
   such, you MUST use the &lt;a
   href=&quot;T:System.Runtime.InteropServices.StructLayoutAttribute&quot;
   &gt;StructLayoutAttribute&lt;/a&gt; and specify a
   &lt;a href=&quot;E:System.Runtime.InteropServices.LayoutKind&quot;&gt;LayoutKind&lt;/a&gt; value
   of &lt;a href=&quot;F:System.Runtime.InteropServices.LayoutKind.Sequential&quot;
   &gt;Sequential&lt;/a&gt; or &lt;a 
   href=&quot;F:System.Runtime.InteropServices.LayoutKind.Explicit&quot;&gt;Explicit&lt;/a&gt;.
   &lt;/p&gt;

   &lt;p&gt;Secondly, classes (again, by default) only have in-bound marshaling.
   That is, Step 4 (copying the unmanaged memory representation back into 
   managed memory) is ommitted.  If you need the unmanaged memory to be copied
   back into managed memory, you must addorn the DllImport function
   declaration argument with an 
   &lt;a href=&quot;T:System.Runtime.InteropServices.OutAttribute&quot;&gt;Out&lt;/a&gt; attribute.
   You will also need to use the 
   &lt;a href=&quot;T:System.Runtime.InteropServices.InAttribute&quot;&gt;In&lt;/a&gt; attribute if
   you want copy-in and copy-out behavior.  To summarize:&lt;/p&gt;

   &lt;ul&gt;
      &lt;li&gt;Using [In] is equivalent to not specifying any parameter
         attributes, and will skip Step 4 (copying unmanaged memory into
         managed memory).&lt;/li&gt;
      &lt;li&gt;Using [Out] will skip Step 2 (copying managed memory into unmanaged
         memory).&lt;/li&gt;
      &lt;li&gt;Use [In, Out] to both copy managed memory to unmanaged memory before
         the unmanaged function call, and then copy unmanaged memory back to
         managed memory after the function call.&lt;/li&gt;
   &lt;/ul&gt;

   &lt;h4&gt;Structure Marshaling&lt;/h4&gt;

   &lt;p&gt;There are two primary differences between classes and structures.
   First, structures do not need to be allocated on the heap; they can be
   stack allocated.  Secondly, they use Sequential LayoutKind by default, so
   structure declarations do not need any additional attributes to use them
   with unmanaged code (assuming that the default sequential layout rules are
   correct for the unmanaged structure).&lt;/p&gt;

   &lt;p&gt;These differences permit structures to be passed by-value to unmanaged
   functions, unlike classes.  Additionally, since structures are typically
   located on the stack (unless they're boxed or part of a class instance), if
   you pass a structure to an unmanaged function by-reference, the structure
   will be passed directly to the unmanaged function, without an intermediate
   unmanaged memory copy.  This means that you may not need to specify the Out
   attribute to see changes made by unmanaged code.&lt;/p&gt;

   &lt;h4&gt;Summary&lt;/h4&gt;

   &lt;p&gt;It's always easier to show the code, so...  Given the following
   unmanaged code definition:&lt;/p&gt;

   &lt;monodoc:example id=&quot;marshal-unmanaged-code&quot;&gt;
      struct UnmanagedStruct {
         int n;
      };

      void PassByValue (struct UnmanagedStruct s);
      void PassByReference (struct UnmanagedStruct *s);
   &lt;/monodoc:example&gt;

   &lt;p&gt;The class wrapper would be:&lt;/p&gt;

   &lt;monodoc:example id=&quot;marshal-class-wrapper&quot;&gt;
      [StructLayout (LayoutKind.Sequential)]
      class ClassWrapper {
         public int n;

         /* cannot wrap function PassByValue */

         /* PassByReference */
         [DllImport (&quot;mylib&quot;)]
         public static extern void PassByReference ([In, Out] ClassWrapper s);
      }
   &lt;/monodoc:example&gt;

   &lt;p&gt;While the structure wrapper would be:&lt;/p&gt;

   &lt;monodoc:example id=&quot;marshal-struct-wrapper&quot;&gt;
      struct StructWrapper {
         public int n;

         /* PassByValue */
         [DllImport (&quot;mylib&quot;)]
         public static extern void PassByValue (StructWrapper s);

         /* PassByReference */
         [DllImport (&quot;mylib&quot;)]
         public static extern void PassByReference (ref StructWrapper s);
      }
   &lt;/monodoc:example&gt;

   &lt;h4&gt;TODO&lt;/h4&gt;

   &lt;p&gt;How are return values handled?  What are the differences between classes
   and structures?&lt;/p&gt;

   &lt;h3&gt;Marshaling Class and Structure Members&lt;/h3&gt;

   &lt;p&gt;Aside from the major differences between classes and structures outlined
   above, the members of classes and structures are marshaled identically.&lt;/p&gt;

   &lt;p&gt;The general rule of advice is this: never pass classes or structures
   containing members of reference type (classes) to unmanaged code.
   This is because unmanaged code can't do anything safely with the unmanaged 
   reference (pointer), and the CLI runtime doesn't do a &quot;deep marshal&quot;
   (marshal members of marshaled classes, and their members, ad
   infinitum).&lt;/p&gt;

   &lt;p&gt;The immediate net effect of this is that you can't have string and array
   members of marshaled classes.&lt;/p&gt;

   &lt;p&gt;It's not quite as bad as this makes out.  You can't pass strings and
   arrays BY DEFAULT.  If you help the runtime marshaler by addorning the
   members with the MarshalAs attribute, the marshaler can figure out what to
   do and you can live life peacefully with the ever-present strings and
   arrays.  Alternatively, string marshaling can also be set by setting the 
   &lt;a href=&quot;F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet&quot;
   &gt;CharSet&lt;/a&gt; member on the StructLayout attribute for the class or
   structure.&lt;/a&gt;

   &lt;h4&gt;Unions&lt;/h4&gt;

   &lt;p&gt;A C union (in which multiple members share the same offset into a
   structure) can be simulated by using the FieldOffset attribute and
   specifying the same offset for the union members.&lt;/p&gt;

   &lt;h4&gt;See Also&lt;/h4&gt;

   &lt;ul&gt;
      &lt;li&gt;&lt;a
         href=&quot;<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmarshalingdatawithplatforminvoke.asp"">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmarshalingdatawithplatforminvoke.asp&quot;</A>
         &gt;Marshaling Data with Platform Invoke&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a
         href=&quot;<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconarrayssample.asp"">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconarrayssample.asp&quot;</A>
         &gt;Arrays Sample&lt;/a&gt;
      &lt;/li&gt;
   &lt;/ul&gt;

   &lt;h4&gt;Arrays Embedded Within Structures&lt;/h4&gt;

   &lt;p&gt;This might be of use.  From David Jesk 
   (&lt;a href=&quot;<A HREF="http://www.chat.net/~jeske/"">http://www.chat.net/~jeske/&quot;</A>&gt;<A HREF="http://www.chat.net/~jeske/</a">http://www.chat.net/~jeske/&lt;/a</A>&gt;):
   &lt;/p&gt;

   &lt;blockquote&gt;
   &lt;p&gt;This time I have some PInvoke information to share, so that when
   someone else runs into this issue they can see what I've done.&lt;/p&gt;

   &lt;p&gt;In my ClearSilver (www.clearsilver.net, an HTML template system) C#
   wrapper, I wanted to access this C-struct:&lt;/p&gt;

   &lt;monodoc:example id=&quot;&quot;&gt;
      typedef struct _neo_err
      {
        int error;
        int err_stack;
        int flags;
        char desc[256];
        const char *file;
        const char *func;
        int lineno;
        /* internal use only */
        struct _neo_err *next;
      } NEOERR;
   &lt;/monodoc:example&gt;

   &lt;p&gt;My philosophy of using unsafe struct pointers, and just accessing the
   struct out in unmanaged memory is great, and it's exactly what I want
   to do. However, handling &quot;char dest[256]&quot; is not straightforward.&lt;/p&gt;

   &lt;p&gt;In C# arrays are reference types. Using one makes the struct a managed
   type, and I can't put the array size in. The following is conceptually
   what I want to do, however, it's obviously invalid:&lt;/p&gt;

   &lt;monodoc:example id=&quot;&quot;&gt;
      [StructLayout(LayoutKind.Sequential)]
      unsafe struct NEOERR {
        public int error;
        public int err_stack;
        public int flags;
        public byte[256] desc;  // this is invalid, can't contain size
        public const byte *file; 
        public const byte *func; 
        public int lineno;

        /* internal use only */
        private NEOERR *next;
      };
   &lt;/monodoc:example&gt;

   &lt;p&gt;This dosn't work either:&lt;/p&gt;

   &lt;monodoc:example id=&quot;&quot;&gt;
     [MarshalAs (UnmanagedType.LPStr, SizeConst=256)] 
       public string desc; 
   &lt;/monodoc:example&gt;
       
   &lt;p&gt;Because in this case, I don't want to marshal the data. I just want to
   talk to it in place. The solution I could come up with is this:&lt;/p&gt;

   &lt;monodoc:example id=&quot;&quot;&gt;
      [StructLayout(LayoutKind.Explicit)]
      unsafe struct NEOERR {
        [FieldOffset(0)] public int error;
        [FieldOffset(4)] public int err_stack;
        [FieldOffset(8)] public int flags;
        // public byte[256] dest;  // not representable
        [FieldOffset(12)] public byte dest_first_char; // use this as an address??
        [FieldOffset(268)] public byte *file; // const
        [FieldOffset(272)] public byte *func; // const
        [FieldOffset(276)] public int lineno;
      };
   &lt;/monodoc:example&gt;

   &lt;p&gt;UGH! First, this is obviously annoying. Second, the only way I can
   figure to get access to &quot;char dest[256]&quot; is to use &quot;char* dest =
   &amp;amp;nerr-&amp;gt;dest_first_char;&quot; and then just use dest as a pointer to the
   string. I've dug through the documentation, and I can't find any
   better solution.&lt;/p&gt;

   &lt;p&gt;Obviously it would be ideal if there were a way to represent a
   value-type array. I wonder how Managed C++ handles &quot;char foo[256];&quot; in
   a struct.&lt;/p&gt;
   &lt;/blockquote&gt;

   &lt;h3 id=&quot;custom-marshal&quot;&gt;Custom Marshaling&lt;/h3&gt;

   &lt;p&gt;TODO: custom marshaling...&lt;/p&gt;

   &lt;h4&gt;See Also&lt;/h4&gt;

   &lt;ul&gt;
      &lt;li&gt;&lt;a 
         href=&quot;<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemruntimeinteropservicesicustommarshalerclasstopic.asp"">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemruntimeinteropservicesicustommarshalerclasstopic.asp&quot;</A>
         &gt;ICustomMarshal Interface&lt;/a&gt;
      &lt;/li&gt;
   &lt;/ul&gt;

   &lt;h2&gt;Avoiding Marshaling&lt;/h2&gt;

   &lt;p&gt;Marshaling is no panacea, as marshaling implies copying data.
   Marshaling may be problematic because the data translation is a complex,
   time-consuming process.  Alternativly, it may be problematic 
   because it isn't possible to copy the data, as the data isn't known or is 
   likely to change.&lt;/p&gt;

   &lt;p&gt;An example of the latter would be the GTK+ libraries.  GTK+ is an
   object-oriented toolkit written in C.  As with all object-oriented
   libraries, there can be an unknown number of derived classes, each of which
   having a different class size.  Furthermore, class instances are typically
   accessed through pointers.  As such, marshaling the entire class between
   managed and unmanaged memory is not an option, as a copy isn't desired,
   access to the same instance is.&lt;/p&gt;

   &lt;p&gt;Another example is when using &quot;opaque&quot; data types; that is, types
   through which interaction is solely through pointers, and nothing about the
   internals of the type is public.  This describes a large portion of the
   Win32 API, where HANDLE is used to represent most objects.&lt;/p&gt;

   &lt;p&gt;There are two ways to handle this in C#: the &quot;type-safe&quot; way, which
   involves using pointers and the &quot;unsafe&quot; C# language features, and the
   CLS-compliant way, which uses System.IntPtr to stand in for a void
   pointer.&lt;/p&gt;

   &lt;p&gt;In effect, the separation between managed and unmanaged memory is made
   explicit.  Managed memory remains typesafe, while unmanaged memory is not
   (since &lt;a href=&quot;T:System.IntPtr&quot;&gt;System.IntPtr&lt;/a&gt; is used to point into 
   unmanaged memory, and there is no way to ensure the actual type of what 
   the System.IntPtr refers to).&lt;/p&gt;

   &lt;p&gt;Be warned that this may not be safe, if the &quot;unmanaged&quot; memory is itself
   garbage collected.  This may be the case if the unmanaged memory is handled
   by a different runtime system (Python, Ruby, Lisp, etc.) or a garbage
   collector is being used (Boehm).  If the unmanaged memory is garbage
   collected, then the System.IntPtr won't be updated when unmanaged memory
   undergoes a garbage collection, resulting in memory corruption.&lt;/p&gt;

   &lt;p&gt;For example, given the unmanaged API:&lt;/p&gt;

   &lt;monodoc:example id=&quot;no-marshal-unmanaged-code&quot;&gt;
      typedef void* HANDLE;

      bool CreateItem (HANDLE *item);
      void DestroyItem (HANDLE item);
      int GetInfo (HANDLE item);
   &lt;/monodoc:example&gt;

   &lt;p&gt;The &quot;type-safe&quot; C# wrapper (using &quot;unsafe&quot; code) is:&lt;/p&gt;

   &lt;monodoc:example id=&quot;no-marshal-unsafe-wrapper&quot;&gt;
      struct Item {

         [DllImport (&quot;library&quot;)]
         public static unsafe extern bool CreateItem (out Item* item);

         [DllImport (&quot;library&quot;)]
         public static unsafe extern void DestroyItem (Item* item);

         [DllImport (&quot;library&quot;)]
         public static unsafe extern int GetInfo (Item* item);
      }

      class ExampleUsage {
         public static unsafe void Main ()
         {
            Item* item = null;
            Item.CreateItem (out item);
            int n = Item.GetInfo (item);
            System.Console.WriteLine (&quot;item count: {0}&quot;, n.ToString());
            Item.DestroyItem (item);
         }
      }
   &lt;/monodoc:example&gt;

   &lt;p&gt;This is &quot;type-safe&quot; in that you can't pass arbitrary memory locations to
   the static Item functions, you must pass a pointer to an Item structure.
   This isn't a strict amount of type safety, but it is likely to minimize
   accidental memory corruption.  It's biggest problem is that it uses
   &quot;unsafe&quot; code, and thus may not be usable from other .NET languages, such
   as Visual Basic .NET and JavaScript.&lt;/p&gt;

   &lt;p&gt;The CLS compliant version uses System.IntPtr to refer to unmanaged
   memory.  This is similar to what the 
   &lt;a href=&quot;T:System.Runtime.InteropServices.Marshal&quot;&gt;Marshal&lt;/a&gt; class does
   to interoperate with unmanaged memory.&lt;/p&gt;
   
   &lt;monodoc:example id=&quot;no-marshal-IntPtr-wrapper&quot;&gt;
      class Item {

         [DllImport (&quot;library&quot;)]
         public static extern bool CreateItem (out System.IntPtr item);

         [DllImport (&quot;library&quot;)]
         public static extern void DestroyItem (System.IntPtr item);

         [DllImport (&quot;library&quot;)]
         public static extern int GetInfo (System.IntPtr item);
      }

      class ExampleUsage {
         public static unsafe void Main ()
         {
            System.IntPtr item = null;
            Item.CreateItem (out item);
            int n = Item.GetInfo (item);
            System.Console.WriteLine (&quot;item count: {0}&quot;, n.ToString());
            Item.DestroyItem (item);
         }
      }
   &lt;/monodoc:example&gt;

   &lt;p&gt;This is &quot;unsafe&quot; in that it is
   easier to accidently mis-use pointers.  For example, if you're using two
   different libraries and wrapping them using System.IntPtr, it is possible
   to pass an object allocated from one library to a function exported by the
   other library, and the CLI Runtime will not catch this error, while the
   &quot;unsafe&quot; C# code would catch this error.&lt;/p&gt;

   &lt;p&gt;However, this isn't normally considered a problem, however, as most
   managed code shouldn't interact with P/Invoke code, but should instead
   interact with managed wrappers for the unmanaged code, which can provide a
   more natural interface to managed clients.&lt;/p&gt;

   &lt;h4&gt;Meaning of &quot;Unsafe&quot;&lt;/h4&gt;

   &lt;p&gt;I think the real problem is that &quot;unsafe&quot; is an overloaded term.  It can
   refer to the use of the &quot;unsafe&quot; C# keyword, and it can be used as
   &quot;anything that isn't safe&quot;, which, as you note, doesn't require the
   &quot;unsafe&quot; keyword.&lt;/p&gt;

   &lt;p&gt;So, &quot;unsafe&quot; can mean (a) C# keyword; (b) violates .NET type system
   (similar to (a)); (c) may be insecure (reading files from a web client);
   (d) capable of causing a segfault.  There are likely other meanings
   people can dream up as well.  Note that (d) doesn't imply (b), as far as
   .NET is concerned.  The runtime could itself have a bug that generates a
   segfault, but this doesn't violate the type system.&lt;/p&gt;

   &lt;p&gt;IntPtr doesn't require a violation of the type system, as you can't get
   the address of a .NET object (unless you &quot;pin&quot; it, which would require
   the appropriate Security rights), and is thus principally useful for
   interacting with unmanaged code, which exists outside of the .NET type
   system.&lt;/p&gt;

   &lt;p&gt;Surely, this is pure semantics, but I can see the designers
   perspective.&lt;/p&gt;

   &lt;h4&gt;Security&lt;/h4&gt;

   &lt;p&gt;Well, to speak on .NET's behalf, .NET has a highly flexible security
   system.  You can't invoke DllImported functions unless your app has the
   appropriate security rights -- generally, that the app is running on the
   local machine.  If you're running it from a network share, or from a web
   site (similar to Java Applets), then your app will get a
   SecurityException.&lt;/p&gt;

   &lt;p&gt;You can get lots of security exceptions for various things, actually. 
   Opening files can generate a security exception, for example.&lt;/p&gt;

   &lt;p&gt;System.Security.Permissions.SecurityPermission is needed with
   SecurityPermissionFlag.UnmanagedCode specified in order to perform a
   P/Invoke.&lt;/p&gt;

   &lt;p&gt;Programs can't specify this permission, though, they can only request it
   (or demand it, and if they can't get it, a SecurityException is
   thrown).&lt;/p&gt;

   &lt;p&gt;Administrators are the people who specify what permissions an
   application actually receives.&lt;/p&gt;

   &lt;p&gt;That's about the limits of my knowledge -- Security isn't my forte.  You
   might find the following topics interesting.&lt;/p&gt;

   &lt;ul&gt;
      &lt;li&gt;&lt;a
        href=&quot;<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconrequestingpermissions.asp"">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconrequestingpermissions.asp&quot;</A>
        &gt;Requesting Permissions&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a
        href=&quot;<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconsecuritysyntax.asp"">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconsecuritysyntax.asp&quot;</A>
        &gt;Security Syntax&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a
        href=&quot;<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconcodeaccesssecurity.asp"">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconcodeaccesssecurity.asp&quot;</A>
        &gt;Code Access Security&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a
        href=&quot;<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconinheritancedemands.asp"">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconinheritancedemands.asp&quot;</A>
        &gt;Inheritance Demands&lt;/a&gt;
      &lt;/li&gt;
   &lt;/ul&gt;


   &lt;h4&gt;See Also&lt;/h4&gt;

   &lt;ul&gt;
      &lt;li&gt;&lt;a 
        href=&quot;<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csspec/html/vclrfcsharpspec_A_2.asp"">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csspec/html/vclrfcsharpspec_A_2.asp&quot;</A>
        &gt;Unsafe Code&lt;/a&gt;
      &lt;/li&gt;
   &lt;/ul&gt;

  &lt;h2&gt;Thanks&lt;/h2&gt;

  &lt;p&gt;A large portion of this document was generated as a result of a mono-list
  discussion between Jonathan Pryor and David Jeske.  See: 
  &lt;a href=&quot;<A HREF="http://lists.ximian.com/archives/public/mono-list/2003-July/014886.html"">http://lists.ximian.com/archives/public/mono-list/2003-July/014886.html&quot;</A>
  &gt;<A HREF="http://lists.ximian.com/archives/public/mono-list/2003-July/014886.html</a">http://lists.ximian.com/archives/public/mono-list/2003-July/014886.html&lt;/a</A>&gt;.
  &lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;


--=-/ifJHgdx3wn1Zt+KL5UT--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI> Next message: <A HREF="000783.html">[Mono-docs-list] (no subject)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#782">[ date ]</a>
              <a href="thread.html#782">[ thread ]</a>
              <a href="subject.html#782">[ subject ]</a>
              <a href="author.html#782">[ author ]</a>
         </LI>
       </UL>
</body></html>
