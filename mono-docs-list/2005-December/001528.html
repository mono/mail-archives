<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-docs-list] Wiki Markup for ECMA documents.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-docs-list%40lists.ximian.com?Subject=%5BMono-docs-list%5D%20Wiki%20Markup%20for%20ECMA%20documents.&In-Reply-To=1133893638.6845.853.camel%40linux.site">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001526.html">
   <LINK REL="Next"  HREF="001525.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-docs-list] Wiki Markup for ECMA documents.</H1>
    <B>Atsushi Eno</B> 
    <A HREF="mailto:mono-docs-list%40lists.ximian.com?Subject=%5BMono-docs-list%5D%20Wiki%20Markup%20for%20ECMA%20documents.&In-Reply-To=1133893638.6845.853.camel%40linux.site"
       TITLE="[Mono-docs-list] Wiki Markup for ECMA documents.">atsushi at ximian.com
       </A><BR>
    <I>Wed Dec  7 12:10:08 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001526.html">[Mono-docs-list] Wiki Markup for ECMA documents.
</A></li>
        <LI>Next message: <A HREF="001525.html">[Mono-docs-list] Wiki Markup for ECMA documents.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1528">[ date ]</a>
              <a href="thread.html#1528">[ thread ]</a>
              <a href="subject.html#1528">[ subject ]</a>
              <a href="author.html#1528">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hola,

&gt;<i> But with this code, we can start moving forward.  We still need the
</I>&gt;<i> inverse process Wiki to ECMA XML before this can land on SVN.
</I>
Yeah. So, here it is.
<A HREF="http://monkey.workarea.jp/trans/mono/index.php/TestMonodocToMediaWiki3">http://monkey.workarea.jp/trans/mono/index.php/TestMonodocToMediaWiki3</A>

However, whitespace handling in the ECMA-&gt;Wiki xsl is a blocker for
practical use (it unexpectedly merges sequential &lt;para&gt;s), so am
really going to rewrite the code in C#.

Atsushi Eno
-------------- next part --------------
using System;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;

namespace Monodoc
{
	public class WikiStyleDocParser
	{
		public static void Main (string [] args)
		{
			if (args.Length &lt; 1) {
				Console.Error.WriteLine (&quot;usage: wiki2ecma sourcefile [--full]&quot;);
				return;
			}

			bool full = args.Length &gt; 1 &amp;&amp; args [1] == &quot;--full&quot;;

			bool isXml = false;
			using (Stream s = File.OpenRead (args [0])) {
				isXml = (s.ReadByte () == '&lt;');
			}

			string text;
			if (isXml) {
				XmlDocument doc = new XmlDocument ();
				doc.Load (args [0]);
				XmlNode node = doc.SelectSingleNode (&quot;//text&quot;);
				text = node.InnerText;
			} else {
				StreamReader sr = new StreamReader (args [0], 
					Encoding.UTF8);
				text = sr.ReadToEnd ();
			}

			// Pass the input Wiki-like content as the .ctor()
			// parameter.
			WikiStyleDocParser p = new WikiStyleDocParser (text);
			XmlNode result;
			if (full)
				result = p.ParseEntireDoc ();
			else
				result = p.ParseContent ();

			XmlTextWriter xw = new XmlTextWriter (Console.Out);
			xw.Formatting = Formatting.Indented;
			result.WriteTo (xw);
			xw.Close ();
		}

		string [] lines;
		int lineno = 1;
		XmlDocument doc;
		string current_member;

		public WikiStyleDocParser (string source)
		{
			lines = source.Split ('\n');
			doc = new XmlDocument ();
			doc.AppendChild (doc.CreateElement (&quot;root&quot;));
		}

		public XmlNode ParseContent ()
		{
			ProcessContent (doc.DocumentElement);
			return doc.DocumentElement;
		}

		public XmlNode ParseEntireDoc ()
		{
			XmlElement el = doc.DocumentElement;

			while (lineno &lt; lines.Length) {
				string line = lines [lineno].Trim ();
				if (line.Length == 0) {
					lineno++;
					continue;
				}
				XmlNode node = null;
				switch (line) {
				case &quot;=== Summary ===&quot;:
					node = ProcessTaggedContent (EditTarget.Summary);
					el.AppendChild (node);
					break;
				case &quot;=== Remarks ===&quot;:
					node = ProcessTaggedContent (EditTarget.Remarks);
					el.AppendChild (node);
					break;
				case &quot;=== Parameters ===&quot;:
					ProcessList (el, &quot;param&quot;, &quot;name&quot;);
					break;
				case &quot;=== Exceptions ===&quot;:
					ProcessList (el, &quot;exception&quot;, &quot;type&quot;);
					break;
				default:
					if (StrUtil.StartsWith (line, &quot;==&quot;)) {
						current_member = line.Substring (
							3, line.Length - 6).Trim ();
						el = doc.CreateElement (&quot;Member&quot;);
						el.SetAttribute (&quot;MemberName&quot;, current_member);
						doc.DocumentElement.AppendChild (el);
						lineno++;
						break;
					}
					throw MarkupError (&quot;Unexpected line format: &quot; + line);
				}
			}
			return doc.DocumentElement;
		}

		void ProcessList (XmlNode parent, string elemName, string defAttr)
		{
			lineno++;
			for (; lineno &lt; lines.Length; lineno++) {
				string line = lines [lineno];
				if (line.Length == 0)
					continue;
				if (line [0] != ';')
					break;
				int idx = line.IndexOf (':');
				XmlElement el = doc.CreateElement (elemName);
				parent.AppendChild (el);
				el.SetAttribute (defAttr, line.Substring (1, idx - 1));
				ProcessSimpleLine (el, line, idx + 1);
			}
		}

		XmlNode ProcessTaggedContent (string target)
		{
			XmlElement el = doc.CreateElement (target);
			lineno++;
			ProcessContent (el);
			return el;
		}

		void ProcessContent (XmlNode container)
		{
			while (lineno &lt; lines.Length) {
				string line = lines [lineno];
				if (line.Length == 0) {
					lineno++;
					continue;
				}

				switch (line [0]) {
				case '=':
					return;
				case '{':
					ProcessTable (container);
					break;
				case ':':
					XmlElement el = doc.CreateElement (&quot;block&quot;);
					el.SetAttribute (&quot;subset&quot;, &quot;none&quot;);
					el.SetAttribute (&quot;type&quot;, &quot;note&quot;);
					container.AppendChild (el);
					ProcessSimple (el, true);
					break;
				default:
					el = doc.CreateElement (&quot;para&quot;);
					container.AppendChild (el);
					ProcessSimple (el, false);
					break;
				}
			}
		}

		void ProcessTable (XmlNode container)
		{
			lineno++;
			XmlElement list = doc.CreateElement (&quot;list&quot;);
			container.AppendChild (list);
			list.SetAttribute (&quot;type&quot;, &quot;table&quot;);
			XmlElement tline = null;
			for (; lineno &lt; lines.Length; lineno++) {
				string line = lines [lineno];
				if (line == &quot;|}&quot;) {
					lineno++;
					return;
				}

				if (line.Length == 0)
					continue;
				if (line == &quot;|-&quot;) {
					tline = doc.CreateElement (&quot;item&quot;);
					continue;
				}
				switch (line [0]) {
				case '!':
					tline = doc.CreateElement (&quot;listheader&quot;);
					int endTerm = line.IndexOf ('!', 1);
					int beginDesc = endTerm &lt; 0 ? -1 : line.IndexOf ('!', endTerm + 1);
					if (beginDesc &lt; 0)
						throw MarkupError (&quot;list table header has incorrect markup : &quot; + line);
					XmlElement term = doc.CreateElement (&quot;term&quot;);
					term.InnerText = line.Substring (1, endTerm - 1);
					tline.AppendChild (term);
					XmlElement desc = doc.CreateElement (&quot;description&quot;);
					desc.InnerText = line.Substring (beginDesc + 1);
					tline.AppendChild (desc);
					list.AppendChild (tline);
					break;
				case '|':
					if (tline == null)
						throw MarkupError (&quot;Specify '|-' to begin new table line&quot;);
					endTerm = line.IndexOf ('|', 1);
					beginDesc = endTerm &lt; 0 ? -1 : line.IndexOf ('|', endTerm + 1);
					term = doc.CreateElement (&quot;term&quot;);
					term.InnerText = line.Substring (1, endTerm - 1);
					tline.AppendChild (term);
					desc = doc.CreateElement (&quot;description&quot;);
					ProcessSimpleLine (desc, line, beginDesc + 1);
					tline.AppendChild (desc);
					list.AppendChild (tline);
					break;
				}
				tline = null;
			}
			// there is already &quot;return&quot; statement above.
			throw MarkupError (&quot;End of list table is missing&quot;);
		}

		void ProcessSimple (XmlNode container, bool allowColon)
		{
			for (;lineno &lt; lines.Length; lineno++) {
				string line = lines [lineno];
				if (line.Length == 0) {
					if (lineno + 1 &lt; lines.Length &amp;&amp;
					    lines [lineno + 1] == String.Empty) {
						lineno++;
						return;
					}
					continue;
				}
				switch (line [0]) {
				case '=':
				case '{':
					return;
				case ':':
					if (!allowColon)
						return;
					ProcessSimpleLine (container, line, 1);
					break;
				default:
					ProcessSimpleLine (container, line, 0);
					break;
				}
			}
		}

		void ProcessSimpleLine (XmlNode container, string line, int from)
		{
			int idx;
			while ((idx = line.IndexOf ('[', from)) &gt;= 0) {
				from = ProcessLink (
					container, line, idx, from);
			}
			if (from != line.Length)
				container.AppendChild (doc.CreateTextNode (line.Substring (from) + '\n'));
		}

		int ProcessLink (XmlNode container, string line, int idx, int from)
		{
			int end = line.IndexOf (']', idx);
			if (end &lt; idx)
				throw MarkupError (String.Format (&quot;There is no matching ']' to close link at position {1} : {0}&quot;, line, idx));
			if (idx &gt; from) {
				XmlText text = doc.CreateTextNode (
					line.Substring (from, idx - from));
				container.AppendChild (text);
			}
			int sep = line.IndexOf ('|', idx, end - idx);
			if (sep &gt; 0) {
				if (line [idx + 1] != '[' ||
				    sep &lt; 0 || sep &gt; end ||
				    end + 1 &gt;= line.Length ||
				    line [end + 1] != ']')
					throw MarkupError (String.Format (&quot;Invalid reference markup at position {1} : {0}&quot;, line, idx));
				// see cref
				XmlElement el = doc.CreateElement (&quot;see&quot;);
				el.SetAttribute (&quot;cref&quot;, line.Substring (
					idx + 2, sep - idx - 2).Trim ());
				container.AppendChild (el);
			} else {
				// paramref
				if (line [idx + 1] != '[' ||
				    end + 1 &gt;= line.Length ||
				    line [end + 1] != ']')
					throw MarkupError (String.Format (&quot;Invalid reference markup at position {1} : {0}&quot;, line, idx));
				XmlElement el = doc.CreateElement (&quot;paramref&quot;);
				el.SetAttribute (&quot;name&quot;, line.Substring (
					idx + 2, end - idx - 2));
				container.AppendChild (el);
			}
			end += 2;
			return end;
		}

		Exception MarkupError (string message)
		{
			throw new Exception (String.Format (
				&quot;At line {1} : {0}&quot;, message, lineno));
		}
	}

	class EditTarget
	{
		public const string Summary = &quot;summary&quot;;
		public const string Remarks = &quot;remarks&quot;;
	}

	class StrUtil
	{
		static CompareInfo ci = CultureInfo.CurrentCulture.CompareInfo;

		public static bool StartsWith (string s, string target)
		{
			return ci.IsPrefix (s, target, CompareOptions.Ordinal);
		}
	}
}
-------------- next part --------------
A non-text attachment was scrubbed...
Name: monodoc2mediawiki.xsl
Type: text/xml
Size: 5606 bytes
Desc: not available
Url : <A HREF="http://lists.ximian.com/pipermail/mono-docs-list/attachments/20051208/d7a19f20/monodoc2mediawiki.xsl">http://lists.ximian.com/pipermail/mono-docs-list/attachments/20051208/d7a19f20/monodoc2mediawiki.xsl</A>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001526.html">[Mono-docs-list] Wiki Markup for ECMA documents.
</A></li>
	<LI>Next message: <A HREF="001525.html">[Mono-docs-list] Wiki Markup for ECMA documents.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1528">[ date ]</a>
              <a href="thread.html#1528">[ thread ]</a>
              <a href="subject.html#1528">[ subject ]</a>
              <a href="author.html#1528">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-docs-list">More information about the Mono-docs-list
mailing list</a><br>
</body></html>
