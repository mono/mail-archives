<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-docs-list] Ecma CIL class docs DTD and XML Schema
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pt99par%40student.bth.se">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000462.html">
   <LINK REL="Next"  HREF="000464.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-docs-list] Ecma CIL class docs DTD and XML Schema
   </H1>
    <B>Per Arneng
    </B> 
    <A HREF="mailto:pt99par%40student.bth.se"
       TITLE="[Mono-docs-list] Ecma CIL class docs DTD and XML Schema">pt99par@student.bth.se
       </A><BR>
    <I>Tue, 8 Apr 2003 01:56:24 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000462.html">[Mono-docs-list] Mono Handbook - Available Jobs
</A></li>
        <LI> Next message: <A HREF="000464.html">[Mono-docs-list] Note on ECMA DTD
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#463">[ date ]</a>
              <a href="thread.html#463">[ thread ]</a>
              <a href="subject.html#463">[ subject ]</a>
              <a href="author.html#463">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--Boundary-00=_ISmk+z3OCv532dV
Content-Type: text/plain;
  charset=&quot;us-ascii&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hi!

I found a DTD in a zip file containing the class library documentation 
submitted to ecma. Converted it using w3c's little perl script to xml schema.

Best regards
 Per Arneng
--Boundary-00=_ISmk+z3OCv532dV
Content-Type: text/x-dtd;
  charset=&quot;us-ascii&quot;;
  name=&quot;All.dtd&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=&quot;All.dtd&quot;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- edited with XML Spy v4.4 U (<A HREF="http://www.xmlspy.com">http://www.xmlspy.com</A>) by Rex Jaeschke (private) --&gt;
&lt;!ELEMENT AssemblyCulture (#PCDATA)&gt;
&lt;!ELEMENT AssemblyInfo (AssemblyName, AssemblyPublicKey, AssemblyVersion, AssemblyCulture, Attributes)&gt;
&lt;!ELEMENT AssemblyName (#PCDATA)&gt;
&lt;!ELEMENT AssemblyPublicKey (#PCDATA)&gt;
&lt;!ELEMENT AssemblyVersion (#PCDATA)&gt;
&lt;!ELEMENT Attribute (AttributeName, Excluded, ExcludedTypeName?, ExcludedLibraryName?)&gt;
&lt;!ELEMENT AttributeName (#PCDATA)&gt;
&lt;!ELEMENT Attributes (Attribute*)&gt;
&lt;!ELEMENT Base (BaseTypeName?, ExcludedBaseTypeName?, ExcludedLibraryName?)&gt;
&lt;!ELEMENT BaseTypeName (#PCDATA)&gt;
&lt;!ELEMENT Docs (summary?, altmember?, altcompliant?, param*, returns?, value?, exception*, threadsafe?, remarks?, example?, permission?, example?)&gt;
&lt;!ELEMENT Excluded (#PCDATA)&gt;
&lt;!ELEMENT ExcludedBaseTypeName (#PCDATA)&gt;
&lt;!ELEMENT ExcludedLibrary (#PCDATA)&gt;
&lt;!ELEMENT ExcludedLibraryName (#PCDATA)&gt;
&lt;!ELEMENT ExcludedTypeName (#PCDATA)&gt;
&lt;!ELEMENT Interface (InterfaceName, Excluded)&gt;
&lt;!ELEMENT InterfaceName (#PCDATA)&gt;
&lt;!ELEMENT Interfaces (Interface*)&gt;
&lt;!ELEMENT Libraries (Types+)&gt;
&lt;!ELEMENT Member (MemberSignature+, MemberType, Attributes?, ReturnValue, Parameters, MemberValue?, Docs, Excluded, ExcludedLibrary*)&gt;
&lt;!ATTLIST Member
	MemberName NMTOKEN #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT MemberOfLibrary (#PCDATA)&gt;
&lt;!ELEMENT MemberSignature EMPTY&gt;
&lt;!ATTLIST MemberSignature
	Language CDATA #REQUIRED
	Value CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT MemberType (#PCDATA)&gt;
&lt;!ELEMENT MemberValue (#PCDATA)&gt;
&lt;!ELEMENT Members (Member*)&gt;
&lt;!ELEMENT PRE EMPTY&gt;
&lt;!ELEMENT Parameter (Attributes?)&gt;
&lt;!ATTLIST Parameter
	Name NMTOKEN #REQUIRED
	Type CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT Parameters (Parameter*)&gt;
&lt;!ELEMENT ReturnType (#PCDATA)&gt;
&lt;!ELEMENT ReturnValue (ReturnType?)&gt;
&lt;!ELEMENT SPAN (#PCDATA | para | paramref | SPAN | see | block)*&gt;
&lt;!ELEMENT ThreadingSafetyStatement (#PCDATA)&gt;
&lt;!ELEMENT Type (TypeSignature+, MemberOfLibrary, AssemblyInfo, ThreadingSafetyStatement?, Docs, Base, Interfaces, Attributes?, Members, TypeExcluded)&gt;
&lt;!ATTLIST Type
	Name NMTOKEN #REQUIRED
	FullName NMTOKEN #REQUIRED
	FullNameSP NMTOKEN #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT TypeExcluded (#PCDATA)&gt;
&lt;!ELEMENT TypeSignature EMPTY&gt;
&lt;!ATTLIST TypeSignature
	Language CDATA #REQUIRED
	Value CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT Types (Type+)&gt;
&lt;!ATTLIST Types
	Library NMTOKEN #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT altcompliant EMPTY&gt;
&lt;!ATTLIST altcompliant
	cref CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT altmember EMPTY&gt;
&lt;!ATTLIST altmember
	cref CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT block (#PCDATA | see | para | paramref | list | block | c | subscript | code | sup | pi)*&gt;
&lt;!ATTLIST block
	subset CDATA #REQUIRED
	type NMTOKEN #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT c (#PCDATA | para | paramref | code | see)*&gt;
&lt;!ELEMENT code (#PCDATA)&gt;
&lt;!ATTLIST code
	lang CDATA #IMPLIED
&gt;<i>
</I>&lt;!ELEMENT codelink EMPTY&gt;
&lt;!ATTLIST codelink
	SampleID CDATA #REQUIRED
	SnippetID CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT description (#PCDATA | SPAN | paramref | para | see | c | permille | block | sub)*&gt;
&lt;!ELEMENT example (#PCDATA | para | code | c | codelink | see)*&gt;
&lt;!ELEMENT exception (#PCDATA | paramref | see | para | SPAN | block)*&gt;
&lt;!ATTLIST exception
	cref CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT i (#PCDATA)&gt;
&lt;!ELEMENT item (term, description*)&gt;
&lt;!ELEMENT list (listheader?, item*)&gt;
&lt;!ATTLIST list
	type NMTOKEN #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT listheader (term, description+)&gt;
&lt;!ELEMENT onequarter EMPTY&gt;
&lt;!ELEMENT para (#PCDATA | see | block | paramref | c | onequarter | superscript | sup | permille | SPAN | list | pi | theta | sub)*&gt;
&lt;!ELEMENT param (#PCDATA | c | paramref | see | block | para | SPAN)*&gt;
&lt;!ATTLIST param
	name CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT paramref EMPTY&gt;
&lt;!ATTLIST paramref
	name CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT permille EMPTY&gt;
&lt;!ELEMENT permission (#PCDATA | see | paramref | para | block)*&gt;
&lt;!ATTLIST permission
	cref CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT pi EMPTY&gt;
&lt;!ELEMENT pre EMPTY&gt;
&lt;!ELEMENT remarks (#PCDATA | para | block | list | c | paramref | see | pre | SPAN | code | PRE)*&gt;
&lt;!ELEMENT returns (#PCDATA | para | list | paramref | see)*&gt;
&lt;!ELEMENT see EMPTY&gt;
&lt;!ATTLIST see
	cref CDATA #IMPLIED
	langword CDATA #IMPLIED
	qualify CDATA #IMPLIED
&gt;<i>
</I>&lt;!ELEMENT sub (#PCDATA | paramref)*&gt;
&lt;!ELEMENT subscript EMPTY&gt;
&lt;!ATTLIST subscript
	term CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT summary (#PCDATA | para | see | block | list)*&gt;
&lt;!ELEMENT sup (#PCDATA | i | paramref)*&gt;
&lt;!ELEMENT superscript EMPTY&gt;
&lt;!ATTLIST superscript
	term CDATA #REQUIRED
&gt;<i>
</I>&lt;!ELEMENT term (#PCDATA | block | see | paramref | para | c | sup | pi | theta)*&gt;
&lt;!ELEMENT theta EMPTY&gt;
&lt;!ELEMENT threadsafe (para+)&gt;
&lt;!ELEMENT value (#PCDATA | para | list | see)*&gt;

--Boundary-00=_ISmk+z3OCv532dV
Content-Type: text/plain;
  charset=&quot;us-ascii&quot;;
  name=&quot;All.xsd&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=&quot;All.xsd&quot;

&lt;schema
  xmlns='<A HREF="http://www.w3.org/2000/10/XMLSchema'">http://www.w3.org/2000/10/XMLSchema'</A>
  targetNamespace='<A HREF="http://www.w3.org/namespace/'">http://www.w3.org/namespace/'</A>
  xmlns:t='<A HREF="http://www.w3.org/namespace/'">http://www.w3.org/namespace/'</A>&gt;

 &lt;element name='AssemblyCulture'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='AssemblyInfo'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:AssemblyName'/&gt;
    &lt;element ref='t:AssemblyPublicKey'/&gt;
    &lt;element ref='t:AssemblyVersion'/&gt;
    &lt;element ref='t:AssemblyCulture'/&gt;
    &lt;element ref='t:Attributes'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='AssemblyName'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='AssemblyPublicKey'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='AssemblyVersion'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Attribute'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:AttributeName'/&gt;
    &lt;element ref='t:Excluded'/&gt;
    &lt;element ref='t:ExcludedTypeName' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:ExcludedLibraryName' minOccurs='0' maxOccurs='1'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='AttributeName'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Attributes'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:Attribute' minOccurs='0' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Base'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:BaseTypeName' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:ExcludedBaseTypeName' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:ExcludedLibraryName' minOccurs='0' maxOccurs='1'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='BaseTypeName'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Docs'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:summary' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:altmember' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:altcompliant' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:param' minOccurs='0' maxOccurs='unbounded'/&gt;
    &lt;element ref='t:returns' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:value' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:exception' minOccurs='0' maxOccurs='unbounded'/&gt;
    &lt;element ref='t:threadsafe' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:remarks' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:example' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:permission' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:example' minOccurs='0' maxOccurs='1'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Excluded'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='ExcludedBaseTypeName'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='ExcludedLibrary'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='ExcludedLibraryName'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='ExcludedTypeName'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Interface'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:InterfaceName'/&gt;
    &lt;element ref='t:Excluded'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='InterfaceName'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Interfaces'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:Interface' minOccurs='0' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Libraries'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:Types' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Member'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:MemberSignature' maxOccurs='unbounded'/&gt;
    &lt;element ref='t:MemberType'/&gt;
    &lt;element ref='t:Attributes' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:ReturnValue'/&gt;
    &lt;element ref='t:Parameters'/&gt;
    &lt;element ref='t:MemberValue' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:Docs'/&gt;
    &lt;element ref='t:Excluded'/&gt;
    &lt;element ref='t:ExcludedLibrary' minOccurs='0' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
   &lt;attribute name='MemberName' type='NMTOKEN' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='MemberOfLibrary'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='MemberSignature'&gt;
  &lt;complexType&gt;
   &lt;attribute name='Language' type='string' use='required'/&gt;
   &lt;attribute name='Value' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='MemberType'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='MemberValue'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Members'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:Member' minOccurs='0' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='PRE'&gt;
  &lt;complexType/&gt;
 &lt;/element&gt;

 &lt;element name='Parameter'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:Attributes' minOccurs='0' maxOccurs='1'/&gt;
   &lt;/sequence&gt;
   &lt;attribute name='Name' type='NMTOKEN' use='required'/&gt;
   &lt;attribute name='Type' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Parameters'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:Parameter' minOccurs='0' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='ReturnType'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='ReturnValue'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:ReturnType' minOccurs='0' maxOccurs='1'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='SPAN'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:SPAN'/&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:block'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='ThreadingSafetyStatement'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Type'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:TypeSignature' maxOccurs='unbounded'/&gt;
    &lt;element ref='t:MemberOfLibrary'/&gt;
    &lt;element ref='t:AssemblyInfo'/&gt;
    &lt;element ref='t:ThreadingSafetyStatement' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:Docs'/&gt;
    &lt;element ref='t:Base'/&gt;
    &lt;element ref='t:Interfaces'/&gt;
    &lt;element ref='t:Attributes' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:Members'/&gt;
    &lt;element ref='t:TypeExcluded'/&gt;
   &lt;/sequence&gt;
   &lt;attribute name='Name' type='NMTOKEN' use='required'/&gt;
   &lt;attribute name='FullName' type='NMTOKEN' use='required'/&gt;
   &lt;attribute name='FullNameSP' type='NMTOKEN' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='TypeExcluded'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='TypeSignature'&gt;
  &lt;complexType&gt;
   &lt;attribute name='Language' type='string' use='required'/&gt;
   &lt;attribute name='Value' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='Types'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:Type' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
   &lt;attribute name='Library' type='NMTOKEN' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='altcompliant'&gt;
  &lt;complexType&gt;
   &lt;attribute name='cref' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='altmember'&gt;
  &lt;complexType&gt;
   &lt;attribute name='cref' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='block'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:list'/&gt;
    &lt;element ref='t:block'/&gt;
    &lt;element ref='t:c'/&gt;
    &lt;element ref='t:subscript'/&gt;
    &lt;element ref='t:code'/&gt;
    &lt;element ref='t:sup'/&gt;
    &lt;element ref='t:pi'/&gt;
   &lt;/choice&gt;
   &lt;attribute name='subset' type='string' use='required'/&gt;
   &lt;attribute name='type' type='NMTOKEN' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='c'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:code'/&gt;
    &lt;element ref='t:see'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='code'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;attribute name='lang' type='string' use='optional'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='codelink'&gt;
  &lt;complexType&gt;
   &lt;attribute name='SampleID' type='string' use='required'/&gt;
   &lt;attribute name='SnippetID' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='description'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:SPAN'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:c'/&gt;
    &lt;element ref='t:permille'/&gt;
    &lt;element ref='t:block'/&gt;
    &lt;element ref='t:sub'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='example'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:code'/&gt;
    &lt;element ref='t:c'/&gt;
    &lt;element ref='t:codelink'/&gt;
    &lt;element ref='t:see'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='exception'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:SPAN'/&gt;
    &lt;element ref='t:block'/&gt;
   &lt;/choice&gt;
   &lt;attribute name='cref' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='i'&gt;
  &lt;complexType mixed='true'&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='item'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:term'/&gt;
    &lt;element ref='t:description' minOccurs='0' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='list'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:listheader' minOccurs='0' maxOccurs='1'/&gt;
    &lt;element ref='t:item' minOccurs='0' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
   &lt;attribute name='type' type='NMTOKEN' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='listheader'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:term'/&gt;
    &lt;element ref='t:description' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='onequarter'&gt;
  &lt;complexType/&gt;
 &lt;/element&gt;

 &lt;element name='para'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:block'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:c'/&gt;
    &lt;element ref='t:onequarter'/&gt;
    &lt;element ref='t:superscript'/&gt;
    &lt;element ref='t:sup'/&gt;
    &lt;element ref='t:permille'/&gt;
    &lt;element ref='t:SPAN'/&gt;
    &lt;element ref='t:list'/&gt;
    &lt;element ref='t:pi'/&gt;
    &lt;element ref='t:theta'/&gt;
    &lt;element ref='t:sub'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='param'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:c'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:block'/&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:SPAN'/&gt;
   &lt;/choice&gt;
   &lt;attribute name='name' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='paramref'&gt;
  &lt;complexType&gt;
   &lt;attribute name='name' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='permille'&gt;
  &lt;complexType/&gt;
 &lt;/element&gt;

 &lt;element name='permission'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:block'/&gt;
   &lt;/choice&gt;
   &lt;attribute name='cref' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='pi'&gt;
  &lt;complexType/&gt;
 &lt;/element&gt;

 &lt;element name='pre'&gt;
  &lt;complexType/&gt;
 &lt;/element&gt;

 &lt;element name='remarks'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:block'/&gt;
    &lt;element ref='t:list'/&gt;
    &lt;element ref='t:c'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:pre'/&gt;
    &lt;element ref='t:SPAN'/&gt;
    &lt;element ref='t:code'/&gt;
    &lt;element ref='t:PRE'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='returns'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:list'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:see'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='see'&gt;
  &lt;complexType&gt;
   &lt;attribute name='cref' type='string' use='optional'/&gt;
   &lt;attribute name='langword' type='string' use='optional'/&gt;
   &lt;attribute name='qualify' type='string' use='optional'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='sub'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;sequence minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:paramref'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='subscript'&gt;
  &lt;complexType&gt;
   &lt;attribute name='term' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='summary'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:block'/&gt;
    &lt;element ref='t:list'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='sup'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:i'/&gt;
    &lt;element ref='t:paramref'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='superscript'&gt;
  &lt;complexType&gt;
   &lt;attribute name='term' type='string' use='required'/&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='term'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:block'/&gt;
    &lt;element ref='t:see'/&gt;
    &lt;element ref='t:paramref'/&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:c'/&gt;
    &lt;element ref='t:sup'/&gt;
    &lt;element ref='t:pi'/&gt;
    &lt;element ref='t:theta'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='theta'&gt;
  &lt;complexType/&gt;
 &lt;/element&gt;

 &lt;element name='threadsafe'&gt;
  &lt;complexType&gt;
   &lt;sequence&gt;
    &lt;element ref='t:para' maxOccurs='unbounded'/&gt;
   &lt;/sequence&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;

 &lt;element name='value'&gt;
  &lt;complexType mixed='true'&gt;
   &lt;choice minOccurs='0' maxOccurs='unbounded'&gt;
    &lt;element ref='t:para'/&gt;
    &lt;element ref='t:list'/&gt;
    &lt;element ref='t:see'/&gt;
   &lt;/choice&gt;
  &lt;/complexType&gt;
 &lt;/element&gt;
&lt;/schema&gt;

--Boundary-00=_ISmk+z3OCv532dV
Content-Type: text/x-perl;
  charset=&quot;us-ascii&quot;;
  name=&quot;dtd2xsd.pl&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=&quot;dtd2xsd.pl&quot;

#! perl
#
# by Dan Connolly <A HREF="http://www.w3.org/People/Connolly/">http://www.w3.org/People/Connolly/</A> <A HREF="mailto:connolly@w3.org">connolly@w3.org</A>
#    Bert Bos <A HREF="http://www.w3.org/People/Bos/">http://www.w3.org/People/Bos/</A> &lt;<A HREF="mailto:bert@w3.org">bert@w3.org</A>&gt;
#    Yuichi Koike
#    Mary Holstege (<A HREF="mailto:holstege@mathling.com">holstege@mathling.com</A>)
# initial hack by DC Apr 2000, based on dtd2bnf by BB Mar 1998;
# major revision to Apr 2000 make it actually usable by YK;
# tweaks by DC; major update Jan 2001 by MH
#
# see Log since then at end.
# $Id: dtd2xsd.pl,v 1.17 2001/01/19 05:59:12 connolly Exp $

use strict;

# Handling command line argument
my $targetNS = &quot;<A HREF="http://www.w3.org/namespace/";">http://www.w3.org/namespace/&quot;;</A>
my $prefix = &quot;t&quot;;
my $alias = 0;
my $file = &quot;&quot;;
my %SimpleTypes;
my @AttrGroupPatterns;
my @ModelGroupPatterns;
my @SubstitutionGroupPatterns;
my %SubstitutionGroup;

my %Mixed;
my %ModelGroup;
my $mapping_file;
my $pcdata_flag = 0;
my $pcdata_simpletype = &quot;string&quot;;
my $debug = 0;

while ($#ARGV &gt;= 0) {
	 my $para = shift(@ARGV);
	 if ($para eq &quot;-ns&quot;) {
		  $targetNS = shift(@ARGV);
	 } elsif ($para eq &quot;-prefix&quot;) {
		  $prefix = shift(@ARGV);
	 } elsif ($para eq &quot;-alias&quot;) {
		  $alias = 1;
	 } elsif ($para eq &quot;-pcdata&quot;) {
		  # Treat #PCDATA by itself as being string (or other simple type
		  # if so designated in the mapping file)
		  $pcdata_flag = 1;
	 } elsif ($para eq &quot;-mapfile&quot;) {
		  $mapping_file = shift(@ARGV);
	 } elsif ($para eq &quot;-simpletype&quot;) {
		  my($pat) = shift(@ARGV);
		  my($b) = shift(@ARGV);
		  $SimpleTypes{$pat} = $b;
	 } elsif ($para eq &quot;-attrgroup&quot;) {
		  push(@AttrGroupPatterns, shift(@ARGV));
	 } elsif ($para eq &quot;-modelgroup&quot;) {
		  push(@ModelGroupPatterns, shift(@ARGV));
	 } elsif ($para eq &quot;-substgroup&quot;) {
		  push(@SubstitutionGroupPatterns, shift(@ARGV));
	 } elsif ($para eq &quot;-debug&quot;) {
		  $debug = 1;
	 } else {
		  $file = $para;
	 }
}

# Alias dictionary: defaults
my %alias_dic;
$alias_dic{&quot;URI&quot;} = &quot;uriReference&quot;;
$alias_dic{&quot;LANG&quot;} = &quot;language&quot;;
$alias_dic{&quot;NUMBER&quot;} = &quot;nonNegativeInteger&quot;;
$alias_dic{&quot;Date&quot;} = &quot;date&quot;;
$alias_dic{&quot;Boolean&quot;} = &quot;boolean&quot;;

if ( $mapping_file )
{
	 print STDERR &quot;Open mapping $mapping_file &quot;;
	 if ( !open( MAPPINGS, &quot;&lt;$mapping_file&quot; ) )
	 {
		  print STDERR &quot;unsuccessful.\n&quot;;
	 }
	 else {
		  print STDERR &quot;successful.\n&quot;;
		  while ( &lt;MAPPINGS&gt; ) {
				chop;
				if ( /^alias\s+([^ \t]+)\s*=\s*([^ \t]+)\s*/i ) {
					 $alias_dic{$1} = $2;
				}
				elsif ( /^simpletype\s+([^ \t]+)\s*=\s*([^ \t]+)\s*/i ) {
					 $SimpleTypes{$1} = $2;
				}
				elsif ( /^attrgroup\s+([^ \t]+)\s*/i ) {
					 push( @AttrGroupPatterns, $1 );
				}
				elsif ( /^modelgroup\s+([^ \t]+)\s*/i ) {
					 push( @ModelGroupPatterns, $1 );
				}
				elsif ( /^substgroup\s+([^ \t]+)\s*/i ) {
					 push( @SubstitutionGroupPatterns, $1 );
				}
				elsif ( /^pcdata\s+([^ \t]+)\s*/i ) {
					 ## BUGLET: doesn't pay attention to prefix; just a special alias
					 $pcdata_simpletype = $1;
				}
		  }
	 }

	 foreach my $key (keys(%alias_dic)) 
	 {
		  print STDERR &quot;Alias \%$key to $alias_dic{$key}\n&quot;
		  }
}

# Variable declaration
my $linelen = 72;

my $PROG = substr($0, rindex($0, &quot;/&quot;) + 1);
my $USAGE = &quot;Usage: $PROG file\n&quot;;

my $str = &quot;(?:\&quot;([^\&quot;]*)\&quot;|\'([^\']*)\')&quot;;
my %pent;				# Parameter entities
my %attributes;			# Attribute lists
my @element;			# Elements in source order
my %model;				# Content models

# Main
$/ = undef;

# Open file, remove comment and include external entity
my $buf = openFile($file);

# Alias treatment
my $alias_ident = &quot;_alias_&quot;;
if ($alias eq 1) {
	 foreach my $key (keys(%alias_dic)) {
		  my $aliaskey = sprintf(&quot;%s%s%s&quot;, $alias_ident, $key, $alias_ident);
		  $buf =~ s/\%$key;/$aliaskey/gsie;
	 }
}


# store all parameter entities
while ($buf =~ s/&lt;!ENTITY\s+%\s+(\S+)\s+$str\s*&gt;//sie) {
    my($n, $repltext) = ($1, $2.$3);
    my ($pat);

    next if $pent{$n}; # only the first declaration of an entity counts

    foreach $pat (keys %SimpleTypes){
		  if ($n =~ /^$pat$/){
				$buf .= &quot; &lt;!_DATATYPE $n $SimpleTypes{$pat} $repltext&gt; &quot;;
				$pent{$n} = &quot;#DATATYPEREF $n&quot;;
				undef $n;
				last;
		  }
    }

    foreach $pat (@AttrGroupPatterns){
		  if ($n =~ /^$pat$/){
				$buf .= &quot; &lt;!_ATTRGROUP $n $repltext&gt; &quot;;
				$pent{$n} = &quot;#ATTRGROUPREF $n&quot;;
				undef $n;
				last;
		  }
    }

    foreach $pat (@ModelGroupPatterns){
		  if ($n =~ /^$pat$/){
				$buf .= &quot; &lt;!_MODELGROUP $n $repltext&gt; &quot;;
				$pent{$n} = &quot;#MODELGROUPREF $n&quot;;
				undef $n;
				last;
		  }
    }

    foreach $pat (@SubstitutionGroupPatterns){
		  if ($n =~ /^$pat$/){
				$buf .= &quot; &lt;!_SUBSTGROUP $n $repltext&gt; &quot;;
				$pent{$n} = &quot;#SUBSTGROUPREF $n&quot;;
				undef $n;
				last;
		  }

    }

    $pent{$n}=$repltext if $n;
}

# remove all general entities
$buf =~ s/&lt;!ENTITY\s+.*?&gt;//gsie;

# loop until parameter entities fully expanded
my $i;
do {
	 # count # of substitutions
	 $i = 0;
	 # expand parameter entities
	 $buf =~ s/%([a-zA-Z0-9_\.-]+);?/$i++,$pent{$1}/gse;
} while ($i != 0);

# treat conditional sections
while($buf =~ s/&lt;!\[\s*?INCLUDE\s*?\[(.*)\]\]&gt;/\1/gsie) {};
while($buf =~ s/&lt;!\[\s*?IGNORE\s*?\[.*\]\]&gt;//gsie) {};

# store attribute lists
$buf =~ s/&lt;!ATTLIST\s+(\S+)\s+(.*?)&gt;/store_att($1, $2)/gsie;

# store content models
$buf =~ s/&lt;!ELEMENT\s+(\S+)\s+(.+?)&gt;/store_elt($1, $2)/gsie;

#print &quot;&lt;?xml version='1.0'?&gt;\n&quot;;
print &quot;&lt;schema
  xmlns='<A HREF="http://www.w3.org/2000/10/XMLSchema'">http://www.w3.org/2000/10/XMLSchema'</A>
  targetNamespace='$targetNS'
  xmlns:$prefix='$targetNS'&gt;\n&quot;;

# find maximum length of non-terminals
#my $maxlen = max(map(length, @element)) + 4;

# write simple type declarations
$buf =~ s/&lt;!_DATATYPE\s+(\S+)\s+(\S+)\s+(.+?)&gt;/write_simpleType($1, $2, $3)/gsie;

# write attribute groups
$buf =~ s/&lt;!_ATTRGROUP\s+(\S+)\s+(.+?)&gt;/write_attrGroup($1, $2)/gsie;

# write model groups
$buf =~ s/&lt;!_MODELGROUP\s+(\S+)\s+(.+?)&gt;/write_modelGroup($1, $2)/gsie;

# write subsitution groups
$buf =~ s/&lt;!_SUBSTGROUP\s+(\S+)\s+(.+?)&gt;/write_substitutionGroup($1, $2)/gsie;


my($e);

# loop over elements, writing XML schema
foreach $e (@element) {
	 my $h = $model{$e};
	 my $h2 = $attributes{$e};
	 my @model = @$h;
	 my $isSimple = ($pcdata_flag eq 1) &amp;&amp; ($model[1] eq '#PCDATA') &amp;&amp;
		  ( ($#model eq 2) || 
			 ( ($#model eq 3) &amp;&amp; ($model[3] eq '*') ) );

	 my $substGroup = $SubstitutionGroup{$e};
	 if ( $substGroup )
	 {
		  $substGroup = &quot; substitutionGroup='$substGroup'&quot;;
	 }

	 # print rule for element $e
	 if ( $isSimple &amp;&amp; ! $h2 )
	 {
		  # Assume (#PCDATA) is string
		  print &quot;\n &lt;element name='$e' type='$pcdata_simpletype'$substGroup&gt;\n&quot;;
	 }
	 else {
		  print &quot;\n &lt;element name='$e'$substGroup&gt;\n&quot;;
	 }

	 if ( $isSimple )
	 {
		  # Assume (#PCDATA) is string
		  if ( $h2 ) 
		  {
				print &quot;  &lt;complexType&gt;\n&quot;;
				print &quot;  &lt;simpleContent&gt;\n&quot;;
				print &quot;  &lt;extension base='string'&gt;\n&quot;;
		  }
	 }

	 else {
		  # print rule for $e's content model
		  print &quot;  &lt;complexType&quot;;
		  if ($model[0] eq 'EMPTY') {
				if (! $h2 ) {
					 print &quot;/&gt;\n&quot;;
				} else {
					 print &quot;&gt;\n&quot;;
				}
		  } 
		  elsif ( $model[0] eq 'ANY' )
		  {
				print &quot;&gt;\n&quot;;
				print &quot;   &lt;sequence&gt;\n&quot;;
				print &quot;   &lt;any namespace='$targetNS'/&gt;\n&quot;;
				print &quot;   &lt;/sequence&gt;\n&quot;;
		  }
		  else {
				if ( $debug eq 1 ) {
					 print STDERR &quot;==mixed? @model\n&quot;; #@@
				}
				if (&amp;isMixed(@model)) {
					 print &quot; mixed='true'&gt;\n&quot;;
				}
				else {
					 print &quot;&gt;\n&quot;;
				}

				my @list = &amp;makeChildList('', @model);
				&amp;printChildList(3, @list);
		  }
	 }

	 # print rule for $e's attributes
	 if (! $h2) {
		  # nothing
	 } else {
		  &amp;printAttrDecls(@$h2);
		  if ( $isSimple ) {
				print &quot;   &lt;/extension&gt;\n&quot;;
				print &quot;   &lt;/simpleContent&gt;\n&quot;;
		  }
	 }

	 if ( !$h2 &amp;&amp; $isSimple ) {
		  # Do nothing
	 }
	 elsif ($h2 || $model[0] ne 'EMPTY') {
		  print &quot;  &lt;/complexType&gt;\n&quot;;
	 }

	 print &quot; &lt;/element&gt;\n&quot;;
}

print &quot;&lt;/schema&gt;\n&quot;;
exit;

sub printSpace
{
	 my ($num) = $_[0];
	 for (my $i=0; $i&lt;$num; $i++) {
		  print &quot; &quot;;
	 }
}

sub printChildList
{
	 my ($num, @list) = @_;

	 my @currentTag = ();
	 for (my $i=0; $i&lt;= $#list; $i++) {
		  my $n = $list[$i];

		  if ($n eq 0 || $n eq 1 || $n eq 2 || $n eq 3) {
				if ( ($pcdata_flag eq 0) &amp;&amp; ($n eq 0 || $n eq 1) &amp;&amp; $list[$i+1] eq 20)
				{
					 # The whole list is 0 20 or 1 20; i.e. (#PCDATA) or (#PCDATA)*. 
					 # Don't generate a sequence child; mixed handles all this.
				}
				else {
#            my $do_it_flag = 1;
					 if ( $currentTag[$#currentTag] eq &quot;&quot; &amp;&amp; $n eq 0 )
					 {
						  push(@currentTag, &quot;&quot;);
#  					 my $n_1 = $list[$i+1];
#  					 if ( $n_1 eq 10 || $n_1 eq 11 || $n_1 eq 12 || $n_1 eq 13 )
#  					 {
#  						  # do nothing: we have a phantom sequence wrapping a choice
#  						  # that we want to not want to appear. OTOH we want a top 
#  						  # level sequence in other cases.
#  						  $do_it_flag = 0;
#  					 }
					 }

#  				if ( $do_it_flag eq 1 )
#  {
					 printSpace($num); $num++;
					 print &quot;&lt;sequence&quot;;
					 if ($n eq 1) {
						  print &quot; minOccurs='0' maxOccurs='unbounded'&quot;;
					 } elsif ($n eq 2) {
						  print &quot; maxOccurs='unbounded'&quot;;
					 } elsif ($n eq 3) {
						  print &quot; minOccurs='0' maxOccurs='1'&quot;;
					 }
					 print &quot;&gt;\n&quot;;
					 push(@currentTag, &quot;sequence&quot;);
				}
#}
		  } elsif ($n eq 10 || $n eq 11 || $n eq 12 || $n eq 13) {
				printSpace($num); $num++;
				print &quot;&lt;choice&quot;;
				if ($n eq 11) {
					 print &quot; minOccurs='0' maxOccurs='unbounded'&quot;;
				} elsif ($n eq 12) {
					 print &quot; maxOccurs='unbounded'&quot;;
				} elsif ($n eq 13) {
					 print &quot; minOccurs='0' maxOccurs='1'&quot;;
				}
				print &quot;&gt;\n&quot;;
				push(@currentTag, &quot;choice&quot;);
		  } elsif ($n eq 20) {
				my $tag = pop(@currentTag);
				if ($tag ne &quot;&quot;) {
					 $num--; printSpace($num);
					 print &quot;&lt;/&quot;, $tag, &quot;&gt;\n&quot;;
				}
		  } else {
				printSpace($num);
				if ($n eq '#MODELGROUPREF') {
					 print &quot;&lt;group ref='$prefix:$list[++$i]'&quot;;
				}
				elsif ($n eq '#SUBSTGROUPREF') {
					 print &quot;&lt;element ref='$prefix:$list[++$i]'&quot;;
				} else {
					 print &quot;&lt;element ref='$prefix:$n'&quot;;
				}

				if ($currentTag[$#currentTag] ne &quot;choice&quot;) {
					 if ($list[$i+1] eq &quot;+&quot;) {
						  print &quot; maxOccurs='unbounded'&quot;;
						  $i++;
					 } elsif ($list[$i+1] eq &quot;?&quot;) {
						  print &quot; minOccurs='0' maxOccurs='1'&quot;;
						  $i++;
					 } elsif ($list[$i+1] eq &quot;*&quot;) {
						  print &quot; minOccurs='0' maxOccurs='unbounded'&quot;;
						  $i++;
					 }
				}
				print &quot;/&gt;\n&quot;;
		  }
	 }
}

sub makeChildList {
	 my ($groupName, @model) = @_;
	 my @ret = ();
	 my @brace = ();
	 for (my $i=0; $i&lt;=$#model; $i++) {
		  my $n = $model[$i];

		  if ($n eq &quot;(&quot;) {
				push(@ret, 0);
				push(@brace, $#ret);
		  } elsif ($n eq &quot;)&quot;) {
				if ($model[$i+1] eq &quot;*&quot;) {
					 $ret[$brace[$#brace]] += 1;
					 $i++;
				} elsif ($model[$i+1] eq &quot;+&quot;) {
					 $ret[$brace[$#brace]] += 2;
					 $i++;
				} elsif ($model[$i+1] eq &quot;?&quot;) {
					 $ret[$brace[$#brace]] += 3;
					 $i++;
				}
				pop(@brace);
				push(@ret, 20);
		  } elsif ($n eq &quot;,&quot;) {
				$ret[$brace[$#brace]] = 0;
		  } elsif ($n eq &quot;|&quot;) {
				$ret[$brace[$#brace]] = 10;
		  } elsif ($n eq &quot;#PCDATA&quot;) {
				if ($model[$i+1] eq &quot;|&quot;) {
					 $i++;
				}
				if($groupName){
					 $Mixed{$groupName} = 1;
				}
		  } else {
				push(@ret, $n);
		  }
	 }

	 # &quot;( ( a | b | c )* )&quot; gets mapped to &quot;0 10 a b c 20 20&quot; which will generate
	 # a spurious sequence element. This is not too harmful when this is an
	 # element content model, but with model groups it is incorrect.
	 # In general we need to strip off 0 20 from the ends when it is redundant. 
	 # Redundant means: there is some other group that bounds the whole list. 
	 # Note that it gets a little tricky:
	 # ( (a|b),(c|d) ) gets mapped to &quot;0 10 a b 20 10 c d 20 20&quot;. If one
	 # naively chops off the 0 and 20 on the groups that there is a 10 on one
	 # end and a 20 on the other, one loses the bounding sequence, which is 
	 # required in this case.
	 #
	 if ( $ret[0] eq 0 &amp;&amp; $ret[$#ret] eq 20 &amp;&amp; $ret[$#ret-1] eq 20 &amp;&amp;
			( $ret[1] eq 0 || $ret[1] eq 1 || $ret[1] eq 2 || $ret[1] eq 3 ||
			  $ret[1] eq 10 || $ret[1] eq 11 || $ret[1] eq 12 || $ret[1] eq 13 )
			)
	 {
		  # OK, it is possible that the 0 20 is redundant. Now scan for balance:
		  # All interim 20 between the proposed new start and the proposed new
		  # final one should be at level 1 or above. 
		  my $depth = 0;
		  my $redundant_paren = 1;  # Assume redundant until proved otherwise
		  for ( my $i = 1; $i &lt;= $#ret-1; $i++ )
		  {
				if ( $ret[$i] eq 20 )
				{
					 $depth--;
					 if ( $i &lt; $#ret-1 &amp;&amp; $depth &lt; 1 )
					 {
						  $redundant_paren = 0;
						  print STDERR &quot;i=$i,depth=$depth\n&quot;;
					 }
				}
				elsif ( $ret[$i] eq 0 || 
						  $ret[$i] eq 1 || 
						  $ret[$i] eq 2 || 
						  $ret[$i] eq 3 ||
						  $ret[$i] eq 10 || 
						  $ret[$i] eq 11 || 
						  $ret[$i] eq 12 || 
						  $ret[$i] eq 13 
						  )
				{
					 $depth++;
				}
		  }  # for

		  if ( $redundant_paren eq 1 )
		  {
				print STDERR &quot;Truncating @ret\n&quot;;
				@ret = @ret[1..$#ret-1];
		  }
	 }

	 if ( $debug eq 1 ) {
		  print STDERR &quot;@model to @ret\n&quot;;
	 }
	 return @ret;
}


sub printAttrDecls{
    my @atts = @_;

    for (my $i = 0; $i &lt;= $#atts; $i++) {
		  if ($atts[$i] eq '#ATTRGROUPREF'){
				print &quot;   &lt;attributeGroup ref='$prefix:$atts[$i+1]'/&gt;\n&quot;;
				$i ++;
		  } else {
				# attribute name
				print &quot;   &lt;attribute name='$atts[$i]'&quot;;

				# attribute type
				my @enume;
				$i++;
				if ($atts[$i] eq &quot;(&quot;) {
					 # like `attname ( yes | no ) #REQUIRED`
					 $i++;
					 while ($atts[$i] ne &quot;)&quot;) {
						  if ($atts[$i] ne &quot;|&quot;) {
								push(@enume, $atts[$i]);
						  }
						  $i++;
					 }
				} elsif ($atts[$i] eq '#DATATYPEREF'){
					 print &quot; type='$prefix:$atts[++$i]'&quot;;
				} elsif ($alias eq 1 &amp;&amp; $atts[$i] =~ s/$alias_ident//gsie) {
					 # alias special
					 print &quot; type='$alias_dic{$atts[$i]}'&quot;;
				} elsif ($atts[$i] =~ /ID|IDREF|ENTITY|NOTATION|IDREFS|ENTITIES|NMTOKEN|NMTOKENS/) {
					 # common type for DTD and Schema
					 print &quot; type='$atts[$i]'&quot;;
				} else {
					 # `attname CDATA #REQUIRED`
					 print &quot; type='string'&quot;;
				}

				$i++;

				# #FIXED
				if($atts[$i] eq &quot;#FIXED&quot;) {
					 $i++;
					 print &quot; use='fixed' value='$atts[$i]'/&gt;\n&quot;;
				} else {
					 # minOccurs
					 if ($atts[$i] eq &quot;#REQUIRED&quot;) {
						  print &quot; use='required'&quot;;
					 } elsif ($atts[$i] eq &quot;#IMPLIED&quot;) {
						  print &quot; use='optional'&quot;;
					 } else {
						  print &quot; use='default' value='$atts[$i]'&quot;;
					 }

					 # enumerate
					 if ($#enume eq -1) {
						  print &quot;/&gt;\n&quot;;
					 } else {
						  print &quot;&gt;\n&quot;;
						  print &quot;    &lt;simpleType&gt;\n&quot;;
						  print &quot;     &lt;restriction base='string'&gt;\n&quot;;
						  &amp;write_enum(@enume);
						  print &quot;     &lt;/restriction&gt;\n&quot;;
						  print &quot;    &lt;/simpleType&gt;\n&quot;;
						  print &quot;   &lt;/attribute&gt;\n&quot;;
					 }
				}
		  }
    }
}

sub write_enum{
    my(@enume) = @_;

    for (my $j = 0; $j &lt;= $#enume; $j++) {
		  print &quot;      &lt;enumeration value='$enume[$j]'/&gt;\n&quot;;
    }
}


# Parse a string into an array of &quot;words&quot;.
# Words are whitespace-separated sequences of non-whitespace characters,
# or quoted strings (&quot;&quot; or ''), with the quotes removed.
# HACK: added () stuff for attlist stuff
# Parse words for attribute list
sub parsewords {
	 my $line = $_[0];
	 $line =~ s/(\(|\)|\|)/ $1 /g;
	 my @words = ();

	 while ($line ne '') {
		  if ($line =~ /^\s+/) {
				# Skip whitespace
		  } elsif ($line =~ /^\&quot;((?:[^\&quot;]|\\\&quot;)*)\&quot;/) {
				push(@words, $1);
		  } elsif ($line =~ /^\'((?:[^\']|\\\')*)\'/) {
				push(@words, $1);
		  } elsif ($line =~ /^\S+/) {
				push(@words, $&amp;);
		  } else {
				die &quot;Cannot happen\n&quot;;
		  }
		  $line = $';
	 }
    return @words;
}

# Store content model, return empty string
sub store_elt
{
	 my ($name, $model) = @_;
	 $model =~ s/\s+/ /gso;
	 push(@element, $name);

	 my @words;
	 while ($model =~ s/^\s*(\(|\)|,|\+|\?|\||[\w_\.-]+|\#\w+|\*)//) {
		  push(@words, $1);
	 };
	 $model{$name} = [ @words ];
	 return '';
}


# Store attribute list, return empty string
sub store_att
{
	 my ($element, $atts) = @_;
	 my @words = parsewords($atts);
	 $attributes{$element} = [ @words ];
	 return '';
}

sub write_simpleType{
    my($n, $b, $stuff) = @_;
    my @words = parsewords($stuff);

    print &quot;\n  &lt;simpleType name='$n'&gt;\n&quot;;
    print &quot;   &lt;restriction base='$b'&gt;\n&quot;;
#    print STDERR &quot;\n==stuff:\n$stuff \n\n===\n&quot;, join('|', @words);

    my $i = 0;
    my @enume;

    if ($words[$i] eq &quot;(&quot;) {
		  $i++;
		  while ($words[$i] ne &quot;)&quot;) {
				if ($words[$i] ne &quot;|&quot;) {
					 push(@enume, $words[$i]);
				}
				$i++;
		  }
		  write_enum(@enume);
    }

	 print &quot;   &lt;/restriction&gt;\n&quot;;
    print &quot;  &lt;/simpleType&gt;\n&quot;;
}

sub write_attrGroup{
    my($n, $stuff) = @_;
    my @words = parsewords($stuff);

    print &quot;\n  &lt;attributeGroup name='$n'&gt;\n&quot;;
#    print STDERR &quot;\n==stuff:\n$stuff \n\n===\n&quot;, join('|', @words);
    printAttrDecls(@words);
    print &quot;  &lt;/attributeGroup&gt;\n&quot;;
}

sub write_modelGroup{
    my($n, $stuff) = @_;
    my @words = parsewords($stuff);

    print &quot;\n  &lt;group name='$n'&gt;\n&quot;;
    print &quot;&lt;!-- $stuff --&gt;\n&quot;;

    my @list = &amp;makeChildList($n, '(', @words, ')');
    &amp;printChildList(3, @list);

    $ModelGroup{$n} = \@list;

    print &quot;  &lt;/group&gt;\n&quot;;
}

sub write_substitutionGroup
{
    my($n, $stuff) = @_;
    my @words = parsewords($stuff);

    print &quot;\n  &lt;element name='$n' abstract='true'&gt;\n&quot;;

    my @list = &amp;makeChildList($n, '(', @words, ')');
	 for ( my $i = 0; $i &lt; $#list; $i++ )
	 {
		  $SubstitutionGroup{ $list[$i] } = $n;
	 }

    print &quot;  &lt;/element&gt;\n&quot;;
}

sub isMixed{
    my(@model) = @_;
	 my $isSimple = ($pcdata_flag eq 1) &amp;&amp; ($model[1] eq '#PCDATA') &amp;&amp;
		  ( ($#model eq 2) || 
			 ( ($#model eq 3) &amp;&amp; ($model[3] eq '*') ) );

	 if ( $debug eq 1 ) {
		  print STDERR &quot;++ mixed? @model\n&quot;; #@@
	 }

	 if ( $isSimple )
	 {
		  if ( $debug eq 1 ) 
		  {
				print STDERR &quot;++ no; simple type. @model\n&quot;; #@@
		  }
		  return 0;
	 }

    my($i);

    for ($i = 0; $i &lt;= $#model; $i++) {
		  if ( $model[$i] eq '#PCDATA' ||
				 ($model[$i] eq '#MODELGROUPREF' &amp;&amp; $Mixed{$model[$i+1]}) ||
				 ($model[$i] eq '#SUBSTGROUPREF' &amp;&amp; $Mixed{$model[$i+1]}) )
		  {
				if ( $debug eq 1 ) {
					 print STDERR &quot;++ yes! $i @model\n&quot;; #@@
				}
				return 1;
		  }
    }

	 if ( $debug eq 1 ) {
		  print STDERR &quot;++ no. @model\n&quot;; #@@
	 }

    return 0;
}

# Return maximum value of an array of numbers
sub max
{
	 my $max = $_[0];
	 foreach my $i (@_) {
		  if ($i &gt; $max) {$max = $i;}
	 }
	 return $max;
}


# 1) Open file
# 2) Remove comment, processing instructions, and general entities
# 3) Include external parameter entities recursively
# 4) Return the contents of opened file
sub openFile {
	 my $file = $_[0];

	 my %extent;
	 my $bufbuf;
	 if ($file ne &quot;&quot;) {
		  print STDERR &quot;open $file &quot;;
		  if(! open AAA, $file) {
				print STDERR &quot; failed!!\n&quot;;
				return &quot;&quot;;
		  }
		  print STDERR &quot; successful\n&quot;;
		  $bufbuf = &lt;AAA&gt;;
	 } else {
		  print STDERR &quot;open STDIN successful\n&quot;;
		  $bufbuf = &lt;&gt;;
	 }

	 # remove comments
	 $bufbuf =~ s/&lt;!--.*?--&gt;//gso;

	 # remove processing instructions
	 $bufbuf =~ s/&lt;\?.*?&gt;//gso;

	 # store external parameter entities
	 while ($bufbuf =~ s/&lt;!ENTITY\s+%\s+(\S+)\s+PUBLIC\s+$str\s+$str.*?&gt;//sie) {
		  $extent{$1} = $4.$5;
	 }
	 while ($bufbuf =~ s/&lt;!ENTITY\s+%\s+(\S+)\s+SYSTEM\s+$str.*?&gt;//sie) {
		  $extent{$1} = $2.$3;
	 }

	 # read external entity files
	 foreach my $key (keys(%extent)) {
		  $bufbuf =~ s/%$key;/openFile($extent{$key})/gsie;
	 }

	 return $bufbuf;
}

# $Log: dtd2xsd.pl,v $
# Revision 1.17  2001/01/19 05:59:12  connolly
# more changelog stuff; link to MH's announcement etc.
#
# Revision 1.16  2001/01/19 05:55:56  connolly
# added Log at end
#
# Changes: 2001/01/10
# Date:      Thu, 11 Jan 2001 14:51:44 -0800
# From:      Mary Holstege &lt;<A HREF="mailto:holstege@mathling.com">holstege@mathling.com</A>&gt;
# To:        <A HREF="mailto:xml-dev@lists.xml.org">xml-dev@lists.xml.org</A>
# Subject:   [ANN] Updated version of DTD to XML Schema tool
# <A HREF="http://lists.xml.org/archives/xml-dev/200101/msg00481.html">http://lists.xml.org/archives/xml-dev/200101/msg00481.html</A>
# <A HREF="http://www.mathling.com/xmlschema/">http://www.mathling.com/xmlschema/</A>
# Switch to CR syntax
# Support external mapping file for type aliases, simple types, model and
#    attribute groups
# Map ANY correctly to wildcard rather than element 'ANY'
# Support treating lead PCDATA as string or other aliased simple type instead
# of as mixed content (may be more appropriate for data-oriented DTDs)
#    e.g. &lt;!ELEMENT title (#PCDATA)&gt; =&gt; &lt;element name=&quot;title&quot; type=&quot;string&quot;/&gt;
# Support subsitution groups.

--Boundary-00=_ISmk+z3OCv532dV--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000462.html">[Mono-docs-list] Mono Handbook - Available Jobs
</A></li>
	<LI> Next message: <A HREF="000464.html">[Mono-docs-list] Note on ECMA DTD
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#463">[ date ]</a>
              <a href="thread.html#463">[ thread ]</a>
              <a href="subject.html#463">[ subject ]</a>
              <a href="author.html#463">[ author ]</a>
         </LI>
       </UL>
</body></html>
