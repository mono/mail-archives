Index: monodocer.cs
===================================================================
--- monodocer.cs	(revision 44877)
+++ monodocer.cs	(working copy)
@@ -19,7 +19,7 @@
 public class Stub {
 	
 	static string srcPath;
-	static Assembly assembly;
+	static Assembly[] assemblies;
 	
 	static bool nooverrides = true, delete = false, ignoremembers = false;
 	
@@ -32,8 +32,8 @@
 		[Option("When updating documentation, write the updated files to this {path}.")]
 		public string updateto = null;
 
-		[Option("The assembly to document.  Specify a {file} path or the name of a GAC'd assembly.")]
-		public string assembly = null;
+		[Option(-1, "The assembly to document.  Specify a {file} path or the name of a GAC'd assembly.")]
+		public string[] assembly = null;
 
 		[Option("Document only the {type name}d by this argument.")]
 		public string type = null;
@@ -82,19 +82,10 @@
 			if (opts.assembly == null)
 				throw new InvalidOperationException("The assembly option is required.");
 				
-			try {
-				assembly = Assembly.LoadFile(opts.assembly);
-			} catch (System.IO.FileNotFoundException e) { }
-
-			if (assembly == null) {
-				try {
-					assembly = Assembly.LoadWithPartialName(opts.assembly);
-				} catch (Exception e) { }
-			}
+			assemblies = new Assembly [opts.assembly.Length];
+			for (int i = 0; i < opts.assembly.Length; i++)
+				assemblies [i] = LoadAssembly (opts.assembly [i]);
 			
-			if (assembly == null)
-				throw new InvalidOperationException("Assembly not found.");
-			
 			// PERFORM THE UPDATES
 			
 			if (opts.type != null)
@@ -102,7 +93,7 @@
 			else if (opts.@namespace != null)
 				DoUpdateNS(opts.@namespace, opts.path + "/" + opts.@namespace, opts.updateto == null ? opts.path + "/" + opts.@namespace : opts.updateto + "/" + opts.@namespace);
 			else
-				DoUpdateAssembly(opts.path, opts.updateto == null ? opts.path : opts.updateto);
+				DoUpdateAssemblies(opts.path, opts.updateto == null ? opts.path : opts.updateto);
 		
 		} catch (InvalidOperationException error) {
 			Console.Error.WriteLine(error.Message);
@@ -119,6 +110,25 @@
 		Console.Error.WriteLine("Members Added: {0}, Members Deleted: {1}", additions, deletions);
 	}
 	
+	private static Assembly LoadAssembly (string name)
+	{
+		Assembly assembly = null;
+		try {
+			assembly = Assembly.LoadFile (name);
+		} catch (System.IO.FileNotFoundException e) { }
+
+		if (assembly == null) {
+			try {
+				assembly = Assembly.LoadWithPartialName (name);
+			} catch (Exception e) { }
+		}
+			
+		if (assembly == null)
+			throw new InvalidOperationException("Assembly " + name + " not found.");
+
+		return assembly;
+	}
+
 	private static void WriteXml(XmlElement element, System.IO.TextWriter output) {
 		XmlTextWriter writer = new XmlTextWriter(output);
 		writer.Formatting = Formatting.Indented;
@@ -134,13 +144,21 @@
 		XmlElement index_root = index.CreateElement("Overview");
 		index.AppendChild(index_root);
 
-		XmlElement index_assembly = index.CreateElement("Assembly");
-		if (assembly == null)
+		if (assemblies.Length == 0)
 			throw new Exception ("No assembly");
-		index_assembly.InnerText = assembly.GetName().Name;
-		index_assembly.SetAttribute("Version", assembly.GetName().Version.ToString());
-		index_root.AppendChild(index_assembly);
 
+		XmlElement index_assemblies = index.CreateElement("Assemblies");
+		index_root.AppendChild(index_assemblies);
+
+		foreach (Assembly assembly in assemblies) {
+			XmlElement index_assembly = index.CreateElement("Assembly");
+
+			index_assembly.InnerText = assembly.GetName().Name;
+			index_assembly.SetAttribute("Version", assembly.GetName().Version.ToString());
+			index_assemblies.AppendChild(index_assembly);
+			MakeAttributes(index_assembly, assembly, true);
+		}
+
 		XmlElement index_remarks = index.CreateElement("Remarks");
 		index_remarks.InnerText = "To be added.";
 		index_root.AppendChild(index_remarks);
@@ -152,8 +170,6 @@
 		XmlElement index_types = index.CreateElement("Types");
 		index_root.AppendChild(index_types);
 		
-		MakeAttributes(index_root, assembly, true);
-		
 		return index;
 	}
 	
@@ -183,7 +199,12 @@
 	}
 	
 	public static void DoUpdateType(string basepath, string typename, string dest) {
-		Type type = assembly.GetType(typename, false);
+		Type type;
+		foreach (Assembly assembly in assemblies) {
+			type = assembly.GetType(typename, false);
+			if (type != null)
+				break;
+		}
 		if (type == null) throw new InvalidOperationException("Type not found: " + typename);
 		if (type.Namespace == null) throw new InvalidOperationException("Types in the root namespace cannot be documented: " + typename);
 		string typename2 = type.FullName.Substring(type.Namespace == "" ? 0 : type.Namespace.Length+1);
@@ -209,6 +230,7 @@
 	
 	public static void DoUpdateNS(string ns, string nspath, string outpath) {
 		Hashtable seenTypes = new Hashtable();
+		Assembly assembly = assemblies [0];
 		
 		foreach (System.IO.FileInfo file in new System.IO.DirectoryInfo(nspath).GetFiles("*.xml")) {
 			XmlDocument basefile = new XmlDocument();
@@ -257,7 +279,8 @@
 		return type.FullName.Substring(start);
 	}
 	
-	public static void DoUpdateAssembly(string source, string dest) {
+	private static void DoUpdateAssemblies (string source, string dest) 
+	{
 		string indexfile = dest + "/index.xml";
 		XmlDocument index;
 		if (new System.IO.FileInfo(indexfile).Exists) {
@@ -268,10 +291,25 @@
 		}
 		XmlElement index_types = (XmlElement)index.SelectSingleNode("Overview/Types");
 		
-		MakeAttributes(index.DocumentElement, assembly, true);
-		
 		Hashtable goodfiles = new Hashtable();
+
+		foreach (Assembly assm in assemblies)
+			DoUpdateAssembly (assm, index, source, dest, goodfiles);
 		
+		CleanupFiles (dest, goodfiles);
+		CleanupIndexTypes (index_types, goodfiles);
+
+		using (System.IO.TextWriter writer
+			= new System.IO.StreamWriter(new System.IO.FileStream(indexfile, System.IO.FileMode.Create)))
+			WriteXml(index.DocumentElement, writer);
+	
+	}
+		
+	private static void DoUpdateAssembly (Assembly assembly, XmlDocument index, string source, string dest, Hashtable goodfiles) 
+	{
+		MakeAttributes(index.DocumentElement, assembly, true);
+		XmlElement index_types = (XmlElement)index.SelectSingleNode("Overview/Types");
+
 		foreach (Type type in assembly.GetTypes()) {
 			if (type.Namespace == null) continue;
 			
@@ -323,7 +361,7 @@
 				typenode.SetAttribute("Name", typename);
 				nsnode.AppendChild(typenode);
 			}
-			
+				
 			// Ensure the namespace index file exists
 			if (!new System.IO.FileInfo(dest + "/" + type.Namespace + ".xml").Exists) {
 				Console.Error.WriteLine("New Namespace File: " + type.Namespace);
@@ -333,7 +371,10 @@
 			// mark the file as corresponding to a type
 			goodfiles[type.Namespace + "/" + typename + ".xml"] = goodfiles;
 		}
-		
+	}
+
+	private static void CleanupFiles (string dest, Hashtable goodfiles)
+	{
 		// Look for files that no longer correspond to types
 		foreach (System.IO.DirectoryInfo nsdir in new System.IO.DirectoryInfo(dest).GetDirectories("*")) {
 			foreach (System.IO.FileInfo typefile in nsdir.GetFiles("*.xml")) {
@@ -345,19 +386,18 @@
 				}
 			}
 		}
+	}
 		
+	private static void CleanupIndexTypes (XmlElement index_types, Hashtable goodfiles)
+	{
 		// Look for type nodes that no longer correspond to types
 		foreach (XmlElement typenode in index_types.SelectNodes("Namespace/Type")) {
 			string fulltypename = ((XmlElement)typenode.ParentNode).GetAttribute("Name") + "/" + typenode.GetAttribute("Name") + ".xml";
 			if (!goodfiles.ContainsKey(fulltypename))
 				typenode.ParentNode.RemoveChild(typenode);
 		}
+	}
 		
-		using (System.IO.TextWriter writer
-			= new System.IO.StreamWriter(new System.IO.FileStream(indexfile, System.IO.FileMode.Create)))
-			WriteXml(index.DocumentElement, writer);
-	}
-	
 	public static void DoUpdateType2(XmlDocument basefile, Type type, string output) {
 		Console.Error.WriteLine("Updating: " + type.FullName);
 		
@@ -538,10 +578,6 @@
 	
 	// CREATE A STUB DOCUMENTATION FILE	
 
-	public static XmlElement StubType(string type) {
-		return StubType(assembly.GetType(type, true));
-	}
-	
 	public static XmlElement StubType(Type type) {
 		string typesig = MakeTypeSignature(type);
 		if (typesig == null) return null; // not publicly visible
