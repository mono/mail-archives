<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-docs-list] Re: Documentation, review.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000102.html">
   <LINK REL="Next"  HREF="000098.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-docs-list] Re: Documentation, review.
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="[Mono-docs-list] Re: Documentation, review.">miguel@ximian.com
       </A><BR>
    <I>25 Aug 2002 12:10:10 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000102.html">[Mono-docs-list] Re: Documentation, review.
</A></li>
        <LI> Next message: <A HREF="000098.html">[Mono-docs-list] Re: [Mono-list] RE: [Qtcsharp-list] MonoDoc GUI and a Call to Arms
 :-)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#103">[ date ]</a>
              <a href="thread.html#103">[ thread ]</a>
              <a href="subject.html#103">[ subject ]</a>
              <a href="author.html#103">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

&gt;<i> &gt; 	1. Assemblies should be each documented on its own, we should
</I>&gt;<i> &gt; 	   not have a full merged set of documented.  
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 	   This way, we can use the same tools to document Gtk# and
</I>&gt;<i> &gt; 	   Qt#.  
</I>&gt;<i> 
</I>&gt;<i> I am not sure what you mean here.  Qt# will use the mono documentation tools as soon as they are
</I>&gt;<i> ready.  We will write a script to put our autogenerated comments into the external mono.xml files.
</I>&gt;<i>  I believe Rachel is planning to do the same, so I don't forsee any problems here.
</I>
Well, currently we have a large directory checked into CVS for all the
Mono classes (mcs/docs/apidocs) without the assembly split.

I would like to make documentation &quot;live&quot; under a &quot;doc&quot; directory in
each assembly, so mcs would have mcs/class/corlib/doc/en for english for
instance and gtk# could have gtk-sharp/gtk/doc/en for english as well.

&gt;<i> &gt;     I do not know where the templates we have right now came from: from
</I>&gt;<i> &gt; our assemblies or from the Microsoft assemblies.   The templates have a
</I>&gt;<i> &gt; number of problems: they are generated files, and hence, they are
</I>&gt;<i> &gt; subject to be overwritten in the future.
</I>&gt;<i> 
</I>&gt;<i> The templates, aka stub xml files are generated by docstub.  It uses reflection to populate the
</I>&gt;<i> stub files.  The backend was taken from NDoc, but it requires no GUI driver.
</I>
I am assuming that the 'reference' was the Microsoft assemblies here. 
That being said, I would like to just generate a skeleton of data
required, rather than having a stubbed-out document.  

This way we can use our incomplete assemblies as the &quot;source&quot; and just
keep upgrading the skeletons as our assemblies mature, without any
impact on the actual documents.

Say, for day 1 of the Mono project the skeleton would have only
contained one class: System.Object.   As we implemented more classes,
the skeleton would contain more classes to be documented.  

The skeleton would never contain any data, it would only list the things
that have to be documented, like for example:

	&lt;class name=&quot;System.Object&quot;&gt;
		&lt;method&gt;string ToString ()&lt;/method&gt;
		&lt;method&gt;int    GetHashCode ()&lt;/method&gt;
	&lt;/class&gt;

	(or something like that)

All documentation would be placed in an external file (using the current
DTD is fine, I do not particularly care).  The GUI tool can then  use
this information to show what things are documented and which ones are
not. 

&gt;<i> This is what docstub does.  I think it should be pretty much feature complete since we use the
</I>&gt;<i> NDoc reflection stuff.
</I>
Yes, docstub might be used here, but we have to remove the &quot;stub&quot; part
of it, ie, kill completely anything remotely looking like pre-filed
documentation.  All documentation should be kept outside.

The first time you launch the GUI editor, it can use the skeletons to
show what needs to be documented (everything  right now ;-) and any
documentation that is done, would go into its own file.

Now, lets say that the first day you document a single class,
System.Object.  Then the only file we check into CVS is
&quot;System.Object.xml&quot;.  If someone contributes documentation
&quot;System.String&quot;, we check &quot;System.String.xml&quot; as well. 

I hope I get my idea across.  If not, this is a good time to get
together, you tell me about your Parisian adventures, and we can get
some sushi or some coffee ;-)

Miguel.


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000102.html">[Mono-docs-list] Re: Documentation, review.
</A></li>
	<LI> Next message: <A HREF="000098.html">[Mono-docs-list] Re: [Mono-list] RE: [Qtcsharp-list] MonoDoc GUI and a Call to Arms
 :-)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#103">[ date ]</a>
              <a href="thread.html#103">[ thread ]</a>
              <a href="subject.html#103">[ subject ]</a>
              <a href="author.html#103">[ author ]</a>
         </LI>
       </UL>
</body></html>
