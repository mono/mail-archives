<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Sockets severe non-linear performance degradation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-list%5D%20Sockets%20severe%20non-linear%20performance%20degradation&In-Reply-To=%3C51C85E86.8080602%40cambsgardner.me.uk%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="050006.html">
   <LINK REL="Next"  HREF="050010.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Sockets severe non-linear performance degradation</H1>
    <B>Ian Gardner</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-list%5D%20Sockets%20severe%20non-linear%20performance%20degradation&In-Reply-To=%3C51C85E86.8080602%40cambsgardner.me.uk%3E"
       TITLE="[Mono-list] Sockets severe non-linear performance degradation">ian at cambsgardner.me.uk
       </A><BR>
    <I>Mon Jun 24 14:58:14 UTC 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="050006.html">[Mono-list] Is there any commercial support available?
</A></li>
        <LI>Next message: <A HREF="050010.html">[Mono-list] Sockets severe non-linear performance degradation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50008">[ date ]</a>
              <a href="thread.html#50008">[ thread ]</a>
              <a href="subject.html#50008">[ subject ]</a>
              <a href="author.html#50008">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Platform: linux ubuntu 12.04 AMD64
Mono version 2.10.8.1

I have just started with C# and have a simple client-server test app
that measures throughput and latency from the client for a typical 
send+recieve message scenario. As I increase the message size to more
than the socket send+recieve buffer size performance falls off a cliff,
whereas I would expect latency (round trip time) to increase approx
linearly with the ratio round_up((message size) / (socket buf size))
and throughput (bytes/sec) to stay approx constant.

I set socket buffer send and receive sizes = N

When message size &lt; N:
Roundtrip Latency: 1-3 milliseconds
Throughput: ~2 Mbyte/sec

This compares well with my equivalent java/C code on the same machine,
about equalling java as I would expect and being a bit slower than
native C sockets (I can comfortably get sub-millisecond round trips
with C, throughput around 5Mbyte/sec)

When N &lt; message size &lt; 2 * N:
Roundtrip Latency: 400-1000 milliseconds
Throughput: 50-100 Kbyte/sec

Machine shows very low CPU usage so it appears that the IO subsystem is
not rescheduling a thread blocked on IO in a timely manner. This
puzzles me since a direct mapping of the Socket methods onto the C
library counterparts should achieve what is required. So have I missed
some critical option, or does mono do something with IO/thread mapping
onto the OS that is causing this?

Some more detail on my test app:
The basic loop I am timing is.
1. Client writes random sized buffer to socket
2. Server reads data
3. Server writes random sized buffer to socket
4. Client reads data and stops timer

A message consists of a small fixed header indicating the size of 
following data.
Thus:
   write requires one system call since I coalesce header+data
   read requires two system calls, one for fixed header and one for
     variable data

Both client and server sockets are given the same options:
   socket.ReceiveBufferSize = 16000;
   socket.SendBufferSize = 16000;
   socket.NoDelay = true;
   socket.SetSocketOption(SocketOptionLevel.Socket,
                          SocketOptionName.DontLinger, false);

I have tried three basic approaches to the read/write loop.
A. socket.Blocking = true and use socket.Receive()/socket.Send()
B. socket.Blocking = true/false and use the async versions of
    socket.Receive()/socket.Send(). I.e. socket.BeginReceive() followed
    immediately by socket.EndReceive()
C. socket.Blocking = false and use socket.Receive()/socket.Send() and
    socket.Poll(SelectMode.SelectRead or SelectWrite)
    to wait for data where appropriate.

All three approaches show the same problem.
Both A and C map to the same approach I have used in native sockets
programming, and B may map to C internally so I did not really expect
it to be any better.

A few more points:
1. The code is operating correctly in the sense that it reliably
    transfers data (which I CRC32 check), it is solely performance which
    is the problem.
2. I use the high resolution System.Diagnostics.Stopwatch.GetTimestamp()
3. I call an explicit System.GC.Collect() before starting each timed
    test to reduce chances of GC skewing the timings.
4. I have tested over a standard TCP socket on main machine address and
    also on local loopback address, no change.
5. I have not tested on windows since I purged microsoft from my life
    several years ago and currently have no windows machine.
6. It is not possible from test code to know if delay is in read, write
    or both read+write blocking.

Any help would be appreciated.

</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="050006.html">[Mono-list] Is there any commercial support available?
</A></li>
	<LI>Next message: <A HREF="050010.html">[Mono-list] Sockets severe non-linear performance degradation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50008">[ date ]</a>
              <a href="thread.html#50008">[ thread ]</a>
              <a href="subject.html#50008">[ subject ]</a>
              <a href="author.html#50008">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
