<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] ASP
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="003087.html">
   <LINK REL="Next"  HREF="003037.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] ASP
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="[Mono-list] ASP">miguel@ximian.com
       </A><BR>
    <I>11 Feb 2002 17:05:55 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="003087.html">[Mono-list] ASP
</A></li>
        <LI> Next message: <A HREF="003037.html">[Mono-list] ASP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3089">[ date ]</a>
              <a href="thread.html#3089">[ thread ]</a>
              <a href="subject.html#3089">[ subject ]</a>
              <a href="author.html#3089">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> My implementation uses a provider interface [1] instead of the virtual HttpWorkerRequest class that ASP.Net uses. The ASP.Net runtime has a number of limitations and and we could make a better implementation of the HttpRuntime and the HttpWorkerRequest. The good thing is that the HttpXXX classes will easily be used on a different server like apache or likewise. My idea is that our HttpWorkerRequest class will implement thje IHttpIOHandler interface (our interface) that our web server stubs supports. We don't need the IISAPIRuntime interfaces.. they are MS internal implementation and the documentation now says : &quot;This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.&quot;
</I>
Good news.  As long as we provide a compatible API where it matters (we
can later revisit this, we should mark these items as [MonoTODO] in
those cases).

Ideally, you should be able to just copy an assembly from Windows and
run on Linux.

&gt;<i> I have also implemented a Server. The HttpServer and HttpReqsponseHandler that is the base of the HTTP/1.0 1.1 web server. It uses separate threads for each request (as the ASP.Net runtime) and the reason for that is the possibility to call end in HttpResponse. (end throws a thread abort exception that is the only exception you can catch and it will be rethrown).
</I>
Beautiful!  Beautiful!

&gt;<i> HttpServer()
</I>&gt;<i> HttpServer(int Port)
</I>&gt;<i> HttpServer(int Port, bool UseDNS)
</I>&gt;<i> Listen()   // Starts the operations
</I>&gt;<i> Shutdown
</I>&gt;<i> SoftwareName
</I>&gt;<i> ServerName
</I>&gt;<i> LookupRemoteInDNS 
</I>
It looks like these could comprise the &quot;hearth&quot; of the HttpChannel and
HttpServerChannel classes.  Very nice.

We will be waiting impatiently! ;-)
Miguel


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="003087.html">[Mono-list] ASP
</A></li>
	<LI> Next message: <A HREF="003037.html">[Mono-list] ASP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3089">[ date ]</a>
              <a href="thread.html#3089">[ thread ]</a>
              <a href="subject.html#3089">[ subject ]</a>
              <a href="author.html#3089">[ author ]</a>
         </LI>
       </UL>
</body></html>
