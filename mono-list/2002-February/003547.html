<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Nunit on Linux
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:martin%40gnome.org">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="003528.html">
   <LINK REL="Next"  HREF="003530.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Nunit on Linux
   </H1>
    <B>Martin Baulig
    </B> 
    <A HREF="mailto:martin%40gnome.org"
       TITLE="[Mono-list] Nunit on Linux">martin@gnome.org
       </A><BR>
    <I>26 Feb 2002 22:05:15 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="003528.html">[Mono-list] Nunit on Linux
</A></li>
        <LI> Next message: <A HREF="003530.html">[Mono-list] CorCompare XML ready
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3547">[ date ]</a>
              <a href="thread.html#3547">[ thread ]</a>
              <a href="subject.html#3547">[ subject ]</a>
              <a href="author.html#3547">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--=-=-=

&quot;Nick Drochak&quot; &lt;<A HREF="mailto:ndrochak@gol.com">ndrochak@gol.com</A>&gt; writes:

&gt;<i> For the tests to be of any practical use anymore, we must get Nunit
</I>&gt;<i> running on Linux.  There are internal calls sprinkled throught the
</I>&gt;<i> corlib now that basically make it impossible to test the corlib on
</I>&gt;<i> windows.  Well, we could get mono to build and work on Windows as
</I>&gt;<i> another option, but that's the easy way out :)
</I>
Hi,

I looked at this a bit this afternoon and I think the biggest job is
to get System.Reflection fully working - NUnit heavily uses dynamic
method invocations and they aren't implemented yet.

For the meantime, one way to test things on Linux is to use a custom
testrunner which calls all the tests statically.

Here's a small HOWTO:

* first of all, you need to write your own testrunner - the following
  is a good start:

  
--=-=-=
Content-Type: application/octet-stream
Content-Disposition: attachment; filename=RunTests.cs

using System;
using System.IO;
using System.Threading;
using System.Globalization;

using NUnit.Framework;

class MainApp {

	static TextWriter fWriter = Console.Out;

	protected static TextWriter Writer {
		get { return fWriter; }
	}

	public static void Print(TestResult result) {
		PrintErrors(result);
		PrintFailures(result);
		PrintHeader(result);
	}

	/// &lt;summary&gt;Prints the errors to the standard output.&lt;/summary&gt;
	public static void PrintErrors(TestResult result) {
		if (result.ErrorCount != 0) {
			if (result.ErrorCount == 1)
				Writer.WriteLine(&quot;There was &quot;+result.ErrorCount+&quot; error:&quot;);
			else
				Writer.WriteLine(&quot;There were &quot;+result.ErrorCount+&quot; errors:&quot;);
			
			int i= 1;
			foreach (TestFailure failure in result.Errors) {
				Writer.WriteLine(i++ + &quot;) &quot;+failure+&quot;(&quot;+failure.ThrownException.GetType().ToString()+&quot;)&quot;);
				Writer.Write(failure.ThrownException);
			}
		}
	}

	/// &lt;summary&gt;Prints failures to the standard output.&lt;/summary&gt;
	public static void PrintFailures(TestResult result) {
		if (result.FailureCount != 0) {
			if (result.FailureCount == 1)
				Writer.WriteLine(&quot;There was &quot; + result.FailureCount + &quot; failure:&quot;);
			else
				Writer.WriteLine(&quot;There were &quot; + result.FailureCount + &quot; failures:&quot;);
			int i = 1;
			foreach (TestFailure failure in result.Failures) {
				Writer.Write(i++ + &quot;) &quot; + failure.FailedTest);
				Exception t= failure.ThrownException;
				if (t.Message != &quot;&quot;)
					Writer.WriteLine(&quot; \&quot;&quot; + t.Message + &quot;\&quot;&quot;);
				else {
					Writer.WriteLine();
					Writer.Write(failure.ThrownException);
				}
			}
		}
	}

	/// &lt;summary&gt;Prints the header of the report.&lt;/summary&gt;
	public static void PrintHeader(TestResult result) {
		if (result.WasSuccessful) {
			Writer.WriteLine();
			Writer.Write(&quot;OK&quot;);
			Writer.WriteLine (&quot; (&quot; + result.RunCount + &quot; tests)&quot;);
			
		} else {
			Writer.WriteLine();
			Writer.WriteLine(&quot;FAILURES!!!&quot;);
			Writer.WriteLine(&quot;Tests Run: &quot;+result.RunCount+ 
					 &quot;, Failures: &quot;+result.FailureCount+
					 &quot;, Errors: &quot;+result.ErrorCount);
		}
	}

 	public static void Main() {

		Thread.CurrentThread.CurrentCulture = new CultureInfo (&quot;en-US&quot;);

		TestResult result = new TestResult ();
		TestSuite suite = new TestSuite ();
		suite.AddTest (new MonoTests.System.DateTimeTest (&quot;DateTimeTest&quot;));
		suite.AddTest (new MonoTests.System.TimeZoneTest (&quot;TimeZoneTest&quot;));
		suite.Run (result);
		Print (result);
	}
}

--=-=-=


* in your test file (let's use DateTimeTest.cs for an example), you need
  to override the RunTests method:

=====
        public DateTimeTest (string name): base(name) {}

	public static ITest Suite
	{
		get {
			TestSuite suite = new TestSuite ();
			return suite;
		}
	}

	protected override void RunTest ()
	{
        	TestCtors ();
		TestToString ();
		TestParseExact ();
		TestParse ();
	}
====

  You need to manually list all your tests there ....

* you need to reference your test suite in the RunTests.cs - if you look at the end of the
  attached RunTests.cs, there is:

====
 	public static void Main() {

		Thread.CurrentThread.CurrentCulture = new CultureInfo (&quot;en-US&quot;);

		TestResult result = new TestResult ();
		TestSuite suite = new TestSuite ();
		suite.AddTest (new MonoTests.System.DateTimeTest (&quot;DateTimeTest&quot;));
		suite.AddTest (new MonoTests.System.TimeZoneTest (&quot;TimeZoneTest&quot;));
		suite.Run (result);
		Print (result);
	}
===

  Add all your test suites there.

* manually compile RunTests.cs and your test suites to an executable RunTests.exe:
  (you need to do this on Windows, but see below)

    csc /nologo /lib:c:/cygwin/usr/local/martin/bin /r:NUnitCore.dll RunTests.cs DateTimeTest.cs
        TimeZoneTest.cs

* run the RunTests.exe with mint or mono

If you're doing stuff on Linux and need to quickly run a command on Windows, here are two shell
scripts which proved useful for me:

  - put this in your $PATH on your Linux box and make csc a symlink to it


--=-=-=
Content-Type: application/octet-stream
Content-Disposition: attachment; filename=atlantis

#!/usr/bin/perl -w

$LINUXPREFIX = '/home/export/martin';
$WINPREFIX   = '//townsville/martin';

$dir = `pwd`; chop $dir;
$dir =~ s/^$LINUXPREFIX/$WINPREFIX/ or die
    &quot;Can't map directory `$dir' to windows path&quot;;

$0 =~ m,.*/(.*)$, or die
    &quot;Can't map command name `$0' to windows path&quot;;
$command = $1;

@args = @ARGV;
unshift @args, $command unless $command eq 'atlantis';

system (&quot;ssh&quot;, &quot;atlantis&quot;, &quot;-l&quot;, &quot;martin&quot;, &quot;/usr/local/bin/atlantis&quot;, $dir, @args);

--=-=-=


 - put this in your $PATH on your Windows box


--=-=-=
Content-Type: application/octet-stream
Content-Disposition: attachment; filename=atlantis

#!/bin/sh

dir=$1 ; shift
cd $dir &amp;&amp; $@

--=-=-=


I'm using a partition which is shared between Linux (/home/export/martin) and Windows (//townsville/martin);
the script automatically translates the path names, so you can just type 'csc' on Linux and it ssh's to
Windows and runs it there.

-- 
Martin Baulig
<A HREF="mailto:martin@gnome.org">martin@gnome.org</A>

--=-=-=--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="003528.html">[Mono-list] Nunit on Linux
</A></li>
	<LI> Next message: <A HREF="003530.html">[Mono-list] CorCompare XML ready
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3547">[ date ]</a>
              <a href="thread.html#3547">[ thread ]</a>
              <a href="subject.html#3547">[ subject ]</a>
              <a href="author.html#3547">[ author ]</a>
         </LI>
       </UL>
</body></html>
