<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] About to Compile MCS
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rafael.teixeirabr%40terra.com.br">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="026322.html">
   <LINK REL="Next"  HREF="026335.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] About to Compile MCS
   </H1>
    <B>A Rafael D Teixeira
    </B> 
    <A HREF="mailto:rafael.teixeirabr%40terra.com.br"
       TITLE="[Mono-list] About to Compile MCS">rafael.teixeirabr@terra.com.br
       </A><BR>
    <I>Mon, 21 Mar 2005 21:11:41 -0300</I>
    <P><UL>
        <LI> Previous message: <A HREF="026322.html">[Mono-list] About to Compile MCS
</A></li>
        <LI> Next message: <A HREF="026335.html">[Mono-list] About to Compile MCS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26345">[ date ]</a>
              <a href="thread.html#26345">[ thread ]</a>
              <a href="subject.html#26345">[ subject ]</a>
              <a href="author.html#26345">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--=-o+84/aXdP00I0x6IPezz
Content-Type: text/plain
Content-Transfer-Encoding: 7bit

Hi Guilherme, see answer inline:

On Sat, 2005-03-19 at 22:33 -0300, Guilherme Martins wrote:
&gt;<i> I have downloaded the jay binary version from an article:
</I>&gt;<i> <A HREF="http://www.codeproject.com/csharp/codedomparser.asp">http://www.codeproject.com/csharp/codedomparser.asp</A>
</I>&gt;<i> 
</I>&gt;<i> An I run jay to generate my cs-parser.cs, that &quot;worked&quot; fine!
</I>&gt;<i> 
</I>&gt;<i> But the generated file have it's syntax wrong, to illustrate the file 
</I>&gt;<i> begins with a case statement :-(...
</I>
It seems you are not using the correct template for jay. If you took the
time to read our makefile you would have seen how jay is called and that
we pass it a C#-specific template file. The template is in the jay
directory parallel with the mcs (compiler) directory.

&gt;<i> Some one know how to solve it?
</I>
from our makefile:

jay -ctv &lt; skeleton.cs cs-parser.jay &gt; cs-parser.cs

As it seems that you aren't getting our sources right skeleton.cs is
attached.

&gt;<i> Note: I'm using Windows and I just want to compile MCS with VS.NET.
</I>
Bad choice, but if you really want now you may be able, just don't
forget to define these two symbols in the project configurations:
NET_1_1 ONLY_1_1.


-- 
Rafael &quot;Monoman&quot; Teixeira 
Mono Hacker since 16 Jul 2001 - <A HREF="http://www.go-mono.org/">http://www.go-mono.org/</A>
Mono Brasil Founding Member - <A HREF="http://monobrasil.softwarelivre.org/">http://monobrasil.softwarelivre.org/</A>
English Blog: <A HREF="http://monoblog.blogspot.com/">http://monoblog.blogspot.com/</A>

--=-o+84/aXdP00I0x6IPezz
Content-Disposition: attachment; filename=skeleton.cs
Content-Type: text/x-csharp; name=skeleton.cs; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

#	jay skeleton

#	character in column 1 determines outcome...
#		# is a comment
#		. is copied
#		t is copied as //t if -t is set
#	other lines are interpreted to call jay procedures

.// created by jay 0.7 (c) 1998 <A HREF="mailto:Axel.Schreiner@informatik.uni-osnabrueck.de">Axel.Schreiner@informatik.uni-osnabrueck.de</A>
.
 prolog		## %{ ... %} prior to the first %%

.
.  /** error output stream.
.      It should be changeable.
.    */
.  public System.IO.TextWriter ErrorOutput = System.Console.Out;
.
.  /** simplified error message.
.      @see &lt;a href=&quot;#yyerror(java.lang.String, java.lang.String[])&quot;&gt;yyerror&lt;/a&gt;
.    */
.  public void yyerror (string message) {
.    yyerror(message, null);
.  }
.
.  /** (syntax) error message.
.      Can be overwritten to control message format.
.      @param message text to be displayed.
.      @param expected vector of acceptable tokens, if available.
.    */
.  public void yyerror (string message, string[] expected) {
.    if ((yacc_verbose_flag &gt; 0) &amp;&amp; (expected != null) &amp;&amp; (expected.Length  &gt; 0)) {
.      ErrorOutput.Write (message+&quot;, expecting&quot;);
.      for (int n = 0; n &lt; expected.Length; ++ n)
.        ErrorOutput.Write (&quot; &quot;+expected[n]);
.        ErrorOutput.WriteLine ();
.    } else
.      ErrorOutput.WriteLine (message);
.  }
.
.  /** debugging support, requires the package jay.yydebug.
.      Set to null to suppress debugging messages.
.    */
t  internal yydebug.yyDebug debug;
.
 debug			## tables for debugging support
.
.  /** index-checked interface to yyNames[].
.      @param token single character or %token value.
.      @return token name or [illegal] or [unknown].
.    */
t  public static string yyname (int token) {
t    if ((token &lt; 0) || (token &gt; yyNames.Length)) return &quot;[illegal]&quot;;
t    string name;
t    if ((name = yyNames[token]) != null) return name;
t    return &quot;[unknown]&quot;;
t  }
.
.  /** computes list of expected tokens on error by tracing the tables.
.      @param state for which to compute the list.
.      @return list of token names.
.    */
.  protected string[] yyExpecting (int state) {
.    int token, n, len = 0;
.    bool[] ok = new bool[yyNames.Length];
.
.    if ((n = yySindex[state]) != 0)
.      for (token = n &lt; 0 ? -n : 0;
.           (token &lt; yyNames.Length) &amp;&amp; (n+token &lt; yyTable.Length); ++ token)
.        if (yyCheck[n+token] == token &amp;&amp; !ok[token] &amp;&amp; yyNames[token] != null) {
.          ++ len;
.          ok[token] = true;
.        }
.    if ((n = yyRindex[state]) != 0)
.      for (token = n &lt; 0 ? -n : 0;
.           (token &lt; yyNames.Length) &amp;&amp; (n+token &lt; yyTable.Length); ++ token)
.        if (yyCheck[n+token] == token &amp;&amp; !ok[token] &amp;&amp; yyNames[token] != null) {
.          ++ len;
.          ok[token] = true;
.        }
.
.    string [] result = new string[len];
.    for (n = token = 0; n &lt; len;  ++ token)
.      if (ok[token]) result[n++] = yyNames[token];
.    return result;
.  }
.
.  /** the generated parser, with debugging messages.
.      Maintains a state and a value stack, currently with fixed maximum size.
.      @param yyLex scanner.
.      @param yydebug debug message writer implementing yyDebug, or null.
.      @return result of the last reduction, if any.
.      @throws yyException on irrecoverable parse error.
.    */
.  internal Object yyparse (yyParser.yyInput yyLex, Object yyd)
.				 {
t    this.debug = (yydebug.yyDebug)yyd;
.    return yyparse(yyLex);
.  }
.
.  /** initial size and increment of the state/value stack [default 256].
.      This is not final so that it can be overwritten outside of invocations
.      of yyparse().
.    */
.  protected int yyMax;
.
.  /** executed at the beginning of a reduce action.
.      Used as $$ = yyDefault($1), prior to the user-specified action, if any.
.      Can be overwritten to provide deep copy, etc.
.      @param first value for $1, or null.
.      @return first.
.    */
.  protected Object yyDefault (Object first) {
.    return first;
.  }
.
.  /** the generated parser.
.      Maintains a state and a value stack, currently with fixed maximum size.
.      @param yyLex scanner.
.      @return result of the last reduction, if any.
.      @throws yyException on irrecoverable parse error.
.    */
.  internal Object yyparse (yyParser.yyInput yyLex)
.				{
.    if (yyMax &lt;= 0) yyMax = 256;			// initial size
.    int yyState = 0;                                   // state stack ptr
.    int [] yyStates = new int[yyMax];	                // state stack 
.    Object yyVal = null;                               // value stack ptr
.    Object [] yyVals = new Object[yyMax];	        // value stack
.    int yyToken = -1;					// current input
.    int yyErrorFlag = 0;				// #tks to shift
.
 local		## %{ ... %} after the first %%

.    int yyTop = 0;
.    goto skip;
.    yyLoop:
.    yyTop++;
.    skip:
.    for (;; ++ yyTop) {
.      if (yyTop &gt;= yyStates.Length) {			// dynamically increase
.        int[] i = new int[yyStates.Length+yyMax];
.        yyStates.CopyTo (i, 0);
.        yyStates = i;
.        Object[] o = new Object[yyVals.Length+yyMax];
.        yyVals.CopyTo (o, 0);
.        yyVals = o;
.      }
.      yyStates[yyTop] = yyState;
.      yyVals[yyTop] = yyVal;
t      if (debug != null) debug.push(yyState, yyVal);
.
.      yyDiscarded: for (;;) {	// discarding a token does not change stack
.        int yyN;
.        if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
.          if (yyToken &lt; 0) {
.            yyToken = yyLex.advance() ? yyLex.token() : 0;

t            if (debug != null)
t              debug.lex(yyState, yyToken, yyname(yyToken), yyLex.value());
.          }
.          if ((yyN = yySindex[yyState]) != 0 &amp;&amp; ((yyN += yyToken) &gt;= 0)
.              &amp;&amp; (yyN &lt; yyTable.Length) &amp;&amp; (yyCheck[yyN] == yyToken)) {
t            if (debug != null)
t              debug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
.            yyState = yyTable[yyN];		// shift to yyN
.            yyVal = yyLex.value();
.            yyToken = -1;
.            if (yyErrorFlag &gt; 0) -- yyErrorFlag;
.            goto yyLoop;
.          }
.          if ((yyN = yyRindex[yyState]) != 0 &amp;&amp; (yyN += yyToken) &gt;= 0
.              &amp;&amp; yyN &lt; yyTable.Length &amp;&amp; yyCheck[yyN] == yyToken)
.            yyN = yyTable[yyN];			// reduce (yyN)
.          else
.            switch (yyErrorFlag) {
.  
.            case 0:
.              yyerror(String.Format (&quot;syntax error, got token `{0}'&quot;, yyname (yyToken)), yyExpecting(yyState));
t              if (debug != null) debug.error(&quot;syntax error&quot;);
.              goto case 1;
.            case 1: case 2:
.              yyErrorFlag = 3;
.              do {
.                if ((yyN = yySindex[yyStates[yyTop]]) != 0
.                    &amp;&amp; (yyN += Token.yyErrorCode) &gt;= 0 &amp;&amp; yyN &lt; yyTable.Length
.                    &amp;&amp; yyCheck[yyN] == Token.yyErrorCode) {
t                  if (debug != null)
t                    debug.shift(yyStates[yyTop], yyTable[yyN], 3);
.                  yyState = yyTable[yyN];
.                  yyVal = yyLex.value();
.                  goto yyLoop;
.                }
t                if (debug != null) debug.pop(yyStates[yyTop]);
.              } while (-- yyTop &gt;= 0);
t              if (debug != null) debug.reject();
.              throw new yyParser.yyException(&quot;irrecoverable syntax error&quot;);
.  
.            case 3:
.              if (yyToken == 0) {
t                if (debug != null) debug.reject();
.                throw new yyParser.yyException(&quot;irrecoverable syntax error at end-of-file&quot;);
.              }
t              if (debug != null)
t                debug.discard(yyState, yyToken, yyname(yyToken),
t  							yyLex.value());
.              yyToken = -1;
.              goto yyDiscarded;		// leave stack alone
.            }
.        }
.        int yyV = yyTop + 1-yyLen[yyN];
t        if (debug != null)
t          debug.reduce(yyState, yyStates[yyV-1], yyN, yyRule[yyN], yyLen[yyN]);
.        yyVal = yyDefault(yyV &gt; yyTop ? null : yyVals[yyV]);
.        switch (yyN) {

 actions		## code from the actions within the grammar

.        }
.        yyTop -= yyLen[yyN];
.        yyState = yyStates[yyTop];
.        int yyM = yyLhs[yyN];
.        if (yyState == 0 &amp;&amp; yyM == 0) {
t          if (debug != null) debug.shift(0, yyFinal);
.          yyState = yyFinal;
.          if (yyToken &lt; 0) {
.            yyToken = yyLex.advance() ? yyLex.token() : 0;
		
t            if (debug != null)
t               debug.lex(yyState, yyToken,yyname(yyToken), yyLex.value());
.          }
.          if (yyToken == 0) {
t            if (debug != null) debug.accept(yyVal);
.            return yyVal;
.          }
.          goto yyLoop;
.        }
.        if (((yyN = yyGindex[yyM]) != 0) &amp;&amp; ((yyN += yyState) &gt;= 0)
.            &amp;&amp; (yyN &lt; yyTable.Length) &amp;&amp; (yyCheck[yyN] == yyState))
.          yyState = yyTable[yyN];
.        else
.          yyState = yyDgoto[yyM];
t        if (debug != null) debug.shift(yyStates[yyTop], yyState);
.	 goto yyLoop;
.      }
.    }
.  }
.
 tables			## tables for rules, default reduction, and action calls
.
 epilog			## text following second %%
.namespace yydebug {
.        using System;
.	 internal interface yyDebug {
.		 void push (int state, Object value);
.		 void lex (int state, int token, string name, Object value);
.		 void shift (int from, int to, int errorFlag);
.		 void pop (int state);
.		 void discard (int state, int token, string name, Object value);
.		 void reduce (int from, int to, int rule, string text, int len);
.		 void shift (int from, int to);
.		 void accept (Object value);
.		 void error (string message);
.		 void reject ();
.	 }
.	 
.	 class yyDebugSimple : yyDebug {
.		 void println (string s){
.			 Console.Error.WriteLine (s);
.		 }
.		 
.		 public void push (int state, Object value) {
.			 println (&quot;push\tstate &quot;+state+&quot;\tvalue &quot;+value);
.		 }
.		 
.		 public void lex (int state, int token, string name, Object value) {
.			 println(&quot;lex\tstate &quot;+state+&quot;\treading &quot;+name+&quot;\tvalue &quot;+value);
.		 }
.		 
.		 public void shift (int from, int to, int errorFlag) {
.			 switch (errorFlag) {
.			 default:				// normally
.				 println(&quot;shift\tfrom state &quot;+from+&quot; to &quot;+to);
.				 break;
.			 case 0: case 1: case 2:		// in error recovery
.				 println(&quot;shift\tfrom state &quot;+from+&quot; to &quot;+to
.					     +&quot;\t&quot;+errorFlag+&quot; left to recover&quot;);
.				 break;
.			 case 3:				// normally
.				 println(&quot;shift\tfrom state &quot;+from+&quot; to &quot;+to+&quot;\ton error&quot;);
.				 break;
.			 }
.		 }
.		 
.		 public void pop (int state) {
.			 println(&quot;pop\tstate &quot;+state+&quot;\ton error&quot;);
.		 }
.		 
.		 public void discard (int state, int token, string name, Object value) {
.			 println(&quot;discard\tstate &quot;+state+&quot;\ttoken &quot;+name+&quot;\tvalue &quot;+value);
.		 }
.		 
.		 public void reduce (int from, int to, int rule, string text, int len) {
.			 println(&quot;reduce\tstate &quot;+from+&quot;\tuncover &quot;+to
.				     +&quot;\trule (&quot;+rule+&quot;) &quot;+text);
.		 }
.		 
.		 public void shift (int from, int to) {
.			 println(&quot;goto\tfrom state &quot;+from+&quot; to &quot;+to);
.		 }
.		 
.		 public void accept (Object value) {
.			 println(&quot;accept\tvalue &quot;+value);
.		 }
.		 
.		 public void error (string message) {
.			 println(&quot;error\t&quot;+message);
.		 }
.		 
.		 public void reject () {
.			 println(&quot;reject&quot;);
.		 }
.		 
.	 }
.}
.// %token constants
. class Token {
 tokens public const int
. }
. namespace yyParser {
.  using System;
.  /** thrown for irrecoverable syntax errors and stack overflow.
.    */
.  internal class yyException : System.Exception {
.    public yyException (string message) : base (message) {
.    }
.  }
.
.  /** must be implemented by a scanner object to supply input to the parser.
.    */
.  internal interface yyInput {
.    /** move on to next token.
.        @return false if positioned beyond tokens.
.        @throws IOException on input error.
.      */
.    bool advance (); // throws java.io.IOException;
.    /** classifies current token.
.        Should not be called if advance() returned false.
.        @return current %token or single character.
.      */
.    int token ();
.    /** associated with current token.
.        Should not be called if advance() returned false.
.        @return value for token().
.      */
.    Object value ();
.  }
. }
.} // close outermost namespace, that MUST HAVE BEEN opened in the prolog

--=-o+84/aXdP00I0x6IPezz--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="026322.html">[Mono-list] About to Compile MCS
</A></li>
	<LI> Next message: <A HREF="026335.html">[Mono-list] About to Compile MCS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26345">[ date ]</a>
              <a href="thread.html#26345">[ thread ]</a>
              <a href="subject.html#26345">[ subject ]</a>
              <a href="author.html#26345">[ author ]</a>
         </LI>
       </UL>
</body></html>
