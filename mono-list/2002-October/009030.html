<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Crytography in Mono using NSS
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:serge%40wildwestsoftware.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="009024.html">
   <LINK REL="Next"  HREF="009034.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Crytography in Mono using NSS
   </H1>
    <B>Sergey Chaban
    </B> 
    <A HREF="mailto:serge%40wildwestsoftware.com"
       TITLE="[Mono-list] Crytography in Mono using NSS">serge@wildwestsoftware.com
       </A><BR>
    <I>Tue, 15 Oct 2002 12:06:30 +0300</I>
    <P><UL>
        <LI> Previous message: <A HREF="009024.html">[Mono-list] Crytography in Mono using NSS
</A></li>
        <LI> Next message: <A HREF="009034.html">[Mono-list] Crytography in Mono using NSS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9030">[ date ]</a>
              <a href="thread.html#9030">[ thread ]</a>
              <a href="subject.html#9030">[ subject ]</a>
              <a href="author.html#9030">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> Speaking of performance I did some tests using native CryptoAPI on Windows
</I>&gt;<i> (from managed code) and found out that, depending how you use it (which is
</I>&gt;<i> something we can't totally control with a frozen API), managed code can be
</I>&gt;<i> faster than unmanaged code
</I>
I think it's indeed true (the fact that managed code can be faster in general).
There was a lot of benchmarking in the early days, see for example this MD5 benchmark:
<A HREF="http://mono.eurosoft.od.ua/Crypto/md5-mark.tar.gz">http://mono.eurosoft.od.ua/Crypto/md5-mark.tar.gz</A>
There are versions in C++, C# and Java (both rolled &amp; unrolled for the latter two).
Unrolled C# code is the same as used in mono libs (the unrolled code is machine-generated).

&gt;<i> Many reasons are motivating me to this end including:
</I>&gt;<i> - portability across operating system: I believe that keeping track of
</I>&gt;<i> multiple external library dependencies across multiple operating system is
</I>&gt;<i> going to be a tough job on the long run (and still a bigger job for porting
</I>&gt;<i> to new, and often limited, platform - like new embebbed devices, cell
</I>&gt;<i> phones, PDA, ...);
</I>
This is very true, I agree 100%.
It's already non-trivial to port Mono to such platforms, so it's better to avoid
new dependencies (IMO).

Sergey


----- Original Message ----- 
From: &quot;Sebastien Pouliot&quot; &lt;<A HREF="mailto:spouliot@videotron.ca">spouliot@videotron.ca</A>&gt;
To: &quot;Daniel Morgan&quot; &lt;<A HREF="mailto:danmorg@sc.rr.com">danmorg@sc.rr.com</A>&gt;; &quot;Mono-List&quot; &lt;<A HREF="mailto:mono-list@ximian.com">mono-list@ximian.com</A>&gt;
Sent: Tuesday, October 15, 2002 4:51 AM
Subject: Re: [Mono-list] Crytography in Mono using NSS


&gt;<i> &gt; I found this on Mono'w web site about needing cyrtography support in Mono.
</I>&gt;<i> &gt; What about using Netscape Security Services?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; <A HREF="http://www.mozilla.org/projects/security/pki/nss/overview.html">http://www.mozilla.org/projects/security/pki/nss/overview.html</A>
</I>&gt;<i> 
</I>&gt;<i> I've not looked at NSS for quite some time (before Mozilla 1.0 release). As
</I>&gt;<i> such it predates my interest in Mono...
</I>&gt;<i> 
</I>&gt;<i> &gt; The only problem I see with using NSS is that it uses NSPR (Netscape
</I>&gt;<i> &gt; Portable Runtime).  How well will NSPR cooperate with the mono runtime?
</I>&gt;<i> 
</I>&gt;<i> No comments here (but I'm curious too :-)
</I>&gt;<i> 
</I>&gt;<i> &gt; If
</I>&gt;<i> &gt; NSS and NSPR is good enough for Netscape and Sun, don't you think it could
</I>&gt;<i> &gt; be good enough for us?
</I>&gt;<i> 
</I>&gt;<i> NSS has been certified FIPS140-1 (level 1 or 2) quite a few time in the past
</I>&gt;<i> so I wouldn't have much concern about the cryptographic quality of the
</I>&gt;<i> algorithm implementations. However I don't think that NSS (or any other
</I>&gt;<i> library - there're tons of them) may not implement all the classes required
</I>&gt;<i> for Mono.
</I>&gt;<i> 
</I>&gt;<i> &gt; Then again, I have no idea what the requirements are for cryptography
</I>&gt;<i> &gt; support in Mono.
</I>&gt;<i> 
</I>&gt;<i> Speaking for myself I'm hoping (and working so) we can have fully managed
</I>&gt;<i> cryptographic classes on mono.
</I>&gt;<i> 
</I>&gt;<i> Many reasons are motivating me to this end including:
</I>&gt;<i> - portability across operating system: I believe that keeping track of
</I>&gt;<i> multiple external library dependencies across multiple operating system is
</I>&gt;<i> going to be a tough job on the long run (and still a bigger job for porting
</I>&gt;<i> to new, and often limited, platform - like new embebbed devices, cell
</I>&gt;<i> phones, PDA, ...);
</I>&gt;<i> - security: In the right environment it's easier to be trust managed code
</I>&gt;<i> than unmanaged code. Also many of the current security flaws are based on
</I>&gt;<i> exploits (like stack overrun) that are gonna be harder to reproduce in a
</I>&gt;<i> managed environment (unless it exploit unmanaged code underneath).
</I>&gt;<i> 
</I>&gt;<i> However I do understand that my criteria aren't universal: performance is
</I>&gt;<i> often cited as good reason to include unmanaged code, another one is reusing
</I>&gt;<i> existing code to accelerate the development.
</I>&gt;<i> 
</I>&gt;<i> Speaking of performance I did some tests using native CryptoAPI on Windows
</I>&gt;<i> (from managed code) and found out that, depending how you use it (which is
</I>&gt;<i> something we can't totally control with a frozen API), managed code can be
</I>&gt;<i> faster than unmanaged code (as too much calls between managed/unmanaged code
</I>&gt;<i> can reduce or destroy any performance advantage).
</I>&gt;<i> 
</I>&gt;<i> Hopefully we can get the best of both world (mine and the other one ;-)
</I>&gt;<i> because we can include many implementations of a single algorithm in the
</I>&gt;<i> class library. The application could choose directly which one to use (bad
</I>&gt;<i> choice but 98% of current C# applications are just doing this - so it's kind
</I>&gt;<i> of too late) or ask for a default algorithm implementation (good choice).
</I>&gt;<i> This default implementation could be different between operating systems
</I>&gt;<i> (like CryptoAPI on Windows) or selected at installation time.
</I>&gt;<i> 
</I>&gt;<i> &gt; However, I thought I would pass the link along to those
</I>&gt;<i> &gt; that maybe interested.
</I>&gt;<i> 
</I>&gt;<i> Thanks. I'll get a new (in a mono perspective) look at it.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Sebastien Pouliot
</I>&gt;<i> Security Architect, Motus Technologies, <A HREF="http://www.motus.com/">http://www.motus.com/</A>
</I>&gt;<i> work: <A HREF="mailto:spouliot@motus.com">spouliot@motus.com</A>
</I>&gt;<i> home: <A HREF="mailto:spouliot@videotron.ca">spouliot@videotron.ca</A>
</I>&gt;<i> 
</I>





</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="009024.html">[Mono-list] Crytography in Mono using NSS
</A></li>
	<LI> Next message: <A HREF="009034.html">[Mono-list] Crytography in Mono using NSS
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9030">[ date ]</a>
              <a href="thread.html#9030">[ thread ]</a>
              <a href="subject.html#9030">[ subject ]</a>
              <a href="author.html#9030">[ author ]</a>
         </LI>
       </UL>
</body></html>
