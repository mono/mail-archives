<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] CryptoConfig and bug #30257 (repost)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:Sebastien%20Pouliot%20%3Cspouliot%40videotron.ca%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="008844.html">
   <LINK REL="Next"  HREF="008847.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] CryptoConfig and bug #30257 (repost)
   </H1>
    <B>Sebastien Pouliot
    </B> 
    <A HREF="mailto:Sebastien%20Pouliot%20%3Cspouliot%40videotron.ca%3E"
       TITLE="[Mono-list] CryptoConfig and bug #30257 (repost)">Sebastien Pouliot &lt;spouliot@videotron.ca&gt;
       </A><BR>
    <I>Sat, 05 Oct 2002 17:02:15 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="008844.html">[Mono-list] mono bug?: VolumeSeparatorChar (System.IO.Path)
</A></li>
        <LI> Next message: <A HREF="008847.html">[Mono-list] CryptoConfig and bug #30257 (repost)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8845">[ date ]</a>
              <a href="thread.html#8845">[ thread ]</a>
              <a href="subject.html#8845">[ subject ]</a>
              <a href="author.html#8845">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.

--Boundary_(ID_qV/239Up6QeZ4r7Z7Sp/Qg)
Content-type: text/plain; charset=iso-8859-1
Content-transfer-encoding: 8BIT

Note:    This is a repost because
a.    The mail didn't seem to reach the list;
b.    There was a file missing to run the test (AllTest.cs.diff)
---

While doing the X509Certificate class I found out that the CryptoConfig
class was missing. This is an important cryptographic class which role seems
little understood (
<A HREF="http://www.codeproject.com/dotnet/encryption_decryption.asp?df=100&forumid=3">http://www.codeproject.com/dotnet/encryption_decryption.asp?df=100&amp;forumid=3</A>
466&amp;select=296127#xx296127xx ). This is probably due to the really short
(one sentence), lame and sometimes wrong class documentation.

So here is the CryptoConfig class with it's NUnit test class. This should
make the GotDotNet &quot;Hash&quot; sample works normally (bug #30257 -
<A HREF="http://bugzilla.ximian.com/show_bug.cgi?id=30257">http://bugzilla.ximian.com/show_bug.cgi?id=30257</A> ) - at least it works under
Windows (both with Mono and MS).

Please note that the class isn't 100% complete because, under MS .NET
framework, it use the &quot;machine.config&quot; file to change default algorithm
implementation - and I couldn't find one in mono. Is there (yet) a
&quot;machine.config&quot; file in mono ?

If not, is there a similar .config file, on which I can base myself to
complete CryptoConfig ?

Note: Installing the WSDK (Web Services Development Kit) changes the
&quot;machine.config&quot; file. After the update the &quot;SHA1&quot; and
&quot;System.Security.Cryptography.SHA1&quot; maps to &quot;SHA1Managed&quot; class (instead of
&quot;SHA1CryptoServiceProvider&quot;). However both &quot;SHA&quot; and
&quot;System.Security.Cryptography.HashAlgorithm&quot; still maps to
&quot;SHA1CryptoServiceProvider&quot;. What this means is that the unit test will FAIL
when run under MS framework if WSDK is installed !


Sébastien Pouliot
Security Architect, Motus Technologies, <A HREF="http://www.motus.com/">http://www.motus.com/</A>
work: <A HREF="mailto:spouliot@motus.com">spouliot@motus.com</A>
home: <A HREF="mailto:spouliot@videotron.ca">spouliot@videotron.ca</A>

--Boundary_(ID_qV/239Up6QeZ4r7Z7Sp/Qg)
Content-type: application/octet-stream; name=AllTests.cs.diff
Content-transfer-encoding: quoted-printable
Content-disposition: attachment; filename=AllTests.cs.diff

2c2
&lt; // TestSuite.System.Security.Cryptography.AllTests.cs
---
&gt;<i> // TestSuite.System.Security.Cryptography.AllCryptoTests.cs=0D
</I>4c4
&lt; // Authors:
---
&gt;<i> // Author:=0D
</I>6,8d5
&lt; //	Sebastien Pouliot (<A HREF="mailto:spouliot@motus.com">spouliot@motus.com</A>)
&lt; //
&lt; // Portions (C) 2002 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
15,44c12,16
&lt;=20
&lt; /// &lt;summary&gt;
&lt; ///   Combines all available crypto unit tests into one test suite.
&lt; /// &lt;/summary&gt;
&lt; public class AllTests : TestCase {
&lt; 	public AllTests (string name) : base (name) {}
&lt;=20
&lt; 	// because most crypto stuff works with byte[] buffers
&lt; 	static public void AssertEquals (string msg, byte[] array1, byte[] =
array2)
&lt; 	{
&lt; 		if ((array1 =3D=3D null) &amp;&amp; (array2 =3D=3D null))
&lt; 			return;
&lt; 		if (array1 =3D=3D null)
&lt; 			Fail (msg + &quot; -&gt; First array is NULL&quot;);
&lt; 		if (array2 =3D=3D null)
&lt; 			Fail (msg + &quot; -&gt; Second array is NULL&quot;);
&lt;=20
&lt; 		bool a =3D (array1.Length =3D=3D array2.Length);
&lt; 		if (a) {
&lt; 			for (int i =3D 0; i &lt; array1.Length; i++) {
&lt; 				if (array1 [i] !=3D array2 [i]) {
&lt; 					a =3D false;
&lt; 					break;
&lt; 				}
&lt; 			}
&lt; 		}
&lt; 		msg +=3D &quot; -&gt; Expected &quot; + BitConverter.ToString (array1, 0);
&lt; 		msg +=3D &quot; is different than &quot; + BitConverter.ToString (array2, 0);
&lt; 		Assert (msg, a);
&lt; 	}
---
&gt;<i>         /// &lt;summary&gt;=0D
</I>&gt;<i>         ///   Combines all available crypto unit tests into one test =
</I>suite.=0D
&gt;<i>         /// &lt;/summary&gt;=0D
</I>&gt;<i>         public class AllTests : TestCase {=0D
</I>&gt;<i>                 public AllTests(string name) : base(name) {}=0D
</I>48c20,21
&lt; 		get {
---
&gt;<i>                         get =0D
</I>&gt;<i>                         {=0D
</I>54c27,29
&lt; 			suite.AddTest (CryptoConfigTest.Suite);
---
&gt;<i> 				suite.AddTest (RijndaelManagedTest.Suite);=0D
</I>&gt;<i> 				suite.AddTest (MD5Test.Suite);=0D
</I>&gt;<i> 				suite.AddTest (RC2Test.Suite);
</I>58,59c33
&lt; }
&lt;=20
---
&gt;<i>         }=0D
</I>
--Boundary_(ID_qV/239Up6QeZ4r7Z7Sp/Qg)
Content-type: text/plain; name=CryptoConfigTest.cs
Content-transfer-encoding: 7BIT
Content-disposition: attachment; filename=CryptoConfigTest.cs

//
// CryptoConfigTest.cs - NUnit Test Cases for CryptoConfig
//
// Author:
//		Sebastien Pouliot (<A HREF="mailto:spouliot@motus.com">spouliot@motus.com</A>)
//
// (C) 2002 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
//

using NUnit.Framework;
using System;
using System.Security.Cryptography;

namespace MonoTests.System.Security.Cryptography
{

public class CryptoConfigTest : TestCase 
{
	public CryptoConfigTest () : base (&quot;System.Security.Cryptography.CryptoConfig testsuite&quot;) {}
	public CryptoConfigTest (string name) : base (name) {}

	protected override void SetUp () {}

	protected override void TearDown () {}

	public static ITest Suite {
		get { 
			return new TestSuite (typeof (CryptoConfigTest)); 
		}
	}

	public void AssertEquals (string msg, byte[] array1, byte[] array2)
	{
		AllTests.AssertEquals (msg, array1, array2);
	}

	void CreateFromName (string name, string objectname)
	{
		object o = CryptoConfig.CreateFromName (name);
		AssertEquals (name, o.ToString(), objectname);
	}

	// validate that CryptoConfig create the exact same implementation between mono and MS
	public void TestCreateFromName () 
	{
		try {
			object o = CryptoConfig.CreateFromName (null);
		}
		catch (ArgumentNullException) {
			// do nothing, this is what we expect
		}
		catch (Exception e) {
			Fail (&quot;ArgumentNullException not thrown: &quot; + e.ToString());
		}
		CreateFromName (&quot;SHA&quot;, &quot;System.Security.Cryptography.SHA1CryptoServiceProvider&quot;);
		// FIXME: We need to support the machine.config file to get exact same results
		// with the MS .NET Framework
		CreateFromName (&quot;SHA1&quot;, &quot;System.Security.Cryptography.SHA1CryptoServiceProvider&quot;);
		CreateFromName( &quot;System.Security.Cryptography.SHA1&quot;, &quot;System.Security.Cryptography.SHA1CryptoServiceProvider&quot;);
		// after installing the WSDK - changes to the machine.config file (not documented)
//		CreateFromName (&quot;SHA1&quot;, &quot;System.Security.Cryptography.SHA1Managed&quot;);
//		CreateFromName (&quot;System.Security.Cryptography.SHA1&quot;, &quot;System.Security.Cryptography.SHA1Managed&quot;);
		CreateFromName (&quot;System.Security.Cryptography.HashAlgorithm&quot;, &quot;System.Security.Cryptography.SHA1CryptoServiceProvider&quot;);
		CreateFromName (&quot;MD5&quot;, &quot;System.Security.Cryptography.MD5CryptoServiceProvider&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.MD5&quot;, &quot;System.Security.Cryptography.MD5CryptoServiceProvider&quot;);  
		CreateFromName (&quot;SHA256&quot;, &quot;System.Security.Cryptography.SHA256Managed&quot;);  
		CreateFromName (&quot;SHA-256&quot;, &quot;System.Security.Cryptography.SHA256Managed&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.SHA256&quot;, &quot;System.Security.Cryptography.SHA256Managed&quot;);  
		CreateFromName (&quot;SHA384&quot;, &quot;System.Security.Cryptography.SHA384Managed&quot;);  
		CreateFromName (&quot;SHA-384&quot;, &quot;System.Security.Cryptography.SHA384Managed&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.SHA384&quot;, &quot;System.Security.Cryptography.SHA384Managed&quot;);  
		CreateFromName (&quot;SHA512&quot;, &quot;System.Security.Cryptography.SHA512Managed&quot;);  
		CreateFromName (&quot;SHA-512&quot;, &quot;System.Security.Cryptography.SHA512Managed&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.SHA512&quot;, &quot;System.Security.Cryptography.SHA512Managed&quot;);  
		CreateFromName (&quot;RSA&quot;, &quot;System.Security.Cryptography.RSACryptoServiceProvider&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.RSA&quot;, &quot;System.Security.Cryptography.RSACryptoServiceProvider&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.AsymmetricAlgorithm&quot;, &quot;System.Security.Cryptography.RSACryptoServiceProvider&quot;);  
		CreateFromName (&quot;DSA&quot;, &quot;System.Security.Cryptography.DSACryptoServiceProvider&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.DSA&quot;, &quot;System.Security.Cryptography.DSACryptoServiceProvider&quot;);  
		CreateFromName (&quot;DES&quot;, &quot;System.Security.Cryptography.DESCryptoServiceProvider&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.DES&quot;, &quot;System.Security.Cryptography.DESCryptoServiceProvider&quot;);  
		CreateFromName (&quot;3DES&quot;, &quot;System.Security.Cryptography.TripleDESCryptoServiceProvider&quot;);  
		CreateFromName (&quot;TripleDES&quot;, &quot;System.Security.Cryptography.TripleDESCryptoServiceProvider&quot;);  
		CreateFromName (&quot;Triple DES&quot;, &quot;System.Security.Cryptography.TripleDESCryptoServiceProvider&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.TripleDES&quot;, &quot;System.Security.Cryptography.TripleDESCryptoServiceProvider&quot;);  
		// LAMESPEC SymmetricAlgorithm documented as TripleDESCryptoServiceProvider
		CreateFromName (&quot;System.Security.Cryptography.SymmetricAlgorithm&quot;, &quot;System.Security.Cryptography.RijndaelManaged&quot;);  
		CreateFromName (&quot;RC2&quot;, &quot;System.Security.Cryptography.RC2CryptoServiceProvider&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.RC2&quot;, &quot;System.Security.Cryptography.RC2CryptoServiceProvider&quot;);  
		CreateFromName (&quot;Rijndael&quot;, &quot;System.Security.Cryptography.RijndaelManaged&quot;);  
		CreateFromName (&quot;System.Security.Cryptography.Rijndael&quot;, &quot;System.Security.Cryptography.RijndaelManaged&quot;);
		// LAMESPEC Undocumented Names in CryptoConfig
		CreateFromName (&quot;RandomNumberGenerator&quot;, &quot;System.Security.Cryptography.RNGCryptoServiceProvider&quot;);
		CreateFromName (&quot;System.Security.Cryptography.RandomNumberGenerator&quot;, &quot;System.Security.Cryptography.RNGCryptoServiceProvider&quot;);
		CreateFromName (&quot;System.Security.Cryptography.KeyedHashAlgorithm&quot;, &quot;System.Security.Cryptography.HMACSHA1&quot;);
		CreateFromName (&quot;HMACSHA1&quot;, &quot;System.Security.Cryptography.HMACSHA1&quot;);
		CreateFromName (&quot;System.Security.Cryptography.HMACSHA1&quot;, &quot;System.Security.Cryptography.HMACSHA1&quot;);
		CreateFromName (&quot;MACTripleDES&quot;, &quot;System.Security.Cryptography.MACTripleDES&quot;);
		CreateFromName (&quot;System.Security.Cryptography.MACTripleDES&quot;, &quot;System.Security.Cryptography.MACTripleDES&quot;);
		// non existing algo should return null (without exception)
		AssertNull (&quot;NonExistingAlgorithm&quot;, CryptoConfig.CreateFromName(&quot;NonExistingAlgorithm&quot;));
	}

	// Tests created using &quot;A Layer Man Guide to ASN.1&quot; from RSA, page 19-20
	// Need to find an OID ? goto <A HREF="http://www.alvestrand.no/~hta/objectid/top.html">http://www.alvestrand.no/~hta/objectid/top.html</A>
	static byte[] oidETSI = { 0x06, 0x03, 0x04, 0x00, 0x00 };
	static byte[] oidSHA1 = { 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A };
	static byte[] oidASN1CharacterModule = { 0x06, 0x04, 0x51, 0x00, 0x00, 0x00 };
	static byte[] oidmd5withRSAEncryption = { 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x04 };

	// LAMESPEC NullReferenceException is thrown (not ArgumentNullException) if parameter is NULL
	public void TestEncodeOID () 
	{
		try {
			byte[] o = CryptoConfig.EncodeOID (null);
		}
		catch (NullReferenceException) {
			// do nothing, this is what we expect
		}
		catch (Exception e) {
			Fail (&quot;NullReferenceException not thrown: &quot; + e.ToString());
		}
		// OID starts with 0, 1 or 2
		AssertEquals (&quot;OID starting with 0.&quot;, oidETSI, CryptoConfig.EncodeOID (&quot;0.4.0.0&quot;));
		AssertEquals (&quot;OID starting with 1.&quot;, oidSHA1, CryptoConfig.EncodeOID (&quot;1.3.14.3.2.26&quot;));
		AssertEquals (&quot;OID starting with 2.&quot;, oidASN1CharacterModule, CryptoConfig.EncodeOID (&quot;2.1.0.0.0&quot;));
		// OID numbers can span multiple bytes
		AssertEquals (&quot;OID with numbers spanning multiple bytes&quot;, oidmd5withRSAEncryption, CryptoConfig.EncodeOID (&quot;1.2.840.113549.1.1.4&quot;));
		
		// &quot;ms&quot;-invalid OID - greater than 127 bytes (length encoding)
		// OID longer than 127 bytes (so length must be encoded on multiple bytes)
		// LAMESPEC: OID greater that 0x7F (127) bytes aren't supported by the MS Framework
		string baseOID = &quot;1.3.6.1.4.1.11071.0.&quot;;
		string lastPart = &quot;1111111111&quot;; // must fit in int32
		for (int i = 1; i &lt; 30; i++)
		{
			baseOID += lastPart + &quot;.&quot;;
		}
		baseOID += &quot;0&quot;;
		try {
			byte[] tooLongOID = CryptoConfig.EncodeOID (baseOID);
		}
		catch (CryptographicUnexpectedOperationException) {
			// do nothing, this is what we expect
		}
		catch (Exception e) {
			Fail (&quot;CryptographicUnexpectedOperationException not thrown: &quot; + e.ToString());
		}
		
		// &quot;ms&quot;-invalid OID - where a number of the OID &gt; Int32
		// LAMESPEC: OID with numbers &gt; Int32 aren't supported by the MS BCL
		try {
			byte[] tooLongOID = CryptoConfig.EncodeOID (&quot;1.1.4294967295&quot;);
		}
		catch (OverflowException) {
			// do nothing, this is what we expect
		}
		catch (Exception e) {
			Fail( &quot;OverflowException not thrown: &quot; + e.ToString ());
		}

		// invalid OID - must start with 0, 1 or 2
		// however it works with MS BCL
		byte[] oid3 = CryptoConfig.EncodeOID (&quot;3.0&quot;);
		byte[] res3 = { 0x06, 0x01, 0x78 };
		AssertEquals (&quot;OID: 3.0&quot;, res3, oid3);

		// invalid OID - must have at least 2 parts (according to X.208)
		try {
			byte[] tooShortOID = CryptoConfig.EncodeOID (&quot;0&quot;);
		}
		catch (CryptographicUnexpectedOperationException) {
			// do nothing, this is what we expect
		}
		catch (Exception e) {
			Fail(&quot;CryptographicUnexpectedOperationException not thrown: &quot; + e.ToString());
		}

		// invalid OID - second value &lt; 40 for 0. and 1. (modulo 40)
		// however it works with MS BCL
		byte[] tooBigSecondPartOID = CryptoConfig.EncodeOID (&quot;0.40&quot;);
		byte[] tooBigSecondPartRes = { 0x06, 0x01, 0x28 };
		AssertEquals (&quot;OID: 0.40&quot;, tooBigSecondPartRes, tooBigSecondPartOID);
	}

	private void MapNameToOID (string name, string oid)
	{
		AssertEquals (&quot;oid(&quot; + name + &quot;)&quot;, oid, CryptoConfig.MapNameToOID (name));
	}

	// LAMESPEC doesn't support all names defined in CryptoConfig 
	// non supported names (in MSFW) are commented or null-ed
	public void TestMapNameToOID() 
	{
		try {
			CryptoConfig.MapNameToOID (null);
		}
		catch (ArgumentNullException) {
			// do nothing, this is what we expect
		}
		catch (Exception e) {
			Fail( &quot;ArgumentNullException not thrown: &quot; + e.ToString ());
		}
//		MapNameToOID (&quot;SHA&quot;, &quot;1.3.14.3.2.26&quot;);
		MapNameToOID (&quot;SHA1&quot;, &quot;1.3.14.3.2.26&quot;);
		MapNameToOID (&quot;System.Security.Cryptography.SHA1&quot;, &quot;1.3.14.3.2.26&quot;);
//		MapNameToOID (&quot;System.Security.Cryptography.HashAlgorithm&quot;, &quot;1.3.14.3.2.26&quot;);
		MapNameToOID (&quot;MD5&quot;, &quot;1.2.840.113549.2.5&quot;);
		MapNameToOID (&quot;System.Security.Cryptography.MD5&quot;, &quot;1.2.840.113549.2.5&quot;);
		MapNameToOID (&quot;SHA256&quot;, &quot;2.16.840.1.101.3.4.1&quot;);
//		MapNameToOID (&quot;SHA-256&quot;, &quot;2.16.840.1.101.3.4.1&quot;);
		MapNameToOID (&quot;System.Security.Cryptography.SHA256&quot;, &quot;2.16.840.1.101.3.4.1&quot;);
		MapNameToOID (&quot;SHA384&quot;, &quot;2.16.840.1.101.3.4.2&quot;);
//		MapNameToOID (&quot;SHA-384&quot;, &quot;2.16.840.1.101.3.4.2&quot;);
		MapNameToOID (&quot;System.Security.Cryptography.SHA384&quot;, &quot;2.16.840.1.101.3.4.2&quot;);
		MapNameToOID (&quot;SHA512&quot;, &quot;2.16.840.1.101.3.4.3&quot;);
//		MapNameToOID (&quot;SHA-512&quot;, &quot;2.16.840.1.101.3.4.3&quot;);
		MapNameToOID (&quot;System.Security.Cryptography.SHA512&quot;, &quot;2.16.840.1.101.3.4.3&quot;);
		// no OID defined ?
		MapNameToOID (&quot;RSA&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.RSA&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.AsymmetricAlgorithm&quot;, null);
		MapNameToOID (&quot;DSA&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.DSA&quot;, null);
		MapNameToOID (&quot;DES&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.DES&quot;, null);
		MapNameToOID (&quot;3DES&quot;, null);
		MapNameToOID (&quot;TripleDES&quot;, null);
		MapNameToOID (&quot;Triple DES&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.TripleDES&quot;, null);
		MapNameToOID (&quot;RC2&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.RC2&quot;, null);
		MapNameToOID (&quot;Rijndael&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.Rijndael&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.SymmetricAlgorithm&quot;, null);
		// LAMESPEC Undocumented Names in CryptoConfig
		MapNameToOID (&quot;RandomNumberGenerator&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.RandomNumberGenerator&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.KeyedHashAlgorithm&quot;, null);
		MapNameToOID (&quot;HMACSHA1&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.HMACSHA1&quot;, null);
		MapNameToOID (&quot;MACTripleDES&quot;, null);
		MapNameToOID (&quot;System.Security.Cryptography.MACTripleDES&quot;, null);
		// non existing algo should return null (without exception)
		MapNameToOID (&quot;NonExistingAlgorithm&quot;, null);
	}

	public void TestToString() 
	{
		// under normal circumstance there are no need to create a CryptoConfig object
		// because all interesting stuff are in static methods
		CryptoConfig cc = new CryptoConfig ();
		AssertEquals (&quot;System.Security.Cryptography.CryptoConfig&quot;, cc.ToString ());
	}
}

}

--Boundary_(ID_qV/239Up6QeZ4r7Z7Sp/Qg)
Content-type: text/plain; name=CryptoConfig.cs
Content-transfer-encoding: 7BIT
Content-disposition: attachment; filename=CryptoConfig.cs

//
// CryptoConfig.cs: Handles cryptographic implementations and OIDs.
//
// Author:
//		Sebastien Pouliot (<A HREF="mailto:spouliot@motus.com">spouliot@motus.com</A>)
//
// (C) 2002 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
//

using System;
using System.Collections;
using System.Reflection;

namespace System.Security.Cryptography
{

public class CryptoConfig
{
	static private Hashtable algorithms;
	static private Hashtable oid;

	private const string defaultNamespace = &quot;System.Security.Cryptography.&quot;;
	private const string defaultSHA1 = defaultNamespace + &quot;SHA1CryptoServiceProvider&quot;;
	private const string defaultMD5 = defaultNamespace + &quot;MD5CryptoServiceProvider&quot;;
	private const string defaultSHA256 = defaultNamespace + &quot;SHA256Managed&quot;;
	private const string defaultSHA384 = defaultNamespace + &quot;SHA384Managed&quot;;
	private const string defaultSHA512 = defaultNamespace + &quot;SHA512Managed&quot;;
	private const string defaultRSA = defaultNamespace + &quot;RSACryptoServiceProvider&quot;;
	private const string defaultDSA = defaultNamespace + &quot;DSACryptoServiceProvider&quot;;
	private const string defaultDES = defaultNamespace + &quot;DESCryptoServiceProvider&quot;;
	private const string default3DES = defaultNamespace + &quot;TripleDESCryptoServiceProvider&quot;;
	private const string defaultRC2 = defaultNamespace + &quot;RC2CryptoServiceProvider&quot;;
	private const string defaultAES = defaultNamespace + &quot;RijndaelManaged&quot;;
	// LAMESPEC: undocumented names in CryptoConfig
	private const string defaultRNG = defaultNamespace + &quot;RNGCryptoServiceProvider&quot;;
	private const string defaultHMAC = defaultNamespace + &quot;HMACSHA1&quot;;
	private const string defaultMAC3DES = defaultNamespace + &quot;MACTripleDES&quot;;

	// Oddly OID seems only available for hash algorithms
	private const string oidSHA1 = &quot;1.3.14.3.2.26&quot;;
	private const string oidMD5 = &quot;1.2.840.113549.2.5&quot;;
	private const string oidSHA256 = &quot;2.16.840.1.101.3.4.1&quot;;
	private const string oidSHA384 = &quot;2.16.840.1.101.3.4.2&quot;;
	private const string oidSHA512 = &quot;2.16.840.1.101.3.4.3&quot;;

	private const string nameSHA1a = &quot;SHA&quot;;
	private const string nameSHA1b = &quot;SHA1&quot;;
	private const string nameSHA1c = &quot;System.Security.Cryptography.SHA1&quot;;
	private const string nameSHA1d = &quot;System.Security.Cryptography.HashAlgorithm&quot;;
	private const string nameMD5a = &quot;MD5&quot;;
	private const string nameMD5b = &quot;System.Security.Cryptography.MD5&quot;;
	private const string nameSHA256a = &quot;SHA256&quot;;
	private const string nameSHA256b = &quot;SHA-256&quot;;
	private const string nameSHA256c = &quot;System.Security.Cryptography.SHA256&quot;;
	private const string nameSHA384a = &quot;SHA384&quot;;
	private const string nameSHA384b = &quot;SHA-384&quot;;
	private const string nameSHA384c = &quot;System.Security.Cryptography.SHA384&quot;;
	private const string nameSHA512a = &quot;SHA512&quot;;
	private const string nameSHA512b = &quot;SHA-512&quot;;
	private const string nameSHA512c = &quot;System.Security.Cryptography.SHA512&quot;;
	private const string nameRSAa = &quot;RSA&quot;;
	private const string nameRSAb = &quot;System.Security.Cryptography.RSA&quot;;
	private const string nameRSAc = &quot;System.Security.Cryptography.AsymmetricAlgorithm&quot;;
	private const string nameDSAa = &quot;DSA&quot;;
	private const string nameDSAb = &quot;System.Security.Cryptography.DSA&quot;;
	private const string nameDESa = &quot;DES&quot;;
	private const string nameDESb = &quot;System.Security.Cryptography.DES&quot;;
	private const string name3DESa = &quot;3DES&quot;;
	private const string name3DESb = &quot;TripleDES&quot;;
	private const string name3DESc = &quot;Triple DES&quot;;
	private const string name3DESd = &quot;System.Security.Cryptography.TripleDES&quot;;
	private const string nameRC2a = &quot;RC2&quot;;
	private const string nameRC2b = &quot;System.Security.Cryptography.RC2&quot;;
	private const string nameAESa = &quot;Rijndael&quot;;
	private const string nameAESb = &quot;System.Security.Cryptography.Rijndael&quot;;
	private const string nameAESc = &quot;System.Security.Cryptography.SymmetricAlgorithm&quot;;
	// LAMESPEC: undocumented names in CryptoConfig
	private const string nameRNGa = &quot;RandomNumberGenerator&quot;;
	private const string nameRNGb = &quot;System.Security.Cryptography.RandomNumberGenerator&quot;;
	private const string nameKeyHasha = &quot;System.Security.Cryptography.KeyedHashAlgorithm&quot;;
	private const string nameHMACa = &quot;HMACSHA1&quot;;
	private const string nameHMACb = &quot;System.Security.Cryptography.HMACSHA1&quot;;
	private const string nameMAC3DESa = &quot;MACTripleDES&quot;;
	private const string nameMAC3DESb = &quot;System.Security.Cryptography.MACTripleDES&quot;;

	// ??? must we read from the machine.config each time or just at startup ???
	[MonoTODO (&quot;support machine.config&quot;)]
	static CryptoConfig()
	{
		algorithms = new Hashtable ();
		// see list @ <A HREF="http://msdn.microsoft.com/library/en-us/cpref/html/">http://msdn.microsoft.com/library/en-us/cpref/html/</A>
		// frlrfSystemSecurityCryptographyCryptoConfigClassTopic.asp
		algorithms.Add (nameSHA1a, defaultSHA1);
		algorithms.Add (nameSHA1b, defaultSHA1);
		algorithms.Add (nameSHA1c, defaultSHA1);
		algorithms.Add (nameSHA1d, defaultSHA1);

		algorithms.Add (nameMD5a, defaultMD5);
		algorithms.Add (nameMD5b, defaultMD5);

		algorithms.Add (nameSHA256a, defaultSHA256);
		algorithms.Add (nameSHA256b, defaultSHA256);
		algorithms.Add (nameSHA256c, defaultSHA256);

		algorithms.Add (nameSHA384a, defaultSHA384);
		algorithms.Add (nameSHA384b, defaultSHA384);
		algorithms.Add (nameSHA384c, defaultSHA384);

		algorithms.Add (nameSHA512a, defaultSHA512);
		algorithms.Add (nameSHA512b, defaultSHA512);
		algorithms.Add (nameSHA512c, defaultSHA512);

		algorithms.Add (nameRSAa, defaultRSA);
		algorithms.Add (nameRSAb, defaultRSA); 
		algorithms.Add (nameRSAc, defaultRSA);

		algorithms.Add (nameDSAa, defaultDSA);  
		algorithms.Add (nameDSAb, defaultDSA);  
	
		algorithms.Add (nameDESa, defaultDES);  
		algorithms.Add (nameDESb, defaultDES);  
	
		algorithms.Add (name3DESa, default3DES);    
		algorithms.Add (name3DESb, default3DES);    
		algorithms.Add (name3DESc, default3DES);     
		algorithms.Add (name3DESd, default3DES);    
	
		algorithms.Add (nameRC2a, defaultRC2);  
		algorithms.Add (nameRC2b, defaultRC2);  

		algorithms.Add (nameAESa, defaultAES);  
		algorithms.Add (nameAESb, defaultAES);
		// LAMESPEC SymmetricAlgorithm documented as TripleDESCryptoServiceProvider
		algorithms.Add (nameAESc, defaultAES);

		// LAMESPEC These names aren't documented but (hint) the classes also have
		// static Create methods. So logically they should (and are) here.
		algorithms.Add (nameRNGa, defaultRNG);
		algorithms.Add (nameRNGb, defaultRNG);
		algorithms.Add (nameKeyHasha, defaultHMAC);
		algorithms.Add (nameHMACa, defaultHMAC);
		algorithms.Add (nameHMACb, defaultHMAC);
		algorithms.Add (nameMAC3DESa, defaultMAC3DES);
		algorithms.Add (nameMAC3DESb, defaultMAC3DES);

		oid = new Hashtable ();
		// comments here are to match with MS implementation (but not with doc)
		// LAMESPEC: only HashAlgorithm seems to have their OID included
		// oid.Add (nameSHA1a, oidSHA1);
		oid.Add (nameSHA1b, oidSHA1);
		oid.Add (nameSHA1c, oidSHA1);
		// oid.Add (nameSHA1d, oidSHA1);
		oid.Add (nameMD5a, oidMD5);
		oid.Add (nameMD5b, oidMD5);
		oid.Add (nameSHA256a, oidSHA256);
		// oid.Add (nameSHA256b, oidSHA256);
		oid.Add (nameSHA256c, oidSHA256);
		oid.Add (nameSHA384a, oidSHA384);
		// oid.Add (nameSHA384b, oidSHA384);
		oid.Add (nameSHA384c, oidSHA384);
		oid.Add (nameSHA512a, oidSHA512);
		// oid.Add (nameSHA512b, oidSHA512);
		oid.Add (nameSHA512c, oidSHA512);
	}

	public static object CreateFromName (string name)
	{
		return CreateFromName (name, null);
	}

	public static object CreateFromName (string name, object[] args)
	{
		if (name == null)
			throw new ArgumentNullException ();
	
		try {
			string algo = (string)algorithms [name];
			Type algoClass = Type.GetType (algo);
			// call the constructor for the type
			return Activator.CreateInstance (algoClass, args);
		}
		catch {
			return null;
		}
	}

	// encode (7bits array) number greater than 127
	private static byte[] EncodeLongNumber (long x)
	{
		// for MS BCL compatibility
		// comment next two lines to remove restriction
		if ((x &gt; Int32.MaxValue) || (x &lt; Int32.MinValue))
			throw new OverflowException(&quot;part of OID doesn't fit in Int32&quot;);

		long y = x;
		// number of bytes required to encode this number
		int n = 1;
		while (y &gt; 0x7F) {
			y = y &gt;&gt; 7;
			n++;
		}
		byte[] num = new byte [n];
		// encode all bytes 
		for (int i = 0; i &lt; n; i++) {
			y = x &gt;&gt; (7 * i);
			y = y &amp; 0x7F;
			if (i != 0)
				y += 0x80;
			num[n-i-1] = Convert.ToByte (y);
		}
		return num;
	}

	public static byte[] EncodeOID (string str)
	{
		char[] delim = { '.' };
		string[] parts = str.Split (delim);
		// according to X.208 n is always at least 2
		if (parts.Length &lt; 2)
			throw new CryptographicUnexpectedOperationException ();
		// we're sure that the encoded OID is shorter than its string representation
		byte[] oid = new byte [str.Length];
		// now encoding value
		try {
			byte part0 = Convert.ToByte (parts [0]);
			// OID[0] &gt; 2 is invalid but &quot;supported&quot; in MS BCL
			// uncomment next line to trap this error
			// if (part0 &gt; 2) throw new CryptographicUnexpectedOperationException ();
			byte part1 = Convert.ToByte (parts [1]);
			// OID[1] &gt;= 40 is illegal for OID[0] &lt; 2 because of the % 40
			// however the syntax is &quot;supported&quot; in MS BCL
			// uncomment next 2 lines to trap this error
			//if ((part0 &lt; 2) &amp;&amp; (part1 &gt;= 40))
			//	throw new CryptographicUnexpectedOperationException ();
			oid[2] = Convert.ToByte (part0 * 40 + part1);
		}
		catch {
			throw new CryptographicUnexpectedOperationException ();
		}
		int j = 3;
		for (int i = 2; i &lt; parts.Length; i++) {
			long x = Convert.ToInt64( parts [i]);
			if (x &gt; 0x7F) {
				byte[] num = EncodeLongNumber (x);
				Array.Copy(num, 0, oid, j, num.Length);
				j += num.Length;
			}
			else
				oid[j++] = Convert.ToByte (x);
		}

		int k = 2;
		// copy the exact number of byte required
		byte[] oid2 = new byte [j];
		oid2[0] = 0x06; // always - this tag means OID
		// Length (of value)
		if (j &gt; 0x7F) {
			// for compatibility with MS BCL
			throw new CryptographicUnexpectedOperationException (&quot;OID &gt; 127 bytes&quot;);
			// comment exception and uncomment next 3 lines to remove restriction
			//byte[] num = EncodeLongNumber (j);
			//Array.Copy (num, 0, oid, j, num.Length);
			//k = num.Length + 1;
		}
		else
			oid2 [1] = Convert.ToByte (j - 2); 

		System.Array.Copy (oid, k, oid2, k, j - k);
		return oid2;
	}

	public static string MapNameToOID (string name)
	{
		if (name == null)
			throw new ArgumentNullException ();

		return (string)oid [name];
	}
}

}

--Boundary_(ID_qV/239Up6QeZ4r7Z7Sp/Qg)--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="008844.html">[Mono-list] mono bug?: VolumeSeparatorChar (System.IO.Path)
</A></li>
	<LI> Next message: <A HREF="008847.html">[Mono-list] CryptoConfig and bug #30257 (repost)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8845">[ date ]</a>
              <a href="thread.html#8845">[ thread ]</a>
              <a href="subject.html#8845">[ subject ]</a>
              <a href="author.html#8845">[ author ]</a>
         </LI>
       </UL>
</body></html>
