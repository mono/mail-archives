<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Static CIL Libraries
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="009136.html">
   <LINK REL="Next"  HREF="009145.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Static CIL Libraries
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] Static CIL Libraries">jonpryor@vt.edu
       </A><BR>
    <I>18 Oct 2002 11:57:34 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="009136.html">[Mono-list] Static CIL Libraries
</A></li>
        <LI> Next message: <A HREF="009145.html">[Mono-list] Static CIL Libraries
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9151">[ date ]</a>
              <a href="thread.html#9151">[ thread ]</a>
              <a href="subject.html#9151">[ subject ]</a>
              <a href="author.html#9151">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Actually, from chatting off-list with Dan, it sounds like he's really
after a way to create *something* that can be used by other assemblies
without requiring that the types of *something* be public.

For example, we have our internal-use-only code (which we don't want
others to use) in `shared.cs'.  OK, simple enough: mark the types in
`shared.cs' as `internal'.  Ah, but what if you want to use `shared.cs'
in lots of different DLLs and EXEs?  Simple enough: compile `shared.cs'
into each assembly that needs the shared code.

But what if another group is responsible for the source code, or
`shared.cs' is actually dozens of source files.  Do you really want to
recompile all these files for each different assembly they logically
belong to?

The .NET way to do this is with modules.  A module is a file that
contains IL code but *doesn't* contain a `.assembly' CIL directive.  In
other words, it's an assembly-less unit of IL code.  Being assembly-less
is important: it allows the classes of the module to be `internal', yet
shared among multiple different assemblies.

On .NET, this would be done by:

	# create shared module code shared.netmodule
	csc /t:module shared.cs

	# create app which uses shared module
	csc /t:exe /addmodule:shared.netmodule app.cs

This is fully supported by ECMA-335: it creates a multi-file assembly. 
See ECMA-335, Partition 2, Section 6 (page 11).

See also: 
<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconbuildingmulti-fileassembly.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconbuildingmulti-fileassembly.asp</A>

Mono appears to support multi-file assemblies (at least, it ran the
test-case I created with .NET).  MCS doesn't; using the `/t:module'
compile flag creates a .dll with a .assembly directive.

It's interesting to create a .netmodule file and run monodis on the
resulting output.  It looks like normal CIL code, but it's missing the
.assembly directive.

 - Jon

On Thu, 2002-10-17 at 18:56, Miguel de Icaza wrote:
&gt;<i> Hello!
</I>&gt;<i> 
</I>&gt;<i> &gt; Can mono/mcs create and use static CIL libraries?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; If so, how do you create the static CIL libraries?
</I>&gt;<i> &gt; How do you link these static CIL libraries with something you are bulding?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; What about Microsoft .NET, Rotor, or Portable.Net?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; If not, can we persuade the Mono team, the Microsoft .NET team, the Rotor
</I>&gt;<i> &gt; team, the Portable.Net team, the ECMA standards people, and others to
</I>&gt;<i> &gt; include standard static CIL libraries support in their C# compiler and CLR
</I>&gt;<i> &gt; runtime?
</I>&gt;<i> 
</I>&gt;<i> The question really is what do you mean by a static CIL library.  
</I>&gt;<i> 
</I>&gt;<i> In the Unix world you have two kinds of libraries: static and dynamic. 
</I>&gt;<i> The difference being that the dynamic libraries contain code that can
</I>&gt;<i> cope with  position-independent layout of the code and can be loaded at
</I>&gt;<i> different addresses, hence allowing dynamically linked executables to
</I>&gt;<i> work.
</I>&gt;<i> 
</I>&gt;<i> So the concept does not really apply to .NET, as there is no machine
</I>&gt;<i> code in the actual assembly, so the assembly is always relocatable.
</I>&gt;<i> 
</I>&gt;<i> Maybe you are thinking of some kind of support to *embed* a library into
</I>&gt;<i> an executable.   If you are looking at that, you should be thinking in
</I>&gt;<i> terms of assemblies.
</I>&gt;<i> 
</I>&gt;<i> Miguel.
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@ximian.com">Mono-list@ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="009136.html">[Mono-list] Static CIL Libraries
</A></li>
	<LI> Next message: <A HREF="009145.html">[Mono-list] Static CIL Libraries
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9151">[ date ]</a>
              <a href="thread.html#9151">[ thread ]</a>
              <a href="subject.html#9151">[ subject ]</a>
              <a href="author.html#9151">[ author ]</a>
         </LI>
       </UL>
</body></html>
