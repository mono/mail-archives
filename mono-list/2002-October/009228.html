<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] compile problem with corelib
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jowenn%40kde.org">
   <META NAME="robots" CONTENT="index,nofollow">
   
   
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] compile problem with corelib
   </H1>
    <B>Joseph Wenninger
    </B> 
    <A HREF="mailto:jowenn%40kde.org"
       TITLE="[Mono-list] compile problem with corelib">jowenn@kde.org
       </A><BR>
    <I>21 Oct 2002 18:16:00 +0200</I>
    <P><UL>
        
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9228">[ date ]</a>
              <a href="thread.html#9228">[ thread ]</a>
              <a href="subject.html#9228">[ subject ]</a>
              <a href="author.html#9228">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--=-Idjkkbr2aKfkIUTrXeHj
Content-Type: text/plain
Content-Transfer-Encoding: 7bit


Hi 

I had a compile problem with the crypto stuff in the corelib. A file
contained ^M special characters. (I assume they are windows carriage
returns). After I've removed them it compiles fine. I'm attaching the
modified file. It would be nice, if someone with CVS access could put it
in.

Kind regards
Joseph Wenninger


--=-Idjkkbr2aKfkIUTrXeHj
Content-Disposition: attachment; filename=RC2CryptoServiceProvider.cs
Content-Transfer-Encoding: quoted-printable
Content-Type: text/plain; name=RC2CryptoServiceProvider.cs; charset=ISO-8859-15

//
// System.Security.Cryptography.RC2CryptoServiceProvider.cs
//
// Authors:
//	Andrew Birkett (<A HREF="mailto:andy@nobugs.org">andy@nobugs.org</A>)
//	Sebastien Pouliot (<A HREF="mailto:spouliot@motus.com">spouliot@motus.com</A>)
//
// Portions (C) 2002 Motus Technologies Inc. (<A HREF="http://www.motus.com">http://www.motus.com</A>)
//         =20
using System;
namespace System.Security.Cryptography {
// References:
// a.	IETF RFC2286: A Description of the RC2(r) Encryption Algorithm
//	<A HREF="http://www.ietf.org/rfc/rfc2268.txt">http://www.ietf.org/rfc/rfc2268.txt</A>

public sealed class RC2CryptoServiceProvider : RC2 {
	public RC2CryptoServiceProvider()
	{
	}
	public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgb=
IV)
	{
		Key =3D rgbKey;
		IV =3D rgbIV;
		return new RC2Transform (this, false);
	}
	public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgb=
IV)
	{
		Key =3D rgbKey;
		IV =3D rgbIV;
		return new RC2Transform (this, true);
	}
	[MonoTODO]
	public override void GenerateIV()
	{
		IVValue =3D new byte[BlockSizeValue / 8];
		for (int i=3D0; i &lt; IVValue.Length; i++) IVValue[i] =3D 0;
	}
	[MonoTODO]
	public override void GenerateKey()
	{
		KeyValue =3D new byte[KeySizeValue / 8];
		for (int i=3D0; i &lt; KeyValue.Length; i++) KeyValue[i] =3D 0;
	}
}

	internal class RC2Transform : SymmetricTransform
	{
		public RC2Transform (RC2 rc2Algo, bool encryption) : base (rc2Algo, encry=
ption, rc2Algo.IV)
		{
			R =3D new UInt32 [4];
			KeySetup (rc2Algo.Key, rc2Algo.EffectiveKeySize);
		}
		private void KeySetup (byte[] key, int t1)=20
		{	=09
			// Expand key into a byte array, then convert to word
			// array since we always access the key in 16bit chunks.
			byte[] L =3D new byte [128];
=09
			int t =3D key.Length;
			int t8 =3D ((t1 + 7) &gt;&gt; 3); // divide by 8
			int tm =3D 255 % (2 &lt;&lt; (8 + t1 - 8*t8 - 1));
=09
			Array.Copy (key, 0, L, 0, t);
=09
			for (int i=3Dt; i &lt; 128; i++)=20
				L [i] =3D (byte) (pitable [(L [i-1] + L [i-t]) &amp; 0xff]);
=09
			L [128-t8] =3D pitable [L [128-t8] &amp; tm];
=09
			for (int i=3D127-t8; i &gt;=3D 0; i--)=20
				L [i] =3D pitable [L [i+1] ^ L [i+t8]];
=09
			K =3D new UInt32 [64];
			int pos =3D 0;
			for (int i=3D0; i &lt; 64; i++)=20
				K [i] =3D (UInt32) (L [pos++] + L [pos++] * 256);
		}

		protected override void ECB (byte[] input, byte[] output)=20
		{
			// unrolled loop, eliminated mul
			R [0] =3D (UInt32) (input [0] + (input [1] &lt;&lt; 8));
			R [1] =3D (UInt32) (input [2] + (input [3] &lt;&lt; 8));
			R [2] =3D (UInt32) (input [4] + (input [5] &lt;&lt; 8));
			R [3] =3D (UInt32) (input [6] + (input [7] &lt;&lt; 8));
=09
			if (encrypt) {
				j =3D 0;
				Mix(); Mix(); Mix(); Mix(); Mix();
				Mash();
				Mix(); Mix(); Mix(); Mix(); Mix(); Mix();
				Mash();
				Mix(); Mix(); Mix(); Mix(); Mix();
			}=20
			else {
				j =3D 63;
				RMix(); RMix(); RMix(); RMix(); RMix();
				RMash();
				RMix(); RMix(); RMix(); RMix(); RMix(); RMix();
				RMash();
				RMix(); RMix(); RMix(); RMix(); RMix();
			}

			// unrolled loop
			output[0] =3D (byte) (R [0] &amp; 0xff);
			output[1] =3D (byte) ((R [0] &gt;&gt; 8) &amp; 0xff);
			output[2] =3D (byte) (R [1] &amp; 0xff);
			output[3] =3D (byte) ((R [1] &gt;&gt; 8) &amp; 0xff);
			output[4] =3D (byte) (R [2] &amp; 0xff);
			output[5] =3D (byte) ((R [2] &gt;&gt; 8) &amp; 0xff);
			output[6] =3D (byte) (R [3] &amp; 0xff);
			output[7] =3D (byte) ((R [3] &gt;&gt; 8) &amp; 0xff);
		}

		static public byte[] pitable =3D {
			0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed,=20
			0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d,
			0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e,=20
			0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2,
			0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13,=20
			0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32,
			0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b,=20
			0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82,
			0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c,=20
			0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc,
			0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1,=20
			0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26,
			0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57,=20
			0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03,
			0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7,=20
			0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7,
			0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7,=20
			0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a,
			0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74,=20
			0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec,
			0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc,=20
			0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39,
			0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a,=20
			0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31,
			0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae,=20
			0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9,
			0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c,=20
			0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9,
			0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0,=20
			0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e,
			0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77,=20
			0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad };
=09
		// The expanded key (in bottom 16 bits of each word)
		public UInt32[] K;
=09
		// The state (again in bottom 16 bits, although we only
		// clear the top 16 bits if needed)
		private UInt32[] R;
=09
		// Key indexer
		private int j;
=09
		private void Mix()=20
		{
			R[0] +=3D K[j]   + (R[3] &amp; R[2]) + ((~R[3]) &amp; R[1]);
			R[0] =3D (R[0] &lt;&lt; 1) | (R[0]&gt;&gt;15 &amp; 0x1);
=09
			R[1] +=3D K[j+1] + (R[0] &amp; R[3]) + ((~R[0]) &amp; R[2]);
			R[1] =3D (R[1] &lt;&lt; 2) | (R[1]&gt;&gt;14 &amp; 0x3);
=09
			R[2] +=3D K[j+2] + (R[1] &amp; R[0]) + ((~R[1]) &amp; R[3]);
			R[2] =3D (R[2] &lt;&lt; 3) | (R[2]&gt;&gt;13 &amp; 0x7);
=09
			R[3] +=3D K[j+3] + (R[2] &amp; R[1]) + ((~R[2]) &amp; R[0]);
			R[3] =3D (R[3] &lt;&lt; 5) | (R[3]&gt;&gt;11 &amp; 0x1f);
			j +=3D 4;=09
		}
=09
		private void RMix()=20
		{
			R[3] &amp;=3D 0xffff;
			R[3] =3D (R[3] &gt;&gt; 5) | ((R[3] &amp; 0x1f) &lt;&lt; 11);
			R[3] -=3D K[j] + (R[2] &amp; R[1]) + ((~R[2]) &amp; R[0]);
=09
			R[2] &amp;=3D 0xffff;
			R[2] =3D (R[2] &gt;&gt; 3) | ((R[2] &amp; 0x7) &lt;&lt; 13);
			R[2] -=3D K[j-1] + (R[1] &amp; R[0]) + ((~R[1]) &amp; R[3]);

			R[1] &amp;=3D 0xffff;
			R[1] =3D (R[1] &gt;&gt; 2) | ((R[1] &amp; 0x3) &lt;&lt; 14);
			R[1] -=3D K[j-2] + (R[0] &amp; R[3]) + ((~R[0]) &amp; R[2]);
=09
			R[0] &amp;=3D 0xffff;
			R[0] =3D (R[0] &gt;&gt; 1) | ((R[0] &amp; 0x1) &lt;&lt; 15);
			R[0] -=3D K[j-3] + (R[3] &amp; R[2]) + ((~R[3]) &amp; R[1]);
=09
			j -=3D 4;
		}
		private void Mash ()
		{
			R [0] +=3D K [R [3] &amp; 63];
			R [1] +=3D K [R [0] &amp; 63];
			R [2] +=3D K [R [1] &amp; 63];
			R [3] +=3D K [R [2] &amp; 63];
		}
		private void RMash ()
		{
			R [3] -=3D K [R [2] &amp; 63];
			R [2] -=3D K [R [1] &amp; 63];
			R [1] -=3D K [R [0] &amp; 63];
			R [0] -=3D K [R [3] &amp; 63];
		}
	}
}

--=-Idjkkbr2aKfkIUTrXeHj--




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9228">[ date ]</a>
              <a href="thread.html#9228">[ thread ]</a>
              <a href="subject.html#9228">[ subject ]</a>
              <a href="author.html#9228">[ author ]</a>
         </LI>
       </UL>
</body></html>
