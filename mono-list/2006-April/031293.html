<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] ECall methods must be packaged into a system module.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20ECall%20methods%20must%20be%20packaged%20into%20a%20system%20module.&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="031282.html">
   <LINK REL="Next"  HREF="031299.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] ECall methods must be packaged into a system module.</H1>
    <B>Antonello Provenzano</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20ECall%20methods%20must%20be%20packaged%20into%20a%20system%20module.&In-Reply-To="
       TITLE="[Mono-list] ECall methods must be packaged into a system module.">antonello at minosse.com
       </A><BR>
    <I>Sun Apr 16 15:20:52 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="031282.html">[Mono-list] - Some Questions About GTK# Widgets -
</A></li>
        <LI>Next message: <A HREF="031299.html">[Mono-list] ECall methods must be packaged into a system module.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31293">[ date ]</a>
              <a href="thread.html#31293">[ thread ]</a>
              <a href="subject.html#31293">[ subject ]</a>
              <a href="author.html#31293">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I created an application that emulates the GNU ReadLine library,
entirely written in C# language, merging part of the sources of the
Mono Console API and the project DotGNU.Terminal (you can checkout it
at <A HREF="http://sourceforge.net/projects/deveelreadline">http://sourceforge.net/projects/deveelreadline</A>).
When I started testing it, I received an exception, wrapped by a
TypeInitializationException, with the message &quot;ECall methods must be
packaged into a system module.&quot;, both under Mono and .NET.

The only internal calls in this library are made inside the
&quot;redefined&quot; Mono Console API included in the library, but when I
tested it, worked perfectly without any problem.
The error, then, is generated by the ReadLine class (a static class
without any constructor: this makes me mad about the fact the
exception thrown is a TypeInitializationException, typically
originated by a constructor of a type).

I would like to receive help from you about this topic: you will find
the ReadLine class attached, even if the complete project can be
downloaded from the project page on SourceForge (the one described
above).

Thanks.
Antonello
-------------- next part --------------
using System;

namespace Deveel {
	public sealed class Readline {
		#region ctor
		private Readline() {
		}
		#endregion

		#region Fields
		// Internal state.
		private static bool enterIsDuplicate = false;
		private static bool controlDIsEOF = true;
		private static bool controlZIsEOF = Console.IsWindows();

		// Line input buffer.
		private static char[] buffer = new char[256];
		private static byte[] widths = new byte[256];
		private static int posn, length, column, lastColumn;
		private static bool overwrite = false;
		private static int historyPosn;
		private static string historySave;
		private static string yankedString = null;
		#endregion

		#region Events
		/// &lt;summary&gt;
		/// Event that is emitted to allow for tab completion.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// If there are no attached handlers, then the Tab key will do 
		/// normal tabbing.
		/// &lt;/remarks&gt;
		public static event TabCompleteEventHandler TabComplete;
		#endregion

		#region Properties
		/// &lt;summary&gt;
		/// Gets or sets a flag that indicates if pressing the &quot;Enter&quot; key on 
		/// an empty line causes the most recent history line to be duplicated.
		/// &lt;/summary&gt;
		public static bool EnterIsDuplicate {
			get { return enterIsDuplicate; }
			set { enterIsDuplicate = value; }
		}

		/// &lt;summary&gt;
		/// Gets or sets a flag that indicates if CTRL-D is an EOF indication
		/// or the &quot;delete character&quot; key.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// The default is true (i.e. EOF).
		/// &lt;/remarks&gt;
		public static bool ControlDIsEOF {
			get { return controlDIsEOF; }
			set { controlDIsEOF = value; }
		}

		/// &lt;summary&gt;
		/// Gets or sets a flag that indicates if CTRL-Z is an EOF indication.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// The default is true on Windows system, false otherwise.
		/// &lt;/remarks&gt;
		public static bool ControlZIsEOF {
			get { return controlZIsEOF; }
			set { controlZIsEOF = value; }
		}
		#endregion

		#region Private Static Methods
		/// &lt;summary&gt;
		/// Makes room for one more character in the input buffer.
		/// &lt;/summary&gt;
		private static void MakeRoom() {
			if (length &gt;= buffer.Length) {
				char[] newBuffer = new char[buffer.Length * 2];
				byte[] newWidths = new byte[buffer.Length * 2];
				Array.Copy(buffer, 0, newBuffer, 0, buffer.Length);
				Array.Copy(widths, 0, newWidths, 0, buffer.Length);
			}
		}

		/// &lt;summary&gt;
		/// Repaint the line starting at the current character.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;step&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;moveToEnd&quot;&gt;&lt;/param&gt;
		private static void Repaint(bool step, bool moveToEnd) {
			int posn = Readline.posn;
			int column = Readline.column;
			int width;

			// Paint the characters in the line.
			while (posn &lt; length) {
				if (buffer[posn] == '\t') {
					width = 8 - (column % 8);
					widths[posn] = (byte)width;
					while (width &gt; 0) {
						Console.Write(' ');
						--width;
						++column;
					}
				} else if (buffer[posn] &lt; 0x20) {
					Console.Write('^');
					Console.Write((char)(buffer[posn] + 0x40));
					widths[posn] = 2;
					column += 2;
				} else if (buffer[posn] == '\u007F') {
					Console.Write('^');
					Console.Write('?');
					widths[posn] = 2;
					column += 2;
				} else {
					Console.Write(buffer[posn]);
					widths[posn] = 1;
					++column;
				}
				++posn;
			}

			// Adjust the position of the last column.
			if (column &gt; lastColumn) {
				lastColumn = column;
			} else if (column &lt; lastColumn) {
				// We need to clear some characters beyond this point.
				width = lastColumn - column;
				lastColumn = column;
				while (width &gt; 0) {
					Console.Write(' ');
					--width;
					++column;
				}
			}

			// Backspace to the initial cursor position.
			if (moveToEnd) {
				width = column - lastColumn;
				Readline.posn = length;
			} else if (step) {
				width = column - (Readline.column + widths[Readline.posn]);
				Readline.column += widths[Readline.posn];
				++(Readline.posn);
			} else {
				width = column - Readline.column;
			}
			while (width &gt; 0) {
				Console.Write('\u0008');
				--width;
			}
		}

		/// &lt;summary&gt;
		/// Add a character to the input buffer.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;ch&quot;&gt;&lt;/param&gt;
		private static void AddChar(char ch) {
			if (overwrite &amp;&amp; posn &lt; length) {
				buffer[posn] = ch;
				Repaint(true, false);
			} else {
				MakeRoom();
				if (posn &lt; length) {
					Array.Copy(buffer, posn, buffer, posn + 1,
						length - posn);
				}
				buffer[posn] = ch;
				++length;
				Repaint(true, false);
			}
		}

		// Go back a specific number of characters.
		private static void GoBack(int num) {
			int width;
			while (num &gt; 0) {
				--posn;
				width = widths[posn];
				column -= width;
				while (width &gt; 0) {
					Console.Write('\u0008');
					--width;
				}
				--num;
			}
		}

		// Backspace one character.
		private static void Backspace() {
			if (posn &gt; 0) {
				GoBack(1);
				Delete();
			}
		}

		// Delete the character under the cursor.
		private static void Delete() {
			if (posn &lt; length) {
				Array.Copy(buffer, posn + 1, buffer, posn,
					length - posn - 1);
				--length;
				Repaint(false, false);
			}
		}

		// Delete a number of characters under the cursor.
		private static void Delete(int num) {
			Array.Copy(buffer, posn + num, buffer, posn,
				length - posn - num);
			length -= num;
			Repaint(false, false);
		}

		// Print a list of alternatives for tab completion.
		private static void PrintAlternatives(String[] list) {
			int width, maxWidth;
			int columns, column, posn;
			String str;

			// Determine the maximum string length, for formatting.
			maxWidth = 0;
			foreach (String a in list) {
				if (a != null) {
					width = a.Length;
					if (width &gt; maxWidth) {
						maxWidth = width;
					}
				}
			}

			// Determine the number of columns.
			width = Console.WindowWidth;
			if (maxWidth &gt; (width - 7)) {
				columns = 1;
			} else {
				columns = width / (maxWidth + 7);
			}

			// Print the strings.
			column = 0;
			for (posn = 0; posn &lt; list.Length; ++posn) {
				str = list[posn];
				if (str != null) {
					Console.Write(str);
					width = str.Length;
				} else {
					width = 0;
				}
				++column;
				if (column &lt; columns) {
					while (width &lt; maxWidth) {
						Console.Write(' ');
						++width;
					}
					Console.Write(&quot;       &quot;);
				} else {
					Console.Write(&quot;\r\n&quot;);
					column = 0;
				}
			}
			if (column != 0) {
				Console.Write(&quot;\r\n&quot;);
			}
		}

		// Tab across to the next stop, or perform tab completion.
		private static void Tab(String prompt) {
			if (TabComplete == null) {
				// Add the TAB character and repaint the line.
				AddChar('\t');
			} else {
				// Perform tab completion and insert the results.
				TabCompleteEventArgs e;
				e = new TabCompleteEventArgs(new String(buffer, 0, posn), new String(buffer, posn, length - posn));
				TabComplete(null, e);
				if (e.Insert != null) {
					// Insert the value that we found.
					bool saveOverwrite = overwrite;
					overwrite = false;
					foreach (char ch in e.Insert) {
						AddChar(ch);
					}
					overwrite = saveOverwrite;
				} else if (e.Alternatives != null &amp;&amp; e.Alternatives.Length &gt; 0) {
					// Print the alternatives for the user.
					int savePosn = posn;
					EndLine();
					PrintAlternatives(e.Alternatives);
					if (prompt != null) {
						Console.Write(prompt);
					}
					posn = savePosn;
					Redraw();
				} else {
					// No alternatives, or alternatives not supplied yet.
					Console.Beep();
				}
			}
		}

		// End the current line.
		private static void EndLine() {
			// Repaint the line and move to the end.
			Repaint(false, true);

			// Output the line terminator to the terminal.
			Console.WriteLine();
		}

		// Move left one character.
		private static void MoveLeft() {
			if (posn &gt; 0) {
				GoBack(1);
			}
		}

		// Move right one character.
		private static void MoveRight() {
			if (posn &lt; length) {
				Repaint(true, false);
			}
		}

		// Set the current buffer contents to a historical string.
		private static void SetCurrent(String line) {
			if (line == null) {
				line = String.Empty;
			}
			Clear();
			foreach (char ch in line) {
				AddChar(ch);
			}
		}

		// Move up one line in the history.
		private static void MoveUp() {
			if (historyPosn == -1) {
				if (History.Count &gt; 0) {
					historySave = new String(buffer, 0, length);
					historyPosn = 0;
					SetCurrent(History.GetHistory(historyPosn));
				}
			} else if ((historyPosn + 1) &lt; History.Count) {
				++historyPosn;
				SetCurrent(History.GetHistory(historyPosn));
			} else {
				Console.Beep();
			}
		}

		// Move down one line in the history.
		private static void MoveDown() {
			if (historyPosn == 0) {
				historyPosn = -1;
				SetCurrent(historySave);
			} else if (historyPosn &gt; 0) {
				--historyPosn;
				SetCurrent(History.GetHistory(historyPosn));
			} else {
				Console.Beep();
			}
		}

		// Move to the beginning of the current line.
		private static void MoveHome() {
			GoBack(posn);
		}

		// Move to the end of the current line.
		private static void MoveEnd() {
			Repaint(false, true);
		}

		// Clear the entire line.
		private static void Clear() {
			GoBack(posn);
			length = 0;
			Repaint(false, false);
		}

		// Cancel the current line and start afresh with a new prompt.
		private static void CancelLine(String prompt) {
			EndLine();
			if (prompt != null) {
				Console.Write(prompt);
			}
			posn = 0;
			length = 0;
			column = 0;
			lastColumn = 0;
			historyPosn = -1;
		}

		// Redraw the current line.
		private static void Redraw() {
			String str = new String(buffer, 0, length);
			int savePosn = posn;
			posn = 0;
			length = 0;
			column = 0;
			lastColumn = 0;
			foreach (char ch in str) {
				AddChar(ch);
			}
			GoBack(length - savePosn);
		}

		// Erase all characters until the start of the current line.
		private static void EraseToStart() {
			if (posn &gt; 0) {
				int savePosn = posn;
				yankedString = new String(buffer, 0, posn);
				GoBack(savePosn);
				Delete(savePosn);
			}
		}

		// Erase all characters until the end of the current line.
		private static void EraseToEnd() {
			yankedString = new String(buffer, posn, length - posn);
			length = posn;
			Repaint(false, false);
		}

		// Erase the previous word on the current line (delimited by whitespace).
		private static void EraseWord() {
			int temp = posn;
			while (temp &gt; 0 &amp;&amp; Char.IsWhiteSpace(buffer[temp - 1])) {
				--temp;
			}
			while (temp &gt; 0 &amp;&amp; !Char.IsWhiteSpace(buffer[temp - 1])) {
				--temp;
			}
			if (temp &lt; posn) {
				temp = posn - temp;
				GoBack(temp);
				yankedString = new String(buffer, posn, temp);
				Delete(temp);
			}
		}

		// Determine if a character is a &quot;word character&quot; (letter or digit).
		private static bool IsWordCharacter(char ch) {
			return Char.IsLetterOrDigit(ch);
		}

		// Erase to the end of the current word.
		private static void EraseToEndWord() {
			int temp = posn;
			while (temp &lt; length &amp;&amp; !IsWordCharacter(buffer[temp])) {
				++temp;
			}
			while (temp &lt; length &amp;&amp; IsWordCharacter(buffer[temp])) {
				++temp;
			}
			if (temp &gt; posn) {
				temp -= posn;
				yankedString = new String(buffer, posn, temp);
				Delete(temp);
			}
		}

		// Erase to the start of the current word.
		private static void EraseToStartWord() {
			int temp = posn;
			while (temp &gt; 0 &amp;&amp; !IsWordCharacter(buffer[temp - 1])) {
				--temp;
			}
			while (temp &gt; 0 &amp;&amp; IsWordCharacter(buffer[temp - 1])) {
				--temp;
			}
			if (temp &lt; posn) {
				temp = posn - temp;
				GoBack(temp);
				yankedString = new String(buffer, posn, temp);
				Delete(temp);
			}
		}

		// Move forward one word in the input line.
		private static void MoveForwardWord() {
			while (posn &lt; length &amp;&amp; !IsWordCharacter(buffer[posn])) {
				MoveRight();
			}
			while (posn &lt; length &amp;&amp; IsWordCharacter(buffer[posn])) {
				MoveRight();
			}
		}

		// Move backward one word in the input line.
		private static void MoveBackwardWord() {
			while (posn &gt; 0 &amp;&amp; !IsWordCharacter(buffer[posn - 1])) {
				MoveLeft();
			}
			while (posn &gt; 0 &amp;&amp; IsWordCharacter(buffer[posn - 1])) {
				MoveLeft();
			}
		}
		#endregion

		#region Public Static Methods
		// Read the next line of input using line editing.  Returns &quot;null&quot;
		// if an EOF indication is encountered in the input.
		public static string ReadLine(string prompt) {
			ConsoleKeyInfo key;
			char ch;
			bool done;
			bool ctrlv;

			// Output the prompt.
			if (prompt != null) {
				Console.Write(prompt);
			}

			// Enter the main character input loop.
			posn = 0;
			length = 0;
			column = 0;
			lastColumn = 0;
			done = false;
			overwrite = false;
			historyPosn = -1;
			ctrlv = false;
			do {
				key = ConsoleExtensions.ReadKey(true);
				ch = key.KeyChar;
				if (ctrlv) {
					ctrlv = false;
					if ((ch &gt;= 0x0001 &amp;&amp; ch &lt;= 0x001F) || ch == 0x007F) {
						// Insert a control character into the buffer.
						AddChar(ch);
						continue;
					}
				}
				if (ch != '\0') {
					switch (ch) {
						case '\u0001': {
								// CTRL-A: move to the home position.
								MoveHome();
							}
							break;

						case '\u0002': {
								// CTRL-B: go back one character.
								MoveLeft();
							}
							break;

						case '\u0003': {
								// CTRL-C encountered in &quot;raw&quot; mode.
								CancelLine(prompt);
							}
							break;

						case '\u0004': {
								// CTRL-D: EOF or delete the current character.
								if (controlDIsEOF) {
									// Signal an EOF if the buffer is empty.
									if (length == 0) {
										EndLine();
										return null;
									}
								} else {
									Delete();
								}
							}
							break;

						case '\u0005': {
								// CTRL-E: move to the end position.
								MoveEnd();
							}
							break;

						case '\u0006': {
								// CTRL-F: go forward one character.
								MoveRight();
							}
							break;

						case '\u0007': {
								// CTRL-G: ring the terminal bell.
								Console.Beep();
							}
							break;

						case '\u0008':
						case '\u007F': {
								if (key.Key == ConsoleKey.Delete) {
									// Delete the character under the cursor.
									Delete();
								} else {
									// Delete the character before the cursor.
									Backspace();
								}
							}
							break;

						case '\u0009': {
								// Process a tab.
								Tab(prompt);
							}
							break;

						case '\u000A':
						case '\u000D': {
								// Line termination.
								EndLine();
								done = true;
							}
							break;

						case '\u000B': {
								// CTRL-K: erase until the end of the line.
								EraseToEnd();
							}
							break;

						case '\u000C': {
								// CTRL-L: clear screen and redraw.
								Console.Clear();
								Console.Write(prompt);
								Redraw();
							}
							break;

						case '\u000E': {
								// CTRL-N: move down in the history.
								MoveDown();
							}
							break;

						case '\u0010': {
								// CTRL-P: move up in the history.
								MoveUp();
							}
							break;

						case '\u0015': {
								// CTRL-U: erase to the start of the line.
								EraseToStart();
							}
							break;

						case '\u0016': {
								// CTRL-V: prefix a control character.
								ctrlv = true;
							}
							break;

						case '\u0017': {
								// CTRL-W: erase the previous word.
								EraseWord();
							}
							break;

						case '\u0019': {
								// CTRL-Y: yank the last erased string.
								if (yankedString != null) {
									foreach (char ch2 in yankedString) {
										AddChar(ch2);
									}
								}
							}
							break;

						case '\u001A': {
								// CTRL-Z: Windows end of file indication.
								if (controlZIsEOF &amp;&amp; length == 0) {
									EndLine();
									return null;
								}
							}
							break;

						case '\u001B': {
								// Escape is &quot;clear line&quot;.
								Clear();
							}
							break;

						default: {
								if (ch &gt;= ' ') {
									// Ordinary character.
									AddChar(ch);
								}
							}
							break;
					}
				} else if (key.Modifiers == (ConsoleModifiers)0) {
					switch (key.Key) {
						case ConsoleKey.Backspace: {
								// Delete the character before the cursor.
								Backspace();
							}
							break;

						case ConsoleKey.Delete: {
								// Delete the character under the cursor.
								Delete();
							}
							break;

						case ConsoleKey.Enter: {
								// Line termination.
								EndLine();
								done = true;
							}
							break;

						case ConsoleKey.Escape: {
								// Clear the current line.
								Clear();
							}
							break;

						case ConsoleKey.Tab: {
								// Process a tab.
								Tab(prompt);
							}
							break;

						case ConsoleKey.LeftArrow: {
								// Move left one character.
								MoveLeft();
							}
							break;

						case ConsoleKey.RightArrow: {
								// Move right one character.
								MoveRight();
							}
							break;

						case ConsoleKey.UpArrow: {
								// Move up one line in the history.
								MoveUp();
							}
							break;

						case ConsoleKey.DownArrow: {
								// Move down one line in the history.
								MoveDown();
							}
							break;

						case ConsoleKey.Home: {
								// Move to the beginning of the line.
								MoveHome();
							}
							break;

						case ConsoleKey.End: {
								// Move to the end of the line.
								MoveEnd();
							}
							break;

						case ConsoleKey.Insert: {
								// Toggle insert/overwrite mode.
								overwrite = !overwrite;
							}
							break;
					}
				} else if ((key.Modifiers &amp; ConsoleModifiers.Alt) != 0) {
					switch (key.Key) {
						case ConsoleKey.F: {
								// ALT-F: move forward a word.
								MoveForwardWord();
							}
							break;

						case ConsoleKey.B: {
								// ALT-B: move backward a word.
								MoveBackwardWord();
							}
							break;

						case ConsoleKey.D: {
								// ALT-D: erase until the end of the word.
								EraseToEndWord();
							}
							break;

						case ConsoleKey.Backspace:
						case ConsoleKey.Delete: {
								// ALT-DEL: erase until the start of the word.
								EraseToStartWord();
							}
							break;
					}
				}
			}
			while (!done);
			if (length == 0 &amp;&amp; enterIsDuplicate) {
				if (History.Count &gt; 0) {
					return History.GetHistory(0);
				}
			}
			return new String(buffer, 0, length);
		}
		#endregion
	}
}
</PRE>














<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="031282.html">[Mono-list] - Some Questions About GTK# Widgets -
</A></li>
	<LI>Next message: <A HREF="031299.html">[Mono-list] ECall methods must be packaged into a system module.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#31293">[ date ]</a>
              <a href="thread.html#31293">[ thread ]</a>
              <a href="subject.html#31293">[ subject ]</a>
              <a href="author.html#31293">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
