<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] inlining of methods using structs
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:tomar%40apricot.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="022801.html">
   <LINK REL="Next"  HREF="022821.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] inlining of methods using structs
   </H1>
    <B>Tom Larsen
    </B> 
    <A HREF="mailto:tomar%40apricot.com"
       TITLE="[Mono-list] inlining of methods using structs">tomar@apricot.com
       </A><BR>
    <I>Wed, 18 Aug 2004 10:03:46 -0700 (PDT)</I>
    <P><UL>
        <LI> Previous message: <A HREF="022801.html">[Mono-list] inlining of methods using structs
</A></li>
        <LI> Next message: <A HREF="022821.html">[Mono-list] inlining of methods using structs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22819">[ date ]</a>
              <a href="thread.html#22819">[ thread ]</a>
              <a href="subject.html#22819">[ subject ]</a>
              <a href="author.html#22819">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&quot;Inlining&quot; is a function of the compiler.  The runtime doesn't
particuarlly care whether the next operator is a call onto a function or
the function inline.  The tradeoff is of course the classic &quot;speed vs
space&quot;.  A commonly used function might incur less of a performance hit if
placed in line but you've increased the IL length of every function that
is now using the code inline.

You seem to be under the guise that &quot;structs&quot; are lightweight.  There is
noting about ECMA CLI specification that indicates this.  In fact
&quot;structs&quot; can be quite complex.  The one blessing of the way C# over Java
is this seperation of &quot;objects&quot; (classes) and &quot;data&quot; (structs) but nothing
ever indicates that objects are heavier or lighter than structs.  If
anything &quot;structs&quot; are harder to deal with because of box/unbox.

Tom Larsen

On Wed, 18 Aug 2004, [ISO-8859-1] R=FCdiger Klaehn wrote:

&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i> I am new on this list. I have been interested in using .NET for
</I>&gt;<i> numerical problems for some time.
</I>&gt;<i>
</I>&gt;<i> When investigating the lower than expected performance of some code of
</I>&gt;<i> mine, I found out that both the Microsoft JIT and the mono JIT do not
</I>&gt;<i> inline methods with an explicit struct parameter or a struct return value=
</I>=2E
&gt;<i>
</I>&gt;<i> This came as quite a shock to me, since I always assumed that structs
</I>&gt;<i> are the way to go for performance critical stuff. I attached an example
</I>&gt;<i> for a case that would benefit tremendously from inlining of method calls
</I>&gt;<i> involving structs in some way.
</I>&gt;<i>
</I>&gt;<i> Is there some deep philosophical reason for not inlining method calls
</I>&gt;<i> involving structs? It does not make any sense for me, since especially
</I>&gt;<i> in the case of small structs the opportunities for inlining and
</I>&gt;<i> subsequent optimizations are huge.
</I>&gt;<i>
</I>&gt;<i> THis would be a nice way to improve the performance of the JIT compiler
</I>&gt;<i> by a factor of 4 or so in many cases.
</I>&gt;<i>
</I>&gt;<i> This is the relevant code in mono/mini/mini.c:
</I>&gt;<i> ---
</I>&gt;<i> =09    /* fixme: why cant we inline valuetype returns? */
</I>&gt;<i> =09    MONO_TYPE_ISSTRUCT (signature-&gt;ret))
</I>&gt;<i> =09=09return FALSE;
</I>&gt;<i>
</I>&gt;<i> =09/* its not worth to inline methods with valuetype arguments?? */
</I>&gt;<i> =09for (i =3D 0; i &lt; signature-&gt;param_count; i++) {
</I>&gt;<i> =09=09if (MONO_TYPE_ISSTRUCT (signature-&gt;params [i])) {
</I>&gt;<i> =09=09=09return FALSE;
</I>&gt;<i> =09=09}
</I>&gt;<i> =09}
</I>&gt;<i> ---
</I>&gt;<i>
</I>&gt;<i> Another thing I have noticed is that mono only inlines methods that are
</I>&gt;<i> shorter than 20 bytes of IL code. I am sure that this makes sense for
</I>&gt;<i> most applications, but in some cases it would be very useful to increase
</I>&gt;<i> this value to 64 or maybe even 128. I think there should be a
</I>&gt;<i> per-assembly attribute to specify the inlining threshold.
</I>&gt;<i>
</I>&gt;<i> best regards
</I>&gt;<i>
</I>&gt;<i> R=FCdiger
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> This is a small benchmark for struct inlining:
</I>&gt;<i> ---
</I>&gt;<i> using System;
</I>&gt;<i>
</I>&gt;<i> namespace OperatorInliningTest
</I>&gt;<i> {
</I>&gt;<i>      public struct Complex
</I>&gt;<i>      {
</I>&gt;<i>          internal double re, im;
</I>&gt;<i>          public Complex(double re, double im)
</I>&gt;<i>          {
</I>&gt;<i>              this.re =3D re;
</I>&gt;<i>              this.im =3D im;
</I>&gt;<i>          }
</I>&gt;<i>          public static implicit operator Complex(double re) {
</I>&gt;<i>              return new Complex(re, 0);
</I>&gt;<i>          }
</I>&gt;<i>          public static Complex I
</I>&gt;<i>          {
</I>&gt;<i>              get { return new Complex(0,1); }
</I>&gt;<i>          }
</I>&gt;<i>          public static Complex Zero
</I>&gt;<i>          {
</I>&gt;<i>              get { return new Complex(0,0); }
</I>&gt;<i>          }
</I>&gt;<i>          public static Complex One
</I>&gt;<i>          {
</I>&gt;<i>              get { return new Complex(1,0); }
</I>&gt;<i>          }
</I>&gt;<i>          public static Complex operator +(Complex a, Complex b)
</I>&gt;<i>          {
</I>&gt;<i>              return new Complex(a.re+b.re,a.im+b.im);
</I>&gt;<i>          }
</I>&gt;<i>          public static Complex operator *(Complex a, Complex b)
</I>&gt;<i>          {
</I>&gt;<i>              return new Complex(a.re*b.re-a.im*b.im,a.re*b.im+a.im*b.re);
</I>&gt;<i>          }
</I>&gt;<i>          public double AbsoluteSquared
</I>&gt;<i>          {
</I>&gt;<i>              get { return re*re+im*im; }
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i>      class Program
</I>&gt;<i>      {
</I>&gt;<i>          static int MandelbrotIteration1(Complex c)
</I>&gt;<i>          {
</I>&gt;<i>              Complex x =3D Complex.Zero;
</I>&gt;<i>              for (int i =3D 0; i &lt; 1000; i++)
</I>&gt;<i>              {
</I>&gt;<i>                  x =3D x*x+c;
</I>&gt;<i>                  if (x.AbsoluteSquared &gt; 4)
</I>&gt;<i>                      return i;
</I>&gt;<i>              }
</I>&gt;<i>              return -1;
</I>&gt;<i>          }
</I>&gt;<i>          static int MandelbrotIteration4(Complex c)
</I>&gt;<i>          {
</I>&gt;<i>              double xre, xim, cre, cim, t;
</I>&gt;<i>              xre =3D 0; xim =3D 0;
</I>&gt;<i>              cre =3D c.re; cim =3D c.im;
</I>&gt;<i>              for (int i =3D 0; i &lt; 1000; i++)
</I>&gt;<i>              {
</I>&gt;<i>                  //x=3Dx*x...
</I>&gt;<i>                  t =3D xre * xre - xim * xim;
</I>&gt;<i>                  xim =3D xre * xim + xre * xim;
</I>&gt;<i>                  xre =3D t;
</I>&gt;<i>                  //...=3Dc;
</I>&gt;<i>                  xre +=3D cre;
</I>&gt;<i>                  xim +=3D cim;
</I>&gt;<i>                  //if(x.AbsoluteSquared&gt;4)
</I>&gt;<i>                  if (xre * xre + xim * xim &gt; 4)
</I>&gt;<i>                      return i;
</I>&gt;<i>              }
</I>&gt;<i>              return -1;
</I>&gt;<i>          }
</I>&gt;<i>          static void Main(string[] args)
</I>&gt;<i>          {
</I>&gt;<i>              DateTime time0, time1;
</I>&gt;<i>              TimeSpan delta0, delta1;
</I>&gt;<i>              Complex x=3DComplex.Zero;
</I>&gt;<i>              time0 =3D DateTime.Now;
</I>&gt;<i>              for (int i =3D 0; i &lt; 10000; i++)
</I>&gt;<i>                  MandelbrotIteration1(x);
</I>&gt;<i>              delta0 =3D DateTime.Now - time0;
</I>&gt;<i>              time1 =3D DateTime.Now;
</I>&gt;<i>              for (int i =3D 0; i &lt; 10000; i++)
</I>&gt;<i>                  MandelbrotIteration4(x);
</I>&gt;<i>              delta1 =3D DateTime.Now - time1;
</I>&gt;<i>              Console.WriteLine(&quot;Relying on the JIT to inline: {0}&quot;, delta=
</I>0);
&gt;<i>              Console.WriteLine(&quot;Manually inlined like in the bad old
</I>&gt;<i> days {0}:&quot;, delta1);
</I>&gt;<i>              Console.ReadLine();
</I>&gt;<i>          }
</I>&gt;<i>      }
</I>&gt;<i> }
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@lists.ximian.com">Mono-list@lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i>
</I>
</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="022801.html">[Mono-list] inlining of methods using structs
</A></li>
	<LI> Next message: <A HREF="022821.html">[Mono-list] inlining of methods using structs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22819">[ date ]</a>
              <a href="thread.html#22819">[ thread ]</a>
              <a href="subject.html#22819">[ subject ]</a>
              <a href="author.html#22819">[ author ]</a>
         </LI>
       </UL>
</body></html>
