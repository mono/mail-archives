<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] catching stack overflow signals
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:dietmar%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="006540.html">
   <LINK REL="Next"  HREF="006541.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] catching stack overflow signals
   </H1>
    <B>Dietmar Maurer
    </B> 
    <A HREF="mailto:dietmar%40ximian.com"
       TITLE="[Mono-list] catching stack overflow signals">dietmar@ximian.com
       </A><BR>
    <I>19 Jun 2002 17:42:42 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="006540.html">[Mono-list] bootstrapping System.dll
</A></li>
        <LI> Next message: <A HREF="006541.html">[Mono-list] catching stack overflow signals
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6538">[ date ]</a>
              <a href="thread.html#6538">[ thread ]</a>
              <a href="subject.html#6538">[ subject ]</a>
              <a href="author.html#6538">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--=-Y5aylY+PVe/IKCnvIfnW
Content-Type: text/plain
Content-Transfer-Encoding: 7bit

Hi all,

today I tried to find a solution to catch stack overflow signals
(segmentation fault) in order to throw a StackOverflow exception, but
unfortunately its not so easy.

On stack overflow the system raises a SIGSEGV signal and transfers
control to the handler. But that action needs the stack, so it raises
another SIGSEGV which then terminates the process immediately.

On solution is to use a separate stack for signal handler. We can use
sigaltstack () to setup such extra stack. I have attached a small test
program I found on the net to show how this works - simply compile the
program with:

gcc sigtest.c -o sigtest

The problem with that solution is that i does not work with pthread. you
can test that if you compile the program with:

gcc sigtest.c -o sigtest -lpthread

Pthread tries to determine the current thread using the stack pointer,
so this fails if we change the stack using sigaltstack.

On workaround is to use a stack allocated memory for sigaltstack, for
example we can define a local variable:

char alttack [8192] __attribute__ (( aligned (32) )); 

That way we solve the above problem, but i am quite sure that this will
confuse pthread somehow, because its thread detection always points to
the same thread in signal handler.

So maybe someone knows a better solution?

- Dietmar








--=-Y5aylY+PVe/IKCnvIfnW
Content-Disposition: attachment; filename=sigtest.c
Content-Transfer-Encoding: quoted-printable
Content-Type: text/x-c; name=sigtest.c; charset=ISO-8859-1

/*
 * Test program to test sigaltstack() system call.
 * Does a stack overflow, which normally linux/i386 will not be able=20
 * to deliver. There are other ways of demonstrating but this is
 * the easiest. Of course apply the sigaltstack() patch first or
 * you wont see diddly.
 */

#include &lt;sys/signal.h&gt;
#include &lt;asm/unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;

struct sigaction act;

#define GET_STACK( x ) \
	__asm__ __volatile(&quot;movl %%esp, %0\n\t&quot; : &quot;=3Dq&quot; (x) : :&quot;%0&quot; )

void handler()
{
	unsigned long ss_sp;

	printf( &quot;Caught SIGSEGV and handled stack overflow correctly.\n&quot; );
	GET_STACK( ss_sp );
	printf( &quot;signal handler stack pointer =3D %p\n&quot;, ss_sp );
	exit(0);
}
void handler1()
{
	printf(&quot;handler1\n&quot;);
	exit(0);
}

void recurse()
{
	char buf[ 4096 ];
	recurse();
}

int main()
{
	long ret;
	struct sigaltstack sa, sa_old;
	unsigned long ss_sp;

	/* Step 1 - setup your alternate sig-stack */
	sa.ss_sp =3D malloc( MINSIGSTKSZ );
	if( !sa.ss_sp )
		printf( &quot;malloc failed\n&quot; );

	sa.ss_size =3D MINSIGSTKSZ;
	sa.ss_flags =3D SS_ONSTACK;

	if( sigaltstack( &amp;sa, &amp;sa_old ) &lt; 0 ) {
		printf( &quot;failed to install alt-stack!\n&quot; );
		exit(0);
}

/* Step 2 - setup a sighandler and specify we want it delivered
	 * on the alternate stack */
	act.sa_handler =3D handler;
	act.sa_flags =3D SA_STACK;

#if 0
	syscall (SYS_sigaction, SIGSEGV, &amp;act, NULL);
#else
	sigaction( SIGSEGV, &amp;act, 0);
#endif=09

/* Step 3 - Generate a stack-overflow with recursion.
     * Without the sigaltstack you will not handle the SIGSEGV
	 * because there will be no more space left on the processes
	 * main stack for the call.
     * With the patch, you will catch it correctly! Wheee!!=20
	 */

	GET_STACK( ss_sp );
	printf( &quot;main stack pointer =3D %p\n&quot;, ss_sp );

	recurse();
}

--=-Y5aylY+PVe/IKCnvIfnW--



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="006540.html">[Mono-list] bootstrapping System.dll
</A></li>
	<LI> Next message: <A HREF="006541.html">[Mono-list] catching stack overflow signals
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6538">[ date ]</a>
              <a href="thread.html#6538">[ thread ]</a>
              <a href="subject.html#6538">[ subject ]</a>
              <a href="author.html#6538">[ author ]</a>
         </LI>
       </UL>
</body></html>
