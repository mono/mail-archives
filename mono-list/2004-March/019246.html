<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] General .NET Q
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="019245.html">
   <LINK REL="Next"  HREF="019252.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] General .NET Q
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] General .NET Q">jonpryor@vt.edu
       </A><BR>
    <I>Wed, 24 Mar 2004 22:15:21 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="019245.html">[Mono-list] General .NET Q
</A></li>
        <LI> Next message: <A HREF="019252.html">[Mono-list] General .NET Q
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19246">[ date ]</a>
              <a href="thread.html#19246">[ thread ]</a>
              <a href="subject.html#19246">[ subject ]</a>
              <a href="author.html#19246">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Below...

On Wed, 2004-03-24 at 21:05, Shawn Vose wrote:
&gt;<i> Does anyone know if the following is possible:
</I>&gt;<i> 
</I>&gt;<i> Taking a snippet of .NET c# code, maybe a function, and storing it in a
</I>&gt;<i> mysql db
</I>&gt;<i> 
</I>&gt;<i> to be later called by another piece of code and executed?
</I>&gt;<i> 
</I>&gt;<i> I was asked this question by a client and I dont have the slightest clue
</I>&gt;<i> on how to answer this. My initial answer is no because it would have to
</I>&gt;<i> be compiled into the calling class; however, I am thinking that
</I>&gt;<i> system.reflection would be able to help me.
</I>
Is it possible?  Yes.  Will System.Reflection do it?  It depends.  It
can't do it alone, though.

The easiest thing to do would be to:
1.  Define an interface
2.  Use System.CodeDom to (a) generate skeleton C# code, (b) include the
    code from the database into the CodeDom code, and (c) compile the
    code into an assembly.  The CodeDom code should implement the 
    interface defined in (1).
3.  Load the assembly at runtime
4.  Instantiate the type from the assembly at runtime, through the 
    numerous mechanisms .NET provides (Activator.CreateInstance, etc.)
5.  Cast the type created in (4) to the interface defined in (1)
6.  Invoke the code via the interface method.

A Variation would be to use a delegate instead of the interface.

A pitfall with this framework is that all methods defined in the
database must conform to a single interface, so you couldn't have
methods with different argument lists and return types defined this way.

To work around that, you could use System.Reflection.MethodInfo, but
this complicates your client code as you need not only need to know what
function to call, but also what arguments to provide it, what it
returns, etc.  This can be done, it's just not as simple or as fast as
the above solution.

(Regarding performance, CodeDom generation will be slow, but it can't be
avoided.  Method invocation also can't be avoided, but
delegate/interface invocation is *much* faster than MethodInfo.Invoke,
so if this code will be invoked frequently, a well-defined
delegate/interface would be preferred.)

 - Jon



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="019245.html">[Mono-list] General .NET Q
</A></li>
	<LI> Next message: <A HREF="019252.html">[Mono-list] General .NET Q
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19246">[ date ]</a>
              <a href="thread.html#19246">[ thread ]</a>
              <a href="subject.html#19246">[ subject ]</a>
              <a href="author.html#19246">[ author ]</a>
         </LI>
       </UL>
</body></html>
