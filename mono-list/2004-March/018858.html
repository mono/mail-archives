<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Mono Evangelism
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="018776.html">
   <LINK REL="Next"  HREF="018777.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Mono Evangelism
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="[Mono-list] Mono Evangelism">miguel@ximian.com
       </A><BR>
    <I>Wed, 10 Mar 2004 10:12:13 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="018776.html">[Mono-list] Mono Evangelism
</A></li>
        <LI> Next message: <A HREF="018777.html">[Mono-list] Mono Evangelism
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18858">[ date ]</a>
              <a href="thread.html#18858">[ thread ]</a>
              <a href="subject.html#18858">[ subject ]</a>
              <a href="author.html#18858">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

&gt;<i> &gt;From the article:
</I>&gt;<i> 
</I>&gt;<i> &quot;Performance . This is one aspect where .NET shines and Java wimps.&quot;
</I>&gt;<i> 
</I>&gt;<i> Is this true?  I have understood the opposite, but things might have changed.
</I>
More work has gone into fine-tuning Java, but it seems that this work
was required due to some features in the language.

The ones that come to mind are:

	* Optimization of virtual calls: the Java JITs try to decide if
	  a class is terminal or not to replace a virtual call to a
	  method with a regular call.  

	  Although this is in general a good idea, it is very complex to
	  implement, since it means that you must re-JIT the code if a
	  new class is loaded that breaks the assumption that a class is
	  not inherited.  This means stopping all running threads in a
	  safe point, storing their state (possible register values, map
	  the stack state), recompile any affected code, and resume the
	  execution into the new JITed classes.

	  Very hard code, a bit of a performance problem, and means that
	  you must keep more data structures alive during the program 
	  execution.

	  Although this optimization would be nice in .NET as well, it
	  is not as important to do, because by default in C# methods
	  are not virtual.   In Java, by default all methods are
	  virtual.

	  For an explanation of why C# did not go virtual, see:

		<A HREF="http://www.artima.com/intv/nonvirtual.html">http://www.artima.com/intv/nonvirtual.html</A>

	* Value types (structs): again, learning from one of Java's
	  limitations the .NET VM supports value types that can assist
	  enormously in performance tuning, since it can be used to 
	  avoid a lot of memory allocations when they are not required
	  (see Ben's recent blog entry for a few examples).

	* Generics: not yet in production, but the generics
	  implementation of .NET is a first class citizen, something
	  that the VM is aware of, and something that it can generate
	  special code for.

	  In the Java world, Generics are just compiler syntactic sugar
	  that is translated into slower boxing classes.

Miguel.
	
		


	

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="018776.html">[Mono-list] Mono Evangelism
</A></li>
	<LI> Next message: <A HREF="018777.html">[Mono-list] Mono Evangelism
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18858">[ date ]</a>
              <a href="thread.html#18858">[ thread ]</a>
              <a href="subject.html#18858">[ subject ]</a>
              <a href="author.html#18858">[ author ]</a>
         </LI>
       </UL>
</body></html>
