<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Accessing member objects in destructors
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="018756.html">
   <LINK REL="Next"  HREF="018757.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Accessing member objects in destructors
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] Accessing member objects in destructors">jonpryor@vt.edu
       </A><BR>
    <I>Thu, 04 Mar 2004 17:28:12 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="018756.html">[Mono-list] Accessing member objects in destructors
</A></li>
        <LI> Next message: <A HREF="018757.html">[Mono-list] Missing classes in gtk-sharp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18766">[ date ]</a>
              <a href="thread.html#18766">[ thread ]</a>
              <a href="subject.html#18766">[ subject ]</a>
              <a href="author.html#18766">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Below...

On Thu, 2004-03-04 at 15:01, Uppenborn, Jason wrote:
&lt;snip/&gt;
&gt;<i> For a *class* destructor, I would say that accessing methods of member
</I>&gt;<i> objects would be correct because, AFAIK, as there isn't any other
</I>&gt;<i> point at which the class is told to release it's resources.
</I>
What, pray tell, is a class destructor, as opposed to an object
destructor?  The destructor syntax is used to implement the class
finalizer, which is very different from a C++ destructor.  The finalizer
overrides System.Object.Finalize, and is thus a method, and only applies
to instances of a class, not the class itself.  I'm not sure what a
class destructor would be.  I can imagine it would be something called
when the class is unloaded, in which case listening to the
AppDomain.Unload event is the nearest equivalent...

&gt;<i> For an *object* destructor, I would say that accessing methods of
</I>&gt;<i> member objects is incorrect: implement IDisposable instead. As I
</I>&gt;<i> understand it, disposal happens as requested or when an object is made
</I>&gt;<i> available for garbage collection, whereas destruction is done whenever
</I>&gt;<i> the garbage collector decides to get around to it. When destruction
</I>&gt;<i> happens, you have no guarantee that any of your references to member
</I>&gt;<i> objects are still valid.
</I>&gt;<i> 
</I>&gt;<i> I'm sure someone will correct me if I'm wrong, but for now that's my
</I>&gt;<i> two cents.
</I>
Here's the correction: System.Object.Finalize is called when the object
is collected by the Garbage Collector.  You should NEVER access member
objects from your finalizer, as those members may have already had their
Finalize methods called, though memory may not have been reclaimed yet.

.NET's GC does NO ordering of object finalization, so it's quite
possible for your members to be finalized before you are.

Exception: Unmanaged resources.  The GC doesn't know anything about
them, so it's your responsibility to deal with these resources.

Exception 2: You really know what you're doing, or you're part of the
runtime infrastructure itself, and make sure that all objects involved
can have their Finalize (or Dispose) methods called *safely* multiple
times.  One example I heard about was .NET's System.Threading.Thread
finalizer, which needs to make sure it doesn't finalize the Finalizer
thread. :-)

This is why the typical IDisposable implementation only accesses members
when Dispose was explicitly called.  When the finalizer executes, nested
members aren't accessed.  For example:

	class Test : IDisposable {
		IDisposable nested;

		public void Dispose ()
		{
			Dispose (true);
		}

		~Test ()
		{
			Dispose (false);
		}

		protected virtual void Dispose (bool disposing)
		{
			if (disposing) {
				// safe to access members
				if (nested != null)
					nested.Dispose ();
			}
			// Always deal with unmanaged members here.
		}
	}

 - Jon



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="018756.html">[Mono-list] Accessing member objects in destructors
</A></li>
	<LI> Next message: <A HREF="018757.html">[Mono-list] Missing classes in gtk-sharp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18766">[ date ]</a>
              <a href="thread.html#18766">[ thread ]</a>
              <a href="subject.html#18766">[ subject ]</a>
              <a href="author.html#18766">[ author ]</a>
         </LI>
       </UL>
</body></html>
