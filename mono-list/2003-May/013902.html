<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Making a ruby.net compiler
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="013896.html">
   <LINK REL="Next"  HREF="013824.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Making a ruby.net compiler
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="[Mono-list] Making a ruby.net compiler">miguel@ximian.com
       </A><BR>
    <I>10 May 2003 20:47:20 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="013896.html">[Mono-list] Making a ruby.net compiler
</A></li>
        <LI> Next message: <A HREF="013824.html">[Mono-list] Making a ruby.net compiler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13902">[ date ]</a>
              <a href="thread.html#13902">[ thread ]</a>
              <a href="subject.html#13902">[ subject ]</a>
              <a href="author.html#13902">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hello,

    I pretty much agree with Paolo's analysis.  I want to add a few
comments for the general readership.

&gt;<i> So, you see that while the register machine design reduces the dispatch
</I>&gt;<i> overhead vs a stack machine _interpreter_, the actual implementation has
</I>
    An interesting point of the design of the CLI is that it is an
encoding system for an intermediate language.  In the &quot;real&quot; language,
you have operations like:

	temp = b + c
	store temp, local

    Which corresponds roughly to:

	ldloc b
	ldloc c
	add
	stloc local

    That language maps into a stack machine easily, as you have pointed
out in your message.   But the bigger mistake is assuming that the
optimal way of executing the above is to interpret &quot;push-local b&quot;,
&quot;push-local c&quot;, &quot;add two operands on stack&quot;, &quot;store stack to local&quot;.

    The CIL stream should be decoded, not only from its bytecode
representation, but into its higher level meaning, so that the
interpreter does not cope with that, but with the higher order
constructs, as the ones illustrated before.

    For instance, Mono and goes through a process of recreating this
meaning in the method_to_ir() process.   At some point Dietmar wrote a
set of BURG rules for the *interpreter*.  Our interpreter was quite a
bit faster with this support, as it did not have to emulate a stack
machine, but rather had a list of higher-level instructions to execute. 
    Such an approach could be used by another virtual machine.

Miguel

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="013896.html">[Mono-list] Making a ruby.net compiler
</A></li>
	<LI> Next message: <A HREF="013824.html">[Mono-list] Making a ruby.net compiler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13902">[ date ]</a>
              <a href="thread.html#13902">[ thread ]</a>
              <a href="subject.html#13902">[ subject ]</a>
              <a href="author.html#13902">[ author ]</a>
         </LI>
       </UL>
</body></html>
