<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Making a ruby.net compiler
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jaroslaw.kowalski%40atm.com.pl">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="013914.html">
   <LINK REL="Next"  HREF="013917.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Making a ruby.net compiler
   </H1>
    <B>Jaroslaw Kowalski
    </B> 
    <A HREF="mailto:jaroslaw.kowalski%40atm.com.pl"
       TITLE="[Mono-list] Making a ruby.net compiler">jaroslaw.kowalski@atm.com.pl
       </A><BR>
    <I>Mon, 12 May 2003 08:55:20 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="013914.html">[Mono-list] Making a ruby.net compiler
</A></li>
        <LI> Next message: <A HREF="013917.html">[Mono-list] Making a ruby.net compiler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13916">[ date ]</a>
              <a href="thread.html#13916">[ thread ]</a>
              <a href="subject.html#13916">[ subject ]</a>
              <a href="author.html#13916">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi!

Some thoughts about using lowest bits of a pointer to store some flags about
object type. I'm not sure if this is valid for this case (I'm not very good
in functional languages)

1. It makes your pointers unaligned, which I believe to be MUCH worse,
because it involves heavy penalty cycles in most current CPUs and is even
disallowed on some RISCs

2. If you want to align your pointers before each dereference - you can do
it but you have to add some additional instructions to the JIT output, which
would reduce the benefit of using bit flags

3. It also (may or may not) make your memory allocator be sub-optimal
because you have to deal with an internal fragmentation (you either allocate
contiguous block and discard the beginning of it or allocate contiguous one
and mangle the pointer, but you have to make a decision which takes time)

I wonder if you could have separate heaps (perhaps starting at some
well-known virtual memory addresses, like

0x40000000 - 0x7fffffff - heap for normal objects
0x80000000 - 0x8fffffff - heap for A objects
0x90000000 - 0x9fffffff - heap for B objects

This has an interesting property of being able to make decisions by checking
some pointer bits, keeps your pointers aligned and may even allow for the
jump table approach.

Just an idea.

Jarek

----- Original Message -----
From: &quot;Michal Moskal&quot; &lt;<A HREF="mailto:malekith@pld-linux.org">malekith@pld-linux.org</A>&gt;
To: &quot;Miguel de Icaza&quot; &lt;<A HREF="mailto:miguel@ximian.com">miguel@ximian.com</A>&gt;
Cc: &quot;Fergus Henderson&quot; &lt;<A HREF="mailto:fjh@cs.mu.OZ.AU">fjh@cs.mu.OZ.AU</A>&gt;; &quot;Erik B?gfors&quot; &lt;<A HREF="mailto:erik@bagfors.nu">erik@bagfors.nu</A>&gt;;
&quot;sho tamashii&quot; &lt;<A HREF="mailto:sh0ii@yahoo.com">sh0ii@yahoo.com</A>&gt;; &quot;Mono List&quot; &lt;<A HREF="mailto:mono-list@ximian.com">mono-list@ximian.com</A>&gt;
Sent: Sunday, May 11, 2003 7:37 PM
Subject: Re: [Mono-list] Making a ruby.net compiler


&gt;<i> [snip]
</I>&gt;<i>
</I>&gt;<i> Few more thoughts.
</I>&gt;<i>
</I>&gt;<i> 1. why should we optimize (special-case) the particular get_type call?
</I>&gt;<i>
</I>&gt;<i> Because it's *very* important in any language that has some kinds of
</I>&gt;<i> variant (discriminating union) data structure, which would be compiled
</I>&gt;<i> to subclasses. For example list is defined in ML:
</I>&gt;<i>
</I>&gt;<i> type 'a list = Cons of 'a * 'a list | Nil
</I>&gt;<i>
</I>&gt;<i> Which would be compiled to following Generic C#:
</I>&gt;<i>
</I>&gt;<i> class list&lt;A&gt; {}
</I>&gt;<i> sealed class Cons&lt;A&gt; : list&lt;A&gt; {
</I>&gt;<i>   A field_1;
</I>&gt;<i>   list&lt;A&gt; field_2;
</I>&gt;<i> }
</I>&gt;<i> sealed class Nil&lt;A&gt; : list&lt;A&gt; {}
</I>&gt;<i>
</I>&gt;<i> And functions like (warning: this isn't optimal version :-)
</I>&gt;<i>
</I>&gt;<i> ML:
</I>&gt;<i>
</I>&gt;<i> let length = function
</I>&gt;<i>     Cons (x, xs) -&gt; 1 + length (xs)
</I>&gt;<i>   | Nil -&gt; 0
</I>&gt;<i>
</I>&gt;<i> C#:
</I>&gt;<i>
</I>&gt;<i> int length&lt;A&gt;(list&lt;A&gt; x)
</I>&gt;<i> {
</I>&gt;<i>   if (x is Cons&lt;A&gt;) { // (*)
</I>&gt;<i>     return 1 + length(((Cons&lt;A&gt;)x).field_2);
</I>&gt;<i>   } else {
</I>&gt;<i>     return 0;
</I>&gt;<i>   }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Here another issue should be raised, wrt Generic C#. It should be
</I>&gt;<i> possible to write something like &quot;if (x is Cons) {&quot; at (*), because
</I>&gt;<i> there is no need to check if type parameter A is the same.
</I>&gt;<i>
</I>&gt;<i> But this is just a comment.
</I>&gt;<i>
</I>&gt;<i> 2. bit patterns Fergus Henderson was talking about could be used to use
</I>&gt;<i>    jump table in pattern matching. For example:
</I>&gt;<i>
</I>&gt;<i> type t =
</I>&gt;<i>     Case1 of int
</I>&gt;<i>   | Case2 of ...
</I>&gt;<i>   | Case3 ...
</I>&gt;<i>   ....
</I>&gt;<i>   | Case23
</I>&gt;<i>
</I>&gt;<i> and then you have function:
</I>&gt;<i>
</I>&gt;<i> let f = function
</I>&gt;<i>     Case1 (i) -&gt; ...
</I>&gt;<i>   | Case2 (...) -&gt; ...
</I>&gt;<i>   ...
</I>&gt;<i>   | Case23 -&gt; ...
</I>&gt;<i>
</I>&gt;<i> you would need to have 23 successive equality tests. It would be better
</I>&gt;<i> to use jump table, but I'm not quite sure if it's at all possible in
</I>&gt;<i> CIL. Anyway it can be done by having compiler-generated &quot;int get_tag()&quot;
</I>&gt;<i> method in each of CaseN classes.
</I>&gt;<i>
</I>&gt;<i> Anyway this jump-table stuff doesn't present that-big performance hit
</I>&gt;<i> as calling runtime function for each typeof.
</I>&gt;<i>
</I>&gt;<i> 3. if you are familiar with ILX, you should remember .classunion type
</I>&gt;<i>    there, that just did discriminating unions.
</I>&gt;<i>
</I>&gt;<i> But I believe it isn't very good idea to put it in Mono, since it's
</I>&gt;<i> very limited (namely it seems to fit OCaml variants, but not SML
</I>&gt;<i> variants (things after of can have names), or OCaml polymorphic
</I>&gt;<i> variants (one polymorphic variant can be in several types)).
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> : Michal Moskal :: <A HREF="http://www.kernel.pl/~malekith">http://www.kernel.pl/~malekith</A> : GCS {C,UL}++++$ a? !tv
</I>&gt;<i> : PLD Linux ::::::::: Wroclaw University, CS Dept : {E-,w}-- {b++,e}&gt;+++ h
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@lists.ximian.com">Mono-list@lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i>
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="013914.html">[Mono-list] Making a ruby.net compiler
</A></li>
	<LI> Next message: <A HREF="013917.html">[Mono-list] Making a ruby.net compiler
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13916">[ date ]</a>
              <a href="thread.html#13916">[ thread ]</a>
              <a href="subject.html#13916">[ subject ]</a>
              <a href="author.html#13916">[ author ]</a>
         </LI>
       </UL>
</body></html>
