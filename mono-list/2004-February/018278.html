<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] unicode trouble
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="018276.html">
   <LINK REL="Next"  HREF="018247.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] unicode trouble
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] unicode trouble">jonpryor@vt.edu
       </A><BR>
    <I>Mon, 09 Feb 2004 20:48:07 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="018276.html">[Mono-list] unicode trouble
</A></li>
        <LI> Next message: <A HREF="018247.html">[Mono-list] IMessageFilter Exists?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18278">[ date ]</a>
              <a href="thread.html#18278">[ thread ]</a>
              <a href="subject.html#18278">[ subject ]</a>
              <a href="author.html#18278">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, 2004-02-09 at 19:21, Marcus wrote:
&gt;<i> As I recall, when the CM3 Modula-3 compiler added support for unicode, they 
</I>&gt;<i> used a hybrid scheme where TEXTs (their equivalent of System.String) can 
</I>&gt;<i> contain both 8-bit and 16-bit &quot;chars&quot;. So only the portions of the string 
</I>&gt;<i> that require more than 8 bits use it. Something similar could be done with 
</I>&gt;<i> 32-bit characters in some future library is compactness were a concern.
</I>
In a fashion, that's what UTF-16 does: most characters are 16-bit, but
when a character doesn't fit within 16-bits a Unicode Surrogate Pair (or
Combining Char, or...) is used, which causes the next character to be
combined in some fashion with the current character.

The downside to this approach is user-complexity: you can't just iterate
over all the literal characters in the string, as there isn't a
one-to-one mapping between the literal characters (16-bit char) and the
logical characters you actually care about (UCS-32 code-point).  The
previously mentioned System.Globalization.TextElementEnumerator is used
to map between the physical mapping (char[] array) and the logical
(UCS-32 code point).

&gt;<i> By the way, how much performance penality is there for accessing a single 8 
</I>&gt;<i> one modern 32-bit processors?
</I>
I don't understand this question.  A &quot;single 8 one modern 32-bit
processors&quot;?  I can only assume that you're asking about the performance
penalty of accessing memory that isn't properly aligned (according to
its underlying type), in which case it depends on the processor: x86
processors will access it, but at a slower rate, and some RISC
processors (Sparc, Alpha, etc.) will refuse to load memory that isn't
properly aligned, generating a processor exception, which (on linux) is
trapped by the OS, which re-maps (copies) the memory to be properly
aligned, and then the memory is accessed properly.

Note that this doesn't cause 8-bit characters to be horribly slow; it
causes accessing a 32-bit quantity (for example) that isn't aligned on a
32-bit address boundary to perform slowly, if at all.  For example, if
the following structure were packed:

	// GNU C
	struct foo {
		char c;		// offset: 0
		int32_t	i;	// offset: 1
	} __attribute__((packed));

	foo f;
	f.i = 42;

The above structure is liable to generate bus errors under some
operating systems, such as SunOS on Sparc, as foo::i isn't
integer-aligned and the processor raises an exception trying to do the
conversion.  The &quot;portable&quot; equivalent would be:

	foo f;
	int32_t n = 42;
	memcpy (&amp;f.i, &amp;n, sizeof(n));

Just a minor digression...

 - Jon

&gt;<i> On Monday 09 February 2004 7:16 am, Jonathan Pryor wrote:
</I>&gt;<i> 
</I>&gt;<i> &gt; I imagine it's due to a memory trade-off.  The easiest way for the
</I>&gt;<i> &gt; programmer do deal with things would be to just use UCS-32 for all
</I>&gt;<i> &gt; Unicode strings.  You wouldn't have to worry about code pairs or
</I>&gt;<i> &gt; anything else like that.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; It would also mean that all strings would require 32-bits for each
</I>&gt;<i> &gt; character, which would eat up *lots* of memory for all strings.  The
</I>&gt;<i> &gt; most common code points -- US, Europe, Asia -- all easily fit within
</I>&gt;<i> &gt; 16-bits, *by design*. 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@lists.ximian.com">Mono-list@lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="018276.html">[Mono-list] unicode trouble
</A></li>
	<LI> Next message: <A HREF="018247.html">[Mono-list] IMessageFilter Exists?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18278">[ date ]</a>
              <a href="thread.html#18278">[ thread ]</a>
              <a href="subject.html#18278">[ subject ]</a>
              <a href="author.html#18278">[ author ]</a>
         </LI>
       </UL>
</body></html>
