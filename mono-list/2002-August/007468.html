<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Announce: A .NET assembly -&gt; native code
 generation tool (ala ngen for MONO)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="007463.html">
   <LINK REL="Next"  HREF="007469.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Announce: A .NET assembly -&gt; native code
 generation tool (ala ngen for MONO)
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="[Mono-list] Announce: A .NET assembly -&gt; native code
 generation tool (ala ngen for MONO)">miguel@ximian.com
       </A><BR>
    <I>01 Aug 2002 00:42:50 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="007463.html">[Mono-list] Announce: A .NET assembly -&gt; native code generation tool (ala ngen for MONO)
</A></li>
        <LI> Next message: <A HREF="007469.html">[Mono-list] Announce: A .NET assembly -&gt; native code generation
 tool (ala ngen for MONO)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7468">[ date ]</a>
              <a href="thread.html#7468">[ thread ]</a>
              <a href="subject.html#7468">[ subject ]</a>
              <a href="author.html#7468">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> This approach is what MS did.  This approach sucks.
</I>&gt;<i> You just won't get good performance that way.
</I>&gt;<i> 
</I>&gt;<i> An ahead-of-time compiler can afford to spend a lot more time compiling,
</I>&gt;<i> and as a result it can use much more sophisticated optimizations than
</I>&gt;<i> a JIT compiler can.
</I>
When we say `Turn on all the optimizations' it means that you can turn
all of the expensive optimizations on.  There are many things that we
can not do at JIT time that we can do effectively if we have a lot of
time to spare.

This is for instance what the Intel ORP JIT engine does: it does a fast
JIT task that inserts profiling information into the code, and if those
trigger a threshold, then the routine is re-JITed with the slow
optimizing JIT engine.

&gt;<i> Note also that GCC's optimizer has already been ported to a lot more
</I>&gt;<i> architectures than the mono JIT has been.  For architectures where
</I>&gt;<i> the choice is to use an interpreter or an ahead-of-time compiler,
</I>&gt;<i> the ahead-of-time compiler should give a very significant speedup.
</I>
Sure, and we are still evaluating the options, but we are going to
improve the JIT engine.

A large number of optimizations is performed on the intermediate
representation which means that every target will benefit from it, the
piece that is architecture dependent is the piece that actually matches
a IR tree to native instructions. 

For instance, constant folding, propagation and inlining in the Mono JIT
are all done on the intermediate representation.  CSE, GCSE, invariant
code motion and loop optimizations should all be performed on this IR,
and not in an architecture specific one.

Anyways, not advocating either case at this point, we will see how
things mature, and we are helping and keeping a close look at Zoltan's
approach.  Maybe it will become the default, but lets keep a scientific
mindset for now.

Miguel.


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="007463.html">[Mono-list] Announce: A .NET assembly -&gt; native code generation tool (ala ngen for MONO)
</A></li>
	<LI> Next message: <A HREF="007469.html">[Mono-list] Announce: A .NET assembly -&gt; native code generation
 tool (ala ngen for MONO)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7468">[ date ]</a>
              <a href="thread.html#7468">[ thread ]</a>
              <a href="subject.html#7468">[ subject ]</a>
              <a href="author.html#7468">[ author ]</a>
         </LI>
       </UL>
</body></html>
