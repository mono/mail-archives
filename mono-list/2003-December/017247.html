<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Bug fix - 41691
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:banirban%40novell.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="017250.html">
   <LINK REL="Next"  HREF="017248.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Bug fix - 41691
   </H1>
    <B>B Anirban
    </B> 
    <A HREF="mailto:banirban%40novell.com"
       TITLE="[Mono-list] Bug fix - 41691">banirban@novell.com
       </A><BR>
    <I>Mon, 08 Dec 2003 21:30:28 -0700</I>
    <P><UL>
        <LI> Previous message: <A HREF="017250.html">[Mono-list] Web service encoding
</A></li>
        <LI> Next message: <A HREF="017248.html">[Mono-list] Bug fix - 41691
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17247">[ date ]</a>
              <a href="thread.html#17247">[ thread ]</a>
              <a href="subject.html#17247">[ subject ]</a>
              <a href="author.html#17247">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,
I am posting here my fixes for bug 41691.
For this I felt a need for changing the check_type method (in
Binder.cs) for extracting  better match. Hence I created here a
overloaded version of check_type method.
Also I overloaded the SelectMethod function for handling named
arguments.
I am attaching the test cases for the same as well. 
Looking forward for your suggestion on this implementation.
Regards.
Anirban.

===================================================================
RCS file: /mono/mcs/class/corlib/System/MonoType.cs,v
retrieving revision 1.49
diff -u -r1.49 MonoType.cs
--- class/corlib/System/MonoType.cs	1 Aug 2003 14:59:42
-0000	1.49
+++ class/corlib/System/MonoType.cs	28 Nov 2003 21:02:17 -0000
@@ -299,7 +299,7 @@
 			if ((invokeAttr &amp; BindingFlags.SetField) != 0 &amp;&amp;
((args == null) || args.Length != 1))
 				throw new ArgumentException
(&quot;invokeAttr&quot;);
 			if ((namedParameters != null) &amp;&amp; ((args == null)
||<i> args.Length &lt; namedParameters.Length))
</I>-				throw new ArgumentException
(&quot;namedParameters&quot;);
+				throw new ArgumentException
(&quot;namedParameters cannot be more than named arguments in number&quot;);
 
 			/* set some defaults if none are provided :-(
*/
 			if ((invokeAttr &amp;
(BindingFlags.Public|BindingFlags.NonPublic)) == 0)
Index: class/corlib/System/TypeCode.cs
===================================================================
RCS file: /mono/mcs/class/corlib/System.Reflection/Binder.cs,v
retrieving revision 1.11
diff -u -r1.11 Binder.cs
--- class/corlib/System.Reflection/Binder.cs	11 May 2003 05:51:07
-0000	1.11
+++ class/corlib/System.Reflection/Binder.cs	28 Nov 2003 21:02:19
-0000
@@ -83,8 +83,14 @@
 							types [i] = args
[i].GetType ();
 					}
 				}
-				MethodBase selected = SelectMethod
(bindingAttr, match, types, modifiers);
+				
 				state = null;
+				MethodBase selected = null;
+				if(names == null)
+					selected = SelectMethod
(bindingAttr, match, types, modifiers);
+				else
+					selected = SelectMethod
(bindingAttr, match, ref args, modifiers, names);
+
 				return selected;
 			}
 

@@ -221,7 +234,214 @@
 					return to.IsAssignableFrom
(from);
 				}
 			}
+			
 
+			private static bool check_type (Type from, Type
to, out int matchVal) {
+				if (from == to){
+					matchVal = 1;
+					return true;
+				}
+				TypeCode fromt = Type.GetTypeCode
(from);
+				TypeCode tot = Type.GetTypeCode (to);
+				matchVal = -1;
+
+				switch (fromt) {
+				case TypeCode.Char:
+					switch (tot) {
+					case TypeCode.UInt16:
+						matchVal = 2;
+						return true;
+					case TypeCode.UInt32:
+						matchVal = 3;
+						return true;
+					case TypeCode.Int32:
+						matchVal = 4;
+						return true;
+					case TypeCode.UInt64:
+						matchVal = 5;
+						return true;
+					case TypeCode.Int64:
+						matchVal = 6;
+						return true;
+					case TypeCode.Single:
+						matchVal = 7;
+						return true;
+					case TypeCode.Double:
+						matchVal = 8;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object);
+				case TypeCode.Byte:
+					switch (tot) {
+					case TypeCode.Char:
+						matchVal = 2;
+						return true;
+					case TypeCode.UInt16:
+						matchVal = 3;
+						return true;
+					case TypeCode.Int16:
+						matchVal = 4;
+						return true;
+					case TypeCode.UInt32:
+						matchVal = 5;
+						return true;
+					case TypeCode.Int32:
+						matchVal = 6;
+						return true;
+					case TypeCode.UInt64:
+						matchVal = 7;
+						return true;
+					case TypeCode.Int64:
+						matchVal = 8;
+						return true;
+					case TypeCode.Single:
+						matchVal = 9;
+						return true;
+					case TypeCode.Double:
+						matchVal = 10;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object) ||
(from.IsEnum &amp;&amp; to == typeof (Enum));
+				case TypeCode.SByte:
+					switch (tot) {
+					case TypeCode.Int16:
+						matchVal = 2;
+						return true;
+					case TypeCode.Int32:
+						matchVal = 3;
+						return true;
+					case TypeCode.Int64:
+						matchVal = 4;
+						return true;
+					case TypeCode.Single:
+						matchVal = 5;
+						return true;
+					case TypeCode.Double:
+						matchVal = 6;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object) ||
(from.IsEnum &amp;&amp; to == typeof (Enum));
+				case TypeCode.UInt16:
+					switch (tot) {
+					case TypeCode.UInt32:
+						matchVal = 2;
+						return true;
+					case TypeCode.Int32:
+						matchVal = 3;
+						return true;
+					case TypeCode.UInt64:
+						matchVal = 4;
+						return true;
+					case TypeCode.Int64:
+						matchVal = 5;
+						return true;
+					case TypeCode.Single:
+						matchVal = 6;
+						return true;
+					case TypeCode.Double:
+						matchVal = 7;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object) ||
(from.IsEnum &amp;&amp; to == typeof (Enum));
+				case TypeCode.Int16:
+					switch (tot) {
+					case TypeCode.Int32:
+						matchVal = 2;
+						return true;
+					case TypeCode.Int64:
+						matchVal = 3;
+						return true;
+					case TypeCode.Single:
+						matchVal = 4;
+						return true;
+					case TypeCode.Double:
+						matchVal = 5;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object) ||
(from.IsEnum &amp;&amp; to == typeof (Enum));
+				case TypeCode.UInt32:
+					switch (tot) {
+					case TypeCode.UInt64:
+						matchVal = 2;
+						return true;
+					case TypeCode.Int64:
+						matchVal = 3;
+						return true;
+					case TypeCode.Single:
+						matchVal = 4;
+						return true;
+					case TypeCode.Double:
+						matchVal = 5;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object) ||
(from.IsEnum &amp;&amp; to == typeof (Enum));
+				case TypeCode.Int32:
+					switch (tot) {
+					case TypeCode.Int64:
+						matchVal = 2;
+						return true;
+					case TypeCode.Single:
+						matchVal = 3;
+						return true;
+					case TypeCode.Double:
+						matchVal = 4;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object) ||
(from.IsEnum &amp;&amp; to == typeof (Enum));
+				case TypeCode.UInt64:
+					switch (tot) {
+					case TypeCode.Int64:
+						matchVal = 2;
+						return true;
+					case TypeCode.Single:
+						matchVal = 3;
+						return true;
+					case TypeCode.Double:
+						matchVal = 4;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object) ||
(from.IsEnum &amp;&amp; to == typeof (Enum));
+
+				case TypeCode.Int64:
+					switch (tot) {
+					case TypeCode.UInt64:
+						matchVal = 2;
+						return true;
+					case TypeCode.Single:
+						matchVal = 3;
+						return true;
+					case TypeCode.Double:
+						matchVal = 4;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object) ||
(from.IsEnum &amp;&amp; to == typeof (Enum));
+				case TypeCode.Single:
+					if(tot ==  TypeCode.Double){
+						matchVal = 2;
+						return true;
+					}
+					matchVal = 50;
+					return to == typeof (object);
+				default:
+					/* TODO: handle valuetype -&gt;
byref */
+					if (to == typeof (object) &amp;&amp;
from.IsValueType){
+						matchVal = 50;
+						return true;
+					}
+					
+					matchVal = 100;
+					return to.IsAssignableFrom
(from);
+				}
+			}
 			private static bool check_arguments (Type[]
types, ParameterInfo[] args) {
 				for (int i = 0; i &lt; types.Length; ++i)
{
 					if (!check_type (types [i], args
[i].ParameterType))
@@ -229,6 +449,189 @@
 				}
 				return true;
 			}
+
+
+		private MethodBase SelectMethod (BindingFlags
bindingAttr,
+                        MethodBase[] match, ref object[] args,
ParameterModifier[] modifiers,
+                        string[] names)
+                {
+	                        int found = 0;
+	                        MethodBase m = null;
+	                        MethodBase tempM = null;
+				int matchVal = 0, totalMatchVal = 0,
utotalMatchVal = 0;
+				int selectedMethod = -1;
+				int NamedParamBestMatch = -1;
+				int UnnamedParamBestMatch = -1;
+				int [] matchSeq = new int
[names.Length];
+				int [] bestMatchSeq = new int
[names.Length];
+				int uNameParamLen = args.Length -
names.Length;
+				int [] ubestMatchSeq = null;
+				int [] umatchSeq = null;
+				if(uNameParamLen &gt; 0){
+					ubestMatchSeq = new int
[uNameParamLen];
+					umatchSeq = new int
[uNameParamLen];
+				}
+				ParameterInfo[] param = null;
+
+				// go thru all the methods 
+                                for (int mi = 0; mi &lt; match.Length;
++mi) {
+                                        m = match [mi];
+                                        param = m.GetParameters ();
+					// match the number of
prameters
+                                        if (args.Length !=
param.Length)
+                                                continue;
+					// for named parameters the
matching 
+					// param name is major criteria
+					// the name has to be matched
+					int j, k;
+					totalMatchVal = 0;
+					utotalMatchVal = 0;
+					found = 0;
+                                        for(j = 0; j&lt;names.Length;
j++){
+                                                for(k = 0;
k&lt;param.Length; k++){
+                                                       
if(param[k].Name == names[j])
+                                                               
break;
+						}
+						// if even one param
name doesn't match
+						// don't consider the
method
+                                                if(k &gt;=
param.Length){
+							found = -1;
+                                                        break;
+						}
+                        
+						// if all the names
matches
+						// start checking types
for named 
+						// parameters
+						matchVal = 0;
+						if (check_type (args
[j].GetType (), param[k].ParameterType, out matchVal)){
+							matchSeq [j] =
matchVal;
+                                                	totalMatchVal =
totalMatchVal + matchVal;
+						}
+                                                else{
+							found = -1;
+                                                        break;
+						}
+                                        }
+
+					//if name or type desn't not
match pickup next method
+					if(found == -1)
+						continue;
+
+					// check if there are any
unnamed urguments
+					if(names.Length &lt; args.Length){
+		                        	ParameterInfo[] parms =
param;
+	        	                	int currentPos =
names.Length;
+	        	                	for(int i=0, l=0;
i&lt;parms.Length; i++){
+	        	                       	 	for(j = 0;
j&lt;names.Length; j++){
+	        	                               
	if(parms[i].Name == names[j])
+	        	                                       
	break;
+							}
+							// chech types
for unnamed params
+	        	                        	if((j &gt;=
names.Length) &amp;&amp; (args.Length &gt; currentPos)){
+
+							if(check_type
(args[currentPos].GetType(), parms[i].ParameterType, out matchVal)){
+									umatchSeq
[l++] = matchVal;
+	        	                                               
utotalMatchVal = utotalMatchVal + matchVal;
+	        	                                               
currentPos++;
+                	                        		}
+                	                        		else{
+									found
= -1;
+                	                               
		break;
+								}
+							}
+	        	                	}
+						
+					}
+					//if types not matched pickup
next method
+					if(found == -1)
+						continue;
+
+					// lower the value, better the
match
+					// hence we will keep only the
least totalMatchvalue 
+					// the preference goes to named
params
+					// first the named prams gets
chance to get the 
+					// better match then comes
unnamed params
+					if (NamedParamBestMatch &gt;
totalMatchVal || NamedParamBestMatch == -1){
+						NamedParamBestMatch =
totalMatchVal;
+						UnnamedParamBestMatch =
utotalMatchVal;
+						for (int n = 0;
n&lt;names.Length; n++)
+							bestMatchSeq [n]
= matchSeq [n];
+						if(uNameParamLen &gt; 0){
+							for (int u = 0;
u&lt;uNameParamLen; u++)
+								ubestMatchSeq
[u] = umatchSeq [u];
+						}
+						selectedMethod = mi;
+					}
+
+					// if two method returns the
same value for 
+					// then match types of each
param
+					// if all the types matches
return a 
+					// AmbiguousMatchException
+					else if (NamedParamBestMatch ==
totalMatchVal){
+						bool noMatch = false;
+						int n = 0;
+						if(uNameParamLen &gt; 0) {
+							if(UnnamedParamBestMatch
== utotalMatchVal){
+								for(n =
0; n&lt;uNameParamLen; n++){
+									if(ubestMatchSeq
[n] != umatchSeq [n]){
+										noMatch
= true;
+										break;
+									}
+								}
+							}
+							else
+								noMatch
= true;
+						}	
+						if(!noMatch){
+							for(n = 0;
n&lt;names.Length; n++){
+								if(bestMatchSeq
[n] != matchSeq [n]){
+									noMatch
= true;
+									break;
+								}
+							}
+						}
+						if(!noMatch)
+							throw new
AmbiguousMatchException();
+					
+						if((uNameParamLen&gt;0) &amp;&amp;
(UnnamedParamBestMatch &gt; utotalMatchVal)){
+							UnnamedParamBestMatch
= utotalMatchVal;
+							for (n = 0;
n&lt;names.Length; n++)
+								bestMatchSeq
[n] = matchSeq [n];
+							for (int u = 0;
u&lt;uNameParamLen; u++)
+								ubestMatchSeq
[u] = umatchSeq [u];
+							selectedMethod =
mi;
+						}		
+					}
+					
+				}
+				// if no method matched
+				if(selectedMethod == -1)
+					return null;
+
+				param =
match[selectedMethod].GetParameters ();
+
+				// rearrange the argumets as per the 
+				// parameters of the qualified method
+				object[] tempArgs = new
object[args.Length];
+                        	int curPos = names.Length;
+				
+				for(int t = 0; t&lt;param.Length; t++){
+					int j;
+	                       	 	for(j = 0; j&lt;names.Length;
j++){
+	                                     	if(param[t].Name ==
names[j]){
+	                                               	tempArgs[t] =
args[j];
+	                                               	break;
+	                                       	}
+					}
+					if((j &gt;= names.Length) &amp;&amp;
(args.Length &gt; curPos)){
+		                                tempArgs[t] =
args[curPos];
+						curPos++;
+					}
+				}
+				args = tempArgs;
+	                        return match[selectedMethod];
+                	}
+		
 
 			public override MethodBase SelectMethod
(BindingFlags bindingAttr, MethodBase[] match, Type[] types,
ParameterModifier[] modifiers)
 			{




Index: class/corlib/Test/System/TypeTest.cs
===================================================================
RCS file: /mono/mcs/class/corlib/Test/System/TypeTest.cs,v
retrieving revision 1.1
diff -u -r1.1 TypeTest.cs
--- class/corlib/Test/System/TypeTest.cs	13 Jul 2003 14:29:25
-0000	1.1
+++ class/corlib/Test/System/TypeTest.cs	29 Nov 2003 11:37:56
-0000
@@ -8,8 +8,10 @@
 
 using NUnit.Framework;
 using System;
+using System.Reflection;
 using System.IO;
 
+
 namespace MonoTests.System
 {
 	class Super : ICloneable {
@@ -20,11 +22,15 @@
 	class Duper: Super {
 	}
 
+	
 	enum TheEnum { A, B, C };
 
 	[TestFixture]
 	public class TypeTest : Assertion
 	{
+		public static object [] values;
+		public static string methodId; 
+		
 		[Test]
 		public void TestIsAssignableFrom () {
 			// Simple tests for inheritance
@@ -77,6 +83,279 @@
 		public void TestIsSubclassOf () {
 			Assert (typeof (ICloneable).IsSubclassOf (typeof
(object)));
 		}
+
+		private void invokeMember(object [] argValues, string []
argNames) {
+			try {
+				values = new object[argValues.Length];
+			
+				Type t = typeof(TypeClass);
+				t.InvokeMember(&quot;checkMethod&quot;,
+					BindingFlags.InvokeMethod,
+					null,
+					null,
+					argValues, 
+					null, 
+					null,
+					argNames);
+			} catch (Exception e) {
+				throw (e);
+			}
+		}
+
+		[Test]
+		public void TestInvokeMember_Method () {
+			try{
+				object[] argValues = new object []
{&quot;aaa&quot;, &quot;bbb&quot;};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;lastName&quot;};
+				invokeMember(argValues, argNames);
+				
+				AssertEquals(&quot;#A1&quot;, methodId, &quot;m1&quot;);
+				AssertEquals(&quot;#A1&quot;,  argValues[0],
values[0]);
+				AssertEquals(&quot;#A1&quot;,  argValues[1],
values[1]);
+			}catch (Exception e){
+				Fail (&quot;Unexpected exception at #A1 &quot; +
e);
+			}
+
+			try{
+				object[] argValues = new object []
{&quot;bbb&quot;, &quot;aaa&quot;};
+				string [] argNames = new string []
{&quot;lastName&quot;, &quot;firstName&quot;};
+				invokeMember(argValues, argNames);
+				
+				AssertEquals(&quot;#A2&quot;, methodId, &quot;m1&quot;);
+				AssertEquals(&quot;#A2&quot;,  argValues[0],
values[1]);
+				AssertEquals(&quot;#A2&quot;,  argValues[1],
values[0]);
+			}catch (Exception e){
+				Fail (&quot;Unexpected exception at #A2 &quot; +
e);
+			}
+
+			try{
+				object[] argValues = new object [] {12,
&quot;bbb&quot;};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;lastName&quot;};
+				invokeMember(argValues, argNames);
+			}catch (Exception e){
+				AssertEquals(&quot;#A3&quot;,
typeof(AmbiguousMatchException), e.GetType());
+			}
+
+			try{
+				object[] argValues = new object []
{&quot;aaa&quot;, 12};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;lastName&quot;};
+				invokeMember(argValues, argNames);
+			}catch (Exception e){
+				AssertEquals(&quot;#A4&quot;,
typeof(MissingMethodException), e.GetType());
+			}
+
+			try{
+				object[] argValues = new object []
{&quot;aaa&quot;, 12};
+				string [] argNames = new string []
{&quot;firstName&quot;, 
+								&quot;lastName&quot;,
&quot;anotherName&quot;};
+				invokeMember(argValues, argNames);
+			}catch (Exception e){
+				AssertEquals(&quot;#A5&quot;,
typeof(ArgumentException), e.GetType());
+			}
+
+			try{
+				double i = 10;
+				object[] argValues = new object []
{&quot;aaa&quot;, &quot;bbb&quot;, i};
+				string [] argNames = new string []
{&quot;firstName&quot;, 
+									&quot;lastName&quot;,
										&quot;ID&quot;};
+				invokeMember(argValues, argNames);
+				
+				AssertEquals(&quot;#A6&quot;, methodId, &quot;m4&quot;);
+				AssertEquals(&quot;#A6&quot;,  argValues[0],
values[0]);
+				AssertEquals(&quot;#A6&quot;,  argValues[1],
values[1]);
+				AssertEquals(&quot;#A6&quot;,  argValues[2],
values[2]);
+			}catch (Exception e){
+				Fail (&quot;Unexpected exception at #A6 &quot; +
e);
+			}
+
+			try{
+				int i = 10;
+				object[] argValues = new object []
{&quot;aaa&quot;, &quot;bbb&quot;, i};
+				string [] argNames = new string []
{&quot;firstName&quot;, 
+									&quot;lastName&quot;,
										&quot;ID&quot;};
+				invokeMember(argValues, argNames);
+				
+				AssertEquals(&quot;#A7&quot;, methodId, &quot;m5&quot;);
+				AssertEquals(&quot;#A7&quot;,  argValues[0],
values[0]);
+				AssertEquals(&quot;#A7&quot;,  argValues[1],
values[1]);
+				AssertEquals(&quot;#A7&quot;,  argValues[2],
values[2]);
+			}catch (Exception e){
+				Fail (&quot;Unexpected exception at #A7 &quot; +
e);
+			}
+
+			// unnamed parameters
+			try{
+				int i = 10;
+				object[] argValues = new object []
{&quot;aaa&quot;, &quot;bbb&quot;, i};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;lastName&quot;};
+				invokeMember(argValues, argNames);
+				
+				AssertEquals(&quot;#A8&quot;, methodId, &quot;m5&quot;);
+				AssertEquals(&quot;#A8&quot;,  argValues[0],
values[0]);
+				AssertEquals(&quot;#A8&quot;,  argValues[1],
values[1]);
+				AssertEquals(&quot;#A8&quot;,  argValues[2],
values[2]);
+			}catch (Exception e){
+				Fail (&quot;Unexpected exception at #A8 &quot; +
e);
+			}
+
+			try{
+				Int16 i = 10;
+				object[] argValues = new object []
{&quot;aaa&quot;, i, &quot;zzz&quot;, 500};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;ID&quot;};
+				invokeMember(argValues, argNames);
+				
+				AssertEquals(&quot;#A9&quot;, methodId, &quot;m7&quot;);
+				AssertEquals(&quot;#A9&quot;,  argValues[0],
values[0]);
+				AssertEquals(&quot;#A9&quot;,  argValues[1],
values[1]);
+				AssertEquals(&quot;#A9&quot;,  argValues[2],
values[2]);
+				AssertEquals(&quot;#A9&quot;,  argValues[3],
values[3]);
+			}catch (Exception e){
+				Fail (&quot;Unexpected exception at #A9 &quot; +
e);
+			}
+
+			try{
+				short s = 500;
+				Int64 i = 10;
+				object[] argValues = new object []
{&quot;aaa&quot;, i, &quot;zzz&quot;, s};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;ID&quot;};
+				invokeMember(argValues, argNames);
+				
+				AssertEquals(&quot;#A10&quot;, methodId, &quot;m8&quot;);
+				AssertEquals(&quot;#A10&quot;,  argValues[0],
values[0]);
+				AssertEquals(&quot;#A10&quot;,  argValues[1],
values[1]);
+				AssertEquals(&quot;#A10&quot;,  argValues[2],
values[2]);
+				AssertEquals(&quot;#A10&quot;,  argValues[3],
values[3]);
+			}catch (Exception e){
+				Fail (&quot;Unexpected exception at #A10 &quot; +
e);
+			}
+			
+			try{
+				Int16 i = 10;
+				Int16 s = 500;
+				object[] argValues = new object []
{&quot;aaa&quot;, i, &quot;zzz&quot;, s};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;ID&quot;};
+				invokeMember(argValues, argNames);
+				
+				AssertEquals(&quot;#A11&quot;, methodId, &quot;m7&quot;);
+				AssertEquals(&quot;#A11&quot;,  argValues[0],
values[0]);
+				AssertEquals(&quot;#A11&quot;,  argValues[1],
values[1]);
+				AssertEquals(&quot;#A11&quot;,  argValues[2],
values[2]);
+				AssertEquals(&quot;#A11&quot;,  argValues[3],
values[3]);
+			}catch (Exception e){
+				Fail (&quot;Unexpected exception at #A11 &quot; +
e);
+			}
+
+			try{
+				object[] argValues = new object []
{&quot;aaa&quot;, 12, &quot;bbb&quot;, &quot;zzz&quot;, 20};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;ID&quot;};
+				invokeMember(argValues, argNames);
+			}catch (Exception e){
+				AssertEquals(&quot;#A12&quot;,
typeof(AmbiguousMatchException), e.GetType());
+			}
+
+			try{
+				object[] argValues = new object []
{&quot;aaa&quot;, 12, &quot;bbb&quot;, &quot;zzz&quot;};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;ID&quot;};
+				invokeMember(argValues, argNames);
+			}catch (Exception e){
+				AssertEquals(&quot;#A13&quot;,
typeof(MissingMethodException), e.GetType());
+			}
+			
+
+			try{
+				object[] argValues = new object []
{&quot;aaa&quot;, 12, 20, &quot;bbb&quot;};
+				string [] argNames = new string []
{&quot;firstName&quot;, &quot;ID&quot;};
+				invokeMember(argValues, argNames);
+			}catch (Exception e){
+				AssertEquals(&quot;#A14&quot;,
typeof(MissingMethodException), e.GetType());
+			}
+		}
 	}
+
+	public class TypeClass 
+	{
+		public static void checkMethod(string lastName, string
firstName)
+		{
+			TypeTest.methodId = &quot;m1&quot;;
+			TypeTest.values[0] = firstName;
+			TypeTest.values[1] = lastName;
+		}
+
+		public static void checkMethod(string lastName, int
firstName)
+		{
+			TypeTest.methodId = &quot;m2&quot;;
+		}
+
+		public static void checkMethod(int firstName, string
lastName)
+		{
+			TypeTest.methodId = &quot;m3&quot;;
+		}
+
+		public static void checkMethod(string lastName, double
ID, string firstName)
+		{
+			TypeTest.methodId = &quot;m4&quot;;
+			TypeTest.values[0] = firstName;
+			TypeTest.values[1] = lastName;
+			TypeTest.values[2] = ID;
+		}
+
+		public static void checkMethod(long ID, string lastName,
string firstName)
+		{
+			TypeTest.methodId = &quot;m5&quot;;
+			TypeTest.values[0] = firstName;
+			TypeTest.values[1] = lastName;
+			TypeTest.values[2] = ID;
+		}
+		
+		public static void checkMethod(Int64 ID, string
lastName, string firstName,  Int64 sal)
+		{
+			TypeTest.methodId = &quot;m6&quot;;
+			TypeTest.values[0] = firstName;
+			TypeTest.values[1] = ID;
+			TypeTest.values[2] = lastName;
+			TypeTest.values[3] = sal;
+		}
+
+		public static void checkMethod(Int32 ID, string
lastName, string firstName, int sal)
+		{
+			TypeTest.methodId = &quot;m7&quot;;
+			TypeTest.values[0] = firstName;
+			TypeTest.values[1] = ID;
+			TypeTest.values[2] = lastName;
+			TypeTest.values[3] = sal;
+		}
+
+		public static void checkMethod(Int64 ID, string
lastName, Int32 sal, string firstName)
+		{
+			TypeTest.methodId = &quot;m8&quot;;
+			TypeTest.values[0] = firstName;
+			TypeTest.values[1] = ID;
+			TypeTest.values[2] = lastName;
+			TypeTest.values[3] = sal;
+		}
+
+		public static void checkMethod(Int32 ID, string
lastName, string firstName, long sal)
+		{
+			TypeTest.methodId = &quot;m9&quot;;
+			TypeTest.values[0] = firstName;
+			TypeTest.values[1] = ID;
+			TypeTest.values[2] = lastName;
+			TypeTest.values[3] = sal;
+		}
+
+
+		public static void checkMethod(Int32 ID, string val,
string lastName, string firstName, long sal)
+		{
+			TypeTest.methodId = &quot;m9&quot;;
+		}
+
+		public static void checkMethod(Int32 ID, string val,
string lastName, long sal, string firstName)
+		{
+			TypeTest.methodId = &quot;m9&quot;;
+		}
+
+
+	}
+
 }
 




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="017250.html">[Mono-list] Web service encoding
</A></li>
	<LI> Next message: <A HREF="017248.html">[Mono-list] Bug fix - 41691
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17247">[ date ]</a>
              <a href="thread.html#17247">[ thread ]</a>
              <a href="subject.html#17247">[ subject ]</a>
              <a href="author.html#17247">[ author ]</a>
         </LI>
       </UL>
</body></html>
