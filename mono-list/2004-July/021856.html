<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] RE: Questions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:lupus%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="021812.html">
   <LINK REL="Next"  HREF="021792.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] RE: Questions
   </H1>
    <B>Paolo Molaro
    </B> 
    <A HREF="mailto:lupus%40ximian.com"
       TITLE="[Mono-list] RE: Questions">lupus@ximian.com
       </A><BR>
    <I>Mon, 5 Jul 2004 19:17:01 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="021812.html">[Mono-list] RE: Questions
</A></li>
        <LI> Next message: <A HREF="021792.html">[Mono-list] Packaging issues and Paris
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21856">[ date ]</a>
              <a href="thread.html#21856">[ thread ]</a>
              <a href="subject.html#21856">[ subject ]</a>
              <a href="author.html#21856">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 07/02/04 <A HREF="mailto:Neale.Ferguson@SoftwareAG-USA.com">Neale.Ferguson@SoftwareAG-USA.com</A> wrote:
&gt;<i>                 try{
</I>&gt;<i>                         try {
</I>&gt;<i>                                 throw new NotImplementedException();
</I>&gt;<i>                         }
</I>&gt;<i>                         finally {
</I>&gt;<i>                                 i++;
</I>&gt;<i>                                 Console.WriteLine(&quot;Finally called&quot;);
</I>&gt;<i>                         }
</I>&gt;<i>                 } catch(NotImplementedException){
</I>&gt;<i>                         i++;
</I>&gt;<i>                         Console.WriteLine(&quot;Exception ignored&quot;);
</I>&gt;<i>                 }
</I>&gt;<i> 
</I>&gt;<i>                 if (i != 2)
</I>&gt;<i>                         return 1;
</I>&gt;<i> 
</I>&gt;<i>                 return 0;
</I>&gt;<i>         }
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> If the exception handler gets involved, discovers the catch, calls the
</I>&gt;<i> call_filter routine which branches to the finally after restoring the
</I>&gt;<i> registers to the context of Main. Now, this finally requires access to
</I>&gt;<i> its entire stack frame as it references the variable &quot;i&quot;. However, it
</I>&gt;<i> then issues a Console.WriteLine which means new stack frames appearing
</I>&gt;<i> after its own. Therefore, when it returns to the &quot;call_filter&quot; routine
</I>&gt;<i> it's possible that the stack frame of this routine has been trashed by
</I>&gt;<i> the calls made in the finally stuff.
</I>&gt;<i> 
</I>&gt;<i> Now considering this works for all the other platforms then I must be
</I>&gt;<i> doing something incorrectly or the ABI for S/390 makes things problematic
</I>&gt;<i> for me.
</I>
There are two registers that are commonly used to address the stack:
the stack pointer and the frame pointer. On x86 the are esp and ebp.
The stack pointer is the actual pointer to the start of the stack.
The frame pointer is the base pointer used to access local vars and
arguments on the stack.
Now, on ppc and s390 the call convention allows us to use the same
hardware register for both the stack and the frame pointer (r1 on ppc)
in most cases (we could do the same on x86 but it complicates some code
and makes for a bigger icache footprint, so currently it's avoided).
There are two cases where this optimization can't be done: methods that
use localloc and methods with exception blocks that need to be executed
during exception handling. In these cases you need to use another
register as frame pointer, so when the finally or filter is executed
local vars in the method are accessed correctly while the stack register
can still be expanded to allow for calls to happen.
So, when allocating variables, you use the frame pointer register instead 
of the stack register in these cases and in the prolog of the method you
simply copy the stack pointer to the frame pointer. The frame register
choosen should be the same used by the C compiler in the platform in
functions that use the C alloca () function (it should be a callee-saves
register and it should not be included in the set of registers used for
global register allocation for that method, obviously).

lupus

-- 
-----------------------------------------------------------------
<A HREF="mailto:lupus@debian.org">lupus@debian.org</A>                                     debian/rules
<A HREF="mailto:lupus@ximian.com">lupus@ximian.com</A>                             Monkeys do it better

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="021812.html">[Mono-list] RE: Questions
</A></li>
	<LI> Next message: <A HREF="021792.html">[Mono-list] Packaging issues and Paris
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#21856">[ date ]</a>
              <a href="thread.html#21856">[ thread ]</a>
              <a href="subject.html#21856">[ subject ]</a>
              <a href="author.html#21856">[ author ]</a>
         </LI>
       </UL>
</body></html>
