<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Assembly mutual dependencies or chicken-and-egg
 problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="017598.html">
   <LINK REL="Next"  HREF="017651.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Assembly mutual dependencies or chicken-and-egg
 problem
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] Assembly mutual dependencies or chicken-and-egg
 problem">jonpryor@vt.edu
       </A><BR>
    <I>Mon, 12 Jan 2004 07:52:24 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="017598.html">[Mono-list] Assembly mutual dependencies or chicken-and-egg problem
</A></li>
        <LI> Next message: <A HREF="017651.html">[Mono-list] Assembly mutual dependencies or chicken-and-eggproblem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17650">[ date ]</a>
              <a href="thread.html#17650">[ thread ]</a>
              <a href="subject.html#17650">[ subject ]</a>
              <a href="author.html#17650">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>You note that System.dll and System.Xml.dll are mutually dependent. 
They are built, however, by referring to the previous versions of the
assemblies.  So System.dll &quot;version&quot; (build?) 101 is built against
System.Xml.dll build 100 (previous build), and System.Xml.dll (which is
built after System.dll) can depend System.dll build 101 (current).

It doesn't look like this will easily work for your scenario.

The simple thing to do would likely be to break the dependency, and have
the Stub objects just refer to the other Stub objects.  The non-stub
objects can then expose new methods/properties, offering the
properly-cast stub objects for consumption.

Pro: No mutual dependencies between assemblies; if the user stays within
the &quot;tablename&quot; classes, they'll never see the Stub classes.

Con: Requires that the user-editable classes have boilerplate code (the
method/property overrides that expose the correct type).

Example:

	// Assembly: Base.dll
	class BaseObject {}

	// Assembly: Stubs.dll
	class Table1_Stub : BaseObject {
		public Table2_Stub Table2 { get; set; }
		// ...
	}

	// Assembly: Business.dll
	class Table1 : Table1_Stub {
		public new Table2 Table2 {
			get {return (Table2) base.Table2;}
			set {base.Table2 = value;}
		}
		// ...
	}

If the boilerplate code is an issue (and it could be, with enough table
values), introducing a &quot;_Impl&quot; class might work.  It would have to be in
the same assembly as the &quot;tablename&quot; classes, but I would think this
would work:

	// Both of these in &quot;Business.dll&quot;
	// You could probably use CodeDom to generate the _Impl classes,
	// since it needs to be in the same language as Table1.
	class Table1_Impl : Table1_Stub {
		public new Table2 Table2 {
			// same as Table1, above
		}
	}

	class Table1 : Table1_Impl {}

To answer your questions:

&gt;<i> Q1: Do you see any problems in the long run? [with original approach]
</I>
It's a complicated build process, and if the API exposed by the classes
ever radically changes (new DB schema, etc.) I think you'd have to start
the build &quot;from scratch&quot; (new stub classes, etc.).

&gt;<i> Q2: Do you have any better ideas?
</I>
See above.

&gt;<i> Q3: I'd like to be able to use VB.NET or JScript.NET for
</I>BUSINESS_OBJECTS.dll while STUBS.dll will remain C#. Do you this this is
doable?

Yes.  The &quot;barrier&quot; between languages is the .netmodule or the
Assembly.  Since each .dll is a different assembly, it should be fairly
straightforward to use different languages in this manner.

&gt;<i> Q4: I know there can be issues with strong-names, but I believe it
</I>should work. Am I right?

I would think so, but I'm not the strong-name expert.

 - Jon

On Fri, 2004-01-09 at 18:38, Jaroslaw Kowalski wrote:
&gt;<i> Hi guys!
</I>&gt;<i> 
</I>&gt;<i> I'm implementing a Data Access Layer (with a source code generator) in C#
</I>&gt;<i> and I'm having a conceptual problem with partitioning my design into
</I>&gt;<i> assemblies as it involves mutual dependencies.
</I>&gt;<i> 
</I>&gt;<i> Maybe someone can give me some advice?
</I>&gt;<i> 
</I>&gt;<i> Problem statement (a bit long - sorry)
</I>&gt;<i> 
</I>&gt;<i> 1. The system represents database entities as objects (O/R mapping)
</I>&gt;<i> 
</I>&gt;<i> 2. All entities ultimately derive from some base class that provides common
</I>&gt;<i> functionality. Let's call it BaseObject.
</I>&gt;<i> 
</I>&gt;<i> 3. On top of that there's a C# code (generated by some stub generation
</I>&gt;<i> utility) that creates a class for each database table. Class is named
</I>&gt;<i> &quot;tablename_STUB&quot; and derives from &quot;BaseObject&quot;.
</I>&gt;<i> 
</I>&gt;<i> 4. I'd like the user to be able to implement additional methods so I create
</I>&gt;<i> another class for each database table, called &quot;tablename&quot;. The idea is that
</I>&gt;<i> this class will never be re-generated while &quot;tablename_STUB&quot; will be
</I>&gt;<i> regenerated whenever the database schema changes.
</I>&gt;<i> 
</I>&gt;<i> So basically I have:
</I>&gt;<i> 
</I>&gt;<i> class BaseObject {}
</I>&gt;<i> class SomeTable_Stub : BaseObject { }
</I>&gt;<i> class SomeTable : SomeTable_Stub { }
</I>&gt;<i> 
</I>&gt;<i> 5. I want the instance of &quot;SomeTable_Stub&quot; to be able to return references
</I>&gt;<i> to &quot;SomeTable&quot; objects. This will be used to represent foreign key
</I>&gt;<i> relationships and I don't want to clutter SomeTable with any boilerplate
</I>&gt;<i> code. So this needs to be done in the Stub class and inherited.
</I>&gt;<i> 
</I>&gt;<i> Now I'd like to partition the system into separate assemblies:
</I>&gt;<i> 
</I>&gt;<i> BASE - which will contain BaseObject and helper stuff
</I>&gt;<i> STUBS - which will contain &quot;_Stub&quot; classes (regenerated after the schema
</I>&gt;<i> changes)
</I>&gt;<i> and
</I>&gt;<i> BUSINESS_OBJECTS - which contains classes without &quot;_Stubs&quot;.
</I>&gt;<i> 
</I>&gt;<i> My problem is that there's a mutual dependency between STUBS and
</I>&gt;<i> BUSINESS_OBJECTS. So I'd need STUBS.dll referencing BUSINESS_OBJECTS.dll and
</I>&gt;<i> vice versa.
</I>&gt;<i> 
</I>&gt;<i> I don't know how to accomplish it best.
</I>&gt;<i> 
</I>&gt;<i> I've looked at mono makefiles and found that &quot;System.dll&quot; references
</I>&gt;<i> &quot;System.Xml.dll&quot; and &quot;System.Xml.dll&quot; references &quot;System.dll&quot;. Somehow we
</I>&gt;<i> have a chicken-and-egg problem because it's not directly buildable.
</I>&gt;<i> 
</I>&gt;<i> I came up with the following idea to build this project:
</I>&gt;<i> 
</I>&gt;<i> 1. Build BASE.dll
</I>&gt;<i> 2. Create a small assembly that will have all the classes and methods that
</I>&gt;<i> STUBS.dll needs from BUSINESS_OBJECTS.dll but they derive from BaseObject
</I>&gt;<i> and the methods will be stubbed out.
</I>&gt;<i> 3. Compile this fake assembly (referencing BASE.dll) and name it:
</I>&gt;<i> &quot;BUSINESS_OBJECTS.dll&quot;
</I>&gt;<i> 4. Compile &quot;STUBS.dll&quot; passing it a reference to this fake
</I>&gt;<i> &quot;BUSINESS_OBJECTS.dll&quot;
</I>&gt;<i> 5. Now that we have &quot;STUBS.dll&quot; we can recompile the actual
</I>&gt;<i> &quot;BUSINESS_OBJECTS.dll&quot; with it.
</I>&gt;<i> 
</I>&gt;<i> I compiled it and even made it work, but I'm not convinced that this is the
</I>&gt;<i> best idea.
</I>&gt;<i> 
</I>&gt;<i> Q1: Do you see any problems in the long run?
</I>&gt;<i> Q2: Do you have any better ideas?
</I>&gt;<i> Q3: I'd like to be able to use VB.NET or JScript.NET for
</I>&gt;<i> BUSINESS_OBJECTS.dll while STUBS.dll will remain C#. Do you this this is
</I>&gt;<i> doable?
</I>&gt;<i> Q4: I know there can be issues with strong-names, but I believe it should
</I>&gt;<i> work. Am I right?
</I>&gt;<i> 
</I>&gt;<i> Jarek
</I>&gt;<i> 
</I>&gt;<i> P.S. I know I can keep the stubs and business objects in a single assembly
</I>&gt;<i> (this is actually how I did this before) but want to evaluate the
</I>&gt;<i> possibility of separating stubs and keeping them pre-compiled. The stubgen
</I>&gt;<i> phase takes a considerable amount of time and the stubs are getting large
</I>&gt;<i> (over 1MB of source code for a large database) so the compilation takes
</I>&gt;<i> time.
</I>&gt;<i> 
</I>&gt;<i> P.S.2. I'm planning to release my O/R mapping software as open source after
</I>&gt;<i> I resolve those basic issues and make it work with mono.
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@lists.ximian.com">Mono-list@lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="017598.html">[Mono-list] Assembly mutual dependencies or chicken-and-egg problem
</A></li>
	<LI> Next message: <A HREF="017651.html">[Mono-list] Assembly mutual dependencies or chicken-and-eggproblem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17650">[ date ]</a>
              <a href="thread.html#17650">[ thread ]</a>
              <a href="subject.html#17650">[ subject ]</a>
              <a href="author.html#17650">[ author ]</a>
         </LI>
       </UL>
</body></html>
