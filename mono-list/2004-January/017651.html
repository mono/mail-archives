<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Assembly mutual dependencies or chicken-and-eggproblem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jaak%40zd.com.pl">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="017650.html">
   <LINK REL="Next"  HREF="017665.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Assembly mutual dependencies or chicken-and-eggproblem
   </H1>
    <B>Jaroslaw Kowalski
    </B> 
    <A HREF="mailto:jaak%40zd.com.pl"
       TITLE="[Mono-list] Assembly mutual dependencies or chicken-and-eggproblem">jaak@zd.com.pl
       </A><BR>
    <I>Mon, 12 Jan 2004 14:10:18 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="017650.html">[Mono-list] Assembly mutual dependencies or chicken-and-egg
 problem
</A></li>
        <LI> Next message: <A HREF="017665.html">[Mono-list] Assembly mutual dependencies or
 chicken-and-eggproblem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17651">[ date ]</a>
              <a href="thread.html#17651">[ thread ]</a>
              <a href="subject.html#17651">[ subject ]</a>
              <a href="author.html#17651">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for your answer.

Actually I've developed a foolproof version of the build process:

1. I have a script that creates a &quot;mini&quot; version of business.dll containing
nothing but all classes and their constructors. The classes inherit from
their _Stub counterparts.

2. I have another script that creates a &quot;mini&quot; version of &quot;stubs.dll&quot;
containing nothing but all &quot;*_Stub&quot; classes and their constructors. The
classes inherit &quot;BaseObject&quot;.

3. The compilation process is:

a) compile &quot;mini&quot; stubs.dll (references nothing but base.dll)

b) compile &quot;mini&quot; business.dll (references &quot;mini&quot; stubs.dll - this must use
the same version and keyfile, to take care of strong names)

c) compile full stubs.dll (references &quot;mini&quot; business.dll)

d) full &quot;business.dll&quot; can be recompiled now against full stubs.dll.

This may cause warnings (or even errors) with compilers that complain that
&quot;business.dll&quot; is not found when compiling &quot;business.dll&quot; (in step &quot;d&quot;), but
can be easily overcome with:

csc /out:business.dll /r:path_to\stubs.dll /r:\path_to\mini_business.dll
business*.cs

Actually csc produces only a warning so I need to reference only
&quot;stubs.dll&quot;.

DO YOU SEE ANY POTENTIAL PROBLEMS WITH THIS AND MCS?

Jarek
----- Original Message ----- 
From: &quot;Jonathan Pryor&quot; &lt;<A HREF="mailto:jonpryor@vt.edu">jonpryor@vt.edu</A>&gt;
To: &quot;Jaroslaw Kowalski&quot; &lt;<A HREF="mailto:jaak@zd.com.pl">jaak@zd.com.pl</A>&gt;
Cc: &quot;Mono List&quot; &lt;<A HREF="mailto:mono-list@ximian.com">mono-list@ximian.com</A>&gt;
Sent: Monday, January 12, 2004 1:52 PM
Subject: Re: [Mono-list] Assembly mutual dependencies or
chicken-and-eggproblem


&gt;<i> You note that System.dll and System.Xml.dll are mutually dependent.
</I>&gt;<i> They are built, however, by referring to the previous versions of the
</I>&gt;<i> assemblies.  So System.dll &quot;version&quot; (build?) 101 is built against
</I>&gt;<i> System.Xml.dll build 100 (previous build), and System.Xml.dll (which is
</I>&gt;<i> built after System.dll) can depend System.dll build 101 (current).
</I>&gt;<i>
</I>&gt;<i> It doesn't look like this will easily work for your scenario.
</I>&gt;<i>
</I>&gt;<i> The simple thing to do would likely be to break the dependency, and have
</I>&gt;<i> the Stub objects just refer to the other Stub objects.  The non-stub
</I>&gt;<i> objects can then expose new methods/properties, offering the
</I>&gt;<i> properly-cast stub objects for consumption.
</I>&gt;<i>
</I>&gt;<i> Pro: No mutual dependencies between assemblies; if the user stays within
</I>&gt;<i> the &quot;tablename&quot; classes, they'll never see the Stub classes.
</I>&gt;<i>
</I>&gt;<i> Con: Requires that the user-editable classes have boilerplate code (the
</I>&gt;<i> method/property overrides that expose the correct type).
</I>&gt;<i>
</I>&gt;<i> Example:
</I>&gt;<i>
</I>&gt;<i> // Assembly: Base.dll
</I>&gt;<i> class BaseObject {}
</I>&gt;<i>
</I>&gt;<i> // Assembly: Stubs.dll
</I>&gt;<i> class Table1_Stub : BaseObject {
</I>&gt;<i> public Table2_Stub Table2 { get; set; }
</I>&gt;<i> // ...
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> // Assembly: Business.dll
</I>&gt;<i> class Table1 : Table1_Stub {
</I>&gt;<i> public new Table2 Table2 {
</I>&gt;<i> get {return (Table2) base.Table2;}
</I>&gt;<i> set {base.Table2 = value;}
</I>&gt;<i> }
</I>&gt;<i> // ...
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> If the boilerplate code is an issue (and it could be, with enough table
</I>&gt;<i> values), introducing a &quot;_Impl&quot; class might work.  It would have to be in
</I>&gt;<i> the same assembly as the &quot;tablename&quot; classes, but I would think this
</I>&gt;<i> would work:
</I>&gt;<i>
</I>&gt;<i> // Both of these in &quot;Business.dll&quot;
</I>&gt;<i> // You could probably use CodeDom to generate the _Impl classes,
</I>&gt;<i> // since it needs to be in the same language as Table1.
</I>&gt;<i> class Table1_Impl : Table1_Stub {
</I>&gt;<i> public new Table2 Table2 {
</I>&gt;<i> // same as Table1, above
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> class Table1 : Table1_Impl {}
</I>&gt;<i>
</I>&gt;<i> To answer your questions:
</I>&gt;<i>
</I>&gt;<i> &gt; Q1: Do you see any problems in the long run? [with original approach]
</I>&gt;<i>
</I>&gt;<i> It's a complicated build process, and if the API exposed by the classes
</I>&gt;<i> ever radically changes (new DB schema, etc.) I think you'd have to start
</I>&gt;<i> the build &quot;from scratch&quot; (new stub classes, etc.).
</I>&gt;<i>
</I>&gt;<i> &gt; Q2: Do you have any better ideas?
</I>&gt;<i>
</I>&gt;<i> See above.
</I>&gt;<i>
</I>&gt;<i> &gt; Q3: I'd like to be able to use VB.NET or JScript.NET for
</I>&gt;<i> BUSINESS_OBJECTS.dll while STUBS.dll will remain C#. Do you this this is
</I>&gt;<i> doable?
</I>&gt;<i>
</I>&gt;<i> Yes.  The &quot;barrier&quot; between languages is the .netmodule or the
</I>&gt;<i> Assembly.  Since each .dll is a different assembly, it should be fairly
</I>&gt;<i> straightforward to use different languages in this manner.
</I>&gt;<i>
</I>&gt;<i> &gt; Q4: I know there can be issues with strong-names, but I believe it
</I>&gt;<i> should work. Am I right?
</I>&gt;<i>
</I>&gt;<i> I would think so, but I'm not the strong-name expert.
</I>&gt;<i>
</I>&gt;<i>  - Jon
</I>&gt;<i>
</I>&gt;<i> On Fri, 2004-01-09 at 18:38, Jaroslaw Kowalski wrote:
</I>&gt;<i> &gt; Hi guys!
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I'm implementing a Data Access Layer (with a source code generator) in
</I>C#
&gt;<i> &gt; and I'm having a conceptual problem with partitioning my design into
</I>&gt;<i> &gt; assemblies as it involves mutual dependencies.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Maybe someone can give me some advice?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Problem statement (a bit long - sorry)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1. The system represents database entities as objects (O/R mapping)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 2. All entities ultimately derive from some base class that provides
</I>common
&gt;<i> &gt; functionality. Let's call it BaseObject.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 3. On top of that there's a C# code (generated by some stub generation
</I>&gt;<i> &gt; utility) that creates a class for each database table. Class is named
</I>&gt;<i> &gt; &quot;tablename_STUB&quot; and derives from &quot;BaseObject&quot;.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 4. I'd like the user to be able to implement additional methods so I
</I>create
&gt;<i> &gt; another class for each database table, called &quot;tablename&quot;. The idea is
</I>that
&gt;<i> &gt; this class will never be re-generated while &quot;tablename_STUB&quot; will be
</I>&gt;<i> &gt; regenerated whenever the database schema changes.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; So basically I have:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; class BaseObject {}
</I>&gt;<i> &gt; class SomeTable_Stub : BaseObject { }
</I>&gt;<i> &gt; class SomeTable : SomeTable_Stub { }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 5. I want the instance of &quot;SomeTable_Stub&quot; to be able to return
</I>references
&gt;<i> &gt; to &quot;SomeTable&quot; objects. This will be used to represent foreign key
</I>&gt;<i> &gt; relationships and I don't want to clutter SomeTable with any boilerplate
</I>&gt;<i> &gt; code. So this needs to be done in the Stub class and inherited.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Now I'd like to partition the system into separate assemblies:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; BASE - which will contain BaseObject and helper stuff
</I>&gt;<i> &gt; STUBS - which will contain &quot;_Stub&quot; classes (regenerated after the schema
</I>&gt;<i> &gt; changes)
</I>&gt;<i> &gt; and
</I>&gt;<i> &gt; BUSINESS_OBJECTS - which contains classes without &quot;_Stubs&quot;.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; My problem is that there's a mutual dependency between STUBS and
</I>&gt;<i> &gt; BUSINESS_OBJECTS. So I'd need STUBS.dll referencing BUSINESS_OBJECTS.dll
</I>and
&gt;<i> &gt; vice versa.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I don't know how to accomplish it best.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I've looked at mono makefiles and found that &quot;System.dll&quot; references
</I>&gt;<i> &gt; &quot;System.Xml.dll&quot; and &quot;System.Xml.dll&quot; references &quot;System.dll&quot;. Somehow
</I>we
&gt;<i> &gt; have a chicken-and-egg problem because it's not directly buildable.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I came up with the following idea to build this project:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; 1. Build BASE.dll
</I>&gt;<i> &gt; 2. Create a small assembly that will have all the classes and methods
</I>that
&gt;<i> &gt; STUBS.dll needs from BUSINESS_OBJECTS.dll but they derive from
</I>BaseObject
&gt;<i> &gt; and the methods will be stubbed out.
</I>&gt;<i> &gt; 3. Compile this fake assembly (referencing BASE.dll) and name it:
</I>&gt;<i> &gt; &quot;BUSINESS_OBJECTS.dll&quot;
</I>&gt;<i> &gt; 4. Compile &quot;STUBS.dll&quot; passing it a reference to this fake
</I>&gt;<i> &gt; &quot;BUSINESS_OBJECTS.dll&quot;
</I>&gt;<i> &gt; 5. Now that we have &quot;STUBS.dll&quot; we can recompile the actual
</I>&gt;<i> &gt; &quot;BUSINESS_OBJECTS.dll&quot; with it.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; I compiled it and even made it work, but I'm not convinced that this is
</I>the
&gt;<i> &gt; best idea.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Q1: Do you see any problems in the long run?
</I>&gt;<i> &gt; Q2: Do you have any better ideas?
</I>&gt;<i> &gt; Q3: I'd like to be able to use VB.NET or JScript.NET for
</I>&gt;<i> &gt; BUSINESS_OBJECTS.dll while STUBS.dll will remain C#. Do you this this is
</I>&gt;<i> &gt; doable?
</I>&gt;<i> &gt; Q4: I know there can be issues with strong-names, but I believe it
</I>should
&gt;<i> &gt; work. Am I right?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Jarek
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; P.S. I know I can keep the stubs and business objects in a single
</I>assembly
&gt;<i> &gt; (this is actually how I did this before) but want to evaluate the
</I>&gt;<i> &gt; possibility of separating stubs and keeping them pre-compiled. The
</I>stubgen
&gt;<i> &gt; phase takes a considerable amount of time and the stubs are getting
</I>large
&gt;<i> &gt; (over 1MB of source code for a large database) so the compilation takes
</I>&gt;<i> &gt; time.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; P.S.2. I'm planning to release my O/R mapping software as open source
</I>after
&gt;<i> &gt; I resolve those basic issues and make it work with mono.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-list maillist  -  <A HREF="mailto:Mono-list@lists.ximian.com">Mono-list@lists.ximian.com</A>
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i>
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="017650.html">[Mono-list] Assembly mutual dependencies or chicken-and-egg
 problem
</A></li>
	<LI> Next message: <A HREF="017665.html">[Mono-list] Assembly mutual dependencies or
 chicken-and-eggproblem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17651">[ date ]</a>
              <a href="thread.html#17651">[ thread ]</a>
              <a href="subject.html#17651">[ subject ]</a>
              <a href="author.html#17651">[ author ]</a>
         </LI>
       </UL>
</body></html>
