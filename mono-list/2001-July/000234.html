<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Gcc front-end?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:saurik%40saurik.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000227.html">
   <LINK REL="Next"  HREF="000238.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Gcc front-end?
   </H1>
    <B>Jay Freeman (saurik)
    </B> 
    <A HREF="mailto:saurik%40saurik.com"
       TITLE="[Mono-list] Gcc front-end?">saurik@saurik.com
       </A><BR>
    <I>Tue, 10 Jul 2001 14:16:58 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="000227.html">[Mono-list] Gcc front-end?
</A></li>
        <LI> Next message: <A HREF="000238.html">[Mono-list] Gcc front-end?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#234">[ date ]</a>
              <a href="thread.html#234">[ thread ]</a>
              <a href="subject.html#234">[ subject ]</a>
              <a href="author.html#234">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>John:

Yes.  Speaking about Microsoft's implementation:  While it caches compiled
code in memory (obviously), it will not (for version 1 at least, future
support has been indicated) cache the code it compiles during execution onto
disk between executions.  It does not do any interpretation or mixed-mode
execution (the byte codes weren't designed to make this easy, anyway).
There is also a &quot;pre-JIT&quot; compiler that can be executed either manually or
from an installation program to compile the code during installation, sign
it (to verify that evil code wasn't plopped in its place), and cache it
away.

The question I have about what you are saying is: if you do this, is there
going to be a good way to get gcc to execute on in-memory sets of byte codes
(as we just downloaded them from whatever site into memory, or maybe someone
used Reflection.Emit to compile on-the-fly into memory) to output an
in-memory binary (for purposes of actual execution)?  From what I've seen of
GCC it looks like god-forsaken, hacked-together, monolithic technology that
only kicks ass at what it does because everyone uses it and keeps it up to
date with all of the latest hacks.  The inability to quickly seperate out
its components for reuse actually seems to be a _feature_ accourding to what
I've heard from Miguel in conversations recently (having to do with being
able to... convince... companies to release their source code, as to get
their product working it needed to actually _become_ gcc rather than just
_using_ gcc for a single purpose, such as a back-end compiler).  While I
really would love to see a gcc front-end, I don't see how this deals well
with the JIT question.

Sincerely,
Jay Freeman (saurik)
<A HREF="mailto:saurik@saurik.com">saurik@saurik.com</A>

----- Original Message -----
From: &quot;John Zedlewski&quot; &lt;<A HREF="mailto:zedlwski@Princeton.EDU">zedlwski@Princeton.EDU</A>&gt;
To: &lt;<A HREF="mailto:mono-list@ximian.com">mono-list@ximian.com</A>&gt;
Sent: Tuesday, July 10, 2001 1:32 PM
Subject: [Mono-list] Gcc front-end?


&gt;<i> Hi folks,
</I>&gt;<i>   On the roadmap, it seems to imply that y'all are working on a
</I>&gt;<i> completely new &quot;JIT&quot; compiler for the CLI.  I'm curious about why this
</I>&gt;<i> is a better plan than writing a Gcc front-end for CLI bytecode.  As soon
</I>&gt;<i> as a Linux x86 &quot;JIT&quot; comes out, somebody's going to complain about the
</I>&gt;<i> lack of optimizations, somebody else will bitch about not having a Linux
</I>&gt;<i> Alpha port, and ten more users will want ports to Solaris and IA-64.  At
</I>&gt;<i> least, that's been my experience with OSS projects in the past ;)  Some
</I>&gt;<i> old posts from the Mercury folks implied that they were able to do the
</I>&gt;<i> Mercury-&gt;gcc interface in under 8,000 LOC.
</I>&gt;<i>
</I>&gt;<i>   Also, am I correct in believing that CLI is designed for more of an
</I>&gt;<i> Ahead-Of-Time compiler with local caching of native code?  That's what
</I>&gt;<i> all the MS marketing-speak seemed to imply (no interepreter or
</I>&gt;<i> mixed-mode).
</I>&gt;<i>
</I>&gt;<i> Thanks!
</I>&gt;<i> --JRZ
</I>


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000227.html">[Mono-list] Gcc front-end?
</A></li>
	<LI> Next message: <A HREF="000238.html">[Mono-list] Gcc front-end?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#234">[ date ]</a>
              <a href="thread.html#234">[ thread ]</a>
              <a href="subject.html#234">[ subject ]</a>
              <a href="author.html#234">[ author ]</a>
         </LI>
       </UL>
</body></html>
