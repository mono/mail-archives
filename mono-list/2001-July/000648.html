<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Re: IEnumerators
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:serge%40wildwestsoftware.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000646.html">
   <LINK REL="Next"  HREF="000650.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Re: IEnumerators
   </H1>
    <B>Serge
    </B> 
    <A HREF="mailto:serge%40wildwestsoftware.com"
       TITLE="[Mono-list] Re: IEnumerators">serge@wildwestsoftware.com
       </A><BR>
    <I>Tue, 17 Jul 2001 16:08:41 +0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000646.html">[Mono-list] Re: IEnumerators
</A></li>
        <LI> Next message: <A HREF="000650.html">[Mono-list] Re: IEnumerators
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#648">[ date ]</a>
              <a href="thread.html#648">[ thread ]</a>
              <a href="subject.html#648">[ subject ]</a>
              <a href="author.html#648">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> If you call GetEnumerator() on a SyncStack instance, it's returning an
</I>&gt;<i> Enumerator that is synchronized (on itself at the moment i think,
</I>&gt;<i> but when change it to use a reference to the stack,
</I>&gt;<i> it'll synchronize on the stack).
</I>
Yes, and that's wrong ;-)
Consider the following snippet. It assumes that methods
of the Enumerator are syncronized on the reference
 to the parent stack:

    Stack syncStack=Synchronized(stack);
    // the calls to e are synched on its parent.
    IEnumerator e=syncStack.GetEnumerator();
    while (e.MoveNext()) {
        DoSomethingWith(e.Current);
    }

Although it protects Enumerator's internal state during each call, it
doesn't protects the collection from being concurrently modified between
calls.
That is, if you creating synchronized stack, you suppose it will be used
concurrently. What you really want is to lock it while you're iterating
through it. Or else you should know that there is no other thread accesing
it in between MoveNext() and Current. Or concurrency is simply not an issue
at the moment, so you don't need synchronization at all, and there is really
no difference between synched and unsynched Enumerators.

The point is that to protect the stack during enumeration the following code
should be used:

    Stack syncStack=Synchronized(stack);
    lock (syncStack) {
        // the calls to e are not synched at all
        IEnumerator e=syncStack.GetEnumerator();
        while (e.MoveNext()) {
            DoSomethingWith(e.Current);
        }
    }

That is, client code should manually lock the entire loop to ensure the
Stack integrity.

&gt;<i> At the very least we should be sure all the classes
</I>&gt;<i> that are there are consistent.
</I>Exactly! I also agree that it's probably too early to do something about it
right now, but maybe just start thinking about it.


--
Sergey








</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000646.html">[Mono-list] Re: IEnumerators
</A></li>
	<LI> Next message: <A HREF="000650.html">[Mono-list] Re: IEnumerators
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#648">[ date ]</a>
              <a href="thread.html#648">[ thread ]</a>
              <a href="subject.html#648">[ subject ]</a>
              <a href="author.html#648">[ author ]</a>
         </LI>
       </UL>
</body></html>
