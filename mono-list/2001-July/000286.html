<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] gcc front-end and portability
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000252.html">
   <LINK REL="Next"  HREF="000307.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] gcc front-end and portability
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="[Mono-list] gcc front-end and portability">miguel@ximian.com
       </A><BR>
    <I>10 Jul 2001 20:03:05 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000252.html">[Mono-list] gcc front-end and portability
</A></li>
        <LI> Next message: <A HREF="000307.html">[Mono-list] gcc front-end and portability
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#286">[ date ]</a>
              <a href="thread.html#286">[ thread ]</a>
              <a href="subject.html#286">[ subject ]</a>
              <a href="author.html#286">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>   I just want to emphasize that it's really, really, really, really hard
</I>&gt;<i> to build a good, cross-platform optimizing JIT from scratch. In the 5-6
</I>&gt;<i> years that Java has been around, no open source or academic project has
</I>&gt;<i> managed to do it (Sable, OpenJIT, and LaTTe are all machine-specific and
</I>&gt;<i> they typically lose to the Sun, MS, and IBM JVMs by a factor of 2 in
</I>&gt;<i> benchmarks). I really don't se a reason to believe that Mono-CLI will do
</I>&gt;<i> better unless it starts from a strong foundation.  But, hey, maybe I'm
</I>&gt;<i> just too much of a cynic.
</I>
I have been doing some intense learning on the subject, and the
differentce really is that to write a JIT for Java you have to either
do some really good work on the bytecode analysis to prove that it
will not do anything strange (which most small projects wont be able
to do, hence them being slow) or you just to `macro expansion' of
opcodes.

The CIL is different from Java Byte Codes in that regard: there are
various assumptions that can be made on the input stream that are just
not possible to do with java (the state of the stack at invocation and
return points, and the type safety of the stack) that come into play.

Please read the links on the `Runtime' web page, I have updated them
with some really interesting links from Paolo (great article on the
guy who did LCC)


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000252.html">[Mono-list] gcc front-end and portability
</A></li>
	<LI> Next message: <A HREF="000307.html">[Mono-list] gcc front-end and portability
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#286">[ date ]</a>
              <a href="thread.html#286">[ thread ]</a>
              <a href="subject.html#286">[ subject ]</a>
              <a href="author.html#286">[ author ]</a>
         </LI>
       </UL>
</body></html>
