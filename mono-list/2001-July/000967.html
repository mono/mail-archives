<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] PInvoke Conventions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rweather%40zip.com.au">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000962.html">
   <LINK REL="Next"  HREF="001104.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] PInvoke Conventions
   </H1>
    <B>Rhys Weatherley
    </B> 
    <A HREF="mailto:rweather%40zip.com.au"
       TITLE="[Mono-list] PInvoke Conventions">rweather@zip.com.au
       </A><BR>
    <I>Sat, 28 Jul 2001 09:16:17 +1000</I>
    <P><UL>
        <LI> Previous message: <A HREF="000962.html">[Mono-list] PInvoke Conventions
</A></li>
        <LI> Next message: <A HREF="001104.html">[Mono-list] PInvoke Conventions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#967">[ date ]</a>
              <a href="thread.html#967">[ thread ]</a>
              <a href="subject.html#967">[ subject ]</a>
              <a href="author.html#967">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>OK, reality check time.  I think that the people that are
suggesting generating C stubs and C# definitions to
handle the &quot;nasty bits&quot; are missing the whole point
behind PInvoke.

There are two primary mechanisms in the CLI for invoking
native method code: internalcall and PInvoke.

The &quot;internalcall&quot; mechanism is used mainly for methods
that live very close to the VM.  As such, they use the same
calling and parameter passing mechanisms as regular
C# code.

If there is a &quot;semantic mismatch&quot; between the parameters
in the C# world and those in the native world, then the
internalcall method itself is reponsible for unpacking the
C# data and converting it into whatever the native
world requires.  This wrapper layer will normally be
written by the programmer, or by tools that the
programmer writes.

The suggestion of building C wrappers that automatically
convert between the two worlds is what is needed to wrap
a C function to be invoked as &quot;internalcall&quot;.

PInvoke is something completely different.  Rather than
requiring the programmer to write the wrapper (either
directly, or indirectly through a tool), PInvoke builds the
wrapper on the fly at runtime from a list of metadata
instructions, supplied as attributes.

PInvoke is very handy for people writing .NET applications.
Let's say Fred is writing a database app and needs to call
some nifty piece of business logic written by some other
group in C.  Being an SQL/dbscript monkey, Fred is not
terribly bright when it comes to C stuff.

With internalcall, he has to drop down to the native level
and invoke some serious black magic.  With PInvoke, he
writes a 1-line description of the C parameters, and the
VM performs the black magic for him.

If we go the route that some people suggesting, then we
might as well forget PInvoke altogether and just use
&quot;internalcall&quot;.

PInvoke is hard.  Damned hard.  It cannot be made easy,
because it is performing a monstrous amount of black
magic behind the scenes.  But that black magic is useful
because then people using the platform don't need to
concern themselves with it.

The trick is coming up with a *standard* way of doing
this black magic.  I fear that if the &quot;C wrapper&quot; crowd
wins this war, then the resulting C# library will only work
with Mono's VM and the rest of us will have to start
from scratch.

Cheers,

Rhys.




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000962.html">[Mono-list] PInvoke Conventions
</A></li>
	<LI> Next message: <A HREF="001104.html">[Mono-list] PInvoke Conventions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#967">[ date ]</a>
              <a href="thread.html#967">[ thread ]</a>
              <a href="subject.html#967">[ subject ]</a>
              <a href="author.html#967">[ author ]</a>
         </LI>
       </UL>
</body></html>
