<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Re: can you explain what you mean?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000537.html">
   <LINK REL="Next"  HREF="000570.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Re: can you explain what you mean?
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="[Mono-list] Re: can you explain what you mean?">miguel@ximian.com
       </A><BR>
    <I>15 Jul 2001 15:04:24 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000537.html">[Mono-list] Re: can you explain what you mean?
</A></li>
        <LI> Next message: <A HREF="000570.html">JVM misconceptions (Re: [Mono-list] Re: can you explain what you mean?)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#566">[ date ]</a>
              <a href="thread.html#566">[ thread ]</a>
              <a href="subject.html#566">[ subject ]</a>
              <a href="author.html#566">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> Of course,
</I>&gt;<i> a good runtime will verify these declarations,
</I>&gt;<i> so maybe the &quot;proof engine&quot; you are thinking of
</I>&gt;<i> is the type checker that any JVM (and, presumably, 
</I>&gt;<i> any safe CLR implementation) needs anyway (and 
</I>&gt;<i> that is pretty trivial to implement).
</I>
It might look trivial to implement, but so far, it does not seem like
anyone has written a Java code generator along those lines.

I was looking yesterday at benchmarks between various java
implementations and the early JIT from Microsoft (the `dumb jit') and
it seems like the dump clr jit is outperforming java.

This is me reading the `JavaLobby' paper

&gt;<i> In fact, it's easy to write something that takes
</I>&gt;<i> JVM bytecodes and reconstructs a parse tree (and
</I>&gt;<i> even source code).  I have done it, and so have 
</I>&gt;<i> many other people.  Conversely, JVM bytecodes are
</I>&gt;<i> easily translated into register instructions precisely
</I>&gt;<i> because the JIT knows the arity of any function
</I>&gt;<i> and primitive that occurs in an instruction sequence.
</I>
The fact that you can decode *some* bytecodes into source code does
not mean that you can decode correctly *all* bytecodes that the JVM
can interpret.  

The generic example I have used it (mix of C and bytecodes):

	while (n &gt; 0){
		ipush (n % 10)
		n /= 10;
		c++;
	}

	while (c--){
		ipop 
		print 
	}

&gt;<i> If you know of other, concrete ways in which the CLR
</I>&gt;<i> and the JVM bytecodes differ in this regard, I would 
</I>&gt;<i> certainly like to know about it.  I'd also be curious 
</I>&gt;<i> where this claim actually originated; is that what 
</I>&gt;<i> Microsoft is saying about the JVM?
</I>
I dont think Microsoft is saying anything about the JVM.  But just
like you, I was wondering why people said `the CIL bytecodes are good
for JITing'. 

The answer is trivial once you read the BURS research papers (the web
site has the links) and the list of restrictions that CIL imposes on
the bytecodes.  You can now precisely track the requirement to the
algorithms being implemented for instruction selection.

Look in Partition I for a set of restriction on CIL byte code. 

Miguel.


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000537.html">[Mono-list] Re: can you explain what you mean?
</A></li>
	<LI> Next message: <A HREF="000570.html">JVM misconceptions (Re: [Mono-list] Re: can you explain what you mean?)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#566">[ date ]</a>
              <a href="thread.html#566">[ thread ]</a>
              <a href="subject.html#566">[ subject ]</a>
              <a href="author.html#566">[ author ]</a>
         </LI>
       </UL>
</body></html>
