<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Novel Proposal for Mono Compiler Implementation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:david%40pipco.freeserve.co.uk">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000298.html">
   <LINK REL="Next"  HREF="000292.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Novel Proposal for Mono Compiler Implementation
   </H1>
    <B>David Gardner
    </B> 
    <A HREF="mailto:david%40pipco.freeserve.co.uk"
       TITLE="[Mono-list] Novel Proposal for Mono Compiler Implementation">david@pipco.freeserve.co.uk
       </A><BR>
    <I>Wed, 11 Jul 2001 02:44:33 GMT</I>
    <P><UL>
        <LI> Previous message: <A HREF="000298.html">[Mono-list] Novel Proposal  for Mono Compiler Implementations
</A></li>
        <LI> Next message: <A HREF="000292.html">[Mono-list] A comment on published research and IP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#296">[ date ]</a>
              <a href="thread.html#296">[ thread ]</a>
              <a href="subject.html#296">[ subject ]</a>
              <a href="author.html#296">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<i> Original Message &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
</I>
On 7/11/01, 1:20:45 AM, &quot;Frank Laub&quot; &lt;<A HREF="mailto:flaub@dev.virtuoso.com">flaub@dev.virtuoso.com</A>&gt; wrote 
regarding RE: [Mono-list] Novel Proposal for Mono Compiler Implementation:


&gt;<i> You know, I've thought about this very thing.  I've specifically thought
</I>&gt;<i> about what kind of emitters you could have.  Here are some revalations I
</I>&gt;<i> had when this is the sort of paradigm is used to develop software:
</I>
&gt;<i> - Source Control
</I>&gt;<i> Currently, source control works (most commonly) by dealing with files.
</I>&gt;<i> Imagine if code was never in a source format, but if it was always
</I>&gt;<i> stored as a parsetree.  An editor for that code would be much like a
</I>&gt;<i> 'viewer' into that parsetree.  Any language could be used to view
</I>&gt;<i> someone else's work.  (i.e. I write a class in VB, another developer
</I>&gt;<i> modifies that class in C#, another developer debugs that code in a C++
</I>&gt;<i> flavor).  Languages won't truly matter when it comes to implementing
</I>&gt;<i> software.
</I>
Surely there has to be some reasonable limit to this. I can't quite 
imagine writing code in C++ and reading it in Prolog and LISP :)

Also, how would you deal with preconditions/postconditions/invariants 
written in Eiffel? More generally, how do you deal with any feature in 
one language not present in another (eg single/multiple inheritance, 
early/late binding, contracts/no contracts, strongly/weakly typed, 
functional/imperative) 

&gt;<i> - Code Reviews
</I>&gt;<i> I'm thinking that the above will make this process easier.
</I>&gt;<i> - Non-Imperative Centric Views
</I>&gt;<i> Instead of emitting code into IL or bytecodes or opcodes, how about
</I>&gt;<i> emitting it as, say database recordsets (organizations can have true
</I>&gt;<i> code repositories, not just shared files of source code), or say the
</I>&gt;<i> output is some graphical representation.  We're now coming closer to the
</I>&gt;<i> idea of editing code visually, not just faking it by using tools that
</I>&gt;<i> generate source code.
</I>
Now the graphical view idea really does sound good. I've always wanted to 
use software components like electronic components, ie like drawing a 
schematic diagram. I would imagine it would be easier for a 
non-programmer to make a custom application using this schematic/graphic 
approach, rather than edit source code.

&gt;<i> The thing I keep thinking is this isn't really a major departure from
</I>&gt;<i> current compiler technology, just an evolution of it.  By seperating the
</I>&gt;<i> phases of a compiler and keeping those pieces truly independent, all
</I>&gt;<i> sorts of possiblities come out.  AND, the biggest side-effect of this
</I>&gt;<i> that I can see is, it makes writing a compiler easier.  Monolithic
</I>&gt;<i> software is a thing of the past, let's setup the tools (compilers) for
</I>&gt;<i> which we build software to also be componentized (which is exactly why
</I>&gt;<i> I'm so interested in .NET).
</I>
I think it's an excellent idea to solve a problem by dividing it into two 
pieces, each less than half the size of the original problem!

Dave


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000298.html">[Mono-list] Novel Proposal  for Mono Compiler Implementations
</A></li>
	<LI> Next message: <A HREF="000292.html">[Mono-list] A comment on published research and IP
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#296">[ date ]</a>
              <a href="thread.html#296">[ thread ]</a>
              <a href="subject.html#296">[ subject ]</a>
              <a href="author.html#296">[ author ]</a>
         </LI>
       </UL>
</body></html>
