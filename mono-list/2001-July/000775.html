<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] PInvoke Conventions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rubys%40us.ibm.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000772.html">
   <LINK REL="Next"  HREF="000787.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] PInvoke Conventions
   </H1>
    <B>Sam Ruby
    </B> 
    <A HREF="mailto:rubys%40us.ibm.com"
       TITLE="[Mono-list] PInvoke Conventions">rubys@us.ibm.com
       </A><BR>
    <I>Thu, 19 Jul 2001 19:38:42 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000772.html">[Mono-list] Better answer for Q66 in FAQ.
</A></li>
        <LI> Next message: <A HREF="000787.html">[Mono-list] PInvoke Conventions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#775">[ date ]</a>
              <a href="thread.html#775">[ thread ]</a>
              <a href="subject.html#775">[ subject ]</a>
              <a href="author.html#775">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Miguel de Icaza wrote:
&gt;<i>
</I>&gt;<i> [DllImport(&quot;libc&quot;),PosixProto(int,off_t,int)]
</I>&gt;<i> int lseek (int, long, int)
</I>
or even better:

  [DllImport(&quot;libc&quot;),PosixProto(int,off_t,int)]
  long lseek (int, long, int)

Such a declaration would work on systems where the number of bits in a &quot;C&quot;
int is in the range of 32 to 64.

Rhys Weatherley wrote:
&gt;<i>
</I>&gt;<i> This assumes that there will be different library builds for each
</I>&gt;<i> platform.  This may not be too bad for core stuff, but may be a
</I>&gt;<i> hassle for extension libraries.
</I>&gt;<i>
</I>&gt;<i> The key issue actually isn't how to make PInvoke work, but rather
</I>&gt;<i> to make it work the same.  An application that imports &quot;lseek&quot;
</I>&gt;<i> needs to work regardless of how the call is marshalled to the
</I>&gt;<i> underlying OS.  When the application is compiled, the method
</I>&gt;<i> signature will be placed into it by the compiler.  It can only run
</I>&gt;<i> if the CLR/library exports a method with the correct signature.
</I>&gt;<i>
</I>&gt;<i> So, autoconf would need to detect the exact system
</I>&gt;<i> characteristics and then write out marshalling information
</I>&gt;<i> to convert the agreed-upon method signature into the
</I>&gt;<i> system-specific one.
</I>
I lost track of what you would be &quot;autoconf'ing&quot;... the compiler? The jit?
The runtime libraries?

Not only would separate builds be a hassle... think about what happens when
you bring multiple languages into the picture...  Will the Python to CIL
compiler also need to be autoconf'ed, or does it only need to support
custom attributes?

My 2 cents: it would be highly desirable for the bytecodes produced by a
compiler to be portable, and any necessary mapping done at JIT time
(preferred) or dynamically at runtime.

- Sam Ruby



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000772.html">[Mono-list] Better answer for Q66 in FAQ.
</A></li>
	<LI> Next message: <A HREF="000787.html">[Mono-list] PInvoke Conventions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#775">[ date ]</a>
              <a href="thread.html#775">[ thread ]</a>
              <a href="subject.html#775">[ subject ]</a>
              <a href="author.html#775">[ author ]</a>
         </LI>
       </UL>
</body></html>
