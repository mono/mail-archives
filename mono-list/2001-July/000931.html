<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] PInvoke:TNG
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rweather%40zip.com.au">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000936.html">
   <LINK REL="Next"  HREF="000934.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] PInvoke:TNG
   </H1>
    <B>Rhys Weatherley
    </B> 
    <A HREF="mailto:rweather%40zip.com.au"
       TITLE="[Mono-list] PInvoke:TNG">rweather@zip.com.au
       </A><BR>
    <I>Thu, 26 Jul 2001 15:05:29 +1000</I>
    <P><UL>
        <LI> Previous message: <A HREF="000936.html">[Mono-list] Tests
</A></li>
        <LI> Next message: <A HREF="000934.html">[Mono-list] PInvoke:TNG
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#931">[ date ]</a>
              <a href="thread.html#931">[ thread ]</a>
              <a href="subject.html#931">[ subject ]</a>
              <a href="author.html#931">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I've been updating &quot;pinvoke.html&quot; with the feedback I received
in the last week.  While experimenting with Miguel's &quot;PosixProto&quot;
proposal, and the suggestions from Fergus, a new idea occurred to me.

So far we've been concentrating on annotating the method definition
with information on how to marshal parameters and return values.
The new idea turns this on its head and annotates the types instead.

Consider the following two C# value type definitions:

    [PosixType]
    public struct off_t
    {
        private long value;

        public off_t(long x) { value = x; }

        public static operator implicit off_t(long x)
            { return new off_t(x); }
        public static operator implicit long(off_t x)
            { return x.value; }
    };

    [PosixType]
    public struct int_t
    {
        private int value;

        public int_t(int x) { value = x; }

        public static operator implicit off_t(int x)
            { return new int_t(x); }
        public static operator implicit int(int_t x)
            { return x.value; }
    };

and the following new definition for &quot;lseek&quot;:

    [DllImport(&quot;libc&quot;)]
    extern public static off_t lseek(int_t fd, off_t offset, int_t
whence);

This is probably the &quot;prettiest&quot; so far out of all the proposals.
The presence of the &quot;PosixType&quot; attribute tells the runtime engine
that it needs to adjust the representation of the type to match
the same-named Posix type (&quot;off_t&quot; and &quot;int&quot; in these examples).

The implicit conversion operators take care of integrating the types
into C#'s type system in such a way that they act like regular
numeric types.

A small drawback of this approach is that it does involve a little
extra overhead to convert between primitive numeric values and
managed values.  However, the JIT should be able to optimize this
overhead away.

I think we can also extend this to handle the &quot;hell case&quot; of &quot;stat&quot;.
Consider the following definition:

    [PosixStructType]
    public struct stat
    {
        public dev_t st_dev;
        public ino_t st_ino;
        public mode_t st_mode;
        public nlink_t st_nlink;
        public uid_t st_uid;
        public gid_t st_gid;
        public dev_t st_rdev;
        public dev_t st_rdev;
        public off_t st_size;
        public blksize_t st_blksize;
        public time_t st_atime;
        public time_t st_ctime;
        public time_t st_mtime;
    };

We'll assume that all of the &quot;XXX_t&quot; types have been defined as above.

When the runtime engine sees the &quot;PosixStructType&quot;, it adjusts its
layout algorithm to map the fields to the correct offsets in the
underlying OS type.

The above definition does not include any of the padding and unused
fields that are present on Linux.  But this doesn't matter because
the runtime engine only cares about things for which it has a name
match.  Everything else is left as a gap.

I've also reversed the usual order for &quot;st_mtime&quot; and &quot;st_ctime&quot; above,
and this doesn't matter either.  The engine will assign offsets based
on their real positions, not their declaration order.

The &quot;stat&quot; method is declared as follows:

    [DllImport(&quot;libc&quot;)]
    extern unsafe public static int_t stat(string pathname, stat *buf);

I think this should solve most of the nasty cases in mapping to
and from Posix types.  Thoughts?

Cheers,

Rhys.




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000936.html">[Mono-list] Tests
</A></li>
	<LI> Next message: <A HREF="000934.html">[Mono-list] PInvoke:TNG
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#931">[ date ]</a>
              <a href="thread.html#931">[ thread ]</a>
              <a href="subject.html#931">[ subject ]</a>
              <a href="author.html#931">[ author ]</a>
         </LI>
       </UL>
</body></html>
