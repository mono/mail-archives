<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] PInvoke Conventions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:fjh%40cs.mu.oz.au">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001016.html">
   <LINK REL="Next"  HREF="001025.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] PInvoke Conventions
   </H1>
    <B>Fergus Henderson
    </B> 
    <A HREF="mailto:fjh%40cs.mu.oz.au"
       TITLE="[Mono-list] PInvoke Conventions">fjh@cs.mu.oz.au
       </A><BR>
    <I>Tue, 31 Jul 2001 09:37:58 +1000</I>
    <P><UL>
        <LI> Previous message: <A HREF="001016.html">[Mono-list] PInvoke Conventions
</A></li>
        <LI> Next message: <A HREF="001025.html">[Mono-list] PInvoke Conventions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1019">[ date ]</a>
              <a href="thread.html#1019">[ thread ]</a>
              <a href="subject.html#1019">[ subject ]</a>
              <a href="author.html#1019">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 30-Jul-2001, James Perry &lt;<A HREF="mailto:jeperry@uwaterloo.ca">jeperry@uwaterloo.ca</A>&gt; wrote:
&gt;<i> 
</I>&gt;<i> I'm looking at the System.Runtime.InteropServices namespace, and in
</I>&gt;<i> particular: StructLayoutAttribute, Marshall, MarshalAs and UnmanagedType.
</I>&gt;<i> The obvious implementation of PInvoke (at least, to me) would be to
</I>&gt;<i> implement it using Marshall and then define the actual values using
</I>&gt;<i> [StructLayout] and MarshalAs - a platform dependent wrapper might be
</I>&gt;<i> necessary, but at least using these _specified_ parts of the runtime and
</I>&gt;<i> class library, PInvoke and all of its platform dependent wrappers can be
</I>&gt;<i> written in C# without any needing any custom attributes (which would
</I>&gt;<i> restrict such code to Mono only).
</I>
Having platform-dependent *source code* seems to me to be a worse sin than
having platform-dependent object code.  That's why I think it would be
better to implement the wrappers in unmanaged C/C++.

However, I could live with the platform-dependent source code *if*
it could be isolated to a single module or two.

&gt;<i> Looking at UnmanagedType and
</I>&gt;<i> StructLayoutAttribute, it seems to me that most POSIX platforms could be
</I>&gt;<i> swept up in a single implementation - it'd take a pretty broken
</I>&gt;<i> implementation of POSIX to fool this.
</I>
I don't agree -- constant values, type sizes, and struct layouts differ
between different Posix platforms.  I don't see how you can do that
just using StructLayoutAttribute, MashalAs, or UnmanagedType and retain
source portability.  You'd have to write different source for different
platforms.

&gt;<i> The other suggested implementation, having external wrappers in unmanaged
</I>&gt;<i> code is plagued with similar problems. From the mono-development side, it's
</I>&gt;<i> again a lot of time doing a relatively simple, repetitive task (but not so
</I>&gt;<i> simple or repetitive to make it very easily scriptable), this time would be
</I>&gt;<i> usefull on other parts of the project. Also from the mono-development side,
</I>&gt;<i> it makes porting mono to other platforms difficult since you need a platform
</I>&gt;<i> dependend implementation of the library; this is mitigated by the fact it
</I>&gt;<i> could probably be done once and then left to an autoconf script to
</I>&gt;<i> fine-tune, but that is also a lot of work which ultimately means the runtime
</I>&gt;<i> developers are now faced with a much larger base of code they have to worry
</I>&gt;<i> about portability issues for which, for reason explained in the previous
</I>&gt;<i> paragraph, I think is a bad idea.
</I>
It's definitely a pain, but this kind of work is easily parallelizable
amongst multiple developers.  You only need to write the C code once,
and no autoconf script is needed unless the interface that you're trying to
wrap is actually different at the C source level on different platforms.

&gt;<i> When you start considering 3rd party developers (you know, the people who
</I>&gt;<i> would actually /use/ mono:) it's a major barrier for two reasons, one of
</I>&gt;<i> which hasn't been touched on yet. The first one means that if you want to
</I>&gt;<i> write something which talks to an external library you can either a) rewrite
</I>&gt;<i> the library in Mono (bad) or b) become responsible for writing a wrapper for
</I>&gt;<i> every platform mono supports (bad) or c) making a wrapper for a single
</I>&gt;<i> platform (defeats the point of using a platform independent architecture, so
</I>&gt;<i> bad). I can't see a good solution to this.
</I>
Write a single wrapper (in unmanaged C/C++) and compile it once for each
different platform.

Using native-code libraries will of course reduce the portability
of your code.  This should come as no surprise.  However, it doesn't
entirely defeat the point of using a platform independent architecture,
because although you need to distribute N copies of the wrappers, one
for each platform, once you've built the wrappers they are unlikely to
change much; whereas for your main application, which does change often,
you only need to distribute one copy.

I think you are exaggerating the drawbacks of this approach a bit.
But I agree that it does have significant drawbacks.

&gt;<i> Ultimately, even if the runtime interop stuff isn't sufficient for PInvoke,
</I>&gt;<i> it could be implemented in a platform dependent way that mitigates a lot of
</I>&gt;<i> the problems of the other two: have a shared library which describes the
</I>&gt;<i> platform dependencies in an abstract way (sizes of integers, sizes of chars,
</I>&gt;<i> etc...) and then have the logic to convert written in PInvoke based on this
</I>&gt;<i> information.
</I>
The trouble is that the &quot;etc...&quot; is large; it includes &quot;offset of tm_idst
in struct tm&quot;, &quot;size of nlink_t&quot;, &quot;value of O_CREAT&quot;, etc.

Still, it may be the best that we can do.
Doing it this way would probably make things easier for Mono users,
albeit at the expense of making things harder for Mono developers.

-- 
Fergus Henderson &lt;<A HREF="mailto:fjh@cs.mu.oz.au">fjh@cs.mu.oz.au</A>&gt;  |  &quot;I have always known that the pursuit
The University of Melbourne         |  of excellence is a lethal habit&quot;
WWW: &lt;<A HREF="http://www.cs.mu.oz.au/~fjh">http://www.cs.mu.oz.au/~fjh</A>&gt;  |     -- the last words of T. S. Garp.


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001016.html">[Mono-list] PInvoke Conventions
</A></li>
	<LI> Next message: <A HREF="001025.html">[Mono-list] PInvoke Conventions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1019">[ date ]</a>
              <a href="thread.html#1019">[ thread ]</a>
              <a href="subject.html#1019">[ subject ]</a>
              <a href="author.html#1019">[ author ]</a>
         </LI>
       </UL>
</body></html>
