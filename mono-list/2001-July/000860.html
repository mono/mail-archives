<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] JVM performance: JVM as a basis for CLR
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:saurik%40saurik.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000864.html">
   <LINK REL="Next"  HREF="000865.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] JVM performance: JVM as a basis for CLR
   </H1>
    <B>Jay Freeman (saurik)
    </B> 
    <A HREF="mailto:saurik%40saurik.com"
       TITLE="[Mono-list] JVM performance: JVM as a basis for CLR">saurik@saurik.com
       </A><BR>
    <I>Sat, 21 Jul 2001 23:18:36 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="000864.html">[Mono-list] JVM performance: JVM as a basis for CLR
</A></li>
        <LI> Next message: <A HREF="000865.html">[Mono-list] JVM performance: JVM as a basis for CLR
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#860">[ date ]</a>
              <a href="thread.html#860">[ thread ]</a>
              <a href="subject.html#860">[ subject ]</a>
              <a href="author.html#860">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Tom:

Regardless of the fact that I agree 100% on the comments of starting with a
JVM (especially ORP, as I've been arguing with Miguel about for months now),
this comparison isn't really that fair.  You are comparing Beta 2 of a
product that has _specifically_ been mentioned in the past by Microsoft to
not have been optimized for speed for purposes of the beta tests against a
standing JVM.

Secondly, the comparison also doesn't really mean anything.  I don't see
what you are trying to show by this... that Java byte-codes are a better
intedmediate representation than Microsoft IL for writing JITs?  I bet I
could find a JVM that performs worse than your JVM.  Does that mean that
Java byte-codes are a better intermediate representation than Java
byte-codes?  Just because a specific implementation of the CLR is worse off
than a specific implementation of a JVM doesn't mean that Mono couldn't be a
better implementation.  Whether that is feasible or not for Ximian with the
rushed planning process they've been using is another question entirely.

Worse yet, you are using a rather abstract test case that you don't actually
run into much in the real world (even in low-level stuff like 3D engines).
If you want a better comparison, check out
<A HREF="http://www.codeproject.com/useritems/sharphsql.asp">http://www.codeproject.com/useritems/sharphsql.asp</A> .  This guy ported a
relational database to C# from Java and ran various benchmarks and profilers
on the result.  Charts and graphs are posted on the page.  Note that there
is a noticable speed difference between C# and Java (C# not performing as
well) with the data in memory (but not when it is on disk).  Maybe there is
an actual performance issue in MS's VM here, but once again this is an
implementation issue, and nothing can be inferred from it about the
viability of the CLR as a platform.  Personally, my interpretation is the
same as this person's.

At this point I'd normally mention the project I started a few months ago to
work off of ORP (the one I couldn't get any interest from anyone in), but
I'm quite soured on it at this point and _I'm_ not even interested in it
anymore :-).

Sincerely,
Jay Freeman (saurik)
<A HREF="mailto:saurik@saurik.com">saurik@saurik.com</A>

----- Original Message -----
From: &quot;Tom&quot; &lt;<A HREF="mailto:tom7ca@yahoo.com">tom7ca@yahoo.com</A>&gt;
To: &lt;<A HREF="mailto:mono-list@ximian.com">mono-list@ximian.com</A>&gt;
Sent: Saturday, July 21, 2001 7:17 PM
Subject: [Mono-list] JVM performance: JVM as a basis for CLR


&gt;<i> Given that there have been lots of arguments against
</I>&gt;<i> basing a Mono runtime (CLI/CLR) on a JVM based on
</I>&gt;<i> performance, I was curious to see how well Microsoft's
</I>&gt;<i> CRL compares to Java VMs in terms of performance.  So,
</I>&gt;<i> without claiming that these are anywhere near complete
</I>&gt;<i> benchmarks, I tested two simple cases: &quot;fib&quot; and
</I>&gt;<i> &quot;convolution&quot;.
</I>&gt;<i>
</I>&gt;<i> On the &quot;fib&quot; benchmark (mostly function calls), CLR
</I>&gt;<i> performs considerably worse than Sun's JVM.  On the
</I>&gt;<i> convolution benchmark, they perform about the same.  I
</I>&gt;<i> gave the CLR the benefit of the doubt and compiled
</I>&gt;<i> with &quot;/unsafe+ /checked-&quot;.  Based on these little
</I>&gt;<i> benchmarks, I see no performance advantage to CLR.
</I>&gt;<i> This seems in agreement with other recent comparisons
</I>&gt;<i> of CLR and JVM.  I have yet to see any reproducible
</I>&gt;<i> evidence that the CLR actually performs significantly
</I>&gt;<i> better on any task; if you know of any (including
</I>&gt;<i> source code), I'd like to know about it.
</I>&gt;<i>
</I>&gt;<i> What does this mean?  I don't want to bring up the
</I>&gt;<i> issue of creating a Java foundation for Gnome, since
</I>&gt;<i> that's not where the project is going.  But I think it
</I>&gt;<i> suggests again that starting with a JVM implementation
</I>&gt;<i> may lead to a high quality CLR implementation much
</I>&gt;<i> faster than starting from scratch.  And starting with
</I>&gt;<i> a JVM may also make it easy to provide CLR and JVM
</I>&gt;<i> support in the same runtime from the start.  I think
</I>&gt;<i> that would be a really great contribution, and it
</I>&gt;<i> would allow the open source community to hedge its
</I>&gt;<i> bets on the C#-vs.-Java issue.
</I>&gt;<i>
</I>&gt;<i> As people have pointed out, Intel's ORP
</I>&gt;<i> (<A HREF="http://orp.sourceforge.net/">http://orp.sourceforge.net/</A>) indeed has a non-trivial
</I>&gt;<i> optimizing JIT.  OpenJIT (<A HREF="http://www.openjit.org/">http://www.openjit.org/</A>) may
</I>&gt;<i> also be worth a look.  I'm going to take a look and
</I>&gt;<i> see how they compare performance-wise to Sun's JDK
</I>&gt;<i> (this is a little easier since programs don't need to
</I>&gt;<i> be ported from one to the other).
</I>&gt;<i>
</I>&gt;<i> Tom.
</I>&gt;<i>
</I>&gt;<i> Here is the output from the benchmarks (this uses
</I>&gt;<i> JDK1.4beta, but JDK1.3 gives the same results):
</I>&gt;<i>
</I>...



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000864.html">[Mono-list] JVM performance: JVM as a basis for CLR
</A></li>
	<LI> Next message: <A HREF="000865.html">[Mono-list] JVM performance: JVM as a basis for CLR
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#860">[ date ]</a>
              <a href="thread.html#860">[ thread ]</a>
              <a href="subject.html#860">[ subject ]</a>
              <a href="author.html#860">[ author ]</a>
         </LI>
       </UL>
</body></html>
