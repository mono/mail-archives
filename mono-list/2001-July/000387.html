<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] x86 JIT
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jks6b%40cs.virginia.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000386.html">
   <LINK REL="Next"  HREF="000232.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] x86 JIT
   </H1>
    <B>Kevin Scott
    </B> 
    <A HREF="mailto:jks6b%40cs.virginia.edu"
       TITLE="[Mono-list] x86 JIT">jks6b@cs.virginia.edu
       </A><BR>
    <I>Wed, 11 Jul 2001 16:31:58 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="000386.html">[Mono-list] x86 JIT
</A></li>
        <LI> Next message: <A HREF="000232.html">[Mono-list] Perplexed and intrigued by ECMA licensing of .Net
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#387">[ date ]</a>
              <a href="thread.html#387">[ thread ]</a>
              <a href="subject.html#387">[ subject ]</a>
              <a href="author.html#387">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>In message &lt;000201c10a42$f7dd4f80$<A HREF="mailto:1699b48c@cp102230a">1699b48c@cp102230a</A>&gt;, &quot;John Zedlewski&quot; writes:
&gt;&gt;<i> Maybe I'm missing something, but how does this scheme communicate to
</I>&gt;<i>the
</I>&gt;&gt;<i> collector which temporaries and registers contain pointers to objects.
</I>&gt;<i>
</I>&gt;<i>Kevin, 
</I>&gt;<i>  You're actually dead right, the scheme I mentioned doesn't say
</I>&gt;<i>anything about registers or temps, because I think that would be highly
</I>&gt;<i>dependent on the exact garbage collector style you want to use.  I think
</I>&gt;<i>the traditional approach is to say that GC can only occur at inserted
</I>&gt;<i>&quot;safe points&quot; where the format of the temporaries and registers is
</I>&gt;<i>known. Since CLI lets you stack-allocate local objects, it doesn't use
</I>&gt;<i>nearly as many local references to GC-described objects as, say, the
</I>&gt;<i>JVM, so we get off kind of easy with the number of local sites we need
</I>&gt;<i>to monitor.
</I>
Right.  But I thought you were proposing a scheme for a gcc-based CLR to
do precise garbage collection.  It seems to me like describing pointer
maps to gcc and getting the compiler to accurately maintain them through 
the optimization process is going to require more work than just inlining 
a function at the object allocation site.  Stack allocation or no, you're 
still going to have registers and possibly temps pointing to heap allocated 
objects.  And if you don't know when and where a pointer might be in a 
register or temporary, you're going to have be conservative when collecting 
objects.  

It seems like the advantage of stack allocation is that it doesn't so much
matter that your GC is conservative -- stack allocated objects just go away 
when the allocating function returns.  And maybe that plus a conservative
collector to get rid of most of the dead heap objects is good enough for 
most programs.

-K

--
Kevin Scott                          PhD Student,  Dept. of Computer Science
<A HREF="mailto:kscott@cs.virginia.edu">kscott@cs.virginia.edu</A>                       University of Virginia       
<A HREF="http://www.cs.virginia.edu/~jks6b">http://www.cs.virginia.edu/~jks6b</A>            +1 804 982 2391 (work)


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000386.html">[Mono-list] x86 JIT
</A></li>
	<LI> Next message: <A HREF="000232.html">[Mono-list] Perplexed and intrigued by ECMA licensing of .Net
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#387">[ date ]</a>
              <a href="thread.html#387">[ thread ]</a>
              <a href="subject.html#387">[ subject ]</a>
              <a href="author.html#387">[ author ]</a>
         </LI>
       </UL>
</body></html>
