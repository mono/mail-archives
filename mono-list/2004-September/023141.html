<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Memory Allocation in unmanaged code
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="023140.html">
   <LINK REL="Next"  HREF="023138.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Memory Allocation in unmanaged code
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] Memory Allocation in unmanaged code">jonpryor@vt.edu
       </A><BR>
    <I>Mon, 06 Sep 2004 18:57:25 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="023140.html">[Mono-list] Memory Allocation in unmanaged code
</A></li>
        <LI> Next message: <A HREF="023138.html">[Mono-list] OpenGL# 0.2.0
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23141">[ date ]</a>
              <a href="thread.html#23141">[ thread ]</a>
              <a href="subject.html#23141">[ subject ]</a>
              <a href="author.html#23141">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Below...

On Fri, 2004-09-03 at 20:10, Jim Fehlig wrote:
&gt;<i> I am having difficulty with a C# wrapper for some unmanaged C code
</I>&gt;<i> that allocates a list.  Unmanaged code snippet: 
</I>&gt;<i>    typedef struct CupsPrinterListStruct 
</I>&gt;<i>    { 
</I>&gt;<i>        char printerUri[1024]; 
</I>&gt;<i>        char printerCupsUri[1024]; 
</I>&gt;<i>        char printerName[1024]; 
</I>&gt;<i>        char printerMakeAndModel[256]; 
</I>&gt;<i>        struct CupsPrinterListStruct *nextPtr; 
</I>&gt;<i>    }CupsPrinterList; 
</I>&gt;<i>    int ListLocalPrinters(CupsPrinterList **printerList); 
</I>&gt;<i>    int FreeLocalPrinterList(CupsPrinterList *listHead); 
</I>
As Marcus mentioned, changing your C# struct to a class allows your code
to work.  Whether that is correct is another matter.
 
Correctness depends upon the ListLocalPrinters() documentation.  What is
`printerList' supposed to be?  Just a pointer to a
CupsPrinterListStruct*?  Or should it be an array of pointers?  How many
elements will be addressed?

This is rather important because if ListLocalPrinters() uses
`printerList' as an array, then it will corrupt memory.  If
ListLocalPrinters() *allocates* an array, then a C# class will only pick
up the first element of the array, and leak the rest.  Further, you have
memory allocator issues: a C# &quot;class&quot; will cause the runtime to free the
returned pointer using CoTaskMemAlloc() (Windows) or g_free() (Linux). 
Given that presumably FreeLocalPrinterList() should be used, this could
also lead to memory corruption.

The &quot;safe&quot; thing to do is (1) continue to use a C# struct, and (2) use
&quot;unsafe&quot; code and casting to retrieve information.  The following
pseudo-code assumes that ListLocalPrinters() takes a pointer to a
CupsPrinterListStruct* (e.g. pointer to a pointer to a single element,
and ListLocalPrinters() will allocate that element).

	// Warning: untested code, but should get the point across

	// public user-visible class, NOT used for interop
	public class PrinterList {
		public string Uri, CupsUri, 
			Name, MakeModel;
	}

	public unsafe class PrintLibWrapper {
		// Convert linked-list to an array
		[DllImport]
		private static extern int ListLocalPrinters (ref IntPtr p);
		[DllImport]
		private static extern int FreeLocalPrinterList(IntPtr p);

		// struct for interop purposes
		private unsafe struct CupsPrinterList {
			// TODO: add element attributes
			public string printerUri, printerCupsUri, printerName,
				printerMakeModel;
			public CupsPrinterList* nextElement;
		}

		// Convert linked list to array
		public unsafe PrinterList[] ListLocalPrinters ()
		{
                        IntPtr list = IntPtr.Zero;
                        
                        try {
                                // TODO: check return value
                        	ListLocalPrinters (ref list);
                                
                                CupsPrinterList* printer = (PrinterList*) list;
                                
                                ArrayList printers = new ArrayList();
                                
                                // traverse linked list, adding each element to 
                                // printers
                                while (printer != null) {
                                	// copy data
                                	PrinterList pl = new PrinterList ();
                                	pl.Uri = printer-&gt;printerUri;
                                	pl.CupsUri = printer-&gt;printerCupsUri;
                                	pl.Name = printer-&gt;printerName;
                                	pl.MakeModel = printer-&gt;printerMakeModel;
                                
                                	printers.add (pl);
                                	printer = printer-&gt;nextElement;
                                }
                                
                                PrinterList[] rval = new PrinterList[printers.Count];
                                printers.CopyTo (rval);
                                
                                return rval;
                        }
                        finally {
                        	if (list != IntPtr.Zero)
                        		FreeLocalPrintersList (list);
                        }
                        return new PrinterList[0];
		}
	}

The above proves I can't write short pseudo-code.  You also need to be
careful about exception-safety, as you don't want to leak unmanaged
memory.

For more information, see:

	<A HREF="http://www.jprl.com/~jon/interop.html">http://www.jprl.com/~jon/interop.html</A>

 - Jon



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="023140.html">[Mono-list] Memory Allocation in unmanaged code
</A></li>
	<LI> Next message: <A HREF="023138.html">[Mono-list] OpenGL# 0.2.0
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23141">[ date ]</a>
              <a href="thread.html#23141">[ thread ]</a>
              <a href="subject.html#23141">[ subject ]</a>
              <a href="author.html#23141">[ author ]</a>
         </LI>
       </UL>
</body></html>
