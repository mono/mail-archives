<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] generic KeyedCollection implementation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20generic%20KeyedCollection%20implementation&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029090.html">
   <LINK REL="Next"  HREF="029103.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] generic KeyedCollection implementation</H1>
    <B>Carlo Kok</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20generic%20KeyedCollection%20implementation&In-Reply-To="
       TITLE="[Mono-list] generic KeyedCollection implementation">ck at carlo-kok.com
       </A><BR>
    <I>Wed Oct 19 05:59:53 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="029090.html">[Mono-list] Mono and MS Office suite
</A></li>
        <LI>Next message: <A HREF="029103.html">[Mono-list] generic KeyedCollection implementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29091">[ date ]</a>
              <a href="thread.html#29091">[ thread ]</a>
              <a href="subject.html#29091">[ subject ]</a>
              <a href="author.html#29091">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Attached to this email an incremental patch for the KeyedCollection ( to 
be applied in the \mcs\class\corlib\System.Collections.ObjectModel 
directory. Also included is a testcase, tested with both Beta2 and my 
own implementation.

I followed the existing testcases I could find in SVN. The two almost 
idental guides on the wiki seem to be out of date:

<A HREF="http://www.mono-project.com/Test_Suite">http://www.mono-project.com/Test_Suite</A>
<A HREF="http://www.mono-project.com/Mono_Contribution_HOWTO">http://www.mono-project.com/Mono_Contribution_HOWTO</A>

comments?

I used the SVN Patch ability of tortoisesvn, if I did that wrong, please 
tell me what I should use instead.

--
Carlo Kok
-------------- next part --------------
Index: Collection.cs
===================================================================
--- Collection.cs	(revision 51865)
+++ Collection.cs	(working copy)
@@ -68,11 +68,17 @@
 
 		public void Add (T item)
 		{
-			list.Add (item);			
+			int idx = list.Count;
+			InsertItem (idx, item);
 		}
 
 		public void Clear ()
 		{
+			ClearItems ();
+		}
+
+		protected virtual void ClearItems ()
+		{
 			list.Clear ();
 		}
 
@@ -98,16 +104,32 @@
 
 		public void Insert (int index, T item)
 		{
+			InsertItem (index, item);
+		}
+
+		protected virtual void InsertItem (int index, T item)
+		{
 			list.Insert (index, item);
 		}
 
 		public bool Remove (T item)
 		{
-			return list.Remove (item);
+			int idx = IndexOf (item);
+			if (idx == -1) 
+				return false;
+			
+			RemoveItem (idx);
+			
+			return true;
 		}
 
 		public void RemoveAt (int index)
 		{
+			RemoveItem (index);
+		}
+
+		protected virtual void RemoveItem (int index)
+		{
 			list.RemoveAt (index);
 		}
 
@@ -117,12 +139,18 @@
 
 		public virtual T this [int index] {
 			get { return list [index]; }
-			set { list [index] = value; }
+			set { SetItem (index, value); }
 		}
 
 		public bool IsReadOnly {
 			get { return list.IsReadOnly; }
 		}
+
+		protected virtual void SetItem (int index, T item)
+		{
+			list[index] = item;
+		}
+
 		
 #region Helper methods for non-generic interfaces
 		
@@ -173,8 +201,9 @@
 				
 		int IList.Add (object item)
 		{
-			list.Add (ConvertItem (item));
-			return list.Count - 1;
+			int idx = list.Count;
+			InsertItem (idx, ConvertItem (item));
+			return idx;
 		}
 		
 		bool IList.Contains (object item)
@@ -193,13 +222,16 @@
 		
 		void IList.Insert (int index, object item)
 		{
-			list.Insert (index, ConvertItem (item));
+			InsertItem (index, ConvertItem (item));
 		}
 		
 		void IList.Remove (object item)
 		{
 			CheckWritable (list);
-			list.Remove (ConvertItem (item));
+
+			int idx = IndexOf (ConvertItem (item));
+
+			RemoveItem (idx);
 		}
 		
 		bool ICollection.IsSynchronized {
@@ -219,7 +251,7 @@
 		
 		object IList.this [int index] {
 			get { return list [index]; }
-			set { list [index] = ConvertItem (value); }
+			set { SetItem (index, ConvertItem (value)); }
 		}
 #endregion
 	}
Index: KeyedCollection.cs
===================================================================
--- KeyedCollection.cs	(revision 51865)
+++ KeyedCollection.cs	(working copy)
@@ -42,58 +42,167 @@
 	[Serializable]
 	public abstract class KeyedCollection&lt;TKey, TItem&gt; : Collection&lt;TItem&gt;
 	{
+		private Dictionary&lt;TKey, TItem&gt; dictionary;
+		private IEqualityComparer&lt;TKey&gt; comparer;
+		private int dictionaryCreationThreshold;
+
+		protected KeyedCollection ()
+			: this (null, 0)
+		{ 
+		}
+
+		protected KeyedCollection (IEqualityComparer&lt;TKey&gt; comparer)
+			: this(comparer, 0)
+		{
+		}
+
+		protected KeyedCollection (IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold)
+		{
+			if (comparer != null)
+				this.comparer = comparer;
+			else
+				this.comparer = EqualityComparer&lt;TKey&gt;.Default;
+
+			this.dictionaryCreationThreshold = dictionaryCreationThreshold;
+
+			if (dictionaryCreationThreshold == 0)
+				dictionary = new Dictionary&lt;TKey, TItem&gt; (this.comparer);
+		}
+
 		public bool Contains (TKey key)
 		{
-			throw new NotImplementedException ();
+			if (dictionary != null)
+				return dictionary.ContainsKey (key);
+			return IndexOfKey (key) &gt;= 0;
 		}
 
+		private int IndexOfKey (TKey key)
+		{
+			for (int i = Count - 1; i &gt;= 0; i--)
+			{
+				TKey lkey = GetKeyForItem (this [i]);
+				if (comparer.Equals (key, lkey))
+					return i;
+			}
+			return -1;
+		}
+
 		public bool Remove (TKey key)
 		{
-			throw new NotImplementedException ();
+			TItem item;
+			if (dictionary != null)
+			{
+				if (dictionary.TryGetValue (key, out item))
+					return base.Remove(item);
+				else
+					return false;
+			}
+
+			int idx = IndexOfKey (key);
+
+			if (idx == -1)
+				return false;
+			
+			RemoveAt(idx);
+			return true;
 		}
 
 		public IEqualityComparer&lt;TKey&gt; Comparer {
 			get {
-				throw new NotImplementedException ();
+				return comparer;
 			}
 		}
 
-		public TItem this[TKey key] {
+		public TItem this [TKey key] {
 			get {
-				throw new NotImplementedException ();
+				if (dictionary != null)
+					return dictionary [key];
+
+				int idx = IndexOfKey (key);
+				if (idx &gt;= 0)
+					return base [idx];
+				else
+					throw new KeyNotFoundException();
 			}
 		}
 
 		protected void ChangeItemKey (TItem item, TKey newKey)
 		{
-			throw new NotImplementedException ();
+			if (!Contains(item)) throw new ArgumentException();
+
+			TKey oldKey = GetKeyForItem (item);
+			if (comparer.Equals (oldKey, newKey)) return;
+
+			if (Contains (newKey)) throw new ArgumentException();
+			if (dictionary != null)
+			{
+
+				if (!dictionary.Remove (oldKey))
+					throw new ArgumentException();
+
+				dictionary.Add (newKey, item);
+			}
 		}
 
-		protected void ClearItems ()
+		protected override void ClearItems ()
 		{
-			throw new NotImplementedException ();
+			if (dictionary != null)
+			{
+				dictionary.Clear();
+			}
+
+			base.ClearItems ();
 		}
 
 		protected abstract TKey GetKeyForItem (TItem item);
 
-		protected virtual void InsertItem (int index, TItem item)
+		protected override void InsertItem (int index, TItem item)
 		{
-			throw new NotImplementedException ();
+			if (dictionary != null)
+			{
+				dictionary.Add (GetKeyForItem (item), item);
+			}
+			else
+			{
+				if (dictionaryCreationThreshold != -1 &amp;&amp; Count + 1 &gt; dictionaryCreationThreshold)
+				{
+					dictionary = new Dictionary&lt;TKey, TItem&gt; (comparer);
+
+					for (int i = Count - 1; i &gt;= 0; i--)
+					{
+						TItem dictitem = this[i];
+						dictionary.Add(GetKeyForItem(dictitem), dictitem);
+					}
+
+					dictionary.Add (GetKeyForItem (item), item);
+				}
+			}
+			base.InsertItem (index, item);
 		}
 
-		protected virtual void RemoveItem (int index)
+		protected override void RemoveItem (int index)
 		{
-			throw new NotImplementedException ();
+			if (dictionary != null)
+			{
+				TKey key = GetKeyForItem (this [index]);
+				dictionary.Remove (key);
+			}
+			base.RemoveItem (index);
 		}
 
-		protected virtual void SetItem (int index, TItem item)
+		protected override void SetItem (int index, TItem item)
 		{
-			throw new NotImplementedException ();
+			if (dictionary != null)
+			{
+				dictionary.Remove (GetKeyForItem (this [index]));
+				dictionary.Add (GetKeyForItem (item), item);
+			}
+			base.SetItem (index, item);
 		}
 
 		protected IDictionary&lt;TKey, TItem&gt; Dictionary {
 			get {
-				throw new NotImplementedException ();
+				return dictionary;
 			}
 		}
 	}
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 51865)
+++ ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2005-10-19  Carlo Kok  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">ck at carlo-kok.com</A>&gt;
+
+        * Added virtual ClearItems, InsertItem, RemoveItem, SetITem
+        * Implemented KeyedCollection
+		
 2005-06-19  David Waite  &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">mass at akuma.org</A>&gt;
 
         * Collection.cs ReadonlyCollection.cs: Implement all methods
-------------- next part --------------
// KeyedCollectionTest.cs - NUnit Test Cases for System.Collections.ObjectModel.KeyedCollection
//
// Carlo Kok (<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">ck at carlo-kok.com</A>)
//
// (C) Carlo Kok
// 

#if NET_2_0
using NUnit.Framework;
using System;
using System.Globalization;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace MonoTests.System.Collections.ObjectModel
{

  [TestFixture]
  public class KeyedCollectionTest 
  {

    private class CaseInsensitiveComparer : IEqualityComparer&lt;string&gt;
    {
      public CaseInsensitiveComparer() { }
      #region IEqualityComparer&lt;string&gt; Members

      public bool Equals(string x, string y)
      {
        return String.Compare(x, y, true, CultureInfo.InvariantCulture) == 0;
      }

      public int GetHashCode(string obj)
      {
        return obj.ToUpper(CultureInfo.InvariantCulture).GetHashCode();
      }

      #endregion
}

    private class StrKeyCollection : KeyedCollection&lt;string, string&gt;
    {
      public StrKeyCollection(IEqualityComparer&lt;string&gt; comparer, int dictionaryCreationThreshold): base(comparer, dictionaryCreationThreshold)
      {
      }

      protected override string GetKeyForItem(string item)
      {
        return &quot;Key:&quot; + item;
      }

      public IDictionary&lt;string, string&gt; GetDictionary()
      {
        return Dictionary;
      }
    }

    public KeyedCollectionTest()
    {
    }

    [Test]
    public void TestDelete()
    {
      StrKeyCollection collection = new StrKeyCollection(EqualityComparer&lt;string&gt;.Default, 2);
      collection.Add(&quot;One&quot;); // Key:First
      collection.Add(&quot;Two&quot;); // Key:Two
      Assert.IsTrue(collection.Remove(&quot;Key:One&quot;));
      collection.Add(&quot;Four&quot;); // Key:Four
      collection.Insert(2, &quot;Three&quot;); // Key:Three
      Assert.IsTrue(collection.Remove(&quot;Key:Three&quot;));

      Assert.IsFalse(collection.Remove(&quot;Unknown&quot;));

      Assert.AreEqual(collection.GetDictionary().Count, 2);


      Assert.AreEqual(collection.Count, 2, &quot;Collection count not equal to 2&quot;);
      // check if all items are ordered correctly

      Assert.AreEqual(collection[0], &quot;Two&quot;);
      Assert.AreEqual(collection[1], &quot;Four&quot;);

      Assert.AreEqual(collection[&quot;Key:Two&quot;], &quot;Two&quot;);
      Assert.AreEqual(collection[&quot;Key:Four&quot;], &quot;Four&quot;);

      try
      {
        collection[&quot;Key:One&quot;].ToString();
        Assert.Fail(&quot;Unknown key should fail&quot;);
      }
      catch (KeyNotFoundException e)
      {
        e.ToString(); // avoid warning
        // oke
      }

      try
      {
        collection[&quot;Key:One&quot;].ToString();
        Assert.Fail(&quot;Unknown key should fail&quot;);
      }
      catch (KeyNotFoundException e)
      {
        e.ToString(); // avoid warning
        // oke
      }
    }

    [Test]
    public void TestInsert()
    {
      StrKeyCollection collection = new StrKeyCollection(EqualityComparer&lt;string&gt;.Default, 2);
      
      Assert.IsNull(collection.GetDictionary(), &quot;Dictionary created too early&quot;); // There can't be a dictionary yet
      
      collection.Add(&quot;One&quot;); // Key:First

      Assert.IsNull(collection.GetDictionary(), &quot;Dictionary created too early&quot;); // There can't be a dictionary yet

      collection.Add(&quot;Two&quot;); // Key:Two

      Assert.IsNull(collection.GetDictionary(), &quot;Dictionary created too early&quot;); // There can't be a dictionary yet

      collection.Add(&quot;Four&quot;); // Key:Four

      Assert.IsNotNull(collection.GetDictionary(), &quot;Dictionary created too late&quot;); // There must be a dictionary 
      
      collection.Insert(2, &quot;Three&quot;); // Key:Three

      Assert.AreEqual(collection.Count, 4, &quot;Collection count not equal to 4&quot;);
      // check if all items are ordered correctly

      Assert.AreEqual(collection[0], &quot;One&quot;);
      Assert.AreEqual(collection[1], &quot;Two&quot;);
      Assert.AreEqual(collection[2], &quot;Three&quot;);
      Assert.AreEqual(collection[3], &quot;Four&quot;);

      Assert.AreEqual(collection[&quot;Key:One&quot;], &quot;One&quot;);
      Assert.AreEqual(collection[&quot;Key:Two&quot;], &quot;Two&quot;);
      Assert.AreEqual(collection[&quot;Key:Three&quot;], &quot;Three&quot;);
      Assert.AreEqual(collection[&quot;Key:Four&quot;], &quot;Four&quot;);

      Assert.AreEqual(collection.GetDictionary().Count, 4);

      try
      {
        collection[&quot;UnkownKey&quot;].ToString();
        Assert.Fail(&quot;Unknown key should fail&quot;);
      }
      catch(KeyNotFoundException e)
      {
        e.ToString(); // avoid warning
        // oke
      }
    }
  }
}
#endif
</PRE>












<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029090.html">[Mono-list] Mono and MS Office suite
</A></li>
	<LI>Next message: <A HREF="029103.html">[Mono-list] generic KeyedCollection implementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29091">[ date ]</a>
              <a href="thread.html#29091">[ thread ]</a>
              <a href="subject.html#29091">[ subject ]</a>
              <a href="author.html#29091">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
