<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Deep Marshaling
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Deep%20Marshaling&In-Reply-To=1129893450.5090.69.camel%40localhost.localdomain">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029117.html">
   <LINK REL="Next"  HREF="029142.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Deep Marshaling</H1>
    <B>Giuseppe Greco</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Deep%20Marshaling&In-Reply-To=1129893450.5090.69.camel%40localhost.localdomain"
       TITLE="[Mono-list] Deep Marshaling">giuseppe.greco at agamura.com
       </A><BR>
    <I>Sun Oct 23 09:21:18 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="029117.html">[Mono-list] Deep Marshaling
</A></li>
        <LI>Next message: <A HREF="029142.html">[Mono-list] Deep Marshaling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29139">[ date ]</a>
              <a href="thread.html#29139">[ thread ]</a>
              <a href="subject.html#29139">[ subject ]</a>
              <a href="author.html#29139">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jon,

that you said is really interesting... and I'm wondering how
can I solve another similar problem. Giving the following type:

[StructLayout(LayoutKind.Sequential)]
internal struct MyStruct
{
     public int Id;
     public byte[] Data;       // of course, that's wrong!!!
}

... I'd like to fill it like this:

public unsafe void FillMyStruct(string s)
{
     //
     // convert the given string into a byte array
     //
     byte[] data = Encoding.UTF8.GetBytes(s);

     //
     // create another byte array for storing
     // a new instance of MyStruct
     //
     byte[] buffer = new byte[
         sizeof(int)    // Size of MyStruct.Id
       + data.Length];  // Length of MyStruct.Data

     //
     // fill the buffer
     //
     fixed (byte* pBuffer = buffer) {
         MyStruct* pMyStruct = (MyStruct*) pBuffer;
         pMyStruct-&gt;Id = 100; // OK
         pMyStruct-&gt;Data = data; // ERROR
     }
}

Any help would be really appreciated,
j3d.

Jonathan Pryor wrote:
&gt;<i> On Thu, 2005-10-20 at 16:07 -0700, Shankari wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i>While marshalling class and structure members, Mono
</I>&gt;&gt;<i>doesnt do a deep marshal.
</I>&gt;&gt;<i>If the structure has a string member, a default of
</I>&gt;&gt;<i>charset.auto is set.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Would you prefer some other default?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>But if the structure has an array of integers, what
</I>&gt;&gt;<i>would be done in that case?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> You could always try it... :-)
</I>&gt;<i> 
</I>&gt;<i> And get this:
</I>&gt;<i> 
</I>&gt;<i>         ** ERROR **: Structure field of type Int16[] can't be marshalled
</I>&gt;<i>         as LPArray
</I>&gt;<i>         aborting...
</I>&gt;<i>         Aborted
</I>&gt;<i> 
</I>&gt;<i> That was for marshaling this structure:
</I>&gt;<i> 
</I>&gt;<i>         struct Outer {
</I>&gt;<i>                 public int size;
</I>&gt;<i>                 public short[] inner;
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i> For which the corresponding C structure would be:
</I>&gt;<i> 
</I>&gt;<i>         struct Outer {
</I>&gt;<i>                 int size;
</I>&gt;<i>                 short *inner;
</I>&gt;<i>         };
</I>&gt;<i> 
</I>&gt;<i> However, *this* does marshal correctly:
</I>&gt;<i> 
</I>&gt;<i>         // C#
</I>&gt;<i>         struct Outer {
</I>&gt;<i>                 int size;
</I>&gt;<i>                 [MarshalAs (UnmanagedType.ByValArray, SizeConst=100)]
</I>&gt;<i>                 short[] inner;
</I>&gt;<i>         }
</I>&gt;<i>         
</I>&gt;<i>         /* C */
</I>&gt;<i>         struct Outer {
</I>&gt;<i>                 int size;
</I>&gt;<i>                 short inner [100];
</I>&gt;<i>         };
</I>&gt;<i>         
</I>&gt;<i> But the above structure has very different semantics than the previous
</I>&gt;<i> pair.
</I>&gt;<i> 
</I>&gt;&gt;<i>From this we can see theorize that Mono's marshaler doesn't like nested
</I>&gt;<i> pointers, unless those pointers are for strings.
</I>&gt;<i> 
</I>&gt;<i> There are workarounds.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>In general, if an array of simple types is a member of
</I>&gt;&gt;<i>the structure , how would it be marshalled(if at all)?
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> It depends on what the C layout is like.  If the array is &quot;inline&quot;, e.g.
</I>&gt;<i> 
</I>&gt;<i>         struct Foo {
</I>&gt;<i>                 char inline_array [100];
</I>&gt;<i>         };
</I>&gt;<i> 
</I>&gt;<i> Then you can use [MarshalAs (UnmanagedType.ByValArray, SizeConst=100)]
</I>&gt;<i> on the appropriate member:
</I>&gt;<i> 
</I>&gt;<i>         struct Foo {
</I>&gt;<i>                 [MarshalAs (UnmanagedType.ByValArray, SizeConst=100)]
</I>&gt;<i>                 public byte[] inline_array;
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i> If the structure member is a *pointer* to the arrar, e.g.
</I>&gt;<i> 
</I>&gt;<i>         struct Foo {
</I>&gt;<i>                 char *external_array;
</I>&gt;<i>         };
</I>&gt;<i> 
</I>&gt;<i> Then you'll need to marshal it manually; see the next answer, as the
</I>&gt;<i> solution applies to both built-in types and user-defined types.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>For array of user defined structures, I assume no
</I>&gt;&gt;<i>marshalling will be done. (Am I correct?)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> No marshaling will be done by default -- you'll abort the program instead.
</I>&gt;<i> 
</I>&gt;<i> If the default marshaler won't handle it, you can marshal it yourself.
</I>&gt;<i> It's not fun, but it's possible.
</I>&gt;<i> 
</I>&gt;<i> To marshal these structures:
</I>&gt;<i> 
</I>&gt;<i>         /* C */
</I>&gt;<i>         struct Inner {
</I>&gt;<i>                 char a, b;
</I>&gt;<i>         };
</I>&gt;<i>         
</I>&gt;<i>         struct Outer {
</I>&gt;<i>                 int size;
</I>&gt;<i>                 struct Inner *inner;
</I>&gt;<i>         };
</I>&gt;<i>         
</I>&gt;<i>         // C#
</I>&gt;<i>         struct Inner {
</I>&gt;<i>                 public byte a, b;
</I>&gt;<i>         }
</I>&gt;<i>         
</I>&gt;<i>         struct Outer {
</I>&gt;<i>                 public int size;
</I>&gt;<i>                 public IntPtr inner; // [1]
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i> The [1] comment is the first sign that we're doing things ourselves.  To
</I>&gt;<i> actually invoke a C function defined as:
</I>&gt;<i> 
</I>&gt;<i>         void PrintOuter(struct Outer *outer);
</I>&gt;<i> 
</I>&gt;<i> we'd need the C# code:
</I>&gt;<i> 
</I>&gt;<i>         [DllImport (&quot;test&quot;)]
</I>&gt;<i>         private static extern void PrintOuter (ref Outer outer);
</I>&gt;<i>         
</I>&gt;<i>         public static void Main ()
</I>&gt;<i>         {
</I>&gt;<i>                 // Create inner array to marshal
</I>&gt;<i>                 Inner[] inner = new Inner [26];
</I>&gt;<i>                 for (int i = 0; i &lt; inner.Length; ++i) {
</I>&gt;<i>                         inner [i].a = (byte) ((int) 'a' + i);
</I>&gt;<i>                         inner [i].b = (byte) ((int) 'z' - i)
</I>&gt;<i>                 }
</I>&gt;<i>                 
</I>&gt;<i>                 Outer o = new Outer ();
</I>&gt;<i>                 o.size = inner.Length;
</I>&gt;<i>                 
</I>&gt;<i>                 // Manually marshal the Inner[] to an IntPtr
</I>&gt;<i>                 int inner_size = Marshal.SizeOf (typeof(Inner));
</I>&gt;<i>                 o.inner = Marshal.AllocHGlobal
</I>&gt;<i>                 (inner_size*inner.Length);
</I>&gt;<i>                 for (int i = 0; i &lt; inner.Length; ++i) {
</I>&gt;<i>                         IntPtr p = (IntPtr) ((long) o.inner + (long)
</I>&gt;<i>                         i*inner_size)
</I>&gt;<i>                         Marshal.StructureToPtr (inner [i], p, false);
</I>&gt;<i>                 }
</I>&gt;<i>                 
</I>&gt;<i>                 // We're done!
</I>&gt;<i>                 PrintOuter (ref o);
</I>&gt;<i>                 
</I>&gt;<i>                 // Cleanup
</I>&gt;<i>                 Marshal.FreeHGlobal (o.inner);
</I>&gt;<i>         }
</I>&gt;<i> 
</I>&gt;<i> See the attached code:
</I>&gt;<i> 
</I>&gt;<i>         gcc -shared -o libsm.so sm.c
</I>&gt;<i>         mcs sm.cs
</I>&gt;<i>         LD_LIBRARY_PATH=`pwd` mono sm.exe
</I>&gt;<i> 
</I>&gt;<i>  - Jon
</I>&gt;<i> 
</I>&gt;<i> ------------------------------------------------------------------------
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">Mono-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>

-- 
----------------------------------------
Giuseppe Greco
::<i>agamura::
</I>
call giuseppe.greco via Skype
phone:  +41 (0)91 604 67 65
mobile: +41 (0)79 590 33 06
email:  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">giuseppe.greco at agamura.com</A>
web:    www.agamura.com
----------------------------------------
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029117.html">[Mono-list] Deep Marshaling
</A></li>
	<LI>Next message: <A HREF="029142.html">[Mono-list] Deep Marshaling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29139">[ date ]</a>
              <a href="thread.html#29139">[ thread ]</a>
              <a href="subject.html#29139">[ subject ]</a>
              <a href="author.html#29139">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
