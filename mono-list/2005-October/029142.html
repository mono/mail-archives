<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Deep Marshaling
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Deep%20Marshaling&In-Reply-To=435B8E4E.2080103%40agamura.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029139.html">
   <LINK REL="Next"  HREF="029143.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Deep Marshaling</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Deep%20Marshaling&In-Reply-To=435B8E4E.2080103%40agamura.com"
       TITLE="[Mono-list] Deep Marshaling">jonpryor at vt.edu
       </A><BR>
    <I>Sun Oct 23 14:53:25 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="029139.html">[Mono-list] Deep Marshaling
</A></li>
        <LI>Next message: <A HREF="029143.html">[Mono-list] Deep Marshaling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29142">[ date ]</a>
              <a href="thread.html#29142">[ thread ]</a>
              <a href="subject.html#29142">[ subject ]</a>
              <a href="author.html#29142">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sun, 2005-10-23 at 15:21 +0200, Giuseppe Greco wrote:
&gt;<i> Jon,
</I>&gt;<i> 
</I>&gt;<i> that you said is really interesting... and I'm wondering how
</I>&gt;<i> can I solve another similar problem. Giving the following type:
</I>&gt;<i> 
</I>&gt;<i> [StructLayout(LayoutKind.Sequential)]
</I>&gt;<i> internal struct MyStruct
</I>&gt;<i> {
</I>&gt;<i>      public int Id;
</I>&gt;<i>      public byte[] Data;       // of course, that's wrong!!!
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> ... I'd like to fill it like this:
</I>&gt;<i> 
</I>&gt;<i> public unsafe void FillMyStruct(string s)
</I>&gt;<i> {
</I>&gt;<i>      //
</I>&gt;<i>      // convert the given string into a byte array
</I>&gt;<i>      //
</I>&gt;<i>      byte[] data = Encoding.UTF8.GetBytes(s);
</I>&gt;<i> 
</I>&gt;<i>      //
</I>&gt;<i>      // create another byte array for storing
</I>&gt;<i>      // a new instance of MyStruct
</I>&gt;<i>      //
</I>&gt;<i>      byte[] buffer = new byte[
</I>&gt;<i>          sizeof(int)    // Size of MyStruct.Id
</I>&gt;<i>        + data.Length];  // Length of MyStruct.Data
</I>&gt;<i> 
</I>&gt;<i>      //
</I>&gt;<i>      // fill the buffer
</I>&gt;<i>      //
</I>&gt;<i>      fixed (byte* pBuffer = buffer) {
</I>&gt;<i>          MyStruct* pMyStruct = (MyStruct*) pBuffer;
</I>&gt;<i>          pMyStruct-&gt;Id = 100; // OK
</I>&gt;<i>          pMyStruct-&gt;Data = data; // ERROR
</I>&gt;<i>      }
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> Any help would be really appreciated,
</I>&gt;<i> j3d.
</I>
This has a fundamental problem associated with it: the Common Language
Infrastructure is *not* C or C++.  You can't subvert the type system
with random casting, as the runtime will *ensure* that all managed types
are used correctly.  This means that such things as C++ &quot;placement new&quot;
aren't possible.

For your particular example, it means that you can't take a pointer to a
type containing non-blittable types.  Thus declaring a `byte*' is safe,
but declaring a `System.Collections.ArrayList*' will yield this:

        error CS0208: Cannot take the address of, get the size of, or
        declare a pointer to a managed type
        `System.Collections.ArrayList'

The reason for this restriction is primarily the garbage collector.
ArrayList, and your MyStruct structure, contain managed arrays (object[]
for ArrayList, and byte[] for MyStruct).  The managed array needs to be
tracked by the garbage collector, lest Bad Things happen.  Consequently,
you cannot use these types in pointer context, as the GC can't safely
track it.

A solution would be to use only blittable types within your structure,
though since you seem to want to make Data a variable length array,
inline with the structure memory, this isn't entirely feasible.
Instead, you'd have to use a named &quot;first&quot; element of the array, and
then index off that, e.g.:

        struct VaribleLengthStruct {
                public int Size;
                public byte data_begin;
        }
        
        void Test ()
        {
                byte* buffer = stackalloc byte [
                        Marshal.SizeOf (VariableLengthStruct)+10
                ];
                VariableLengthStruct *p = (VariableLengthStruct*)
                buffer;
                p-&gt;Size = 10;
                byte* data = &amp;p-&gt;data_begin;
                for (int i = 0; i &lt; 10; ++i)
                        data [i] = (byte) i;
        }

The above is in fact how Mono's System.String handles things:

        public sealed class String // : ...
        {
                [NonSerialized] private int length;
                [NonSerialized] private char start_char;
        }

Can you provide more information about the problem you're *actually*
trying to solve?

 - Jon


</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029139.html">[Mono-list] Deep Marshaling
</A></li>
	<LI>Next message: <A HREF="029143.html">[Mono-list] Deep Marshaling
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29142">[ date ]</a>
              <a href="thread.html#29142">[ thread ]</a>
              <a href="subject.html#29142">[ subject ]</a>
              <a href="author.html#29142">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
