<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] this .net exe work for you?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20this%20.net%20exe%20work%20for%20you%3F&In-Reply-To=19138-17854%40sneakemail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029165.html">
   <LINK REL="Next"  HREF="029182.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] this .net exe work for you?</H1>
    <B>Abe Gillespie</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20this%20.net%20exe%20work%20for%20you%3F&In-Reply-To=19138-17854%40sneakemail.com"
       TITLE="[Mono-list] this .net exe work for you?">abe.gillespie at gmail.com
       </A><BR>
    <I>Tue Oct 25 19:01:13 EDT 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="029165.html">[Mono-list] this .net exe work for you?
</A></li>
        <LI>Next message: <A HREF="029182.html">[Mono-list] this .net exe work for you?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29167">[ date ]</a>
              <a href="thread.html#29167">[ thread ]</a>
              <a href="subject.html#29167">[ subject ]</a>
              <a href="author.html#29167">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Wow Jonathan, you're very generous.  What to donate some of you
copious amounts of time to my programming endeavours?  :)

-Abe

On 10/25/05, Jonathan Gilbert &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">2a5gjx302 at sneakemail.com</A>&gt; wrote:
&gt;<i> At 09:15 PM 24/10/2005 +0200, Jose Pascual wrote:
</I>&gt;<i> &gt;this .net exe work for you?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;(.net with winforms)
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;regards
</I>&gt;<i>
</I>&gt;<i> I have not tried running your EXE. However, I have decompiled it. For
</I>&gt;<i> anyone who is interested:
</I>&gt;<i>
</I>&gt;<i> Plain text: <A HREF="http://israel.logiclrd.cx/ThreadTester.cs">http://israel.logiclrd.cx/ThreadTester.cs</A>
</I>&gt;<i> Highlighted: <A HREF="http://israel.logiclrd.cx/ThreadTester.cs.html">http://israel.logiclrd.cx/ThreadTester.cs.html</A>
</I>&gt;<i>
</I>&gt;<i> Here is an analysis of your source code:
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i> using System;
</I>&gt;<i> using System.Collections;
</I>&gt;<i> using System.ComponentModel;
</I>&gt;<i> using System.Drawing;
</I>&gt;<i> using System.Threading;
</I>&gt;<i> using System.Windows.Forms;
</I>&gt;<i>
</I>&gt;<i> public abstract class Shapes
</I>&gt;<i> {
</I>&gt;<i>       // Methods
</I>&gt;<i>       public void CheckCoordinates()
</I>&gt;<i>       {
</I>&gt;<i>             if ((frm1.panel1.Size.Height - 20 &lt; yVal) || (yVal &lt;= 0))
</I>&gt;<i>                   directionY = directionY * -1;
</I>&gt;<i>
</I>&gt;<i>             if ((frm1.panel1.Size.Width - 20 &lt; xVal) || (xVal &lt;= 0))
</I>&gt;<i>                   directionX = directionX * -1;
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       public abstract void paint(Graphics g);
</I>&gt;<i>
</I>&gt;<i>       // Fields
</I>&gt;<i>       protected Color color;
</I>&gt;<i>       protected int directionX = 1;
</I>&gt;<i>       protected int directionY = 1;
</I>&gt;<i>       protected Form1 frm1;
</I>&gt;<i>       protected int height;
</I>&gt;<i>       protected int speed;
</I>&gt;<i>       protected int width;
</I>&gt;<i>       protected int xVal;
</I>&gt;<i>       protected int yVal;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public class Circle : Shapes
</I>&gt;<i> {
</I>&gt;<i>       // Methods
</I>&gt;<i>       public Circle(int x, int y, int w, int h, Color c, Form1 f, int spd)
</I>&gt;<i>       {
</I>&gt;<i>             this.xVal = x;
</I>&gt;<i>             this.yVal = y;
</I>&gt;<i>             this.color = c;
</I>&gt;<i>             this.width = w;
</I>&gt;<i>             this.height = h;
</I>&gt;<i>             this.frm1 = f;
</I>&gt;<i>             this.speed = spd;
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       public override void paint(Graphics g)
</I>&gt;<i>       {
</I>&gt;<i>             try
</I>&gt;<i>             {
</I>&gt;<i>                   Thread.Sleep(this.speed);
</I>&gt;<i>                   g.DrawEllipse(new Pen(this.frm1.BackColor), this.xVal,
</I>&gt;<i> this.yVal, this.width, this.height);
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Up to this point is okay.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>                   lock (typeof(Thread))
</I>&gt;<i>                   {
</I>&gt;<i>                         this.xVal += this.directionX;
</I>&gt;<i>                         this.yVal += this.directionY;
</I>&gt;<i>                         base.CheckCoordinates();
</I>&gt;<i>                   }
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> The above, however, is NOT okay. You don't even NEED the lock if the
</I>&gt;<i> current thread is the only thread accessing those variables, but assuming
</I>&gt;<i> the lock were required, you chose a very bad object to use. The 'Type'
</I>&gt;<i> object for Thread is global across the entire AppDomain, which means all
</I>&gt;<i> threads end up being forced to wait here while exactly one thread updates
</I>&gt;<i> its own local variables.
</I>&gt;<i>
</I>&gt;<i> This is also a very dangerous object to lock, because it is entirely
</I>&gt;<i> possible that the runtime might lock this object during some operation
</I>&gt;<i> which suspends all threads -- say, garbage collection -- and with the
</I>&gt;<i> thread holding the lock suspended, it could cause an unfixable deadlock.
</I>&gt;<i>
</I>&gt;<i> In the event that you do need to lock threads around a section of code
</I>&gt;<i> (which will only be the case when the different threads are accessing the
</I>&gt;<i> *same resource*), you need to use your own object to do the lock. You can
</I>&gt;<i> lock the object itself, or, generally considered better practice, you can
</I>&gt;<i> create an object specifically for locking:
</I>&gt;<i>
</I>&gt;<i> class Fuu
</I>&gt;<i> {
</I>&gt;<i>   public readonly SyncRoot = new object();
</I>&gt;<i>   public int Counter;
</I>&gt;<i>
</I>&gt;<i>   public void Increment()
</I>&gt;<i>   {
</I>&gt;<i>     lock (SyncRoot) // a safe object to lock
</I>&gt;<i>     {
</I>&gt;<i>       Counter = Counter + 1; // no race conditions here
</I>&gt;<i>     }
</I>&gt;<i>   }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>                   g.DrawEllipse(new Pen(this.color), this.xVal, this.yVal,
</I>&gt;<i> this.width, this.height);
</I>&gt;<i>             }
</I>&gt;<i>             catch (Exception exception) {}
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Why are you catching all exceptions here and ignoring them? Are you perhaps
</I>&gt;<i> *expecting* an exception to occur? The only reason that could be is that
</I>&gt;<i> when testing, you encountered exceptions here. The correct course of action
</I>&gt;<i> is to correct the code so that the exception doesn't happen. Very rarely
</I>&gt;<i> does it make sense to ignore *all* exceptions.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>       }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public class Rectangle : Shapes
</I>&gt;<i> {
</I>&gt;<i>       // Methods
</I>&gt;<i>       public Rectangle(int x, int y, int w, int h, Color c, Form1 f, int spd)
</I>&gt;<i>       {
</I>&gt;<i>             this.xVal = x;
</I>&gt;<i>             this.yVal = y;
</I>&gt;<i>             this.color = c;
</I>&gt;<i>             this.width = w;
</I>&gt;<i>             this.height = h;
</I>&gt;<i>             this.frm1 = f;
</I>&gt;<i>             this.speed = spd;
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       public override void paint(Graphics g)
</I>&gt;<i>       {
</I>&gt;<i>             try
</I>&gt;<i>             {
</I>&gt;<i>                   Thread.Sleep(this.speed);
</I>&gt;<i>                   g.DrawRectangle(new Pen(this.frm1.BackColor), this.xVal,
</I>&gt;<i> this.yVal, this.width, this.height);
</I>&gt;<i>                   lock (typeof(Thread))
</I>&gt;<i>                   {
</I>&gt;<i>                         this.xVal += this.directionX;
</I>&gt;<i>                         this.yVal += this.directionY;
</I>&gt;<i>                         base.CheckCoordinates();
</I>&gt;<i>                   }
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Same comment here as above.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>                   g.DrawRectangle(new Pen(this.color), this.xVal,
</I>&gt;<i> this.yVal, this.width, this.height);
</I>&gt;<i>             }
</I>&gt;<i>             catch (Exception exception) {}
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> ..and here too.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>       }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public class Form1 : System.Windows.Forms.Form
</I>&gt;<i> {
</I>&gt;<i>       public Form1()
</I>&gt;<i>       {
</I>&gt;<i>             // This call is required by the Windows Form Designer.
</I>&gt;<i>             InitializeComponent();
</I>&gt;<i>
</I>&gt;<i>             // Add any initialization after the InitializeComponent() call
</I>&gt;<i>             this.g = this.panel1.CreateGraphics();
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> A Graphics object on a System.Windows.Forms component uses an underlying
</I>&gt;<i> object called a &quot;DC&quot; -- Device Context -- and these are limited across the
</I>&gt;<i> entire system. The preferred practice is to create a new Graphics each time
</I>&gt;<i> you need to draw and then release it when you're finished. This is
</I>&gt;<i> especially pertinent because while the design principles of
</I>&gt;<i> System.Windows.Forms do not encourage it, they also do not prevent the
</I>&gt;<i> underlying Win32 handle from being destroyed &amp; recreated, and if that
</I>&gt;<i> happens, the DC, and thus the Graphics object, will be invalid.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i> #region &quot;Windows Form Designer generated code&quot;
</I>&gt;<i>       protected override void Dispose(bool disposing)
</I>&gt;<i>       {
</I>&gt;<i>             if (disposing &amp;&amp; !(this.components == null))
</I>&gt;<i>                   this.components.Dispose();
</I>&gt;<i>
</I>&gt;<i>             base.Dispose(disposing);
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       // Required by the Windows Form Designer
</I>&gt;<i>       private Container components = null;
</I>&gt;<i>
</I>&gt;<i>       //NOTE: The following procedure is required by the Windows Form Designer
</I>&gt;<i>       //It can be modified using the Windows Form Designer.
</I>&gt;<i>       //Do not modify it using the code editor.
</I>&gt;<i>       private Button cmdColor;
</I>&gt;<i>       private Button cmdExit;
</I>&gt;<i>       private Button cmdStart;
</I>&gt;<i>       private ComboBox comboBox1;
</I>&gt;<i>       private ComboBox comboBoxSpeed;
</I>&gt;<i>       private Label label1;
</I>&gt;<i>       public volatile Panel panel1;
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Why is this 'volatile'? The reason for 'volatile's existence is when
</I>&gt;<i> multiple threads are accessing a variable *whose value is rapidly
</I>&gt;<i> changing*. It defeats the processor's caching system so that the latest
</I>&gt;<i> value is always retrieved; otherwise, a thread running in a tight loop
</I>&gt;<i> might never get anything other than the first value it reads. Your 'panel1'
</I>&gt;<i> variable is assigned only once, and this is done before any of the threads
</I>&gt;<i> that need to read from it are even created.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i>       [System.Diagnostics.DebuggerStepThrough]
</I>&gt;<i>       private void InitializeComponent()
</I>&gt;<i>       {
</I>&gt;<i> [snipped]
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       [STAThread]
</I>&gt;<i>       private static void Main()
</I>&gt;<i>       {
</I>&gt;<i>             Application.Run(new Form1());
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i> #endregion
</I>&gt;<i>
</I>&gt;<i>       public ColorDialog c;
</I>&gt;<i>       private volatile Graphics g;
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Same thing here: this variable is only ever assigned once. As mentioned
</I>&gt;<i> earlier, though, it shouldn't even exist.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>       public static Color shapeColor = Color.Blue;
</I>&gt;<i>       private const int shapSize = 15;
</I>&gt;<i>       public static int threadCount = 0;
</I>&gt;<i>       private Hashtable threadHolder = new Hashtable();
</I>&gt;<i>
</I>&gt;<i>       private void StartThread()
</I>&gt;<i>       {
</I>&gt;<i>             Shapes shape;
</I>&gt;<i>             if (this.comboBox1.Text == &quot;Rectangle&quot;)
</I>&gt;<i>                   shape = new Rectangle(0, 0, shapSize, shapSize,
</I>&gt;<i> Form1.shapeColor, this, Convert.ToInt32(this.comboBoxSpeed.Text.Trim()));
</I>&gt;<i>             else if (this.comboBox1.Text == &quot;Circle&quot;)
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Here you should use comboBox1.SelectedIndex instead of .Text. While using
</I>&gt;<i> .Text is arguably easier to read, you might possibly one day want to change
</I>&gt;<i> the text, perhaps for localization (&quot;Cercle&quot; instead of &quot;Circle&quot; for
</I>&gt;<i> French, say). Then again, you might one day want to change the order
</I>&gt;<i> instead...
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>                   shape = new Circle(0, 0, shapSize, shapSize,
</I>&gt;<i> Form1.shapeColor, this, Convert.ToInt32(this.comboBoxSpeed.Text.Trim()));
</I>&gt;<i>             else
</I>&gt;<i>                   shape = new Rectangle(0, 0, shapSize, shapSize,
</I>&gt;<i> Form1.shapeColor, this, Convert.ToInt32(this.comboBoxSpeed.Text.Trim()));
</I>&gt;<i>
</I>&gt;<i>             while (true)
</I>&gt;<i>             {
</I>&gt;<i>                   try
</I>&gt;<i>                   {
</I>&gt;<i>                         shape.paint(this.g);
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Here is the core of your troubles. You have a DC to the window, and
</I>&gt;<i> multiple threads are calling methods on that DC concurrently. This is
</I>&gt;<i> extremely bad! While DCs are not bound to any specific threads like GUI
</I>&gt;<i> widgets are, there is no guarantee of their re-entrancy. This isn't easy to
</I>&gt;<i> fix; basically, your entire test program is based on a flawed assumption.
</I>&gt;<i> Perhaps one way to fix it would be to use the &quot;Invoke&quot; method to marshal
</I>&gt;<i> the paint calls onto the GUI thread. This would serialize the drawing
</I>&gt;<i> operations. Another way to serialize them would be to lock an object (but
</I>&gt;<i> NOT a system object! it must be an object that you created) that is common
</I>&gt;<i> to the threads. For instance:
</I>&gt;<i>
</I>&gt;<i> class Fuu
</I>&gt;<i> {
</I>&gt;<i>   // This object is a field variable of 'Fuu', not a local variable of the
</I>&gt;<i>   // thread procedure, and so it is common to all threads.
</I>&gt;<i>   object sync = new object();
</I>&gt;<i>
</I>&gt;<i>   public void ThreadProc()
</I>&gt;<i>   {
</I>&gt;<i>     while (true)
</I>&gt;<i>     {
</I>&gt;<i>       update_position();
</I>&gt;<i>
</I>&gt;<i>       lock (sync)
</I>&gt;<i>       {
</I>&gt;<i>         using (Graphics g = CreateGraphics())
</I>&gt;<i>           paint(g);
</I>&gt;<i>       }
</I>&gt;<i>     }
</I>&gt;<i>   }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> This example also shows the recommended use of CreateGraphics().
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>                   }
</I>&gt;<i>                   catch (Exception exception)
</I>&gt;<i>                   {
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> I imagine you don't get this happening very often, since your paint
</I>&gt;<i> functions already catch all exceptions and ignore them.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>                         Console.WriteLine(&quot;Exception in Form1 whileloop &gt;&gt;
</I>&gt;<i> &quot; + exception);
</I>&gt;<i>                         return;
</I>&gt;<i>                   }
</I>&gt;<i>             }
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       private void button1_Click(object sender, EventArgs e)
</I>&gt;<i>       {
</I>&gt;<i>             foreach (Thread thread in threadHolder.Values)
</I>&gt;<i>                   if ((thread != null) &amp;&amp; thread.IsAlive)
</I>&gt;<i>                         thread.Abort();
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> I notice that farther down, you set the .IsBackground property of all the
</I>&gt;<i> threads to 'true'. Calling .Abort() on them is therefore completely
</I>&gt;<i> superfluous. As a matter of fact, .Abort() should virtually never be used;
</I>&gt;<i> it is always more appropriate to find a way to notify the thread and let
</I>&gt;<i> the thread end itself.
</I>&gt;<i>
</I>&gt;<i> When you call .Abort() on a thread, it throws an uncatchable
</I>&gt;<i> ThreadAbortException. I say &quot;uncatchable&quot; because even if you do catch it,
</I>&gt;<i> it is automatically rethrown at the end of the 'catch' block, so you can't
</I>&gt;<i> stop its propagation. This does, then, have the effect of terminating the
</I>&gt;<i> thread (provided it doesn't go into a loop in the 'catch' clause).
</I>&gt;<i>
</I>&gt;<i> However, when a thread is marked as a background thread, it is
</I>&gt;<i> automatically killed off when all non-background threads are gone. Closing
</I>&gt;<i> the main form will result in the &quot;Application.Run()&quot; call inside the 'Main'
</I>&gt;<i> method to return. 'Main' itself will return, and the main thread will then
</I>&gt;<i> terminate. The result will be that the only threads left will be background
</I>&gt;<i> threads trying to draw to a non-existent form. When you expect this
</I>&gt;<i> situation, the best course of action is to catch specifically the
</I>&gt;<i> &quot;ObjectDisposedException&quot;, which can be thrown whenever you call a method
</I>&gt;<i> on the disposed Form (such as 'CreateGraphics()'). Unlike catching all
</I>&gt;<i> exceptions, in this case you know specifically why the exception has been
</I>&gt;<i> thrown and can stop trying to draw to the form.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>             Form.ActiveForm.Close();
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       private void button2_Click(object sender, EventArgs e)
</I>&gt;<i>       {
</I>&gt;<i>             Thread thread = new Thread(new ThreadStart(this.StartThread));
</I>&gt;<i>             this.threadHolder.Add(threadCount++, thread);
</I>&gt;<i>             thread.Name = &quot;Thread ID: &quot; + Form1.threadCount;
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Not sure if this is your intent, but the thread's index in 'ThreadHolder'
</I>&gt;<i> will be one less than the index in its 'Name' property... It would probably
</I>&gt;<i> be more appropriate to use an ArrayList instead of a Hashtable in this
</I>&gt;<i> situation, by the way, as you are never looking up a thread by its ID. The
</I>&gt;<i> only thing you use the collection for is enumerating the threads and
</I>&gt;<i> killing them. Enumerating a Hashtable is a very costly operation, while
</I>&gt;<i> enumerating an ArrayList is about as fast as directly accessing an array.
</I>&gt;<i>
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>             thread.IsBackground = true;
</I>&gt;<i>             thread.Start();
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       private void cmdColor_Click(object sender, EventArgs e)
</I>&gt;<i>       {
</I>&gt;<i>             this.c = new ColorDialog();
</I>&gt;<i>             this.c.ShowDialog();
</I>&gt;<i>             Form1.shapeColor = this.c.Color;
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
</I>&gt;<i>       {
</I>&gt;<i>
</I>&gt;<i>       }
</I>&gt;<i>
</I>&gt;<i>       private void Form1_Load(object sender, EventArgs e)
</I>&gt;<i>       {
</I>&gt;<i>
</I>&gt;<i>       }
</I>&gt;<i> }
</I>&gt;<i> ---------------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> I know this happens when using the designer, that you hook events you
</I>&gt;<i> didn't mean to hook, but it does look a little bit sloppy when you don't
</I>&gt;<i> clean up after making that mistake. You can remove the binding by switching
</I>&gt;<i> the Properties panel to the 'Events' (little lightning-bolt icon at the top
</I>&gt;<i> of the panel), and then clicking once on the name of the method you want to
</I>&gt;<i> unhook and pressing delete.
</I>&gt;<i>
</I>&gt;<i> The only other thing I noticed is that you aren't consistent in renaming
</I>&gt;<i> your controls. This makes a big difference in how professional your code
</I>&gt;<i> looks. For a test, it isn't that important, but to have &quot;comboBox1&quot;,
</I>&gt;<i> &quot;label1&quot;, etc. and &quot;cmdColor&quot;, &quot;cmdExit&quot;, etc. in the same project looks
</I>&gt;<i> bad. I also notice that the event handlers for two of the buttons are named
</I>&gt;<i> differently (&quot;button1&quot; instead of &quot;cmdExit&quot;, &quot;button2&quot; instead of
</I>&gt;<i> &quot;cmdStart&quot;). Basically, this tells you that assigning the correct name to a
</I>&gt;<i> control should be the first priority after adding it to the form, before
</I>&gt;<i> you do anything else.
</I>&gt;<i>
</I>&gt;<i> If there are any parts of my explanation that were unclear to you, feel
</I>&gt;<i> free to reply to me *off the list* and I'll elaborate.
</I>&gt;<i>
</I>&gt;<i> Good luck with your programming endeavours :-)
</I>&gt;<i>
</I>&gt;<i> Jonathan Gilbert
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">Mono-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i>
</I></PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029165.html">[Mono-list] this .net exe work for you?
</A></li>
	<LI>Next message: <A HREF="029182.html">[Mono-list] this .net exe work for you?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29167">[ date ]</a>
              <a href="thread.html#29167">[ thread ]</a>
              <a href="subject.html#29167">[ subject ]</a>
              <a href="author.html#29167">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
