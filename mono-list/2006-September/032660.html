<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Static constructor issue
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Static%20constructor%20issue&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="032659.html">
   <LINK REL="Next"  HREF="032665.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Static constructor issue</H1>
    <B>Jonathan Gilbert</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Static%20constructor%20issue&In-Reply-To="
       TITLE="[Mono-list] Static constructor issue">2a5gjx302 at sneakemail.com
       </A><BR>
    <I>Thu Sep  7 15:07:42 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="032659.html">[Mono-list] Static constructor issue
</A></li>
        <LI>Next message: <A HREF="032665.html">[Mono-list] Static constructor issue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32660">[ date ]</a>
              <a href="thread.html#32660">[ thread ]</a>
              <a href="subject.html#32660">[ subject ]</a>
              <a href="author.html#32660">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>At 02:28 PM 07/09/2006 -0400, Abe Gillespie wrote:
&gt;&gt;<i> No, I wasn't talking of instance constructors. An example:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> class Parent {
</I>&gt;&gt;<i>         static Parent() {
</I>&gt;&gt;<i>                 // important stuff
</I>&gt;&gt;<i>         }
</I>&gt;&gt;<i>         public Parent(int foo) {
</I>&gt;&gt;<i>         }
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> class Child : Parent {
</I>&gt;&gt;<i>         static Child() {
</I>&gt;&gt;<i>                 // stuff that relies on &quot;important stuff&quot;
</I>&gt;&gt;<i>         }
</I>&gt;&gt;<i>         public Child(int foo) : base(foo) {
</I>&gt;&gt;<i>         }
</I>&gt;&gt;<i> }
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Code then does new Child(42);.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I would assume that before Child.cctor is called, Parent.cctor would
</I>&gt;&gt;<i> need to be called by the runtime - which apparently is not happening.
</I>&gt;&gt;<i> So I'm wondering whether this is a Mono issue or whether it is
</I>&gt;&gt;<i> intended that way.
</I>&gt;<i>
</I>&gt;<i>static Child.ctor is called first and then static Parent.ctor is
</I>&gt;<i>called ... that's just the way the order of operations go.
</I>&gt;<i>
</I>&gt;<i>The metaphor I was given way back in my student days is this:
</I>&gt;<i>Think of building a watch, you first start with the internals (gears
</I>&gt;<i>and such) and this can be seen as the Child.  Then you put on the
</I>&gt;<i>outer parts (housing, glass, etc.) where this is seen as the Parent.
</I>&gt;<i>
</I>&gt;<i>The reason why it's different for instance ctors is because you call
</I>&gt;<i>the Parent ctor specifically before the code inside the Child ctor
</I>&gt;<i>runs.
</I>
I'm not sure that metaphor is really useful :-) If you want to force the
base class' static constructor to run first, then access any member of the
base class from the derived class' static constructor. The reason the base
class' static constructor is not immediately run is that the inheritance
rules involved don't apply to static members. Unlike other languages, .NET
*does* offer inheritance of static members, but the derived class -- in
terms of its static members -- is not really seen as a &quot;kind-of&quot; the base
class.

To put it succinctly: The execution of Child's .cctor does not in and of
itself constitute accessing a member of Parent.

See the attached sample which demonstrates this behaviour.

Jonathan Gilbert
-------------- next part --------------
using System;

class MainClass
{
  static void Main()
  {
    Output.WriteLine(&quot;Calling Child..ctor from Main&quot;);
    Output.Indent++;
    new Child(42);
    Output.Indent--;
    Output.WriteLine(&quot;Leaving Main&quot;);
  }
}

class Output
{
  public static int Indent;

  public static void WriteLine(string line)
  {
    WriteIndent();
    Console.WriteLine(line);
  }

  public static void WriteLine(string line, object p0)
  {
    WriteIndent();
    Console.WriteLine(line, p0);
  }

  static void WriteIndent()
  {
    for (int i=0; i &lt; Indent; i++)
      Console.Write(&quot;  &quot;);
  }

  public static int WriteLineThroughAndIndent(string line, int through)
  {
    WriteLine(line);
    Indent++;
    return through;
  }
}

class Child : Parent
{
  static Child()
  {
    object value;

    Output.WriteLine(&quot;Start of Child..cctor&quot;);
    Output.Indent++;

    Output.WriteLine(&quot;Outside value (first pass)&quot;);
    Output.Indent++;
    Output.WriteLine(&quot;getting outside value...&quot;);
    value = Outside.Value;
    Output.WriteLine(&quot;outside value: {0}&quot;, value == null ? &quot;(null)&quot; : value);
    Output.Indent--;

    Output.WriteLine(&quot;Parent value&quot;);
    Output.Indent++;
    Output.WriteLine(&quot;getting parent value...&quot;);
    value = Parent.Value;
    Output.WriteLine(&quot;parent value: {0}&quot;, value == null ? &quot;(null)&quot; : value);
    Output.Indent--;

    Output.WriteLine(&quot;Outside value (second pass)&quot;);
    Output.Indent++;
    Output.WriteLine(&quot;getting outside value...&quot;);
    value = Outside.Value;
    Output.WriteLine(&quot;outside value: {0}&quot;, value == null ? &quot;(null)&quot; : value);
    Output.Indent--;

    Output.Indent--;
    Output.WriteLine(&quot;End of Child..cctor&quot;);
  }

  public Child(int value)
    : base(Output.WriteLineThroughAndIndent(&quot;Start of Child..ctor&quot;, value))
  {
    Output.WriteLine(&quot;Child..ctor({0})&quot;, value);

    Output.Indent--;
    Output.WriteLine(&quot;End of Child..ctor&quot;);
  }
}

class Parent
{
  static Parent()
  {
    Output.WriteLine(&quot;Start of Parent..cctor&quot;);
    Output.Indent++;
    Output.WriteLine(&quot;setting Parent.Value...&quot;);
    Parent.Value = &quot;The parent's static value&quot;;
    Output.WriteLine(&quot;setting Outside.Value...&quot;);
    Outside.Value = &quot;The outside static value, assigned from Parent&quot;;
    Output.Indent--;
    Output.WriteLine(&quot;End of Parent..ctor&quot;);
  }

  public static string Value;

  public Parent(int value)
  {
    Output.WriteLine(&quot;Start of Parent..ctor&quot;);
    Output.Indent++;

    Output.WriteLine(&quot;Parent..ctor({0})&quot;, value);

    Output.Indent--;
    Output.WriteLine(&quot;End of Parent..ctor&quot;);
  }
}

class Outside
{
  public static string Value;
}
</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="032659.html">[Mono-list] Static constructor issue
</A></li>
	<LI>Next message: <A HREF="032665.html">[Mono-list] Static constructor issue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32660">[ date ]</a>
              <a href="thread.html#32660">[ thread ]</a>
              <a href="subject.html#32660">[ subject ]</a>
              <a href="author.html#32660">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
