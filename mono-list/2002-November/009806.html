<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Writing daemons in C#
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="009805.html">
   <LINK REL="Next"  HREF="009815.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Writing daemons in C#
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] Writing daemons in C#">jonpryor@vt.edu
       </A><BR>
    <I>20 Nov 2002 10:37:16 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="009805.html">[Mono-list] Writing daemons in C# - SCM for Linux
</A></li>
        <LI> Next message: <A HREF="009815.html">[Mono-list] Writing daemons in C#
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9806">[ date ]</a>
              <a href="thread.html#9806">[ thread ]</a>
              <a href="subject.html#9806">[ subject ]</a>
              <a href="author.html#9806">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I would suggest an alternative approach.  Use P/Invoke for everything,
but instead of having the C# values differ from the platform-specific
values, let them be the same.  Instead, use P/Invoke to also get the
platform-specific values.

It could look like this:

	public sealed class OpenMode {
		[DllImport (&quot;posix-values&quot;)]
		private static extern int posix_get_O_CREAT ();

		[DllImport (&quot;posix-values&quot;)]
		private static extern int posix_get_O_EXCL ();

		[DllImport (&quot;posix-values&quot;)]
		private static extern int posix_get_O_APPEND ();

		public static int O_CREAT {
			get {return posix_get_O_CREAT();}
		}

		public static int O_EXCL {
			get {return posix_get_O_EXCL ();}
		}

		public static int O_APPEND {
			get {return posix_get_O_APPEND ();}
		}
	}

	public sealed class PosixFunctions {
		[DllImport(&quot;libc&quot;)]
		public static extern int open (string pathname, int flags, int mode);
	}

The advantage to this is that you don't have to write as much custom
code.  All of the `posix_get_CONSTANT()' functions can be generated with
a single perl script:

	#!/usr/bin/perl

	print &lt;&lt;EOF;
	/*
	 * Defines functions to get the value of a POSIX constant
	 */
	#include &lt;fcntl.h&gt;
	#include &lt;sys/stat.h&gt;

	EOF

	while (&lt;&gt;) {
	  $constant = $_;
	  chop $constant;
	  print &lt;&lt;EOF;
	int posix_get_$constant ()
	{
		return $constant;
	}
	
	EOF
	}

It reads from standard input one constant per line, so the input could
be:

	O_CREAT
	O_EXCL
	O_APPEND

and the script would generate all the appropriate `posix_get_'
functions.

Actually, you could probably automate the generate of most of the Posix
constants in this fashion, minimizing the amount of custom code you
would have to write and maintain.

It might also be interesting to look at Gtk#, which appears to use XML
input files to describe the GTK+ API and automatically generates some
bindings from the XML description.  I would imagine that similar things
could be done for POSIX.

 - Jon

On Wed, 2002-11-20 at 05:44, Miguel de Icaza wrote:
&gt;<i> Hello,
</I>&gt;<i> 
</I>&gt;<i> &gt; I'm presuming DllImport and P/Invoke aren't the preferred methods here? 
</I>&gt;<i> &gt; I looked at System.Net.Socket, since that would appear to be a task
</I>&gt;<i> &gt; similar to implementing POSIX APIs.  It uses InternalCall, which I'm
</I>&gt;<i> &gt; presuming (C# In A Nutshell is not so clear on this) is implemented
</I>&gt;<i> &gt; within the interpreter.  I poked through mono and found the file
</I>&gt;<i> &gt; mono/io-layer/sockets.c which appears to be the internal implementation
</I>&gt;<i> &gt; of the Sockets API.  Would the POSIX implementation look similar to
</I>&gt;<i> &gt; this?  Is there someplace all this is documented or am I on my own?
</I>&gt;<i> 
</I>&gt;<i> Ok, here is where it gets tricky.  The official response is `Only use
</I>&gt;<i> P/Invoke', but sometimes it might be convenient (for speed reasons) to
</I>&gt;<i> use internal calls.  The tricky bit is: internal calls are only
</I>&gt;<i> available on the runtime.
</I>&gt;<i> 
</I>&gt;<i> Now, I figured that there is a *hack* we can use, but it is a hack, in
</I>&gt;<i> which you P/Invoke into a bootstrap routine (called from a static
</I>&gt;<i> constructor), and the bootstrap routine in turn registers the
</I>&gt;<i> InternalCalls with the runtime, and then the rest of the code uses
</I>&gt;<i> internalcalls.
</I>&gt;<i> 
</I>&gt;<i> My suggestion is: for now stick to using P/Invoke, and we will later
</I>&gt;<i> implement the performance hack.
</I>&gt;<i> 
</I>&gt;<i> Now, another of the tricky bits is this: enumerations and constants are
</I>&gt;<i> different across the various Unix implementations, so it is not possible
</I>&gt;<i> to P/Invoke a library with constants that are defined in C# directly,
</I>&gt;<i> because they will likely change (in fact, the values change across Linux
</I>&gt;<i> ports: the same system constant value is different across ports).
</I>&gt;<i> 
</I>&gt;<i> So the process to assemble this is multi-process:
</I>&gt;<i> 
</I>&gt;<i> 	* A C# file containing all the enumeration values.
</I>&gt;<i> 
</I>&gt;<i> 	* A C# program that can read these enumeration values and
</I>&gt;<i> 	  generate &quot;support&quot; header file for C consumption.
</I>&gt;<i> 
</I>&gt;<i> 	* A C program that includes the header file, and maps constants
</I>&gt;<i> 	  to their native valuess.
</I>&gt;<i> 
</I>&gt;<i> 	* A C# set of definitions to P/Invoke into it.
</I>&gt;<i> 
</I>&gt;<i> Let me give you an illustration:
</I>&gt;<i> 
</I>&gt;<i> PosixEnums.cs:
</I>&gt;<i> [IncludeFile (&quot;fcntl.h&quot;)]
</I>&gt;<i> [IncludeFile (&quot;sys/stat.h&quot;)]
</I>&gt;<i> 	enum OpenMode {
</I>&gt;<i> 		O_CREAT,
</I>&gt;<i> 		O_EXCL,
</I>&gt;<i> 		O_APPEND
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> The a C# program uses reflection to generate the following header file:
</I>&gt;<i> 
</I>&gt;<i> #include &lt;fcntl.h&gt;
</I>&gt;<i> #include &lt;sys/stat.h&gt;
</I>&gt;<i> #define OpenMode_O_CREAT	O_CREAT
</I>&gt;<i> #define OpenMode_O_EXCL         O_EXCL
</I>&gt;<i> #define OpenMode_O_APPEND       O_APPEND
</I>&gt;<i> 
</I>&gt;<i> And the following C helper file:
</I>&gt;<i> 
</I>&gt;<i> #include &quot;PosixEnums.h&quot;
</I>&gt;<i> map_OpenMode (int flags)
</I>&gt;<i> {
</I>&gt;<i> 	switch (flags){
</I>&gt;<i> 		case OpenMode_O_CREAT: return O_CREAT;
</I>&gt;<i> 		case OpenMode_O_EXCEL: return O_EXCL;
</I>&gt;<i> 		case OpenMode_O_APPEND: return O_APPEND;
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> Notice that the source file contains the attribute &quot;IncludeFile&quot; (that
</I>&gt;<i> you will have to create, and &quot;pull&quot; it out yourself to generate the
</I>&gt;<i> corresponding header files).
</I>&gt;<i> 
</I>&gt;<i> Then you have to write the C code, *manually*:
</I>&gt;<i> 
</I>&gt;<i> int posix_open (string filename, int flags)
</I>&gt;<i> {
</I>&gt;<i> 	return open (filename, 	map_OpenMode (flags));
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> Then from C# you write (again manually) the P/Invoke invocation:
</I>&gt;<i> 
</I>&gt;<i> [DllImport (&quot;Mono.Posix.so&quot;, EntryPoint=&quot;posix_open&quot;)]
</I>&gt;<i> int open (string filename, OpenMode mode);
</I>&gt;<i> 
</I>&gt;<i> Once you have the code, we can integrate it into the build.
</I>&gt;<i> 
</I>&gt;<i> Hope this helps,
</I>&gt;<i> Miguel.
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@ximian.com">Mono-list@ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="009805.html">[Mono-list] Writing daemons in C# - SCM for Linux
</A></li>
	<LI> Next message: <A HREF="009815.html">[Mono-list] Writing daemons in C#
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9806">[ date ]</a>
              <a href="thread.html#9806">[ thread ]</a>
              <a href="subject.html#9806">[ subject ]</a>
              <a href="author.html#9806">[ author ]</a>
         </LI>
       </UL>
</body></html>
