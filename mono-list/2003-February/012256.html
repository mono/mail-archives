<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] mono performance on highly recursive functions
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:lupus%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="012255.html">
   <LINK REL="Next"  HREF="012245.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] mono performance on highly recursive functions
   </H1>
    <B>Paolo Molaro
    </B> 
    <A HREF="mailto:lupus%40ximian.com"
       TITLE="[Mono-list] mono performance on highly recursive functions">lupus@ximian.com
       </A><BR>
    <I>Mon, 17 Feb 2003 16:39:18 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="012255.html">[Mono-list] mono performance on highly recursive functions
</A></li>
        <LI> Next message: <A HREF="012245.html">[Mono-list] mcs/class/doc/TemplateTest.cs corrupt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12256">[ date ]</a>
              <a href="thread.html#12256">[ thread ]</a>
              <a href="subject.html#12256">[ subject ]</a>
              <a href="author.html#12256">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 02/18/03 Fergus Henderson wrote:
&gt;<i> &gt; If you're willing to do the preprocessing, you can just use an ahead of
</I>&gt;<i> &gt; time compiler: that will reduce the jit processing time much more than
</I>&gt;<i> &gt; optimizing just the IL code.
</I>&gt;<i> 
</I>&gt;<i> Yes, but that sacrifices portability of the binary.
</I>
You still can use the IL binary (and even with an AOT compiler you need
the IL assembly anyway), so there is no loss of portability.

Note: doing the optimization in the JIT doesn't exclude someone from
optimizing the IL code too, it's just that we will focus on doing
the optimization at the jit level because we don't have the resources
for doing basically the same work multiple times. I guess third-party
compiler guys want their share of fun coding optimizations, so, more
power to them! :-)

&gt;<i> &gt; There are also several reports at least by
</I>&gt;<i> &gt; the MS people on how trying to outsmart the JIT by optimizing the IL
</I>&gt;<i> &gt; code may result in the JIT missing some optimization opportunities.
</I>&gt;<i> 
</I>&gt;<i> I would be interested to see those.
</I>
The one I remember was about using a local to store the length of an
array and checking that in a for loop, instead of using the ldlen opcode
at each iteration.

&gt;<i> &gt; And I can understand that, a tool working on the IL code doesn't have
</I>&gt;<i> &gt; all the info the JIT has.
</I>&gt;<i> 
</I>&gt;<i> That's true, but such a tool has time to compute more information than
</I>&gt;<i> a JIT can.  So neither has more information than the other; they have
</I>&gt;<i> different information.  It's useful to have optimization at both points.
</I>
Well, I guess once there is such a tool and we'll have the optimizations
implemented in the JIT we'll be able to compare what's most effective:-)

&gt;<i> &gt; Anyway, even if you write an IL optimizer, the optimizations need to be
</I>&gt;<i> &gt; implemented in the JIT, too: you can't always depend on having a
</I>&gt;<i> &gt; preprocessor for IL code, think Reflection.Emit.
</I>&gt;<i> 
</I>&gt;<i> That is a good point; I wasn't considering that.
</I>&gt;<i> If you want to optimize the performance of programs which
</I>&gt;<i> uses Reflect.Emit to dynamically construct code on the fly,
</I>&gt;<i> then yes, it does make sense to put optimizations like
</I>&gt;<i> detecting tail recursion in the JIT.
</I>
Well, we have already the ikvm JVM running with mono and that uses
Reflection.Emit (ok, I tried only two tests, fibonacci and ackermann,
but Zoltan has been doing a great job fixing issues with it). If you
factor out the startup cost (1.2 secs on my pentium III 1.13, but we
haven't tryed to optimized it yet), the speed is very competitive with
other free-software JVMs.
I also expect more 'scripting' languages will be implemented on the CLR
using Reflection.Emit in the next few months.

lupus

-- 
-----------------------------------------------------------------
<A HREF="mailto:lupus@debian.org">lupus@debian.org</A>                                     debian/rules
<A HREF="mailto:lupus@ximian.com">lupus@ximian.com</A>                             Monkeys do it better

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="012255.html">[Mono-list] mono performance on highly recursive functions
</A></li>
	<LI> Next message: <A HREF="012245.html">[Mono-list] mcs/class/doc/TemplateTest.cs corrupt
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12256">[ date ]</a>
              <a href="thread.html#12256">[ thread ]</a>
              <a href="subject.html#12256">[ subject ]</a>
              <a href="author.html#12256">[ author ]</a>
         </LI>
       </UL>
</body></html>
