<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Future of JIT
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="011782.html">
   <LINK REL="Next"  HREF="011812.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Future of JIT
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] Future of JIT">jonpryor@vt.edu
       </A><BR>
    <I>02 Feb 2003 11:42:03 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="011782.html">[Mono-list] Future of JIT
</A></li>
        <LI> Next message: <A HREF="011812.html">[Mono-list] Future of JIT
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11786">[ date ]</a>
              <a href="thread.html#11786">[ thread ]</a>
              <a href="subject.html#11786">[ subject ]</a>
              <a href="author.html#11786">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The biggest problem is the licensing issues -- it's not GPL compatible. 
At least, not immediately so.

The problem is the &quot;you may not sell vcode or any product drived from it
in which it is a significant part of the value of the project.&quot;  If mono
were to use this as its JIT, it could be argued to be a &quot;significant
part of the value of the project&quot; (the JIT is very important), which
means you can't sell it, which directly conflicts with the GPL.

The requirement to &quot;acknowledge the use of vcode clearly in all product
documentation and distribution media&quot; also conflicts with the GPL.  This
is similar to the original BSD's &quot;obnoxious advertising clause&quot;; see:

	<A HREF="http://www.gnu.org/philosophy/bsd.html">http://www.gnu.org/philosophy/bsd.html</A>

Note, I am not a lawyer, don't trust me, yada-yada-yada, but this is my
current understanding of the licensing issues.

The other problem is that a new JIT engine is already under
development.  It is described (briefly) in this presentation:

	<A HREF="http://primates.ximian.com/~miguel/slides-europe-nov-2002/ETH.sxi">http://primates.ximian.com/~miguel/slides-europe-nov-2002/ETH.sxi</A>

I think it's also mentioned in some of the other presentations, but I
haven't checked.

In particular, start reading at Slide 26.  Benefits are greater
portability, better code generation, more flexible, and it's as fast or
faster than the current JIT.

 - Jon

On Sat, 2003-02-01 at 20:34, Ilya Minkov wrote:
&gt;<i> Have you considered VCODE/ICODE to become a basis for your JIT backend?
</I>&gt;<i> 
</I>&gt;<i> It was developed/used for runtime code generation in Tick C Compiler, 
</I>&gt;<i> which is in turn based upon LCC. And since its command set is tuned for 
</I>&gt;<i> LCC, it should also fit the .NET architecture if i'm not wrong. I 
</I>&gt;<i> haven't read many important papers because of lack of time, so don't 
</I>&gt;<i> consider what i tell here sole truth, it can have rumors/ 
</I>&gt;<i> misconceptions/ stuff mixed in.
</I>&gt;<i> 
</I>&gt;<i> It has been well ported to all (widespread) RISC CPUs, and there is a 
</I>&gt;<i> half-broken x86 port. I have been intending to make a &quot;real&quot; x86 port 
</I>&gt;<i> for use in some project of mine. But i think MONO could be a better use 
</I>&gt;<i> for me, and i would like to be of use if i have time and our targets match.
</I>&gt;<i> 
</I>&gt;<i> VCODE is a set of C macros, generating target machine code out of the 
</I>&gt;<i> generalized RISC set without intermediate representation, like GNU 
</I>&gt;<i> Lightning does. With a difference that GNU Lightning is broken.
</I>&gt;<i> 
</I>&gt;<i> ICODE is a form of binary representation for VCODE, which also 
</I>&gt;<i> integrates a number of generic optimisations and register allocation, 
</I>&gt;<i> reaching considerable execution speeds.
</I>&gt;<i> 
</I>&gt;<i> The thing to check: *licensing issues* (?), i don't know under which 
</I>&gt;<i> condition it has been licensed.
</I>&gt;<i> - checked already. It's &quot;fair use&quot; - not to sell, else use as desired, 
</I>&gt;<i> retain copyright. It even allows usage in commercial products but it 
</I>&gt;<i> doesn't matter.
</I>&gt;<i> 
</I>&gt;<i> I think the system should be as staged as possible, so that only a minor 
</I>&gt;<i> part should be ported to another architecture, and that improving some 
</I>&gt;<i> actually platform-independant stuff wouldn't break some platform while 
</I>&gt;<i> leaving others working. Besides, this VCODE already contain a lot of 
</I>&gt;<i> work done by others.
</I>&gt;<i> 
</I>&gt;<i> I also think that it should be possible to attach a peephole optimiser 
</I>&gt;<i> to VCODE. Any time a label is issued, if optimiser is enabled, it would 
</I>&gt;<i> disassemble (simplified, extracting a minimum of information) all the 
</I>&gt;<i> code generated since the last label, and write &quot;tags&quot;, noting where each 
</I>&gt;<i> CPU command starts and some basic properties of it, like LCC-Win32 does 
</I>&gt;<i> it. Then, peephole optimisation is basically pattern-matching and 
</I>&gt;<i> disassembling certaing commands as this information is needed, and so on 
</I>&gt;<i> as usual. Finally, the last label should be moved back.
</I>&gt;<i> 
</I>&gt;<i> Then i think, compilation should be &quot;lazy&quot;. The first time a function is 
</I>&gt;<i> compiled, it is done the fastest way, optimising nothing. Functions 
</I>&gt;<i> which it requieres are not compiled. Inputs are placed on stack as 
</I>&gt;<i> usual, but with a CALL to some (assembly-written) dispatcher function. 
</I>&gt;<i> This dispatcher when called does the folowing:
</I>&gt;<i>   - Looks at return adress. Using that, finds out what function exactly 
</I>&gt;<i> is to be called in this place. (This information needs to be generated 
</I>&gt;<i> when compiling that original function)
</I>&gt;<i>   - If the function to be called is already compiled, then change the 
</I>&gt;<i> call adress (which is just placed before the return adress) with the 
</I>&gt;<i> actual function adress to be called, and call this function, then return.
</I>&gt;<i>   - If the function is not yet compiled, compile it, then procede as in 
</I>&gt;<i> previous case.
</I>&gt;<i> The next time a function will call another function directly
</I>&gt;<i> 
</I>&gt;<i> First time a function is compiled it is compiled without optimisations. 
</I>&gt;<i> I guess it would be OK to place a call to counter in the beginning of 
</I>&gt;<i> such a function - since it's not compiled for speed...
</I>&gt;<i> As soon as this counter decides that the function has been called &quot;often 
</I>&gt;<i> enough&quot;, it should recompile the function with all optimisations on, 
</I>&gt;<i> this time without embedding the counter. The system to replace adresses 
</I>&gt;<i> might either be the same as previous, or more a more rapid one so that 
</I>&gt;<i> the unoptimised function can be deleted at once.
</I>&gt;<i> 
</I>&gt;<i> Of course, there can just as well be multiple optimisation steps, but it 
</I>&gt;<i> might be the next step.
</I>&gt;<i> 
</I>&gt;<i> Opinions?
</I>&gt;<i> 
</I>&gt;<i> -i.
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@lists.ximian.com">Mono-list@lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="011782.html">[Mono-list] Future of JIT
</A></li>
	<LI> Next message: <A HREF="011812.html">[Mono-list] Future of JIT
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11786">[ date ]</a>
              <a href="thread.html#11786">[ thread ]</a>
              <a href="subject.html#11786">[ subject ]</a>
              <a href="author.html#11786">[ author ]</a>
         </LI>
       </UL>
</body></html>
