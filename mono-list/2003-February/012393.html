<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] SMTP into CVS
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pt99par%40student.bth.se">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="012392.html">
   <LINK REL="Next"  HREF="012394.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] SMTP into CVS
   </H1>
    <B>Per Arneng
    </B> 
    <A HREF="mailto:pt99par%40student.bth.se"
       TITLE="[Mono-list] SMTP into CVS">pt99par@student.bth.se
       </A><BR>
    <I>Sun, 23 Feb 2003 01:41:00 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="012392.html">[Mono-list] Syntax Error???
</A></li>
        <LI> Next message: <A HREF="012394.html">[Mono-list] Status of the new JIT engine?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12393">[ date ]</a>
              <a href="thread.html#12393">[ thread ]</a>
              <a href="subject.html#12393">[ subject ]</a>
              <a href="author.html#12393">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--------------Boundary-00=_CKKQ6KQ4H56G5CMEJPMK
Content-Type: text/plain;
  charset=&quot;us-ascii&quot;
Content-Transfer-Encoding: quoted-printable

Hi!

Here are the smtp classes. They have now a namespace that is SmtpClient a=
nd=20
they should probably be in another namespace. I have designed the classes=
 in=20
souch a way so that they will be easy to incorperate in the SmtpMail clas=
s.=20

It would be nice if someone could insert them into the cvs or tell me of =
where=20
to insert them. I think that a new assembly would be good since the class=
es=20
expose more functionallity than the SmtpMail do. SmtpStream ex: provides=20
direct access to the smtp protocol.  but anyhing is ok with me :)

When everything is added it can be used inside SmtpMail.Send like this
----------------------
SmtpClient smtp =3D new SmtpClient( this.SmtpServer );

smtp.Send( message );

smtp.Close();
----------------------

I think its better if i send a patch later for SmtpMail to manage all the=
=20
exceptions in a copatible way with .NET sdk..

Here is the code size in loc:
    268 SmtpClient.cs
      9 SmtpException.cs
     63 SmtpResponse.cs
    235 SmtpStream.cs
    575 total

Here is the status page: <A HREF="http://p.rsn.bth.se/smtp">http://p.rsn.bth.se/smtp</A>
=20
Best regards
   Per Arneng

--------------Boundary-00=_CKKQ6KQ4H56G5CMEJPMK
Content-Type: text/x-makefile;
  charset=&quot;us-ascii&quot;;
  name=&quot;Makefile&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=&quot;Makefile&quot;


CC=mcs
BIN_DIR=../bin
DLL_FILE=$(BIN_DIR)/SmtpClient.dll
SRC_FILES=$(wildcard Smtp*.cs)

all: $(DLL_FILE)


$(DLL_FILE): $(SRC_FILES)
	$(CC) -o $(DLL_FILE) --target library -warn:4 -r System.Web.dll $(SRC_FILES)

clean:
	rm -f *~ $(DLL_FILE)
--------------Boundary-00=_CKKQ6KQ4H56G5CMEJPMK
Content-Type: text/x-c++src;
  charset=&quot;us-ascii&quot;;
  name=&quot;SmtpException.cs&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=&quot;SmtpException.cs&quot;

using System.IO;

namespace SmtpClient {

    public class SmtpException : IOException {
	public SmtpException( string message ) : base( message ) {}
    }

}

--------------Boundary-00=_CKKQ6KQ4H56G5CMEJPMK
Content-Type: text/x-c++src;
  charset=&quot;us-ascii&quot;;
  name=&quot;SmtpClient.cs&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=&quot;SmtpClient.cs&quot;

// SmtpClient.cs
// author: Per Arneng &lt;<A HREF="mailto:pt99par@student.bth.se">pt99par@student.bth.se</A>&gt;
using System;
using System.Net;
using System.IO;
using System.Text;
using System.Collections;
using System.Net.Sockets;
using System.Web.Mail;

namespace SmtpClient {

    /// represents a conntection to a smtp server
    public class SmtpClient {
	
	private string server;
	private TcpClient tcpConnection;
	private SmtpStream smtp;
	private Encoding encoding;
	
	//Initialise the variables and connect
	public SmtpClient( string server ) {
	    
	    this.server = server;
	    encoding = new ASCIIEncoding( );

	    Connect();
	}
	
	// make the actual connection
	// and HELO handshaking
	private void Connect() {
	    tcpConnection = new TcpClient( server , 25 );
	    
	    Stream stream = tcpConnection.GetStream();
	    smtp = new SmtpStream( stream );
	    
	    // read the server greeting
	    smtp.ReadResponse();
	    smtp.CheckForStatusCode( 220 );
	   
	    // write the HELO command to the server
	    smtp.WriteHelo( Dns.GetHostName() );
	    	    
	}
	
	public void Send( MailMessage msg ) {

	    if( ( ! HasData( msg.From )  ) || ( ! HasData( msg.To ) ) )
		throw new ArgumentException( &quot;From &amp; To properties must be set.&quot; );
	    
	    // start with a reset incase old data
	    // is present at the server in this session
	    smtp.WriteRset();
	    
	    // write the mail from command
	    smtp.WriteMailFrom( msg.From );
	    	    
	    // write the rcpt to command
	    smtp.WriteRcptTo( msg.To );
	    
	    // write the data command and then
	    // send the email
	    smtp.WriteData();
	   

	    if( msg.Attachments.Count == 0 ) {
		
		SendSinglepartMail( msg );
	    
	    } else {
		
		SendMultipartMail( msg );
	    
	    }

	    // write the data end tag &quot;.&quot;
	    smtp.WriteDataEndTag();

	}
	
	// sends a single part mail to the server
	private void SendSinglepartMail( MailMessage msg ) {
	    	    	    
	    // create the headers
	    IDictionary headers = CreateHeaders( msg );
	
	    smtp.WriteHeaders( headers );
	    
	    // send the mail body
	    smtp.WriteLine( msg.Body );

	}
	
	// sends a multipart mail to the server
	private void SendMultipartMail( MailMessage msg ) {
	    	    	    
	    // create the headers
	    IDictionary headers = CreateHeaders( msg );

	    // set the part boundary
	    string boundary = &quot;NextPart_000_1113_1962_1fe8&quot;;
		
	    // set the Content-Type header to multipart/mixed
	    headers[ &quot;Content-Type&quot; ] = 
		String.Format( &quot;multipart/mixed;\r\n   boundary={0}&quot; , boundary );
		
	    // write the headers
	    // and start writing the multipart body
	    smtp.WriteHeaders( headers );
		
	    // write the first part text part
	    // before the attachments
	    smtp.WriteBoundary( boundary );
		
	    Hashtable partHeaders = new Hashtable();
	    partHeaders[ &quot;Content-Type&quot; ] = &quot;text/plain&quot;;
		
	    smtp.WriteHeaders( partHeaders );
	    		
	    smtp.WriteLine( msg.Body );

	    smtp.WriteBoundary( boundary );
	    
	    // now start to write the attachments

	    for( int i=0; i&lt; msg.Attachments.Count ; i++ ) {
		MailAttachment a = (MailAttachment)msg.Attachments[ i ];
		FileStream file = 
		    new FileStream( a.Filename , FileMode.Open );
		    		    
		Hashtable aHeaders = new Hashtable();
		
		aHeaders[ &quot;Content-Type&quot; ] = 
		    String.Format( &quot;unknown/unknown; name=\&quot;{0}\&quot;&quot;, a.Filename );
		
		aHeaders[ &quot;Content-Disposition&quot; ] = 
		    String.Format( &quot;attachment; filename=\&quot;{0}\&quot;&quot; , a.Filename );
		
		aHeaders[ &quot;Content-Transfer-Encoding&quot; ] = &quot;base64&quot;;
			
		smtp.WriteHeaders( aHeaders );
		    
		smtp.WriteBase64( file );
		    
		smtp.WriteLine( &quot;&quot; );
		
		// if it is the last attachment write
		// the final boundary otherwise write
		// a normal one.
		if( i &lt; (msg.Attachments.Count - 1) ) { 
		    smtp.WriteBoundary( boundary );
		} else {
		    smtp.WriteFinalBoundary( boundary );
		}
		    
		file.Close();
	    }
	       
	}
	
	// send the standard headers
	// and the custom in MailMessage
	// FIXME: more headers needs to be added so
	// that all properties from MailMessage are sent..
	// missing: Priority , UrlContentBase,UrlContentLocation
	private IDictionary CreateHeaders( MailMessage msg ) {
	    Hashtable headers = new Hashtable(); 
	    
	    headers[ &quot;From&quot; ] = msg.From;
	    headers[ &quot;To&quot; ] = msg.To;
	    	    
	    if( HasData( msg.Cc ) ) headers[ &quot;Cc&quot; ] = msg.Cc;
			    
	    if( HasData( msg.Bcc ) ) headers[ &quot;Bcc&quot; ] = msg.Bcc;
	    
	    if( HasData( msg.Subject ) ) headers[ &quot;Subject&quot; ] = msg.Subject;
	    
	    if( HasData( msg.UrlContentBase ) ) 
		headers[ &quot;Content-Base&quot; ] = msg.UrlContentBase;
	    
	    if( HasData( msg.UrlContentLocation ) ) 
		headers[ &quot;Content-Location&quot; ] = msg.UrlContentLocation;
	    
	    // set body the content type
	    switch( msg.BodyFormat ) {
		
	    case MailFormat.Html: 
		headers[ &quot;Content-Type&quot; ] = &quot;text/html&quot;; 
		break;
	    
	    case MailFormat.Text: 
		headers[ &quot;Content-Type&quot; ] = &quot;text/plain&quot;; 
		break;
	    
	    default: 
		headers[ &quot;Content-Type&quot; ] = &quot;text/plain&quot;; 
		break;

	    }
	    
	    // set the priority as in the same way as .NET sdk does
	    switch( msg.Priority ) {
		
	    case MailPriority.High: 
		headers[ &quot;Importance&quot; ] = &quot;high&quot;;
		break;
	    
	    case MailPriority.Low: 
		headers[ &quot;Importance&quot; ] = &quot;low&quot;;
		break;
		
	    case MailPriority.Normal: 
		headers[ &quot;Importance&quot; ] = &quot;normal&quot;;
		break;
		
	    default: 
		headers[ &quot;Importance&quot; ] = &quot;normal&quot;;
		break;

	    }
	    
	    // .NET sdk allways sets this to normal
	    headers[ &quot;Priority&quot; ] = &quot;normal&quot;;
	    

	    // add mime version
	    headers[ &quot;Mime-Version&quot; ] = &quot;1.0&quot;;
	    
	    // set the mailer -- should probably be changed
	    headers[ &quot;X-Mailer&quot; ] = &quot;Mono (System.Web.Mail.SmtpMail.Send)&quot;;
	    
	    // add the custom headers they will overwrite
	    // the earlier ones if they are the same
	    foreach( string key in msg.Headers.Keys )
		headers[ key ] = (string)msg.Headers[ key ];
		
	    

	    return headers;
	}
	
	// returns true if str is not null and not
	// empty
	private bool HasData( string str ) {
	    bool hasData = false;
	    if( str != null ) {
		if( str.Length &gt; 0 ) {
		    hasData = true;
		}
	    }
	    return hasData;
	}
	
	
	// send quit command and
	// closes the connection
	public void Close() {
	    
	    smtp.WriteQuit();
	    tcpConnection.Close();
	
	}
	
		
    }

}

--------------Boundary-00=_CKKQ6KQ4H56G5CMEJPMK
Content-Type: text/x-c++src;
  charset=&quot;us-ascii&quot;;
  name=&quot;SmtpResponse.cs&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=&quot;SmtpResponse.cs&quot;

// SmtpResponse.cs
// author: Per Arneng &lt;<A HREF="mailto:pt99par@student.bth.se">pt99par@student.bth.se</A>&gt;
using System;

namespace SmtpClient {

    /// this class represents the response from the smtp server
    public class SmtpResponse {
	
	private string rawResponse;
	private int statusCode;
	private string[] parts;

	/// use the Parse method to create instances
	protected SmtpResponse() {}

	/// the smtp status code FIXME: change to Enumeration?
	public int StatusCode {
	    get { return statusCode; }
	    set { statusCode = value; }
	}
	
	/// the response as it was recieved
	public string RawResponse {
	    get { return rawResponse; }
	    set { rawResponse = value; }
	}

	/// the response as parts where ; was used as delimiter
	public string[] Parts {
	    get { return parts; }
	    set { parts = value; }
	}

	/// parses a new response object from a response string
	public static SmtpResponse Parse( string line ) {
	    SmtpResponse response = new SmtpResponse();
	    
	    if( line == null )
		throw new ArgumentNullException( &quot;Null is not allowed &quot; + 
						 &quot;as a response string.&quot;);

	    if( line.Length &lt; 4 ) 
		throw new FormatException( &quot;Response is to short &quot; + 
					   line.Length + &quot;.&quot;);
	    
	    if( line[ 3 ] != ' ' )
		throw new FormatException( &quot;Response format is wrong.&quot;);
	    
	    // parse the response code
	    response.StatusCode = Int32.Parse( line.Substring( 0 , 3 ) );
	    
	    // set the rawsponse
	    response.RawResponse = line;

	    // set the response parts
	    response.Parts = line.Substring( 0 , 3 ).Split( ';' );

	    return response;
	}
    }

}

--------------Boundary-00=_CKKQ6KQ4H56G5CMEJPMK
Content-Type: text/x-c++src;
  charset=&quot;us-ascii&quot;;
  name=&quot;SmtpStream.cs&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment; filename=&quot;SmtpStream.cs&quot;

// SmtpStream.cs
// author: Per Arneng &lt;<A HREF="mailto:pt99par@student.bth.se">pt99par@student.bth.se</A>&gt;
using System;
using System.IO;
using System.Collections;
using System.Text;
using System.Security.Cryptography;

namespace SmtpClient {

    public class SmtpStream {
	
	protected Stream stream;
	protected Encoding encoding;
	protected SmtpResponse lastResponse;
	protected string command = &quot;&quot;;

	public SmtpStream( Stream stream ) {
	    this.stream = stream;
	    encoding = new ASCIIEncoding();
	}
	
	public SmtpResponse LastResponse {
	    get { return lastResponse; }
	}
	
	public void WriteRset() {
	    command = &quot;RSET&quot;;
	    WriteLine( command );
	    ReadResponse();
	    CheckForStatusCode( 250 );
	
	}
	
	public void WriteHelo( string hostName ) { 
	    command = &quot;HELO &quot; + hostName;
	    WriteLine( command );
	    ReadResponse();
	    CheckForStatusCode( 250 );
	    
	}
	
	public void WriteMailFrom( string from ) {
	    command = &quot;MAIL FROM: &quot; + from;
	    WriteLine( command );
	    ReadResponse();
	    CheckForStatusCode( 250 );
	    
	}
	
	public void WriteRcptTo( string to ) {
	    command = &quot;RCPT TO: &quot; + to;  
	    WriteLine( command );
	    ReadResponse();
	    CheckForStatusCode( 250 );
	    	    
	}
	

	public void WriteData() {
	    command = &quot;DATA&quot;;
	    WriteLine( command );
	    ReadResponse();
	    CheckForStatusCode( 354 );
	
	}
	
	public void WriteQuit() {
	    command = &quot;QUIT&quot;;
	    WriteLine( command );
	    ReadResponse();
	    CheckForStatusCode( 221 );
	
	}
		
	public void WriteBoundary( string boundary ) {
	
	    WriteLine( &quot;--{0}&quot; , boundary );
	
	}
	
	public void WriteFinalBoundary( string boundary ) {
	
	    WriteLine( &quot;--{0}--&quot; , boundary );
	
	}
	
	public void WriteDataEndTag() {
	    command = &quot;.&quot;;
	    WriteLine( command );
	    ReadResponse();
	    CheckForStatusCode( 250 );
	
	}
	
	
	public void WriteHeaders( IDictionary headers ) {
	    // write the headers
	    foreach( string key in headers.Keys )
		WriteLine( &quot;{0}: {1}&quot; , key , (string)headers[ key ] );
	    
	    // write the header end tag
	    WriteLine( &quot;&quot; );
	}
	
	public void CheckForStatusCode( int statusCode ) {
	    
	    if( LastResponse.StatusCode != statusCode ) {
		
		string msg = &quot;&quot; + 
		    &quot;Server reponse: '&quot; + lastResponse.RawResponse + &quot;';&quot; +
		    &quot;Status code: '&quot; +  lastResponse.StatusCode + &quot;';&quot; + 
		    &quot;Expected status code: '&quot; + statusCode + &quot;';&quot; + 
		    &quot;Last command: '&quot; + command + &quot;'&quot;;
		
		throw new SmtpException( msg ); 
					
	    }
	}
	
	// writes a formatted line to the server
	public void WriteLine( string format ,  params object[] args ) {
	    WriteLine( String.Format( format , args ) );
	}
	
	// writes a line to the server
	public void WriteLine( string line ) {
	    byte[] buffer = encoding.GetBytes( line + &quot;\r\n&quot; );
	    
	    stream.Write( buffer , 0 , buffer.Length );
	
	    #if DEBUG 
	      DebugPrint( line );
            #endif
	}
	
	// read a line from the server
	public void ReadResponse( ) {
	    string line = null;
	    
	    byte[] buffer = new byte[ 4096 ];
	    
	    int readLength = stream.Read( buffer , 0 , buffer.Length );
	    
	    if( readLength &gt; 0 ) { 
	    
		line = encoding.GetString( buffer , 0 , readLength );
		
		line = line.TrimEnd( new Char[] { '\r' , '\n' , ' ' } );
			
	    }
	   
	    // parse the line to the lastResponse object
	    lastResponse = SmtpResponse.Parse( line );
	   
	    #if DEBUG
	      DebugPrint( line );
	    #endif
	}


	// reads bytes from a stream and writes the encoded
	// as base64 encoded characters. ( 60 chars on each row)
	public void WriteBase64( Stream inStream ) {
	
	    ICryptoTransform base64 = new ToBase64Transform();
	    ASCIIEncoding encoding = new ASCIIEncoding();
	
	    // the buffers
	    byte[] plainText = new byte[ base64.InputBlockSize ];
	    byte[] cipherText = new byte[ base64.OutputBlockSize ];

	    int readLength = 0;
	    int trLength = 0;
	
	    StringBuilder row = new StringBuilder( 60 );
	
	    // read through the stream until there 
	    // are no more bytes left
	    while( true ) {
		readLength = inStream.Read( plainText , 0 , plainText.Length );
	    
		// break when there is no more data
		if( readLength &lt; 1 ) break;
	    
		// transfrom and write the blocks. If the block size
		// is less than the InputBlockSize then write the final block
		if( readLength == plainText.Length ) {
		
		    trLength = base64.TransformBlock( plainText , 0 , 
						      plainText.Length ,
						      cipherText , 0 );
		
		    // trLength must be the same size as the cipherText
		    // length otherwise something is wrong
		    if( trLength != cipherText.Length )
			throw new Exception( &quot;All of the plaintext bytes where not converted&quot; );
		
		    // convert the bytes to a string and then add it to the
		    // current row
		    string cipherString = encoding.GetString( cipherText , 0 , trLength ); 
		    row.Append( cipherString );
		
		    // when a row is full write it and begin
		    // on the next row
		    if( row.Length == 60 ) {
			WriteLine( row.ToString() );
			row.Remove( 0 , 60 );
		    }
		
		} else {
		    // convert the final blocks of bytes
		    cipherText = base64.TransformFinalBlock( plainText , 0 , readLength );
		
		    // convert the bytes to a string and then write it
		    string cipherString = encoding.GetString( cipherText , 0 , 
							      cipherText.Length );
		    row.Append( cipherString );
		    WriteLine( row.ToString() );
		
		}
	    
	    } 
    
	}
	
	/// debug printing 
	private void DebugPrint( string line ) {
	    Console.WriteLine( &quot;smtp: {0}&quot; , line );
	}

    }


}

--------------Boundary-00=_CKKQ6KQ4H56G5CMEJPMK--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="012392.html">[Mono-list] Syntax Error???
</A></li>
	<LI> Next message: <A HREF="012394.html">[Mono-list] Status of the new JIT engine?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12393">[ date ]</a>
              <a href="thread.html#12393">[ thread ]</a>
              <a href="subject.html#12393">[ subject ]</a>
              <a href="author.html#12393">[ author ]</a>
         </LI>
       </UL>
</body></html>
