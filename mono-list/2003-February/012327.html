<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Patch to Sys.Win.Forms/Sys.Drawing 1/2
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pigolkine%40gmx.de">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="012331.html">
   <LINK REL="Next"  HREF="012328.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Patch to Sys.Win.Forms/Sys.Drawing 1/2
   </H1>
    <B>Alexandre Pigolkine
    </B> 
    <A HREF="mailto:pigolkine%40gmx.de"
       TITLE="[Mono-list] Patch to Sys.Win.Forms/Sys.Drawing 1/2">pigolkine@gmx.de
       </A><BR>
    <I>20 Feb 2003 00:20:43 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="012331.html">[Mono-list] XML Read() statement
</A></li>
        <LI> Next message: <A HREF="012328.html">[Mono-list] Patch to Sys.Win.Forms/Sys.Drawing 2/2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12327">[ date ]</a>
              <a href="thread.html#12327">[ thread ]</a>
              <a href="subject.html#12327">[ subject ]</a>
              <a href="author.html#12327">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Index: Button.cs
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/Button.cs,v
retrieving revision 1.11
diff -u -r1.11 Button.cs
--- Button.cs	10 Feb 2003 06:28:51 -0000	1.11
+++ Button.cs	19 Feb 2003 23:03:13 -0000
@@ -11,6 +11,7 @@
 //
 
 using System.Drawing;
+using System.Runtime.InteropServices;
 
 namespace System.Windows.Forms {
 
@@ -261,12 +262,13 @@
 			switch (m.Msg) {
 				case Msg.WM_DRAWITEM: {
 					DRAWITEMSTRUCT dis = new DRAWITEMSTRUCT();
-					Win32.CopyMemory(ref dis, m.LParam, 48);
+					dis = (DRAWITEMSTRUCT)Marshal.PtrToStructure(m.LParam, dis.GetType());
 					Rectangle	rect = new Rectangle(dis.rcItem.left, dis.rcItem.top, dis.rcItem.right - dis.rcItem.left, dis.rcItem.bottom - dis.rcItem.top);
 					DrawItemEventArgs args = new DrawItemEventArgs(Graphics.FromHdc(dis.hDC), Font,
 						rect, dis.itemID, (DrawItemState)dis.itemState);
 					OnDrawItem( args);
-					Win32.CopyMemory(m.LParam, ref dis, 48);
+					//Marshal.StructureToPtr(dis, m.LParam, false);
+					m.Result = (IntPtr)1;
 				}
 					break;
 				default:
Index: ChangeLog
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/ChangeLog,v
retrieving revision 1.82
diff -u -r1.82 ChangeLog
--- ChangeLog	14 Feb 2003 02:17:26 -0000	1.82
+++ ChangeLog	19 Feb 2003 23:03:13 -0000
@@ -1,3 +1,14 @@
+ 2003-02-19 Alexandre Pigolkine &lt;<A HREF="mailto:pigolkine@gmx.de">pigolkine@gmx.de</A>&gt;
+	* Button.cs
+	* CheckedListBox.cs
+	* ComboBox.cs
+	* Control.cs
+	* ControlPaint.cs
+	* Form.cs
+	* ListBox.cs
+	* win32functions.cs
+					implementation added
+					
  2003-02-11 Alexandre Pigolkine &lt;<A HREF="mailto:pigolkine@gmx.de">pigolkine@gmx.de</A>&gt;
  	* ButtonBase.cs
 	* ComboBox.cs
@@ -1297,6 +1308,7 @@
 * RichTextBoxSelectionAttribute.cs
 * RichTextBoxSelectionTypes.cs
 * RichTextBoxStreamType.cs
+
 * RichTextBoxWordPunctuations.cs
 * RightToLeft.cs
 * SaveFileDialog.cs
@@ -1960,6 +1972,7 @@
 * Stubbed and commented out
 * NativeWindow.cs, MonthCalendar.HitTestInfo.cs, MouseEventArgs.cs,
 * have bad extra byte from old skeleton, need new corrected version.
+
 * MonthCalendar.HitTestInfo.cs needs to be incorporated into MonthCalendar.
 
 2002-5-27 DennisHayes &lt;<A HREF="mailto:dennish@raytek.com">dennish@raytek.com</A>&gt;
Index: CheckedListBox.cs
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/CheckedListBox.cs,v
retrieving revision 1.13
diff -u -r1.13 CheckedListBox.cs
--- CheckedListBox.cs	6 Feb 2003 03:44:35 -0000	1.13
+++ CheckedListBox.cs	19 Feb 2003 23:03:14 -0000
@@ -23,6 +23,7 @@
 		// private fields
 		private bool checkOnClick;
 		private bool threeDCheckBoxes;
+		private CheckedListBox.ObjectCollection Items_;
 		
 		
 		// --- Constructor ---
@@ -30,6 +31,8 @@
 		{
 			checkOnClick = false;
 			threeDCheckBoxes = true;
+			Items_ = new CheckedListBox.ObjectCollection(this);
+			DrawMode_ = DrawMode.Normal;
 		}
 		
 		// --- CheckedListBox Properties ---
@@ -57,37 +60,23 @@
 		[MonoTODO]
 		protected override CreateParams CreateParams {
 			get {
-				CreateParams createParams = new CreateParams ();
-				window = new ControlNativeWindow (this);
-
-				createParams.Caption = Text;
-				createParams.ClassName = &quot;CHECKEDLISTBOX&quot;;
-				createParams.X = Left;
-				createParams.Y = Top;
-				createParams.Width = Width;
-				createParams.Height = Height;
-				createParams.ClassStyle = 0;
-				createParams.ExStyle = 0;
-				createParams.Param = 0;
-				//			createParams.Parent = Parent.Handle;
-				createParams.Style = (int) (
-					WindowStyles.WS_CHILD | 
-					WindowStyles.WS_VISIBLE |
-					WindowStyles.WS_CLIPSIBLINGS);
-				window.CreateHandle (createParams);
-				return createParams;
+				if( Parent != null) {
+					CreateParams createParams = base.CreateParams;
+					// set ownerDraw flag to be able to paint check-boxes
+					createParams.Style |= (int)ListBoxStyles.LBS_OWNERDRAWFIXED;
+					return createParams;
+				}
+				return null;
 			}		
 		}
 		
 		[MonoTODO]
 		public override DrawMode DrawMode {
 			get {
-				//FIXME
-				return base.DrawMode;
+				return DrawMode.Normal;
 			}
 			set {
-				//FIXME
-				base.DrawMode = value;
+				// always DrawMode.Normal
 			}
 		}
 		
@@ -106,7 +95,7 @@
 		[MonoTODO]
 		public CheckedListBox.ObjectCollection Items {
 			get {
-				throw new NotImplementedException (); 
+				return Items_; 
 			}
 		}
 
@@ -188,8 +177,11 @@
 		[MonoTODO]
 		protected override void OnDrawItem(DrawItemEventArgs e)
 		{
-			//FIXME
-			base.OnDrawItem(e);
+			Rectangle checkRect = new Rectangle( e.Bounds.Left, e.Bounds.Top, e.Bounds.Height, e.Bounds.Height);
+			Rectangle textRect = new Rectangle( checkRect.Right, e.Bounds.Top, e.Bounds.Width - checkRect.Width, e.Bounds.Height);
+			ControlPaint.DrawCheckBox(e.Graphics, checkRect, ButtonState.Normal);
+			e.Graphics.DrawString(Items_[e.Index].ToString(), Font, SystemBrushes.ControlText, textRect.X, textRect.Y);
+			//base.OnDrawItem(e);
 		}
 		
 		[MonoTODO]
@@ -204,6 +196,11 @@
 		{
 			//FIXME
 			base.OnHandleCreated(e);
+			if( Items_ != null) {
+				foreach( object item in Items_) {
+					Win32.SendMessage(Handle, (int)ListBoxMessages.LB_ADDSTRING, 0, item.ToString());
+				}
+			}
 		}
 		
 		// only supports .NET framework, thus is not stubbed out
@@ -265,9 +262,6 @@
 		/// - public new event DrawItemEventHandler DrawItem;
 		/// - public new event MeasureItemEventHandler MeasureItem;
 		public event ItemCheckEventHandler ItemCheck;
-		
-		
-		
 		
 		/// sub-class: CheckedListBox.CheckedIndexCollection
 		/// &lt;summary&gt;
Index: ComboBox.cs
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/ComboBox.cs,v
retrieving revision 1.19
diff -u -r1.19 ComboBox.cs
--- ComboBox.cs	14 Feb 2003 02:17:26 -0000	1.19
+++ ComboBox.cs	19 Feb 2003 23:03:14 -0000
@@ -11,6 +11,7 @@
 using System.ComponentModel;
 using System.Collections;
 using System.Drawing;
+using System.Runtime.InteropServices;
 
 namespace System.Windows.Forms {
 
@@ -37,6 +38,7 @@
 		int selecedStart;
 		private ComboBox.ObjectCollection Items_ = null;
 		int itemHeight_;
+		int maxDropDownItems;
 
 		bool updateing; // true when begin update has been called. do not paint when true;
 		// --- Constructor ---
@@ -58,8 +60,10 @@
 			text = &quot;&quot;;
 			Items_ = new ComboBox.ObjectCollection(this);
 			itemHeight_ = 13;
-
+			maxDropDownItems = 8;
 			SubClassWndProc_ = true;
+
+			Size = DefaultSize;
 		}
 		
 		// --- Properties ---
@@ -91,6 +95,12 @@
 			}
 		}
 		
+		internal int getDropDownHeight() {
+			// FIXME: use PreferredHeight instead of DefaultSize.Height ?
+			// FIXME: those calculations probably wrong
+			return DefaultSize.Height + (maxDropDownItems + 1) * itemHeight_ - (itemHeight_ / 2);
+		}
+
 		[MonoTODO]
 		protected override CreateParams CreateParams {
 			get {
@@ -105,8 +115,12 @@
 					createParams.X = Left;
 					createParams.Y = Top;
 					createParams.Width = Width;
-					// FIXME: Create combo box with 5 elements in drop down list box
-					createParams.Height = Height * 5;
+					if( DropDownStyle == ComboBoxStyle.Simple) {
+						createParams.Height = Height;
+					}
+					else {
+						createParams.Height = getDropDownHeight();
+					}
 					createParams.ClassStyle = 0;
 					createParams.ExStyle = (int)( WindowExStyles.WS_EX_RIGHTSCROLLBAR | WindowExStyles.WS_EX_NOPARENTNOTIFY);
 					createParams.Param = 0;
@@ -141,10 +155,12 @@
 					if( !integralHeight) {
 						createParams.Style |= (int)ComboBoxStyles.CBS_NOINTEGRALHEIGHT;
 					}
+/*
+ *	Keep Control unsorted, but sort data in Items (ArrayList)
 					if( sorted) {
 						createParams.Style |= (int)ComboBoxStyles.CBS_SORT;
 					}
-
+*/
 					return createParams;
 				}
 				return null;
@@ -156,7 +172,25 @@
 				return new Size(121,21);//correct size
 			}
 		}
+/*
+		public new Size Size {
+			//FIXME: should we return client size or someother size???
+			get {
+				return base.Size;
+			}
+			set {
 
+				if( dropDownStyle == ComboBoxStyle.Simple) {
+					Size sz = value;
+					sz.Height += maxDropDownItems * itemHeight_;
+					base.Size = sz;
+				}
+				else {
+					base.Size = value;
+				}
+			}
+		}
+*/
 		public DrawMode DrawMode {
 			get {
 				return drawMode;
@@ -268,10 +302,15 @@
 		[MonoTODO]
 		public int MaxDropDownItems {
 			get {
-				throw new NotImplementedException ();
+				return maxDropDownItems;
 			}
 			set {
-				//FIXME:		
+				if( maxDropDownItems != value) {
+					maxDropDownItems = value;
+					if( DropDownStyle != ComboBoxStyle.Simple) {
+						Height = getDropDownHeight();
+					}
+				}
 			}
 		}
 		
@@ -371,16 +410,13 @@
 					sorted = value;
 					if( IsHandleCreated) {
 						if( sorted) {
-							Win32.UpdateWindowStyle(Handle, 0, (int)ComboBoxStyles.CBS_SORT);
 							object[] items = new object[Items.Count];
 							Items.CopyTo(items, 0);
 							Items.Clear();
 							Items.AddRange(items);
 						}
-						else {
-							Win32.UpdateWindowStyle(Handle, (int)ComboBoxStyles.CBS_SORT, 0);
-						}
 					}
+					selectedIndex = -1;
 				}
 			}
 		}
@@ -395,15 +431,13 @@
 			}
 		}
 		
-		
-		
-		
 		/// --- Methods ---
 		/// internal .NET framework supporting methods, not stubbed out:
 
 		internal void populateControl( ICollection items) {
 			if( IsHandleCreated &amp;&amp; items != null) {
 				foreach( object obj in items) {
+					// CHECKME : shall we check for null here or in Add/Insert functions
 					if( obj != null) {
 						Win32.SendMessage(Handle, (int)ComboBoxMessages.CB_ADDSTRING, 0, getDisplayMemberOfObj(obj));
 					}
@@ -514,7 +548,9 @@
 		[MonoTODO]
 		protected virtual void OnDropDownStyleChanged(EventArgs e) 
 		{
-			//FIXME:		
+			if( DropDownStyleChanged != null) {
+				DropDownStyleChanged(this, e);
+			}
 		}
 		
 		[MonoTODO]
@@ -615,7 +651,24 @@
 		protected override void SetBoundsCore(int x,int y,int width,int height,BoundsSpecified specified) 
 		{
 			//FIXME:
+			// If DropDownStyle == ComboBoxStyle.Simple, the heigth is a real window height - no control over it
+			// else, 
+			//		if Handle created - specify complete height, ComboBox-control will adjust window rectangle
+			//			else - set the height to Default.
+			if(DropDownStyle != ComboBoxStyle.Simple) {
+				if( IsHandleCreated) {
+					height = getDropDownHeight();
+				}
+				else {
+					height = DefaultSize.Height;
+				}
+			}
 			base.SetBoundsCore(x,y,width,height,specified);
+			// FIXME: this is needed, otherwise painting is not correct
+			if( dropDownStyle == ComboBoxStyle.Simple ) {
+				Win32.InvalidateRect(Handle, IntPtr.Zero, 0);
+				Win32.UpdateWindow(Handle);
+			}
 		}
 		
 		// for IList interface
@@ -639,24 +692,26 @@
 			switch (m.Msg) {
 				case Msg.WM_MEASUREITEM: {
 					MEASUREITEMSTRUCT mis = new MEASUREITEMSTRUCT();
-					Win32.CopyMemory(ref mis, m.LParam, 24);
+					mis = (MEASUREITEMSTRUCT)Marshal.PtrToStructure(m.LParam, mis.GetType());
 					MeasureItemEventArgs args = new MeasureItemEventArgs(CreateGraphics(),mis.itemID);
 					args.ItemHeight = mis.itemHeight;
 					args.ItemWidth = mis.itemWidth;
 					OnMeasureItem( args);
 					mis.itemHeight = args.ItemHeight;
 					mis.itemWidth = args.ItemWidth;
-					Win32.CopyMemory(m.LParam, ref mis, 24);
+					Marshal.StructureToPtr(mis, m.LParam, false);
+					m.Result = (IntPtr)1;
 				}
 					break;
 				case Msg.WM_DRAWITEM: {
 					DRAWITEMSTRUCT dis = new DRAWITEMSTRUCT();
-					Win32.CopyMemory(ref dis, m.LParam, 48);
+					dis = (DRAWITEMSTRUCT)Marshal.PtrToStructure(m.LParam, dis.GetType());
 					Rectangle	rect = new Rectangle(dis.rcItem.left, dis.rcItem.top, dis.rcItem.right - dis.rcItem.left, dis.rcItem.bottom - dis.rcItem.top);
 					DrawItemEventArgs args = new DrawItemEventArgs(Graphics.FromHdc(dis.hDC), Font,
 						rect, dis.itemID, (DrawItemState)dis.itemState);
 					OnDrawItem( args);
-					Win32.CopyMemory(m.LParam, ref dis, 48);
+					//Marshal.StructureToPtr(dis, m.LParam, false);
+					m.Result = (IntPtr)1;
 				}
 					break;
 /*
@@ -771,22 +826,49 @@
 				[MonoTODO] get { return collection_.IsSynchronized; }
 			}
 			
+			class ComboItemComparer : IComparer {
+				private ComboBox owner_ = null;
+				public ComboItemComparer(ComboBox owner) {
+					owner_ = owner;
+				}
+
+				public int Compare(object x, object y) {
+					return owner_.getDisplayMemberOfObj(x).CompareTo(owner_.getDisplayMemberOfObj(y));
+				}
+			}
+
 			/// --- methods ---
 			/// --- ObjectCollection Methods ---
 			/// Note: IList methods are stubbed out, otherwise IList interface cannot be implemented
 			[MonoTODO]
-			public int Add(object item) 
-			{
-				int result = collection_.Add(item);
-				owner_.populateControl(new object[] {item});
-				return result;
+			public int Add(object item) {
+				// FIXME: not optimal 
+				int idx = collection_.Add(item);
+				if( owner_.Sorted) {
+					ComboItemComparer cic = new ComboItemComparer(owner_);
+					collection_.Sort(cic);
+					idx = collection_.BinarySearch(item,cic);
+					if( owner_.IsHandleCreated) {
+						Win32.SendMessage(owner_.Handle, (int)ComboBoxMessages.CB_INSERTSTRING, idx, owner_.getDisplayMemberOfObj(item));
+					}
+				}
+				else {
+					if( owner_.IsHandleCreated) {
+						Win32.SendMessage(owner_.Handle, (int)ComboBoxMessages.CB_ADDSTRING, 0, owner_.getDisplayMemberOfObj(item));
+					}
+				}
+				return idx;
 			}
 			
 			[MonoTODO]
 			public void AddRange(object[] items) 
 			{
-				collection_.AddRange(items);
-				owner_.populateControl(items);
+				// FIXME: not optimal 
+				foreach(object item in items) {
+					Add(item);
+				}
+//				owner_.populateControl(items);
+//				collection_.AddRange(items);
 			}
 			
 			[MonoTODO]
Index: Control.cs
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/Control.cs,v
retrieving revision 1.26
diff -u -r1.26 Control.cs
--- Control.cs	14 Feb 2003 02:17:26 -0000	1.26
+++ Control.cs	19 Feb 2003 23:03:15 -0000
@@ -81,6 +81,7 @@
     		bool visible;
 			object tag;
 			protected bool mouseIsInside_;
+			bool recreatingHandle;

 			// BeginInvoke() etc. helpers
 			static int InvokeMessage = Win32.RegisterWindowMessage(&quot;mono_control_invoke_helper&quot;);
@@ -189,6 +190,7 @@
     			visible = true;
     			parent = null;
 				mouseIsInside_ = false;
+				recreatingHandle = false;
 				// Do not create Handle here, only in CreateHandle
     			// CreateHandle();//sets window handle. FIXME: No it does not
     		}
@@ -354,12 +356,7 @@
     				} else return bounds;
     			}
     			set {
-    				if (IsHandleCreated)
-    					Win32.SetWindowPos (
-    						//Handle, (IntPtr) 0, value.X, value.Y,
-							Handle, SetWindowPosZOrder.HWND_TOPMOST, value.X, value.Y,
-							value.Width, value.Height, 0);
-    				else bounds = value;
+					SetBounds(value.Left, value.Top, value.Width, value.Height);
     			}
     		}
     		
@@ -487,8 +484,7 @@
 				else {
 					Win32.AdjustWindowRect( ref rc, styleIfNoWindow, menuIfNoWindow ? 1 : 0);
 				}
-				Width = rc.right - rc.left;
-				Height = rc.bottom - rc.top;
+				Size = new Size(rc.right - rc.left, rc.bottom - rc.top);
 			}    		
     		
     		public bool ContainsFocus {
@@ -755,10 +751,11 @@
     				return bounds.Height;
     			}
     			set {
-    				bounds.Height = value;
+    				//bounds.Height = value;
     				if (IsHandleCreated) {
     					// FIXME: SetWindowPos
     				}
+					SetBounds(bounds.X, bounds.Y, bounds.Width, value, BoundsSpecified.Height);
     			}
     		}
     		
@@ -807,11 +804,10 @@
 					} else return bounds.X;
 				}
 				set {
-					bounds.X = value;
- 
 					if (IsHandleCreated) {
 						// FIXME: SetWindowPos
 					}
+					SetBounds(value, bounds.Y, bounds.Width, bounds.Height, BoundsSpecified.X);
 				}
 			}
  		
@@ -822,13 +818,10 @@
 					return new Point (Top, Left);
 				}
 				set {
-					bounds.X = value.X;
-					bounds.Y = value.Y;
-    
 					if (IsHandleCreated) {
 						// FIXME: SetWindowPos
 					}
-    
+					SetBounds(value.X, value.Y, bounds.Width, bounds.Height, BoundsSpecified.Location);
 				}
 			}
     		
@@ -918,7 +911,7 @@
     		[MonoTODO]
     		public bool RecreatingHandle {
     			get {
-    				throw new NotImplementedException ();
+    				return recreatingHandle;
     			}
     		}
     		
@@ -1004,15 +997,16 @@
     			}
     			set {
 					if( IsHandleCreated) {
+/*
 						Win32.SetWindowPos(Handle, SetWindowPosZOrder.HWND_TOP, 0, 0, value.Width, value.Height,
 							SetWindowPosFlags.SWP_NOMOVE | SetWindowPosFlags.SWP_NOMOVE | 
 							SetWindowPosFlags.SWP_NOZORDER);// Activating might be a good idea?? | SetWindowPosFlags.SWP_NOACTIVATE);
+*/							
 					}
-
-					Width = value.Width;
-					Height = value.Height;
-    			}
+					SetBounds(bounds.X, bounds.Y, value.Width, value.Height, BoundsSpecified.Size);
+				}
     		}
+
     		internal int tabindex;//for debug/test only. remove
     		[MonoTODO]
     		public int TabIndex {
@@ -1078,12 +1072,11 @@
     				} else return bounds.Top;
  			}
  			set {
- 				bounds.Y = value;
- 
  				if (IsHandleCreated) {
  					// FIXME: SetWindowPos
  				}
- 			}
+				SetBounds(bounds.X, value, bounds.Width, bounds.Height, BoundsSpecified.Y);
+			}
  		}
  		
     		[MonoTODO]
@@ -1117,11 +1110,11 @@
     				return bounds.Width;
     			}
     			set {
-    				bounds.Width = value;
     				if (IsHandleCreated) {
     					// FIXME: SetWindowPos
     				}
-    			}
+					SetBounds(bounds.X, bounds.Y, value, bounds.Height, BoundsSpecified.Width);
+				}
     		}
     		
     		/// --- methods ---
@@ -1656,7 +1649,7 @@
     		
     		protected virtual void OnMouseEnter (EventArgs e) 
     		{
-				System.Console.WriteLine(&quot;OnMouseEnter&quot;);
+				//System.Console.WriteLine(&quot;OnMouseEnter&quot;);
     			if (MouseEnter != null)
     				MouseEnter (this, e);
     		}
@@ -1669,7 +1662,7 @@
     		
     		protected virtual void OnMouseLeave (EventArgs e) 
     		{
-				System.Console.WriteLine(&quot;OnMouseLeave&quot;);
+				//System.Console.WriteLine(&quot;OnMouseLeave&quot;);
 
 				mouseIsInside_ = false;
     			if (MouseLeave != null)
@@ -1978,25 +1971,41 @@
     		// are big enough to warrant recreating the HWND
     		protected void RecreateHandle() 
     		{
+				recreatingHandle = true;
 				if( IsHandleCreated) {
 					DestroyHandle ();
 					CreateHandle ();
 				}
-       		}
+				recreatingHandle = false;
+			}
     		
  			//Compact Framework
     		[MonoTODO]
     		public Rectangle RectangleToClient (Rectangle r) 
     		{
-    			throw new NotImplementedException ();
+				// FIXME: What to return if Handle is not created yet ?
+				RECT rect = new RECT();
+				rect.left = r.Left;
+				rect.top = r.Top;
+				rect.right = r.Right;
+				rect.bottom = r.Bottom;
+				Win32.ScreenToClient(Handle,ref rect);
+				return new Rectangle( rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
     		}
     		
  			//Compact Framework
     		[MonoTODO]
     		public Rectangle RectangleToScreen (Rectangle r) 
     		{
-    			throw new NotImplementedException ();
-    		}
+				// FIXME: What to return if Handle is not created yet ?
+				RECT rect = new RECT();
+				rect.left = r.Left;
+				rect.top = r.Top;
+				rect.right = r.Right;
+				rect.bottom = r.Bottom;
+				Win32.ClientToScreen(Handle,ref rect);
+				return new Rectangle( rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
+			}
     		
     		[MonoTODO]
     		protected static bool ReflectMessage (IntPtr hWnd, ref Message m) {
@@ -2161,22 +2170,45 @@
     		[MonoTODO]
     		public void SetBounds (int x, int y, int width, int height) 
     		{
-				//FIXME:
+				SetBounds(x, y, width, height, BoundsSpecified.All);
 			}
     		
     		[MonoTODO]
-    		public void SetBounds (int x, int y, int width, int height,
-    				       BoundsSpecified specified) 
+    		public void SetBounds (int x, int y, int width, int height, BoundsSpecified specified) 
     		{
-				//FIXME:
+				SetBoundsCore( x, y, width, height, specified);
 			}
     		
     		[MonoTODO]
-    		protected virtual void SetBoundsCore (
-    			int x, int y, int width, int height,
-    			BoundsSpecified specified) 
+    		protected virtual void SetBoundsCore ( int x, int y, int width, int height, BoundsSpecified specified) 
     		{
-				//FIXME:
+				if( IsHandleCreated) {
+//					SetWindowPosFlags flags = SetWindowPosFlags.SWP_NOOWNERZORDER | SetWindowPosFlags.SWP_NOZORDER |
+//						SetWindowPosFlags.SWP_FRAMECHANGED | SetWindowPosFlags.SWP_DRAWFRAME;
+					SetWindowPosFlags flags = SetWindowPosFlags.SWP_NOZORDER |
+						SetWindowPosFlags.SWP_FRAMECHANGED | SetWindowPosFlags.SWP_DRAWFRAME;
+					Win32.SetWindowPos( Handle, SetWindowPosZOrder.HWND_NOTOPMOST, x, y, width, height, flags);
+					RECT rect = new RECT();
+					Win32.GetWindowRect (Handle, ref rect);
+					if( Parent != null) {
+						Win32.ScreenToClient(Parent.Handle, ref rect);
+					}
+					bounds = new Rectangle (rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
+				}
+				else {
+					if( (specified &amp; BoundsSpecified.X) != 0) {
+						bounds.X = x;
+					}
+					if( (specified &amp; BoundsSpecified.Y) != 0) {
+						bounds.Y = y;
+					}
+					if( (specified &amp; BoundsSpecified.Width) != 0) {
+						bounds.Width = width;
+					}
+					if( (specified &amp; BoundsSpecified.Height) != 0) {
+						bounds.Height = height;
+					}
+				}
 			}
     		
     		[MonoTODO]
Index: ControlPaint.cs
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/ControlPaint.cs,v
retrieving revision 1.13
diff -u -r1.13 ControlPaint.cs
--- ControlPaint.cs	10 Feb 2003 06:28:51 -0000	1.13
+++ ControlPaint.cs	19 Feb 2003 23:03:15 -0000
@@ -285,21 +285,28 @@
 		}
 		
 		[MonoTODO]
-		public static void DrawCheckBox(
-			Graphics graphics,
-			Rectangle rectangle) {
-			//FIXME:
+		public static void DrawCheckBox( Graphics graphics, Rectangle rectangle, ButtonState state) {
+			// FIXME: (sometimes) DrawFrameControl paints control not in &quot;desired&quot; position ( DC coordinates transformed or something like this)
+			// so, we paint to the bitmap ( fresh DC, (0,0)) and then DrawImage to requested position
+			Bitmap bmp = new Bitmap(rectangle.Width+1, rectangle.Height+1,graphics);
+			Graphics g = Graphics.FromImage(bmp);
+			// FIXME: fill new context with some color here?
+			IntPtr hdc = g.GetHdc();
+			RECT rc = new RECT();
+			rc.left = 0;
+			rc.top = 0;
+			rc.right = rectangle.Width;
+			rc.bottom = rectangle.Height;
+			int res = Win32.DrawFrameControl( hdc, ref rc, (uint)DrawFrameControl.DFC_BUTTON, (uint)DrawFrameControl.DFCS_BUTTONCHECK);
+			g.ReleaseHdc(hdc);
+			g.Dispose();
+			graphics.DrawImage(bmp, rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height);
+			bmp.Dispose();
 		}
 		
 		[MonoTODO]
-		public static void DrawCheckBox(
-			Graphics graphics,
-			int x,
-			int y,
-			int width,
-			int height,
-			ButtonState state) {
-			//FIXME:
+		public static void DrawCheckBox(Graphics graphics, int x, int y, int width, int height, ButtonState state) {
+			DrawCheckBox(graphics, new Rectangle(x, y, width, height), state);
 		}
 		
 		[MonoTODO]
Index: Form.cs
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/Form.cs,v
retrieving revision 1.26
diff -u -r1.26 Form.cs
--- Form.cs	6 Feb 2003 03:45:10 -0000	1.26
+++ Form.cs	19 Feb 2003 23:03:15 -0000
@@ -304,7 +304,8 @@
 //							//long myStyle = Win32.GetWindowLongA( Handle, Win32.GWL_STYLE);
 //							//myStyle |= (long)Win32.WS_OVERLAPPEDWINDOW;
 //							//Win32.SetWindowLongA( Handle, Win32.GWL_STYLE, myStyle);
-							Win32.SetMenu( Handle, mainMenu_.Handle);
+							int res = Win32.SetMenu( Handle, mainMenu_.Handle);
+							Console.WriteLine (&quot;Form.assignMenu. result {0}&quot;, res);
 						}
 						else {
 							Win32.SetMenu( Handle, IntPtr.Zero);
@@ -656,7 +657,7 @@
     		protected override void OnHandleCreated (EventArgs e)
     		{
     			base.OnHandleCreated (e);
-				Console.WriteLine (&quot;OnHandleCreated&quot;);
+				Console.WriteLine (&quot;Form.OnHandleCreated&quot;);
 				assignMenu();
 			}
     
Index: ListBox.cs
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/ListBox.cs,v
retrieving revision 1.20
diff -u -r1.20 ListBox.cs
--- ListBox.cs	6 Feb 2003 03:45:10 -0000	1.20
+++ ListBox.cs	19 Feb 2003 23:03:16 -0000
@@ -9,6 +9,7 @@
 //
 using System.Collections;
 using System.Drawing;
+using System.Runtime.InteropServices;
 
 namespace System.Windows.Forms {
 
@@ -33,6 +34,7 @@
 		protected ListBox.ObjectCollection	Items_ = null;
 		protected DrawMode DrawMode_ = DrawMode.Normal;
 		protected bool UseTabStops_ = false;
+		protected bool MultiColumn_ = false;
 		
 		//
 		//	 --- Public Fields
@@ -67,6 +69,19 @@
 				base.BackgroundImage = value;
 			}
 		}
+
+		public bool MultiColumn {
+			get {
+				return MultiColumn_;
+			}
+			set {
+				if( MultiColumn_ != value) {
+					MultiColumn_ = value;
+					RecreateHandle();
+				}
+			}
+		}
+
 		[MonoTODO]
 		public override RightToLeft RightToLeft {
 			get {
@@ -324,6 +339,12 @@
 							createParams.Style |= (int)ListBoxStyles.LBS_OWNERDRAWVARIABLE;
 							break;
 					}
+					if( MultiColumn_) {
+						createParams.Style |= (int)ListBoxStyles.LBS_MULTICOLUMN | (int)WindowStyles.WS_HSCROLL;
+					}
+					else {
+						createParams.Style |= (int)WindowStyles.WS_VSCROLL;
+					}
 					// CHECKME : this call is commented because (IMHO) Control.CreateHandle supposed to do this
 					// and this function is CreateParams, not CreateHandle
 					// window.CreateHandle (createParams);
@@ -403,6 +424,11 @@
 		protected override void OnHandleCreated(EventArgs e) {
 			//FIXME:
 			base.OnHandleCreated(e);
+			if( Items_ != null) {
+				foreach( object item in Items_) {
+					Win32.SendMessage(Handle, (int)ListBoxMessages.LB_ADDSTRING, 0, item.ToString());
+				}
+			}
 		}
 		[MonoTODO]
 		protected override void OnHandleDestroyed(EventArgs e) {
@@ -461,24 +487,26 @@
 			switch (m.Msg) {
 				case Msg.WM_MEASUREITEM: {
 					MEASUREITEMSTRUCT mis = new MEASUREITEMSTRUCT();
-					Win32.CopyMemory(ref mis, m.LParam, 24);
+					mis = (MEASUREITEMSTRUCT)Marshal.PtrToStructure(m.LParam, mis.GetType());
 					MeasureItemEventArgs args = new MeasureItemEventArgs(CreateGraphics(),mis.itemID);
 					args.ItemHeight = mis.itemHeight;
 					args.ItemWidth = mis.itemWidth;
 					OnMeasureItem( args);
 					mis.itemHeight = args.ItemHeight;
 					mis.itemWidth = args.ItemWidth;
-					Win32.CopyMemory(m.LParam, ref mis, 24);
+					Marshal.StructureToPtr(mis, m.LParam, false);
+					m.Result = (IntPtr)1;
 					}
 					break;
 				case Msg.WM_DRAWITEM: {
 					DRAWITEMSTRUCT dis = new DRAWITEMSTRUCT();
-					Win32.CopyMemory(ref dis, m.LParam, 48);
+					dis = (DRAWITEMSTRUCT)Marshal.PtrToStructure(m.LParam, dis.GetType());
 					Rectangle	rect = new Rectangle(dis.rcItem.left, dis.rcItem.top, dis.rcItem.right - dis.rcItem.left, dis.rcItem.bottom - dis.rcItem.top);
 					DrawItemEventArgs args = new DrawItemEventArgs(Graphics.FromHdc(dis.hDC), Font,
 						rect, dis.itemID, (DrawItemState)dis.itemState);
 					OnDrawItem( args);
-					Win32.CopyMemory(m.LParam, ref dis, 48);
+					//Marshal.StructureToPtr(dis, m.LParam, false);
+					m.Result = (IntPtr)1;
 					}
 					break;
 				default:
@@ -696,6 +724,9 @@
 				int result = -1;
 				if( item != null) {
 					result = items_.Add(item);
+					if( owner_.IsHandleCreated) {
+						Win32.SendMessage(owner_.Handle, (int)ListBoxMessages.LB_ADDSTRING, 0, item.ToString());
+					}
 				}
 				return result;
 			}
Index: NativeWindow.cs
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/NativeWindow.cs,v
retrieving revision 1.19
diff -u -r1.19 NativeWindow.cs
--- NativeWindow.cs	14 Feb 2003 02:17:53 -0000	1.19
+++ NativeWindow.cs	19 Feb 2003 23:03:16 -0000
@@ -110,6 +110,7 @@
 					if( (cp.Style &amp; (int)WindowStyles.WS_CHILD) != 0) {
 						Win32.SetWindowLong(windowHandle, GetWindowLongFlag.GWL_ID, (int)windowHandle);
 					}
+					System.Console.WriteLine(&quot;Created window {0}, class {1}&quot;, windowHandle,cp.ClassName);
 				}
 				//debug
 				else {
@@ -177,14 +178,16 @@
 		{
 		}
 
+		static int messageLevel = 0;
  		static private IntPtr WndProc (
-			IntPtr hWnd, Msg msg, IntPtr wParam, IntPtr lParam) 
+			IntPtr hWnd, Msg msg, IntPtr wParam, IntPtr lParam)
 		{
+			Console.WriteLine(&quot;WndProc{0} enter {1}&quot;, messageLevel++, msg);
  			Message message = new Message ();
  			NativeWindow window = null;
 			// CHECKME: This try/catch is implemented to keep Message Handlers &quot;Exception safe&quot;
 			try {
-				// windowCollection is a collection of all the 
+				// windowCollection is a collection of all the
 				// NativeWindow(s) that have been created.
 				// Dispatch the current message to the approriate
 				// window.
@@ -194,10 +197,10 @@
 				message.WParam = wParam;
 				message.LParam = lParam;
 	 			message.Result = (IntPtr) 0;
-	
+
 				if (msg == Msg.WM_CREATE)
 					Console.WriteLine (&quot;WM_CREATE (static)&quot;);
-					
+
 	 			if (window != null) {
 					if (msg == Msg.WM_CREATE) {
 						Console.WriteLine (&quot;WM_CREATE (static != null)&quot;);
@@ -215,9 +218,10 @@
 				if( window != null)
 					window.OnThreadException(ex);
 			}
+			Console.WriteLine(&quot;WndProc{0} exit {1}&quot;,--messageLevel, msg);
  			return message.Result;
  		}
- 		
+
 		internal static Win32.WndProc GetWindowProc() {
 			if( wp == null){
 				wp = new Win32.WndProc (WndProc);
Index: win32functions.cs
===================================================================
RCS file: /mono/mcs/class/System.Windows.Forms/System.Windows.Forms/win32functions.cs,v
retrieving revision 1.10
diff -u -r1.10 win32functions.cs
--- win32functions.cs	10 Feb 2003 06:28:51 -0000	1.10
+++ win32functions.cs	19 Feb 2003 23:03:16 -0000
@@ -40,7 +40,7 @@
 	/// &lt;summary&gt;
 	/// Windows API Functions
 	/// &lt;/summary&gt;
-	public class Win32
+	public class Win32 
 	{
 		#region Constructors
 		// No need to construct this object
@@ -77,19 +77,6 @@
 		[DllImport(&quot;kernel32.dll&quot;)]
 		internal static extern void OutputDebugString(string message);
 
-		[DllImport(&quot;kernel32.dll&quot;)]
-		internal static extern MEASUREITEMSTRUCT MulDiv(IntPtr ptr, int AlwaysOne, int AlwaysOneDiv);
-		[DllImport(&quot;kernel32.dll&quot;)]
-		internal static extern void CopyMemory(IntPtr ptr, ref MEASUREITEMSTRUCT mis, int Size);
-		[DllImport(&quot;kernel32.dll&quot;)]
-		internal static extern void CopyMemory(ref MEASUREITEMSTRUCT mis, IntPtr ptr, int Size);
-		[DllImport(&quot;kernel32.dll&quot;)]
-		internal static extern void CopyMemory(IntPtr ptr, ref DRAWITEMSTRUCT mis, int Size);
-		[DllImport(&quot;kernel32.dll&quot;)]
-		internal static extern void CopyMemory(ref DRAWITEMSTRUCT mis, IntPtr ptr, int Size);
-		[DllImport(&quot;kernel32.dll&quot;)]
-		internal static extern void CopyMemory(ref PAINTSTRUCT ps, IntPtr ptr, int Size);
-
 		[DllImport (&quot;kernel32.dll&quot;, CallingConvention = CallingConvention.StdCall,
 			 CharSet = CharSet.Auto)]
 		internal extern static uint GetLastError ();
@@ -133,47 +120,47 @@
 		static internal extern int SetMapMode(IntPtr hDC, int fnMapMode);
 		[DllImport(&quot;gdi32.dll&quot;)]
 		static internal extern int GetObjectType(IntPtr handle);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern IntPtr CreateDIBSection(IntPtr hdc, ref BITMAPINFO_FLAT bmi, 
 			int iUsage, ref int ppvBits, IntPtr hSection, int dwOffset);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int GetDIBits(IntPtr hDC, IntPtr hbm, int StartScan, int ScanLines, int lpBits, BITMAPINFOHEADER bmi, int usage);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int GetDIBits(IntPtr hdc, IntPtr hbm, int StartScan, int ScanLines, int lpBits, ref BITMAPINFO_FLAT bmi, int usage);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern IntPtr GetPaletteEntries(IntPtr hpal, int iStartIndex, int nEntries, byte[] lppe);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern IntPtr GetSystemPaletteEntries(IntPtr hdc, int iStartIndex, int nEntries, byte[] lppe);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int SetDCBrushColor(IntPtr hdc,  int crColor);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern IntPtr CreateSolidBrush(int crColor);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int SetBkMode(IntPtr hDC, BackgroundMode mode);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int SetViewportOrgEx(IntPtr hdc,  int x, int y,  int param);
-		[DllImport(&quot;gdi32&quot;)]
-        internal static extern int SetTextColor(IntPtr hDC, int colorRef);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
+		internal static extern int SetTextColor(IntPtr hDC, int colorRef);
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int SetStretchBltMode(IntPtr hDC, StrechModeFlags StrechMode);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int SetPixel(IntPtr hDC, int x, int y, int color);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern IntPtr CreatePen(PenStyle penStyle, int width, int color);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int GetClipRgn(IntPtr hDC, ref IntPtr region);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern IntPtr CreateRectRgn(int nLeftRect,  int TopRect, int nRightRect, int nBottomRect);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int GetRgnBox(IntPtr hRegion, ref RECT rc);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern IntPtr GetStockObject(GSO_ objectType);
-		[DllImport(&quot;gdi32&quot;)]
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int ExtTextOut(IntPtr hdc, int x, int y,
-				ExtTextOutFlags options, ref RECT rc, int str, int strLen, IntPtr distances);
-		[DllImport(&quot;gdi32&quot;)]
+			ExtTextOutFlags options, ref RECT rc, int str, int strLen, IntPtr distances);
+		[DllImport(&quot;gdi32.dll&quot;)]
 		internal static extern int ExtTextOut(IntPtr hdc, int x, int y,
-				ExtTextOutFlags options, ref RECT rc, string str, int strLen, IntPtr distances);
+			ExtTextOutFlags options, ref RECT rc, string str, int strLen, IntPtr distances);
 
 		[DllImport (&quot;gdi32.dll&quot;, 
 			 CallingConvention = CallingConvention.StdCall, 
@@ -185,7 +172,7 @@
 			 CharSet = CharSet.Auto)]
 		internal static extern uint SetBkColor (IntPtr hdc, uint crColor);
 
-		internal static int RGB(Color color)
+		internal static int RGB(Color color) 
 		{
 			return color.R | (color.G &lt;&lt; 8) | (color.B &lt;&lt; 16);
 		}
@@ -195,7 +182,7 @@
 		#region Uxtheme.dll functions
 		[DllImport(&quot;uxtheme.dll&quot;)]
 		static public extern int SetWindowTheme(IntPtr hWnd, StringBuilder AppID, StringBuilder ClassID);
-		static public void DisableWindowsXPTheme(IntPtr hWnd)
+		static public void DisableWindowsXPTheme(IntPtr hWnd) 
 		{
 			// Disable using the Window XP Theme for the Window handle
 			// passed as a parameter
@@ -205,7 +192,7 @@
 		}
 		#endregion
 	
-		#region User32.dll functions
+		#region user32.dll functions
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		static internal extern IntPtr GetDesktopWindow();
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
@@ -222,45 +209,45 @@
 		static internal extern IntPtr SetClipboardData( int Format, IntPtr hData);
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		static internal extern bool GetMenuItemRect(IntPtr hWnd, IntPtr hMenu, int Item, ref RECT rc);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern int SendMessage(IntPtr hWnd, int msg, int wParam, int lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern int SendMessage(IntPtr hWnd, Msg msg, int wParam, int lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, IntPtr lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern void SendMessage(IntPtr hWnd, int msg, int wParam, ref RECT lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern int SendMessage(IntPtr hWnd, int msg, int wParam, ref POINT lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern int SendMessage(IntPtr hWnd, int msg, int wParam, string lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern int SendMessage(IntPtr hWnd, Msg msg, int wParam, string lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern void SendMessage(IntPtr hWnd, ToolBarMessages msg, int wParam, ref TBBUTTON lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern void SendMessage(IntPtr hWnd, ToolBarMessages msg, int wParam, ref TBBUTTONINFO lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern int SendMessage(IntPtr hWnd, RebarMessages msg, int wParam, ref REBARBANDINFO lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern void SendMessage(IntPtr hWnd, TreeViewMessages msg, int wParam, ref TVITEM lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern void SendMessage(IntPtr hWnd, TreeViewMessages msg, int wParam, ref TVINSERTSTRUCT lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern void SendMessage(IntPtr hWnd, TreeViewMessages msg, int wParam, ref TVSORTCB lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern int SendMessage(IntPtr hWnd, TreeViewMessages msg, int wParam, ref TVHITTESTINFO hti);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern void SendMessage(IntPtr hWnd, ListViewMessages msg, int wParam, ref LVITEM lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern void SendMessage(IntPtr hWnd, HeaderControlMessages msg, int wParam, ref HDITEM lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern void SendMessage(IntPtr hWnd, HeaderControlMessages msg, int wParam, ref HD_HITTESTINFO hti);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern int SendMessage(IntPtr hWnd, HeaderControlMessages msg, int wParam, int lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;PostMessageA&quot;)]
 		internal static extern IntPtr PostMessage(IntPtr hWnd, int msg, int wParam, int lParam);
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;PostMessageA&quot;)]
 		internal static extern IntPtr PostMessage(IntPtr hWnd, Msg msg, int wParam, int lParam);
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern IntPtr SetWindowsHookEx(WindowsHookCodes hookid, HookProc pfnhook, IntPtr hinst, int threadid);
@@ -273,83 +260,119 @@
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal extern static IntPtr GetDlgItem(IntPtr hDlg, int nControlID);
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
-        internal extern static int InvalidateRect(IntPtr hWnd,  ref RECT rc, int bErase);
+		internal extern static int InvalidateRect(IntPtr hWnd,  ref RECT rc, int bErase);
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal extern static int InvalidateRect(IntPtr hWnd,  IntPtr rc, int bErase);
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern bool WaitMessage();
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;PeekMessageA&quot;)]
 		internal static extern bool PeekMessage(ref MESSAGE msg, int hWnd, int wFilterMin, int wFilterMax, PeekMessageFlags flags);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;GetMessageA&quot;)]
 		internal static extern bool GetMessage(ref MESSAGE msg, int hWnd, int wFilterMin, int wFilterMax);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern bool TranslateMessage(ref MESSAGE msg);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;DispatchMessageA&quot;)]
 		internal static extern bool DispatchMessage(ref MESSAGE msg);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;LoadCursorA&quot;)]
 		internal static extern IntPtr LoadCursor(IntPtr hInstance, CursorType cursor);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern IntPtr SetCursor(IntPtr hCursor);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern IntPtr BeginPaint(IntPtr hWnd, ref PAINTSTRUCT ps);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern bool EndPaint(IntPtr hWnd, ref PAINTSTRUCT ps);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, ref POINT pptDst, ref SIZE psize, 
 			IntPtr hdcSrc, ref POINT pprSrc, Int32 crKey, ref BLENDFUNCTION pblend, UpdateLayeredWindowFlags dwFlags);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern bool ClientToScreen(IntPtr hWnd, ref POINT pt);
+		
+		internal static bool ClientToScreen(IntPtr hWnd, ref RECT rect) {
+			POINT pt1 = new POINT();
+			pt1.x = rect.left;
+			pt1.y = rect.top;
+			POINT pt2 = new POINT();
+			pt2.x = rect.right;
+			pt2.y = rect.bottom;
+			bool result = Win32.ClientToScreen(hWnd, ref pt1);
+			result &amp;= Win32.ClientToScreen(hWnd, ref pt2);
+			rect.left = pt1.x;
+			rect.top = pt1.y;
+			rect.right = pt2.x;
+			rect.bottom = pt2.y;
+			return result;
+		}
+
+
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		internal static extern bool ScreenToClient(IntPtr hWnd, ref POINT pt);
+
+		internal static bool ScreenToClient(IntPtr hWnd, ref RECT rect) {
+			POINT pt1 = new POINT();
+			pt1.x = rect.left;
+			pt1.y = rect.top;
+			POINT pt2 = new POINT();
+			pt2.x = rect.right;
+			pt2.y = rect.bottom;
+			bool result = Win32.ScreenToClient(hWnd, ref pt1);
+			result &amp;= Win32.ScreenToClient(hWnd, ref pt2);
+			rect.left = pt1.x;
+			rect.top = pt1.y;
+			rect.right = pt2.x;
+			rect.bottom = pt2.y;
+			return result;
+		}
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern bool TrackMouseEvent(ref TRACKMOUSEEVENT tme);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern bool SetWindowRgn(IntPtr hWnd, IntPtr hRgn, bool redraw);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern short GetKeyState(int virtKey);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern bool MoveWindow(IntPtr hWnd, int x, int y, int width, int height, bool repaint);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern int GetClassName(IntPtr hWnd,  StringBuilder ClassName, int nMaxCount);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;SetWindowLongA&quot;)]
 		internal static extern int SetWindowLong(IntPtr hWnd, GetWindowLongFlag flag, int dwNewLong);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;SetWindowLongA&quot;)]
 		internal static extern IntPtr SetWindowLong(IntPtr hWnd, GetWindowLongFlag flag, WinProc winProc);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;SetWindowLongA&quot;)]
 		internal static extern IntPtr SetWindowLong(IntPtr hWnd, GetWindowLongFlag flag, WndProc winProc);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern IntPtr GetDCEx(IntPtr hWnd, IntPtr hRegion, int flags);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern IntPtr GetWindowDC(IntPtr hWnd);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern int FillRect(IntPtr hDC, ref RECT rect, IntPtr hBrush);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SetWindowTextA&quot;)]
 		internal static extern int SetWindowText(IntPtr hWnd, string text);
 
-		[DllImport(&quot;User32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;GetWindowTextA&quot;)]
 		internal static extern int GetWindowText(IntPtr hWnd, StringBuilder text, int maxCount);
 
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Ansi,EntryPoint=&quot;SendMessageA&quot;)]
 		static internal extern int SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);
 
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)] 
@@ -395,25 +418,25 @@
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		static internal extern int GetScrollBarInfo(IntPtr hWnd, SystemObject id, ref SCROLLBARINFO sbi);
 
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;GetWindowLongA&quot;)]
 		static internal extern IntPtr GetWindowLong(IntPtr hWnd, GetWindowLongFlag flag);
 
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		static internal extern int SetProp(IntPtr hWnd, IntPtr atom, IntPtr hData);
 
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;CallWindowProcA&quot;)]
 		static internal extern int CallWindowProc(IntPtr hOldProc, IntPtr hWnd, int message, int wParam, int lParam);
 
 		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
 		static internal extern int EndMenu();
 
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
-        static internal extern int DefWindowProc(IntPtr hWnd, int message, int wParam, int lParam);
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;DefWindowProcA&quot;)]
+		static internal extern int DefWindowProc(IntPtr hWnd, int message, int wParam, int lParam);
 
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
-        static internal extern IntPtr LoadCursor(IntPtr hInstance, LC_ standardCursor);
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto,EntryPoint=&quot;LoadCursorA&quot;)]
+		static internal extern IntPtr LoadCursor(IntPtr hInstance, LC_ standardCursor);
 
-		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;user32.dll&quot;, CharSet=CharSet.Auto, EntryPoint=&quot;RegisterWindowMessageA&quot;)]
 		static internal extern int RegisterWindowMessage( string message_name);
 
 		[DllImport (&quot;user32.dll&quot;, CallingConvention = CallingConvention.StdCall, 
@@ -455,27 +478,27 @@
 
 		#region Shell32.dll functions
 
-		[DllImport(&quot;Shell32.dll&quot;, CharSet=CharSet.Auto)]
-		internal static extern IntPtr SHGetFileInfo(string drivePath, int fileAttributes, 
+		[DllImport(&quot;shell32.dll&quot;, CharSet=CharSet.Auto)]
+		internal static extern IntPtr SHGetFileInfo(string drivePath, int fileAttributes,
 			out SHFILEINFO fileInfo, int countBytesFileInfo, ShellFileInfoFlags flags);
 
-		[DllImport(&quot;Shell32.dll&quot;, CharSet=CharSet.Auto)]
-		internal static extern IntPtr SHGetFileInfo(IntPtr idl, int fileAttributes, 
+		[DllImport(&quot;shell32.dll&quot;, CharSet=CharSet.Auto)]
+		internal static extern IntPtr SHGetFileInfo(IntPtr idl, int fileAttributes,
 			out SHFILEINFO fileInfo, int countBytesFileInfo, ShellFileInfoFlags flags);
 
-		[DllImport(&quot;Shell32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;shell32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern int SHGetSpecialFolderLocation(IntPtr hwndOwner, ShellSpecialFolder folder, out IntPtr idl);
 
-		[DllImport(&quot;Shell32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;shell32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern int SHGetMalloc(out IMalloc alloc);
 
-		[DllImport(&quot;Shell32.dll&quot;, CharSet=CharSet.Auto)]
+		[DllImport(&quot;shell32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern int SHGetDesktopFolder(out IShellFolder folder);
-		
-		[DllImport(&quot;Shell32.dll&quot;, CharSet=CharSet.Auto)]
+
+		[DllImport(&quot;shell32.dll&quot;, CharSet=CharSet.Auto)]
 		internal static extern int SHGetPathFromIDList(IntPtr idl, StringBuilder path);
 
-		internal static void SHFreeMalloc(IntPtr handle)
+		internal static void SHFreeMalloc(IntPtr handle) 
 		{
 			IMalloc alloc = null;
 			try 
@@ -487,14 +510,14 @@
 				IUnknown iUnknown = (IUnknown)alloc;
 				iUnknown.Release();
 			}
-			catch (Exception e)
+			catch (Exception e) 
 			{
 				// In case the Garbage collector is trying to free
 				// this memory from its own thread
 				Debug.WriteLine(e.Message);
 			}
 		}
-		
+
 		#endregion
 
 		#region Common Controls functions
@@ -552,11 +575,11 @@
 
 		[DllImport(&quot;comctl32.dll&quot;)]
 		internal static extern int ImageList_SetDragCursorImage(IntPtr himlDrag, int iDrag, int dxHotspot, int dyHotspot);
-								
+
 		internal static int ImageList_DrawEx(IntPtr hImageList, int imageIndex, IntPtr hDCDest, int x, int y, int dx, int dy,   
-			ImageListDrawColor backColor, ImageListDrawColor foreColor, ImageListDrawFlags flags)
+			ImageListDrawColor backColor, ImageListDrawColor foreColor, ImageListDrawFlags flags) 
 		{
-            uint bColor = (uint)ImageListDrawColors.CLR_NONE;
+			uint bColor = (uint)ImageListDrawColors.CLR_NONE;
 			if ( backColor == ImageListDrawColor.Default )
 				bColor =  (uint)ImageListDrawColors.CLR_DEFAULT;
 
@@ -569,7 +592,7 @@
 		}
 
 		
-		static internal bool IsCommonCtrl6()
+		static internal bool IsCommonCtrl6() 
 		{
 			DLLVERSIONINFO dllVersion = new DLLVERSIONINFO();
 			// We are assummng here that anything greater or equal than 6
@@ -582,67 +605,67 @@
 		#endregion
 
 		#region Win32 Macro-Like helpers
-		internal static int X_LPARAM(int lParam)
+		internal static int X_LPARAM(int lParam) 
 		{
 			return (lParam &amp; 0xffff);
 		}
 	 
-		internal static int Y_LPARAM(int lParam)
+		internal static int Y_LPARAM(int lParam) 
 		{
 			return (lParam &gt;&gt; 16);
 		}
 
-		internal static Point GetPointFromLPARAM(int lParam)
+		internal static Point GetPointFromLPARAM(int lParam) 
 		{
 			return new Point(X_LPARAM(lParam), Y_LPARAM(lParam));
 		}
 
-		internal static int LOW_ORDER(int param)
+		internal static int LOW_ORDER(int param) 
 		{
 			return (param &amp; 0xffff);
 		}
 
-		internal static int HIGH_ORDER(int param)
+		internal static int HIGH_ORDER(int param) 
 		{
 			return (param &gt;&gt; 16);
 		}
 
-		internal static int INDEXTOOVERLAYMASK(int index)
+		internal static int INDEXTOOVERLAYMASK(int index) 
 		{
 			return (int)((uint)index &lt;&lt; 8); 
 		}
 
-		internal static int OVERLAYMASKTOINDEX(int index)
+		internal static int OVERLAYMASKTOINDEX(int index) 
 		{
-			return (int)((uint)index &gt;&gt; 8); 
+			return (int)((uint)index &gt;&gt; 8);
 		}
 
-		internal static int INDEXTOSTATEIMAGEMASK(int i)
+		internal static int INDEXTOSTATEIMAGEMASK(int i) 
 		{
 			return (int)((uint)i &lt;&lt; 12);
 		}
 
-		internal static int STATEIMAGEMASKTOINDEX(int i)
+		internal static int STATEIMAGEMASKTOINDEX(int i) 
 		{
-			 return (int)((uint)i &gt;&gt; 12);
+			return (int)((uint)i &gt;&gt; 12);
 		}
 
-		internal static short HRESULT_CODE(int hr)
+		internal static short HRESULT_CODE(int hr) 
 		{
-             return (short)(hr &amp; 0xFFFF);
+			return (short)(hr &amp; 0xFFFF);
 		}
 
-		internal static bool SUCCEEDED(int status)
+		internal static bool SUCCEEDED(int status) 
 		{
 			return (status &gt;= 0);
 		}
 
-		internal static bool FAILED(int status)
+		internal static bool FAILED(int status) 
 		{
 			return (status &lt; 0);
 		}
 
-		internal static int  MAKEINTRESOURCE(int res)
+		internal static int  MAKEINTRESOURCE(int res) 
 		{
 			return 0x0000FFFF &amp; res;
 		}
@@ -661,7 +684,7 @@
 		//correct?
 		[DllImport (&quot;user32.dll&quot;, 
 			 CallingConvention = CallingConvention.StdCall,
-			 CharSet = CharSet.Auto)]
+			 CharSet = CharSet.Auto,EntryPoint=&quot;SendMessageA&quot;)]
 		internal static extern uint SendMessage(
 			IntPtr hWnd, uint Msg,
 			IntPtr wParam, IntPtr lParam);
@@ -722,7 +745,7 @@
 			 CallingConvention.StdCall, CharSet = CharSet.Auto)]
 		internal static extern int  TranslateMessage (ref MSG msg);
 
-		[DllImport (&quot;user32.dll&quot;, CallingConvention = 
+		[DllImport (&quot;user32.dll&quot;, CallingConvention =
 			 CallingConvention.StdCall, CharSet = CharSet.Auto)]
 		internal static extern int DispatchMessageA (ref MSG msg);
 
@@ -756,7 +779,7 @@
 
 		[DllImport (&quot;user32.dll&quot;, 
 			 CallingConvention = CallingConvention.StdCall, 
-			 CharSet = CharSet.Auto)]
+			 CharSet = CharSet.Ansi)]
 		internal static extern int MessageBoxA (
 			IntPtr hWnd, string pText, string pCaption, uint uType);
 
@@ -772,7 +795,7 @@
 		internal static extern IntPtr GetParent (IntPtr hWnd);
 
 		[DllImport (&quot;user32.dll&quot;, 
-			 CallingConvention = CallingConvention.StdCall, 
+			 CallingConvention = CallingConvention.StdCall,
 			 CharSet = CharSet.Auto)]
 		internal static extern bool SetWindowTextA (
 			IntPtr hWnd, string lpString);
@@ -812,7 +835,7 @@
 			 CharSet = CharSet.Auto)]
 		internal static extern bool IsMenu (IntPtr hWnd);
 
-		
+
 		[DllImport (&quot;user32.dll&quot;, 
 			 CallingConvention = CallingConvention.StdCall, 
 			 CharSet = CharSet.Auto)]


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="012331.html">[Mono-list] XML Read() statement
</A></li>
	<LI> Next message: <A HREF="012328.html">[Mono-list] Patch to Sys.Win.Forms/Sys.Drawing 2/2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12327">[ date ]</a>
              <a href="thread.html#12327">[ thread ]</a>
              <a href="subject.html#12327">[ subject ]</a>
              <a href="author.html#12327">[ author ]</a>
         </LI>
       </UL>
</body></html>
