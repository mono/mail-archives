<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] A documentation coverage tool
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:peter%40newton.cx">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="011705.html">
   <LINK REL="Next"  HREF="011706.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] A documentation coverage tool
   </H1>
    <B>Peter Williams
    </B> 
    <A HREF="mailto:peter%40newton.cx"
       TITLE="[Mono-list] A documentation coverage tool">peter@newton.cx
       </A><BR>
    <I>30 Jan 2003 00:38:27 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="011705.html">[Mono-list] A documentation coverage tool
</A></li>
        <LI> Next message: <A HREF="011706.html">[Mono-list] RE: [Mono-winforms-list] Changes to monostub
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11708">[ date ]</a>
              <a href="thread.html#11708">[ thread ]</a>
              <a href="subject.html#11708">[ subject ]</a>
              <a href="author.html#11708">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--=-iFvuyoeqqm8g3xeNaXIp
Content-Type: text/plain
Content-Transfer-Encoding: 7bit

On Wed, 2003-01-29 at 20:29, Peter Williams wrote:
&gt;<i> Hi Duncan et al,
</I>
Ok, I sort of ran with this and wrote a tool to compare the ECMA
documentation file for a class and compare it against the master.xml
file. Again, it almost surely has some issues, but I thought it was
really nifty.

	Peter

-- 
Peter Williams     <A HREF="mailto:peter@newton.cx">peter@newton.cx</A> / <A HREF="mailto:peterw@ximian.com">peterw@ximian.com</A>

&quot;[Ninjas] are cool; and by cool, I mean totally sweet.&quot;
                              -- REAL Ultimate Power

--=-iFvuyoeqqm8g3xeNaXIp
Content-Disposition: attachment; filename=ClassChecker.cs
Content-Type: text/plain; name=ClassChecker.cs; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

// Author: Peter Williams &lt;<A HREF="mailto:peterw@ximian.com">peterw@ximian.com</A>&gt;

using System;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.IO;
using System.Xml;

//
// Known bugs:
//
// * Implementations of interface functions might
//   be handled wrong. The doc file records
//   the name as something like 
//
//   &lt;Member MemberName=&quot;System.Collections.IEnumerable.GetEnumerator&quot;&gt;
//
//   but the master XML file only has 
//
//   &lt;method name=&quot;GetEnumerator()&quot; argnames=&quot;&quot; returntype=&quot;System.CharEnumerator&quot; /&gt;
//
//   So there isn't enough info to tie the two together. Well, maybe we could chop
//   off everything before the last period? Seems risky.
//
// * Probably there are more bugs when the XML isn't in the expected format.
//   I must admit that XmlTextReader is not winning my heart.
//

namespace MonoDoc {

public enum MemberType {
	Class,
	Interface,
	Struct,
	Delegate,
	Enum,
	Constructor,
	Field,
	Prop,
	Method,
	Operator,
	Event
};

public enum DocType {
	Unknown,
	Docs,
	NoDocs
};
	
public class Member {
	public MemberType type;
	public DocType    docs;
	public string     name;
	public string     return_type; // or type of self if property
	public string[]   param_names;
	public string[]   param_types;

	private int param_size;

	private void AddParam (string name, string type)
	{
		if (param_size == 0) {
			param_names = new string[2];
			param_types = new string[2];
		} else if (param_size == param_names.Length) {
			string[] new_names = new string [param_size * 2];
			string[] new_types = new string [param_size * 2];

			param_names.CopyTo (new_names, 0);
			param_types.CopyTo (new_types, 0);

			param_names = new_names;
			param_types = new_types;
		}

		param_names[param_size] = name;
		param_types[param_size] = type;
		param_size++;
	}

	private void EnumFromMaster (XmlTextReader r)
	{
		int depth = r.Depth;

		while (r.Read () &amp;&amp; r.Depth &gt; depth) {
			if (r.Name == &quot;field&quot; &amp;&amp; r[&quot;name&quot;] != &quot;&quot;)
				AddParam (r[&quot;name&quot;], null);
		}
	}

	private void ParamsFromMaster (XmlTextReader r)
	{
		string name = r[&quot;name&quot;];
		string args = r[&quot;argnames&quot;];

		if (args == &quot;&quot;)
			return;

		string[] namelist = Regex.Split (args, &quot;, &quot;);
		string types = Regex.Match (name, &quot;[^(]*\\(([^)]*)\\)&quot;).Groups[1].Value;
		string[] typelist = Regex.Split (types, &quot;, &quot;);

		for (int i = 0; i &lt; namelist.Length; i++)
			AddParam (namelist[i], typelist[i]);
	}

	private void TypeFromDoc (XmlTextReader r)
	{
		// this probably needs robustification

		r.Read();
		string t = r.Value;

		switch (t) {
		case &quot;Class&quot;:
		case &quot;Interface&quot;:
		case &quot;Structure&quot;:
			throw new Exception (String.Format (&quot;Can't handle a nested {0} yet&quot;, t));
		case &quot;Delegate&quot;:
			type = MemberType.Delegate;
			break;
		case &quot;Enumeration&quot;:
			type = MemberType.Enum;
			break;
		case &quot;Constructor&quot;:
			type = MemberType.Constructor;
			break;
		case &quot;Field&quot;:
			type = MemberType.Field;
			break;
		case &quot;Property&quot;:
			type = MemberType.Prop;
			break;
		case &quot;Method&quot;:
			type = MemberType.Method;
			break;
		// This doesn't happen
		// case &quot;Operator&quot;:
		//	type = MemberType.Operator;
		// 	break;
		case &quot;Event&quot;:
			type = MemberType.Event;
			break;
		default:
			throw new Exception (String.Format (
				&quot;Unknown member type {0} in doc xml file&quot;, t));
		}
	}

	private void RVFromDoc (XmlTextReader r)
	{
		int depth = r.Depth;

		while (r.Read() &amp;&amp; r.Depth &gt; depth) {
			if (r.Name == &quot;ReturnType&quot;) {
				r.Read();
				return_type = r.Value;

				// bail out before the close tag screws us up.
				return;
			}
		}

		// We can have this element be empty,
		// if it's an event or something, so
		// don't complain about that.
	}

	private void ParamsFromDoc (XmlTextReader r)
	{
		int depth = r.Depth;

		while (r.Read() &amp; r.Depth &gt; depth) {
			if (r.Name != &quot;Parameter&quot; || r[&quot;Name&quot;] == &quot;&quot;)
				continue;

			AddParam (r[&quot;Name&quot;], r[&quot;Type&quot;]);
		}
	}

	// Public

	public Member ()
	{
		docs = DocType.Unknown;
		param_size = 0;
	}

	public static string MemberTypeName (MemberType type)
	{
		string t = &quot;[unknown type]&quot;;

		switch (type) {
		case MemberType.Class:
			t = &quot;class&quot;;
			break;
		case MemberType.Interface:
			t = &quot;interface&quot;;
			break;
		case MemberType.Struct:
			t = &quot;structure&quot;;
			break;
		case MemberType.Delegate:
			t = &quot;delegate&quot;;
			break;
		case MemberType.Enum:
			t = &quot;enumeration&quot;;
			break;
		case MemberType.Constructor:
			t = &quot;constructor&quot;;
			break;
		case MemberType.Field:
			t = &quot;field&quot;;
			break;
		case MemberType.Prop:
			t = &quot;property&quot;;
			break;
		case MemberType.Method:
			t = &quot;method&quot;;
			break;
		case MemberType.Operator:
			t = &quot;operator&quot;;
			break;
		case MemberType.Event:
			t = &quot;event&quot;;
			break;
		}

		return t;
	}

	public string ParamsList (bool with_names)
	{
		StringBuilder sb = new StringBuilder();

		if (with_names) {
			for (int i = 0; i &lt; param_size; i++) {
				if (i != 0)
					sb.Append (&quot;, &quot;);
				sb.Append (String.Format (&quot;{0} {1}&quot;, param_types[i], param_names[i]));
			}
		} else {
			for (int i = 0; i &lt; param_size; i++) {
				if (i != 0)
					sb.Append (&quot;, &quot;);
				sb.Append (param_types[i]);
			}
		}

		return sb.ToString ();
	}

	public void Print()
	{
		Console.WriteLine (&quot;{0} {1}:&quot;, MemberTypeName (type), name);

		if (return_type != null)
			Console.WriteLine (&quot;   return or self type: {0}&quot;, return_type);
		if (param_names != null)
			Console.WriteLine (&quot;   params: {0}&quot;, ParamsList (true));
	}

	// Read in a member from a master.xml-style file

	public static Member FromMasterFile (XmlTextReader r)
	{
		Member m = new Member ();

		m.name = r[&quot;name&quot;];

		switch (r.Name) {
		case &quot;class&quot;:
		case &quot;interface&quot;:
		case &quot;structure&quot;:
		case &quot;delegate&quot;:
			throw new Exception (String.Format (
				&quot;Can't handle a nested {0} yet.&quot;, r.Name));
		case &quot;enum&quot;:
			m.type = MemberType.Enum;
			m.EnumFromMaster (r);
			break;
		case &quot;constructor&quot;:
			m.type = MemberType.Constructor;
			m.ParamsFromMaster (r);
			break;
		case &quot;method&quot;:
			m.type = MemberType.Method;
			m.ParamsFromMaster (r);
			break;
		case &quot;operator&quot;:
			// The ECMA doc files list these as methods,
			// and I'd rather lose this info and use the
			// names, which agree, than include a table of
			// all special method names and change matching
			// methods to operators.

			//m.type = MemberType.Operator;
			m.type = MemberType.Method;
			m.ParamsFromMaster (r);
			break;
		case &quot;property&quot;:
			m.type = MemberType.Prop;
			m.return_type = r[&quot;propertytype&quot;];
			break;
		case &quot;event&quot;:
			m.type = MemberType.Event;
			break;
		case &quot;field&quot;:
			m.type = MemberType.Field;
			break;
		}

		// Let's canonicalize for fun and profit
		if ((m.type == MemberType.Constructor || m.type == MemberType.Method)
		    &amp;&amp; m.param_size == 0) {
			if (Regex.Match (m.name, &quot;\\(\\)$&quot;) == null)
				m.name = m.name + &quot;()&quot;;
		}

		return m;
	}

	// read in a member from a doc file

	public static Member FromDocFile (XmlTextReader r, string class_name)
	{
		Member m = new Member ();
		int depth;

		if (r.Name != &quot;Member&quot;)
			throw new Exception (&quot;Not on &lt;Member&gt; when reading doc xml file&quot;);

		m.name = r[&quot;MemberName&quot;];
		depth = r.Depth;

		// I can't figure out a way to tell start tags
		// from end tags. This is ridiculous.

		bool got_m_type = false;
		bool got_rv = false;
		bool got_params = false;

		while (r.Read() &amp;&amp; r.Depth &gt; depth) {
			switch (r.Name) {
			case &quot;MemberType&quot;:
				if (!got_m_type) {
					m.TypeFromDoc (r);
					got_m_type = true;
				}
				break;
			case &quot;ReturnValue&quot;:
				if (!got_rv) {
					m.RVFromDoc (r);
					got_rv = true;
				}
				break;
			case &quot;Parameters&quot;:
				if (!got_params) {
					m.ParamsFromDoc (r);
					got_params = true;
				}
				break;
			case &quot;Docs&quot;:
				m.docs = DocType.Docs;
				break;
			}
		}

		if (m.docs == DocType.Unknown)
			m.docs = DocType.NoDocs;

		if (m.type == MemberType.Method) {
			// munge the name so that we can check
			// overloadings

			StringBuilder sb = new StringBuilder (m.name);

			sb.Append ('(');
			sb.Append (m.ParamsList (false));
			sb.Append (')');
			m.name = sb.ToString();
		}

		if (m.type == MemberType.Constructor) {
			// whee, a different kind of munging

			StringBuilder sb = new StringBuilder (class_name);
			sb.Append ('(');
			sb.Append (m.ParamsList (false));
			sb.Append (')');
			m.name = sb.ToString();
		}

		return m;
	}

	public bool CheckAgainst (Member canon)
	{
		bool ok = true;

		if (canon == null) {
			Console.WriteLine (&quot;{0}: This member is documented but doesn't exist&quot;, name);
			return false;
		}

		if (name != canon.name)
			throw new Exception (String.Format (
				&quot;Checking member {0} against {1}&quot;, name, canon.name));

		if (docs != DocType.Docs) {
			Console.WriteLine (&quot;{0}: No &lt;Docs&gt; tag.&quot;, name);
			ok = false;
		}

		if (type != canon.type) {
			Console.WriteLine (&quot;{0}: Type is {2} but is documented as {1}.&quot;,
				name, MemberTypeName (type), MemberTypeName (canon.type));
			ok = false;
		}

		if (canon.return_type != null &amp;&amp; return_type != canon.return_type) {
			if (canon.type == MemberType.Prop)
				Console.WriteLine (&quot;{0}: Property type should be {1} but is documented as {2}.&quot;,
					name, canon.return_type, return_type);
			else
				Console.WriteLine (&quot;{0}: Return type should be {1} but is documented as {2}.&quot;,
					name, canon.return_type, return_type);
			ok = false;
		}

		if (canon.param_size &gt; 0) {
			if (param_size != canon.param_size) {
				Console.WriteLine (&quot;{0}: Method has {1} parameters but {2} are documented.&quot;,
					name, canon.param_size, param_size);

				Console.WriteLine (&quot;   {0}&quot;, ParamsList (true));
				ok = false;
			} else {
				for (int i = 0; i &lt; canon.param_size; i++) {
					if (param_names[i] != canon.param_names[i]) {
						Console.WriteLine (&quot;{0}: parameter {1} is named {2} but is documented as {3}&quot;,
							name, i, canon.param_names[i], param_names[i]);
						ok = false;
					}

					if (param_types[i] != canon.param_types[i]) {
						Console.WriteLine (&quot;{0}: parameter {1} is of type {2} but is documented as {3}&quot;,
							name, i, canon.param_types[i], param_types[i]);
						ok = false;
					}
				}
			}
		}

		return ok;
	}
}

class ClassChecker {

	string[] args;
	Hashtable cov;

	FileStream doc_stream;
	XmlTextReader dr;

	string class_name;
	string full_name;

	void Go ()
	{
		if (args.Length != 2) {
			Usage ();
			Environment.Exit (1);
		}

		string master_file = args[0];
		string doc_file = args[1];

		try {
			// Open up the doc and see what we're dealing with
			InitDoc (doc_file);

			// Parse the master xml file; see what we should document.
			ReadMaster (master_file);

			// See what' actually documented
			CompareDocs ();
		} catch (Exception e) {
			Console.WriteLine (&quot;Error checking doc file {0}: {1}&quot;,
				doc_file, e.Message);
		}

		// Cleanup
		DoneDoc ();
	}

	void InitDoc (string doc_file)
	{
		doc_stream = File.OpenRead (doc_file);
		dr = new XmlTextReader (doc_stream);

		while (dr.Read()) {
			if (dr.Name == &quot;Type&quot;) {
				class_name = dr[&quot;Name&quot;];
				full_name = dr[&quot;FullName&quot;];

				Console.WriteLine (&quot;Checking documentation of {0}:&quot;, full_name);
				Console.WriteLine ();
				return;
			}
		}

		throw new Exception (String.Format (&quot;Didn't find &lt;Type&gt; node in {0}&quot;, doc_file));
	}

	void DoneDoc ()
	{
		dr.Close ();
		doc_stream.Close ();
	}

	void ReadMaster (string master_file)
	{
		FileStream master_stream = File.OpenRead (master_file);
		XmlTextReader mr = new XmlTextReader (master_stream);

		bool yay = false;

		while (mr.Read()) {
			if ((mr.Name != &quot;class&quot; &amp;&amp; mr.Name != &quot;interface&quot;) || 
			    mr[&quot;name&quot;] != class_name || 
			    mr[&quot;namespace&quot;] + &quot;.&quot; + class_name != full_name) 
				continue;

			yay = true;

			int depth = mr.Depth;
			while (mr.Read() &amp;&amp; mr.Depth &gt; depth) {
				// we get closing tags too or something
				if (mr[&quot;name&quot;] != &quot;&quot;) {
					Member m = Member.FromMasterFile (mr);
					//m.Print();
					cov[m.name] = m;
				}
			}

			break;
		}

		mr.Close ();
		master_stream.Close ();

		if (yay == false)
			throw new Exception (String.Format (&quot;Didn't find &lt;class&gt; node for {0} in {1}&quot;,
				full_name, master_file));
	}

	void CompareDocs ()
	{
		int ok = 0;
		int total = 0;

		while (dr.Read ()) {
			if (dr.Name == &quot;Members&quot;) {
				int depth = dr.Depth;

				while (dr.Read() &amp;&amp; dr.Depth &gt; depth) {
					if (dr.Name == &quot;Member&quot;) {
						Member m = Member.FromDocFile (dr, class_name);
						Member canon = (Member) cov[m.name];
	
						total++;
						if (m.CheckAgainst (canon))
							ok++;

						if (canon != null)
							cov[m.name] = null;
					}
				}
			}
		}

		foreach (string s in cov.Keys) {
			Member canon = cov[s] as Member;

			if (canon != null) {
				Console.WriteLine (&quot;{0}: not documented&quot;, canon.name);
				total++;
			}
		}

		if (total == 0)
			throw new Exception (&quot;No &lt;Members&gt; tag in documentation file&quot;);

		Console.WriteLine ();
		Console.WriteLine (&quot;Summary: {0} / {1} members properly documented ({2:F2}%)&quot;,
			ok, total, (float) 100.0 * ok / total);
	}

	///////////////////////////////////////////
	// Housekeeping

	void Usage ()
	{
		Console.WriteLine (&quot;ClassChecker.exe [path to master xml file] [path to class documentation xml file&quot;);
	}

	ClassChecker (string[] args)
	{
		this.args = new string[args.Length];
		args.CopyTo (this.args, 0);

		cov = new Hashtable ();
	}

	static void Main (string[] args)
	{
		ClassChecker cc = new ClassChecker (args);
		cc.Go();
	}
}

}

--=-iFvuyoeqqm8g3xeNaXIp--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="011705.html">[Mono-list] A documentation coverage tool
</A></li>
	<LI> Next message: <A HREF="011706.html">[Mono-list] RE: [Mono-winforms-list] Changes to monostub
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11708">[ date ]</a>
              <a href="thread.html#11708">[ thread ]</a>
              <a href="subject.html#11708">[ subject ]</a>
              <a href="author.html#11708">[ author ]</a>
         </LI>
       </UL>
</body></html>
