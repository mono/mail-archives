<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Array.CopyTo - Mono (Ubuntu) vs .Net (Windows)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-list%5D%20Array.CopyTo%20-%20Mono%20%28Ubuntu%29%20vs%20.Net%20%28Windows%29&In-Reply-To=%3C9DBEE472-5F6B-4270-8C8F-D3B58DB8CADE%40spicypixel.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="050115.html">
   <LINK REL="Next"  HREF="050110.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Array.CopyTo - Mono (Ubuntu) vs .Net (Windows)</H1>
    <B>Aaron Oneal</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=Re%3A%20%5BMono-list%5D%20Array.CopyTo%20-%20Mono%20%28Ubuntu%29%20vs%20.Net%20%28Windows%29&In-Reply-To=%3C9DBEE472-5F6B-4270-8C8F-D3B58DB8CADE%40spicypixel.com%3E"
       TITLE="[Mono-list] Array.CopyTo - Mono (Ubuntu) vs .Net (Windows)">aaron.oneal at spicypixel.com
       </A><BR>
    <I>Tue Jul 30 16:53:41 UTC 2013</I>
    <P><UL>
        <LI>Previous message: <A HREF="050115.html">[Mono-list] Array.CopyTo - Mono (Ubuntu) vs .Net (Windows)
</A></li>
        <LI>Next message: <A HREF="050110.html">[Mono-list] Building mono 3.0 from source
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50116">[ date ]</a>
              <a href="thread.html#50116">[ thread ]</a>
              <a href="subject.html#50116">[ subject ]</a>
              <a href="author.html#50116">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Is there a reason your video source requires this technique to buffer? This code is inefficient because:

1. It allocates a new buffer every time it reads from the source buffer.
2. It removes data from the source buffer by doing 2 more heap and block copies.

I'm pretty sure overlapping regions are supported in a way that you can avoid one copy by doing an in-place BlockCopy for #2 instead of a second allocation.

But, the main issue is, why must you dynamically allocate new buffers and &quot;remove&quot; data from the source buffer in the first place? In the buffering scenarios I'm familiar with, you would normally allocate a fixed-size buffer which you would pass down to the underlying data provider along with the start index and length to fill. Once your buffer is full, you stop reading from the source until you drain your buffer. Your buffer is emptied not by copying data and re-allocating a buffer, but by simply moving the index for the start of your buffered data. Specifically, you might want to check out this article on circular buffers.

<A HREF="http://en.wikipedia.org/wiki/Circular_buffer">http://en.wikipedia.org/wiki/Circular_buffer</A>

You really don't want to be performing heap allocations every read.


On Jul 27, 2013, at 10:56 AM, const86 &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">powerdeth at narod.ru</A>&gt; wrote:

&gt;<i> Write module buffering online video stream for the player. I write it as
</I>&gt;<i> follows:
</I>&gt;<i> Buffer.BlockCopy (buf, 0, _buffer, _length, length);
</I>&gt;<i> where:
</I>&gt;<i> buf-what record
</I>&gt;<i> _buffer - where to write
</I>&gt;<i> _length - buffer size
</I>&gt;<i> length - the length of bytes to write
</I>&gt;<i> 
</I>&gt;<i> Reads the bytes from buffer:
</I>&gt;<i>   byte [] outbs = new byte [_buffer.Length];
</I>&gt;<i> Buffer.BlockCopy (_buffer, 0, outbs, 0, length); / / copy the block of a
</I>&gt;<i> certain size
</I>&gt;<i> / / Delete the data read from the buffer
</I>&gt;<i> var buf = new byte [_buffer.Length];
</I>&gt;<i> Buffer.BlockCopy (_buffer, length, buf, 0, _buffer.Length - length);
</I>&gt;<i> _buffer = new byte [_buffer.Length];
</I>&gt;<i> Buffer.BlockCopy (buf, 0, _buffer, 0, buf.Length);
</I>&gt;<i> _length - = length;
</I>&gt;<i> 
</I>&gt;<i> / / Return the read data
</I>&gt;<i> 
</I>&gt;<i> return outbs;
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> .Net (Windovs) this algorithm is very fast. So the difference that no buffer
</I>&gt;<i> that is almost negligible.
</I>&gt;<i> In a mono (Ubuntu), this algorithm operates so slowly that for every 2
</I>&gt;<i> seconds viewing awaits player 5.
</I>&gt;<i> 
</I>&gt;<i> Question. How to improve the algorithm in mono, that he was able to cope
</I>&gt;<i> with the flow in rialtaym.
</I>&gt;<i> 
</I>&gt;<i> P.S. Sorry for the bad English. This is the Google Translate. I do not know
</I>&gt;<i> English so much on what to ask such questions :).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> --
</I>&gt;<i> View this message in context: <A HREF="http://mono.1490590.n4.nabble.com/Array-CopyTo-Mono-Ubuntu-vs-Net-Windows-tp4660316.html">http://mono.1490590.n4.nabble.com/Array-CopyTo-Mono-Ubuntu-vs-Net-Windows-tp4660316.html</A>
</I>&gt;<i> Sent from the Mono - General mailing list archive at Nabble.com.
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">Mono-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="050115.html">[Mono-list] Array.CopyTo - Mono (Ubuntu) vs .Net (Windows)
</A></li>
	<LI>Next message: <A HREF="050110.html">[Mono-list] Building mono 3.0 from source
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50116">[ date ]</a>
              <a href="thread.html#50116">[ thread ]</a>
              <a href="subject.html#50116">[ subject ]</a>
              <a href="author.html#50116">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
