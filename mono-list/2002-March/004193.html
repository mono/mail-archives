<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] delegates and AsyncCallback
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jasonw%40develop.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="004188.html">
   <LINK REL="Next"  HREF="004189.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] delegates and AsyncCallback
   </H1>
    <B>Jason Whittington
    </B> 
    <A HREF="mailto:jasonw%40develop.com"
       TITLE="[Mono-list] delegates and AsyncCallback">jasonw@develop.com
       </A><BR>
    <I>Mon, 18 Mar 2002 19:36:57 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="004188.html">[Mono-list] delegates and AsyncCallback
</A></li>
        <LI> Next message: <A HREF="004189.html">[Mono-list] Cygwin build
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4193">[ date ]</a>
              <a href="thread.html#4193">[ thread ]</a>
              <a href="subject.html#4193">[ subject ]</a>
              <a href="author.html#4193">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>I just try to implement asynchronous delegate support, but I don't know
</I>&gt;<i>when to invoke the AsyncCallback passed to BeginInvoke
</I>
You should invoke the AsyncCallback delegate right after the method
finishes, and you should invoke it from the worker thread, not the
calling thread.

The reason you're only seeing the callback sometimes is that your code
has a race condition. The main thread occasionally gets the EndInvoke in
before the async_callback fires and then it exits, taking down the
worker thread before it ever manages to call the your callback.  Change
that EndInvoke to a Console.ReadLine() and you'll see the callback get
called every time.

Typically when passing an async callback EndInvoke is called inside the
callback proc, not from the issuing thread. If you think about it,
there's no REASON to pass in the AsyncCallback if your main thread is
going to rendezvous with EndInvoke - it's there to allow you to harvest
the results asynchronously.  I modified your code to reflect this:

======================
using System;

class Test {
	delegate int SimpleDelegate (int a);

	static int F (int a) {
		Console.WriteLine (&quot;Test.F from delegate: &quot; + a);
		return a;
	}

	static void async_callback (IAsyncResult ar)
	{
	int result = ((SimpleDelegate)(ar.AsyncState)).EndInvoke(ar);
	Console.WriteLine(result);
	}
	
	static void Main () {
		SimpleDelegate d = new SimpleDelegate (F);
		d.BeginInvoke(3, new AsyncCallback (async_callback), d);
		System.Console.ReadLine();		
	}
} 
=======================

Hope this helps,
Jason





</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="004188.html">[Mono-list] delegates and AsyncCallback
</A></li>
	<LI> Next message: <A HREF="004189.html">[Mono-list] Cygwin build
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4193">[ date ]</a>
              <a href="thread.html#4193">[ thread ]</a>
              <a href="subject.html#4193">[ subject ]</a>
              <a href="author.html#4193">[ author ]</a>
         </LI>
       </UL>
</body></html>
