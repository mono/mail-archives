<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] patch: support for value types and strings
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:dietmar%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="002107.html">
   <LINK REL="Next"  HREF="002093.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] patch: support for value types and strings
   </H1>
    <B>Dietmar Maurer
    </B> 
    <A HREF="mailto:dietmar%40ximian.com"
       TITLE="[Mono-list] patch: support for value types and strings">dietmar@ximian.com
       </A><BR>
    <I>15 Nov 2001 16:15:16 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="002107.html">[Mono-list] Mono Status
</A></li>
        <LI> Next message: <A HREF="002093.html">[Mono-list] Info on all Mono related projects.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2092">[ date ]</a>
              <a href="thread.html#2092">[ thread ]</a>
              <a href="subject.html#2092">[ subject ]</a>
              <a href="author.html#2092">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Got more test programs working: struct.exe, string.exe and
stringbuilder.exe.

Value types: I have introduced a new nonterminal in the BURG grammar,
called vtype. I hope we can eliminate most unnecessary copying that way.

- Dietmar


Index: mono/jit/ChangeLog
===================================================================
RCS file: /cvs/public/mono/mono/jit/ChangeLog,v
retrieving revision 1.42
diff -u -r1.42 ChangeLog
--- mono/jit/ChangeLog	2001/11/10 04:29:12	1.42
+++ mono/jit/ChangeLog	2001/11/15 11:07:52
@@ -1,3 +1,14 @@
+2001-11-15  Dietmar Maurer  &lt;<A HREF="mailto:dietmar@ximian.com">dietmar@ximian.com</A>&gt;
+
+	* Makefile.am (mono_SOURCES): renamed testjit to mono
+
+	* x86.brg: added debugging support 
+
+	* testjit.c: added support for value types, CFG improvements
+
+	* emit-x86.c (enter_method): handle value types
+	(tree_allocate_regs): impl. a better way to handle chain rules
+
 2001-11-10  Dietmar Maurer  &lt;<A HREF="mailto:dietmar@ximian.com">dietmar@ximian.com</A>&gt;
 
 	* x86.brg (INITOBJ): bug fix: initialize data before use,
Index: mono/jit/Makefile.am
===================================================================
RCS file: /cvs/public/mono/mono/jit/Makefile.am,v
retrieving revision 1.9
diff -u -r1.9 Makefile.am
--- mono/jit/Makefile.am	2001/11/09 16:39:49	1.9
+++ mono/jit/Makefile.am	2001/11/15 11:07:52
@@ -3,9 +3,9 @@
 	$(GMODULE_CFLAGS)		\
 	$(GLIB_CFLAGS)			
 
-bin_PROGRAMS = testjit
+bin_PROGRAMS = mono
 
-testjit_SOURCES =		\
+mono_SOURCES =			\
 	codegen.h		\
 	codegen-x86.c		\
 	emit-x86.c		\
@@ -14,9 +14,9 @@
 	regset.c		\
 	mempool.h		\
 	mempool.c		\
-	testjit.c
+	jit.c
 
-testjit_LDADD =				\
+mono_LDADD =				\
 	../metadata/libmetadata.a	\
 	$(GLIB_LIBS)			\
 	$(GMODULE_LIBS) 		\
Index: mono/jit/emit-x86.c
===================================================================
RCS file: /cvs/public/mono/mono/jit/emit-x86.c,v
retrieving revision 1.16
diff -u -r1.16 emit-x86.c
--- mono/jit/emit-x86.c	2001/11/09 06:28:40	1.16
+++ mono/jit/emit-x86.c	2001/11/15 11:07:52
@@ -25,7 +25,7 @@
 static void
 enter_method (MonoMethod *method, gpointer ebp)
 {
-	int i;
+	int i, j;
 	MonoClass *class;
 	MonoObject *o;
 
@@ -33,17 +33,31 @@
 		method-&gt;klass-&gt;name, method-&gt;name);
 
 	ebp += 8;
-	
+
+	if (method-&gt;signature-&gt;ret-&gt;type == MONO_TYPE_VALUETYPE) {
+		int size, align;
+
+		if ((size = mono_type_size (method-&gt;signature-&gt;ret, &amp;align)) &gt; 4 ||
size == 3) {
+			printf (&quot;VALUERET:%p, &quot;, *((gpointer *)ebp));
+			ebp += sizeof (gpointer);
+		}
+	}
+
 	if (method-&gt;signature-&gt;hasthis) {
-		o = *((MonoObject **)ebp);
-		class = o-&gt;klass;
-		printf (&quot;this:%p[%s.%s], &quot;, o, class-&gt;name_space, class-&gt;name);
+		if (method-&gt;klass-&gt;valuetype) {
+			printf (&quot;value:%p, &quot;, *((gpointer *)ebp));
+		} else {
+			o = *((MonoObject **)ebp);
+			class = o-&gt;klass;
+			printf (&quot;this:%p[%s.%s], &quot;, o, class-&gt;name_space, class-&gt;name);
+		}
 		ebp += sizeof (gpointer);
 	}
 
 	for (i = 0; i &lt; method-&gt;signature-&gt;param_count; ++i) {
 		MonoType *type = method-&gt;signature-&gt;params [i];
 		int size, align;
+		size = mono_type_size (type, &amp;align);
 
 		switch (type-&gt;type) {
 		case MONO_TYPE_BOOLEAN:
@@ -73,17 +87,18 @@
 		case MONO_TYPE_R8:
 			printf (&quot;%f, &quot;, *((double *)(ebp)));
 			break;
-
+		case MONO_TYPE_VALUETYPE: 
+			printf (&quot;[&quot;);
+			for (j = 0; j &lt; size; j++)
+				printf (&quot;%02x,&quot;, *((guint8*)ebp +j));
+			printf (&quot;], &quot;);
+			break;
 		default:
 			printf (&quot;XX, &quot;);
 		}
-
-		size = mono_type_size (type, &amp;align);
-		if (size &lt; 4) 
-			size = 4;
 
-		ebp += size;
-
+		ebp += size + 3;
+		ebp = (gpointer)((unsigned)ebp &amp; ~(3));
 	}
 
 	printf (&quot;)\n&quot;);
@@ -433,15 +448,18 @@
 
 	//printf (&quot;RALLOC START %d %p %d\n&quot;,  tree-&gt;op, rs-&gt;free_mask, goal);
 
+	if (nts [0] &amp;&amp; kids [0] == tree) {
+		/* chain rule */
+		tree_allocate_regs (kids [0], nts [0], rs);
+		return;
+	}
+
 	for (i = 0; nts [i]; i++)
-		if (kids [i] != tree) /* don't allocate regs for chain rules */
-			tree_allocate_regs (kids [i], nts [i], rs);
+		tree_allocate_regs (kids [i], nts [i], rs);
 
 	for (i = 0; nts [i]; i++) {
-		if (kids [i] != tree) { /* we do not free register for chain rules */
-			mono_regset_free_reg (rs, kids [i]-&gt;reg1);
-			mono_regset_free_reg (rs, kids [i]-&gt;reg2);
-		}
+		mono_regset_free_reg (rs, kids [i]-&gt;reg1);
+		mono_regset_free_reg (rs, kids [i]-&gt;reg2);
 	}
 
 	switch (goal) {
@@ -631,8 +649,8 @@
 	mono_regset_reserve_reg (cfg-&gt;rs, X86_ESP);
 	mono_regset_reserve_reg (cfg-&gt;rs, X86_EBP);
 
-	// fixme: remove limitation to 1024 bytes
-	method-&gt;addr = cfg-&gt;start = cfg-&gt;code = g_malloc (1024);
+	// fixme: remove limitation to 4096 bytes
+	method-&gt;addr = cfg-&gt;start = cfg-&gt;code = g_malloc (4096);
 
 	if (mono_jit_dump_forest) {
 		int i;
Index: mono/jit/jit.c
===================================================================
RCS file: /cvs/public/mono/mono/jit/jit.c,v
retrieving revision 1.43
diff -u -r1.43 jit.c
--- mono/jit/jit.c	2001/11/09 22:20:33	1.43
+++ mono/jit/jit.c	2001/11/15 11:07:52
@@ -45,7 +45,7 @@
 };
 #undef OPDEF
 
-#define SET_VARINFO(vi,t,k,o)  do { vi.type=t; vi.kind=k; vi.offset=o;
} while (0)
+#define SET_VARINFO(vi,t,k,o,s)  do { vi.type=t; vi.kind=k;
vi.offset=o; vi.size=s; } while (0)
 
 #define
MAKE_CJUMP(name)                                                      \
 case
CEE_##name:                                                             
\
@@ -62,7 +62,8 @@
 	g_assert (target &gt;= 0 &amp;&amp; target &lt;= header-&gt;code_size);               
\
 	g_assert (bcinfo [target].is_block_start);                           
\
 	tbb = &amp;cfg-&gt;bblocks [bcinfo [target].block_id];                      
\
-	MARK_REACHED (tbb);                                                  
\
+	create_outstack (cfg, bb, stack, sp - stack);                        
\
+	mark_reached (cfg, tbb, bb-&gt;outstack, bb-&gt;outdepth);                 
\
 	t1-&gt;data.p = tbb;                                                    
\
 	ADD_TREE (t1);                                                       
\
 	ip += near_jump ? 1: 4;		                                      \
@@ -354,7 +355,8 @@
 		*svt = VAL_DOUBLE;
 		return MB_TERM_LDIND_R8;
 	case MONO_TYPE_VALUETYPE: {
-		int size =  type-&gt;data.klass-&gt;instance_size - sizeof (MonoObject);
+		int size, align;
+		size = mono_type_size (type, &amp;align);
 
 		switch (size) {
 		case 4:
@@ -367,8 +369,7 @@
 			*svt = VAL_I32;
 			return MB_TERM_LDIND_U1;
 		default:
-			*svt = VAL_UNKNOWN;
-			return MB_TERM_LDIND_OBJ;
+			g_assert_not_reached ();
 		}
 	}
 	default:
@@ -401,12 +402,14 @@
 	case MONO_TYPE_I:
 	case MONO_TYPE_I4:
 	case MONO_TYPE_U4:
+	case MONO_TYPE_VALUETYPE:
 		*svt = VAL_I32;
 		return MB_TERM_CALL_I4;
 	case MONO_TYPE_CLASS:
 	case MONO_TYPE_OBJECT:
 	case MONO_TYPE_STRING:
 	case MONO_TYPE_PTR:
+	case MONO_TYPE_SZARRAY: 
 		*svt = VAL_POINTER;
 		return MB_TERM_CALL_I4;
 	case MONO_TYPE_I8:
@@ -444,6 +447,9 @@
 	else 
 		printf (&quot; %s&quot;, mono_burg_term_string [tree-&gt;op]);
 
+	if (tree-&gt;op == MB_TERM_ADDR_L)
+		printf (&quot;[%d]&quot;, tree-&gt;data.i);
+
 	g_assert (!(tree-&gt;right &amp;&amp; !tree-&gt;left));
 
 	mono_print_ctree (tree-&gt;left);
@@ -507,12 +513,12 @@
 		cfg-&gt;locals_size &amp;= ~(align - 1);
 		cfg-&gt;locals_size += size;
 
-		SET_VARINFO (vi, type, kind, - cfg-&gt;locals_size);
+		SET_VARINFO (vi, type, kind, - cfg-&gt;locals_size, size);
 		g_array_append_val (cfg-&gt;varinfo, vi);
 		break;
 	}
 	case MONO_ARGVAR: {
-		SET_VARINFO (vi, type, kind, cfg-&gt;args_size + 8);
+		SET_VARINFO (vi, type, kind, cfg-&gt;args_size + 8, size);
 		g_array_append_val (cfg-&gt;varinfo, vi);
 
 		cfg-&gt;args_size += align - 1;
@@ -552,36 +558,47 @@
 mono_allocate_intvar (MonoFlowGraph *cfg, int slot, MonoValueType type)
 {
 	int size, align, vnum;
-
+	
 	g_assert (type != VAL_UNKNOWN);
 
-	if ((vnum = cfg-&gt;intvars[slot][type - 1]))
+	if ((vnum = cfg-&gt;intvars [type - 1 + slot * VAL_DOUBLE]))
 		return vnum;
 
 	mono_get_val_sizes (type, &amp;size, &amp;align);
 
-	return cfg-&gt;intvars[slot][type - 1] = arch_allocate_var (cfg, size,
align, MONO_TEMPVAR, type);
+	return cfg-&gt;intvars[type - 1 + slot * VAL_DOUBLE] = arch_allocate_var
(cfg, size, align, MONO_TEMPVAR, type);
 }
 
 /**
  * ctree_create_load:
- * @mp: pointer to a memory pool
- * @addr_type: address type (MB_TERM_ADDR_L or MB_TERM_ADDR_G)
- * @type: the type of the value
+ * @cfg: pointer to the control flow graph
+ * @type: the type of the value to load
  * @addr: the address of the value
  *
  * Creates a tree to load the value at address @addr.
  */
 inline static MBTree *
-ctree_create_load (MonoMemPool *_p, int addr_type, MonoType *type,
gpointer addr, MonoValueType *svt)
+ctree_create_load (MonoFlowGraph *cfg, MonoType *type, MBTree *addr,
MonoValueType *svt)
 {
-	int ldind = map_ldind_type (type, svt);
+	MonoMemPool *mp = cfg-&gt;mp;
+	int ldind, size, align, vnum;
 	MBTree *t;
 
-	t = mono_ctree_new_leaf (mp, addr_type);
-	t-&gt;data.p = addr;
-	t = mono_ctree_new (mp, ldind, t, NULL);
+	if (type-&gt;type == MONO_TYPE_VALUETYPE) {
+		size = mono_type_size (type, &amp;align);
 
+		if (size &gt; 4 || size == 3) {
+		
+			vnum = arch_allocate_var (cfg, size, align, MONO_TEMPVAR,
VAL_UNKNOWN);
+			t = mono_ctree_new (mp, MB_TERM_LDIND_OBJ, addr, NULL);
+			t-&gt;data.i = vnum;
+			return t;
+		}
+	}
+
+	ldind = map_ldind_type (type, svt);
+	t = mono_ctree_new (mp, ldind, addr, NULL);
+
 	return t;
 }
 
@@ -713,16 +730,27 @@
 	case MB_TERM_LDIND_R4:
 	case MB_TERM_STIND_R8:
 	case MB_TERM_LDIND_R8: {
-		if (dup)
-			*dup = ctree_create_dup (mp, s);
-		return NULL;
+		if (slot &gt;= 0) {
+			vnum = mono_allocate_intvar (cfg, slot, s-&gt;svt);
+
+			if (s-&gt;left-&gt;op == MB_TERM_ADDR_L &amp;&amp; s-&gt;left-&gt;data.i == vnum) {
+				if (dup)
+					*dup = ctree_create_dup (mp, s);
+				return NULL;
+			}
+			// fall through
+		} else {
+			if (dup)
+				*dup = ctree_create_dup (mp, s);
+			return NULL;
+		}
 	}			
 	default: {
 			g_assert (s-&gt;svt != VAL_UNKNOWN);
 
-			if (slot &gt;= 0) 
+			if (slot &gt;= 0) {
 				vnum = mono_allocate_intvar (cfg, slot, s-&gt;svt);
-			else {
+			} else {
 				int size, align;
 				mono_get_val_sizes (s-&gt;svt, &amp;size, &amp;align);
 				vnum = arch_allocate_var (cfg, size, align, MONO_TEMPVAR, s-&gt;svt);
@@ -755,7 +783,7 @@
 
 	cfg-&gt;varinfo = g_array_new (FALSE, TRUE, sizeof (MonoVarInfo));
 	
-	SET_VARINFO (vi, 0, 0, 0);
+	SET_VARINFO (vi, 0, 0, 0, 0);
 	g_array_append_val (cfg-&gt;varinfo, vi); /* add invalid value at
position 0 */
 
 	cfg-&gt;intvars = mono_mempool_alloc0 (mp, sizeof (guint16) * VAL_DOUBLE
* 
@@ -775,7 +803,7 @@
 	g_array_free (cfg-&gt;varinfo, TRUE);
 }
 
-#define CREATE_BLOCK(t) {if (!bcinfo [t].is_block_start)
{block_count++;bcinfo [t].is_block_start = 1;}}
+#define CREATE_BLOCK(t) {if (!bcinfo [t].is_block_start)
{block_count++;bcinfo [t].is_block_start = 1; }}
 
 void
 mono_analyze_flow (MonoFlowGraph *cfg)
@@ -898,6 +926,26 @@
 		case CEE_LDELEM_R4:
 		case CEE_LDELEM_R8:
 		case CEE_LDELEM_REF:
+		case CEE_CONV_OVF_I_UN:
+		case CEE_CONV_OVF_U_UN:
+		case CEE_CONV_OVF_I1_UN:
+		case CEE_CONV_OVF_U1_UN:
+		case CEE_CONV_OVF_I2_UN:
+		case CEE_CONV_OVF_U2_UN:
+		case CEE_CONV_OVF_I4_UN:
+		case CEE_CONV_OVF_U4_UN:
+		case CEE_CONV_OVF_I8_UN:
+		case CEE_CONV_OVF_U8_UN:
+		case CEE_CONV_OVF_I:
+		case CEE_CONV_OVF_U:
+		case CEE_CONV_OVF_I1:
+		case CEE_CONV_OVF_U1:
+		case CEE_CONV_OVF_I2:
+		case CEE_CONV_OVF_U2:
+		case CEE_CONV_OVF_I4:
+		case CEE_CONV_OVF_U4:
+		case CEE_CONV_OVF_I8:
+		case CEE_CONV_OVF_U8:
 		case CEE_CONV_I1:
 		case CEE_CONV_U1:
 		case CEE_CONV_I2:
@@ -927,6 +975,7 @@
 		case CEE_STSFLD: 
 		case CEE_STFLD:
 		case CEE_NEWOBJ:
+		case CEE_CPOBJ:
 		case CEE_NEWARR:
 		case CEE_LDTOKEN:
 		case CEE_CALL:
@@ -968,6 +1017,8 @@
 		case CEE_LDLOCA_S:
 		case CEE_STLOC_S:
 		case CEE_LDARG_S: 
+		case CEE_LDARGA_S: 
+		case CEE_STARG_S:
 			ip += 2;
 			break;
 		case CEE_BR_S:
@@ -1003,7 +1054,7 @@
 			for (i = 0; i &lt; n; i++) {
 				target = read32 (ip) + st;
 				ip += 4;
-				CREATE_BLOCK (st + target);			
+				CREATE_BLOCK (target);			
 			}
 			break;
 		}
@@ -1012,6 +1063,7 @@
 			switch (*ip) {
 				
 			case CEE_CEQ:
+			case CEE_CLT:
 				ip++;
 				break;
 			case CEE_LDARG:
@@ -1057,39 +1109,6 @@
 	cfg-&gt;block_count = block_count;
 }
 
-static MBTree **
-mono_copy_stack (MBTree **sp, int depth, MonoMemPool *mp)
-{
-	int i;
-	MBTree **copy;
-
-	copy = mono_mempool_alloc (mp, depth * sizeof (MBTree *));
-	
-	sp -= depth;
-
-	for (i = 0; i &lt; depth; i++) {
-		switch (sp [i]-&gt;op) {
-		case MB_TERM_LDIND_I1:
-		case MB_TERM_LDIND_U1:
-		case MB_TERM_LDIND_I2:
-		case MB_TERM_LDIND_U2:
-		case MB_TERM_LDIND_I4:
-		case MB_TERM_LDIND_U4:
-		case MB_TERM_LDIND_I8:
-		case MB_TERM_LDIND_R4:
-		case MB_TERM_LDIND_R8:
-			break;
-		default:
-			g_warning (&quot;cant handle type %s (%d)\n&quot;, mono_burg_term_string [sp
[i]-&gt;op], i);
-				// fixme: store the value somewhere
-			g_assert_not_reached ();
-		}
-	}
-
-	g_assert_not_reached ();
-	return NULL;
-}
-
 /**
  * ves_array_element_address:
  * @this: a pointer to the array object
@@ -1161,10 +1180,69 @@
 #define LOCAL_POS(n)    (1 + n)
 #define LOCAL_TYPE(n)   ((header)-&gt;locals [(n)])
 
-#define ARG_POS(n)      (1 + header-&gt;num_locals + n)
+#define ARG_POS(n)      (firstarg + n)
 #define ARG_TYPE(n)     ((n) ? (signature)-&gt;params [(n) -
(signature)-&gt;hasthis] : \
 			(signature)-&gt;hasthis ? &amp;method-&gt;klass-&gt;this_arg: (signature)-&gt;params
[(0)])
 
+static void
+create_outstack (MonoFlowGraph *cfg, MonoBBlock *bb, MBTree **stack,
int depth)
+{
+	MonoMemPool *mp = cfg-&gt;mp;
+	MBTree **c = stack, *t1, *t2;
+	GPtrArray *forest = bb-&gt;forest;
+	int i;
+
+	g_assert (bb-&gt;reached);
+
+	if (depth &lt;= 0)
+		return;
+
+	if (bb-&gt;outstack) {
+		g_assert (bb-&gt;outdepth == depth);
+		return;
+	}
+
+	bb-&gt;outdepth = depth;
+	bb-&gt;outstack = mono_mempool_alloc (mp, depth * sizeof (MBTree *));
+	
+	for (i = 0; i &lt; depth; i++) {
+		if ((t1 = mono_store_tree (cfg, i, c [i], &amp;t2)))
+			ADD_TREE (t1);
+		bb-&gt;outstack [i] = t2;
+	}
+}
+
+static void
+mark_reached (MonoFlowGraph *cfg, MonoBBlock *target, MBTree **stack,
int depth)
+{
+	MonoMemPool *mp = cfg-&gt;mp;
+	int i;
+
+	if (target-&gt;reached)
+		return;
+
+	target-&gt;reached = 1;
+
+	if (depth == 0)
+		return;
+
+	g_assert (stack);
+
+	if (target-&gt;instack) {
+		g_assert (target-&gt;indepth == depth);
+		return;
+	}
+
+	target-&gt;indepth = depth;
+	target-&gt;instack = mono_mempool_alloc (mp, depth * sizeof (MBTree *));
+	
+	for (i = 0; i &lt; depth; i++) {
+		target-&gt;instack [i] = ctree_create_dup (mp, stack [i]);
+	}
+	
+	
+}
+
 #define MARK_REACHED(bb) do { if (!bb-&gt;reached) { bb-&gt;reached = 1; }}
while (0)
 
 /**
@@ -1193,6 +1271,7 @@
 	register const unsigned char *ip, *end;
 	GPtrArray *forest;
 	int i, j, depth, repeat_count;
+	int varnum = 0, firstarg = 0, retvtarg = 0;
 	gboolean repeat, superblock_end;
 	MonoBBlock *bb, *tbb;
 
@@ -1207,10 +1286,23 @@
 
 		for (i = 0; i &lt; header-&gt;num_locals; ++i) {
 			size = mono_type_size (header-&gt;locals [i], &amp;align);
-			arch_allocate_var (cfg, size, align, MONO_LOCALVAR, VAL_UNKNOWN);
+			varnum = arch_allocate_var (cfg, size, align, MONO_LOCALVAR,
VAL_UNKNOWN);
 		}
 	}
+
+	if (signature-&gt;ret-&gt;type == MONO_TYPE_VALUETYPE) {
+		int size, align;
+
+		size = mono_type_size (signature-&gt;ret, &amp;align);
+		
+		retvtarg = varnum = arch_allocate_var (cfg, size, align,
MONO_LOCALVAR, VAL_UNKNOWN);
+		
+		//printf (&quot;VALUETYPE METHOD %s.%s::%s %d\n&quot;,
method-&gt;klass-&gt;name_space, 
+		//method-&gt;klass-&gt;name, method-&gt;name, size);
+	}
 	
+	firstarg = varnum + 1;
+ 
 	if (signature-&gt;params_size) {
 		int align, size;
 		int has_this = signature-&gt;hasthis;
@@ -1244,19 +1336,11 @@
 			//printf (&quot;BBS %d %d %d %d\n&quot;, i, bb-&gt;reached, bb-&gt;finished,
superblock_end);
 			
 			if (!bb-&gt;reached &amp;&amp; !superblock_end) {
+				MonoBBlock *sbb = &amp;cfg-&gt;bblocks [i - 1];
 
-				if ((depth = sp - stack)) {
+				g_assert (sbb-&gt;outdepth == (sp - stack));
 
-					g_assert_not_reached ();
-					//bb-&gt;instack = mono_copy_stack;
-					bb-&gt;indepth = depth;
-
-					for (j = 0; j &lt; depth; j++) {
-						bb-&gt;instack [j] = ctree_create_dup (mp, sp [j]);
-					}
-				}
-
-				MARK_REACHED (bb);
+				mark_reached (cfg, bb, sbb-&gt;outstack, sbb-&gt;outdepth);
 			} 
 			
 			if (bb-&gt;reached) {
@@ -1357,7 +1441,6 @@
 		case CEE_LDOBJ: {
 			guint32 token;
 			MonoClass *c;
-			int size;
 
 			++ip;
 			token = read32 (ip);
@@ -1367,25 +1450,7 @@
 			c = mono_class_get (image, token);
 			g_assert (c-&gt;valuetype);
 
-			size = c-&gt;instance_size - sizeof (MonoObject);
-			switch (size) {
-			case 4:
-				t1 = mono_ctree_new (mp, MB_TERM_LDIND_U4, *sp, NULL);
-				svt = VAL_I32;
-				break;
-			case 2:
-				t1 = mono_ctree_new (mp, MB_TERM_LDIND_U2, *sp, NULL);
-				svt = VAL_I32;
-				break;
-			case 1:
-				t1 = mono_ctree_new (mp, MB_TERM_LDIND_U1, *sp, NULL);
-				_vt = VAL_I32;
-				break;
-			default:
-				t1 = mono_ctree_new (mp, MB_TERM_LDIND_OBJ, *sp, NULL);
-				svt = VAL_UNKNOWN;
-				break;
-			}
+			t1 = ctree_create_load (cfg, &amp;c-&gt;byval_arg, *sp, &amp;svt);
 			PUSH_TREE (t1, svt);
 			break;
 		}
@@ -1433,7 +1498,9 @@
 				t1-&gt;data.p = addr;
 				svt = VAL_POINTER;
 			} else {
-				t1 = ctree_create_load (mp, MB_TERM_ADDR_G, field-&gt;type, addr,
&amp;svt);
+				t1 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_G);
+				t1-&gt;data.p = addr;
+				t1 = ctree_create_load (cfg, field-&gt;type, t1, &amp;svt);
 			}
 
 			PUSH_TREE (t1, svt);
@@ -1531,7 +1598,7 @@
 			else 
 				t1-&gt;data.i = field-&gt;offset;
 
-			printf (&quot;VALUETYPE %d %d %d\n&quot;, klass-&gt;valuetype, field-&gt;offset,
t1-&gt;data.i);
+			//printf (&quot;VALUETYPE %d %d %d\n&quot;, klass-&gt;valuetype, field-&gt;offset,
t1-&gt;data.i);
 
 			t1 = mono_ctree_new (mp, MB_TERM_ADD, sp [0], t1);
 			t1 = mono_ctree_new (mp, map_stind_type (field-&gt;type), t1, sp [1]);
@@ -1566,6 +1633,8 @@
 			// hack: we store n at position 0
 			jt [0] = (MonoBBlock *)n;
 
+			create_outstack (cfg, bb, stack, sp - stack);
+
 			for (i = 1; i &lt;= (n + 1); i++) {
 				if (i &gt; n)
 					target = st;
@@ -1576,7 +1645,7 @@
 				g_assert (target &gt;= 0 &amp;&amp; target &lt;= header-&gt;code_size);
 				g_assert (bcinfo [target].is_block_start);
 				tbb = &amp;cfg-&gt;bblocks [bcinfo [target].block_id];
-				MARK_REACHED (tbb);
+				mark_reached (cfg, tbb, stack, sp - stack);
 				jt [i] = tbb; 
 			}
 
@@ -1613,6 +1682,21 @@
 
 			break;
 		}
+		case CEE_CPOBJ: {
+			MonoClass *class;
+			guint32 token;
+
+			++ip;
+			token = read32 (ip);
+			class = mono_class_get (image, token);
+			ip += 4;
+			sp -= 2;
+
+			t1 = mono_ctree_new (mp, MB_TERM_CPOBJ, sp [0], sp [1]);
+			ADD_TREE (t1);
+			
+			break;
+		}
 		case CEE_NEWOBJ: {
 			MonoMethodSignature *csig;
 			MonoMethod *cm;
@@ -1663,7 +1747,7 @@
 			t1 = mono_ctree_new (mp, MB_TERM_ARG, this, NULL);	
 			ADD_TREE (t1);
 			args_size += sizeof (gpointer);
-
+			
 			if (newarr) {
 
 				t2 = mono_ctree_new_leaf (mp, MB_TERM_CONST_I4);
@@ -1688,7 +1772,7 @@
 			t1-&gt;svt = svt;
 
 			if (newarr) {
-				
+     
 				t1 = mono_store_tree (cfg, -1, t1, &amp;t2);
 				g_assert (t1);
 				ADD_TREE (t1);
@@ -1712,7 +1796,7 @@
 			int virtual = *ip == CEE_CALLVIRT;
 			gboolean array_set = FALSE;
 			gboolean array_get = FALSE;
-			int nargs;
+			int nargs, vtype_num = 0;
 
 			++ip;
 			token = read32 (ip);
@@ -1729,6 +1813,9 @@
 			g_assert (csig-&gt;call_convention == MONO_CALL_DEFAULT);
 			g_assert (!virtual || csig-&gt;hasthis);
 
+			/* fixme: we need to unbox the this pointer for value types */
+			g_assert (!virtual || !cm-&gt;klass-&gt;valuetype);
+
 			nargs = csig-&gt;param_count;
 			arg_sp = sp -= nargs;
 			
@@ -1755,6 +1842,27 @@
 				args_size += sizeof (gpointer);
 			}
 
+			if (csig-&gt;ret-&gt;type == MONO_TYPE_VALUETYPE) {
+				int size, align;
+
+				if ((size = mono_type_size (csig-&gt;ret, &amp;align)) &gt; 4 || size == 3) {
+
+					//printf (&quot;VALUETYPE RETURN %s.%s::%s %d\n&quot;,
cm-&gt;klass-&gt;name_space, 
+					//cm-&gt;klass-&gt;name, cm-&gt;name, size);
+				
+					vtype_num = arch_allocate_var (cfg, size, align, MONO_TEMPVAR,
VAL_UNKNOWN);
+				
+					t2 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_L);
+					t2-&gt;data.i = vtype_num;
+				
+					t1 = mono_ctree_new (mp, MB_TERM_ARG, t2, NULL);	
+					ADD_TREE (t1);
+					t1-&gt;svt = VAL_POINTER;
+
+					args_size += sizeof (gpointer);
+				}
+			}
+
 			if (array_get) {
 				int size, align, vnum;
 				
@@ -1822,11 +1930,17 @@
 
 				if (csig-&gt;ret-&gt;type != MONO_TYPE_VOID) {
 
-					t1 = mono_store_tree (cfg, -1, t1, &amp;t2);
-					g_assert (t1);
-					ADD_TREE (t1);
-					PUSH_TREE (t2, t2-&gt;svt);
-					
+					if (vtype_num) {
+						ADD_TREE (t1);
+						t1 = mono_ctree_new_leaf (mp, MB_TERM_VTYPE);
+						t1-&gt;data.i = vtype_num;
+						PUSH_TREE (t1, VAL_UNKNOWN); 
+					} else {
+						t1 = mono_store_tree (cfg, -1, t1, &amp;t2);
+						g_assert (t1);
+						ADD_TREE (t1);
+						PUSH_TREE (t2, t2-&gt;svt);
+					}
 				} else
 					ADD_TREE (t1);
    
@@ -1920,8 +2034,9 @@
 			int n = (*ip) - CEE_LDLOC_0;
 			++ip;
 
-			t1 = ctree_create_load (mp, MB_TERM_ADDR_L, LOCAL_TYPE (n), 
-						(gpointer)LOCAL_POS (n), &amp;svt);
+			t1 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_L);
+			t1-&gt;data.i = LOCAL_POS (n);
+			t1 = ctree_create_load (cfg, LOCAL_TYPE (n), t1, &amp;svt);
 
 			PUSH_TREE (t1, svt);
 			break;
@@ -1929,8 +2044,9 @@
 		case CEE_LDLOC_S: {
 			++ip;
 			
-			t1 = ctree_create_load (mp, MB_TERM_ADDR_L, LOCAL_TYPE (*ip), 
-						(gpointer)LOCAL_POS (*ip), &amp;svt);
+			t1 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_L);
+			t1-&gt;data.i = LOCAL_POS (*ip);
+			t1 = ctree_create_load (cfg, LOCAL_TYPE (*ip), t1, &amp;svt);
 			++ip;
 
 			PUSH_TREE (t1, svt);
@@ -2047,15 +2163,17 @@
 			++ip;
 			t1 = mono_ctree_new_leaf (mp, MB_TERM_BR);
 			target = cli_addr + 2 + (signed char) *ip;
-
+ 
 			g_assert (target &gt;= 0 &amp;&amp; target &lt;= header-&gt;code_size);
 			g_assert (bcinfo [target].is_block_start);
 			tbb = &amp;cfg-&gt;bblocks [bcinfo [target].block_id];
-			MARK_REACHED (tbb);
-			t1-&gt;data.p = tbb;
+			create_outstack (cfg, bb, stack, sp - stack);
+			mark_reached (cfg, tbb, bb-&gt;outstack, bb-&gt;outdepth);
 
+			t1-&gt;data.p = tbb;
 			ADD_TREE (t1);
 			++ip;
+
 			superblock_end = TRUE;
 			break;
 		}
@@ -2069,11 +2187,13 @@
 			g_assert (target &gt;= 0 &amp;&amp; target &lt;= header-&gt;code_size);
 			g_assert (bcinfo [target].is_block_start);
 			tbb = &amp;cfg-&gt;bblocks [bcinfo [target].block_id];
-			MARK_REACHED (tbb);
+			create_outstack (cfg, bb, stack, sp - stack);
+			mark_reached (cfg, tbb, bb-&gt;outstack, bb-&gt;outdepth);
+		      
 			t1-&gt;data.p = tbb;
-
 			ADD_TREE (t1);
 			ip += 4;
+
 			superblock_end = TRUE;
 			break;
 		}
@@ -2106,9 +2226,10 @@
 			g_assert (target &gt;= 0 &amp;&amp; target &lt;= header-&gt;code_size);
 			g_assert (bcinfo [target].is_block_start);
 			tbb = &amp;cfg-&gt;bblocks [bcinfo [target].block_id];
-			MARK_REACHED (tbb);
+			create_outstack (cfg, bb, stack, sp - stack);
+			mark_reached (cfg, tbb, bb-&gt;outstack, bb-&gt;outdepth);
+  
 			t1-&gt;data.p = tbb;
-
 			ip += near_jump ? 1: 4;
 			ADD_TREE (t1);
 			break;
@@ -2130,19 +2251,12 @@
 			g_assert (target &gt;= 0 &amp;&amp; target &lt;= header-&gt;code_size);
 			g_assert (bcinfo [target].is_block_start);
 			tbb = &amp;cfg-&gt;bblocks [bcinfo [target].block_id];
-			MARK_REACHED (tbb);
+			create_outstack (cfg, bb, stack, sp - stack);
+			mark_reached (cfg, tbb, bb-&gt;outstack, bb-&gt;outdepth);
+		    
 			t1-&gt;data.p = tbb;
-
 			ip += near_jump ? 1: 4;
 			ADD_TREE (t1);
-
-			if ((tbb-&gt;indepth = sp - stack)) {
-				
-				printf (&quot;DEPTH %d\n&quot;, tbb-&gt;indepth);
-				g_assert_not_reached ();
-			}
-
-
 			break;
 		}
 		case CEE_RET: {
@@ -2174,20 +2288,42 @@
 			int n = (*ip) - CEE_LDARG_0;
 			++ip;
 
-			t1 = ctree_create_load (mp, MB_TERM_ADDR_L, ARG_TYPE (n), 
-						(gpointer)ARG_POS (n), &amp;svt);
+			t1 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_L);
+			t1-&gt;data.i = ARG_POS (n);
+			t1 = ctree_create_load (cfg, ARG_TYPE (n), t1, &amp;svt);
 			PUSH_TREE (t1, svt);
 			break;
 		}
 		case CEE_LDARG_S: {
 			++ip;
 
-			t1 = ctree_create_load (mp, MB_TERM_ADDR_L, ARG_TYPE (*ip), 
-						(gpointer)ARG_POS (*ip), &amp;svt);
+			t1 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_L);
+			t1-&gt;data.i = ARG_POS (*ip);
+			t1 = ctree_create_load (cfg, ARG_TYPE (*ip), t1, &amp;svt);
 			PUSH_TREE (t1, svt);
 			++ip;
 			break;
 		}
+		case CEE_LDARGA_S: {
+			++ip;
+
+			t1 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_L);
+			t1-&gt;data.i = ARG_POS (*ip);
+			PUSH_TREE (t1, VAL_POINTER);
+			++ip;
+			break;
+		}
+		case CEE_STARG_S: {
+			++ip;
+			--sp;
+
+			t1 = ctree_create_store (mp, MB_TERM_ADDR_L, *sp, LOCAL_TYPE (*ip), 
+						 (gpointer)ARG_POS (*ip));
+			++ip;
+
+			ADD_TREE (t1);			
+			break;
+		}
 		case CEE_DUP: {
 			++ip; 
 			sp--;
@@ -2245,6 +2381,13 @@
 			PUSH_TREE (t1, VAL_I64);		
 			break;
 		}
+		case CEE_CONV_U8: {
+			++ip;
+			sp--;
+			t1 = mono_ctree_new (mp, MB_TERM_CONV_I8, *sp, NULL);
+			PUSH_TREE (t1, VAL_I64);		
+			break;
+		}
 		case CEE_CONV_R8: {
 			++ip;
 			sp--;
@@ -2252,11 +2395,36 @@
 			PUSH_TREE (t1, VAL_DOUBLE);		
 			break;
 		}
+		case CEE_CONV_OVF_U4: {
+			// fixme: raise exceptions ?
+			++ip;
+			sp--;
+			t1 = mono_ctree_new (mp, M__TERM_CONV_I4, *sp, NULL);
+			PUSH_TREE (t1, VAL_I32);		
+			break;
+		}
+		case CEE_CONV_OVF_I4_UN: {
+			// fixme: raise exceptions ?
+			++ip;
+			sp--;
+			t1 = mono_ctree_new (mp, MB_TERM_CONV_I4, *sp, NULL);
+			PUSH_TREE (t1, VAL_I32);		
+			break;
+		}
+		case CEE_CONV_OVF_U4_UN: {
+			// fixme: raise exceptions ?
+			++ip;
+			sp--;
+			t1 = mono_ctree_new (mp, MB_TERM_CONV_I4, *sp, NULL);
+			PUSH_TREE (t1, VAL_I32);		
+			break;
+		}
 		case 0xFE: {
 			++ip;			
 			switch (*ip) {
 				
 			MAKE_BI_ALU (CEQ)
+			MAKE_BI_ALU (CLT)
 
 			case CEE_INITOBJ: {
 				MonoClass *class;
@@ -2280,8 +2448,9 @@
 				n = read32 (ip);
 				ip += 4;
 
-				t1 = ctree_create_load (mp, MB_TERM_ADDR_L, ARG_TYPE (n), 
-							(gpointer)ARG_POS (n), &amp;svt);
+				t1 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_L);
+				t1-&gt;data.i = ARG_POS (n);
+				t1 = ctree_create_load (cfg, ARG_TYPE (n), t1, &amp;svt);
 				PUSH_TREE (t1, svt);
 				break;
 			}
@@ -2300,7 +2469,9 @@
 	}		
 
         if ((depth = sp - stack)) {
-		g_assert_not_reached ();
+		create_outstack (cfg, bb, stack, sp - stack);
+		//mono_print_forest (forest);
+		//printf (&quot;DEPTH %d %d\n&quot;, depth, sp [0]-&gt;op);
 	}
 
 	                        } else 
Index: mono/jit/jit.h
===================================================================
RCS file: /cvs/public/mono/mono/jit/jit.h,v
retrieving revision 1.11
diff -u -r1.11 jit.h
--- mono/jit/jit.h	2001/11/07 06:33:48	1.11
+++ mono/jit/jit.h	2001/11/15 11:07:52
@@ -26,6 +26,7 @@
 	MonoValueType type;
 	MonoValueKind kind;
 	int offset;
+	int size;
 } MonoVarInfo;
 
 typedef struct {
@@ -42,6 +43,8 @@
 	GPtrArray    *forest;
 	MBTree      **instack;
 	gint32        indepth;
+	MBTree      **outstack;
+	gint32        outdepth;
 	gint32        addr;
 } MonoBBlock;
 
@@ -53,7 +56,7 @@
 	GArray           *varinfo;
 	gint32            locals_size;
 	gint32            args_size;
-	guint16         **intvars;
+	guint16          *intvars;
 
 	MonoMemPool      *mp;
 	guint8           *start;
Index: mono/jit/x86.brg
===================================================================
RCS file: /cvs/public/mono/mono/jit/x86.brg,v
retrieving revision 1.35
diff -u -r1.35 x86.brg
--- mono/jit/x86.brg	2001/11/10 04:29:12	1.35
+++ mono/jit/x86.brg	2001/11/15 11:07:52
@@ -91,6 +91,33 @@
 #define MB_USE_OPT2(c) c
 #endif
 
+//#define DEBUG
+
+#ifdef DEBUG
+#define MEMCOPY debug_memcpy
+void *MEMCOPY (void *dest, const void *src, size_t n);
+
+#define PRINT_REG(text,reg) \
+g_assert (reg &gt;= 0); \
+x86_push_reg (s-&gt;code, X86_EAX); \
+x86_push_reg (s-&gt;code, X86_EDX); \
+x86_push_reg (s-&gt;code, X86_ECX); \
+x86_push_reg (s-&gt;code, reg); \
+x86_push_imm (s-&gt;code, reg); \
+x86_push_imm (s-&gt;code, text &quot; %d %p\n&quot;); \
+x86_call_code (s-&gt;code, printf); \
+x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, 3*4); \
+x86_pop_reg (s-&gt;code, X86_ECX); \
+x86_pop_reg (s-&gt;code, X86_EDX); \
+x86_pop_reg (s-&gt;code, X86_EAX); 
+#else
+
+#define MEMCOPY memcpy
+
+#define PRINT_REG(x,y)
+
+#endif
+
 /* The call instruction for virtual functions must have a known
  * size (used by x86_magic_trampoline)
  */
@@ -116,9 +143,9 @@
 %term BREAK SWITCH BR RET RETV 
 %term ADD SUB MUL DIV DIV_UN REM REM_UN AND OR XOR SHL SHR SHR_UN NEG
NOT
 %term BLT BLT_UN BEQ BNE_UN BRTRUE BRFALSE BGE BGE_UN BLE BLE_UN BGT
BGT_UN 
-%term CEQ
-%term CONV_I4 CONV_I1 CONV_I2 CONV_I8 CONV_R8
-%term INTF_ADDR VFUNC_ADDR NOP NEWARR NEWOBJ POP INITOBJ
+%term CEQ CLT
+%term CONV_I4 CONV_I1 CONV_I2 CONV_I8 CONV_U8 CONV_R8
+%term INTF_ADDR VFUNC_ADDR NOP NEWARR NEWOBJ CPOBJ POP INITOBJ VTYPE
 %term LDLEN
 
 #
@@ -220,6 +247,8 @@
 }
 
 stmt: STIND_I4 (addr, reg) {
+	PRINT_REG (&quot;STIND_I4&quot;, tree-&gt;right-&gt;reg1);
+
 	switch (tree-&gt;left-&gt;data.ainfo.amode) {
 
 	case AMImmediate:
@@ -244,6 +273,8 @@
 }
 
 stmt: STIND_I1 (addr, reg) {
+	PRINT_REG (&quot;STIND_I1&quot;, tree-&gt;right-&gt;reg1);
+
 	switch (tree-&gt;left-&gt;data.ainfo.amode) {
 
 	case AMImmediate:
@@ -267,7 +298,84 @@
 	}
 }
 
+stmt: STIND_I2 (addr, reg) {
+	PRINT_REG (&quot;STIND_I2&quot;, tree-&gt;right-&gt;reg1);
+
+	switch (tree-&gt;left-&gt;data.ainfo.amode) {
+
+	case AMImmediate:
+		x86_mov_mem_reg (s-&gt;code, tree-&gt;left-&gt;data.ainfo.offset,
tree-&gt;right-&gt;reg1, 2);
+		break;
+		
+	case AMBase:
+		x86_mov_membase_reg (s-&gt;code, tree-&gt;left-&gt;data.ainfo.basereg, 
+				     tree-&gt;left-&gt;data.ainfo.offset, tree-&gt;right-&gt;reg1, 2);
+		break;		
+	case AMIndex:
+		x86_mov_memindex_reg (s-&gt;code, X86_NOBASEREG,
tree-&gt;left-&gt;data.ainfo.offset,
+				      tree-&gt;left-&gt;data.ainfo.indexreg,
tree-&gt;left-&gt;data.ainfo.shift,
+				      tree-&gt;right-&gt;reg1, 2);
+		break;		
+	case AMBaseIndex:
+		x86_mov_memindex_reg (s-&gt;code, tree-&gt;left-&gt;data.ainfo.basereg,
tree-&gt;left-&gt;data.ainfo.offset,
+				      tree-&gt;left-&gt;data.ainfo.indexreg,
tree-&gt;left-&gt;data.ainfo.shift,
+				      tree-&gt;right-&gt;reg1, 2);
+		break;		
+	}
+}
+
+reg: LDIND_I1 (addr) {
+	switch (tree-&gt;left-&gt;data.ainfo.amode) {
+
+	case AMImmediate:
+		x86_mov_reg_mem (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.ainfo.offset,
1);
+		break;
+
+	case AMBase:
+		x86_mov_reg_membase (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
+				     tree-&gt;left-&gt;data.ainfo.offset, 1);
+		break;		
+	case AMIndex:
+		x86_mov_reg_memindex (s-&gt;code, tree-&gt;reg1, X86_NOBASEREG,
tree-&gt;left-&gt;data.ainfo.offset,
+				      tree-&gt;left-&gt;data.ainfo.indexreg,
tree-&gt;left-&gt;data.ainfo.shift, 1);
+		break;		
+	case AMBaseIndex:
+		x86_mov_reg_memindex (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
+				      tree-&gt;left-&gt;data.ainfo.offset,
tree-&gt;left-&gt;data.ainfo.indexreg, 
+				      tree-&gt;left-&gt;data.ainfo.shift, 1);
+		break;		
+	}
+
+	PRINT_REG (&quot;LDIND_I1&quot;, tree-&gt;reg1);
+}
+
+reg: LDIND_I2 (addr) {
+	switch (tree-&gt;left-&gt;data.ainfo.amode) {
+
+	case AMImmediate:
+		x86_mov_reg_mem (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.ainfo.offset,
2);
+		break;
+
+	case AMBase:
+		x86_mov_reg_membase (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
+				     tree-&gt;left-&gt;data.ainfo.offset, 2);
+		break;		
+	case AMIndex:
+		x86_mov_reg_memindex (s-&gt;code, tree-&gt;reg1, X86_NOBASEREG,
tree-&gt;left-&gt;data.ainfo.offset,
+				      tree-&gt;left-&gt;data.ainfo.indexreg,
tree-&gt;left-&gt;data.ainfo.shift, 2);
+		break;		
+	case AMBaseIndex:
+		x86_mov_reg_memindex (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
+				      tree-&gt;left-&gt;data.ainfo.offset,
tree-&gt;left-&gt;data.ainfo.indexreg, 
+				      tree-&gt;left-&gt;data.ainfo.shift, 2);
+		break;		
+	}
+
+	PRINT_REG (&quot;LDIND_I2&quot;, tree-&gt;reg1);
+}
+
 reg: LDIND_I4 (addr) {
+
 	switch (tree-&gt;left-&gt;data.ainfo.amode) {
 
 	case AMImmediate:
@@ -288,29 +396,58 @@
 				      tree-&gt;left-&gt;data.ainfo.shift, 4);
 		break;		
 	}
+
+	PRINT_REG (&quot;LDIND_I4&quot;, tree-&gt;reg1);
 }
 
 reg: LDIND_U1 (addr) {
 	switch (tree-&gt;left-&gt;data.ainfo.amode) {
 
 	case AMImmediate:
-		x86_mov_reg_mem (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.ainfo.offset,
1);
+		x86_widen_mem (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.ainfo.offset,
FALSE, FALSE);
 		break;
 
 	case AMBase:
-		x86_mov_reg_membase (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
-				     tree-&gt;left-&gt;data.ainfo.offset, 1);
+		x86_widen_membase (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
+				   tree-&gt;left-&gt;data.ainfo.offset, FALSE, FALSE);
 		break;		
 	case AMIndex:
-		x86_mov_reg_memindex (s-&gt;code, tree-&gt;reg1, X86_NOBASEREG,
tree-&gt;left-&gt;data.ainfo.offset,
-				      tree-&gt;left-&gt;data.ainfo.indexreg,
tree-&gt;left-&gt;data.ainfo.shift, 1);
+		x86_widen_memindex (s-&gt;code, tree-&gt;reg1, X86_NOBASEREG,
tree-&gt;left-&gt;data.ainfo.offset,
+				    tree-&gt;left-&gt;data.ainfo.indexreg, tree-&gt;left-&gt;data.ainfo.shift,
FALSE, FALSE);
 		break;		
 	case AMBaseIndex:
-		x86_mov_reg_memindex (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
-				      tree-&gt;left-&gt;data.ainfo.offset,
tree-&gt;left-&gt;data.ainfo.indexreg, 
-				      tree-&gt;left-&gt;data.ainfo.shift, 1);
+		x86_widen_memindex (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
+				    tree-&gt;left-&gt;data.ainfo.offset, tree-&gt;left-&gt;data.ainfo.indexreg,
+				    tree-&gt;left-&gt;data.ainfo.shift, FALSE, FALSE);
+		break;		
+	}
+
+	PRINT_REG (&quot;LDIND_U1&quot;, tree-&gt;reg1);
+}
+
+reg: LDIND_U2 (addr) {
+	switch (tree-&gt;left-&gt;data.ainfo.amode) {
+
+	case AMImmediate:
+		x86_widen_mem (s-&gt;code, tree-&gt;reg1, tree-&gt;_eft-&gt;data.ainfo.offset,
FALSE, TRUE);
+		break;
+
+	case AMBase:
+		x86_widen_membase (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
+				   tree-&gt;left-&gt;data.ainfo.offset, FALSE, TRUE);
+		break;		
+	case AMIndex:
+		x86_widen_memindex (s-&gt;code, tree-&gt;reg1, X86_NOBASEREG,
tree-&gt;left-&gt;data.ainfo.offset,
+				    tree-&gt;left-&gt;data.ainfo.indexreg, tree-&gt;left-&gt;data.ainfo.shift,
FALSE, TRUE);
+		break;		
+	case AMBaseIndex:
+		x86_widen_memindex (s-&gt;code, tree-&gt;reg1,
tree-&gt;left-&gt;data.ainfo.basereg, 
+				    tree-&gt;left-&gt;data.ainfo.offset, tree-&gt;left-&gt;data.ainfo.indexreg,
+				    tree-&gt;left-&gt;data.ainfo.shift, FALSE, TRUE);
 		break;		
 	}
+
+	PRINT_REG (&quot;LDIND_U2&quot;, tree-&gt;reg1);
 }
 
 reg: LDIND_U4 (addr) {
@@ -334,6 +471,8 @@
 				      tree-&gt;left-&gt;data.ainfo.shift, 4);
 		break;		
 	}
+
+	PRINT_REG (&quot;LDIND_U4&quot;, tree-&gt;reg1);
 }
 
 locaddr: ADDR_L 10 {
@@ -341,9 +480,8 @@
 }
 
 reg: ADDR_L 1 {
-	int offset = g_array_index (s-&gt;varinfo, MonoVarInfo,
tree-&gt;data.i).offset;
-	x86_mov_reg_reg (s-&gt;code, tree-&gt;reg1, X86_EBP, 4);
-	x86_alu_reg_imm (s-&gt;code, X86_ADD, tree-&gt;reg1, offset); 
+	int offset = g_array_index (s-&gt;varinfo, MonoVarInfo,
tree-&gt;data.i).offset;  
+	x86_lea_membase (s-&gt;code, tree-&gt;reg1, X86_EBP, offset);
 }
 
 reg: CONV_I1 (reg) {
@@ -362,40 +500,12 @@
 	x86_mov_reg_imm (s-&gt;code, tree-&gt;reg1, tree-&gt;data.i);
 }
 
-# do nothing
-reg: CONV_I4 (reg) 
-
-reg: LDIND_I4 (reg) {
-	x86_mov_reg_membase (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;reg1, 0, 4);
-}
-
-reg: LDIND_I1 (locaddr) {
-	x86_widen_membase (s-&gt;code, tree-&gt;reg1, X86_EBP, tree-&gt;left-&gt;data.i,
TRUE, FALSE);
-}
-
-reg: LDIND_U1 (locaddr) {
-	x86_widen_membase (s-&gt;code, tree-&gt;reg1, X86_EBP, tree-&gt;left-&gt;data.i,
FALSE, FALSE);
-}
-
-reg: LDIND_I2 (locaddr) {
-	x86_widen_membase (s-&gt;code, tree-&gt;reg1, X86_EBP, tree-&gt;left-&gt;data.i,
TRUE, TRUE);
-}
-
-reg: LDIND_U2 (locaddr) {
-	x86_widen_membase (s-&gt;code, tree-&gt;reg1, X86_EBP, tree-&gt;left-&gt;data.i,
FALSE, TRUE);
-}
-
-reg: LDIND_I4 (locaddr) {
-	x86_mov_reg_membase (s-&gt;code, tree-&gt;reg1, X86_EBP, tree-&gt;left-&gt;data.i,
4);
-}
-
-reg: LDIND_U4 (locaddr) {
-	x86_mov_reg_membase (s-&gt;code, tree-&gt;reg1, X86_EBP, tree-&gt;left-&gt;data.i,
4);
-}
+reg: CONV_I4 (reg) {
+	if (tree-&gt;reg1 != tree-&gt;left-&gt;reg1)
+		x86_mov_reg_reg (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;reg1, 4);
+	PRINT_REG (&quot;CONV_I4&quot;, tree-&gt;left-&gt;reg1);
+} 
 
-reg: LDIND_I4 (ADDR_G) {
-	x86_mov_reg_mem (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.p, 4);
-}
 
 reg: MUL (reg, reg) {
 	if (tree-&gt;reg1 != tree-&gt;left-&gt;reg1)
@@ -474,11 +584,17 @@
 }
 
 reg: CEQ (reg, reg) {
-	x86_test_reg_reg (s-&gt;code, tree-&gt;left-&gt;reg1, tree-&gt;right-&gt;reg1);
+	x86_alu_reg_reg (s-&gt;code, X86_CMP, tree-&gt;left-&gt;reg1,
tree-&gt;right-&gt;reg1);
 	x86_set_reg (s-&gt;code, X86_CC_EQ, tree-&gt;reg1, TRUE);
 	x86_widen_reg (s-&gt;code, tree-&gt;reg1, tree-&gt;reg1, FALSE, FALSE);
 }
 
+reg: CLT (reg, reg) {
+	x86_alu_reg_reg (s-&gt;code, X86_CMP, tree-&gt;left-&gt;reg1,
tree-&gt;right-&gt;reg1);
+	x86_set_reg (s-&gt;code, X86_CC_LT, tree-&gt;reg1, TRUE);
+	x86_widen_reg (s-&gt;code, tree-&gt;reg1, tree-&gt;reg1, FALSE, FALSE);
+}
+
 reg: AND (reg, reg) {
 	if (tree-&gt;reg1 != tree-&gt;left-&gt;reg1)
 		x86_mov_reg_reg (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;reg1, 4);
@@ -948,11 +1064,6 @@
 	x86_push_imm (s-&gt;code, tree-&gt;left-&gt;data.i);
 }
 
-stmt: ARG (LDIND_OBJ (reg)) {
-      // fixme:
-      g_assert_not_reached ();
-}
-
 reg: CALL_I4 (CONST_I4) {
 	
 	x86_call_code (s-&gt;code, tree-&gt;left-&gt;data.p);
@@ -998,6 +1109,8 @@
 	if (tree-&gt;data.i)
 		x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, tree-&gt;data.i);
 
+	PRINT_REG (&quot;CONV_I4(VIRTUAL)&quot;, tree-&gt;reg1);
+
 	g_assert (tree-&gt;reg1 == X86_EAX);
 }
 
@@ -1063,7 +1176,7 @@
 	x86_mov_reg_imm (s-&gt;code, tree-&gt;reg2, *(gint32 *)(&amp;tree-&gt;data.p + 4));
 }
 
-lreg: CONV_I8 (CONST_I4) 1 {
+lreg: CONV_I8 (CONST_I4) {
 	x86_mov_reg_imm (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.i);
 
 	if (tree-&gt;left-&gt;data.i &gt;= 0)
@@ -1072,6 +1185,29 @@
 		x86_mov_reg_imm (s-&gt;code, tree-&gt;reg2, -1);		
 }
 
+lreg: CONV_I8 (reg) {
+	guint8 *i1;
+
+	if (tree-&gt;reg1 != tree-&gt;left-&gt;reg1)
+		x86_mov_reg_reg (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;reg1, 4);
+
+	// fixme: check if the branch8 is to the right location
+	x86_breakpoint (s-&gt;code);
+
+	x86_alu_reg_imm (s-&gt;code, X86_CMP, tree-&gt;left-&gt;reg1, 0);
+	x86_alu_reg_reg (s-&gt;code, X86_XOR, tree-&gt;reg2, tree-&gt;reg2);
+	x86_branch8 (s-&gt;code, X86_CC_GE, 4, TRUE);
+	i1 = s-&gt;code;
+	x86_mov_reg_imm (s-&gt;code, tree-&gt;reg2, -1); 
+	g_assert ((s-&gt;code - i1) == 4);
+	g_assert_not_reached ();
+}
+
+lreg: CONV_U8 (CONST_I4) 1 {
+	x86_mov_reg_imm (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.i);
+	x86_alu_reg_reg (s-&gt;code, X86_XOR, tree-&gt;reg2, tree-&gt;reg2);
+}
+
 stmt: STIND_I8 (locaddr, lreg) {
 	x86_mov_membase_reg (s-&gt;code, X86_EBP, tree-&gt;left-&gt;data.i,
 			     tree-&gt;right-&gt;reg1, 4);
@@ -1722,6 +1858,109 @@
 	}
 }
 
+# support for value types
+
+vtype: VTYPE
+
+vtype: LDIND_OBJ (reg) {
+	int treg = X86_EAX;
+	int offset = g_array_index (s-&gt;varinfo, MonoVarInfo,
tree-&gt;data.i).offset;
+	int size = g_array_index (s-&gt;varinfo, MonoVarInfo, tree-&gt;data.i).size;
+
+	if (tree-&gt;left-&gt;reg1 == X86_EAX)
+		treg = X86_ECX;
+
+	x86_push_reg (s-&gt;code, X86_EAX);
+	x86_push_reg (s-&gt;code, X86_EDX);
+	x86_push_reg (s-&gt;code, X86_ECX);
+
+	x86_push_imm (s-&gt;code, size);
+	x86_push_reg (s-&gt;code, tree-&gt;left-&gt;reg1);
+	x86_lea_membase (s-&gt;code, treg, X86_EBP, offset);
+	x86_push_reg (s-&gt;code, treg);
+	x86_call_code (s-&gt;code, MEMCOPY);
+	x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, 12);
+
+	x86_pop_reg (s-&gt;code, X86_ECX);
+	x86_pop_reg (s-&gt;code, X86_EDX);
+	x86_pop_reg (s-&gt;code, X86_EAX);
+}
+
+stmt: STIND_OBJ (reg, vtype) {
+	int treg = X86_EAX;
+	int offset = g_array_index (s-&gt;varinfo, MonoVarInfo,
tree-&gt;right-&gt;data.i).offset;
+	int size = g_array_index (s-&gt;varinfo, MonoVarInfo,
tree-&gt;right-&gt;data.i).size;
+
+	if (tree-&gt;left-&gt;reg1 == X86_EAX)
+		treg = X86_ECX;
+
+	x86_push_reg (s-&gt;code, X86_EAX);
+	x86_push_reg (s-&gt;code, X86_EDX);
+	x86_push_reg (s-&gt;code, X86_ECX);
+
+	x86_push_imm (s-&gt;code, size);
+	x86_lea_membase (s-&gt;code, treg, X86_EBP, offset);
+	x86_push_reg (s-&gt;code, treg);
+	x86_push_reg (s-&gt;code, tree-&gt;left-&gt;reg1);
+	x86_call_code (s-&gt;code, MEMCOPY);
+	x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, 12);
+
+	x86_pop_reg (s-&gt;code, X86_ECX);
+	x86_pop_reg (s-&gt;code, X86_EDX);
+	x86_pop_reg (s-&gt;code, X86_EAX);
+}
+
+stmt: ARG (vtype) {
+	int treg = X86_EAX;
+	int offset = g_array_index (s-&gt;varinfo, MonoVarInfo,
tree-&gt;left-&gt;data.i).offset;
+	int size = g_array_index (s-&gt;varinfo, MonoVarInfo,
tree-&gt;left-&gt;data.i).size;
+	int sa;
+	
+	sa = size + 3;
+	sa &amp;= ~3;
+
+	/* reserve space for the argument */
+	x86_alu_reg_imm (s-&gt;code, X86_SUB, X86_ESP, sa);
+
+	x86_push_reg (s-&gt;code, X86_EAX);
+	x86_push_reg (s-&gt;code, X86_EDX);
+	x86_push_reg (s-&gt;code, X86_ECX);
+
+	x86_push_imm (s-&gt;code, size);
+
+	x86_lea_membase (s-&gt;code, treg, X86_EBP, offset);
+	x86_push_reg (s-&gt;code, treg);
+
+	x86_lea_membase (s-&gt;code, treg, X86_ESP, 5*4);
+	x86_push_reg (s-&gt;code, treg);
+
+	x86_call_code (s-&gt;code, MEMCOPY);
+	x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, 12);
+
+	x86_pop_reg (s-&gt;code, X86_ECX);
+	x86_pop_reg (s-&gt;code, X86_EDX);
+	x86_pop_reg (s-&gt;code, X86_EAX);
+}
+
+stmt: RETV (vtype) {
+	int treg = X86_EAX;
+	int offset = g_array_index (s-&gt;varinfo, MonoVarInfo,
tree-&gt;left-&gt;data.i).offset;
+	int size = g_array_index (s-&gt;varinfo, MonoVarInfo,
tree-&gt;left-&gt;data.i).size;
+
+	x86_push_imm (s-&gt;code, size);
+	x86_lea_membase (s-&gt;code, treg, X86_EBP, offset);
+	x86_push_reg (s-&gt;code, treg);
+	x86_push_membase (s-&gt;code, X86_EBP, 8);
+
+	x86_call_code (s-&gt;code, MEMCOPY);
+	x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, 12);
+
+	if (!tree-&gt;last_instr) {
+		tree-&gt;is_jump = 1;
+		x86_jump32 (s-&gt;code, s-&gt;epilog - 5);      
+	}
+}
+
 %% 
 
 #include &quot;jit.h&quot;
@@ -1776,3 +2015,18 @@
 	return mono_ctree_new (mp, op, NULL, NULL);
 }
 
+#ifdef DEBUG
+void *
+MEMCOPY (void *dest, const void *src, size_t n)
+{
+	int i, l = n;
+
+	printf (&quot;MEMCPY(%p to %p [%d]) &quot;, src, dest, n);
+
+	for (i = 0; i &lt; l; i++)
+		printf (&quot;%02x &quot;, *((guint8 *)src + i));
+	printf (&quot;\n&quot;);
+	
+	return memcpy (dest, src, n);
+}
+#endif
Index: mono/metadata/class.c
===================================================================
RCS file: /cvs/public/mon_/mono/metadata/class.c,v
retrieving revision 1.52
diff -u -r1.52 class.c
--- mono/metadata/class.c	2001/11/14 15:18:56	1.52
+++ mono/metadata/class.c	2001/11/15 11:07:53
@@ -946,6 +946,7 @@
 		class = mono_class_create_from_typespec (image, type_token);
 		break;
 	default:
+		g_warning (&quot;unknown token type %x&quot;, type_token &amp; 0xff000000);
 		g_assert_not_reached ();
 	}
 	
Index: mono/tests/Makefile.am
===================================================================
RCS file: /cvs/public/mono/mono/tests/Makefile.am,v
retrieving revision 1.21
diff -u -r1.21 Makefile.am
--- mono/tests/Makefile.am	2001/11/14 15:18:56	1.21
+++ mono/tests/Makefile.am	2001/11/15 11:07:53
@@ -1,6 +1,6 @@
 
 TEST_PROG=../interpreter/mint
-JITTEST_PROG=../jit/testjit
+JITTEST_PROG=../jit/mono
 
 CSC=csc
 




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="002107.html">[Mono-list] Mono Status
</A></li>
	<LI> Next message: <A HREF="002093.html">[Mono-list] Info on all Mono related projects.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2092">[ date ]</a>
              <a href="thread.html#2092">[ thread ]</a>
              <a href="subject.html#2092">[ subject ]</a>
              <a href="author.html#2092">[ author ]</a>
         </LI>
       </UL>
</body></html>
