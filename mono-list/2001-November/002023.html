<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] jit patch: array support
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:dietmar%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="002022.html">
   <LINK REL="Next"  HREF="002024.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] jit patch: array support
   </H1>
    <B>Dietmar Maurer
    </B> 
    <A HREF="mailto:dietmar%40ximian.com"
       TITLE="[Mono-list] jit patch: array support">dietmar@ximian.com
       </A><BR>
    <I>09 Nov 2001 11:25:03 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="002022.html">[Mono-list] Make test
</A></li>
        <LI> Next message: <A HREF="002024.html">[Mono-list] patch: more jit work + bug fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2023">[ date ]</a>
              <a href="thread.html#2023">[ thread ]</a>
              <a href="subject.html#2023">[ subject ]</a>
              <a href="author.html#2023">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Index: mono/jit/ChangeLog
===================================================================
RCS file: /cvs/public/mono/mono/jit/ChangeLog,v
retrieving revision 1.37
diff -u -r1.37 ChangeLog
--- mono/jit/ChangeLog	2001/11/08 21:38:32	1.37
+++ mono/jit/ChangeLog	2001/11/09 06:26:26
@@ -1,3 +1,14 @@
+2001-11-09  Dietmar Maurer  &lt;<A HREF="mailto:dietmar@ximian.com">dietmar@ximian.com</A>&gt;
+
+	* testjit.c (mono_analyze_stack): finished array support
+
+2001-11-08  Dietmar Maurer  &lt;<A HREF="mailto:dietmar@ximian.com">dietmar@ximian.com</A>&gt;
+
+	* testjit.c (MAKE_STELEM, MAKE_LDELEM): we build a tree which
+	represents the address of the element. This way we can emit highly
+	optimized x86 instructions to access ellements (using base+index+offset
+	adressing mode)
+
 2001-11-07  Miguel de Icaza  &lt;<A HREF="mailto:miguel@ximian.com">miguel@ximian.com</A>&gt;
 
 	* mempool.c: Include string.h to kill warning.
Index: mono/jit/emit-x86.c
===================================================================
RCS file: /cvs/public/mono/mono/jit/emit-x86.c,v
retrieving revision 1.15
diff -u -r1.15 emit-x86.c
--- mono/jit/emit-x86.c	2001/11/08 21:38:32	1.15
+++ mono/jit/emit-x86.c	2001/11/09 06:26:27
@@ -37,7 +37,7 @@
 	if (method-&gt;signature-&gt;hasthis) {
 		o = *((MonoObject **)ebp);
 		class = o-&gt;klass;
-		printf (&quot;%p[%s.%s], &quot;, o, class-&gt;name_space, class-&gt;name);
+		printf (&quot;this:%p[%s.%s], &quot;, o, class-&gt;name_space, class-&gt;name);
 		ebp += sizeof (gpointer);
 	}
 
@@ -431,8 +431,11 @@
 		break;
 	}
 
+	//printf (&quot;RALLOC START %d %p %d\n&quot;,  tree-&gt;op, rs-&gt;free_mask, goal);
+
 	for (i = 0; nts [i]; i++)
-		tree_allocate_regs (kids [i], nts [i], rs);
+		if (kids [i] != tree) /* don't allocate regs for chain rules */
+			tree_allocate_regs (kids [i], nts [i], rs);
 
 	for (i = 0; nts [i]; i++) {
 		if (kids [i] != tree) { /* we do not free register for chain rules */
@@ -448,7 +451,6 @@
 			g_warning (&quot;register allocation failed %d 0x%08x 0x%08x\n&quot;,  tree-&gt;reg1, rs-&gt;free_mask, tree-&gt;exclude_mask);
 			g_assert_not_reached ();
 		}
-
 		break;
 
 	case MB_NTERM_lreg:
@@ -464,15 +466,17 @@
 	case MB_NTERM_freg:
 		/* fixme: allocate floating point registers */
 		break;
-
-		/*
+      
 	case MB_NTERM_addr:
 		if (tree-&gt;op == MB_TERM_ADD) {
 			tree-&gt;reg1 = mono_regset_alloc_reg (rs, tree-&gt;left-&gt;reg1, tree-&gt;exclude_mask);
 			tree-&gt;reg2 = mono_regset_alloc_reg (rs, tree-&gt;right-&gt;reg1, tree-&gt;exclude_mask);
 		}
+		if (tree-&gt;op == MB_TERM_CALL_I4) {
+			tree-&gt;reg1 = mono_regset_alloc_reg (rs, tree-&gt;left-&gt;reg1, tree-&gt;exclude_mask);
+		}
 		break;
-		*/
+		
 	case MB_NTERM_base:
 		if (tree-&gt;op == MB_TERM_ADD) {
 			tree-&gt;reg1 = mono_regset_alloc_reg (rs, tree-&gt;left-&gt;reg1, tree-&gt;exclude_mask);
@@ -490,6 +494,7 @@
 		/* do nothing */
 	}
 
+	//printf (&quot;RALLOC END %d %p\n&quot;,  tree-&gt;op, rs-&gt;free_mask);
 	tree-&gt;emit = mono_burg_func [ern];
 }
 
@@ -507,6 +512,7 @@
 			//printf (&quot;AREGSTART %d:%d %p\n&quot;, i, j, cfg-&gt;rs-&gt;free_mask);
 			tree_allocate_regs (t1, 1, cfg-&gt;rs);
 			//printf (&quot;AREGENDT %d:%d %p\n&quot;, i, j, cfg-&gt;rs-&gt;free_mask);
+			g_assert (cfg-&gt;rs-&gt;free_mask == 0xffffffff);
 		}
 	}
 }
@@ -610,7 +616,6 @@
 	g_assert (!(method-&gt;flags &amp; METHOD_ATTRIBUTE_PINVOKE_IMPL));
 
 	//g_assert (!method-&gt;addr);
-
 	printf (&quot;Start JIT compilation %p %p\n&quot;, method, method-&gt;addr);
 	printf (&quot;Start JIT compilation of %s.%s:%s\n&quot;, method-&gt;klass-&gt;name_space,
 		method-&gt;klass-&gt;name, method-&gt;name);
Index: mono/jit/testjit.c
===================================================================
RCS file: /cvs/public/mono/mono/jit/testjit.c,v
retrieving revision 1.39
diff -u -r1.39 testjit.c
--- mono/jit/testjit.c	2001/11/08 21:38:32	1.39
+++ mono/jit/testjit.c	2001/11/09 06:26:27
@@ -10,6 +10,7 @@
 #include &lt;config.h&gt;
 #include &lt;glib.h&gt;
 #include &lt;stdlib.h&gt;
+#include &lt;stdarg.h&gt;
 #include &lt;string.h&gt;
 
 #include &lt;mono/metadata/assembly.h&gt;
@@ -91,8 +92,13 @@
 case CEE_##name: {                                                            \
 	++ip;                                                                 \
 	sp -= 2;                                                              \
-	t1 = mono_ctree_new (mp, MB_TERM_LDELEMA, sp [0], sp [1]);            \
-	t1-&gt;data.i = s;                                                       \
+        t1 = mono_ctree_new_leaf (mp, MB_TERM_CONST_I4);                      \
+        t1-&gt;data.i = s;                                                       \
+        t1 = mono_ctree_new (mp, MB_TERM_MUL, sp [1], t1);                    \
+        t2 = mono_ctree_new_leaf (mp, MB_TERM_CONST_I4);                      \
+        t2-&gt;data.i = G_STRUCT_OFFSET (MonoArray, vector);                     \
+        t2 = mono_ctree_new (mp, MB_TERM_ADD, sp [0], t2);                    \
+	t1 = mono_ctree_new (mp, MB_TERM_ADD, t1, t2);                        \
 	t1 = mono_ctree_new (mp, op, t1, NULL);                               \
 	PUSH_TREE (t1, svt);                                                  \
 	break;                                                                \
@@ -106,7 +112,8 @@
 	ADD_TREE (t1);                                                        \
 	break;                                                                \
 }
-	
+
+/*	
 #define MAKE_STELEM(name, op, s)                                              \
 case CEE_##name: {                                                            \
 	++ip;                                                                 \
@@ -117,6 +124,23 @@
 	ADD_TREE (t1);                                                        \
 	break;                                                                \
 }
+*/
+
+#define MAKE_STELEM(name, op, s)                                              \
+case CEE_##name: {                                                            \
+	++ip;                                                                 \
+	sp -= 3;                                                              \
+        t1 = mono_ctree_new_leaf (mp, MB_TERM_CONST_I4);                      \
+        t1-&gt;data.i = s;                                                       \
+        t1 = mono_ctree_new (mp, MB_TERM_MUL, sp [1], t1);                    \
+        t2 = mono_ctree_new_leaf (mp, MB_TERM_CONST_I4);                      \
+        t2-&gt;data.i = G_STRUCT_OFFSET (MonoArray, vector);                     \
+        t2 = mono_ctree_new (mp, MB_TERM_ADD, sp [0], t2);                    \
+	t1 = mono_ctree_new (mp, MB_TERM_ADD, t1, t2);                        \
+	t1 = mono_ctree_new (mp, op, t1, sp [2]);                             \
+	ADD_TREE (t1);                                                        \
+	break;                                                                \
+}
 	
 /* Whether to dump the assembly code after genreating it */
 gboolean mono_jit_dump_asm = FALSE;
@@ -142,6 +166,24 @@
 	return g_malloc0 (size);
 } 
 
+static int
+map_store_svt_type (int svt)
+{
+	switch (svt) {
+	case VAL_I32:
+	case VAL_POINTER:
+		return MB_TERM_STIND_I4;
+	case VAL_I64:
+		return MB_TERM_STIND_I8;
+	case VAL_DOUBLE:
+		return MB_TERM_STIND_R8;
+	default:
+		g_assert_not_reached ();
+	}
+
+	return 0;
+}
+
 /**
  * map_stind_type:
  * @type: the type to map
@@ -172,6 +214,7 @@
 	case MONO_TYPE_STRING:
 	case MONO_TYPE_PTR:
 	case MONO_TYPE_SZARRAY:
+	case MONO_TYPE_ARRAY:    
 		return MB_TERM_STIND_I4;
 	case MONO_TYPE_I8:
 	case MONO_TYPE_U8:
@@ -244,6 +287,7 @@
 	case MONO_TYPE_STRING:
 	case MONO_TYPE_PTR:
 	case MONO_TYPE_SZARRAY:
+	case MONO_TYPE_ARRAY:    
 		*svt = VAL_POINTER;
 		return MB_TERM_LDIND_U4;
 	case MONO_TYPE_I8:
@@ -525,6 +569,7 @@
 		t-&gt;svt = VAL_POINTER;
 		return t;
 	default:
+		g_warning (&quot;unknown tree opcode %d&quot;, s-&gt;op);
 		g_assert_not_reached ();
 	}
 
@@ -542,38 +587,38 @@
 	case MB_TERM_STIND_I1:
 	case MB_TERM_LDIND_I1:
 		t = ctree_dup_address (mp, s-&gt;left);
-		t-&gt;svt = VAL_I32;
 		t = mono_ctree_new (mp, MB_TERM_LDIND_I1, t, NULL);
+		t-&gt;svt = VAL_I32;
 		break;
 	case MB_TERM_STIND_I2:
 	case MB_TERM_LDIND_I2:
 		t = ctree_dup_address (mp, s-&gt;left);
-		t-&gt;svt = VAL_I32;
 		t = mono_ctree_new (mp, MB_TERM_LDIND_I2, t, NULL);
+		t-&gt;svt = VAL_I32;
 		break;
 	case MB_TERM_STIND_I4:
 	case MB_TERM_LDIND_I4:
 		t = ctree_dup_address (mp, s-&gt;left);
-		t-&gt;svt = VAL_I32;
 		t = mono_ctree_new (mp, MB_TERM_LDIND_I4, t, NULL);
+		t-&gt;svt = VAL_I32;
 		break;
 	case MB_TERM_STIND_I8:
 	case MB_TERM_LDIND_I8:
 		t = ctree_dup_address (mp, s-&gt;left);
-		t-&gt;svt = VAL_I64;
 		t = mono_ctree_new (mp, MB_TERM_LDIND_I8, t, NULL);
+		t-&gt;svt = VAL_I64;
 		break;
 	case MB_TERM_STIND_R4:
 	case MB_TERM_LDIND_R4:
 		t = ctree_dup_address (mp, s-&gt;left);
-		t-&gt;svt = VAL_DOUBLE;
 		t = mono_ctree_new (mp, MB_TERM_LDIND_R4, t, NULL);
+		t-&gt;svt = VAL_DOUBLE;
 		break;
 	case MB_TERM_STIND_R8:
 	case MB_TERM_LDIND_R8:
 		t = ctree_dup_address (mp, s-&gt;left);
-		t-&gt;svt = VAL_DOUBLE;
 		t = mono_ctree_new (mp, MB_TERM_LDIND_R8, t, NULL);
+		t-&gt;svt = VAL_DOUBLE;
 		break;
 	default: {
 			g_assert (s-&gt;svt != VAL_UNKNOWN);
@@ -589,20 +634,8 @@
 			t = mono_ctree_new_leaf (mp, MB_TERM_ADDR_L);
 			t-&gt;data.i = vnum;
 		       
-			switch (s-&gt;svt) {
-			case VAL_I32:
-			case VAL_POINTER:
-				t = mono_ctree_new (mp, MB_TERM_STIND_I4, t, s);
-				break;
-			case VAL_I64:
-				t = mono_ctree_new (mp, MB_TERM_STIND_I8, t, s);
-				break;
-			case VAL_DOUBLE:
-				t = mono_ctree_new (mp, MB_TERM_STIND_R8, t, s);
-				break;
-			default:
-				g_assert_not_reached ();
-			}
+			t = mono_ctree_new (mp, map_store_svt_type (s-&gt;svt), t, s);
+			t-&gt;svt = s-&gt;svt;
 		}
 	}
 
@@ -1055,6 +1088,70 @@
 	return NULL;
 }
 
+/**
+ * ves_array_element_address:
+ * @this: a pointer to the array object
+ *
+ * Returns: the address of an array element.
+ */
+static gpointer 
+ves_array_element_address (MonoArray *this, ...)
+{
+	MonoClass *class;
+	va_list ap;
+	int i, ind, esize;
+	gpointer ea;
+
+	g_assert (this != NULL);
+
+	va_start(ap, this);
+
+	class = this-&gt;obj.klass;
+
+	ind = va_arg(ap, int) - this-&gt;bounds [0].lower_bound;
+	for (i = 1; i &lt; class-&gt;rank; i++) {
+		ind = ind*this-&gt;bounds [i].length + va_arg(ap, int) -
+			this-&gt;bounds [i].lower_bound;;
+	}
+
+	esize = mono_array_element_size (class);
+	ea = (gpointer*)((char*)this-&gt;vector + (ind * esize));
+
+	va_end(ap);
+
+	return ea;
+}
+
+static MonoArray *
+mono_array_new_va (MonoMethod *cm, ...)
+{
+	va_list ap;
+	guint32 *lengths;
+	guint32 *lower_bounds;
+	int pcount = cm-&gt;signature-&gt;param_count;
+	int rank = cm-&gt;klass-&gt;rank;
+	int i, d;
+
+	va_start (ap, cm);
+
+	lengths = alloca (sizeof (guint32) * pcount);
+	for (i = 0; i &lt; pcount; ++i)
+		lengths [i] = d = va_arg(ap, int);
+
+	if (rank == pcount) {
+		/* Only lengths provided. */
+		lower_bounds = NULL;
+	} else {
+		g_assert (pcount == (rank * 2));
+		/* lower bounds are first. */
+		lower_bounds = lengths;
+		lengths += rank;
+	}
+	va_end(ap);
+
+	return mono_array_new_full (cm-&gt;klass, lengths, lower_bounds);
+}
+
 #define ADD_TREE(t)     do { g_ptr_array_add (forest, (t)); } while (0)
 #define PUSH_TREE(t,k)  do { *sp = t; sp++; t-&gt;svt = k; } while (0)
 
@@ -1089,7 +1186,7 @@
 	MonoMethodSignature *signature;
 	MonoImage *image;
 	MonoValueType svt;
-	MBTree **sp, **stack, *t1, *t2;
+	MBTree **sp, **stack, **arg_sp, *t1, *t2;
 	register const unsigned char *ip, *end;
 	GPtrArray *forest;
 	int i, j, depth, repeat_count;
@@ -1498,16 +1595,13 @@
 
 			break;
 		}
-		case CEE_NEWOBJ:
-		case CEE_CALL: 
-		case CEE_CALLVIRT: {
+		case CEE_NEWOBJ: {
 			MonoMethodSignature *csig;
 			MonoMethod *cm;
-			MBTree *nobj, *this = NULL;
+			MBTree *this = NULL;
 			guint32 token;
-			int i, nargs, align, size, args_size = 0;
-			int virtual = *ip == CEE_CALLVIRT;
-			int newobj = *ip == CEE_NEWOBJ;
+			int i, align, size, args_size = 0;
+			int newarr = FALSE;
 
 			++ip;
 			token = read32 (ip);
@@ -1515,114 +1609,208 @@
 
 			cm = mono_get_method (image, token, NULL);
 			g_assert (cm);
+			g_assert (!strcmp (cm-&gt;name, &quot;.ctor&quot;));
 			
-			if ((cm-&gt;flags &amp; METHOD_ATTRIBUTE_FINAL) ||
-			    !(cm-&gt;flags &amp; METHOD_ATTRIBUTE_VIRTUAL))
-				virtual = 0;
-
-			// fixme: virtual does not work
-			//virtual = 0;
-
 			csig = cm-&gt;signature;
 			g_assert (csig-&gt;call_convention == MONO_CALL_DEFAULT);
+			g_assert (csig-&gt;hasthis);
+			
+			arg_sp = sp -= csig-&gt;param_count;
 
-			if (newobj) {
-				int n;
+			if (cm-&gt;klass-&gt;parent == mono_defaults.array_class) {
 
-				for (i = 0; i &lt; csig-&gt;param_count; i++)
-					sp [-i] = sp [-i - 1];
-				
-				n = arch_allocate_var (cfg, sizeof (gpointer), sizeof (gpointer), 
-						       MONO_TEMPVAR, VAL_UNKNOWN);
-				
-				nobj = mono_ctree_new_leaf (mp, MB_TERM_NEWOBJ);
-				nobj-&gt;data.p = cm-&gt;klass;
-				nobj-&gt;svt = VAL_POINTER;
-
-				nobj = ctree_create_store (mp, MB_TERM_ADDR_L, nobj, 
-							   &amp;cm-&gt;klass-&gt;this_arg, (gpointer)n);
-				ADD_TREE (nobj);
-				sp [-i] =  ctree_create_dup (mp, nobj);
-				sp++;
-			} 
-			
-			nargs = csig-&gt;param_count;
-			if (csig-&gt;hasthis || virtual || newobj) {
-				nargs++;
-				sp = sp - nargs;
-				this =  *sp;
+				newarr = TRUE;
+				this = mono_ctree_new_leaf (mp, MB_TERM_CONST_I4);
+				this-&gt;data.p = cm;
+
 			} else {
-				sp = sp - nargs;
+				
+				this = mono_ctree_new_leaf (mp, MB_TERM_NEWOBJ);
+				this-&gt;data.p = cm-&gt;klass;
+				this-&gt;svt = VAL_POINTER;
+
+				t1 = mono_store_tree (cfg, -1, this, &amp;this);
+				ADD_TREE (t1);
+
 			}
 
-			//printf (&quot;MINFO %s.%s::%s %d %d\n&quot;, cm-&gt;klass-&gt;name_space, 
-			//cm-&gt;klass-&gt;name, cm-&gt;name, cm-&gt;flags &amp; METHOD_ATTRIBUTE_VIRTUAL, virtual);
- 
-			if (virtual) {
-				t2 = ctree_create_dup (mp, this);
-			       
-				if (!cm-&gt;klass-&gt;metadata_inited)
-					mono_class_metadata_init (cm-&gt;klass);
+			for (i = csig-&gt;param_count - 1; i &gt;= 0; i--) {
+				t1 = mono_ctree_new (mp, MB_TERM_ARG, arg_sp [i], NULL);	
+				ADD_TREE (t1);
+				size = mono_type_size (cm-&gt;signature-&gt;params [i], &amp;align);
+				args_size += (size + 3) &amp; ~3;
+			}
 
-				if (cm-&gt;klass-&gt;flags &amp; TYPE_ATTRIBUTE_INTERFACE)
-					t2 = mono_ctree_new (mp, MB_TERM_INTF_ADDR, t2, NULL);
-				else 
-					t2 = mono_ctree_new (mp, MB_TERM_VFUNC_ADDR, t2, NULL);
-	 
-				t2-&gt;data.m = cm;
+			t1 = mono_ctree_new (mp, MB_TERM_ARG, this, NULL);	
+			ADD_TREE (t1);
+			args_size += sizeof (gpointer);
+
+			if (newarr) {
+
+				t2 = mono_ctree_new_leaf (mp, MB_TERM_CONST_I4);
+				t2-&gt;data.p = mono_array_new_va;
+
+				t1 = mono_ctree_new (mp, MB_TERM_CALL_I4, t2, NULL);
+				t1-&gt;data.i = args_size;
+				t1-&gt;svt = VAL_I32;
+
 			} else {
+				
 				if (!cm-&gt;addr)
 					cm-&gt;addr = arch_create_simple_jit_trampoline (cm);
 
 				t2 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_G);
 				t2-&gt;data.p = (char *)cm + G_STRUCT_OFFSET (MonoMethod, addr);
+				t2 = mono_ctree_new (mp, MB_TERM_LDIND_I4, t2, NULL);
+			}
+
+			t1 = mono_ctree_new (mp, map_call_type (csig-&gt;ret, &amp;svt), t2, NULL);
+			t1-&gt;data.i = args_size;
+			t1-&gt;svt = svt;
+
+			if (newarr) {
+				
+				t1 = mono_store_tree (cfg, -1, t1, &amp;t2);
+				ADD_TREE (t1);
+				PUSH_TREE (t2, t2-&gt;svt);
+
+			} else {
 
+				ADD_TREE (t1);			
+				t1 = ctree_create_dup (mp, this);		
+				PUSH_TREE (t1, t1-&gt;svt);
 			}
+			break;
+		}
+		case CEE_CALL: 
+		case CEE_CALLVIRT: {
+			MonoMethodSignature *csig;
+			MonoMethod *cm;
+			MBTree *this = NULL;
+			guint32 token;
+			int i, align, size, args_size = 0;
+			int virtual = *ip == CEE_CALLVIRT;
+			gboolean array_set = FALSE;
+			gboolean array_get = FALSE;
+			int nargs;
 
-			if (nargs) {
+			++ip;
+			token = read32 (ip);
+			ip += 4;
 
-#ifdef ARCH_ARGS_RIGHT_TO_LEFT
-				for (i = nargs - 1; i &gt;= 0; i--) {
-#else
-				for (i = 0; i &lt; nargs; i++) {
-#endif
-					t1 = mono_ctree_new (mp, MB_TERM_ARG, sp [i], NULL);	
-					ADD_TREE (t1);
+			cm = mono_get_method (image, token, NULL);
+			g_assert (cm);
+			
+			if ((cm-&gt;flags &amp; METHOD_ATTRIBUTE_FINAL) ||
+			    !(cm-&gt;flags &amp; METHOD_ATTRIBUTE_VIRTUAL))
+				virtual = 0;
 
-					if (!i &amp;&amp; this)
-						size = mono_type_size (&amp;cm-&gt;klass-&gt;this_arg, &amp;align);
-					else
-						size = mono_type_size (cm-&gt;signature-&gt;params [i - (this != NULL)], &amp;align);
+			csig = cm-&gt;signature;
+			g_assert (csig-&gt;call_convention == MONO_CALL_DEFAULT);
+			g_assert (!virtual || csig-&gt;hasthis);
 
-					// fixme: does this really work ?
-					args_size += (size + 3) &amp; ~3;
-				}
+			nargs = csig-&gt;param_count;
+			arg_sp = sp -= nargs;
+			
+			if ((cm-&gt;iflags &amp; METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) &amp;&amp;
+			    (cm-&gt;klass-&gt;parent == mono_defaults._rray_class)) {
+				if (!strcmp (cm-&gt;name, &quot;Set&quot;)) { 
+					array_set = TRUE;
+					nargs--;
+				} else if (!strcmp (cm-&gt;name, &quot;Get&quot;)) 
+					array_get = TRUE;
 			}
 
-			t1 = mono_ctree_new (mp, map_call_type (csig-&gt;ret, &amp;svt), t2, NULL);
-			t1-&gt;data.i = args_size;
-			t1-&gt;svt = svt;
+			for (i = nargs - 1; i &gt;= 0; i--) {
+				t1 = mono_ctree_new (mp, MB_TERM_ARG, arg_sp [i], NULL);	
+				ADD_TREE (t1);
+				size = mono_type_size (cm-&gt;signature-&gt;params [i], &amp;align);
+				args_size += (size + 3) &amp; ~3;
+			}
 
-			if (csig-&gt;ret-&gt;type != MONO_TYPE_VOID) {
-				int n;
+			if (csig-&gt;hasthis) {
+				this = *(--sp);
+				t1 = mono_ctree_new (mp, MB_TERM_ARG, this, NULL);	
+				ADD_TREE (t1);
+				args_size += sizeof (gpointer);
+			}
 
-				size = mono_type_size (csig-&gt;ret, &amp;align);
-				n = arch_allocate_var (cfg, size, align, MONO_TEMPVAR, VAL_UNKNOWN);
+			if (array_get) {
+				int size, align, vnum;
 				
-				t2 = ctree_create_store (mp, MB_TERM_ADDR_L, t1, csig-&gt;ret, (gpointer)n);
-				ADD_TREE (t2);
+				t2 = mono_ctree_new_leaf (mp, MB_TERM_CONST_I4);
+				t2-&gt;data.p = ves_array_element_address;
 
-				t1 = ctree_create_dup (mp, t2);
-				PUSH_TREE (t1, svt);
+				t1 = mono_ctree_new (mp, MB_TERM_CALL_I4, t2, NULL);
+				t1-&gt;data.i = args_size;
+
+				t1 = mono_ctree_new (mp, map_ldind_type (csig-&gt;ret, &amp;svt), t1, NULL);
+				t1-&gt;svt = svt;		
+
+				mono_get_val_sizes (t1-&gt;svt, &amp;size, &amp;align);
+				vnum = arch_allocate_var (cfg, size, align, MONO_TEMPVAR, svt);
+
+				t2 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_L);
+				t2-&gt;data.i = vnum;
+				t1 = mono_ctree_new (mp, map_store_svt_type (svt), t2, t1);
+				t1-&gt;svt = svt;
+
+				ADD_TREE (t1);
+				t1 = ctree_create_dup (mp, t1);
+				PUSH_TREE (t1, t1-&gt;svt);
+
+			} else if (array_set) {
+
+				t2 = mono_ctree_new_leaf (mp, MB_TERM_CONST_I4);
+				t2-&gt;data.p = ves_array_element_address;
+
+				t1 = mono_ctree_new (mp, MB_TERM_CALL_I4, t2, NULL);
+				t1-&gt;data.i = args_size;
+
+				t1 = mono_ctree_new (mp, map_stind_type (csig-&gt;params [nargs]), t1, arg_sp [nargs]);
+				ADD_TREE (t1);
+			
 			} else {
-				if (newobj) {
-					ADD_TREE (t1);			
-					t1 = ctree_create_dup (mp, nobj);		
-					PUSH_TREE (t1, t1-&gt;svt);
+
+				if (virtual) {
+				
+					t2 = ctree_create_dup (mp, this);
+			       
+					if (!cm-&gt;klass-&gt;metadata_inited)
+						mono_class_metadata_init (cm-&gt;klass);
+
+					if (cm-&gt;klass-&gt;flags &amp; TYPE_ATTRIBUTE_INTERFACE)
+						t2 = mono_ctree_new (mp, MB_TERM_INTF_ADDR, t2, NULL);
+					else 
+						t2 = mono_ctree_new (mp, MB_TERM_VFUNC_ADDR, t2, NULL);
+	 
+					t2-&gt;data.m = cm;
+
 				} else {
-					ADD_TREE (t1);
+				
+					if (!cm-&gt;addr)
+						cm-&gt;addr = arch_create_simple_jit_trampoline (cm);
+				
+					t2 = mono_ctree_new_leaf (mp, MB_TERM_ADDR_G);
+					t2-&gt;data.p = (char *)cm + G_STRUCT_OFFSET (MonoMethod, addr);
+					t2 = mono_ctree_new (mp, MB_TERM_LDIND_I4, t2, NULL);
 				}
+
+				t1 = mono_ctree_new (mp, map_call_type (csig-&gt;ret, &amp;svt), t2, NULL);
+				t1-&gt;data.i = args_size;
+				t1-&gt;svt = svt;
+
+				if (csig-&gt;ret-&gt;type != MONO_TYPE_VOID) {
+
+					t1 = mono_store_tree (cfg, -1, t1, &amp;t2);
+					ADD_TREE (t1);
+					PUSH_TREE (t2, t2-&gt;svt);
+					
+				} else
+					ADD_TREE (t1);
+   
 			}
+
 			break;
 		}
 		case CEE_ISINST:
@@ -2091,8 +2279,22 @@
 
 
 	} while (repeat);
+
+	//printf (&quot;FINISHED\n&quot;);
+}
+
+/* this function is never called */
+static void 
+ves_array_set (MonoArray *this, ...)
+{
+	g_assert_not_reached ();
+}
 
-		//printf (&quot;FINISHED\n&quot;);
+/* this function is never called */
+static void 
+ves_array_get (MonoArray *this, ...)
+{
+	g_assert_not_reached ();
 }
 	
 /**
@@ -2212,6 +2414,8 @@
 
 	mono_init ();
 	mono_init_icall ();
+	mono_add_internal_call (&quot;__array_Set&quot;, ves_array_set);
+	mono_add_internal_call (&quot;__array_Get&quot;, ves_array_get);
 
 	assembly = mono_assembly_open (file, NULL, NULL);
 	if (!assembly){
Index: mono/jit/x86.brg
===================================================================
RCS file: /cvs/public/mono/mono/jit/x86.brg,v
retrieving revision 1.32
diff -u -r1.32 x86.brg
--- mono/jit/x86.brg	2001/11/08 21:38:32	1.32
+++ mono/jit/x86.brg	2001/11/09 06:26:27
@@ -26,8 +26,6 @@
 #define MBCOST_DATA  MonoFlowGraph
 #define MBALLOC_STATE mono_mempool_alloc (data-&gt;mp, sizeof (MBState))
 
-#define ARCH_ARGS_RIGHT_TO_LEFT
-
 typedef enum {
 	AMImmediate       = 0,  // ptr
 	AMBase            = 1,  // V[REG]  
@@ -121,7 +119,7 @@
 %term CEQ
 %term CONV_I4 CONV_I1 CONV_I2 CONV_I8 CONV_R8
 %term INTF_ADDR VFUNC_ADDR NOP BOX NEWARR NEWOBJ POP 
-%term LDLEN LDELEMA
+%term LDLEN
 
 #
 # we start at stmt
@@ -268,6 +266,29 @@
 	}
 }
 
+reg: LDIND_U4 (addr) {
+	switch (tree-&gt;left-&gt;data.ainfo.amode) {
+
+	case AMImmediate:
+		x86_mov_reg_mem (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.ainfo.offset, 4);
+		break;
+
+	case AMBase:
+		x86_mov_reg_membase (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.ainfo.basereg, 
+				     tree-&gt;left-&gt;data.ainfo.offset, 4);
+		break;		
+	case AMIndex:
+		x86_mov_reg_memindex (s-&gt;code, tree-&gt;reg1, X86_NOBASEREG, tree-&gt;left-&gt;data.ainfo.offset,
+				      tree-&gt;left-&gt;data.ainfo.indexreg, tree-&gt;left-&gt;data.ainfo.shift, 4);
+		break;		
+	case AMBaseIndex:
+		x86_mov_reg_memindex (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;data.ainfo.basereg, 
+				      tree-&gt;left-&gt;data.ainfo.offset, tree-&gt;left-&gt;data.ainfo.indexreg, 
+				      tree-&gt;left-&gt;data.ainfo.shift, 4);
+		break;		
+	}
+}
+
 locaddr: ADDR_L 10 {
 	tree-&gt;data.i = g_array_index (s-&gt;varinfo, MonoVarInfo, tree-&gt;data.i).offset;
 }
@@ -493,8 +514,23 @@
 }
 
 reg: BOX (reg) {
-	// fixme: implement me
-	//g_assert_not_reached ();
+	if (tree-&gt;reg1 != X86_EAX)
+		x86_push_reg (s-&gt;code, X86_EAX);
+	x86_push_reg (s-&gt;code, X86_ECX);
+	x86_push_reg (s-&gt;code, X86_EDX);
+
+	x86_push_reg (s-&gt;code, tree-&gt;left-&gt;reg1); //save it to memory
+	x86_push_reg (s-&gt;code, X86_ESP); // push address to saved value
+	x86_push_imm (s-&gt;code, tree-&gt;data.p);
+	x86_call_code (s-&gt;code, mono_value_box);
+	x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, 12);
+
+	x86_pop_reg (s-&gt;code, X86_EDX);
+	x86_pop_reg (s-&gt;code, X86_ECX);
+	if (tree-&gt;reg1 != X86_EAX) {
+		x86_mov_reg_reg (s-&gt;code, tree-&gt;reg1, X86_EAX, 4);
+		x86_pop_reg (s-&gt;code, X86_EAX);
+	}
 }
 
 # array support
@@ -505,12 +541,11 @@
 			     G_STRUCT_OFFSET (MonoArrayBounds, length), 4);
 }
 
-reg: LDELEMA (reg, reg) {
-	x86_mov_reg_membase (s-&gt;code, tree-&gt;reg1, tree-&gt;left-&gt;reg1, 
-			     G_STRUCT_OFFSET (MonoArray, vector), 4);
-	x86_imul_reg_reg_imm (s-&gt;code, tree-&gt;right-&gt;reg1, tree-&gt;right-&gt;reg1, tree-&gt;data.i);
-	x86_alu_reg_reg (s-&gt;code, X86_ADD, tree-&gt;reg1, tree-&gt;right-&gt;reg1);
-}
+#reg: LDELEMA (reg, reg) {
+#	x86_imul_reg_reg_imm (s-&gt;code, tree-&gt;right-&gt;reg1, tree-&gt;right-&gt;reg1, tree-&gt;data.i);
+#	x86_alu_reg_reg (s-&gt;code, X86_ADD, tree-&gt;reg1, tree-&gt;right-&gt;reg1);
+#	x86_alu_reg_imm (s-&gt;code, X86_ADD, tree-&gt;reg1, G_STRUCT_OFFSET (MonoArray, vector));
+#}
 
 reg: NEWARR (reg) {
 	if (tree-&gt;reg1 != X86_EAX)
@@ -526,7 +561,7 @@
 	x86_pop_reg (s-&gt;code, X86_EDX);
 	x86_pop_reg (s-&gt;code, X86_ECX);
 	if (tree-&gt;reg1 != X86_EAX) {
-		x86_mov_reg_reg (s-&gt;code, X86_EAX, tree-&gt;reg1, 4);
+		x86_mov_reg_reg (s-&gt;code, tree-&gt;reg1, X86_EAX, 4);
 		x86_pop_reg (s-&gt;code, X86_EAX);
 	}
 }
@@ -544,7 +579,7 @@
 	x86_pop_reg (s-&gt;code, X86_EDX);
 	x86_pop_reg (s-&gt;code, X86_ECX);
 	if (tree-&gt;reg1 != X86_EAX) {
-		x86_mov_reg_reg (s-&gt;code, X86_EAX, tree-&gt;reg1, 4);
+		x86_mov_reg_reg (s-&gt;code, tree-&gt;reg1, X86_EAX, 4);
 		x86_pop_reg (s-&gt;code, X86_EAX);
 	}
 }
@@ -828,12 +863,22 @@
 
 stmt: ARG (LDIND_OBJ (reg)) {
       // fixme:
-      //g_assert_not_reached ();
+      g_assert_not_reached ();
+}
+
+reg: CALL_I4 (CONST_I4) {
+	
+	x86_call_code (s-&gt;code, tree-&gt;left-&gt;data.p);
+
+	if (tree-&gt;data.i)
+		x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, tree-&gt;data.i);
+	
+	g_assert (tree-&gt;reg1 == X86_EAX);
 }
 
-reg: CALL_I4 (ADDR_G) {
+reg: CALL_I4 (LDIND_I4 (ADDR_G)) {
 	
-	x86_call_mem (s-&gt;code, tree-&gt;left-&gt;data.p);
+	x86_call_mem (s-&gt;code, tree-&gt;left-&gt;left-&gt;data.p);
 
 	if (tree-&gt;data.i)
 		x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, tree-&gt;data.i);
@@ -869,8 +914,8 @@
 	g_assert (tree-&gt;reg1 == X86_EAX);
 }
 
-stmt: CALL_I4 (ADDR_G) {
-	x86_call_mem (s-&gt;c_de, tree-&gt;left-&gt;data.p);
+stmt: CALL_I4 (LDIND_I4 (ADDR_G)) {
+	x86_call_mem (s-&gt;code, tree-&gt;left-&gt;left-&gt;data.p);
 
 	if (tree-&gt;data.i)
 		x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, tree-&gt;data.i);
@@ -900,13 +945,6 @@
 		x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, tree-&gt;data.i);
 }
 
-stmt: CALL_I4 (ADDR_G) {
-	x86_call_mem (s-&gt;code, tree-&gt;left-&gt;data.p);
-
-	if (tree-&gt;data.i)
-		x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, tree-&gt;data.i);
-}
-
 stmt: SWITCH (reg) {
 	guint32 offset;
 	guint32 *jt = (guint32 *)tree-&gt;data.p;
@@ -1155,19 +1193,9 @@
 		x86_pop_reg (s-&gt;code, X86_ECX);
 }
 
-lreg: CALL_I8 (addr) {
-
-	switch (tree-&gt;left-&gt;data.ainfo.amode) {
-	case AMImmediate:
-		x86_call_mem (s-&gt;code, tree-&gt;left-&gt;data.ainfo.offset);
-		break;
-	case AMBase:
-		x86_call_membase (s-&gt;code, tree-&gt;left-&gt;data.ainfo.basereg, 
-				  tree-&gt;left-&gt;data.ainfo.offset);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
+lreg: CALL_I8 (LDIND_I4 (ADDR_G)) {
+	
+	x86_call_mem (s-&gt;code, tree-&gt;left-&gt;left-&gt;data.p);
 
 	if (tree-&gt;data.i)
 		x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, tree-&gt;data.i);
@@ -1416,11 +1444,26 @@
 }
 
 freg: CONST_R4 {
-	x86_fld (s-&gt;code, tree-&gt;data.p, FALSE);
+	float f = *(float *)tree-&gt;data.p;
+
+	if (f == 0.0)
+		x86_fldz (s-&gt;code);
+	else if (f == 1.0)
+		x86_fld1(s-&gt;code);
+	else
+		x86_fld (s-&gt;code, tree-&gt;data.p, FALSE);
 }
 
 freg: CONST_R8 {
-	x86_fld (s-&gt;code, tree-&gt;data.p, TRUE);
+	double d = *(double *)tree-&gt;data.p;
+	printf (&quot;TEST %f\n&quot;, d);
+
+	if (d == 0.0)
+		x86_fldz (s-&gt;code);
+	else if (d == 1.0)
+		x86_fld1(s-&gt;code);
+	else
+		x86_fld (s-&gt;code, tree-&gt;data.p, TRUE);
 }
 
 freg: LDIND_R4 (locaddr) {
@@ -1493,21 +1536,31 @@
 	x86_alu_reg_imm (s-&gt;code, X86_AND, X86_EAX, 0x4500);
 	x86_alu_reg_imm (s-&gt;code, X86_CMP, X86_EAX, 0x4000);
 	offset = 6 + s-&gt;code - s-&gt;start;
-	x86_branch32 (s-&gt;code, X86_CC_NE, tree-&gt;data.bb-&gt;addr - offset, TRUE);
+	x86_branch32 (s-&gt;code, X86_CC_NE, tree-&gt;data.bb-&gt;addr - offset, FALSE);
 }
 
-stmt: BLT_UN (freg, freg) {
+stmt: BLT (freg, freg) {
 	gint32 offset;
 
 	tree-&gt;is_jump = 1;
 	x86_fcompp (s-&gt;code);
 	x86_fnstsw (s-&gt;code);
 	x86_alu_reg_imm (s-&gt;code, X86_AND, X86_EAX, 0x4500);
-	x86_alu_reg_imm (s-&gt;code, X86_CMP, X86_EAX, 0x0100);
 	offset = 6 + s-&gt;code - s-&gt;start;
 	x86_branch32 (s-&gt;code, X86_CC_EQ, tree-&gt;data.bb-&gt;addr - offset, TRUE);
 }
 
+stmt: BLT_UN (freg, freg) {
+	gint32 offset;
+
+	tree-&gt;is_jump = 1;
+	x86_fcompp (s-&gt;code);
+	x86_fnstsw (s-&gt;code);
+	x86_alu_reg_imm (s-&gt;code, X86_AND, X86_EAX, 0x4500);
+	offset = 6 + s-&gt;code - s-&gt;start;
+	x86_branch32 (s-&gt;code, X86_CC_EQ, tree-&gt;data.bb-&gt;addr - offset, FALSE);
+}
+
 stmt: BGE_UN (freg, freg) {
 	gint32 offset;
 
@@ -1515,9 +1568,8 @@
 	x86_fcompp (s-&gt;code);
 	x86_fnstsw (s-&gt;code);
 	x86_alu_reg_imm (s-&gt;code, X86_AND, X86_EAX, 0x4500);
-	x86_alu_reg_imm (s-&gt;code, X86_CMP, X86_EAX, 0x0100);
 	offset = 6 + s-&gt;code - s-&gt;start;
-	x86_branch32 (s-&gt;code, X86_CC_NE, tree-&gt;data.bb-&gt;addr - offset, TRUE);
+	x86_branch32 (s-&gt;code, X86_CC_NE, tree-&gt;data.bb-&gt;addr - offset, FALSE);
 }
 
 stmt: BGT_UN (freg, freg) {
@@ -1527,8 +1579,9 @@
 	x86_fcompp (s-&gt;code);
 	x86_fnstsw (s-&gt;code);
 	x86_alu_reg_imm (s-&gt;code, X86_AND, X86_EAX, 0x4500);
+	x86_alu_reg_imm (s-&gt;code, X86_CMP, X86_EAX, 0x0100);
 	offset = 6 + s-&gt;code - s-&gt;start;
-	x86_branch32 (s-&gt;code, X86_CC_EQ, tree-&gt;data.bb-&gt;addr - offset, TRUE);
+	x86_branch32 (s-&gt;code, X86_CC_EQ, tree-&gt;data.bb-&gt;addr - offset, FALSE);
 }
 
 stmt: BLE_UN (freg, freg) {
@@ -1539,22 +1592,12 @@
 	x86_fnstsw (s-&gt;code);
 	x86_alu_reg_imm (s-&gt;code, X86_AND, X86_EAX, 0x4500);
 	offset = 6 + s-&gt;code - s-&gt;start;
-	x86_branch32 (s-&gt;code, X86_CC_NE, tree-&gt;data.bb-&gt;addr - offset, TRUE);
+	x86_branch32 (s-&gt;code, X86_CC_NE, tree-&gt;data.bb-&gt;addr - offset, FALSE);
 }
 
-freg: CALL_R8 (addr) {
-
-	switch (tree-&gt;left-&gt;data.ainfo.amode) {
-	case AMImmediate:
-		x86_call_mem (s-&gt;code, tree-&gt;left-&gt;data.ainfo.offset);
-		break;
-	case AMBase:
-		x86_call_membase (s-&gt;code, tree-&gt;left-&gt;data.ainfo.basereg, 
-				  tree-&gt;left-&gt;data.ainfo.offset);
-		break;
-	default:
-		g_assert_not_reached ();
-	}
+freg: CALL_R8 (LDIND_I4 (ADDR_G)) {
+	
+	x86_call_mem (s-&gt;code, tree-&gt;left-&gt;left-&gt;data.p);
 
 	if (tree-&gt;data.i)
 		x86_alu_reg_imm (s-&gt;code, X86_ADD, X86_ESP, tree-&gt;data.i);
Index: mono/tests/array.cs
===================================================================
RCS file: /cvs/public/mono/mono/tests/array.cs,v
retrieving revision 1.5
diff -u -r1.5 array.cs
--- mono/tests/array.cs	2001/08/28 10:47:36	1.5
+++ mono/tests/array.cs	2001/11/09 06:26:27
@@ -97,7 +97,7 @@
 	
 
 	public static int Main () {
-	       	       
+
 		if (atest () != 0)
 			return 1;
 		






</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="002022.html">[Mono-list] Make test
</A></li>
	<LI> Next message: <A HREF="002024.html">[Mono-list] patch: more jit work + bug fixes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2023">[ date ]</a>
              <a href="thread.html#2023">[ thread ]</a>
              <a href="subject.html#2023">[ subject ]</a>
              <a href="author.html#2023">[ author ]</a>
         </LI>
       </UL>
</body></html>
