<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] ppc patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rodo%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <LINK REL="Previous"  HREF="002808.html">
   <LINK REL="Next"  HREF="002811.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] ppc patch
   </H1>
    <B>Radek Doulík
    </B> 
    <A HREF="mailto:rodo%40ximian.com"
       TITLE="[Mono-list] ppc patch">rodo@ximian.com
       </A><BR>
    <I>21 Jan 2002 09:25:30 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="002808.html">[Mono-list] C++ to CIL compilers?
</A></li>
        <LI> Next message: <A HREF="002811.html">[Mono-list] ppc patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2809">[ date ]</a>
              <a href="thread.html#2809">[ thread ]</a>
              <a href="subject.html#2809">[ subject ]</a>
              <a href="author.html#2809">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--=-iBFoFvYehilaRIq1Zd1u
Content-Type: text/plain
Content-Transfer-Encoding: 7bit


Hi all,

I am attaching next patch for powerpc architecture. It makes trampolines
generation more complete + initialize array endianess fix. I am looking
forward to comments on later one.

Isn't there a faster way to lookup type than decide by class name
string?

Couldn't array contain more complex types than [U]Int32,16,64,Char,...?

Otherwise it passes all but delegate tests as on x86. Delegates are not
implemented at all at this point.

OK to commit?

Cheers
Radek


--=-iBFoFvYehilaRIq1Zd1u
Content-Disposition: attachment; filename=diff
Content-Transfer-Encoding: quoted-printable
Content-Type: text/plain; charset=ISO-8859-2

? .debug
? diff
? diff.OK
? mono/trace
? mono/stest.dat
? mono/diff
? mono/arch/libffi
? mono/arch/ppc/g4_user_manual.pdf
? mono/arch/ppc/dis
? mono/arch/ppc/xptc
? mono/arch/ppc/g4_user_manual.ps
? mono/arch/ppc/test.dir
? mono/arch/ppc/t.s
? mono/arch/ppc/tramp.od
? mono/arch/ppc/tramp.c.new
? mono/arch/x86/test
? mono/arch/x86/test.s
? mono/arch/x86/a.out
? mono/interpreter/log
? mono/interpreter/out.s
? mono/interpreter/dump
? mono/interpreter/interp.s
? mono/interpreter/log1
? mono/interpreter/a.s
? mono/metadata/diff
? mono/metadata/icall.c.rodo
? mono/metadata/object.c.rodo
? mono/tests/stest.dat
? mono/tests/log
? mono/tests/tests.tgz
? mono/tests/miguel
Index: mono/arch/ppc/ppc-codegen.h
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvs/public/mono/mono/arch/ppc/ppc-codegen.h,v
retrieving revision 1.1
diff -u -p -r1.1 ppc-codegen.h
--- mono/arch/ppc/ppc-codegen.h	2001/11/29 19:32:19	1.1
+++ mono/arch/ppc/ppc-codegen.h	2002/01/21 10:24:34
@@ -43,6 +43,41 @@ typedef enum {
 } PPCIntRegister;
=20
 typedef enum {
+	f0 =3D 0,
+	f1,
+	f2,
+	f3,
+	f4,
+	f5,
+	f6,
+	f7,
+	f8,
+	f9,
+	f10,
+	f11,
+	f12,
+	f13,
+	f14,
+	f15,
+	f16,
+	f17,
+	f18,
+	f19,
+	f20,
+	f21,
+	f22,
+	f23,
+	f24,
+	f25,
+	f26,
+	f27,
+	f28,
+	f29,
+	f30,
+	f31
+} PPCFloatRegister;
+
+typedef enum {
 	lr =3D 256,
 } PPCSpecialRegister;
=20
@@ -55,10 +90,15 @@ c[2] =3D x &amp; 0xff; x &gt;&gt;=3D 8; \
 c[3] =3D x; c +=3D 4; }
=20
 #define  addi(c,D,A,d) emit32 (c, (14 &lt;&lt; 26) | ((D) &lt;&lt; 21) | ((A) &lt;&lt; 16) |=
 (guint16)(d))
+#define addis(c,D,A,d) emit32 (c, (15 &lt;&lt; 26) | ((D) &lt;&lt; 21) | ((A) &lt;&lt; 16) |=
 (guint16)(d))
+#define    li(c,D,v)   addi   (c, D, 0, v);
+#define   lis(c,D,v)   addis  (c, D, 0, v);
 #define   lwz(c,D,d,a) emit32 (c, (32 &lt;&lt; 26) | ((D) &lt;&lt; 21) | ((a) &lt;&lt; 16) |=
 (guint16)(d))
 #define   stw(c,S,d,a) emit32 (c, (36 &lt;&lt; 26) | ((S) &lt;&lt; 21) | ((a) &lt;&lt; 16) |=
 (guint16)(d))
+#define   stb(c,S,d,a) emit32 (c, (38 &lt;&lt; 26) | ((S) &lt;&lt; 21) | ((a) &lt;&lt; 16) |=
 (guint16)(d))
 #define  stwu(c,s,d,a) emit32 (c, (37 &lt;&lt; 26) | ((s) &lt;&lt; 21) | ((a) &lt;&lt; 16) |=
 (guint16)(d))
 #define    or(c,a,s,b) emit32 (c, (31 &lt;&lt; 26) | ((s) &lt;&lt; 21) | ((a) &lt;&lt; 16) |=
 ((b) &lt;&lt; 11) | 888)
+#define   ori(c,S,A,u) emit32 (c, (24 &lt;&lt; 26) | ((S) &lt;&lt; 21) | ((A) &lt;&lt; 16) |=
 (guint16)(u))
 #define    mr(c,a,s)   or     (c, a, s, s)
 #define mfspr(c,D,spr) emit32 (c, (31 &lt;&lt; 26) | ((D) &lt;&lt; 21) | ((spr) &lt;&lt; 11)=
 | (339 &lt;&lt; 1))
 #define  mflr(c,D)     mfspr  (c, D, lr)
@@ -67,5 +107,11 @@ c[3] =3D x; c +=3D 4; }
=20
 #define  blrl(c)       emit32(c, 0x4e800021)
 #define   blr(c)       emit32(c, 0x4e800020)
+
+#define   lfs(c,D,d,A) emit32(c, (48 &lt;&lt; 26) | ((D) &lt;&lt; 21) | ((A) &lt;&lt; 16) | =
(guint16)(d))
+#define   lfd(c,D,d,A) emit32(c, (50 &lt;&lt; 26) | ((D) &lt;&lt; 21) | ((A) &lt;&lt; 16) | =
(guint16)(d))
+#define  stfs(c,S,d,a) emit32 (c, (52 &lt;&lt; 26) | ((S) &lt;&lt; 21) | ((a) &lt;&lt; 16) |=
 (guint16)(d))
+#define  stfd(c,S,d,a) emit32 (c, (54 &lt;&lt; 26) | ((S) &lt;&lt; 21) | ((a) &lt;&lt; 16) |=
 (guint16)(d))
+
=20
 #endif
Index: mono/arch/ppc/tramp.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvs/public/mono/mono/arch/ppc/tramp.c,v
retrieving revision 1.2
diff -u -p -r1.2 tramp.c
--- mono/arch/ppc/tramp.c	2001/11/29 21:23:53	1.2
+++ mono/arch/ppc/tramp.c	2002/01/21 10:24:35
@@ -21,9 +21,14 @@
 #endif
=20
 /* void
-fake_func (gpointer (*callme)(), void *retval, void *this_obj, stackval *a=
rguments)
+fake_func (gdouble (*callme)(), stackval *retval, void *this_obj, stackval=
 *arguments)
 {
-	*(gpointer*)retval =3D (*callme) (arguments [0].data.p, arguments [1].dat=
a.p, arguments [2].data.p);
+	guint32 i =3D 0xc002becd;
+
+	callme =3D (gpointer) 0x100fabcd;
+
+	*(gpointer*)retval =3D (gpointer)(*callme) (arguments [0].data.p, argumen=
ts [1].data.p, arguments [2].data.p);
+	*(gdouble*) retval =3D (gdouble)(*callme) (arguments [0].data.f);
 } */
=20
 #define MIN_CACHE_LINE 8
@@ -47,8 +52,8 @@ flush_icache (guint8 *code, guint size)
 	asm (&quot;isync&quot;);
 }
=20
-#define NOT_IMPLEMENTED \
-                g_error (&quot;FIXME: Not yet implemented. (trampoline)&quot;);
+#define NOT_IMPLEMENTED(x) \
+                g_error (&quot;FIXME: %s is not yet implemented. (trampoline)&quot;,=
 x);
=20
 #define PROLOG_INS 8
 #define CALL_INS   2
@@ -80,7 +85,7 @@ add_general (guint *gr, guint *stack_siz
 }
=20
 static void inline
-calculate_sizes (MonoMethod *method, guint *stack_size, guint *code_size)
+calculate_sizes (MonoMethod *method, guint *stack_size, guint *code_size, =
guint *strings, gint runtime)
 {
 	MonoMethodSignature *sig;
 	guint i, fr, gr;
@@ -89,6 +94,7 @@ calculate_sizes (MonoMethod *method, gui
 	fr =3D gr =3D 0;
 	*stack_size =3D MINIMAL_STACK_SIZE*4;
 	*code_size  =3D (PROLOG_INS + CALL_INS + EPILOG_INS)*4;
+	*strings =3D 0;
=20
 	sig =3D method-&gt;signature;
 	if (sig-&gt;hasthis) {
@@ -97,7 +103,8 @@ calculate_sizes (MonoMethod *method, gui
=20
 	for (i =3D 0; i &lt; sig-&gt;param_count; ++i) {
 		if (sig-&gt;params [i]-&gt;byref) {
-			g_error (&quot;FIXME, trampoline: byref&quot;);
+			add_general (&amp;gr, stack_size, code_size, TRUE);
+			continue;
 		}
 		simpletype =3D sig-&gt;params [i]-&gt;type;
 	enum_calc_size:
@@ -127,16 +134,28 @@ calculate_sizes (MonoMethod *method, gui
 				g_error (&quot;can only marshal enums, not generic structures (size: %d)&quot;,
 					 mono_class_value_size (sig-&gt;params [i]-&gt;data.klass, NULL));
 			add_general (&amp;gr, stack_size, code_size, TRUE);
+			*code_size +=3D 4;
 			break;
 		case MONO_TYPE_STRING:
-			NOT_IMPLEMENTED;
+			if ((method-&gt;iflags &amp; METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) || runtime) =
{
+				add_general (&amp;gr, stack_size, code_size, TRUE);
+				break;
+			}
+			(*strings) ++;
+			*code_size +=3D 12*4;
+			*stack_size +=3D 4;
 			break;
 		case MONO_TYPE_I8:
 			add_general (&amp;gr, stack_size, code_size, FALSE);
 			break;
 		case MONO_TYPE_R4:
 		case MONO_TYPE_R8:
-			NOT_IMPLEMENTED;
+			if (fr &lt; 7) {
+				*code_size +=3D 4;
+				fr ++;
+			} else {
+				NOT_IMPLEMENTED (&quot;R8 arg&quot;);
+			}
 			break;
 		default:
 			g_error (&quot;Can't trampoline 0x%x&quot;, sig-&gt;params [i]-&gt;type);
@@ -144,7 +163,7 @@ calculate_sizes (MonoMethod *method, gui
 	}
=20
 	if (sig-&gt;ret-&gt;byref) {
-		g_error (&quot;trampoline, retval byref - TODO&quot;);
+		*code_size +=3D 8;
 	} else {
 		simpletype =3D sig-&gt;ret-&gt;type;
 enum_retvalue:
@@ -160,10 +179,10 @@ enum_retvalue:
 		case MONO_TYPE_OBJECT:
 		case MONO_TYPE_R4:
 		case MONO_TYPE_R8:
-			*code_size +=3D 8;
-			break;
+		case MONO_TYPE_SZARRAY:
+		case MONO_TYPE_ARRAY:
 		case MONO_TYPE_STRING:
-			NOT_IMPLEMENTED;
+			*code_size +=3D 8;
 			break;
 		case MONO_TYPE_I8:
 			*code_size +=3D 12;
@@ -173,6 +192,8 @@ enum_retvalue:
 				simpletype =3D sig-&gt;ret-&gt;data.klass-&gt;enum_basetype-&gt;type;
 				goto enum_retvalue;
 			}
+			NOT_IMPLEMENTED (&quot;valuetype&quot;);
+			break;
 		case MONO_TYPE_VOID:
 			break;
 		default:
@@ -180,6 +201,15 @@ enum_retvalue:
 		}
 	}
=20
+	if (*strings) {
+		/* space to keep parameters and prepared strings */
+		 *stack_size +=3D 8;
+		 *code_size +=3D 16;
+		 if (sig-&gt;hasthis) {
+			 *stack_size +=3D 4;
+			 *code_size  +=3D 12;
+		 }
+	}
 	/* align stack size to 16 */
 	printf (&quot;      stack size: %d (%d)\n       code size: %d\n&quot;, (*stack_size=
 + 15) &amp; ~15, *stack_size, *code_size);
 	*stack_size =3D (*stack_size + 15) &amp; ~15;
@@ -187,50 +217,80 @@ enum_retvalue:
 }
=20
 static inline guint8 *
-emit_prolog (guint8 *p, guint stack_size)
+emit_prolog (guint8 *p, MonoMethod *method, guint stack_size, guint string=
s)
 {
 	/* function prolog */
-	stwu (p, r1, -stack_size, r1);            /* sp      &lt;--- sp - 48, sp[0] =
&lt;---- sp     save sp, allocate stack */
+	stwu (p, r1, -stack_size, r1);            /* sp      &lt;--- sp - stack_size=
, sp[0] &lt;---- sp save sp, allocate stack */
 	mflr (p, r0);                             /* r0      &lt;--- LR */
-	stw  (p, r31, stack_size - 4, r1);        /* sp[44]  &lt;--- r31     save r3=
1 */
-	stw  (p, r0, stack_size + 4, r1);         /* sp[52]  &lt;--- LR      save re=
turn address in &quot;callme&quot; stack frame */
+	stw  (p, r31, stack_size - 4, r1);        /* sp[+4]  &lt;--- r31     save r3=
1 */
+	stw  (p, r0, stack_size + 4, r1);         /* sp[-4]  &lt;--- LR      save re=
turn address for &quot;callme&quot; */
 	mr   (p, r31, r1);                        /* r31     &lt;--- sp */
=20
 	/* handle our parameters */
-	mr   (p, r12, r6);                        /* keep &quot;arguments&quot; in register=
 */
-	mr   (p, r0, r3);                         /* keep &quot;callme&quot; in register */
-	stw  (p, r4, 8, r31);                     /* preserve &quot;retval&quot;, sp[8] */
+	if (strings) {
+		stw  (p, r30, 16, r1);
+		stw  (p, r29, 20, r1);
+		if (method-&gt;signature-&gt;hasthis) {
+			stw  (p, r28, 24, r1);
+		}
+		mr   (p, r30, r6);                        /* args */
+		mr   (p, r29, r3);                        /* callme */
+		if (method-&gt;signature-&gt;hasthis) {
+			mr   (p, r28, r5);                /* this */
+		}
+	} else {
+		mr   (p, r12, r6);                        /* keep &quot;arguments&quot; in registe=
r */
+		mr   (p, r0, r3);                         /* keep &quot;callme&quot; in register *=
/
+	}
+	stw  (p, r4, 8, r31);                     /* preserve &quot;retval&quot;, sp[+8] */
=20
 	return p;
 }
=20
+#define ARG_BASE strings ? r30 : r12
 #define SAVE_4_IN_GENERIC_REGISTER \
 			if (gr &lt; GENERAL_REGS) { \
-				lwz  (p, r3 + gr, i*16, r12); \
+				lwz  (p, r3 + gr, i*16, ARG_BASE); \
 				gr ++; \
 			} else { \
-				NOT_IMPLEMENTED; \
+				NOT_IMPLEMENTED(&quot;save on stack&quot;); \
 			}
=20
 inline static guint8*
-emit_save_parameters (guint8 *p, MonoMethod *method)
+emit_save_parameters (guint8 *p, MonoMethod *method, guint strings, gint r=
untime)
 {
 	MonoMethodSignature *sig;
-	guint i, fr, gr;
+	guint i, fr, gr, act_strs;
 	guint32 simpletype;
=20
 	fr =3D gr =3D 0;
-
+	act_strs =3D 0;
 	sig =3D method-&gt;signature;
+
+	if (strings) {
+		for (i =3D 0; i &lt; sig-&gt;param_count; ++i) {
+			if (!sig-&gt;params [i]-&gt;byref &amp;&amp; sig-&gt;params [i]-&gt;type =3D=3D MONO_TYPE_S=
TRING) {
+				lis  (p, r0,     (guint32) mono_string_to_utf8 &gt;&gt; 16);
+				lwz  (p, r3, i*16, r30);
+				ori  (p, r0, r0, (guint32) mono_string_to_utf8 &amp; 0xffff);
+				mtlr (p, r0);
+				blrl (p);
+				stw  (p, r3, 24 + act_strs, r31);
+				act_strs +=3D 4;
+			}
+		}
+	}
+
 	if (sig-&gt;hasthis) {
-		g_warning (&quot;FIXME: trampoline, decide on MONO_CALL_THISCALL&quot;);
 		mr (p, r3, r5);
 		gr ++;
 	}
=20
+	act_strs =3D 0;
 	for (i =3D 0; i &lt; sig-&gt;param_count; ++i) {
 		if (sig-&gt;params [i]-&gt;byref) {
-			g_error (&quot;FIXME, trampoline: byref&quot;);
+			SAVE_4_IN_GENERIC_REGISTER;
+			continue;
 		}
 		simpletype =3D sig-&gt;params [i]-&gt;type;
 	enum_calc_size:
@@ -259,25 +319,52 @@ emit_save_parameters (guint8 *p, MonoMet
 			if (mono_class_value_size (sig-&gt;params [i]-&gt;data.klass, NULL) !=3D 4)
 				g_error (&quot;can only marshal enums, not generic structures (size: %d)&quot;,
 					 mono_class_value_size (sig-&gt;params [i]-&gt;data.klass, NULL));
-			SAVE_4_IN_GENERIC_REGISTER;
+			if (gr &lt; GENERAL_REGS) {
+				lwz  (p, r3 + gr, i*16, ARG_BASE);
+				lwz  (p, r3 + gr, 0, r3 + gr);
+				gr ++;
+			} else {
+				NOT_IMPLEMENTED (&quot;save value type on stack&quot;);
+			}
 			break;
 		case MONO_TYPE_STRING:
-			NOT_IMPLEMENTED;
+			if ((method-&gt;iflags &amp; METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) || runtime) =
{
+				SAVE_4_IN_GENERIC_REGISTER;
+			} else {
+				if (gr &lt; 8) {
+					lwz (p, r3 + gr, 24 + act_strs * 4, r31);
+					gr ++;
+					act_strs ++;
+				} else
+					NOT_IMPLEMENTED (&quot;string on stack&quot;);
+			}
 			break;
 		case MONO_TYPE_I8:
 			if (gr &lt; 7) {
 				g_warning (&quot;check endianess&quot;);
-				lwz  (p, r3 + gr, i*16, r12);
+				lwz  (p, r3 + gr, i*16, ARG_BASE);
 				gr ++;
-				lwz  (p, r3 + gr, i*17, r12);
+				lwz  (p, r3 + gr, i*17, ARG_BASE);
 				gr ++;
 			} else {
-				NOT_IMPLEMENTED;
+				NOT_IMPLEMENTED (&quot;i8 on stack&quot;);
 			}
 			break;
 		case MONO_TYPE_R4:
+			if (fr &lt; 7) {
+				lfs  (p, f1 + fr, i*16, ARG_BASE);
+				fr ++;
+			} else {
+				NOT_IMPLEMENTED (&quot;r4 on stack&quot;);
+			}
+			break;
 		case MONO_TYPE_R8:
-			NOT_IMPLEMENTED;
+			if (fr &lt; 7) {
+				lfd  (p, f1 + fr, i*16, ARG_BASE);
+				fr ++;
+			} else {
+				NOT_IMPLEMENTED (&quot;r8 on stack&quot;);
+			}
 			break;
 		default:
 			g_error (&quot;Can't trampoline 0x%x&quot;, sig-&gt;params [i]-&gt;type);
@@ -306,22 +393,100 @@ alloc_code_memory (guint code_size)
 }
=20
 static inline guint8 *
-emit_call_and_store_retval (guint8 *p, MonoMethod *method)
+emit_call_and_store_retval (guint8 *p, MonoMethod *method, guint strings)
 {
+	MonoMethodSignature *sig =3D method-&gt;signature;
+	guint32 simpletype;
+
 	/* call &quot;callme&quot; */
-	mtlr (p, r0);
+	mtlr (p, strings ? r29 : r0);
 	blrl (p);
=20
 	/* get return value */
-	lwz  (p, r9, 8, r31);        /* load &quot;retval&quot; address */
-	stw  (p, r3, 0, r9);          /* save return value (r3) to &quot;retval&quot; */
+	if (sig-&gt;ret-&gt;byref) {
+		lwz  (p, r9, 8, r31);        /* load &quot;retval&quot; address */
+		stw  (p, r3, 0, r9);         /* save return value (r3) to &quot;retval&quot; */
+	} else {
+		simpletype =3D sig-&gt;ret-&gt;type;
+enum_retvalue:
+		switch (simpletype) {
+		case MONO_TYPE_BOOLEAN:
+		case MONO_TYPE_I1:
+		case MONO_TYPE_U1:
+			lwz  (p, r9, 8, r31);        /* load &quot;retval&quot; address */
+			stb  (p, r3, 0, r9);         /* save return value (r3) to &quot;retval&quot; */
+			break;
+		case MONO_TYPE_I4:
+		case MONO_TYPE_U4:
+		case MONO_TYPE_I:
+		case MONO_TYPE_U:
+		case MONO_TYPE_CLASS:
+		case MONO_TYPE_OBJECT:
+		case MONO_TYPE_SZARRAY:
+		case MONO_TYPE_ARRAY:
+		case MONO_TYPE_STRING:
+			lwz  (p, r9, 8, r31);        /* load &quot;retval&quot; address */
+			stw  (p, r3, 0, r9);         /* save return value (r3) to &quot;retval&quot; */
+			break;
+		case MONO_TYPE_R4:
+			lwz  (p, r9, 8, r31);        /* load &quot;retval&quot; address */
+			stfs (p, f1, 0, r9);         /* save return value (f1) to &quot;retval&quot; */
+			break;
+		case MONO_TYPE_R8:
+			lwz  (p, r9, 8, r31);        /* load &quot;retval&quot; address */
+			stfd (p, f1, 0, r9);         /* save return value (f1) to &quot;retval&quot; */
+			break;
+		case MONO_TYPE_I8:
+			g_warning (&quot;check endianess&quot;);
+			lwz  (p, r9, 8, r31);        /* load &quot;retval&quot; address */
+			stw  (p, r3, 0, r9);         /* save return value (r3) to &quot;retval&quot; */
+			stw  (p, r4, 4, r9);         /* save return value (r3) to &quot;retval&quot; */
+			break;
+		case MONO_TYPE_VALUETYPE:
+			if (sig-&gt;ret-&gt;data.klass-&gt;enumtype) {
+				simpletype =3D sig-&gt;ret-&gt;data.klass-&gt;enum_basetype-&gt;type;
+				goto enum_retvalue;
+			}
+			NOT_IMPLEMENTED (&quot;retval valuetype&quot;);
+			break;
+		case MONO_TYPE_VOID:
+			break;
+		default:
+			g_error (&quot;Can't handle as return value 0x%x&quot;, sig-&gt;ret-&gt;type);
+		}
+	}
=20
 	return p;
 }
=20
 static inline guint8 *
-emit_epilog (guint8 *p)
+emit_epilog (guint8 *p, MonoMethod *method, guint strings)
 {
+	if (strings) {
+		MonoMethodSignature *sig =3D method-&gt;signature;
+		guint i, act_strs;
+
+		/* free allocated memory */
+		act_strs =3D 0;
+		for (i =3D 0; i &lt; sig-&gt;param_count; ++i) {
+			if (!sig-&gt;params [i]-&gt;byref &amp;&amp; sig-&gt;params [i]-&gt;type =3D=3D MONO_TYPE_S=
TRING) {
+				lis  (p, r0,     (guint32) g_free &gt;&gt; 16);
+				lwz  (p, r3, 24 + act_strs, r31);
+				ori  (p, r0, r0, (guint32) g_free &amp; 0xffff);
+				mtlr (p, r0);
+				blrl (p);
+				act_strs +=3D 4;
+			}
+		}
+
+		/* restore volatile registers */
+		lwz  (p, r30, 16, r1);
+		lwz  (p, r29, 20, r1);
+		if (method-&gt;signature-&gt;hasthis) {
+			lwz  (p, r28, 24, r1);
+		}
+	}
+
 	/* function epilog */
 	lwz  (p, r11, 0,  r1);        /* r11     &lt;--- sp[0]   load backchain from=
 caller's function */
 	lwz  (p, r0, 4, r11);         /* r0      &lt;--- r11[4]  load return address=
 */
@@ -334,20 +499,19 @@ emit_epilog (guint8 *p)
 }
=20
 MonoPIFunc
-mono_create_trampoline (MonoMethod *method)
+mono_create_trampoline (MonoMethod *method, int runtime)
 {
 	guint8 *p, *code_buffer;
-	guint stack_size, code_size;
-
-	printf (&quot;\nPInvoke [start emiting]\n&quot;);
+	guint stack_size, code_size, strings;
=20
-	calculate_sizes (method, &amp;stack_size, &amp;code_size);
+	printf (&quot;\nPInvoke [start emiting] %s\n&quot;, method-&gt;name);
+	calculate_sizes (method, &amp;stack_size, &amp;code_size, &amp;strings, runtime);
=20
 	p =3D code_buffer =3D alloc_code_memory (code_size);
-	p =3D emit_prolog (p, stack_size);
-	p =3D emit_save_parameters (p, method);
-	p =3D emit_call_and_store_retval (p, method);
-	p =3D emit_epilog (p);
+	p =3D emit_prolog (p, method, stack_size, strings);
+	p =3D emit_save_parameters (p, method, strings, runtime);
+	p =3D emit_call_and_store_retval (p, method, strings);
+	p =3D emit_epilog (p, method, strings);
=20
 	/* {
 		guchar *cp;
Index: mono/metadata/class.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvs/public/mono/mono/metadata/class.c,v
retrieving revision 1.65
diff -u -p -r1.65 class.c
--- mono/metadata/class.c	2002/01/17 10:08:43	1.65
+++ mono/metadata/class.c	2002/01/21 10:24:35
@@ -18,6 +18,7 @@
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
+#include &lt;signal.h&gt;
 #include &lt;mono/metadata/image.h&gt;
 #include &lt;mono/metadata/cil-coff.h&gt;
 #include &lt;mono/metadata/metadata.h&gt;
Index: mono/metadata/icall.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvs/public/mono/mono/metadata/icall.c,v
retrieving revision 1.43
diff -u -p -r1.43 icall.c
--- mono/metadata/icall.c	2002/01/17 10:08:43	1.43
+++ mono/metadata/icall.c	2002/01/21 10:24:35
@@ -135,12 +135,56 @@ ves_icall_InitializeArray (MonoArray *ar
 	MonoClass *klass =3D array-&gt;obj.klass;
 	guint32 size =3D mono_array_element_size (klass);
 	int i;
+#if G_BYTE_ORDER !=3D G_LITTLE_ENDIAN
+	const gchar *name;
+#endif
+
 	for (i =3D 0; i &lt; klass-&gt;rank; ++i)
 		size *=3D array-&gt;bounds [i].length;
-	/*
-	 * FIXME: ENOENDIAN: we need to byteswap as needed.
-	 */
 	memcpy (mono_array_addr (array, char, 0), field_handle-&gt;data, size);
+
+#if G_BYTE_ORDER !=3D G_LITTLE_ENDIAN
+#define SWAP(n) \
+	gint i; \
+	guint ## n tmp; \
+	guint ## n *data =3D (guint ## n *) mono_array_addr (array, char, 0); \
+\
+	for (i =3D 0; i &lt; size; i +=3D n/8, data++) { \
+		tmp =3D read ## n (data); \
+		*data =3D tmp; \
+	}
+
+	name =3D klass-&gt;element_class-&gt;name;
+	printf (&quot;Initialize array with elements of %s type\n&quot;, name);
+
+	if (name [0] =3D=3D 'I') {
+		if (name [1] =3D=3D 'n' &amp;&amp; name [2] =3D=3D 't') {
+			if (name [3] =3D=3D '3' &amp;&amp; name [4] =3D=3D '2' &amp;&amp; name [5] =3D=3D 0) {
+				SWAP (32);
+			} else if (name [3] =3D=3D '1' &amp;&amp; name [4] =3D=3D '6' &amp;&amp; name [5] =3D=
=3D 0) {
+				SWAP (16);
+			} else if (name [3] =3D=3D '6' &amp;&amp; name [4] =3D=3D '4' &amp;&amp; name [5] =3D=
=3D 0) {
+				SWAP (64);
+			}
+		}
+	} else if (name [0] =3D=3D 'U') {
+		if (name [1] =3D=3D 'I') {
+			if (name [2] =3D=3D 'n' &amp;&amp; name [3] =3D=3D 't') {
+				if (name [4] =3D=3D '3' &amp;&amp; name [5] =3D=3D '2' &amp;&amp; name [6] =3D=3D 0) {
+					SWAP (32);
+				} else if (name [4] =3D=3D '1' &amp;&amp; name [5] =3D=3D '6' &amp;&amp; name [6] =3D=
=3D 0) {
+					SWAP (16);
+				} else if (name [4] =3D=3D '6' &amp;&amp; name [5] =3D=3D '4' &amp;&amp; name [6] =3D=
=3D 0) {
+					SWAP (64);
+				}
+			}
+		}
+	} else if (name [0] =3D=3D 'C') {
+		if (name [1] =3D=3D 'h' &amp;&amp; name [2] =3D=3D 'a' &amp;&amp; name [3] =3D=3D 'r' &amp;&amp;=
 name [4] =3D=3D 0) {
+			SWAP (16);
+		}
+	}
+#endif
 }
=20
 static MonoObject *
Index: mono/metadata/object.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvs/public/mono/mono/metadata/object.c,v
retrieving revision 1.31
diff -u -p -r1.31 object.c
--- mono/metadata/object.c	2002/01/09 14:41:59	1.31
+++ mono/metadata/object.c	2002/01/21 10:24:35
@@ -9,6 +9,7 @@
 #include &lt;config.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;stdio.h&gt;
+#include &lt;signal.h&gt;
 #include &lt;string.h&gt;
 #include &lt;mono/metadata/tabledefs.h&gt;
 #include &lt;mono/metadata/loader.h&gt;
@@ -398,6 +399,7 @@ mono_ldstr (MonoImage *image, guint32 in
 		mprotect ((void *) ((int) str &amp; ~(PAGESIZE - 1)), len2 + ((int) str &amp; (P=
AGESIZE - 1)),
 				    PROT_READ | PROT_WRITE | PROT_EXEC);
 		len2 &gt;&gt;=3D 1;
+		/* printf (&quot;swap %p\n&quot;, str); */
 		for (i =3D 0, s =3D (guint16 *) str; i &lt; len2; i++, s++) {
 			*s =3D ((*s &amp; 0xff) &lt;&lt; 8) | (*s &gt;&gt; 8);
 		}
Index: mono/metadata/verify.c
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: /cvs/public/mono/mono/metadata/verify.c,v
retrieving revision 1.3
diff -u -p -r1.3 verify.c
--- mono/metadata/verify.c	2002/01/11 14:13:13	1.3
+++ mono/metadata/verify.c	2002/01/21 10:24:35
@@ -4,6 +4,7 @@
 #include &lt;mono/metadata/tabledefs.h&gt;
 #include &lt;mono/metadata/mono-endian.h&gt;
 #include &lt;string.h&gt;
+#include &lt;signal.h&gt;
 #include &lt;ctype.h&gt;
=20
 /*

--=-iBFoFvYehilaRIq1Zd1u--



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="002808.html">[Mono-list] C++ to CIL compilers?
</A></li>
	<LI> Next message: <A HREF="002811.html">[Mono-list] ppc patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2809">[ date ]</a>
              <a href="thread.html#2809">[ thread ]</a>
              <a href="subject.html#2809">[ subject ]</a>
              <a href="author.html#2809">[ author ]</a>
         </LI>
       </UL>
</body></html>
