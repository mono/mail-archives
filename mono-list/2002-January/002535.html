<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] class libs .. some progress..
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:Quenio.dos.Santos%40ZeroG.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="002533.html">
   <LINK REL="Next"  HREF="002577.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] class libs .. some progress..
   </H1>
    <B>Quenio dos Santos
    </B> 
    <A HREF="mailto:Quenio.dos.Santos%40ZeroG.com"
       TITLE="[Mono-list] class libs .. some progress..">Quenio.dos.Santos@ZeroG.com
       </A><BR>
    <I>Fri, 4 Jan 2002 05:08:42 -0800</I>
    <P><UL>
        <LI> Previous message: <A HREF="002533.html">[Mono-list] class libs .. some progress..
</A></li>
        <LI> Next message: <A HREF="002577.html">[Mono-list] class libs .. some progress..
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2535">[ date ]</a>
              <a href="thread.html#2535">[ thread ]</a>
              <a href="subject.html#2535">[ subject ]</a>
              <a href="author.html#2535">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.

------=_NextPart_000_0003_01C194DD.E0B535E0
Content-Type: text/plain;
	charset=&quot;iso-8859-1&quot;
Content-Transfer-Encoding: 7bit

Hello Ravi,

I have found the same problem with this nightly build. I have made some
slight changes to the attached files and now it is building. But I don't
garantee the tests will pass. It seems to me that someone forgot to checkin
a new version of the XMLInputSource class.

Hope it helps,
   Quenio dos Santos

-----Original Message-----
From: <A HREF="mailto:mono-list-admin@ximian.com">mono-list-admin@ximian.com</A> [mailto:<A HREF="mailto:mono-list-admin@ximian.com">mono-list-admin@ximian.com</A>]On
Behalf Of Ravi Pratap M
Sent: Friday, January 04, 2002 2:12 AM
To: <A HREF="mailto:mono-list@ximian.com">mono-list@ximian.com</A>
Subject: [Mono-list] class libs .. some progress..


Hi guys,

    So after trying something else, here's what I now land with  : some
brokenness in System.XML perhaps ?

[<A HREF="mailto:ravi@raj">ravi@raj</A>] $ pwd
/home/ravi/mcs/class
[<A HREF="mailto:ravi@raj">ravi@raj</A>] $ cd ..
[<A HREF="mailto:ravi@raj">ravi@raj</A>] $ make windows
for i in jay mcs class tools; do                        \
        (cd $i; make linux)             \
done
make[1]: Entering directory `/home/ravi/mcs/jay'
make[1]: Nothing to be done for `linux'.
make[1]: Leaving directory `/home/ravi/mcs/jay'
make[1]: Entering directory `/home/ravi/mcs/mcs'
make[1]: Nothing to be done for `linux'.
make[1]: Leaving directory `/home/ravi/mcs/mcs'
make[1]: Entering directory `/home/ravi/mcs/class'
../nant/NAnt.exe linux
Buildfile: C:\cygwin\home\ravi\mcs\class\library.build

linux:
     [nant] C:\cygwin\home\ravi\mcs\class\corlib\corlib.build linux
            Buildfile: C:\cygwin\home\ravi\mcs\class\corlib\corlib.build

            linux:
                  [csc] Compiling 423 files to
C:\cygwin\home\ravi\mcs\class\lib\corlib.dll
C:\cygwin\home\ravi\mcs\class\corlib\System.IO\CheckPermission.cs(59,4):
warning CS0162: Unreachable code detected

                  [csc] Compiling 380 files to
C:\cygwin\home\ravi\mcs\class\corlib\Test\corlib_res.dll
C:\cygwin\home\ravi\mcs\class\corlib\System.IO\CheckPermission.cs(59,4):
warning CS0162: Unreachable code detected

                 [nant]
C:\cygwin\home\ravi\mcs\class\corlib\Test\corlib_test.build build
                        Buildfile:
C:\cygwin\home\ravi\mcs\class\corlib\Test\corlib_test.build

                        build:

                        BUILD SUCCEEDED

                        Total time: 0 seconds

            BUILD SUCCEEDED

            Total time: 27 seconds
     [nant] C:\cygwin\home\ravi\mcs\class\System\System.build build
            Buildfile: C:\cygwin\home\ravi\mcs\class\System\System.build

            build:
                 [nant]
C:\cygwin\home\ravi\mcs\class\System\Test\System_test.build build
                        build:

                        BUILD SUCCEEDED

                        Total time: 0 seconds

            BUILD SUCCEEDED

            Total time: 1 seconds
     [nant]
C:\cygwin\home\ravi\mcs\class\System.Drawing\System.Drawing.build build
            Buildfile:
C:\cygwin\home\ravi\mcs\class\System.Drawing\System.Drawing.build

            build:

            BUILD SUCCEEDED

            Total time: 0 seconds
     [nant] C:\cygwin\home\ravi\mcs\class\System.Web\System.Web.build build
            Buildfile:
C:\cygwin\home\ravi\mcs\class\System.Web\System.Web.build

            build:

            BUILD SUCCEEDED

            Total time: 1 seconds
     [nant] C:\cygwin\home\ravi\mcs\class\System.XML\System.XML.build build
            Buildfile:
C:\cygwin\home\ravi\mcs\class\System.XML\System.XML.build

            build:
                  [csc] Compiling 56 files to
C:\cygwin\home\ravi\mcs\class\lib\System.Xml.dll
C:\cygwin\home\ravi\mcs\class\System.XML\System.Xml\XmlParser.cs(106,13):
error CS1502: The best overloaded method match for
'System.Xml.XmlException.XmlException(string, System.Exception)' has some
invalid arguments
C:\cygwin\home\ravi\mcs\class\System.XML\System.Xml\XmlParser.cs(106,60):
error CS1503: Argument '2': cannot convert from 'System.Xml.XmlInputSource'
to 'System.Exception'
C:\cygwin\home\ravi\mcs\class\System.XML\System.Xml\XmlParser.cs(119,8):
error CS0117: 'System.Xml.XmlInputSource' does not contain a definition for
'pieceStart'
C:\cygwin\home\ravi\mcs\class\System.XML\System.Xml\XmlParser.cs(128,9):
error CS0117: 'System.Xml.XmlInputSource' does not contain a definition for
'pieceStart'
C:\cygwin\home\ravi\mcs\class\System.XML\System.Xml\XmlParser.cs(135,9):
error CS0117: 'System.Xml.XmlInputSource' does not contain a definition for
'pieceStart'


            BUILD FAILED
            C:\cygwin\home\ravi\mcs\class\System.XML\System.XML.build:-1:
Program error, see build log for details.
            Program error, see build log for details.



_______________________________________________
Mono-list maillist  -  <A HREF="mailto:Mono-list@ximian.com">Mono-list@ximian.com</A>
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>

------=_NextPart_000_0003_01C194DD.E0B535E0
Content-Type: text/plain;
	name=&quot;XmlException.cs&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename=&quot;XmlException.cs&quot;

// -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
//
// System.Xml.XmlException
//
// Author:
//   Daniel Weber (<A HREF="mailto:daniel-weber@austin.rr.com">daniel-weber@austin.rr.com</A>)
//
// (C) 2001 Daniel Weber

using System;
using System.Runtime.Serialization;

namespace System.Xml
{
	/// &lt;summary&gt;
	/// Abstract class XmlNodeList.
	/// &lt;/summary&gt;
	public class XmlException : SystemException
	{
		// Private data members
		int FlineNumber;
		int FlinePosition;
		string Fmessage;

		// public properties
		/// &lt;summary&gt;
		/// Get the line number where the exception occured
		/// &lt;/summary&gt;
		public int LineNumber=20
		{
			get
			{
				return FlineNumber;
			}
		}

		/// &lt;summary&gt;
		/// Get the line position where the exception occured.
		/// &lt;/summary&gt;
		public int LinePosition=20
		{
			get
			{
				return FlinePosition;
			}
		}

		/// &lt;summary&gt;
		/// Get the error message describing the exception.
		/// &lt;/summary&gt;
		public override string Message=20
		{
			get
			{
				return Fmessage;
			}
		}

		// Public Methods

		// Constructors
		/// &lt;summary&gt;
		/// Create a new XmlException object.
		/// &lt;/summary&gt;
		/// &lt;param name=3D&quot;info&quot;&gt;The serializatin object holding all exception =
information.&lt;/param&gt;
		/// &lt;param name=3D&quot;context&quot;&gt;The streaming context containing the =
context of the error&lt;/param&gt;
		public XmlException(
			SerializationInfo info,
			StreamingContext context
			)
		{
			FlineNumber =3D info.GetInt32(&quot;lineNumber&quot;);
			FlinePosition =3D info.GetInt32(&quot;linePosition&quot;);
			Fmessage =3D info.GetString(&quot;message&quot;);

		}

		/// &lt;summary&gt;
		/// Create a new XmlException
		/// &lt;/summary&gt;
		/// &lt;param name=3D&quot;message&quot;&gt;Description of error&lt;/param&gt;
		/// &lt;param name=3D&quot;innerException&quot;&gt;Exception causing error.  Value can =
be null.&lt;/param&gt;
		public XmlException(
			string message,
			Exception innerException
			)
		{
			Fmessage =3D message;
		}

		/// &lt;summary&gt;
		/// Create a new XmlException
		/// &lt;/summary&gt;
		/// &lt;param name=3D&quot;message&quot;&gt;Description of error&lt;/param&gt;
		public XmlException(
			string message
			)
		{
			Fmessage =3D message;
		}
	}
}

------=_NextPart_000_0003_01C194DD.E0B535E0
Content-Type: text/plain;
	name=&quot;XmlInputSource.cs&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename=&quot;XmlInputSource.cs&quot;

// -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
//
// System.Xml.XmlInputSource.cs
//	port of Open Xml TXmlInputSource class
//
// Author:
//   Daniel Weber (<A HREF="mailto:daniel-weber@austin.rr.com">daniel-weber@austin.rr.com</A>
//
// (C) 2001 Daniel Weber
//	=09
//

using System;
using System.IO;

namespace System.Xml
{
	internal class XmlInputSource
	{
		private DomEncodingType Fencoding;

		private string FpublicID;
		private string FsystemID;
		public string FrootName;

		private Stream FStream;

		private bool FLastCharWasCR;

		// Buffer storage for UTF-8 surrogates
		// see <A HREF="http://www.ietf.org/rfc/rfc2279.txt">http://www.ietf.org/rfc/rfc2279.txt</A> for a complete description =
of UTF-8 encoding
		private int FLastUcs4;			=09


		//FLocator: TdomStandardLocator;

		// public properties
		=
//=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D
		public DomEncodingType encoding
		{
			get
			{
				return Fencoding;
			}
		}

		//property locator: TdomStandardLocator read FLocator;
		public string publicId
		{
			get
			{
				return FpublicID;
			}
		}

		public string rootName=20
		{
			get
			{
				return FrootName;
			}
		}

		public Stream stream
		{
			get
			{
				return FStream;
			}
		}

		public string streamAsWideString
		{
			get
			{
				return string.Empty;
				//wideString read getStreamAsWideString;
			}
		}

		public string systemId
		{
			get=20
			{
				return FsystemID;
			}
		}

		// private methods
		=
//=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D
		/// &lt;summary&gt;
		/// Analyze the first bytes of an XML document to try and determine =
encoding
		/// &lt;/summary&gt;
		/// &lt;returns&gt;Determined encoding type, defaults to UTF-8&lt;/returns&gt;
		private void setEncodingType()
		{
			try
			{
				byte[] buf =3D new byte[4];

				FStream.Seek(0, SeekOrigin.Begin);
				FStream.Read(buf, 0, 4);

				// UTF-16 code streams should begin with 0xfeff for big-endian =
systems
				//	or 0xfffe for little endian systems.
				// check that first....
				if ( (buf[0] =3D=3D 0xfe) &amp; (buf[1] =3D=3D 0xff) )
					Fencoding =3D DomEncodingType.etUTF16BE;
				else if ( (buf[0] =3D=3D 0xff) &amp; (buf[1] =3D=3D 0xfe) )
					Fencoding =3D DomEncodingType.etUTF16LE;
				else
				{
					// assume utf-8, look for encoding in &lt;?xml version=3D&quot;1.0&quot; =
encoding=3D&quot;ISO-8859-6&quot;&gt; tag, eg
					Fencoding =3D DomEncodingType.etUTF8;

					// Check if the stream begins with &lt;?[X|x][M|m][L|l]
					if ( (buf[0] =3D=3D 0x3c) &amp; (buf[1] =3D=3D 0x3f) &amp;			// &quot;&lt;?&quot;   =20
						((buf[2] =3D=3D 0x78) | (buf[2] =3D=3D0x58) ) &amp;		// &quot;x&quot; or &quot;X&quot;
						( (buf[2] =3D=3D 0x6d) | (buf[3] =3D=3D0x4d) ) &amp;		// &quot;m&quot; or &quot;M&quot;
						( (buf[2] =3D=3D 0x6c) | (buf[2] =3D=3D0x4c) ) )		// &quot;l&quot; or &quot;L&quot;
					{
					=09
						string tag =3D &quot;&quot;;
						while (FStream.Position !=3D FStream.Length)
						{
							char c =3D getNextChar();
							tag +=3D c;

							if (c  =3D=3D '&gt;')
								break;
						}

						// start from the location of &quot;encoding&quot;, and scan for quotes
						string encodeString =3D readEncodingAttrFromTag(tag);
						encodeString =3D encodeString.ToUpper();

						if ( (encodeString.IndexOf(&quot;ISO-8859-1&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;LATIN-1&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etLatin1;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-2&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;LATIN-2&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etLatin2;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-3&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;LATIN-3&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etLatin3;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-4&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;LATIN-4&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etLatin4;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-5&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;CYRILLIC&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etCyrillic;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-6&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;ARABIC&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etArabic;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-7&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;GREEK&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etGreek;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-8&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;HEBREW&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etHebrew;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-9&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;LATIN-5&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etLatin5;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-10&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;LATIN-6&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etLatin6;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-13&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;LATIN-7&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etLatin7;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-14&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;LATIN-8&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etLatin8;
						else if ( (encodeString.IndexOf(&quot;ISO-8859-15&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;LATIN-9&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etLatin9;
						else if (encodeString.IndexOf(&quot;KOI8-R&quot;) !=3D -1)
							Fencoding =3D DomEncodingType.etKOI8R;
						else if (encodeString.IndexOf(&quot;CP10000_MACROMAN&quot;) !=3D -1)
							Fencoding =3D DomEncodingType.etcp10000_MacRoman;
						else if ( (encodeString.IndexOf(&quot;Windows-1250&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;CP1250&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etcp1250;
						else if ( (encodeString.IndexOf(&quot;Windows-1251&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;CP1251&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etcp1251;
						else if ( (encodeString.IndexOf(&quot;Windows-1252&quot;) !=3D -1) |
							(encodeString.IndexOf(&quot;CP1252&quot;) !=3D -1) )
							Fencoding =3D DomEncodingType.etcp1252;
					}
				}

			}
			catch
			{
				Fencoding =3D DomEncodingType.etUTF8;
			}

			FStream.Seek(0, SeekOrigin.Begin);
		}

		/// &lt;summary&gt;
		/// Helper function to try and find the encoding attribute value in=20
		/// declaration tag.  Does not do well-formedness checks.
		/// &lt;/summary&gt;
		/// &lt;param name=3D&quot;tag&quot;&gt;string to scan&lt;/param&gt;
		/// &lt;exception cref=3D&quot;InvalidOperationException&quot;&gt;If bad encoding char =
found, mis-matched quotes, or no equals sign.&lt;/exception&gt;
		/// &lt;returns&gt;encoding, or string.Empty if it is not found.&lt;/returns&gt;
		private string readEncodingAttrFromTag( string tag )
		{
			int encodeIndex =3D tag.IndexOf(&quot;encoding&quot;);
			if ( encodeIndex =3D=3D -1)
				return string.Empty;
			else
			{
				int curIndex =3D encodeIndex + &quot;encoding&quot;.Length;
				bool firstQuoteFound =3D false;
				bool equalsFound =3D false;
				char quoteChar =3D (char) 0xffff;			// c# insists on =
initialization...
				string encoding =3D &quot;&quot;;

				while ( curIndex !=3D tag.Length )
				{
					char c =3D tag[curIndex];
					curIndex++;

					if ( c =3D=3D '=3D')
					{
						equalsFound =3D true;
						continue;
					}

					if ( (c=3D=3D '\&quot;') | (c=3D=3D'\'') )
					{
						if ( !firstQuoteFound &amp; !equalsFound)
							throw new InvalidOperationException(&quot;No equals sign found in =
encoding attribute&quot;);
						else if ( firstQuoteFound )
						{
							if (c =3D=3D quoteChar)
								return encoding;
							else
								throw new InvalidOperationException(&quot;non-matching quotes in =
attribute value&quot;);
						}
						else
						{
							firstQuoteFound =3D true;
							quoteChar =3D c;
							continue;
						}
					}
					else if (firstQuoteFound)
					{
						if ( ( c &gt;=3D 'a') &amp; ( c &lt;=3D 'z'))			encoding +=3D c;
						else if ( ( c &gt;=3D 'A') &amp; ( c &lt;=3D 'Z'))	encoding +=3D c;
						else if ( ( c &gt;=3D '0') &amp; ( c &lt;=3D '9'))	encoding +=3D c;
						else if ( c =3D=3D '_' )					encoding +=3D c;
						else if ( c =3D=3D '-')						encoding +=3D c;
						else if (c =3D=3D '.')						encoding +=3D c;
						else
							throw new InvalidOperationException(&quot;invalid character in =
encoding attribute&quot;);
					}
				}
				return string.Empty;
			}
		}
	=09

		/// &lt;summary&gt;
		/// Return true if input stream is at EOF.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public bool atEOF()
		{
			return (FStream.Length =3D=3D FStream.Position);
		}
=09
		/// &lt;summary&gt;
		/// Sets the internal root name by analyzing the tags at the beginning =
of the stream.
		/// root name is:
		/// - the element tag of the first element found
		/// - the root name listed in a !DOCTYPE tag
		/// - empty if a parse error occurs, or no applicable tags are found.
		/// Does not do well-formedness checks - skips comments and proc. =
instructions
		/// &lt;/summary&gt;
		private void getRootName()
		{
			reset();
			FrootName =3D string.Empty;
		=09
			while ( ! atEOF() )
			{
				string tag =3D &quot;&lt;&quot;;
				char c =3D getNextChar();

				// skip whitespace to first tag
				while ( !atEOF() &amp;&amp; (XmlNames_1_0.IsXmlWhiteSpace( c )) )
					c =3D getNextChar();
				if ( (c !=3D '&lt;') | atEOF() ) break;

				while ( !atEOF() &amp; ( c !=3D '&gt;' ) )
				{
					c =3D getNextChar();
					tag +=3D c;
				}
				if ( atEOF() ) break;

				// Only allow 1) comments, 2) processing instructions before =
&lt;!DOCTYPE ...&gt;
				if ( tag.StartsWith(&quot;&lt;?&quot;) )				// Processing instruction
					continue;
				else if ( tag.StartsWith(&quot;&lt;--&quot;) )		// comment
					continue;
				else if ( tag.StartsWith(&quot;&lt;!DOCTYPE&quot;) )	// what we're looking for...
				{
					setRootName( tag );
					break;
				}
					// no DOCTYPE tag?  Use the first element tag as the root
				else if ( tag.StartsWith( &quot;&lt;&quot; ) )
					setRootName( tag );
					// we hit a non-comment, processing instruction or declaration, we =
ain't gonna get it
				else
				{
					FrootName =3D string.Empty;
					break;
				}
			}
		}

		private void setRootName( string doctypeTag )
		{
			int start =3D doctypeTag.IndexOf(&quot;&lt;DOCTYPE&quot;);
			if ( start =3D=3D -1 )=20
				start =3D 1;				// set from element
			else
				start +=3D &quot;&lt;DOCTYPE&quot;.Length;
			while ( ( start !=3D doctypeTag.Length ) &amp; =
XmlNames_1_0.IsXmlWhiteSpace( doctypeTag[start] ) )
				start++;
		=09
			string tmp =3D string.Empty;

			while ( ( start !=3D doctypeTag.Length ) &amp;&amp;=20
				!XmlNames_1_0.IsXmlWhiteSpace(doctypeTag[start])  &amp;&amp;
				(doctypeTag[start] !=3D '&gt;') &amp;&amp;
				(doctypeTag[start] !=3D '[') &amp;&amp;=20
				(doctypeTag[start] !=3D '/') )
				tmp +=3D doctypeTag[start];

			if (XmlNames_1_0.isXmlName(tmp) ) FrootName =3D tmp;
		}

		/// &lt;summary&gt;
		/// Read in the next character (either UTF-8 or UTF-16) and convert by =
charset
		/// Normalize CR/LF pairs to single CR.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public char getNextChar()
		{
			byte[] buf =3D new byte[2];
			char retval =3D (char) 0xffff;
			int bCount;

			switch(Fencoding)
			{
				case DomEncodingType.etLatin1:
					bCount =3D stream.Read(buf,0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_1ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etLatin2:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_2ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etLatin3:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_3ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etLatin4:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_4ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etCyrillic:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_5ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etArabic:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_6ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etGreek:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_7ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etHebrew:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_8ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etLatin5:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_9ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etLatin6:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_10ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etLatin7:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_13ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etLatin8:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_14ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etLatin9:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.Iso8859_15ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etKOI8R:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.KOI8_RToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etcp10000_MacRoman:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.cp10000_MacRomanToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etcp1250:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.cp1250ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etcp1251:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.cp1251ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etcp1252:
					bCount =3D stream.Read(buf, 0, 1);
					if (bCount =3D=3D 1)=20
						retval =3D XmlUtil.cp1252ToUTF16Char(buf[0]);
					break;
				case DomEncodingType.etUTF8:
					if ( FLastUcs4 &gt;=3D 0x10000)
					{
						// Output low surrogate
						retval =3D XmlUtil.Utf16LowSurrogate(FLastUcs4);
						FLastUcs4 =3D 0;
					}
					else
					{
						FLastUcs4 =3D XmlUtil.ReadUTF8Char( stream );
						if ( FLastUcs4 &gt;=3D 0x10000)
							retval =3D XmlUtil.Utf16HighSurrogate(FLastUcs4);
						else
							retval =3D (char) FLastUcs4;
					}
					break;
				case DomEncodingType.etUTF16BE:
					bCount =3D stream.Read(buf, 0, 2);
					if (bCount =3D=3D 2)
						retval =3D System.Convert.ToChar( (buf[0] &lt;&lt; 16) + buf[1] );
					break;
				case DomEncodingType.etUTF16LE:
					bCount =3D stream.Read(buf, 0, 2);
					if (bCount =3D=3D 2)
						retval =3D System.Convert.ToChar( (buf[1] &lt;&lt; 16) + buf[0] );
					break;
			}

			// normalize CRLF or a single CR to LF:
			if ( (retval =3D=3D 0x000D) &amp; FLastCharWasCR)		// 0x000d =3D CR
			{
				FLastCharWasCR =3D false;
				return getNextChar();
			}
			else if ( retval =3D=3D 0x000A)						// 0x000a =3D LF
			{
				FLastCharWasCR =3D true;
				return (char) 0x000D;
			}
			else
				FLastCharWasCR =3D false;
			return retval;
 =20
			//  if assigned(locator) then locator.evaluate(dest);
		}

		/// &lt;summary&gt;
		/// Reset the Input to the origin and clear internal variables.
		/// &lt;/summary&gt;
		public void reset()
		{
			FLastUcs4 =3D 0;
			FLastCharWasCR =3D false;

			switch(Fencoding)
			{
					// skip the leading 0xfeff/oxfffe on UTF-16 streams
				case DomEncodingType.etUTF16BE:
					FStream.Seek(2, SeekOrigin.Begin);
					break;
				case DomEncodingType.etUTF16LE:
					FStream.Seek(2, SeekOrigin.Begin);
					break;
				default:
					FStream.Seek(0, SeekOrigin.Begin);
					break;
			}
		}
       =20
		/*
		 * private
   =20

		  protected
			function getStreamAsWideString: wideString; virtual;
			procedure skipTextDecl(const locator: TdomStandardLocator); virtual;
		  public
			constructor create(const stream: TStream;
							   const publicId,
									 systemId: wideString); virtual;
			destructor destroy; override;


		*/
		// Constructor
		=
//=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D
		XmlInputSource(Stream inputStream, string publicID, string systemID)
		{
			if (inputStream =3D=3D null)
				throw new NullReferenceException(&quot;Null stream passed to =
XmlInputSource constructor&quot;);

			FStream =3D inputStream;
			FLastUcs4 =3D 0;
			FLastCharWasCR =3D false;
			FpublicID =3D publicID;
			FsystemID =3D systemID;
			setEncodingType();
			//FLocator:=3D TdomStandardLocator.create(self);
			getRootName();
		}

		public void pieceStart()
		{
		}
	}
}

------=_NextPart_000_0003_01C194DD.E0B535E0
Content-Type: text/plain;
	name=&quot;XmlParser.cs&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename=&quot;XmlParser.cs&quot;

// -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
//
// internal System.Xml.XmlParser
//
// Author:
//   Daniel Weber (<A HREF="mailto:daniel-weber@austin.rr.com">daniel-weber@austin.rr.com</A>)
//
// (C) 2001 Daniel Weber
//

using System;
using System.Collections;

namespace System.Xml
{
	internal class XmlParser
	{
		// Private data members
		XmlDocument Fdoc;
		XmlInputSource Fsrc;

		// Elements push themselves on on start, pop on complete
		Stack RefNodes;

		// private classes
		private enum DomPieceType
		{
			xmlProcessingInstruction,
			xmlXmlDeclaration,
			xmlTextDeclaration,
			xmlComment,xmlCDATA,
			xmlPCDATA,
			xmlDoctype,
			xmlStartTag,
			xmlEndTag,
			xmlEmptyElementTag,
			xmlCharRef,
			xmlEntityRef,
			xmlParameterEntityRef,
			xmlEntityDecl,
			xmlElementDecl,
			xmlAttributeDecl,
			xmlNotationDecl,
			xmlCondSection,
			xmlUnknown,

		}

		// constants
		private const char CR =3D (char) 0x0D;
		private const char LF =3D (char) 0x0A;
		private const char QM =3D '?';
		private const char AMP =3D '&amp;';
		private const char GTCODE =3D '&lt;';
		private const char LTCODE =3D '&gt;';
		private const char SINGLEQUOTE =3D (char) 0x39;	// '
		private const char DOUBLEQUOTE =3D (char) 0x34;	// &quot;
		private const char NUMBERSIGN =3D (char) 0x35;	// #
		private const char SLASH =3D (char) 0x47;			// /
		private const string PISTART =3D &quot;&lt;?&quot;;
		private const string PIEND =3D &quot;?&gt;&quot;;
		private const string XMLDECLSTART =3D &quot;&lt;?xml&quot;;
		private const string COMMENTSTART =3D &quot;&lt;!--&quot;;
		private const string CDATASTART =3D &quot;&lt;![CDATA[&quot;;
		private const string DOCTYPESTART =3D &quot;&lt;!DOCTYPE&quot;;

		// private properties
		private XmlNode refNode
		{
			get
			{
				Object e =3D RefNodes.Peek();
				if ( e =3D=3D null )
					return null;
				else
					return e as XmlNode;
			}
		}

		// public properties

		// public methods
		public bool parse()
		{
			bool retval =3D true;
			XmlException parseError =3D null;
			bool singleQuoteOpen =3D false;
			bool doubleQuoteOpen =3D false;
			bool bracketOpen =3D false;
			string content =3D &quot;&quot;;
			DomPieceType pieceType =3D DomPieceType.xmlUnknown;=20
			string subEndMarker =3D &quot;&quot;;
			string subStartMarker =3D &quot;&quot;;

			try
			{
				while ( !Fsrc.atEOF() )
				{
					if ( parseError !=3D null) break;

					char c =3D Fsrc.getNextChar();

					if ( !XmlNames_1_0.IsXmlChar(c) )
					{
						content +=3D c;
						throw new XmlException(&quot;'Invalid character error.'&quot; + Fsrc);
					}
         =20
					switch (pieceType)
					{
						case DomPieceType.xmlUnknown:
							if ( c =3D=3D GTCODE)
								pieceType =3D DomPieceType.xmlStartTag;
							else if ( c =3D=3D AMP)
								pieceType =3D DomPieceType.xmlEntityRef;
							else
								pieceType =3D DomPieceType.xmlPCDATA;
							content +=3D c;
							Fsrc.pieceStart();
							break;

						case DomPieceType.xmlPCDATA:
							if ( c =3D=3D GTCODE )
							{
								parseError =3D writePCDATA(content);
								content =3D &quot;&quot;;
								pieceType =3D DomPieceType.xmlStartTag;
								Fsrc.pieceStart();
							}
							else if ( c =3D=3D AMP)
							{
								parseError =3D writePCDATA(content);
								content =3D &quot;&quot;;
								pieceType =3D DomPieceType.xmlEntityRef;
								Fsrc.pieceStart();
							}
							content +=3D c;
							break;

						case DomPieceType.xmlEntityRef:
                            content +=3D c;
							if ( c =3D=3D ';' )
							{
								if ( content[2] =3D=3D NUMBERSIGN )
									parseError =3D writeCharRef(content);
								else
									parseError =3D writeEntityRef(content);
								content =3D &quot;&quot;;
								pieceType =3D DomPieceType.xmlUnknown;
							}
							break;

						case DomPieceType.xmlStartTag:
                            content +=3D c;
							switch( content.Length)
							{
								case 2:
									if (content.StartsWith(PISTART))
										pieceType =3D DomPieceType.xmlProcessingInstruction;
									break;
								case 4:
									if (content.StartsWith(COMMENTSTART))
										pieceType =3D DomPieceType.xmlComment;
									break;
								case 9:
									if (content.StartsWith(CDATASTART))
										pieceType =3D DomPieceType.xmlCDATA;
									else if (content.StartsWith(DOCTYPESTART))
									{
										pieceType =3D DomPieceType.xmlDoctype;
										subEndMarker =3D &quot;&quot;;
										subStartMarker =3D &quot;&quot;;
										bracketOpen =3D false;
									}
									break;
							}

							// Count quotation marks:
							if ((c =3D=3D SINGLEQUOTE) &amp;&amp; (! doubleQuoteOpen))
								singleQuoteOpen =3D ! singleQuoteOpen;
							else if ((c =3D=3D DOUBLEQUOTE) &amp;&amp; (! singleQuoteOpen))
								doubleQuoteOpen =3D ! doubleQuoteOpen;
							else if (c =3D=3D LTCODE)
							{
								if ((! doubleQuoteOpen) &amp;&amp; (! singleQuoteOpen))
								{
									if (content[2] =3D=3D SLASH)
									{
										int l =3D content.Length;
										int offset =3D 3;
										// eliminate white-space after tag name:
										while ((l-offset &gt; 0) &amp;&amp; =
XmlNames_1_0.IsXmlWhiteSpace(content[l-offset+2]))
											offset++;
										parseError =3D writeEndElement(content.Substring(3, =
l-offset));
									}
									else=20
									{
										if (content[content.Length-1] =3D=3D SLASH)
											parseError =3D writeEmptyElement(content.Substring(2, =
content.Length-3));
										else=20
											parseError =3D writeStartElement(content.Substring(2, =
content.Length-2));
									}
									content =3D &quot;&quot;;
									pieceType =3D DomPieceType.xmlUnknown;
								}
							}
							break;

						//&lt;?PINAME ?&gt;
						case DomPieceType.xmlProcessingInstruction:
							content +=3D c;
							if ( c =3D=3D LTCODE )
								if (content[content.Length-1] =3D=3D QM)
								{
									if ( (content.Length &gt; 5) &amp;&amp;
										(XmlNames_1_0.IsXmlWhiteSpace(content[6])) &amp;&amp;
										(content.StartsWith(XMLDECLSTART)) )
										parseError =3D writeXmlDeclaration(content.Substring(3, =
content.Length-4));
									else
										parseError =3D writeProcessingInstruction(content.Substring(3, =
content.Length-4));
								content =3D &quot;&quot;;
								pieceType =3D DomPieceType.xmlUnknown;
								}
							break;

						    =20
						case DomPieceType.xmlComment:
							content +=3D c;
                            if (c =3D=3D LTCODE)
								if ( (content.EndsWith(&quot;--&gt;&quot;) ) &amp;&amp; (content.Length &gt; 6) )
								{
									parseError =3D writeComment(content.Substring(5, =
content.Length-7));
									content =3D &quot;&quot;;
									pieceType =3D DomPieceType.xmlUnknown;
								}
							break;

						case DomPieceType.xmlCDATA:
							content +=3D c;
							if (c =3D=3D LTCODE )
							{
								if (content[content.Length-1] =3D=3D ']' )
									if (content[content.Length-2] =3D=3D ']')
									{
										parseError =3D writeCDATA(content.Substring(10, =
content.Length-12));
										content =3D &quot;&quot;;
										pieceType =3D DomPieceType.xmlUnknown;
									}
							}
							break;

						case DomPieceType.xmlDoctype:
							content +=3D c;
							if (subEndMarker =3D=3D &quot;&quot;)
							{
								if ( (c =3D=3D SINGLEQUOTE) &amp;&amp; (! doubleQuoteOpen))
								{
									singleQuoteOpen =3D !singleQuoteOpen;
								}=20
								else if ( (c =3D=3D DOUBLEQUOTE) &amp;&amp; (! singleQuoteOpen))
								{
									doubleQuoteOpen =3D ! doubleQuoteOpen;
								}

								if (bracketOpen)
								{
									if (! (singleQuoteOpen | doubleQuoteOpen) )=20
									{
										if (c =3D=3D GTCODE)=20
										{
											subStartMarker =3D &quot;&lt;&quot;;
										}
										else if ( (c =3D=3D '!') &amp;&amp; (subStartMarker =3D=3D &quot;&lt;&quot;))
										{
											subStartMarker =3D &quot;&lt;&quot;;
										}
										else if ( (c =3D=3D QM) &amp;&amp; (subStartMarker =3D=3D &quot;&lt;&quot;) )
										{
											subStartMarker =3D &quot;&quot;;
											subEndMarker =3D PIEND;
										}
										else if ((c =3D=3D '-') &amp;&amp; (subStartMarker =3D=3D &quot;&lt;!&quot;))
										{
											subStartMarker =3D &quot;&lt;!-&quot;;
										}
										else if ((c =3D=3D '-') &amp;&amp; (subStartMarker =3D=3D &quot;&lt;!-&quot;))
										{
											subStartMarker =3D &quot;&quot;;
											subEndMarker =3D &quot;--&gt;&quot;;
										}
										else if (subStartMarker !=3D &quot;&quot;)
										{
											subStartMarker =3D &quot;&quot;;
										}
                                       =20
										if ((c =3D=3D ']') &amp;&amp; (! singleQuoteOpen) &amp;&amp; (! =
doubleQuoteOpen))
											bracketOpen =3D false;
									}
								}
								else // if BracketOpened ...=20
								{
									if ((c =3D=3D '[') &amp;&amp; (! singleQuoteOpen) &amp;&amp; (! =
doubleQuoteOpen))
										bracketOpen =3D true;
								} =20
							}	//if BracketOpened ... else ...
							else // if (SubEndMarker =3D '') ...
							{
								if (content.EndsWith(subEndMarker))
									subEndMarker =3D &quot;&quot;;
							}	//if (SubEndMarker =3D '') ... else ...

							if ((! doubleQuoteOpen) &amp;&amp; (! singleQuoteOpen) &amp;&amp; (! bracketOpen) =
&amp;&amp;=20
								(subEndMarker =3D=3D &quot;&quot;) &amp;&amp; (c =3D=3D '&gt;'))
							{
								parseError =3D writeDoctype(content);
								content =3D &quot;&quot;;
								pieceType =3D DomPieceType.xmlUnknown;
							}
							break;

						}	// switch
				}	// while more characters

				if (parseError =3D=3D null)
					if (content.Length &gt; 0)
						parseError =3D writePCDATA(content);
			}		// try
			catch=20
			{
				// we need to raise the exception again, converted to an =
XmlException
				/*
					  except
						on EConvertError do raise =
EParserInvalidCharacter_Err.create('Invalid character error.');
						on EReadError do raise EParserInvalidCharacter_Err.create('Invalid =
character error.');
					  end; {try ...}
					except
					  on E: EParserInvalidCharacter_Err do
						parserError:=3D parserErrorFactory(sender,inputSource.Locator,
														 EParserInvalidCharacter_Err.create('Invalid character =
error.'),
														 '');
   =20
				*/
			}

			if (parseError !=3D null)
			{
				// Deal with the error, somehow
				retval =3D false;
			}
			return retval;
		}


		// private methods
		private XmlException writePCDATA(string content)
		{
			return null;
		}

		private XmlException writeEntityRef(string content)
		{
			string entityName =3D content.Substring(2, content.Length - 2);
			return null;
		}

		private XmlException writeCharRef( string content)
		{
			return null;
		}

		private XmlException writeEndElement( string content)
		{
			return null;
		}

		private XmlException writeEmptyElement( string content)
		{
			return null;
		}

		private XmlException writeStartElement( string content)
		{
			return null;
		}

		private XmlException writeComment( string content)
		{
/*
 procedure TdomStandardIntSubsetBuilder.comment(const sender: =
TdomCustomParser;
                                               const locator: =
TdomStandardLocator;
                                               const data: wideString);
var
  newComment: TdomCMComment;
begin
  if not assigned(FRefNode) then exit;
  try
    newComment:=3D FRefNode.OwnerCMObject.CreateCMComment(data);
    try
      FRefNode.appendChild(newComment);
    except
      if assigned(newComment.ParentNode)
        then newComment.ParentNode.RemoveChild(newComment);
      FRefNode.OwnerCMObject.FreeAllCMNodes(TdomCMNode(newComment));
      raise;
    end; {try ...}
  except
    raise EParserInvalidCharacter_Err.create('Invalid character =
error.');
  end; {try ...}
end;

function TXmlDocBuilder.comment(const sender: TXmlCustomProcessorAgent;
                                const locator: TdomStandardLocator;
                                      data: wideString): =
TXmlParserError;
var
  newComment: TdomComment;
begin
  if assigned(FOnComment) then FOnComment(sender,locator,data);
  result:=3D nil;
  if assigned(FRefNode) then begin
    try
      newComment:=3D FRefNode.OwnerDocument.CreateComment(data);
      try
        FRefNode.appendChild(newComment);
      except
        if assigned(newComment.ParentNode)
          then newComment.ParentNode.RemoveChild(newComment);
        FRefNode.OwnerDocument.FreeAllNodes(TdomNode(newComment));
        raise;
      end; {try ...}
    except
      result:=3D parserErrorFactory(sender,locator,
                                  =
EParserInvalidComment_Err.create('Invalid comment error.'),
                                  data);
    end; {try ...}
  end; {if assigned(FRefNode) ...}

  if not assigned(result)
    then if assigned(nextHandler)
      then result:=3D nextHandler.comment(sender,locator,data);
end;


function TXmlWFTestContentHandler.comment(const sender: =
TXmlCustomProcessorAgent;
                                          const locator: =
TdomStandardLocator;
                                                data: wideString): =
TXmlParserError;
var
  dataLength: integer;
begin
  if assigned(FOnComment) then FOnComment(sender,locator,data);
  if not FIsActive
    then raise EParserException.Create('TXmlWFTestContentHandler not =
active.');
  result:=3D nil;
  FXMLDeclarationAllowed:=3D false;

  if pos('--',data) &gt; 0
    then result:=3D parserErrorFactory(sender,locator,
                                     =
EParserInvalidComment_Err.create('Invalid comment error.'),
                                     '--');
  dataLength:=3D length(data);
  if dataLength &gt; 0
    then if WideChar(data[dataLength]) =3D '-'
      then if not assigned(result)
        then result:=3D parserErrorFactory(sender,locator,
                                         =
EParserInvalidComment_Err.create('Invalid comment error.'),
                                         '-');
  if not IsXmlChars(data)
    then if not assigned(result)
      then result:=3D parserErrorFactory(sender,locator,
                                       =
EParserInvalidCharacter_Err.create('Invalid character error.'),
                                       data);

  if not assigned(result)
    then if assigned(nextHandler)
      then result:=3D nextHandler.comment(sender,locator,data);
end;


*/
			return null;
		}


		private XmlException writeXmlDeclaration ( string content)
		{
			return null;
		}

		private XmlException writeProcessingInstruction( string content)
		{
			return null;
		}

		private XmlException writeCDATA( string content)
		{
			return null;
		}

		private XmlException writeDoctype( string content)
		{
			return null;
		}

		private void mainLoop()
		{
		}

		// Constructors
		public XmlParser ( XmlInputSource src, XmlDocument doc )
		{
			Fsrc =3D src;
			Fdoc =3D doc;
			RefNodes =3D new Stack();
		}

	}
}

------=_NextPart_000_0003_01C194DD.E0B535E0--



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="002533.html">[Mono-list] class libs .. some progress..
</A></li>
	<LI> Next message: <A HREF="002577.html">[Mono-list] class libs .. some progress..
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2535">[ date ]</a>
              <a href="thread.html#2535">[ thread ]</a>
              <a href="subject.html#2535">[ subject ]</a>
              <a href="author.html#2535">[ author ]</a>
         </LI>
       </UL>
</body></html>
