<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] PDF creation library for Mono?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:willems%40digicore.co.za">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="023582.html">
   <LINK REL="Next"  HREF="023614.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] PDF creation library for Mono?
   </H1>
    <B>Willem J.W. Semmelink
    </B> 
    <A HREF="mailto:willems%40digicore.co.za"
       TITLE="[Mono-list] PDF creation library for Mono?">willems@digicore.co.za
       </A><BR>
    <I>Tue, 5 Oct 2004 09:12:18 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="023582.html">[Mono-list] PDF creation library for Mono?
</A></li>
        <LI> Next message: <A HREF="023614.html">[Mono-list] PDF creation library for Mono?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23596">[ date ]</a>
              <a href="thread.html#23596">[ thread ]</a>
              <a href="subject.html#23596">[ subject ]</a>
              <a href="author.html#23596">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> -----Original Message-----
</I>&gt;<i> From: Marek Habersack [mailto:<A HREF="mailto:grendel@caudium.net">grendel@caudium.net</A>]=3D20
</I>&gt;<i> Sent: Tuesday, 5 October 2004 10:31 AM
</I>&gt;<i> To: <A HREF="mailto:mono-list@lists.ximian.com">mono-list@lists.ximian.com</A>
</I>&gt;<i> Subject: [Mono-list] PDF creation library for Mono?
</I>&gt;<i>=3D20
</I>&gt;<i> Hello,
</I>&gt;<i>=3D20
</I>&gt;<i>   I was wondering whether anyone knows about a free, managed=3D20
</I>&gt;<i> PDF creation library that works with Mono? I've googled for=3D20
</I>

Hi Marek
I attach a class below that I am currently working on. I give it away as =
GPL.=20
I have no project registered for it (yet), but feel free to send me bug =
reports and suggestions via email.


This is how you use the class:

PDFExport expt =3D new PDFExport();
String filename =3D &quot;Test.pdf&quot;;
//Assign Info and other properties before beginning the export
expt.Information.Title =3D &quot;Document Title&quot;;
expt.Information.Subject=3D&quot;Document Subject&quot;;
expt.Information.AuthorName =3D &quot;Willem&quot;;
expt.Information.Keywords =3D &quot;Test Export&quot;;
expt.Information.Creator =3D &quot;My Test Program&quot;;
expt.PageSize =3D SBReport.Export.PageSizes.pgA4;
if (Strm=3D=3Dnull)
	expt.BeginExport(filename); //Illustrate export to file
else {
	expt.BeginExport(Strm);	//Illustrate export to stream (2nd HTML =
example)
}=20
	expt.NewPage();		=09
expt.WriteText(&quot;Toets A&quot;,20,10,&quot;Arial&quot;,10);
expt.WriteText(&quot;Toets B&quot;,40,20,&quot;Times New Roman&quot;,10);
expt.WriteText(&quot;Toets C&quot;,60,40,&quot;Courier New&quot;,10);
expt.WriteText(&quot;Willem Semmelink&quot;,120,80,&quot;Script&quot;,20);
expt.DrawVLine(150,150,200);
SBReport.RptColour clr =3D new SBReport.RptColour(250,0,0);
System.Drawing.Color fillclr =3D System.Drawing.Color.Aquamarine;
expt.DrawHLine(155,150,200,LineStyles.Dash,2,clr);
expt.DrawRectangle(200,200,300,120,LineStyles.Solid,2,clr,fillclr,FillPat=
terns.DiagCrossLines);
expt.NewPage();
fillclr =3D System.Drawing.Color.DarkOrchid;
expt.WriteText(&quot;Sonya Semmelink&quot;,120,80,&quot;Arial&quot;,20);
expt.DrawHLine(50,150,200);
expt.DrawVLine(50,150,200,LineStyles.Dots,1,clr);
expt.DrawRectangle(200,200,300,120,LineStyles.Solid,2,clr,fillclr,FillPat=
terns.HorizLines);
expt.EndExport();
System.Console.WriteLine(filename + &quot; was created&quot;);

Regards
Willem Semmelink


//Below follows the PDF class:
using System;
//using System.FileStream;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
namespace SBReport.Export
{
	/// &lt;summary&gt;
	/// Summary description for Class.
	/// &lt;/summary&gt;
	public class PDFExport : IExportInterface
	{
		public PDFExport()
		{
		}
	=09
		#region Properties=20
			=09
		#endregion

		#region Public methods
	=09
		//Code common to both public BeginExport methods
		protected override void OnStartDoc()
		{
			//Initialize all data
			xrefTable =3D new ArrayList();			// Table containing object offsets			=
		=09
			//PDFWriter =3D new =
System.IO.StreamWriter(PDFOutStream,System.Text.Encoding.ASCII);
			m_PageObjRefs=3D&quot;&quot;;							// Clear the page references				=09
			m_StartXOffs=3D0;								// Reset startxref value
			m_LastObjId=3D-1;								// Reset object count
			m_PagesCount=3D0;								// Reset number of pages in doc
			m_PageContents=3D&quot;&quot;;							// Clean curent page contents
			m_Offset =3D 10;								// PDF header contains 0...9 bytes, incl CRLF
														// so the first object will write at position 10
			m_PageProcSetPatterns=3D&quot;&quot;;					// Clear patterns for current page
			m_IsFirstPage=3Dtrue;							// Is the first page of the document
			m_Patterns =3D new ArrayList();				// Table containing pattern IDs
			foreach(int i in Enum.GetValues(typeof(FillPatterns)))		=09
			{ //Create an empty array item (i.e. value of 0) for each enumerated =
pattern
				m_Patterns.Add(0);						=20
			}				=09
			m_Fonts=3Dnew Hashtable();					//Start with no fonts in document
			m_PageFonts=3D&quot;&quot;;								//No fonts on current page
		=09
			//Start writing to the stream				//PDF Spec Paragraph 5.13	=09
			StreamWrite(&quot;%PDF-1.3&quot; + CRLF);				// Write the PDF header
			xrefTable.Add(GetNewObjID());				// First Object has offset of 0				=09
	=09
			//Get Object reference for Pages object [it is written at end of doc]
			m_PagesObjId =3D GetNewObjID();
		}
		//No XML comment - defined in parent
		protected override void OnEndDoc()
		{
			int rootObjectId,outlineObjectId;			=09

			//Finish the curent page____________________________
			FlushCurrentPage();

			//Write Pages Object________________________ Adobe Spec 6.3
			string text =3D &quot;/Type /Pages&quot; + CRLF +		//Write object type
				&quot;/Count &quot; + m_PagesCount.ToString();	//Number of pages in document
			text +=3D CRLF + &quot;/Kids [&quot; + m_PageObjRefs + &quot;]&quot;;	//Add references to =
all pages
					=09
			PDFWriteObj(m_PagesObjId,true,				//This object ID; dictionary&lt;&lt;, &gt;&gt;  =

				text);									//Contents of the pages object			=09

			//Write Outline Object_____________________  Adobe Spec 6.7
			outlineObjectId =3D GetNewObjID();			//Save obj ID of Outline object=20
			PDFWriteObj(								//Write Outlines Object
				outlineObjectId,true,					//This object number; dictionary&lt;&lt;, &gt;&gt;=20
				&quot;/Type /Outlines&quot; + CRLF +				//Write object type
				&quot;/Count 0&quot;);							//Empty object for now			=09

			//Write the root object_____________________ Adobe Spec 6.2
			rootObjectId =3D GetNewObjID();				//Save obj ID of catalog object as =
root		=09
			PDFWriteObj(								//Write Catalog Object
				rootObjectId,true,						//This object number; dictionary&lt;&lt;, &gt;&gt;=20
				&quot;/Type /Catalog&quot; + CRLF +				//Write object type
				&quot;/Pages &quot; + PDFObjRef(m_PagesObjId) + CRLF+	//Pages reference =3D 3		=
	=09
				&quot;/Outlines &quot; +PDFObjRef(outlineObjectId)+CRLF+ //Outlines reference =
=3D 2
				&quot;/Pagemode /UseOutlines&quot;);				//Start Acrobat Reader to view =
Outlines

			// Write final stuff to end the file properly
			int infoObjectID=3DWriteDocumentInfo();		//Write the document info =
object=09
			WriteCrossRef();							//Write the Cross Reference Table		=09
			WriteTrailer(rootObjectId,infoObjectID);	//Write the Trailer

			//Clean up memory that was used
			xrefTable.Clear();
		}

		//No XML comment - defined in parent
		public override void NewPage()
		{ =20
			if (! m_IsFirstPage) { //If this is not the first page, write =
previous page to stream
				FlushCurrentPage();
			}
			m_PageContents=3D&quot;&quot;;				//Start with a clean page contents object =
array
			m_PageProcSetPatterns=3D&quot;&quot;;		//Start with no patterns in ProcSet
			m_IsFirstPage=3Dfalse;			//Next time we call this function, we will =
flush crrent page
			m_PagesCount++;					//Increment pages counter
			m_PageFonts=3D&quot;&quot;;					//Start page with no fonts in resource list
		}
	=09
		//No XML comment - defined in parent
		public override void WriteText(string text,int left, int =
top,SBReport.Font font)
		{ //Adobe Specification Chapter 11
			string fontRef =3D PDFAddFont(font);  //Returns something like &quot;/F1&quot;
			int objId=3DGetNewObjID();
			int pgHeight =3D PAGE_DIMENSIONS[(int)m_PageSize,1];		=09
			PDFWriteStreamObj(objId,&quot;&quot;,
				            &quot;BT&quot; + CRLF +
							fontRef+&quot; &quot; + font.Size.ToString() + &quot; Tf&quot; + CRLF +=20
							&quot;-0.1940 Tc&quot; + CRLF + //Character spacing
							left.ToString() + &quot; &quot; +
							(pgHeight - top).ToString() + &quot; &quot; + //PDF measures from bottom of =
pg
							&quot;Td (&quot;+text+&quot;) Tj&quot; + CRLF +
							&quot;ET&quot; + CRLF				          =20
					);//PDFWriteObj
			if (m_PageContents.Length &gt; 0) {
					m_PageContents +=3D &quot; &quot;;
			}
			m_PageContents +=3D PDFObjRef(objId);
		}	=09
	=09

		public override void DrawHLine(int fromX, int fromY,int length,
			LineStyles style,int thickness,	RptColour clr )
		{
			DrawPDFLine(fromX,fromY,fromX+length,fromY,style,thickness,clr);
		}

		public override void DrawVLine(int fromX, int fromY,int length,
			LineStyles style,int thickness,
			RptColour clr
			)
		{
			DrawPDFLine(fromX,fromY,fromX,fromY+length,style,thickness,clr);
		}	=09
		=09
		//No XML comment - defined in parent
		public override void DrawRectangle(int left, int top,int width, int =
height,
				LineStyles style,int thickness, RptColour lineClr, RptColour =
fillClr,
				FillPatterns pattern)
		{ //Adobe specification Paragraph 7.1, Chapter 12
			int objId=3DGetNewObjID();
			int pgHeight =3D PAGE_DIMENSIONS[(int)m_PageSize,1];
			string widthstr =3D &quot;&quot;;
			string colorstr=3D  PDFColour(lineClr,true);
			string fillClrStr=3D&quot;&quot;;
			if (fillClr !=3Dnull) fillClrStr=3DPDFColour(fillClr,false);
			if (thickness &gt; 1) {widthstr =3D thickness.ToString() + &quot; w&quot; + CRLF;}
			string stylestr=3DPDFLineStyle(style);
			string patternStr =3D &quot;&quot;;
			string fillStr  =3D ((fillClr=3D=3Dnull)? &quot;S&quot;:&quot;B&quot;) + CRLF;
			if (pattern !=3D FillPatterns.Solid)=20
			{
				fillStr =3D &quot;S&quot; + CRLF;
				PDFFillPattern(pattern);					//Create a pattern object if it does =
not exist
				patternStr =3D //&quot;/Pattern cs /P&quot; +
						   &quot;/CS1 cs&quot; + CRLF +
						   String.Format(&quot;{0,4} {1,4} {2,4}&quot;,				=09
								((double)fillClr.Red/255),	//We do not use the PDFColour =
function
								((double)fillClr.Green/255),  //because we do not want the &quot;rg&quot; =
at the end
								((double)fillClr.Blue/255)) +
						   &quot; /P&quot; +=09
						  ((int) pattern).ToString() +
						  &quot; scn&quot; + CRLF +						=09
						  left.ToString() + &quot; &quot; +
						  (pgHeight-top).ToString() + &quot; &quot; +
						  width.ToString() + &quot; &quot; +
						  ( - height).ToString() + &quot; re&quot; + CRLF +
						  &quot;f&quot; + CRLF;						 =20
			}
			PDFWriteStreamObj(objId,&quot;&quot;,		=09
						patternStr +
						colorstr +=20
						fillClrStr+
						widthstr + stylestr +    =20
						left.ToString() + &quot; &quot; +
						(pgHeight-top).ToString() + &quot; &quot; +
						width.ToString() + &quot; &quot; +
						( - height).ToString() + &quot; re&quot; + CRLF +
						fillStr=09
				);//PDFWriteObj
			if (m_PageContents.Length &gt; 0)=20
			{
				m_PageContents +=3D &quot; &quot;;
			}
			m_PageContents +=3D PDFObjRef(objId);			=09
		}
=09
		#endregion Public Methods
		//---------------------------------------------------
		#region Private Functions/Methods

		/// &lt;summary&gt;
		/// Write an object to the PDF file and add it's offset to the
		/// xref table.
		/// &lt;/summary&gt;
		/// &lt;param name=3D&quot;objno&quot;&gt;Object number&lt;/param&gt;
		/// &lt;param name=3D&quot;dictionary&quot;&gt;Write &lt;c&gt;&lt;&lt;&lt;/c&gt; at start and &lt;c&gt;&gt;&gt;&lt;/c&gt; =
at end&lt;/param&gt;
		/// &lt;param name=3D&quot;dictionaryText&quot;&gt;Object contents - printed in =
dictionary&lt;/param&gt;
		private void PDFWriteObj(int objno,bool dictionary,string =
dictionaryText)
		{
			string txt =3D objno.ToString() + &quot; 0 obj&quot; + CRLF;
			if (dictionary) {=20
				txt +=3D &quot;&lt;&lt;&quot; + CRLF;=20
			}
			txt +=3D dictionaryText + CRLF;
			if (dictionary) {
				txt +=3D &quot;&gt;&gt;&quot; + CRLF;=09
			}
			//if (writeEndObj)=20
			//{
				txt +=3D &quot;endobj&quot;+ CRLF+CRLF;=20
			//}						=09
			xrefTable[objno] =3Dm_Offset;				//Insert offset at object index
			m_Offset +=3D txt.Length;					//Calculate offset for next object		=09
			StreamWrite(txt);
		}


		/// &lt;summary&gt;
		/// Write an object with an embedded stream
		/// &lt;/summary&gt;
		/// &lt;param name=3D&quot;objno&quot;&gt;Object ID&lt;/param&gt;
		/// &lt;param name=3D&quot;dictionaryText&quot;&gt;Object text - printed in =
dictionary&lt;/param&gt;
		/// &lt;param name=3D&quot;streamText&quot;&gt;Stream contents&lt;/param&gt;
		private void PDFWriteStreamObj(int objno, string dictionaryText, =
string streamText)
		{ //Adobe Specification Paragraph 4.8
			int streamLen =3D streamText.Length;
			string fullText =3D &quot;&lt;&lt; &quot; +=20
				(dictionaryText =3D=3D &quot;&quot;? &quot;&quot;:(CRLF+dictionaryText + CRLF)) +=20
				&quot;/Length &quot; + streamLen.ToString() +=20
				(dictionaryText =3D=3D &quot;&quot;? &quot; &gt;&gt;&quot;:CRLF+&quot;&gt;&gt;&quot;)+
				CRLF +
				&quot;stream&quot; + CRLF +
				streamText +=20
				&quot;endstream&quot;;		=09
			PDFWriteObj(objno,false,fullText);
		}
	=09

		//returns something like /F1 - reference to font by internal name
		private string PDFAddFont(SBReport.Font font)
		{
			/*const string widths =3D 		=09
				&quot;[278 278 355 556 556 889 667 190 333 333 389 &quot;+
				&quot;584 278 333 278 278 556 556 556 556 556 556 556 &quot;+
				&quot;556 556 556 278 278 584 584 584 556 1015 667 667 &quot;+
				&quot;722 722 667 610 778 722 278 500 667 556 832 722 &quot;+
				&quot;778 667 778 722 667 610 722 667 944 667 667 610 &quot;+
				&quot;278 278 278 469 556 333 556 556 500 556 556 278 &quot;+
				&quot;556 556 222 222 500 222 832 556 556 556 556 333 &quot;+
				&quot;500 278 556 500 722 500 500 500 334 260 334 584 &quot;+
				&quot;750 556 750 222 556 333 1000 556 556 333 1000 667 &quot;+
				&quot;333 1000 750 610 750 750 222 222 333 333 350 556 &quot;+
				&quot;1000 333 1000 500 333 944 750 500 667 278 333 556 &quot;+
				&quot;556 556 556 260 556 333 736 370 556 584 333 736 552 &quot;+
				&quot;400 549 333 333 333 576 537 278 333 333 365 556 834 &quot;+
				&quot;834 834 610 667 667 667 667 667 667 1000 722 667 667 &quot;+
				&quot;667 667 278 278 278 278 722 722 778 778 778 778 778 &quot;+
				&quot;584 778 722 722 722 722 667 667 610 556 556 556 556 &quot;+
				&quot;556 556 889 500 556 556 556 556 278 278 278 278 556 &quot;+
				&quot;556 556 556 556 556 556 549 610 556 556 556 556 500 556 500]&quot;;
			*/
			string fontReference;
			int fontObjectId;
			if(m_Fonts.ContainsKey(font.Name))
			{	//Font has been used before - return it's object ID
				string s =3D (string)m_Fonts[font.Name];
				fontReference=3Ds.Substring(0,s.IndexOf(&quot;,&quot;));
				fontObjectId=3Dint.Parse(s.Substring(s.IndexOf(&quot;,&quot;)+1));
			}=20
			else
			{	//Font not yet used, stream out its details=20
				fontObjectId=3DGetNewObjID();
				fontReference =3D &quot;/F&quot; + (m_Fonts.Count+1).ToString();			=09
				m_Fonts.Add(font.Name,fontReference+&quot;,&quot;+fontObjectId.ToString());	=
//Remember which fonts we streamed out

				SBReport.FontMetrics fontMetrics =3D font.CalcFontMetrics();
				int FontFlags =3D 0 +
					(fontMetrics.IsFixedWidth? 1:0) +
					(fontMetrics.IsSerif?		2:0) +
					(fontMetrics.IsSymbol?		4:0) +
					(fontMetrics.IsScript?		8:0) +
					(fontMetrics.IsSymbol?		0:32)+ //32 is on right: not symblic
					(font.Italic?				64:0);

				string widths =3D &quot;&quot;;
				for(int i =3D 32; i &lt;=3D 255; i++)
				{ //get the width of each character in the font
					widths +=3D fontMetrics.CharWidths[i].ToString() + &quot; &quot;;
				}

				//Adobe Spec 7.7
				int widthsObjID=3DGetNewObjID();
				int fontdescrID=3DGetNewObjID();
				PDFWriteObj(fontObjectId,true,			//font object id; dictionary:&lt;&lt;, &gt;&gt; =
=09
					/*	_________ Type 1 Font Descriptor  __________			=09
					 * &quot;/Type /Font&quot; + CRLF +				//Object type
					 * &quot;/Subtype /Type1&quot; + CRLF +				=09
					 *((font.Name=3D=3D&quot;Arial&quot;)? &quot;/BaseFont /Helvetica&quot; : &quot;/BaseFont =
/Times-Roman&quot;)
					 * */
				=09
					/*  _________ TrueType Font Descriptor _________*/
					&quot;/Type /Font&quot; + CRLF +				//Object type
					&quot;/Subtype /TrueType&quot; + CRLF +
					&quot;/Name &quot; + fontReference + CRLF +
					&quot;/BaseFont /&quot; + PDFFontName(font.Name) +  =20
						((font.Bold=3D=3Dtrue || font.Italic=3D=3Dtrue)?=20
						//true:	add font styles after font name
						&quot;,&quot; +=20
						(font.Bold=3D=3Dtrue? &quot;&quot;:&quot;Bold&quot;) +=20
						(font.Italic=3D=3Dtrue? &quot;&quot;:&quot;Italic&quot;)											=09
						//false: no font style added
						:&quot;&quot;)
						+ CRLF  +
					&quot;/Encoding /WinAnsiEncoding&quot; + CRLF +=20
						/* &quot;WinAnsiEncoding&quot;, &quot;MacRomanEncoding&quot;, &quot;MacExpertEncoding&quot;,
						 *  &quot;StandardEncoding&quot;, &quot;PDFDocEncoding&quot;
						 * */
					&quot;/FirstChar 32&quot; + CRLF +		//Replace with variable
					&quot;/LastChar  255&quot; + CRLF + 	//Replace with variable			=09
					//&quot;/Widths &quot; + PDFObjRef(widthsObjID) + CRLF+
					&quot;/Widths [&quot; + widths + &quot;]&quot;+ CRLF+
					&quot;/FontDescriptor &quot; + PDFObjRef(fontdescrID)
					); 							=09

				//PDFWriteObj(widthsObjID,true,widths);
				PDFWriteObj(fontdescrID,true,
					&quot;/Type /FontDescriptor&quot; + CRLF +				=09
					&quot;/FontName /&quot; + PDFFontName(font.Name) + CRLF + =20
					&quot;/Flags &quot; + FontFlags.ToString() + CRLF +
					&quot;/FontBBox [&quot;  +
							fontMetrics.FontBox.left + &quot; &quot; +
							fontMetrics.FontBox.top  + &quot; &quot; +
							fontMetrics.FontBox.right+ &quot; &quot; +
							fontMetrics.FontBox.bottom+ &quot;]&quot; + CRLF+
							//[-250 -144 2664 864]&quot; +CRLF+
					&quot;/Ascent &quot;+ fontMetrics.Ascent + CRLF +		//&quot;/Ascent 864&quot; + CRLF +
					&quot;/CapHeight &quot;+ fontMetrics.Ascent + CRLF +	//&quot;/CapHeight 864&quot; + =
CRLF +
					&quot;/Descent &quot;+fontMetrics.Descent + CRLF +	//&quot;/Descent -144&quot; + CRLF +	=
			=09
					&quot;/AvgWidth &quot;+fontMetrics.AvgWidth + CRLF +	//&quot;/AvgWidth 432&quot; + CRLF =
+
					&quot;/MaxWidth &quot;+fontMetrics.MaxWidth + CRLF +	//&quot;/MaxWidth 2664&quot; + =
CRLF +
					&quot;/StemV 0&quot; + CRLF +
					&quot;/ItalicAngle 0&quot;=09
					);
			}//if ContainsKey
		=09
			//Only add to page resources if it is not yet there
			if (m_PageFonts.IndexOf(fontReference) &lt; 0)	{=20
				m_PageFonts +=3D fontReference + &quot; &quot; + PDFObjRef(fontObjectId) + &quot; =
&quot;;
			}
			return fontReference;
		}

		//PDF does not like spaces in names like &quot;Times New Roman&quot;. Remove =
spaces
		private string PDFFontName(string oldName)
		{
			return oldName.Replace(&quot; &quot;,&quot;&quot;);
		}

		private void FlushCurrentPage()
		{ //Write the last (current) page to the stream,=20
			=20
			//ProcSet______________________________________ Adobe Spec 7.6
			int procset=3DGetNewObjID();
			string ProcSetText =3D&quot;/Font &lt;&lt; &quot; + m_PageFonts + &quot; &gt;&gt; &quot; + CRLF+
								&quot;/ProcSet [/PDF /Text /ImageC]&quot;;					=09
					=09
			if (m_PageProcSetPatterns.Length &gt;0)			//Adobe Spec Example 7.32
			{
				ProcSetText +=3D CRLF + &quot;/Pattern &lt;&lt; &quot; + m_PageProcSetPatterns + &quot; =
&gt;&gt;<i>&quot; + CRLF +
</I>					&quot;/ColorSpace &lt;&lt; /CS1 [/Pattern /DeviceRGB] &gt;&gt;&quot;;
			}		=09
			PDFWriteObj(procset,true,ProcSetText);=20
						=09
			//Page Object
			double pgWidth =3D PAGE_DIMENSIONS[(int)m_PageSize,0];
			double pgHeight =3D PAGE_DIMENSIONS[(int)m_PageSize,1];
			string text =3D &quot;/Type /Page&quot; + CRLF +	//Define object type
				&quot;/Parent &quot; + PDFObjRef(m_PagesObjId) + CRLF +=20
				&quot;/MediaBox [0 0 &quot; +=20
					pgWidth.ToString() + &quot; &quot; + 	//Define page size
					pgHeight.ToString() + &quot;]&quot; +	CRLF +
				&quot;/Resources &quot; + PDFObjRef(procset) + CRLF +=20
				//&quot;/Resources &lt;&lt; &quot; +
				//&quot;/Font &lt;&lt; /&quot; + fName + &quot; &quot; + PDFObjRef(fontid) + &quot; &gt;&gt; &quot; +
				//&quot;/ProcSet &quot; + PDFObjRef(procset) +	&quot;&gt;&gt;&quot; + CRLF +
				&quot;/Contents &quot; +
				(  m_PageContents.Length &lt;=3D 5? m_PageContents : &quot;[&quot; + =
m_PageContents + &quot;]&quot;)			=09
				;
			int newObjID =3D GetNewObjID();
			PDFWriteObj(newObjID,true,					//This object number
				text);=09
			if (m_PageObjRefs.Length &gt; 0){
				m_PageObjRefs +=3D &quot; &quot;;
			}
			m_PageObjRefs +=3D PDFObjRef(newObjID);
		}

		///&lt;summary&gt;PDF object reference&lt;/summary&gt;
		private string PDFObjRef(int o)
		{ //Adobe Specification Paragraph 4.11
			return  o.ToString() + &quot; 0 R&quot;;
		}


		/// &lt;summary&gt;Write the PDF cross-reference table&lt;/summary&gt;
		private void WriteCrossRef()
		{ //Adobe speification Paragraph 5.15
			m_StartXOffs =3D m_Offset;			//Save offset of xref=20
			StreamWrite(&quot;xref&quot; + CRLF);		//Intro to the xref table

			//First number indicates we start at object 0 [first entry in this =
subsection]
			//Second number is the number of cross reference entries
			StreamWrite(&quot;0 &quot; + xrefTable.Count.ToString() + CRLF);=20
			int i =3D 0;
			foreach (int offset in xrefTable)
			{ //Each entry must be exactly 20 bytes, including end-of-line marker
				//offset =3D number of bytes from the begining of the file to the=20
				//beginning of the object: must be 10 bytes long, padded with =
leading zeroes
				if (i=3D=3D0) StreamWrite(&quot;0000000000 65535 f&quot;+CRLF);
				else=20
				{
					StreamWrite(String.Format(&quot;{0:D10} 00000 n{1}&quot;,offset, CRLF));
				}
				++i;
			}
		}


		/// &lt;summary&gt;Write the last part of the PDF file&lt;/summary&gt;
		private void WriteTrailer(int root,int info)
		{	//Adobe Specificaton Paragraph 5.16
			StreamWrite(&quot;trailer&quot; + CRLF + &quot;&lt;&lt;&quot; + CRLF);
			StreamWrite(&quot;/Size &quot;  + xrefTable.Count.ToString() + CRLF);
			StreamWrite(&quot;/Root &quot;  + PDFObjRef(root) + CRLF);=09
			if (info &gt; 0)
			{
				StreamWrite(&quot;/Info &quot;  + PDFObjRef(info) + CRLF);=09
			}
			StreamWrite(&quot;&gt;&gt;&quot;+CRLF+&quot;startxref&quot;+CRLF+m_StartXOffs+CRLF);	//Save =
position of xref table
		=09
			//Specification says nothing about newline after %%EOF. Acrobat =
reader works without it
			//Ghostview owever complains - since gv is used a lot on linux I =
added CRLF.
			StreamWrite(&quot;%%EOF&quot;+CRLF); 				//End-of-file marker
		}


		/// &lt;summary&gt;Write a Document Info object&lt;/summary&gt;
		/// &lt;returns&gt;Object ID of the object&lt;/returns&gt;
		private int WriteDocumentInfo() //returns Object ID of the info object
		{ // Adobe Specification Paragraph 6.10
			string text =3D &quot;&quot;;
		=09
			//Title________________________________________________
			if(Information.Title.Length &gt; 0)
			{
				text +=3D &quot;/Title (&quot; + ConvertStrToPDF(Information.Title) + &quot;)&quot; + =
CRLF;
			}
			//Subject______________________________________________
			if(Information.Subject.Length &gt; 0)
			{
				text +=3D &quot;/Subject (&quot; +ConvertStrToPDF(Information.Subject) + &quot;)&quot; + =
CRLF;
			}
			//Author_______________________________________________
			if (Information.AuthorName.Length &gt; 0)
			{			=09
				text +=3D &quot;/Author (&quot; + ConvertStrToPDF(Information.AuthorName) + =
&quot;)&quot; + CRLF;
			}
			//Creationdate_________________________________________
			DateTime now =3D DateTime.Now;
			TimeZone z =3D TimeZone.CurrentTimeZone;
			TimeSpan t =3D z.GetUtcOffset(now);
			text +=3D &quot;/CreationDate (D:&quot; +=20
					now.ToString(&quot;yyyyMMddHHmmss&quot;) +
					&quot;+&quot; + t.Hours.ToString(&quot;D2&quot;) + &quot;'&quot;+t.Minutes +&quot;')&quot; + CRLF;
		=09
			//Document Keywords____________________________________
			if (Information.Keywords.Length &gt; 0)
			{		=09
				text +=3D &quot;/Keywords (&quot; + ConvertStrToPDF(Information.Keywords) + =
&quot;)&quot; + CRLF;
			}

			//Program that created the PDF document
			if (Information.Creator.Length &gt; 0)
			{
				text +=3D &quot;/Creator (&quot; + ConvertStrToPDF(Information.Creator) + &quot;)&quot; =
+ CRLF;
			}

			//Producer of the PDF document
			text +=3D &quot;/Producer (&quot; + ConvertStrToPDF(ProductVersion) + &quot;)&quot;;

			//Write the info object________________________________
			int newObjID =3D GetNewObjID();
			PDFWriteObj(newObjID,true,				//This object number; dictionary:&lt;&lt;, &gt;&gt; =

				text);								//document info
			return newObjID;
		}


		/// &lt;summary&gt;Increment Object ID and return it&lt;/summary&gt;
		/// &lt;returns&gt;New Object ID number&lt;/returns&gt;
		private int GetNewObjID()	=09
		{
			xrefTable.Add(0);	  //Increase xross reference table size [Insert ID =
in table when writing obj]
			return ++m_LastObjId; //Return a new number to keep Object IDs unique
		}


//		/// &lt;summary&gt;Output the data to the file or stream&lt;/summary&gt;
//		/// &lt;param name=3D&quot;s&quot;&gt;String of data to write&lt;/param&gt;
//		private void StreamWrite(string s)
//		{ //If we write a string, the length is first written - we DONT want =
that: make charArray
//			PDFWriter.Write(s.ToCharArray());
//		}


		/// &lt;summary&gt;Normalize string so that special characters are handled =
appropriately&lt;/summary&gt;
		/// &lt;param name=3D&quot;s&quot;&gt;String to normalize&lt;/param&gt;
		/// &lt;returns&gt;Strin after normalisation&lt;/returns&gt;
		private string ConvertStrToPDF(string s)
		{	//convert  &quot;\&quot;, &quot;(&quot;, and  &quot;)&quot; to &quot;\x&quot;.
			string tmp=3Ds;
			tmp.Replace(@&quot;\&quot;, @&quot;\\&quot;);
			tmp.Replace(@&quot;(&quot;, @&quot;\(&quot;);
			tmp.Replace(@&quot;)&quot;, @&quot;\)&quot;);
			tmp.Replace(&quot;\r&quot;, @&quot;\r&quot;);
			tmp.Replace(&quot;\n&quot;, @&quot;\n&quot;);
			return tmp;
		}
	=09
	=09
		/// &lt;summary&gt;Create colour&lt;/summary&gt;
		/// &lt;param name=3D&quot;c&quot;&gt;colour to use&lt;/param&gt;
		/// &lt;param name=3D&quot;f&quot;&gt;g or rg if false (fill); G or RG if true =
(stroke)&lt;/param&gt;
		/// &lt;returns&gt;PDF string representation&lt;/returns&gt;
		private string PDFColour(RptColour c,bool f)
		{ //Adobe specification, Paragraph 8.5, 12.1
			string colorstr;
			if ((c.Red+c.Green+c.Blue)=3D=3D0)=20
			{
				if (m_IsBlack) {
					colorstr =3D &quot;&quot;; //Conserve file size: need not repeat last color
				} else {
					m_IsBlack=3Dtrue;
					colorstr =3D ((f)? &quot;0 G&quot;:&quot;0 g&quot;) + CRLF;
				}
			}
			else=20
			{
				m_IsBlack=3Dfalse;
				colorstr =3D String.Format(&quot;{0,4} {1,4} {2,4} {3}&quot;,				=09
						((double)c.Red/255),
						((double)c.Green/255),
						((double)c.Blue/255),
						((f)? &quot;RG&quot;:&quot;rg&quot;) + CRLF
					);
			}
			return (colorstr);
		}

		private void DrawPDFLine(int fromX, int fromY,int toX, int toY,
			LineStyles style,int thickness,
			RptColour clr
			)
		{ // Adobe Specification Paragrap 12.1
			int objId=3DGetNewObjID();
			int pgHeight =3D PAGE_DIMENSIONS[(int)m_PageSize,1];
			string widthstr =3D &quot;&quot;;
			string colorstr=3D PDFColour(clr,true);		=09
			if (thickness &gt; 1) {widthstr =3D thickness.ToString() + &quot; w&quot; + CRLF;}
			string stylestr=3DPDFLineStyle(style);		=09
			PDFWriteStreamObj(objId,&quot;&quot;,
				colorstr+
				widthstr + stylestr +    =20
				fromX.ToString() + &quot; &quot; +
				(pgHeight-fromY).ToString() +&quot; m&quot; + CRLF +
				toX.ToString() + &quot; &quot; +
				(pgHeight-toY).ToString() + &quot; l&quot; + CRLF +
				&quot;s&quot; + CRLF				          =20
				);//PDFWriteObj
			if (m_PageContents.Length &gt; 0)=20
			{
				m_PageContents +=3D &quot; &quot;;
			}
			m_PageContents +=3D PDFObjRef(objId);				                             =
=20
		}

		/// &lt;summary&gt;Sets line style&lt;/summary&gt;	=09
		/// &lt;returns&gt;String to be written in PDF file&lt;/returns&gt;
		private string PDFLineStyle(LineStyles style)
		{ //Adobe Specification, Paragraph 8.3
			string stylestr=3D&quot;&quot;;
			switch(style)
			{
				case LineStyles.Dots:
					m_IsSolid=3Dfalse;
					stylestr=3D&quot;[1 2] 0 d&quot; + CRLF; //1 on 2 off=20
					break;
				case LineStyles.Dash:
					m_IsSolid=3Dfalse;
					//Adobe's spec has example of [3 3] as 3 on, 3 off, but that =
displays=20
					//almost solid - had to make [3 5] or [3 6] to get decent spaces =
in-between.
					stylestr=3D&quot;[3 5] 0 d&quot; + CRLF;
					break;
				//Adobe spec seems not to allow for dash-dot, etc
				default:
					if (m_IsSolid) {
						stylestr=3D&quot;&quot;;	//save file size: need not repeat for each line
					} else {
						m_IsSolid=3Dtrue;
						stylestr=3D&quot;[4 0] 0 d&quot; + CRLF;
					}
					break;
			}
			return stylestr;
		}


		/// &lt;summary&gt;Create a fill pattern object.&lt;/summary&gt;
		/// &lt;param name=3D&quot;pattern&quot;&gt;Pattern to create. An Error is thrown if =
the Solid pattern is passed.&lt;/param&gt;
		/// &lt;returns&gt;Object ID of the pattern&lt;/returns&gt;
		private int PDFFillPattern(FillPatterns pattern)
		{ //Adobe Specification Paragraph 7.17 - see example of star pattern =
(Example 7.33)
			int objId =3D (int) m_Patterns[(int) pattern];
			if (objId &gt; 0) // If the pattern has been defined, we simply return =
it's Object ID
			{
				AddPatternToProcSet(objId,(int)pattern); //Ensure it is in current =
page's resources
				return objId; //Re-use same pattern object
			}=20
			else  //Add the pattern object to the file
			{
				objId=3DGetNewObjID();
				//int procSetId =3D GetNewObjID();=09
				//PDFWriteObj(procSetId,true,&quot;/ProcSet [/PDF] &quot;); //Create a ProcSet =
for the pattern

				string ObjectText =3D=20
					&quot;/Type /Pattern&quot; + CRLF + 				=09
					&quot;/PatternType 1&quot; + CRLF +	//Tiling pattern (smoothing not yet =
implemented)
					&quot;/Resources &lt;&lt; &gt;&gt;&quot; + CRLF + //+ PDFObjRef(procSetId) + CRLF +
					&quot;/PaintType 2&quot;   + CRLF +	//Use external colour, i.e. colour not =
defined in pattern
					&quot;/TilingType 1&quot;  + CRLF ;	//Pattern cells are spaced consistently
					//Matrix not defined, accept default of identity matrix
								=09
				//Now we define the pattern in the stream part of the object
				string PatternStr=3D&quot;&quot;;
				switch (pattern)
				{
					case FillPatterns.VertLines:
						ObjectText +=3D=20
							&quot;/BBox [0 0 7 8]&quot; + CRLF +  //Pattern bounding box Spec Example =
7.33				=09
							&quot;/XStep 8&quot;		  + CRLF +	//Note This is differrent between Example=20
							&quot;/YStep 7&quot;;					//7.33 and 7.32 [Bitmap vs vector-drawn]

						 PatternStr =3D &quot;0 0 m&quot;	+ CRLF +  &quot;0 8 l&quot;	+ CRLF +  &quot;s&quot; + CRLF +
									  &quot;2 0 m&quot;	+ CRLF +  &quot;2 8 l&quot;	+ CRLF +  &quot;s&quot; + CRLF +
									  &quot;4 0 m&quot;	+ CRLF +  &quot;4 8 l&quot;	+ CRLF +  &quot;s&quot;       + CRLF +
									  &quot;6 0 m&quot;	+ CRLF +  &quot;6 8 l&quot;	+ CRLF +  &quot;s&quot;;
						 break;
					case FillPatterns.HorizLines:
						ObjectText +=3D=20
							&quot;/BBox [0 0 8 7]&quot; + CRLF +  //Pattern bounding box Spec Example =
7.33				=09
							&quot;/XStep 7&quot;		  + CRLF +	//Note This is differrent between Example=20
							&quot;/YStep 8&quot;;					//7.33 and 7.32 [Bitmap vs vector-drawn]

						PatternStr=3D &quot;0 0 m&quot;	+ CRLF +  &quot;8 0 l&quot;	+ CRLF +  &quot;s&quot; + CRLF +
									&quot;0 2 m&quot;	+ CRLF +  &quot;8 2 l&quot;	+ CRLF +  &quot;s&quot; + CRLF +
									&quot;0 4 m&quot;	+ CRLF +  &quot;8 4 l&quot;	+ CRLF +  &quot;s&quot; + CRLF +
									&quot;0 6 m&quot;	+ CRLF +  &quot;8 6 l&quot;	+ CRLF +  &quot;s&quot;;								=09
						 break;
					case FillPatterns.CrossLines:
						ObjectText +=3D=20
							&quot;/BBox [0 0 8 8]&quot; + CRLF +  //Pattern bounding box Spec Example =
7.33				=09
							&quot;/XStep 6&quot;		  + CRLF +	//Note This is differrent between Example=20
							&quot;/YStep 6&quot;;					//7.33 and 7.32 [Bitmap vs vector-drawn]

						PatternStr=3D &quot;0 0 m&quot;	+ CRLF +  &quot;8 0 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
									&quot;0 2 m&quot;	+ CRLF +  &quot;8 2 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
									&quot;0 4 m&quot;	+ CRLF +  &quot;8 4 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
									&quot;0 6 m&quot;	+ CRLF +  &quot;8 6 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
								//Vert
									&quot;0 0 m&quot;	+ CRLF +  &quot;0 8 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
									&quot;2 0 m&quot;	+ CRLF +  &quot;2 8 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
									&quot;4 0 m&quot;	+ CRLF +  &quot;4 8 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
									&quot;6 0 m&quot;	+ CRLF +  &quot;6 8 l&quot;	+ CRLF + &quot;s&quot;;
						break;=09
					case FillPatterns.DiagFwLines:
						ObjectText +=3D=20
							&quot;/BBox [0 0 5 5]&quot; + CRLF +  //Pattern bounding box Spec Example =
7.33				=09
							&quot;/XStep 5&quot;		  + CRLF +	//Note This is differrent between Example=20
							&quot;/YStep 5&quot;;					//7.33 and 7.32 [Bitmap vs vector-drawn]
					=09
						PatternStr=3D &quot;0 0 m&quot;	+ CRLF +  &quot;5 5 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
									&quot;-3 3 m&quot;	+ CRLF +  &quot;3 -3 l&quot;	+ CRLF + &quot;s&quot;;
						break;=09
					case FillPatterns.DiagBwLines:
						ObjectText +=3D=20
							&quot;/BBox [0 0 5 5]&quot; + CRLF +  //Pattern bounding box Spec Example =
7.33				=09
							&quot;/XStep 5&quot;		  + CRLF +	//Note This is differrent between Example=20
							&quot;/YStep 5&quot;;					//7.33 and 7.32 [Bitmap vs vector-drawn]
					=09
						PatternStr=3D &quot;0 5 m&quot;	+ CRLF +  &quot;5 0 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
									&quot;3 -3 m&quot;	+ CRLF +  &quot;-3 3 l&quot;	+ CRLF + &quot;s&quot;;
						break;=09
					case FillPatterns.DiagCrossLines:
						ObjectText +=3D=20
							&quot;/BBox [0 0 5 5]&quot; + CRLF +  //Pattern bounding box Spec Example =
7.33				=09
							&quot;/XStep 5&quot;		  + CRLF +	//Note This is differrent between Example=20
							&quot;/YStep 5&quot;;					//7.33 and 7.32 [Bitmap vs vector-drawn]
					=09
						PatternStr=3D=20
							&quot;0 0 m&quot;	+ CRLF +  &quot;5 5 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
							&quot;-3 3 m&quot;	+ CRLF +  &quot;3 -3 l&quot;	+ CRLF + &quot;s&quot;+CRLF+
							&quot;0 5 m&quot;	+ CRLF +  &quot;5 0 l&quot;	+ CRLF + &quot;s&quot; + CRLF +
							&quot;3 -3 m&quot;	+ CRLF +  &quot;-3 3 l&quot;	+ CRLF + &quot;s&quot;;
						break;	=09
					case FillPatterns.Solid:
						 throw new ArgumentOutOfRangeException(&quot;pattern&quot;);
				}
				string StreamText =3D PatternStr + CRLF;							=09

				PDFWriteStreamObj(objId,ObjectText,StreamText);=09
				m_Patterns[(int) pattern] =3D objId;
				AddPatternToProcSet(objId,(int)pattern); //Ensure it is in current =
page's resources
				return objId;
			}
		}


		private void AddPatternToProcSet(int objId,int pattern)
		{		=09
			string patternName =3D &quot;/P&quot; + pattern.ToString();
			if (m_PageProcSetPatterns.IndexOf(patternName) &lt; 0)
			{
				if (m_PageProcSetPatterns.Length &gt; 0)
				{
					m_PageProcSetPatterns +=3D &quot; &quot;;
				}
				m_PageProcSetPatterns +=3D patternName + &quot; &quot; + PDFObjRef(objId);
			}
		}

		#endregion Private functions/Methods

		#region Private data members	=09
		private System.IO.Stream PDFOutStream;	// Stream in which the PDF =
output is sent
		private System.IO.StreamWriter PDFWriter;=20
		private ArrayList xrefTable; 	=09
		private string m_PageObjRefs=3D&quot;&quot;;
		private int m_StartXOffs =3D 0;
		private int m_LastObjId =3D0;=09
		private int m_PagesObjId=3D0;
		private int m_Offset;
	=09
		private bool m_IsBlack=3Dtrue;			//True if we do not need to repeat =
black colour
		private bool m_IsSolid=3Dtrue;			//True if Solid line - need not =
repeat for each line
		private ArrayList m_Patterns;			//List of ObjetID's, Array index =3D =
FillPatterns enum
		private Hashtable m_Fonts=3Dnull;				//List of all fonts used in the =
document
	=09
		//Create a separate Page class for te following?
		private string	m_PageContents=3D&quot;&quot;;
		private string	m_PageProcSetPatterns=3D&quot;&quot;;
		private bool	m_IsFirstPage=3Dtrue;=09
		private int     m_PagesCount=3D0;			//Number of pages in document
		private string  m_PageFonts=3D&quot;&quot;;			//List of ObjectID's of fonts used =
on this page
		#endregion
	}
}
//END OF PDF CLASS
using System;
using System.Drawing;
using System.IO;
namespace SBReport.Export
{

	public struct DocInfo
	{	=09
		/// &lt;summary&gt;
		/// Title of the document. PDF files have an info object where the=20
		/// document's title can be saved.=20
		/// &lt;/summary&gt;
		public string Title
		{
			get {return m_Title; }
			set {m_Title =3D value; }
		}
		private string m_Title;

		/// &lt;summary&gt;
		/// Subject of the document. PDF files have an info object where the=20
		/// document's subject can be saved.=20
		/// &lt;/summary&gt;
		public string Subject
		{
			get {return m_Subject; }
			set {m_Subject =3D value; }
		}
		private string m_Subject;

		/// &lt;summary&gt;
		/// Name of document author. PDF files have an info object where the=20
		/// name of the document's author can be saved.=20
		/// &lt;/summary&gt;
		public string AuthorName
		{
			get {return m_AuthorName; }
			set {m_AuthorName =3D value; }
		}
		private string m_AuthorName;

		/// &lt;summary&gt;
		/// Keywords for the document. PDF files have an info object where the =

		/// keywords can be saved.=20
		/// &lt;/summary&gt;
		public string Keywords
		{
			get {return m_Keywords; }
			set {m_Keywords =3D value; }
		}
		private string m_Keywords;

		/// &lt;summary&gt;
		/// Creator of the document. PDF files have an info object where the=20
		/// program name that created the document can be saved.=20
		/// &lt;/summary&gt;
		public string Creator
		{
			get {return m_Creator; }
			set {m_Creator =3D value; }
		}
		private string m_Creator;
	}
=09

	/// &lt;summary&gt;
	/// Interface to export the report
	/// &lt;/summary&gt;
	public abstract class IExportInterface
	{	=09
		#region properties
		public DocInfo Information;
			=09
		///&lt;summary&gt;Determines the size of the page.&lt;/summary&gt;
		///&lt;remarks&gt;Changing this property in runtime affects all pages after
		/// changing. The current page, and all new pages created after=20
		/// changing this property will be in the new size,=20
		/// whilst all pages that were created before changing this property, =
will
		/// remain in the old size.&lt;/remarks&gt;
		public PageSizes PageSize
		{
			get{return m_PageSize; }
			set{m_PageSize =3D value;}
		}
		protected PageSizes m_PageSize=3DPageSizes.pgA4;
	=09
		/// &lt;summary&gt;
		/// File name to use when saving the document to a file
		/// &lt;/summary&gt;
		public string FileName
		{
			get{return m_FileName; }
			set{m_FileName=3Dvalue;}
		}
		protected string m_FileName=3D&quot;&quot;;
		#endregion properties

		#region public methods
		/// &lt;summary&gt;
		/// Start the export, and write it to disk in the file given by the =
parameter.
		/// If a file already exists with the specifiec name, the file will be =
overwritten
		/// by the new exported file.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;This function will be implemented to create a =
System.IO.FileStream=20
		/// class. The remainder of the execution wil be as if BeginExport was
		/// called with the stream as a parameter - see the stream version of =
this function.&lt;/remarks&gt;
		/// &lt;param name=3D&quot;filename&quot;&gt;File to which we must export&lt;/param&gt;
		public void BeginExport(string filename)
		{
			m_FileName =3D filename;
			System.IO.FileInfo fi =3D new FileInfo(filename);	=09
			m_fileFull=3Dfi.FullName.Substring(0,fi.FullName.LastIndexOf('.'));=20
			m_fileBase=3Dfi.Name.Substring(0,fi.Name.LastIndexOf('.'));=20
			m_fileExt =3Dfi.Extension;	//extension part of file name
		=09
			CreateFileStream(filename);
			OnStartDoc();
		}
	=09
		/// &lt;summary&gt;
		/// Start the export, and write it to a stream as given in the =
parameter.
		/// &lt;/summary&gt;
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;By exporting all output to a stream, we open up more =
possibilities
		/// for exporting. To ensure compatibility, the file version of this =
function=20
		/// also creates a stream for file output.
		/// This function can be implemented to create a =
System.IO.BinaryWriter=20
		/// with the stream as a parameter to it's constructor. All export is =
then done
		/// via the binary writer to the given stream:
		/// &lt;code&gt;
		/// System.IO.FileStream MyStream;
		/// System.IO.BinaryWriter MyWriter;
		/// public override void BeginExport(string filename)
		/// {
		///   FileInfo fi =3D new FileInfo(filename);
		///	  if (fi.Exists) {fi.Delete();} =20
		///   MyStream =3D new =
System.IO.FileStream(filename,FileMode.CreateNew);
		///   BeginExport();
		/// }
		/// public override void BeginExport(System.IO.Stream stream)
		/// {
		///		MyStream =3D stream;
		///		BeginExport();
		/// }
		/// private void BeginExport()
		/// {
		///		MyWriter =3D new System.IO.BinaryWriter(MyStream);
		///		MyWriter.Write(&quot;Hello World&quot;.ToCharArray());=20
		/// } //The EndExport function will close both the writer and the =
stream.
		/// &lt;/code&gt;
		/// &lt;param name=3D&quot;stream&quot;&gt;Stream to which we must export&lt;/param&gt;	=09
		public void BeginExport(System.IO.Stream stream)
		{
			m_fileFull=3D&quot;&quot;; //name of path+file  but no extension
			m_fileBase=3D&quot;&quot;; //name of file with no extension
			m_fileExt =3D&quot;&quot;; //extension part of file name
			DocOutStream =3D stream;
			DocWriter =3D new =
System.IO.StreamWriter(DocOutStream,System.Text.Encoding.ASCII);
			OnStartDoc();
		}


		/// &lt;summary&gt;
		/// Create a new Page in the export.=20
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;All subsequent drawing will be displayed on the new page. =

		/// The size of the page is set to the current value of the
		/// PageSize property. The current page and all calls to NewPage=20
		/// after changing PageSize will be in the new size,=20
		/// whilst all pages that were created before changing PageSize, will
		/// remain in the old size.
		/// &lt;/remarks&gt;
		abstract public void NewPage();

		/// &lt;summary&gt;
		/// End the export by writing the proper document termination =
characters to the stream.
		/// &lt;/summary&gt;
		public void EndExport()
		{
			OnEndDoc();

			CloseStream();		=09
		}

		#region WriteText
		///&lt;summary&gt;Write text on the current page. Font style is =
regular.&lt;/summary&gt;
		/// &lt;param name=3D&quot;text&quot;&gt;text to be written&lt;/param&gt;
		/// &lt;param name=3D&quot;left&quot;&gt;Position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;top&quot;&gt;Position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;fontName&quot;&gt;Name of font to use&lt;/param&gt;
		/// &lt;param name=3D&quot;fontsize&quot;&gt;Font Size of text&lt;/param&gt;
		public void WriteText(string text,int left, int top,string =
fontName,int fontsize)
		{
			SBReport.Font font =3D new SBReport.Font(fontName,fontsize);
			WriteText(text,left,top,font);
		}


		///&lt;summary&gt;Write text on the current page. Font style is =
regular.&lt;/summary&gt;
		/// &lt;param name=3D&quot;text&quot;&gt;text to be written&lt;/param&gt;
		/// &lt;param name=3D&quot;left&quot;&gt;Position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;top&quot;&gt;Position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;font&quot;&gt;Defines the font to be used&lt;/param&gt;	=09
		abstract public void WriteText(string text,int left, int =
top,SBReport.Font font);
		#endregion WriteText

		#region DrawHLine
		///&lt;summary&gt;Draw solid black line of width 1 on the current =
page.&lt;/summary&gt;
		/// &lt;param name=3D&quot;fromX&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;fromY&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;length&quot;&gt;Width of the line measured in pixels =
(difference between line left and right)&lt;/param&gt;	=09
		public void DrawHLine(int fromX, int fromY,int length)
		{
			LineStyles style =3D SBReport.Export.LineStyles.Solid;
			SBReport.RptColour clr =3D new RptColour(0,0,0); //Black
			DrawHLine(fromX,fromY,length,style,1,clr);
	}
		///&lt;summary&gt;Draw black line of specified width and style on the =
current page.&lt;/summary&gt;
		/// &lt;param name=3D&quot;fromX&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;fromY&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;length&quot;&gt;Width of the line measured in pixels =
(difference between line left and right)&lt;/param&gt;
		/// &lt;param name=3D&quot;style&quot;&gt;Solid, Dashed, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;thickness&quot;&gt;Line width&lt;/param&gt;
		public void DrawHLine(int fromX, int fromY,int length,
			LineStyles style,int thickness)
		{
			SBReport.RptColour clr =3D new RptColour(0,0,0); //Black
			DrawHLine(fromX,fromY,length,style,thickness,clr);	=09
		}
		=09
		///&lt;summary&gt;Draw colour line of specified width and style on the =
current page.&lt;/summary&gt;
		/// &lt;param name=3D&quot;fromX&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;fromY&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;length&quot;&gt;Width of the line measured in pixels =
(difference between line left and right)&lt;/param&gt;
		/// &lt;param name=3D&quot;LineStyles&quot;&gt;Solid, Dashed, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;style&quot;&gt;Solid, dotted, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;thickness&quot;&gt;Line width measured in pixels&lt;/param&gt;
		/// &lt;param name=3D&quot;clr&quot;&gt;Line colour&lt;/param&gt;
		abstract public void DrawHLine(int fromX, int fromY,int length,
			LineStyles style,int thickness, RptColour clr );
		#endregion DrawHLine

		#region DrawVLine
		///&lt;summary&gt;Draw solid black line of width 1 on the current =
page.&lt;/summary&gt;
		/// &lt;param name=3D&quot;fromX&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;fromY&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;length&quot;&gt;Height of the line measured in pixels =
(difference between line top and bottom)&lt;/param&gt;
		public void DrawVLine(int fromX, int fromY,int length)
		{
			LineStyles style =3D SBReport.Export.LineStyles.Solid;
			SBReport.RptColour clr =3D new RptColour(0,0,0); //Black
			DrawVLine(fromX,fromY,length,style,1,clr);
		}
		///&lt;summary&gt;Draw black line of specified width and style on the =
current page.&lt;/summary&gt;
		/// &lt;param name=3D&quot;fromX&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;fromY&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;length&quot;&gt;Height of the line measured in pixels =
(difference between line top and bottom)&lt;/param&gt;
		/// &lt;param name=3D&quot;style&quot;&gt;Solid, Dashed, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;thickness&quot;&gt;Line width&lt;/param&gt;
		public void DrawVLine(int fromX, int fromY,int length,
			LineStyles style,int thickness)
		{
			SBReport.RptColour clr =3D new RptColour(0,0,0); //Black
			DrawVLine(fromX,fromY,length,style,thickness,clr);	=09
		}
		=09
		///&lt;summary&gt;Draw colour line of specified width and style on the =
current page.&lt;/summary&gt;
		/// &lt;param name=3D&quot;fromX&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;fromY&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;length&quot;&gt;Height of the line measured in pixels =
(difference between line top and bottom)&lt;/param&gt;
		/// &lt;param name=3D&quot;LineStyles&quot;&gt;Solid, Dashed, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;style&quot;&gt;Solid, dotted, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;thickness&quot;&gt;Line width measured in pixels&lt;/param&gt;
		/// &lt;param name=3D&quot;clr&quot;&gt;Line colour&lt;/param&gt;
		abstract public void DrawVLine(int fromX, int fromY,int length,
			LineStyles style,int thickness, RptColour clr );
		#endregion DrawVLine
	=09
		#region DrawRectangle
		///&lt;summary&gt;Draw solid black rectanle of width 1 on the current page.
		//////The rectangle is not filled (transparent).
		///&lt;/summary&gt;
		/// &lt;param name=3D&quot;left&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;top&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;width&quot;&gt;Distance in pixels from left edge to right =
edge of rectangle&lt;/param&gt;
		/// &lt;param name=3D&quot;height&quot;&gt;Distance in pixels from top edge to bottom =
edge of rectangle&lt;/param&gt;	=09
		public void DrawRectangle(int left, int top,int width, int height)
		{
			RptColour C=3Dnew RptColour(); //Black
			=
DrawRectangle(left,top,width,height,LineStyles.Solid,1,C,null,FillPattern=
s.Solid);
		}

		///&lt;summary&gt;Draw black rectangle of specified width and style on the =
current page.
		///The rectangle is not filled (transparent).
		///&lt;/summary&gt;
		/// &lt;param name=3D&quot;left&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;top&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;width&quot;&gt;Distance in pixels from left edge to right =
edge of rectangle&lt;/param&gt;
		/// &lt;param name=3D&quot;height&quot;&gt;Distance in pixels from top edge to bottom =
edge of rectangle&lt;/param&gt;
		/// &lt;param name=3D&quot;style&quot;&gt;Solid, Dashed, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;thickness&quot;&gt;Line width&lt;/param&gt;	=09
		public void DrawRectangle(int left, int top,int width, int height,
			LineStyles style,int thickness)
		{
			RptColour C=3Dnew RptColour(); //Black
			DrawRectangle(left,top,width,height,style,thickness,C,null,
				FillPatterns.Solid );
		}=09

		///&lt;summary&gt;Draw colour rectangle of specified width and style on the =
current page.
		///If the fill colour is null, the rectangle is not filled. If the =
fill colour is=20
		///not null, it is filled with a solid fill type of the specified =
colour.
		///&lt;/summary&gt;
		/// &lt;param name=3D&quot;left&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;top&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;width&quot;&gt;Distance in pixels from left edge to right =
edge of rectangle&lt;/param&gt;
		/// &lt;param name=3D&quot;height&quot;&gt;Distance in pixels from top edge to bottom =
edge of rectangle&lt;/param&gt;
		/// &lt;param name=3D&quot;LineStyles&quot;&gt;Solid, Dashed, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;style&quot;&gt;Solid, dotted, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;thickness&quot;&gt;Line width measured in pixels&lt;/param&gt;
		/// &lt;param name=3D&quot;lineClr&quot;&gt;Line colour&lt;/param&gt;
		/// &lt;param name=3D&quot;fillClr&quot;&gt;Fill colour. Pass null for no =
fill.&lt;/param&gt;
		public void DrawRectangle(int left, int top,int width, int height,
			LineStyles style,int thickness, RptColour lineClr, RptColour fillClr)
		{
			DrawRectangle(left, top,width, height,style,thickness, =
lineClr,fillClr,FillPatterns.Solid);
		}

		///&lt;summary&gt;Draw colour rectangle of specified width and style on the =
current page.
		///If the fill colour is null, the rectangle is not filled. If the =
fill colour is=20
		///not null, it is filled with the specified pattern in the specified =
colour.
		///&lt;/summary&gt;
		/// &lt;param name=3D&quot;left&quot;&gt;Start position in pixels from left edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;top&quot;&gt;Start position in pixels from top edge of =
page&lt;/param&gt;
		/// &lt;param name=3D&quot;width&quot;&gt;Distance in pixels from left edge to right =
edge of rectangle&lt;/param&gt;
		/// &lt;param name=3D&quot;height&quot;&gt;Distance in pixels from top edge to bottom =
edge of rectangle&lt;/param&gt;
		/// &lt;param name=3D&quot;LineStyles&quot;&gt;Solid, Dashed, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;style&quot;&gt;Solid, dotted, etc&lt;/param&gt;
		/// &lt;param name=3D&quot;thickness&quot;&gt;Line width measured in pixels&lt;/param&gt;
		/// &lt;param name=3D&quot;lineClr&quot;&gt;Line colour&lt;/param&gt;
		/// &lt;param name=3D&quot;fillClr&quot;&gt;Fill colour. Pass null for no =
fill.&lt;/param&gt;
		/// &lt;param name=3D&quot;pattern&quot;&gt;Pattern to fill the box&lt;/param&gt;
		abstract public void DrawRectangle(int left, int top,int width, int =
height,
			LineStyles style,int thickness, RptColour lineClr, RptColour fillClr,
			FillPatterns pattern);
		#endregion DrawRectangle
		#endregion Public methods

		#region Protected properties
		/// &lt;summary&gt;
		/// Code common to both public BeginExport methods is placed here
		/// &lt;/summary&gt;
		protected abstract void OnStartDoc();
		protected abstract void OnEndDoc();
	=09
		/// &lt;summary&gt;Output the data to the file or stream&lt;/summary&gt;
		/// &lt;param name=3D&quot;s&quot;&gt;String of data to write&lt;/param&gt;
		protected void StreamWrite(string s)
		{ //If we write a string, the length is first written - we DONT want =
that: make charArray
			DocWriter.Write(s.ToCharArray());
		}

		/// &lt;summary&gt;
		/// To be called by child classes when they output to more than one =
file, e.g. HTML class
		/// &lt;/summary&gt;
		/// &lt;param name=3D&quot;fileName&quot;&gt;File name to create&lt;/param&gt;
		protected void CreateFileStream(string fileName)
		{
			System.IO.FileInfo fi =3D new FileInfo(fileName);
			if (fi.Exists) {fi.Delete();}		=09
			DocOutStream =3D new =
System.IO.FileStream(fileName,System.IO.FileMode.CreateNew);
			DocWriter =3D new =
System.IO.StreamWriter(DocOutStream,System.Text.Encoding.ASCII);
		}

		/// &lt;summary&gt;
		/// To be called by child classes when they output to more than one =
file, e.g. HTML class
		/// &lt;/summary&gt;
		/// &lt;param name=3D&quot;fileName&quot;&gt;File name to create&lt;/param&gt;
		protected void CloseStream()
		{	=09
			DocWriter.Close();
			DocOutStream.Close();
		}
	=09
		protected const string CRLF =3D &quot;\r\n&quot;;
		protected const string ProductVersion =3D &quot;Seabreeze SBReports (c) =
Willem Semmelink&quot;;
		protected System.IO.Stream DocOutStream;		// Stream in which the HTML =
output is sent
		protected System.IO.StreamWriter DocWriter; 	//
		protected static readonly int[,] PAGE_DIMENSIONS=3D{
			 //PgWidth		PgHeight	[Pixels]
			{612, 			792},		//A4
			{612,			792}		//Letter
														 };
		protected string m_fileFull=3D&quot;&quot;; //name of path+file but no extension
		protected string m_fileBase=3D&quot;&quot;; //name of file with no extension
		protected string m_fileExt =3D&quot;&quot;; //extension part of file name
		#endregion protected properties
	}

}

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="023582.html">[Mono-list] PDF creation library for Mono?
</A></li>
	<LI> Next message: <A HREF="023614.html">[Mono-list] PDF creation library for Mono?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23596">[ date ]</a>
              <a href="thread.html#23596">[ thread ]</a>
              <a href="subject.html#23596">[ subject ]</a>
              <a href="author.html#23596">[ author ]</a>
         </LI>
       </UL>
</body></html>
