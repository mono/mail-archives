<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] commented stubs in EventLog class
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:poussine%40freesurf.fr">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <LINK REL="Previous"  HREF="014707.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] commented stubs in EventLog class
   </H1>
    <B>Hervé Poussineau
    </B> 
    <A HREF="mailto:poussine%40freesurf.fr"
       TITLE="[Mono-list] commented stubs in EventLog class">poussine@freesurf.fr
       </A><BR>
    <I>Tue, 1 Jul 2003 00:46:35 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="014707.html">[Mono-list] Getting mod_mono
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14708">[ date ]</a>
              <a href="thread.html#14708">[ thread ]</a>
              <a href="subject.html#14708">[ subject ]</a>
              <a href="author.html#14708">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.

------=_NextPart_000_0031_01C33F6A.39CF3530
Content-Type: text/plain;
	charset=&quot;iso-8859-1&quot;
Content-Transfer-Encoding: 8bit

&gt;<i>What about contributing a simple-minded EventLog implementation?
</I>
I've already done a first EventLog implementation, if anyone is interested.

This implementation does absolutly nothing, but it compiles and run without
any (known) errors.
Only 14 methods/properties are still missing to EventLog be fully
operational :
* EventLog: LogDisplayName
* EventLog: Clear()
* EventLog: Close()
* EventLog: void WriteEntry(string source, string message, EventLogEntryType
type, int eventID, short category, byte[] rawData)
* EventLog: EventLog[] GetEventLogs(string machineName)
* EventLog: string LogNameFromSourceName(string source, string machineName)
* EventLog: bool Exists(string logName, string machineName)
* EventLog: void Delete(string logName, string machineName)
* EventLog: void CreateEventSource(string source, string logName, string
machineName)
* EventLog: bool SourceExists(string source, string machineName)
* EventLog: void DeleteEventSource(string source, string machineName)
* EventLogEntryCollection: EventLogEntryCollection(string logName, string
machineName)
* EventLogEntry: void GetObjectData(SerializationInfo info, StreamingContext
context)
* EventLogEntry: void Fill()

Hervé

PS: in attached files, 2 completed files (EventLog.cs and EventLogEntry.cs)
and a patch for EventLogEntryCollection.
PS2: as Gert Driesen said, &quot;What direction should we take on unix ?&quot;

------=_NextPart_000_0031_01C33F6A.39CF3530
Content-Type: application/octet-stream;
	name=&quot;EventLogEntryCollection.patch&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename=&quot;EventLogEntryCollection.patch&quot;

Index: class/System/System.Diagnostics/EventLogEntryCollection.cs
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
RCS file: =
/mono/mcs/class/System/System.Diagnostics/EventLogEntryCollection.cs,v
retrieving revision 1.1
diff -u -r1.1 EventLogEntryCollection.cs
--- class/System/System.Diagnostics/EventLogEntryCollection.cs	9 Jun =
2002 18:06:07 -0000	1.1
+++ class/System/System.Diagnostics/EventLogEntryCollection.cs	30 Jun =
2003 22:47:15 -0000
@@ -3,6 +3,7 @@
 //
 // Authors:
 //   Jonathan Pryor (<A HREF="mailto:jonpryor@vt.edu">jonpryor@vt.edu</A>)
+//   Herv=C3=A9 Poussineau (<A HREF="mailto:hpoussineau@fr.st">hpoussineau@fr.st</A>)
 //
 // (C) 2002 Jonathan Pryor
 //
@@ -18,8 +19,10 @@
=20
 		private ArrayList eventLogs =3D new ArrayList ();
=20
-		internal EventLogEntryCollection()
+		[MonoTODO]
+		internal EventLogEntryCollection (string logName, string machineName)
 		{
+			// Fill eventLogs arraylist
 		}
=20
 		public int Count {

------=_NextPart_000_0031_01C33F6A.39CF3530
Content-Type: application/octet-stream;
	name=&quot;EventLogEntry.cs&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename=&quot;EventLogEntry.cs&quot;

//
// System.Diagnostics.EventLogEntry
//
// Authors:
//    Herv=C3=A9 Poussineau (<A HREF="mailto:hpoussineau@fr.st">hpoussineau@fr.st</A>)
//    Jonathan Pryor (<A HREF="mailto:jonpryor@vt.edu">jonpryor@vt.edu</A>)
//
// (C) 2003 Herv=C3=A9 Poussineau
//

using System;
using System.ComponentModel;
using System.Runtime.Serialization;

namespace System.Diagnostics
{
	[Serializable]
	public class EntryWrittenEventArgs : EventArgs
	{
		private EventLogEntry _Entry;
	=09
		public EventLogEntry Entry { get { return _Entry; } }
	=09
		public EntryWrittenEventArgs() : this(null) {}
		public EntryWrittenEventArgs(EventLogEntry entry) { _Entry =3D entry; =
}
	}
=09
	[Serializable]
	public sealed class EventLogEntry : Component, ISerializable
	{
#region Attributes
		private string            _Category;
		private short             _CategoryNumber;
		private byte[]            _Data;
		private EventLogEntryType _EntryType;
		private int               _EventID;
		private int               _Index;
		private string            _MachineName;
		private string            _Message;
		private string[]          _ReplacementStrings;
		private string            _Source;
		private DateTime          _TimeGenerated;
		private DateTime          _TimeWritten;
		private string            _UserName;
	=09
		private bool _Filled =3D false;
		private bool _Initialized =3D false;
#endregion

#region Constructors
		internal EventLogEntry(
				string            source,
				string            message,
				EventLogEntryType entryType,
				int               eventID,
				short             categoryNumber,
				byte[]            data)
		{
			_Source         =3D source;
			_Message        =3D message;
			_EntryType      =3D entryType;
			_EventID        =3D eventID;
			_CategoryNumber =3D categoryNumber;
			_Data           =3D data;
		}
#endregion

#region Public properties
		public short CategoryNumber { get { return _CategoryNumber; } }
		public byte[] Data { get { return _Data; } }
		public EventLogEntryType EntryType { get { return _EntryType; } }
		public int EventID { get { return _EventID; } }
		public string Message { get { return _Message; } }
		public string Source { get { return _Source; } }
	=09
		public string Category
		{
			get
			{
				if (!_Filled)
					Fill();
				return _Category;
			}
		}
	=09
		public int Index
		{
			get
			{
				if (!_Filled)
					Fill();
				return _Index;
			}
		}
	=09
		public string MachineName
		{
			get
			{
				if (!_Filled)
					Fill();
				return _MachineName;
			}
		}
	=09
		public string[] ReplacementStrings
		{
			get
			{
				if (!_Filled)
					Fill();
				return _ReplacementStrings;
			}
		}
	=09
		public DateTime TimeGenerated
		{
			get
			{
				if (!_Filled)
					Fill();
				return _TimeGenerated;
			}
		}
	=09
		public DateTime TimeWritten
		{
			get
			{
				if (!_Filled)
					Fill();
				return _TimeWritten;
			}
		}
	=09
		public string UserName
		{
			get
			{
				if (!_Filled)
					Fill();
				return _UserName;
			}
		}
#endregion

#region Interface ISerializable
		[MonoTODO]
		public void GetObjectData(SerializationInfo info, StreamingContext =
context)
		{
			throw new NotImplementedException();
		}
#endregion

#region Public methods
		internal void setIndex(int index)
		{
			_Index =3D index;
			_Initialized =3D true;
		}
#endregion

#region Private methods
		[MonoTODO(&quot;Replace default values with real informations&quot;)]
		private void Fill()
		{
			if (!_Initialized)
				throw new InvalidOperationException();
		=09
			_Category           =3D String.Empty;
			_MachineName        =3D String.Empty;
			_ReplacementStrings =3D new string[0];
			_TimeGenerated      =3D DateTime.MinValue;
			_TimeWritten        =3D DateTime.MinValue;
			_UserName           =3D String.Empty;
		=09
			_Filled =3D true;
		}
#endregion
	}
}

------=_NextPart_000_0031_01C33F6A.39CF3530
Content-Type: application/octet-stream;
	name=&quot;EventLog.cs&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename=&quot;EventLog.cs&quot;

//
// System.Diagnostics.EventLog
//
// Authors:
//    Herv=C3=A9 Poussineau (<A HREF="mailto:hpoussineau@fr.st">hpoussineau@fr.st</A>)
//    Jonathan Pryor (<A HREF="mailto:jonpryor@vt.edu">jonpryor@vt.edu</A>)
//
// (C) 2003 Herv=C3=A9 Poussineau
//

using System;
using System.ComponentModel;

namespace System.Diagnostics
{
	public delegate void EntryWrittenEventHandler(object sender, =
EntryWrittenEventArgs e);
=09
	public class EventLog : Component, ISupportInitialize
	{
#region Constants
		private const string EventLogApplication =3D &quot;Application&quot;;
		private const string EventLogSystem =3D &quot;System&quot;;
		private const string EventLogSecurity =3D &quot;Security&quot;;
		private const string LocalMachine =3D &quot;.&quot;;
#endregion

#region Attributes
		private bool   _RaisingEvents =3D false;
		private string _Log;
		private string _MachineName;
		private string _Source;
	=09
		private ISynchronizeInvoke _SynchronizingObject =3D null;
		private EventLogEntryCollection _Entries =3D null;
	=09
		///&lt;summary&gt;Indicate if developpment environment is in initialization =
phase&lt;/summary&gt;
		private bool _Initialization =3D false;
#endregion

#region Events
		public event EntryWrittenEventHandler EntryWritten;
#endregion

#region Public properties
		public bool EnableRaisingEvents
		{
			get { return _RaisingEvents; }
			set { _RaisingEvents =3D value; }
		}
	=09
		public EventLogEntryCollection Entries
		{
			get
			{
				if (_Entries =3D=3D null)
					_Entries =3D new EventLogEntryCollection(Log, MachineName);
				return _Entries;
			}
		}
	=09
		public string Log
		{
			get { return _Log; }
			set
			{
				string log;
				if (Exists(value, MachineName))
					log =3D value;
				else
					log =3D EventLogApplication;
				if (_Log !=3D log)
				{
					_Log =3D log;
					_Entries =3D null;
				}
				_Source =3D null;
			}
		}
	=09
		[MonoTODO]
		public string LogDisplayName { get { return _Log; } }
	=09
		public string MachineName
		{
			get { return _MachineName; }
			set
			{
				if (value =3D=3D null || value =3D=3D &quot;&quot;)
					throw new ArgumentException(&quot;Invalid value&quot;);
			=09
				if (_MachineName !=3D value)
				{
					_MachineName =3D value;
					_Entries =3D null;
				}
			}
		}
	=09
		public string Source
		{
			get { return _Source; }
			set { _Source =3D value; }
		}
	=09
		public ISynchronizeInvoke SynchronizingObject
		{
			get { return _SynchronizingObject; }
			set { _SynchronizingObject =3D value; }
		}
#endregion

#region Constructors
		public EventLog() : this(&quot;&quot;, LocalMachine, &quot;&quot;) {}
		public EventLog(string logName) : this(logName, LocalMachine, &quot;&quot;) {}
		public EventLog(string logName, string machineName) : this(logName, =
machineName, &quot;&quot;) {}
	=09
		public EventLog(string logName, string machineName, string source)
		{
			_Log =3D logName;
			_MachineName =3D machineName;
			_Source =3D source;
		}
#endregion

#region Public instance methods
		public void BeginInit() { _Initialization =3D true; }
	=09
		[MonoTODO]
		public void Clear()
		{
			if (Log =3D=3D &quot;&quot;)
				throw new ArgumentException(&quot;Log =3D=3D \&quot;\&quot;&quot;);
		}
	=09
		[MonoTODO]
		public void Close()
		{
		=09
		}
	=09
		public void EndInit() { _Initialization =3D false; }
	=09
		public void WriteEntry(string message)
		{
			WriteEntry(Source, message, EventLogEntryType.Information, 0, 0, new =
byte[0]);
		}
	=09
		public void WriteEntry(string message, EventLogEntryType type)
		{
			WriteEntry(Source, message, type, 0, 0, new byte[0]);
		}
	=09
		public void WriteEntry(string source, string message)
		{
			WriteEntry(source, message, EventLogEntryType.Information, 0, 0, new =
byte[0]);
		}
	=09
		public void WriteEntry(string message, EventLogEntryType type, int =
eventID)
		{
			WriteEntry(Source, message, type, eventID, 0, new byte[0]);
		}
	=09
		public void WriteEntry(string source, string message, =
EventLogEntryType type)
		{
			WriteEntry(source, message, type, 0, 0, new byte[0]);
		}
	=09
		public void WriteEntry(string message, EventLogEntryType type, int =
eventID, short category)
		{
			WriteEntry(Source, message, type, eventID, category, new byte[0]);
		}
	=09
		public void WriteEntry(string source, string message, =
EventLogEntryType type, int eventID)
		{
			WriteEntry(source, message, type, eventID, 0, new byte[0]);
		}
	=09
		public void WriteEntry(string message, EventLogEntryType type, int =
eventID, short category, byte[] rawData)
		{
			WriteEntry(Source, message, type, eventID, category, rawData);
		}
	=09
		public void WriteEntry(string source, string message, =
EventLogEntryType type, int eventID, short category)
		{
			WriteEntry(source, message, type, eventID, category, new byte[0]);
		}
	=09
		[MonoTODO]
		public void WriteEntry(string source, string message, =
EventLogEntryType type, int eventID, short category, byte[] rawData)
		{
			DateTime now =3D DateTime.Now;
		=09
			if (_Initialization)
				return;
		=09
			if (!SourceExists(source))
				CreateEventSource(source, Log);
		=09
			// create entry
			EventLogEntry eventLogEntry =3D new EventLogEntry(
			             source,
			             message,
			             type,
			             eventID,
			             category,
			             rawData);
		=09
			// write entry		=09
			int index =3D 0; //TODO : index =3D SystemWriteEvent(eventLogEntry, =
now)
		=09
			eventLogEntry.setIndex(index);
		=09
			if (EnableRaisingEvents)
				if (EntryWritten !=3D null)
					EntryWritten(this, new EntryWrittenEventArgs(eventLogEntry));
		}
#endregion

#region Public static methods	=09
		public static void CreateEventSource(string source, string logName)
		{
			CreateEventSource(source, logName, LocalMachine);
		}
	=09
		[MonoTODO]
		public static void CreateEventSource(string source, string logName, =
string machineName)
		{
		=09
		}
	=09
		public static void Delete(string logName)
		{
			Delete(logName, LocalMachine);
		}
	=09
		[MonoTODO]
		public static void Delete(string logName, string machineName)
		{
			if (logName =3D=3D null || logName =3D=3D String.Empty)
				throw new ArgumentException(&quot;logName&quot;);
		=09
			if (!Exists(logName))
				throw new SystemException(&quot;logName not found&quot;);
		}
	=09
		public static void DeleteEventSource(string source)
		{
			DeleteEventSource(source, LocalMachine);
		}
	=09
		[MonoTODO]
		public static void DeleteEventSource(string source, string =
machineName)
		{
			if (!SourceExists(source, machineName))
				throw new ArgumentException();
		}
	=09
		public static bool Exists(string logName)
		{
			return Exists(logName, LocalMachine);
		}
	=09
		[MonoTODO]
		public static bool Exists(string logName, string machineName)
		{
			return false;
		}
	=09
		public static EventLog[] GetEventLogs()
		{
			return GetEventLogs(LocalMachine);
		}
	=09
		[MonoTODO]
		public static EventLog[] GetEventLogs(string machineName)
		{
			return new EventLog[0];
		}
	=09
		[MonoTODO]
		public static string LogNameFromSourceName(string source, string =
machineName)
		{
			return &quot;&quot;;
		}
	=09
		public static bool SourceExists(string source)
		{
			return SourceExists(source, LocalMachine);
		}
	=09
		[MonoTODO]
		public static bool SourceExists(string source, string machineName)
		{
			return false;
		}
#endregion
	}
}

------=_NextPart_000_0031_01C33F6A.39CF3530--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="014707.html">[Mono-list] Getting mod_mono
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14708">[ date ]</a>
              <a href="thread.html#14708">[ thread ]</a>
              <a href="subject.html#14708">[ subject ]</a>
              <a href="author.html#14708">[ author ]</a>
         </LI>
       </UL>
</body></html>
