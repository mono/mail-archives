<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] List.FindAll method implementation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20List.FindAll%20method%20implementation&In-Reply-To=c3b5f930703182351x45677aeu8396254b6b764011%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="034659.html">
   <LINK REL="Next"  HREF="034711.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] List.FindAll method implementation</H1>
    <B>Paolo Molaro</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20List.FindAll%20method%20implementation&In-Reply-To=c3b5f930703182351x45677aeu8396254b6b764011%40mail.gmail.com"
       TITLE="[Mono-list] List.FindAll method implementation">lupus at ximian.com
       </A><BR>
    <I>Thu Mar 22 13:04:44 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="034659.html">[Mono-list] List.FindAll method implementation
</A></li>
        <LI>Next message: <A HREF="034711.html">[Mono-list] List.FindAll method implementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34708">[ date ]</a>
              <a href="thread.html#34708">[ thread ]</a>
              <a href="subject.html#34708">[ subject ]</a>
              <a href="author.html#34708">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 03/19/07 Juan C. Olivares wrote:
&gt;<i> It uses the new algorithm bits-on-stack for
</I>&gt;<i> System.Collections.Generic.List&lt;T&gt;::FindAll
</I>&gt;<i> (Predicate). This algorithm stores a group of uint's in the stack and uses
</I>&gt;<i> their bits as flags.
</I>&gt;<i> 
</I>&gt;<i> Because there's no way to know the size of the stack in any moment in time,
</I>&gt;<i> Miguel suggested me to limit this new method to use only 8KB of the stack...
</I>&gt;<i> so it will be useful for list with 8 * 1024 * 8 elements or less. Bigger
</I>&gt;<i> lists will use the old algorithm.
</I>
As a rule, stackalloc must not be used in the class libraries.
Exceptions are possible if the size is small and if it provides a
significant performance speedup for a common operation.
8 KB of stack space is definitely too much to use and it is also,
as your numbers show, in an area where an heap-allocated array would be
faster. 1 KB of stack-allocated memory would be on the high-side
already.

That said, if the existing code is slow, we need to understand why,
because that is what we need to fix first: the existing code just uses
List&lt;T&gt;.Add (T val) and this is a very basic operation. If that is slow,
it needs to be improved and FindAll() will become faster as a
consequence.

As a data point, the older code was significantly slower because
it used an iterator.
As another data point, the new code is sometimes slightly slower and sometimes
slightly faster for the attached benchmark (depending on things like the value 
of mod, ie how many results we return): I just changed 0x1000 to 1 in the
FindAll if so that the stackalloc func was not called.

So I'd like to see the code you used to generate your numbers, because
as things look right now, I see no reason to use the stackalloc codepath
at all (given its risks) and it should be removed.
Thanks!

lupus

-- 
-----------------------------------------------------------------
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">lupus at debian.org</A>                                     debian/rules
<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">lupus at ximian.com</A>                             Monkeys do it better
-------------- next part --------------
using System;
using System.Collections.Generic;

class T {
	static int size = 10;
	static int count = 1000000;
	static int mod = 10;

	static Predicate&lt;string&gt; match = delegate (string v) {
		return v == &quot;hello&quot;;
		//return false;
	};

	static List&lt;string&gt; Setup ()
	{
		List&lt;string&gt; l = new List&lt;string&gt; ();
		int start, end;
		start = Environment.TickCount;
		for (int i = 0; i &lt; size; ++i) {
			if ((i % mod) == 0)
				l.Add (&quot;hello&quot;);
			else
				l.Add (&quot;world&quot;);
		}
		end = Environment.TickCount;
		Console.WriteLine (&quot;size: {0}, loops: {1}, setup time: {2}&quot;, size, count, end-start);
		return l;
	}

	static void Run (List&lt;string&gt; l)
	{
		int start, end;
		List&lt;string&gt; res;
		start = Environment.TickCount;
		for (int i = 0; i &lt; count; ++i) {
			res = l.FindAll (match);
		}
		end = Environment.TickCount;
		Console.WriteLine (&quot;size: {0}, loops: {1}, time: {2}&quot;, size, count, end-start);
	}

	static void Main (string[] args) {
		if (args.Length &gt; 0)
			size = int.Parse (args [0]);
		if (args.Length &gt; 1)
			count = int.Parse (args [1]);
		if (args.Length &gt; 2)
			mod = int.Parse (args [2]);
		List&lt;string&gt; res;
		while (count &gt;= 10) {
			res = Setup ();
			Run (res);
			size *= 10;
			count /= 10;
		}
	}
}

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="034659.html">[Mono-list] List.FindAll method implementation
</A></li>
	<LI>Next message: <A HREF="034711.html">[Mono-list] List.FindAll method implementation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34708">[ date ]</a>
              <a href="thread.html#34708">[ thread ]</a>
              <a href="subject.html#34708">[ subject ]</a>
              <a href="author.html#34708">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
