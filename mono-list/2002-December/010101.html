<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Automatically reusing c++ libraries in c#
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:neilcawse%40hotmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="010100.html">
   <LINK REL="Next"  HREF="010105.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Automatically reusing c++ libraries in c#
   </H1>
    <B>Neil Cawse
    </B> 
    <A HREF="mailto:neilcawse%40hotmail.com"
       TITLE="[Mono-list] Automatically reusing c++ libraries in c#">neilcawse@hotmail.com
       </A><BR>
    <I>Thu, 5 Dec 2002 23:13:38 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="010100.html">[Mono-list] Mono in CVS, Makefile error
</A></li>
        <LI> Next message: <A HREF="010105.html">[Mono-list] Tips on using MONO (please answer)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10101">[ date ]</a>
              <a href="thread.html#10101">[ thread ]</a>
              <a href="subject.html#10101">[ subject ]</a>
              <a href="author.html#10101">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.

------=_NextPart_000_02EB_01C29CB3.F14D4FD0
Content-Type: text/plain;
	charset=&quot;iso-8859-1&quot;
Content-Transfer-Encoding: quoted-printable

Ive spent quite a bit of time researching how best to reuse the existing =
great libraries written in c++ - in c#. I was looking at some really =
good cross platform gui stuff for use in cross platform projects, for =
example. WxWindows (www.wxwindows.org) and swt (part of Eclipse =
www.eclipse.org).
C# is very good at accessing c libraries through pinvoke (using extern), =
but reusing c++ libraries are notoriously difficult (see other posts for =
info on different ways mangling is done and all the issues)
One option was using MS Visual C++ managed extensions to expose the =
functions to the managed world. Directly porting the existing c++ code =
like this looks like a lot of work! Adding a managed piece that then =
passes through the calls to the unmananged library would work but there =
were issues.
C++ supports having mixed dll's or exe's - ie you can embed managed and =
unmanaged code together. This works fine in a windows environment but =
without understanding the exact mechanics of how ms .net allows this, I =
suspect that it's a problem for MONO/DotGNU. The other option would be =
my c# program calling a managed c++ dll (which will/should run under =
DotGNU/Mono) calling an unmanaged dll. Yuck!
Other posts I read pointed me to swig. www.swig.org this is a cross =
platform app that builds addons to allow c++ libraries to be used from =
java apps, Perl, Python etc. etc. But no .net
This stuff is pretty clever, it's a partial compiler, including =
precompiler and parser that then builds the necessary c code to be added =
and compiled into your c++ dll and the java jni code (in the case of =
java). It also builds a wrapper around these jni calls so that you can =
use your object in java in exactly the same way as the c++ object.
V. cool stuff. So I grabbed the cvs and hacked the java stuff to see if =
I could get some decent results for .net. Now there is plenty of work =
left and ill need weeks before I find enough time to finish but =
basically - as an example - this is what it does at the moment:

Very simple c++ object example
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D
class Shape {
public:
  Shape() {
    nshapes++;
  }
  virtual ~Shape() {
    nshapes--;
  };
  double  x, y;  =20
  void    move(double dx, double dy);
  virtual double area(void) =3D 0;
  virtual double perimeter(void) =3D 0;
  static  int nshapes;
  };

class Circle : public Shape {
private:
  double radius;
public:
  Circle(double r) : radius(r) { };
  virtual double area(void);
  virtual double perimeter(void);
};

class Square : public Shape {
private:
  double width;
public:
  Square(double w) : width(w) { };
  virtual double area(void);
  virtual double perimeter(void);
};
#define M_PI 3.14159265358979323846

/* Move the shape to a new location */
void Shape::move(double dx, double dy) {
  x +=3D dx;
  y +=3D dy;
}

int Shape::nshapes =3D 0;

double Circle::area(void) {
  return M_PI*radius*radius;
}

double Circle::perimeter(void) {
  return 2*M_PI*radius;
}

double Square::area(void) {
  return width*width;
}

double Square::perimeter(void) {
  return 4*width;
}

RUN .net SWIG, produces:
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D

#define DllExport   __declspec( dllexport )
extern &quot;C&quot; {
DllExport void delete_Shape(int jarg1) {
    Shape *arg1 =3D (Shape *) 0 ;
   =20
    arg1 =3D *(Shape **)&amp;jarg1;=20
    delete arg1;
}

DllExport void set_Shape_x(int jarg1, double jarg2) {
    Shape *arg1 =3D (Shape *) 0 ;
    double arg2 ;
   =20
    arg1 =3D *(Shape **)&amp;jarg1;=20
    arg2 =3D (double)jarg2;=20
    if (arg1) (arg1)-&gt;x =3D arg2;
   =20
}

DllExport double get_Shape_x(int jarg1) {
    double jresult =3D 0 ;
    Shape *arg1 =3D (Shape *) 0 ;
    double result;
   =20
    arg1 =3D *(Shape **)&amp;jarg1;=20
    result =3D (double) ((arg1)-&gt;x);
   =20
    jresult =3D (double)result;=20
    return jresult;
}

DllExport void Shape_move(int jarg1, double jarg2, double jarg3) {
    Shape *arg1 =3D (Shape *) 0 ;
    double arg2 ;
    double arg3 ;
   =20
    arg1 =3D *(Shape **)&amp;jarg1;=20
    arg2 =3D (double)jarg2;=20
    arg3 =3D (double)jarg3;=20
    (arg1)-&gt;move(arg2,arg3);
   =20
}

DllExport int get_Shape_nshapes() {
    int jresult =3D 0 ;
    int result;
   =20
    result =3D (int)Shape::nshapes;
   =20
    jresult =3D (int)result;=20
    return jresult;
}

.BLA BLA.

DllExport long SquareToShape(long jarg1) {
    long baseptr =3D 0;
    *(Shape **)&amp;baseptr =3D *(Square **)&amp;jarg1;
    return baseptr;
}
}

AND
The Matching c# code:
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D
using System.Runtime.InteropServices;
class examplePINVOKE {
  [DllImport(&quot;example&quot;)]
  public static extern void delete_Shape(int jarg1);
  [DllImport(&quot;example&quot;)]
  public static extern void set_Shape_x(int jarg1, double jarg2);
  [DllImport(&quot;example&quot;)]
  public static extern double get_Shape_x(int jarg1);
=20
 .BLA BLA.

  [DllImport(&quot;example&quot;)]
  public static extern int CircleToShape(int jarg1);
  [DllImport(&quot;example&quot;)]
  public static extern int SquareToShape(int jarg1);
}

AND

using System;
public class Shape : IDisposable {
  private int swigCPtr;
  protected bool swigCMemOwn;

  protected Shape(int cPtr, bool cMemoryOwn) {
    swigCMemOwn =3D cMemoryOwn;
    swigCPtr =3D cPtr;
  }

  protected Shape() : this(0, false) {
  }

  public virtual void Dispose() {
    delete();
  }

  protected void delete() {
    if(swigCPtr !=3D 0 &amp;&amp; swigCMemOwn) {
      examplePINVOKE.delete_Shape(swigCPtr);
      swigCMemOwn =3D false;
    }
    swigCPtr =3D 0;
  }

  protected static long getCPtr(Shape obj) {
    return (obj =3D=3D null) ? 0 : obj.swigCPtr;
  }

  public void setX(double x) {
    examplePINVOKE.set_Shape_x(swigCPtr, x);
  }

  public double getX() {
    return examplePINVOKE.get_Shape_x(swigCPtr);
  }

.BLA BLA.
}

So if you got down this far ;) now what you have is:
using a single command you can reuse all the great c++ libraries in c#.
Sounds good?!

I think this route is the most robust and sensible way of reuse. Do you =
agree? Will this be useful?
I need to finish the work and then convince Dave to add this into his =
Swig project. Swig offers pretty complete support of c++ including =
templates, virtual methods - take a look at the website. Quite a lot of =
work remains to make sure we are writing decent c# code, to finish off =
and thoroughly test. I havnt had the time to even try it on a c++ =
library bigger than the example above - but I will!


Neil
416 436 6345
------=_NextPart_000_02EB_01C29CB3.F14D4FD0
Content-Type: text/html;
	charset=&quot;iso-8859-1&quot;
Content-Transfer-Encoding: quoted-printable

&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;
&lt;HTML&gt;&lt;HEAD&gt;
&lt;META http-equiv=3DContent-Type =
content=3Dtext/html;charset=3Diso-8859-1&gt;
&lt;META content=3D&quot;MSHTML 6.00.2800.1126&quot; name=3DGENERATOR&gt;
&lt;STYLE&gt;&lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY id=3DMailContainerBody=20
style=3D&quot;PADDING-LEFT: 10px; FONT-WEIGHT: normal; FONT-SIZE: 10pt; =
COLOR: #000000; BORDER-TOP-STYLE: none; PADDING-TOP: 15px; FONT-STYLE: =
normal; FONT-FAMILY: Verdana; BORDER-RIGHT-STYLE: none; =
BORDER-LEFT-STYLE: none; TEXT-DECORATION: none; BORDER-BOTTOM-STYLE: =
none&quot;=20
leftMargin=3D0 topMargin=3D0 acc_role=3D&quot;text&quot; CanvasTabStop=3D&quot;true&quot;=20
name=3D&quot;Compose message area&quot;&gt;&lt;?xml:namespace prefix=3D&quot;v&quot; =
/&gt;&lt;?xml:namespace prefix=3D&quot;o&quot; /&gt;
&lt;DIV&gt;Ive spent quite a bit of time researching how best to reuse the =
existing=20
great libraries written in c++ - in c#. I was looking at some really =
good cross=20
platform gui stuff for use in cross platform projects, for example. =
WxWindows=20
(&lt;A href=3D&quot;<A HREF="http://www.wxwindows.org"">http://www.wxwindows.org&quot;</A>&gt;www.wxwindows.org&lt;/A&gt;) and swt =
(part of=20
Eclipse &lt;A href=3D&quot;<A HREF="http://www.eclipse.org"">http://www.eclipse.org&quot;</A>&gt;www.eclipse.org&lt;/A&gt;).&lt;BR&gt;C# =
is very=20
good at accessing c libraries through pinvoke (using extern), but =
reusing c++=20
libraries are notoriously difficult (see other posts for info on =
different ways=20
mangling is done and all the issues)&lt;BR&gt;One option was using MS Visual =
C++=20
managed extensions to expose the functions to the managed world. =
Directly=20
porting the existing c++ code like this looks like a lot of work! Adding =
a=20
managed piece that then passes through the calls to the unmananged =
library would=20
work but there were issues.&lt;BR&gt;C++ supports having mixed dll's or exe's =
- ie you=20
can embed managed and unmanaged code together. This works fine in a =
windows=20
environment but without understanding the exact mechanics of how ms .net =
allows=20
this, I suspect that it=92s a problem for MONO/DotGNU. The other option =
would be=20
my c# program calling a managed c++ dll (which will/should run under=20
DotGNU/Mono) calling an unmanaged dll. Yuck!&lt;BR&gt;Other posts I read =
pointed me to=20
swig. &lt;A href=3D&quot;<A HREF="http://www.swig.org"">http://www.swig.org&quot;</A>&gt;www.swig.org&lt;/A&gt; this is a cross =
platform=20
app that builds addons to allow c++ libraries to be used from java apps, =
Perl,=20
Python etc. etc. But no .net&lt;BR&gt;This stuff is pretty clever, it=92s a =
partial=20
compiler, including precompiler and parser that then builds the =
necessary c code=20
to be added and compiled into your c++ dll and the java jni code (in the =
case of=20
java). It also builds a wrapper around these jni calls so that you can =
use your=20
object in java in exactly the same way as the c++ object.&lt;BR&gt;V. cool =
stuff. So I=20
grabbed the cvs and hacked the java stuff to see if I could get some =
decent=20
results for .net. Now there is plenty of work left and ill need weeks =
before I=20
find enough time to finish but basically - as an example - this is what =
it does=20
at the moment:&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;Very simple c++ object =
example&lt;BR&gt;=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D&lt;BR&gt;class=20
Shape {&lt;BR&gt;public:&lt;BR&gt;&amp;nbsp; Shape() {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
nshapes++;&lt;BR&gt;&amp;nbsp; }&lt;BR&gt;&amp;nbsp; virtual ~Shape() =
{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
nshapes--;&lt;BR&gt;&amp;nbsp; };&lt;BR&gt;&amp;nbsp; double&amp;nbsp; x, y;&amp;nbsp;&amp;nbsp; =
&lt;BR&gt;&amp;nbsp;=20
void&amp;nbsp;&amp;nbsp;&amp;nbsp; move(double dx, double dy);&lt;BR&gt;&amp;nbsp; virtual =
double=20
area(void) =3D 0;&lt;BR&gt;&amp;nbsp; virtual double perimeter(void) =3D =
0;&lt;BR&gt;&amp;nbsp;=20
static&amp;nbsp; int nshapes;&lt;BR&gt;&amp;nbsp; };&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;class Circle : public Shape {&lt;BR&gt;private:&lt;BR&gt;&amp;nbsp; double=20
radius;&lt;BR&gt;public:&lt;BR&gt;&amp;nbsp; Circle(double r) : radius(r) { };&lt;BR&gt;&amp;nbsp; =
virtual=20
double area(void);&lt;BR&gt;&amp;nbsp; virtual double perimeter(void);&lt;BR&gt;};&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;class Square : public Shape {&lt;BR&gt;private:&lt;BR&gt;&amp;nbsp; double=20
width;&lt;BR&gt;public:&lt;BR&gt;&amp;nbsp; Square(double w) : width(w) { };&lt;BR&gt;&amp;nbsp; =
virtual=20
double area(void);&lt;BR&gt;&amp;nbsp; virtual double =
perimeter(void);&lt;BR&gt;};&lt;BR&gt;#define=20
M_PI 3.14159265358979323846&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;/* Move the shape to a new location */&lt;BR&gt;void Shape::move(double =
dx,=20
double dy) {&lt;BR&gt;&amp;nbsp; x +=3D dx;&lt;BR&gt;&amp;nbsp; y +=3D dy;&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;int Shape::nshapes =3D 0;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;double Circle::area(void) {&lt;BR&gt;&amp;nbsp; return =
M_PI*radius*radius;&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;double Circle::perimeter(void) {&lt;BR&gt;&amp;nbsp; return =
2*M_PI*radius;&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;double Square::area(void) {&lt;BR&gt;&amp;nbsp; return =
width*width;&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;double Square::perimeter(void) {&lt;BR&gt;&amp;nbsp; return =
4*width;&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;RUN .net SWIG, =
produces:&lt;BR&gt;=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;#define DllExport&amp;nbsp;&amp;nbsp; __declspec( dllexport )&lt;BR&gt;extern &quot;C&quot; =

{&lt;BR&gt;DllExport void delete_Shape(int jarg1) {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; =
Shape *arg1=20
=3D (Shape *) 0 ;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; arg1 =3D =
*(Shape=20
**)&amp;amp;jarg1; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; delete arg1;&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;DllExport void set_Shape_x(int jarg1, double jarg2) =
{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
Shape *arg1 =3D (Shape *) 0 ;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; double arg2=20
;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; arg1 =3D *(Shape =
**)&amp;amp;jarg1;=20
&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; arg2 =3D (double)jarg2; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if =
(arg1)=20
(arg1)-&amp;gt;x =3D arg2;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;DllExport double get_Shape_x(int jarg1) {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; =
double=20
jresult =3D 0 ;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Shape *arg1 =3D (Shape *) 0=20
;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; double result;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; arg1 =3D *(Shape **)&amp;amp;jarg1; =
&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
result =3D (double) ((arg1)-&amp;gt;x);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; =
&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
jresult =3D (double)result; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return =
jresult;&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;DllExport void Shape_move(int jarg1, double jarg2, double jarg3)=20
{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Shape *arg1 =3D (Shape *) 0 =
;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; double=20
arg2 ;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; double arg3 ;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; arg1 =3D *(Shape **)&amp;amp;jarg1; =
&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; arg2=20
=3D (double)jarg2; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; arg3 =3D (double)jarg3;=20
&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; (arg1)-&amp;gt;move(arg2,arg3);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; =

&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;DllExport int get_Shape_nshapes() {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int =
jresult =3D 0=20
;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; int result;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; =
&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
result =3D (int)Shape::nshapes;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; =
&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
jresult =3D (int)result; &lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return =
jresult;&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;=85BLA BLA=85&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;DllExport long SquareToShape(long jarg1) {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; =
long=20
baseptr =3D 0;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; *(Shape **)&amp;amp;baseptr =3D =
*(Square=20
**)&amp;amp;jarg1;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return baseptr;&lt;BR&gt;}&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;AND&lt;BR&gt;The Matching c# =
code:&lt;BR&gt;=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D&lt;=
BR&gt;using=20
System.Runtime.InteropServices;&lt;BR&gt;class examplePINVOKE {&lt;BR&gt;&amp;nbsp;=20
[DllImport(&quot;example&quot;)]&lt;BR&gt;&amp;nbsp; public static extern void =
delete_Shape(int=20
jarg1);&lt;BR&gt;&amp;nbsp; [DllImport(&quot;example&quot;)]&lt;BR&gt;&amp;nbsp; public static extern =
void=20
set_Shape_x(int jarg1, double jarg2);&lt;BR&gt;&amp;nbsp; =
[DllImport(&quot;example&quot;)]&lt;BR&gt;&amp;nbsp;=20
public static extern double get_Shape_x(int =
jarg1);&lt;BR&gt;&amp;nbsp;&lt;BR&gt;&amp;nbsp;=85BLA=20
BLA=85&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp; [DllImport(&quot;example&quot;)]&lt;BR&gt;&amp;nbsp; public static extern int=20
CircleToShape(int jarg1);&lt;BR&gt;&amp;nbsp; [DllImport(&quot;example&quot;)]&lt;BR&gt;&amp;nbsp; =
public=20
static extern int SquareToShape(int jarg1);&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;AND&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;using System;&lt;BR&gt;public class Shape : IDisposable {&lt;BR&gt;&amp;nbsp; =
private int=20
swigCPtr;&lt;BR&gt;&amp;nbsp; protected bool swigCMemOwn;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp; protected Shape(int cPtr, bool cMemoryOwn) =
{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
swigCMemOwn =3D cMemoryOwn;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; swigCPtr =3D =
cPtr;&lt;BR&gt;&amp;nbsp;=20
}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp; protected Shape() : this(0, false) {&lt;BR&gt;&amp;nbsp; }&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp; public virtual void Dispose() {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
delete();&lt;BR&gt;&amp;nbsp; }&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp; protected void delete() {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; if(swigCPtr =
!=3D 0=20
&amp;amp;&amp;amp; swigCMemOwn) {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
examplePINVOKE.delete_Shape(swigCPtr);&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; =

swigCMemOwn =3D false;&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; =
swigCPtr =3D=20
0;&lt;BR&gt;&amp;nbsp; }&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp; protected static long getCPtr(Shape obj) =
{&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
return (obj =3D=3D null) ? 0 : obj.swigCPtr;&lt;BR&gt;&amp;nbsp; }&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp; public void setX(double x) {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;=20
examplePINVOKE.set_Shape_x(swigCPtr, x);&lt;BR&gt;&amp;nbsp; }&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp; public double getX() {&lt;BR&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; return=20
examplePINVOKE.get_Shape_x(swigCPtr);&lt;BR&gt;&amp;nbsp; }&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;=85BLA BLA=85&lt;BR&gt;}&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;So if you got down this far ;) now what you have is:&lt;BR&gt;using a =
single=20
command you can reuse all the great c++ libraries in c#.&lt;BR&gt;Sounds =
good?!&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;I think this route is the most robust and sensible way of reuse. Do =
you=20
agree? Will this be useful?&lt;BR&gt;I need to finish the work and then =
convince Dave=20
to add this into his Swig project. Swig offers pretty complete support =
of c++=20
including templates, virtual methods - take a look at the website. Quite =
a lot=20
of work remains to make sure we are writing decent c# code, to finish =
off and=20
thoroughly test. I havnt had the time to even try it on a c++ library =
bigger=20
than the example above - but I will!&lt;/DIV&gt;
&lt;DIV&gt;&amp;nbsp;&lt;/DIV&gt;
&lt;DIV&gt;&lt;BR&gt;Neil&lt;/DIV&gt;
&lt;DIV&gt;416 436 6345&lt;/DIV&gt;
&lt;DIV&gt;&lt;/DIV&gt;&lt;/BODY&gt;&lt;/HTML&gt;

------=_NextPart_000_02EB_01C29CB3.F14D4FD0--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="010100.html">[Mono-list] Mono in CVS, Makefile error
</A></li>
	<LI> Next message: <A HREF="010105.html">[Mono-list] Tips on using MONO (please answer)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10101">[ date ]</a>
              <a href="thread.html#10101">[ thread ]</a>
              <a href="subject.html#10101">[ subject ]</a>
              <a href="author.html#10101">[ author ]</a>
         </LI>
       </UL>
</body></html>
