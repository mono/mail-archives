<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Calling back from unmanaged code to managed code.
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:francis%40aspl.es">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <LINK REL="Previous"  HREF="024673.html">
   <LINK REL="Next"  HREF="024689.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Calling back from unmanaged code to managed code.
   </H1>
    <B>Francis Brosnan Blázquez
    </B> 
    <A HREF="mailto:francis%40aspl.es"
       TITLE="[Mono-list] Calling back from unmanaged code to managed code.">francis@aspl.es
       </A><BR>
    <I>Mon, 29 Nov 2004 20:05:27 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="024673.html">[Mono-list] mod_mono production quality
</A></li>
        <LI> Next message: <A HREF="024689.html">[Mono-list] Calling back from unmanaged code to managed code.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24666">[ date ]</a>
              <a href="thread.html#24666">[ thread ]</a>
              <a href="subject.html#24666">[ subject ]</a>
              <a href="author.html#24666">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

I'm trying to make the c# binding for some set of libraries which, in
sort, makes petitions to a remote server without blocking the caller. In
this context, the caller must suply a handler to manage the server
response.

Later, when server response arrives, these libraries initiate a thread
and execute on it the Caller's handler. 

The binding works fine until unmanaged code invoke the caller's handler
inside the newly thread create.

I've made a litle test to show more presiselly what I'm trying to do.
The follwing file is the unmanaged pice of code that has two ways to
notify the caller throught its handler: 1) by creating a new thread, 2)
by using the actual caller's thread.

----
#include &lt;stdio.h&gt;
#include &lt;glib.h&gt;

typedef struct {
        gint    value;
        gchar * text_response;
}Response;

typedef void (*Callback) (Response * res);


gpointer Work (Callback cb) {

        g_print (&quot;Recieved call on unmanaged side..\n&quot;);

        Response * res     = g_new (Response, 1);
        res-&gt;value         = 2;
        res-&gt;text_response = g_strdup (&quot;some text&quot;);

        g_print (&quot;Calling back to managed side..\n&quot;);
        cb (res);

        g_print (&quot;Calling back finished..\n&quot;);
        return NULL;
}

void Function  (Callback cb)
{
        Work (cb);

        return;
}

void Function2 (Callback cb)
{

        g_thread_create ((GThreadFunc) Work, cb, FALSE, NULL);

        return;
}
----

The following file is a simple test that dll-import the previous two
functions: Function and Function2 and invoke them.

----
using System;
using System.Threading;
using System.Runtime.InteropServices;

public class Callback {

        [StructLayout(LayoutKind.Sequential)]
        public struct Response {
                public int    value;
                public string text_response;
        }

        public delegate void CallbackFunc (ref Response res);

        [DllImport(&quot;libcallback&quot;)]
        extern static void Function (CallbackFunc cb);

        [DllImport(&quot;libcallback&quot;)]
        extern static void Function2 (CallbackFunc cb);


        public static void ProcessResponse (ref Response res) {
                Console.WriteLine (&quot;Recieved callback on managed side&quot;);
                Console.WriteLine (&quot;  Values: {0} and {1}&quot;, res.value,
    res.text_response); 
        }


        public static void Main (string [] args) {

                Console.WriteLine (&quot;Test init..&quot;);

                CallbackFunc cb = new CallbackFunc (ProcessResponse);

                Function (cb);
                Thread.Sleep (2000);

                Function2 (cb);
                Thread.Sleep (2000);


                Console.WriteLine (&quot;Test finished..&quot;);
        }
}
----

When I execute this test I get the following:

----
$ ./Callback.exe
Test init..
Recieved call on unmanaged side..
Calling back to managed side..
Recieved callback on managed side
  Values: 2 and some text
Calling back finished..
Recieved call on unmanaged side..
Calling back to managed side..

** ERROR **: file mini.c: line 6558 (mono_get_lmf_addr): should not be
reached
aborting...
Abortado
----

I've been reading about .Net Threading system and it seems that there is
no problem to invoke static or instance methods from unmanaged create
threads.

What I'm missing? Is not possible to invoke a managed method from a
newly created thread on the unmanaged side? 

I've also uploaded a zip file with both files and a makefile to get the
whole compiled: <A HREF="http://dolphin.aspl.es/~acinom/files.zip">http://dolphin.aspl.es/~acinom/files.zip</A>
 
Cheers,

-- 
Francis Brosnan Blázquez &lt;<A HREF="mailto:francis@aspl.es">francis@aspl.es</A>&gt;


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="024673.html">[Mono-list] mod_mono production quality
</A></li>
	<LI> Next message: <A HREF="024689.html">[Mono-list] Calling back from unmanaged code to managed code.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24666">[ date ]</a>
              <a href="thread.html#24666">[ thread ]</a>
              <a href="subject.html#24666">[ subject ]</a>
              <a href="author.html#24666">[ author ]</a>
         </LI>
       </UL>
</body></html>
