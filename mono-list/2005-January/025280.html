<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Implementing attribute-based code generation
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:nazgul%40nemerle.org">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="025277.html">
   <LINK REL="Next"  HREF="025271.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Implementing attribute-based code generation
   </H1>
    <B>Kamil Skalski
    </B> 
    <A HREF="mailto:nazgul%40nemerle.org"
       TITLE="[Mono-list] Implementing attribute-based code generation">nazgul@nemerle.org
       </A><BR>
    <I>Thu, 13 Jan 2005 15:10:22 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="025277.html">[Mono-list] Implementing attribute-based code generation
</A></li>
        <LI> Next message: <A HREF="025271.html">[Mono-list] Implementing attribute-based code generation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25280">[ date ]</a>
              <a href="thread.html#25280">[ thread ]</a>
              <a href="subject.html#25280">[ subject ]</a>
              <a href="author.html#25280">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Dnia czwartek, 13 stycznia 2005 14:47, Stephen Touset napisa=C5=82:
&gt;<i> Shawn Vose wrote:
</I>&gt;<i> &gt; Use System.Reflection to read available methods, attributes and
</I>&gt;<i> &gt; properties for a dll. You can use it to do so at runtime. I know there
</I>&gt;<i> &gt; has been a few questions and answers on Relection in the archives
</I>&gt;<i>
</I>&gt;<i> What I'm trying to accomplish is slightly different, and cannot be done
</I>&gt;<i> with the current design of attributes.
</I>
Of course it is reasonable that you want to stick in C# and you will have t=
o=20
change architecture of mcs to accomplish it. Implementation, which you are=
=20
describing is exactly what we do in Nemerle. Compiler is looking at=20
attrubutes and for some of them it runs a macro operating on compiler's=20
internal structures.

So instead (besides) of attatching some metadata to generated assembly, it=
=20
runs external program modifing method's body. Seeing this feature in mcs=20
would be nice.=20
Probably a little problem would be easy generation of code - you will have =
to=20
use mcs's API to build syntax trees. In Nemerle we have special syntax for=
=20
this, so implementation of pre-condition macro Requires is:

  /// Example: [Requires (i !=3D 4 &amp;&amp; boo (), throw ArgumentException ())] =
foo=20
(i : int) : void { ... }
  /// Example: [Requires (i !=3D 4)] foo (i : int) : void { ... }
  [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance,
                       Nemerle.MacroTargets.Method,
                       Inherited =3D true, AllowMultiple =3D true)]
  macro Requires (_ : TypeBuilder, m : ParsedMethod, assertion, otherwise =
=3D=20
null)
  {
    def check =3D
      if (otherwise !=3D null)
        &lt;[ unless ($assertion) $otherwise ]&gt;
      else
        &lt;[ assert ($assertion, &quot;The ``Requires'' contract of method `&quot; +
                   $(m.name.GetName ().Id : string) + &quot;' has been=20
violated.&quot;) ]&gt;;
       =20
    m.Body =3D &lt;[
      $check;
      $(m.Body)
    ]&gt;
  }

Here, generated program it is quite small, but in case of invariant it is m=
uch=20
more complex.

In future we are planing to provide a C# fronend to Nemerle compiler, so yo=
u=20
would have Design By Contrace also in pure C#.

&gt;<i>
</I>&gt;<i> As an example, I want to be able to place preconditions and
</I>&gt;<i> postconditions on methods and invariants on classes. These attributes
</I>&gt;<i> need to follow inheritance rules for Design By Contract as well:
</I>&gt;<i> postconditions are logically ORed with any inherited postconditions from
</I>&gt;<i> base classes, while postconditions and invariants are logically ANDed
</I>&gt;<i> with inherited ones from their base classes. This is not possible with
</I>&gt;<i> the current implementation of attributes.
</I>&gt;<i>
</I>&gt;<i> Nor is the ability for an attribute to consitently, automatically, and
</I>&gt;<i> predictable modify the way a method or class works. Attributes cannot
</I>&gt;<i> access the methods they belong to, nor can they generate code
</I>&gt;<i> dynamically. There is also no way to have them transparently invoke code
</I>&gt;<i> upon method execution.
</I>&gt;<i>
</I>&gt;<i> Because of this, something would need to be written to have certain
</I>&gt;<i> attributes generate code in the methods they modify, or in all the
</I>&gt;<i> methods of the classes they modify. Also, these attributes would need to
</I>&gt;<i> be inherited upon their base classes as well, automatically. A script
</I>&gt;<i> could theoretically do it, but that would require a lot of additional
</I>&gt;<i> work, reimplementing a C# parser that already exists with Mono.
</I>&gt;<i>
</I>&gt;<i> If you can find a way to do this with System.Reflection, please let me
</I>&gt;<i> know. It would save me a bundle of time.
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@lists.ximian.com">Mono-list@lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>
</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="025277.html">[Mono-list] Implementing attribute-based code generation
</A></li>
	<LI> Next message: <A HREF="025271.html">[Mono-list] Implementing attribute-based code generation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25280">[ date ]</a>
              <a href="thread.html#25280">[ thread ]</a>
              <a href="subject.html#25280">[ subject ]</a>
              <a href="author.html#25280">[ author ]</a>
         </LI>
       </UL>
</body></html>
