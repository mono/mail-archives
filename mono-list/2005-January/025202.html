<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Class lib 1.1: List&lt;T&gt;.ToArray()
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:Sijmen%20Mulder%20%3Csjmulder%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="025201.html">
   <LINK REL="Next"  HREF="025206.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Class lib 1.1: List&lt;T&gt;.ToArray()
   </H1>
    <B>Sijmen Mulder
    </B> 
    <A HREF="mailto:Sijmen%20Mulder%20%3Csjmulder%40gmail.com%3E"
       TITLE="[Mono-list] Class lib 1.1: List&lt;T&gt;.ToArray()">Sijmen Mulder &lt;sjmulder@gmail.com&gt;
       </A><BR>
    <I>Fri, 7 Jan 2005 14:10:33 +0100</I>
    <P><UL>
        <LI> Previous message: <A HREF="025201.html">[Mono-list] Problem building 1.1.3
</A></li>
        <LI> Next message: <A HREF="025206.html">[Mono-list] ANN: RemObjects Chrome for Mono - Public Preview available now!
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25202">[ date ]</a>
              <a href="thread.html#25202">[ thread ]</a>
              <a href="subject.html#25202">[ subject ]</a>
              <a href="author.html#25202">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>------=_Part_721_12050966.1105103433467
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

Hi there,

While trying my tic-tac-toe bot on Linux with Mono 1.1, I found out
that the method System.Collections.Generic.List&lt;T&gt;:ToArray() is
missing.

I edited the List.cs file to include the method. Here is the inserted method:

public T[] ToArray()
{
	T[] ret = new T[count];

	if (count &gt; 0)
		Array.Copy (contents, ret, count);

	return ret;
}

Also, I have attached the updated file as I don't know how to make a
good diff in Windows. If there is anything wrong with the code, please
let me know.

Thanks,

-- 
Sijmen Mulder

 'May the Lord bless you and protect you. May the Lord smile on you
and be gracious to you. May the Lord show you his favor and give you
his peace.'
 'De Heer zegent je, en Hij bewaart je. De Heer kijkt met liefde naar
je, en Hij is je genadig. De Heer bedenkt het goede voor je, en geeft
je vrede.'

------=_Part_721_12050966.1105103433467
Content-Type: text/plain; name=&quot;List.cs&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment; filename=&quot;List.cs&quot;

// -*- Mode: csharp; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -=
*-
//
// System.Collections.Generic.List
//
// Author:
//    Martin Baulig (<A HREF="mailto:martin@ximian.com">martin@ximian.com</A>)
//
// (C) 2004 Novell, Inc.
//

//
// Copyright (C) 2004 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//=20
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//=20
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#if NET_2_0
using System;
using System.Collections;
using System.Runtime.InteropServices;

namespace System.Collections.Generic
{
=09[CLSCompliant(false)]
=09[ComVisible(false)]
=09public class List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;,
=09=09IList, ICollection, IEnumerable
=09{
=09=09protected int count;
=09=09protected int capacity;
=09=09protected T[] contents;
=09=09protected int modified;

=09=09public List ()
=09=09{
=09=09}

=09=09public List (int capacity)
=09=09{
=09=09=09this.capacity =3D capacity;
=09=09=09contents =3D new T [capacity];
=09=09}

=09=09public List (ICollection collection)
=09=09=09: this (collection.Count)
=09=09{
=09=09=09collection.CopyTo (contents, 0);
=09=09=09count =3D collection.Count;
=09=09}

=09=09protected void Resize (int size)
=09=09{
=09=09=09if (size &lt; capacity)
=09=09=09=09return;

=09=09=09if (size &lt; 10)
=09=09=09=09size =3D 10;

=09=09=09T[] ncontents =3D new T [size];
=09=09=09if (count &gt; 0)
=09=09=09=09Array.Copy (contents, 0, ncontents, 0, count);

=09=09=09modified++;
=09=09=09contents =3D ncontents;
=09=09=09capacity =3D size;
=09=09}

=09=09public void Add (T item)
=09=09{
=09=09=09if (count &gt;=3D capacity)
=09=09=09=09Resize (2 * capacity);

=09=09=09contents [count] =3D item;
=09=09=09count++;
=09=09}

=09=09int IList.Add (object item)
=09=09{
=09=09=09if (count &gt;=3D capacity)
=09=09=09=09Resize (2 * capacity);

=09=09=09contents [count] =3D (T) item;
=09=09=09return count++;
=09=09}

=09=09public void Clear ()
=09=09{
=09=09=09count =3D 0;
=09=09}

=09=09public bool Contains (T item)
=09=09{
=09=09=09for (int i =3D 0; i &lt; count; i++)
=09=09=09=09if (contents [i] =3D=3D item)
=09=09=09=09=09return true;

=09=09=09return false;
=09=09}

=09=09bool IList.Contains (object item)
=09=09{
=09=09=09return Contains ((T) item);
=09=09}

=09=09public int IndexOf (T item)
=09=09{
=09=09=09for (int i =3D 0; i &lt; count; i++)
=09=09=09=09if (contents [i] =3D=3D item)
=09=09=09=09=09return i;

=09=09=09return -1;
=09=09}

=09=09int IList.IndexOf (object item)
=09=09{
=09=09=09return IndexOf ((T) item);
=09=09}

=09=09public void Insert (int index, T item)
=09=09{
=09=09=09if (index &lt; 0)
=09=09=09=09throw new ArgumentException ();
=09=09=09if (index &gt; count)
=09=09=09=09index =3D count;

=09=09=09Resize (index);
=09=09=09int rest =3D count - index;
=09=09=09if (rest &gt; 0)
=09=09=09=09Array.Copy (contents, index, contents, index+1, rest);
=09=09=09contents [index] =3D item;
=09=09}

=09=09void IList.Insert (int index, object item)
=09=09{
=09=09=09Insert (index, (T) item);
=09=09}

=09=09public bool Remove (T item)
=09=09{
=09=09=09int index =3D IndexOf (item);
=09=09=09if (index &lt; 0)
=09=09=09=09return false;

=09=09=09RemoveAt (index);
=09=09=09return true;
=09=09}

=09=09void IList.Remove (object item)
=09=09{
=09=09=09Remove ((T) item);
=09=09}

=09=09public void RemoveAt (int index)
=09=09{
=09=09=09if ((index &lt; 0) || (count =3D=3D 0))
=09=09=09=09throw new ArgumentException ();
=09=09=09if (index &gt; count)
=09=09=09=09index =3D count;

=09=09=09int rest =3D count - index;
=09=09=09if (rest &gt; 0)
=09=09=09=09Array.Copy (contents, index+1, contents, index, rest);

=09=09=09count--;
=09=09}

=09=09public bool IsFixedSize {
=09=09=09get {
=09=09=09=09return false;
=09=09=09}
=09=09}

=09=09public bool IsReadOnly {
=09=09=09get {
=09=09=09=09return false;
=09=09=09}
=09=09}

=09=09public T this [int index] {
=09=09=09get {
=09=09=09=09return contents [index];
=09=09=09}

=09=09=09set {
=09=09=09=09contents [index] =3D value;
=09=09=09}
=09=09}

=09=09object IList.this [int index] {
=09=09=09get {
=09=09=09=09return contents [index];
=09=09=09}

=09=09=09set {
=09=09=09=09// contents [index] =3D (T) value;
=09=09=09}
=09=09}

=09=09public void CopyTo (T[] array, int arrayIndex)
=09=09{
=09=09=09if (count &gt; 0)
=09=09=09=09Array.Copy (contents, 0, array, arrayIndex, count);
=09=09}

=09=09void ICollection.CopyTo (Array array, int arrayIndex)
=09=09{
=09=09=09if (count &gt; 0)
=09=09=09=09Array.Copy (contents, 0, array, arrayIndex, count);
=09=09}

=09=09public T[] ToArray()
=09=09{
=09=09=09T[] ret =3D new T[count];

=09=09=09if (count &gt; 0)
=09=09=09=09Array.Copy (contents, ret, count);

=09=09=09return ret;
=09=09}

=09=09public int Count {
=09=09=09get {
=09=09=09=09return count;
=09=09=09}
=09=09}

=09=09public bool IsSynchronized {
=09=09=09get { return false; }
=09=09}

=09=09public object SyncRoot {
=09=09=09get { return this; }
=09=09}

=09=09public Enumerator GetEnumerator ()
=09=09{
=09=09=09return new Enumerator (this);
=09=09}

=09=09IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ()
=09=09{
=09=09=09return new Enumerator (this);
=09=09}

=09=09IEnumerator IEnumerable.GetEnumerator ()
=09=09{
=09=09=09return new Enumerator (this);
=09=09}

=09=09public struct Enumerator : IEnumerator&lt;T&gt;, IEnumerator
=09=09{
=09=09=09List&lt;T&gt; list;
=09=09=09int modified;
=09=09=09int current;

=09=09=09public Enumerator (List&lt;T&gt; list)
=09=09=09{
=09=09=09=09this.list =3D list;
=09=09=09=09this.modified =3D list.modified;
=09=09=09=09this.current =3D -1;
=09=09=09}

=09=09=09public T Current {
=09=09=09=09get {
=09=09=09=09=09if (list.modified !=3D modified)
=09=09=09=09=09=09throw new InvalidOperationException ();
=09=09=09=09=09if (current &lt; 0)
=09=09=09=09=09=09current =3D 0;
=09=09=09=09=09if (current &gt; list.count)
=09=09=09=09=09=09throw new ArgumentException ();
=09=09=09=09=09return list.contents [current];
=09=09=09=09}
=09=09=09}

=09=09=09object IEnumerator.Current {
=09=09=09=09get {
=09=09=09=09=09return Current;
=09=09=09=09}
=09=09=09}

=09=09=09public bool MoveNext ()
=09=09=09{
=09=09=09=09if (list.modified !=3D modified)
=09=09=09=09=09throw new InvalidOperationException ();

=09=09=09=09current++;
=09=09=09=09return current &lt; list.count;
=09=09=09}

=09=09=09public void Reset ()
=09=09=09{
=09=09=09=09if (list.modified !=3D modified)
=09=09=09=09=09throw new InvalidOperationException ();

=09=09=09=09current =3D -1;
=09=09=09}

=09=09=09public void Dispose ()
=09=09=09{
=09=09=09=09modified =3D -1;
=09=09=09}
=09=09}
=09}
}
#endif

------=_Part_721_12050966.1105103433467--

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="025201.html">[Mono-list] Problem building 1.1.3
</A></li>
	<LI> Next message: <A HREF="025206.html">[Mono-list] ANN: RemObjects Chrome for Mono - Public Preview available now!
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25202">[ date ]</a>
              <a href="thread.html#25202">[ thread ]</a>
              <a href="subject.html#25202">[ subject ]</a>
              <a href="author.html#25202">[ author ]</a>
         </LI>
       </UL>
</body></html>
