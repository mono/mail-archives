<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Mono and the OS/X Port
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jddst19%40mac.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="008224.html">
   <LINK REL="Next"  HREF="008225.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Mono and the OS/X Port
   </H1>
    <B>John Duncan
    </B> 
    <A HREF="mailto:jddst19%40mac.com"
       TITLE="[Mono-list] Mono and the OS/X Port">jddst19@mac.com
       </A><BR>
    <I>Tue, 10 Sep 2002 15:41:31 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="008224.html">[Mono-list] Mono and the OS/X Port
</A></li>
        <LI> Next message: <A HREF="008225.html">[Mono-list] PNG, interface or rewrite?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8230">[ date ]</a>
              <a href="thread.html#8230">[ thread ]</a>
              <a href="subject.html#8230">[ subject ]</a>
              <a href="author.html#8230">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Yes, you're right. I am working on it. Here's where I am:

I have a PB project building mint and libmono (actually, a Framework I 
called mono-cocoa). Mint seems to run but I haven't made it able to run 
mcs.exe. This gives me the tough task of narrowing down mcs.exe by 
building it on Linux until I find where the weakness in mint is. 
Nonetheless, I think I have most of the bugs in the native interface 
worked out and it should only be a matter of time.

I would appreciate help anywhere along the line. Let me know and I'll 
try to package up what I've got. It's a little bit different from the 
basic mono build and it's not production quality.

Anyhow, my goal is to eventually provide a usable runtime for OS X that 
acts in quite a native capacity. I'd like to adopt something similar to 
the approach used for MRJ. This means that the Mono runtime should 
eventually be able to tie in to the Obj-C Cocoa objects and there will 
also be a packager for wrapping up Mono applications in a .app bundle.

I've been working really slowly, though, because I'm on vacation. Having 
someone else egging me along will probably help me to move more quickly.

John

On Tuesday, September 10, 2002, at 11:50 AM, Steve Mentzer wrote:

&gt;<i>
</I>&gt;<i> As of right now, there is little information on the main go-mono web 
</I>&gt;<i> site that indicates that an OS/X port is even being attempted. At 
</I>&gt;<i> least, I was unable to locate any such information...
</I>&gt;<i>
</I>&gt;<i> In any case, after reading the digests, I discovered that an OS/X port 
</I>&gt;<i> is being attempted.... by at least one person.
</I>&gt;<i>
</I>&gt;<i> I am a new windows-&gt;mac switchee who has been developing production 
</I>&gt;<i> software with the MS .net implementation(s) since beta 2. I am eager to 
</I>&gt;<i> begin working on the mono/osx port in whatever capacity.
</I>&gt;<i>
</I>&gt;<i> Given that a large number of MacOS/X developers have been asking where 
</I>&gt;<i> the .net implementation is, would it be wise to extend the existing 
</I>&gt;<i> go-mono web site to include information about the os/x specific port?
</I>&gt;<i>
</I>&gt;<i> I know the demand is there. Droves of my penguin-loving bretheren are 
</I>&gt;<i> beginning to feel the pull of OS/X. I believe there is a historic 
</I>&gt;<i> opportunity to create a viable alternative to IIS for hosting XML web 
</I>&gt;<i> services on a commercially viable *desktop* platform.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -----Original Message-----
</I>&gt;<i> From: Jonathan Pryor [mailto:<A HREF="mailto:jonpryor@vt.edu">jonpryor@vt.edu</A>]
</I>&gt;<i> Sent: Tuesday, September 10, 2002 8:50 AM
</I>&gt;<i> To: Mono List
</I>&gt;<i> Subject: Re: [Mono-list] Question about C#
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Inline...
</I>&gt;<i>
</I>&gt;<i> On Mon, 2002-09-09 at 23:49, Ricardo Kirkner wrote:
</I>&gt;<i>
</I>&gt;<i> &lt;snip/&gt;
</I>&gt;<i>             2. If I want to overload the ++ operator in a class that I
</I>&gt;<i>             dont want to be public, but internal or private, how can I
</I>&gt;<i>             prevent someone from accessing a method (the ++ operator)
</I>&gt;<i>             that has been defined public?
</I>&gt;<i>         Question to ponder: how will they access the public method if
</I>&gt;<i>         they can't access the class in the first place?  Consider
</I>&gt;<i>         methods that must be public, such as Object.ToString().  Is it a
</I>&gt;<i>         problem that this method is public, even in your internal
</I>&gt;<i>         classes?  Not usually -- non-internal users can't access the
</I>&gt;<i>         class, so the existence of a public ToString() method shouldn't
</I>&gt;<i>         be a problem.  The same should be true of any operators.
</I>&gt;<i>
</I>&gt;<i>         (The answer to the above question of accessing internal classes
</I>&gt;<i>         is simple, actually: use Reflection and poke around...
</I>&gt;<i>         Alternatively, modify the runtime to permit poking on internal
</I>&gt;<i>         data.  It's hard to protect against the runtime....  However,
</I>&gt;<i>         these ideas are not trivial, and can probably be ignored most of
</I>&gt;<i>         the time.)
</I>&gt;<i>     This is not really a clean solution, is it? I mean, although I
</I>&gt;<i>     cannot access the class (so I dont have to worry about the
</I>&gt;<i>     &quot;public-nes&quot; of the methods inside that class, it does not mean that
</I>&gt;<i>     it is correct to force you to declare the method public. (although
</I>&gt;<i>     this could be, and probably is, just a simplification made by the
</I>&gt;<i>     language designers)
</I>&gt;<i>
</I>&gt;<i> Again, I'm not sure why operators need to be public.  However, the
</I>&gt;<i> reason for requiring that overridden methods not change the access
</I>&gt;<i> specifiers is to minimize confusion.  Through polymorphism, you're able
</I>&gt;<i> to invoke a derived class implementation through a reference to a base
</I>&gt;<i> class.  Wouldn't it be weird if you couldn't invoke the same method
</I>&gt;<i> through a reference to the derived class?  Consider the following
</I>&gt;<i> C#-like code:
</I>&gt;<i>
</I>&gt;<i>     class Base {
</I>&gt;<i>         public virtual void Calculate () {/* ... */}
</I>&gt;<i>     }
</I>&gt;<i>
</I>&gt;<i>     class Derived : Base {
</I>&gt;<i>         // Note: change protection; not allowed in C#
</I>&gt;<i>         protected override void Calculate () { /* ... */ }
</I>&gt;<i>     }
</I>&gt;<i>
</I>&gt;<i>     class User {
</I>&gt;<i>         public static void Main () {
</I>&gt;<i>             Base b = new Derived ();
</I>&gt;<i>
</I>&gt;<i>             // Legal; method is public
</I>&gt;<i>             b.Calculate ();
</I>&gt;<i>
</I>&gt;<i>             Derived d = new Derived ();
</I>&gt;<i>
</I>&gt;<i>             // Not legal; method is protected!
</I>&gt;<i>             d.Calculate ();
</I>&gt;<i>         }
</I>&gt;<i>     }
</I>&gt;<i> Requiring that overridden methods provide the same access specifiers as
</I>&gt;<i> the base method can be seen as a simplification of the language.  It can
</I>&gt;<i> also be seen as a sane requirement, reducing programmer confusion in
</I>&gt;<i> situations like the example above.
</I>&gt;<i>
</I>&gt;<i>         However, the real question remains: why do you need an
</I>&gt;<i>         assignment operator?  Assignment operators are useful in C++
</I>&gt;<i>         when wrapping resources, such as memory, files, thread locks,
</I>&gt;<i>         etc., to make sure that the resource is properly managed (in
</I>&gt;<i>         concert with the copy constructor and destructor)...  In C#, the
</I>&gt;<i>         garbage collector is used for resource management, removing
</I>&gt;<i>         (what I've found) the greatest need for the trio of C++ copy
</I>&gt;<i>         constructor, assignment operator, and destructor.  If you need
</I>&gt;<i>         something more deterministic, the IDisposable interface/idiom is
</I>&gt;<i>         appropriate.
</I>&gt;<i>
</I>&gt;<i>     I actually dont have a need for an assignment operator, but I think
</I>&gt;<i>     it is really nice if you can do something like
</I>&gt;<i>
</I>&gt;<i>         obj1 = obj2;
</I>&gt;<i>
</I>&gt;<i>     instead of
</I>&gt;<i>
</I>&gt;<i>         obj1 = new ObjectType(obj2);
</I>&gt;<i>
</I>&gt;<i>     This whole issue arises because c# treats objects as references to
</I>&gt;<i>     objects instead as the real ones (not that I find this wrong). I
</I>&gt;<i>     think that if you use a language that tries to be so simple as c#
</I>&gt;<i>     is, and that tries to &quot;help&quot; the programmer by simplifying syntax,
</I>&gt;<i>     etc, then it is suspicious not being able to write a simple object
</I>&gt;<i>     assignment  (without having both variables referencing the same
</I>&gt;<i>     object. Note that by simle I mean using the = operator). This
</I>&gt;<i>     could be just a decision made by the folks who thought about the
</I>&gt;<i>     language (and then I could not make anything about it, of course),
</I>&gt;<i>     so I dont want to make a big discussion about this here (because it
</I>&gt;<i>     is really a C# topic and not mono specific).
</I>&gt;<i>
</I>&gt;<i> Simplicity is often achieved by removing features.  Java is often
</I>&gt;<i> considered to be simple because it removed multiple inheritance,
</I>&gt;<i> operator overloading, enumerations, templates, and lots of other fun C++
</I>&gt;<i> features.  In comparison, C# is considerably less simple than Java, but
</I>&gt;<i> still simpler than C++.  For example, C# followed the Simula-like (and
</I>&gt;<i> Java-like) bifurcation of the type system.  You have stack-allocated
</I>&gt;<i> types, and heap-allocated types, and never the two shall meet.  (This is
</I>&gt;<i> true for Simula and Java, but C# lets you convert the stack-allocated
</I>&gt;<i> objects into heap-allocated objects, bridging the type system.  You
</I>&gt;<i> still can't have any object-type be located on the stack, though.)
</I>&gt;<i> Stroustrup hated this bifurcation, which is why C++ (by default) allows
</I>&gt;<i> objects to be allocated anywhere.  However, C++'s flexibility leads to
</I>&gt;<i> complexity.  The ability to store any object anywhere, coupled with the
</I>&gt;<i> lack of a garbage collector, requires that the programmer be much more
</I>&gt;<i> involved with the lifetime of objects than is required in other
</I>&gt;<i> programming languages.
</I>&gt;<i>
</I>&gt;<i> So .NET simplified things by allowing programmers to have a choice
</I>&gt;<i> between two allocation functions: stack based types (structures), or
</I>&gt;<i> heap-allocated reference types (everything else).  By limiting the
</I>&gt;<i> choices they simplified the language, simplified run-time semantics, and
</I>&gt;<i> allowed for more general optimizations in the runtime.  (For example,
</I>&gt;<i> all copying can be done through bitwise copy operations, increasing
</I>&gt;<i> performance.)  Programming flexibility was less of a requirement than
</I>&gt;<i> simplification, that's all.
</I>&gt;<i>
</I>&gt;<i> Thus we have one form of assignment -- bitwise copy -- with two sets of
</I>&gt;<i> semantics.  Structure assignment, which copies the whole structure, and
</I>&gt;<i> reference assignment, which copies a reference to the actual object.
</I>&gt;<i>
</I>&gt;<i> As you put it, it's just a decision made by the folks who thought about
</I>&gt;<i> the language and the runtime.  I'm sure they had more reasons than the
</I>&gt;<i> above behind their decision, but it was still their decision.
</I>&gt;<i>
</I>&gt;<i>     Finally, I want to thank you Jonathan, for your comments, I believe
</I>&gt;<i>     they helped
</I>&gt;<i>
</I>&gt;<i>     With regards,
</I>&gt;<i>
</I>&gt;<i>     Ricardo Kirkner
</I>&gt;<i>
</I>&gt;<i> - Jon
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@ximian.com">Mono-list@ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@ximian.com">Mono-list@ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="008224.html">[Mono-list] Mono and the OS/X Port
</A></li>
	<LI> Next message: <A HREF="008225.html">[Mono-list] PNG, interface or rewrite?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8230">[ date ]</a>
              <a href="thread.html#8230">[ thread ]</a>
              <a href="subject.html#8230">[ subject ]</a>
              <a href="author.html#8230">[ author ]</a>
         </LI>
       </UL>
</body></html>
