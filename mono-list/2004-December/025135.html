<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Design by Contract
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rshade%40dvsconsulting.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="025106.html">
   <LINK REL="Next"  HREF="025062.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Design by Contract
   </H1>
    <B>Robert Shade
    </B> 
    <A HREF="mailto:rshade%40dvsconsulting.com"
       TITLE="[Mono-list] Design by Contract">rshade@dvsconsulting.com
       </A><BR>
    <I>Fri, 31 Dec 2004 18:17:21 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="025106.html">[Mono-list] Design by Contract
</A></li>
        <LI> Next message: <A HREF="025062.html">[Mono-list] could be Net remoting server app. started when Linux or Mac starts  ? how to set it ?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25135">[ date ]</a>
              <a href="thread.html#25135">[ thread ]</a>
              <a href="subject.html#25135">[ subject ]</a>
              <a href="author.html#25135">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a really neat design idea.  I originally thought you were 
talking about something like what unit testing is for; but, after some 
research, I see that this is much more.

Just to add my two cents, I think I would discourage the attribute idea.

For one, it would mean that your compiled application would have to link 
with your DBC library.  This would mean that the user would have to deal 
with a bunch of #if's so that those attributes would not be compiled in 
production code. Otherwise, the user would be forced to distribute your 
library with their product.

Secondly, attributes would force the checking to be done by a modified 
compiler.  This would seriously limit your target audience to mono 
folks.  Love mono, but the masses are using Microsoft's compiler.

Finally, I would imagine that adding this (admittedly wonderful) 
complexity into the compiler is not something the maintainers would 
like.  It would also increase the learning curve of someone wanting to 
join up on the project.

I would recommend using an external processor similar to some of the 
tools available for aspect oriented programming.  You'd add the DBC 
&quot;hooks&quot; by some sort of special comments or macros.  The former would be 
kind of nice because you'd still be able to compile it with a regular 
compiler.  The latter would require the user to run his or her code 
through the tool before compiling.  Both could then be used as 
placeholders for runtime checking code to be inserted.

An external tool would also allow you to investigate the code flow in 
ways that the compiler may not.  For example, you could do &quot;process&quot; 
time checking of the code to see if your &quot;contracts&quot; are always 
true/false.  (I belive the MS compiler does this for conditionals)  For 
things that were marked &quot;invariant&quot;, you could follow the code flow to 
see if these are modified at any point.  You'd perhaps even be able to 
warn the user under exactly what conditions the contracts would fail. 
If you had that functionality, you would completely eliminate the need 
for the user to have the (runtime) contract checking code present.  The 
user would already know precisely under what conditions errors would 
occur and could add exception handling to take care of it.

/end of brain dump :)

rob

Stephen Touset wrote:
&gt;<i> I've been using C# for quite awhile now, but one feature that I wish was
</I>&gt;<i> available in the language is support for Design by Contract:
</I>&gt;<i> automatically-enforced preconditions and postconditions on functions, and
</I>&gt;<i> invariants on classes.
</I>&gt;<i> 
</I>&gt;<i> Having done some research into the problem, the best approach seems to be
</I>&gt;<i> using attributes. Using statements inside functions works, but induces a
</I>&gt;<i> lot of programmatic overhead; specifically, inheritance rules for DBC
</I>&gt;<i> would need to be implemented manually. Invariants, also, would be tedious:
</I>&gt;<i> code to check against the invariant would need to be added before the
</I>&gt;<i> preconditions and after the postconditions of every function in the class.
</I>&gt;<i> Worse still is that postconditions must be inserted above every return
</I>&gt;<i> statement. This isn't too bad if you insist upon only one return statement
</I>&gt;<i> per function, but for anyone with multiple returns, this becomes tedious
</I>&gt;<i> quickly. And of course, all of these are clear violations of the Don't
</I>&gt;<i> Repeat Yourself rule.
</I>&gt;<i> 
</I>&gt;<i> Attributes seem to be the way to go. The pre/postconditions and invariants
</I>&gt;<i> are, at the core, metadata about the functions and class. The attributes
</I>&gt;<i> themselves would be able to understand their own inheritance criteria, and
</I>&gt;<i> code can automatically be generated to verify the terms of the contract
</I>&gt;<i> wherever needed. Unfortunately, the way attributes in C# are implemented,
</I>&gt;<i> there seems to be no way to practically use them. Reflection may be
</I>&gt;<i> powerful, but there doesn't appear to be a way that an attribute can
</I>&gt;<i> access (or even determine) the function or class that it applies to.
</I>&gt;<i> 
</I>&gt;<i> My initial approach was to use the CodeDom libraries to insert code into
</I>&gt;<i> functions that would be dynamically based upon the applicable attributes,
</I>&gt;<i> and enforce the conditions correctly. However, the inability for
</I>&gt;<i> attributes to access the &quot;calling&quot; class all but cripples this attempt. My
</I>&gt;<i> next thought was to simply have a script which would understand the
</I>&gt;<i> attributes and insert the applicable statements at compile-time. However,
</I>&gt;<i> the need for attribute inheritance quickly caused this approach to become
</I>&gt;<i> unwieldy.
</I>&gt;<i> 
</I>&gt;<i> Does anyone have an idea about how this could be done in a reasonable
</I>&gt;<i> fashion? If so, would anyone be willing to help on the project?
</I>&gt;<i> 
</I>
</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="025106.html">[Mono-list] Design by Contract
</A></li>
	<LI> Next message: <A HREF="025062.html">[Mono-list] could be Net remoting server app. started when Linux or Mac starts  ? how to set it ?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25135">[ date ]</a>
              <a href="thread.html#25135">[ thread ]</a>
              <a href="subject.html#25135">[ subject ]</a>
              <a href="author.html#25135">[ author ]</a>
         </LI>
       </UL>
</body></html>
