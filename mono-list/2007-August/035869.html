<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] [ANNOUNCE] Monotooth 0.1.0 Beta released
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20%5BANNOUNCE%5D%20Monotooth%200.1.0%20Beta%20released&In-Reply-To=46B3057F.7080509%40hytti.uku.fi">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="035868.html">
   <LINK REL="Next"  HREF="035871.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] [ANNOUNCE] Monotooth 0.1.0 Beta released</H1>
    <B>Andreas F&#228;rber</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20%5BANNOUNCE%5D%20Monotooth%200.1.0%20Beta%20released&In-Reply-To=46B3057F.7080509%40hytti.uku.fi"
       TITLE="[Mono-list] [ANNOUNCE] Monotooth 0.1.0 Beta released">andreas.faerber at web.de
       </A><BR>
    <I>Fri Aug  3 07:25:30 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="035868.html">[Mono-list] [ANNOUNCE] Monotooth 0.1.0 Beta released
</A></li>
        <LI>Next message: <A HREF="035871.html">[Mono-list] [ANNOUNCE] Monotooth 0.1.0 Beta released
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35869">[ date ]</a>
              <a href="thread.html#35869">[ thread ]</a>
              <a href="subject.html#35869">[ subject ]</a>
              <a href="author.html#35869">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

&gt;&gt;&gt;&gt;<i> Independent of the underlying implementation it would be more  
</I>&gt;&gt;&gt;&gt;<i> handy if you could provide front-end classes like LocalDevice  
</I>&gt;&gt;&gt;&gt;<i> that wrap any internal platform decisions, so that e.g. the  
</I>&gt;&gt;&gt;&gt;<i> local device's (default) BDADDR can be accessed via  
</I>&gt;&gt;&gt;&gt;<i> LocalDevice.Address (JSR-82 style) instead of having to go  
</I>&gt;&gt;&gt;&gt;<i> through the full-blown factory pattern first - the developer  
</I>&gt;&gt;&gt;&gt;<i> cannot really chose an implementation to use on a given platform  
</I>&gt;&gt;&gt;&gt;<i> as in the classic widget factory example.
</I>&gt;&gt;&gt;<i> This could be done at some point but by now I'll stick to this  
</I>&gt;&gt;&gt;<i> way :). One may use a little longer method chain to achieve this.
</I>&gt;&gt;<i> That's what I'm trying to avoid. So you would be opposed to such a  
</I>&gt;&gt;<i> contribution?
</I>&gt;<i>
</I>&gt;<i> I'm basically not against it, but this way of getting the local  
</I>&gt;<i> device address would break the design a little. I'll see what can  
</I>&gt;<i> be done :).
</I>
I was thinking of a wrapper along these lines:

public class LocalDevice {
	public static ILocalDevice Default {
		return Factory.Create().GetDevice(); // you'll know better
	}
}

leading to an invocating like LocalDevice.Default.Address, hiding the  
underlying complexity.
This way it allows the use of multiple devices and leaves the factory  
pattern untouched; an alternative or addition would be the adapter  
pattern but that'll be much more complicated.

&gt;&gt;&gt;&gt;<i> Also, I see on Linux you are handling the inquiry via a native  
</I>&gt;&gt;&gt;&gt;<i> library and BlueZ's hci_inquiry function - I have recently found  
</I>&gt;&gt;&gt;&gt;<i> their D-Bus interface to be much more powerful (inquiry provides  
</I>&gt;&gt;&gt;&gt;<i> up-to-date RSSI), and using dbus-sharp would reduce the need for  
</I>&gt;&gt;&gt;&gt;<i> native code in that area. I have some example code I could share.
</I>&gt;&gt;&gt;<i> Good idea, I would love to see this approach. The reason I'm  
</I>&gt;&gt;&gt;<i> using the native library-&gt;bluez way is the marshaling problem,  
</I>&gt;&gt;&gt;<i> since hci_inquiry() takes a double struct pointer.
</I>&gt;&gt;<i> You are aware of the ref keyword, MarshalAs attribute and the  
</I>&gt;&gt;<i> marshalling functions? It should be possible to replace virtually  
</I>&gt;&gt;<i> all native code at the cost of typing in all relevant constants  
</I>&gt;&gt;<i> and possibly using overloads. And for the socket stuff  
</I>&gt;&gt;<i> System.Net.Sockets.Socket might be used, feeding it the constants  
</I>&gt;&gt;<i> as integers.
</I>&gt;<i> Yes, I'm very aware of the ref keyword and all the others. The  
</I>&gt;<i> problem with ref keyword is correctly implementing pointer  
</I>&gt;<i> arithmetics, see <A HREF="http://people.csail.mit.edu/albert/bluez-intro/">http://people.csail.mit.edu/albert/bluez-intro/</A> 
</I>&gt;<i> c401.html#bzi-choosing. The main point of my current work is to try  
</I>&gt;<i> to avoid the use of my custom library. If I get the hci_inquiry  
</I>&gt;<i> function to work via Marshaling , then I will definitely add it to  
</I>&gt;<i> code, but now it is very difficult.
</I>
I know how to inquire with BlueZ. ;-) Yet I don't see where the  
pointer arithmetic problem is in that piece of example code. If you  
want to use HCI you can use Marshal.AllocHGlobal with Marshal.SizeOf  
to calculate the size and offsets?

See attached for an alternative way to inquire, which can avoid  
waiting 10 seconds for the first results using events and can supply  
the RSSI.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: DBusInquiry.cs
Type: application/octet-stream
Size: 1627 bytes
Desc: not available
Url : <A HREF="http://lists.ximian.com/pipermail/mono-list/attachments/20070803/0c601fea/attachment.obj">http://lists.ximian.com/pipermail/mono-list/attachments/20070803/0c601fea/attachment.obj</A> 
-------------- next part --------------

&gt;<i> The problem with System.Net.Sockets.Socket (and calling the socket 
</I>&gt;<i> ()/bind()/connect() from BSD socket interface) is that they use  
</I>&gt;<i> special casts to create the connection. The socket() part is not a  
</I>&gt;<i> problem, I can use constants as you said. The problem is bind()/ 
</I>&gt;<i> connect() part of the connections: for example, connect(socket,  
</I>&gt;<i> (struct sockaddr*)address, length). The cast is the problem, since  
</I>&gt;<i> I have tried it already via creating my own structure in Mono and  
</I>&gt;<i> passing it as a parameter to bind(). It failed miserably, since the  
</I>&gt;<i> Marshaling failed to cast it to a form that bind() could understand.
</I>
Sockets are a C API so casts are unlikely to be the problem (it's a  
pointer to a struct either way and is used because C does not have  
the concept of inheritance). More likely is that the managed  
structure used for marshalling was incorrect. I'll look into it.  
Having it managed would be beneficial for using the code in a daemon.

&gt;<i> The extensions will not be a problem, so feel free to create your  
</I>&gt;<i> code and publish it. I will integrate it to Monotooth quite surely,  
</I>&gt;<i> since the aim of my library is to be as cross-platform as possible.
</I>
That would be really great!

Andreas
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="035868.html">[Mono-list] [ANNOUNCE] Monotooth 0.1.0 Beta released
</A></li>
	<LI>Next message: <A HREF="035871.html">[Mono-list] [ANNOUNCE] Monotooth 0.1.0 Beta released
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35869">[ date ]</a>
              <a href="thread.html#35869">[ thread ]</a>
              <a href="subject.html#35869">[ subject ]</a>
              <a href="author.html#35869">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
