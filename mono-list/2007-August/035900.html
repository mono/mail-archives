<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Hang on JIT-ing fn with P/Invoke?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Hang%20on%20JIT-ing%20fn%20with%20P/Invoke%3F&In-Reply-To=001201c7da85%24799fcd90%240302a8c0%40alanpc1">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="035899.html">
   <LINK REL="Next"  HREF="035918.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Hang on JIT-ing fn with P/Invoke?</H1>
    <B>Jonathan Pryor</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Hang%20on%20JIT-ing%20fn%20with%20P/Invoke%3F&In-Reply-To=001201c7da85%24799fcd90%240302a8c0%40alanpc1"
       TITLE="[Mono-list] Hang on JIT-ing fn with P/Invoke?">jonpryor at vt.edu
       </A><BR>
    <I>Thu Aug  9 10:58:02 EDT 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="035899.html">[Mono-list] Hang on JIT-ing fn with P/Invoke?
</A></li>
        <LI>Next message: <A HREF="035918.html">[Mono-list] Hang on JIT-ing fn with P/Invoke?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35900">[ date ]</a>
              <a href="thread.html#35900">[ thread ]</a>
              <a href="subject.html#35900">[ subject ]</a>
              <a href="author.html#35900">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Thu, 2007-08-09 at 14:01 +0100, Andy Hume wrote:
&gt;<i> There may well be something wrong with the P/Invoke definitions :-,),
</I>
I have no idea why it's hanging, but the P/Invoke definitions *are*
wrong:

&gt;<i>     [StructLayout(LayoutKind.Sequential)]
</I>&gt;<i>     class uuid_t
</I>&gt;<i>     {
</I>&gt;<i>         public byte type;
</I>&gt;<i>         public Guid uuid128; //?
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i>     [StructLayout(LayoutKind.Sequential)]
</I>&gt;<i>     class sdp_list_t
</I>&gt;<i>     {
</I>&gt;<i>         public sdp_list_t next;
</I>&gt;<i>         public IntPtr data;
</I>&gt;<i>     }
</I>&gt;<i> 
</I>&gt;<i>     class NativeMethods
</I>&gt;<i>     {
</I>&gt;<i>         const string BluetoothLibrary = &quot;libbluetooth&quot;;
</I>&gt;<i> 
</I>&gt;<i>         //sdp_list_t* sdp_list_append(sdp_list_t* list, void* d);
</I>&gt;<i>         [DllImport(BluetoothLibrary)]
</I>&gt;<i>         internal static extern sdp_list_t sdp_list_append(sdp_list_t list, uuid_t d);
</I>&gt;<i> 
</I>&gt;<i>         //uuid_t* sdp_uuid16_create(uuid_t* uuid, uint16_t data);
</I>&gt;<i>         [DllImport(BluetoothLibrary)]
</I>&gt;<i>         internal static extern uuid_t sdp_uuid16_create(uuid_t uuid, Int16 data);
</I>&gt;<i> 
</I>&gt;<i>     }
</I>
Never use reference types as the return value of a P/Invoke (in this
case, both sdp_list_t and uuid_t are reference types, as you declared
them `class', not `struct').  The reason for this is that the runtime
will allocate a class instance on the GC heap, copy over the
class/structure contents, and free the returned memory [1].  This is
almost *never* what you want, as the memory may (probably will) be freed
by the wrong function, thus corrupting the heap.  Not good.

The correct thing to do is to use IntPtr as the return value, and
marshal the IntPtr into the appropriate type using
Marshal.PtrToStructure().

So a more accurate binding would be:

        struct BluezUuid {
                public byte type;
                public Guid uuid128;
        }
        
        static class NativeMethods {
                const string BluetoothLibrary = &quot;libbluetooth&quot;;
                
                // sdp_list_t* sdp_list_append(sdp_list_t* list, void*
                d);
                internal static extern IntPtr sdp_list_append(IntPtr
                list, 
                	IntPtr d);
                
                // uuid_t* sdp_uuid16_create(uuid_t* uuid, uint16_t
                data);
                internal static extern IntPtr sdp_uuid16_create(
                        ref BluezUuid u, ushort val);
        }

With usage:

        IntPtr uuid = 
            UnixMarshal.AllocHeap(Marshal.SizeOf(typeof(BluezUuid));
        NativeMethods.sdp_uuid16_create(uuid, 0x0100);
        
        IntPtr search_list = NativeMethods.sdp_list_append(IntPtr.Zero,
            uuid);

Yes, this style of programming is horribly unsafe (IntPtrs everywhere!
No compiler-checked type safety!), but you need to conform to what the
existing code is expecting, in this case malloc(3)-allocated memory of
the appropriate size, with no inappropriate implicit marshaling.

 - Jon

[1]
<A HREF="http://www.mono-project.com/Dllimport#Classes_and_Structures_as_Return_Values">http://www.mono-project.com/Dllimport#Classes_and_Structures_as_Return_Values</A>



</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="035899.html">[Mono-list] Hang on JIT-ing fn with P/Invoke?
</A></li>
	<LI>Next message: <A HREF="035918.html">[Mono-list] Hang on JIT-ing fn with P/Invoke?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#35900">[ date ]</a>
              <a href="thread.html#35900">[ thread ]</a>
              <a href="subject.html#35900">[ subject ]</a>
              <a href="author.html#35900">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
