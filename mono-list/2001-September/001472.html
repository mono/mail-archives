<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Performance issue
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:serge%40wildwestsoftware.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001466.html">
   <LINK REL="Next"  HREF="001471.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Performance issue
   </H1>
    <B>Serge
    </B> 
    <A HREF="mailto:serge%40wildwestsoftware.com"
       TITLE="[Mono-list] Performance issue">serge@wildwestsoftware.com
       </A><BR>
    <I>Tue, 4 Sep 2001 21:47:42 +0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="001466.html">[Mono-list] Performance issue
</A></li>
        <LI> Next message: <A HREF="001471.html">[Mono-list] Performance issue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1472">[ date ]</a>
              <a href="thread.html#1472">[ thread ]</a>
              <a href="subject.html#1472">[ subject ]</a>
              <a href="author.html#1472">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> * Range checking: the runtime will detect invalid array access
</I>&gt;<i>           by checking every time the range of the array.
</I>
Sometimes this could be eliminated by unrolling the loop that accesses the
array (this is true in the current MS implementation).
Some code in Mono's System.Security.Cryptography (MD5 stuff) uses this
technique.
Here is the original code on which the above is based -
<A HREF="http://eurosoft.od.ua/mono/Crypto/hashers.tar.gz">http://eurosoft.od.ua/mono/Crypto/hashers.tar.gz</A>
There are C# (optimized and not-optimized), C++ and Java implementations.
Generally this optimized C# code runs as fast as C++ implementation (with
the same optimization applied).
Those who's fluent in x86 Assembly may use ngen tool to produce the native
image (essentialy off-line JIT) and see what's going on ;-)
Basically for urolled loop JIT-produced code performs bounds checks only
during the first pass, it caches the values locally (on the stack), and uses
&quot;cached&quot; values then.
Not sure whether this optimisation is applicable to your code though. And
it's quite possible that some other JIT could perform such optimisation
itself (it's quite clumsy to do it by-hand).
Also, if your array is an instance variable make a local reference to it
before accessing - this will improve speed.
And lastly - if you're just moving memory blocks, use Buffer.BlockCopy

----
Serge







</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001466.html">[Mono-list] Performance issue
</A></li>
	<LI> Next message: <A HREF="001471.html">[Mono-list] Performance issue
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1472">[ date ]</a>
              <a href="thread.html#1472">[ thread ]</a>
              <a href="subject.html#1472">[ subject ]</a>
              <a href="author.html#1472">[ author ]</a>
         </LI>
       </UL>
</body></html>
