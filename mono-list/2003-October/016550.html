<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Marshaling bug?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:pbaena%40uol.com.ar">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="016564.html">
   <LINK REL="Next"  HREF="016551.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Marshaling bug?
   </H1>
    <B>pbaena@uol.com.ar
    </B> 
    <A HREF="mailto:pbaena%40uol.com.ar"
       TITLE="[Mono-list] Marshaling bug?">pbaena@uol.com.ar
       </A><BR>
    <I>Sat, 25 Oct 2003 14:08:29 -0300 (GMT)</I>
    <P><UL>
        <LI> Previous message: <A HREF="016564.html">[Mono-list] Beginners Questions: How to...
</A></li>
        <LI> Next message: <A HREF="016551.html">[Mono-list] Marshaling bug?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16550">[ date ]</a>
              <a href="thread.html#16550">[ thread ]</a>
              <a href="subject.html#16550">[ subject ]</a>
              <a href="author.html#16550">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thank you for all the suggestions. You're right. It seems that the problem is when retrieving from the g_list.

The SWT API is very new so this is expected. The second approach I learned from Gtk#'s List wrapper. The intent of SWT is to be a thin layer on top of Gtk+ so I wouldn't dare to use Gtk#. All in all, Gtk# is very responsive, so I think it wouldn't hurt SWT to be a little higher level. Let's see how this evolves.

Regards!!

&gt;<i> Pardon me for saying this, but your SWT code is borked.  Seriously.
</I>&gt;<i> 
</I>&gt;<i> Why?  Opaque pointer values should be expressed as a System.IntPtr, not
</I>&gt;<i> a System.Int32 (&quot;int&quot;).  This is so that if you ever move to a platform
</I>&gt;<i> with a different sized pointer (say, 64-bit Opteron, or PowerPC 970, or
</I>&gt;<i> UltraSparc, or...), you won't kill all your pointer values.
</I>&gt;<i> 
</I>&gt;<i> Furthermore, you've got arrays where you shouldn't have arrays. 
</I>&gt;<i> Consider the prototype for g_utf8_to_utf16:
</I>&gt;<i> 
</I>&gt;<i> 	gunichar* g_utf8_to_utf16 (const gchar *str,
</I>&gt;<i> 		glong len,
</I>&gt;<i> 		glong *items_read,
</I>&gt;<i> 		glong *items_written,
</I>&gt;<i> 		GError **error);
</I>&gt;<i> 
</I>&gt;<i> Then, consider how C code would call it:
</I>&gt;<i> 
</I>&gt;<i> 	int items_read, items_written;
</I>&gt;<i> 	const char* str = &quot;this is my utf-8 string&quot;;
</I>&gt;<i> 	gunichar* result = 
</I>&gt;<i> 		g_utf8_to_utf16 (str, strlen (str),
</I>&gt;<i> 			&amp;items_read,
</I>&gt;<i> 			&amp;items_written,
</I>&gt;<i> 			NULL /* ignore errors */);
</I>&gt;<i> 
</I>&gt;<i> Assuming that we don't want to handle wrapping GError in C#, this would
</I>&gt;<i> be a better wrapper:
</I>&gt;<i> 
</I>&gt;<i> 	[DllImport(...)]
</I>&gt;<i> 	static extern IntPtr g_utf8_to_utf16 (byte[] str, int len, 
</I>&gt;<i> 		out int items_read, out int items_written,
</I>&gt;<i> 		IntPtr error /* pass IntPtr.Zero for this */);
</I>&gt;<i> 
</I>&gt;<i> Notice that &quot;items_read&quot; and &quot;items_written&quot; are mapped to a &quot;out&quot;
</I>&gt;<i> parameter, instead of an array.  This is more appropriate for this
</I>&gt;<i> function (and for any function similar to it -- items_read and
</I>&gt;<i> items_written aren't holding arrays, they're just an &quot;out&quot; pointer for
</I>&gt;<i> various data).
</I>&gt;<i> 
</I>&gt;<i> To answer your last question: what's the advantage of this:
</I>&gt;<i> 
</I>&gt;<i> 	string s = &quot;Let's i18n, baby...do it hard!&quot;;
</I>&gt;<i> 	IntPtr unmanaged_memory = Marshal.StringToHGlobalAnsi (s);
</I>&gt;<i> 
</I>&gt;<i> over the voluminous amounts of code you demonstrated before?  Well, it's
</I>&gt;<i> shorter.
</I>&gt;<i> 
</I>&gt;<i> But it's also seriously broken, at least from a
</I>&gt;<i> cross-platform/portability perspective.  Here's why:
</I>&gt;<i> 
</I>&gt;<i>   - Not all platforms support &quot;HGLOBAL&quot;.  On Unix platforms, this is
</I>&gt;<i>     likely to be normal g_malloc/g_free, but on Windows, this should
</I>&gt;<i>     be using the GlobalAlloc and GlobalFree Win32 APIs.  Which means
</I>&gt;<i>     you have different functions to call on different platforms, which
</I>&gt;<i>     will be a portability headache.
</I>&gt;<i> 
</I>&gt;<i>   - Even worse, StringToHGlobalAnsi creates an &quot;Ansi&quot; string.  Ansi
</I>&gt;<i>     IS NOT Utf-8.  At least, you can't assume that it is, though it
</I>&gt;<i>     *could* be.  Ansi is, typically, the local code page, and if you've
</I>&gt;<i>     been paying attention to the file-name handling thread on 
</I>&gt;<i>     mono-devel-list, you'd know that trying to mix the current code
</I>&gt;<i>     page with Unicode handling is fraught with danger (and confusion,
</I>&gt;<i>     and annoyance, and users with Pitchforks complaining about your
</I>&gt;<i>     app not working right...).
</I>&gt;<i> 
</I>&gt;<i> So, how do you do string-interop, portably, between Mono &amp; GTK+?  Well,
</I>&gt;<i> you could just use Gtk#, which will tackle this issue (eventually; it
</I>&gt;<i> appears to use Marshal.StringToHGlobalAnsi in some places, so it's
</I>&gt;<i> likely assuming that, under Mono, Ansi == UTF-8).  This is certainly the
</I>&gt;<i> easiest way to go, unless you're dead set on providing *another* GTK+
</I>&gt;<i> wrapper.  (Of course, this places a Gtk# dependency on SWT, which may be
</I>&gt;<i> undesirable.)
</I>&gt;<i> 
</I>&gt;<i> If you do it on your own, you're pretty much stuck doing what you're
</I>&gt;<i> doing in your first example.
</I>&gt;<i> 
</I>&gt;<i> As for why it doesn't work, it could be a regression.  On my system, it
</I>&gt;<i> appears to be correctly converting the .NET UTF-16 input string &quot;str&quot;
</I>&gt;<i> into a UTF-8 string -- I'm able to pass &quot;data&quot; to g_printf and see
</I>&gt;<i> unmanaged representation.
</I>&gt;<i> 
</I>&gt;<i> It's the return trip -- converting the UTF-8 unmanaged memory and
</I>&gt;<i> copying it into the CLI char[] array, that appears to be the problem. 
</I>&gt;<i> I'll need to write a small test case, and if this is a new marshalling
</I>&gt;<i> bug, I'll file it in bugzilla.
</I>&gt;<i> 
</I>&gt;<i> Thanks,
</I>&gt;<i>  - Jon
</I>&gt;<i> 
</I>&gt;<i> On Sat, 2003-10-25 at 09:52, <A HREF="mailto:pbaena@uol.com.ar">pbaena@uol.com.ar</A> wrote:
</I>&gt;<i> &gt; I reported a bug (#50116) about this problem of mine (of SWT really), and I wanted to get help from the experts to see if the API can be improved.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; SWT works this way to append and retrieve from a g_list:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; --------------------------------CODE-------------------------
</I>&gt;<i> &gt; using System;
</I>&gt;<i> &gt; using System.Runtime.InteropServices;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; class testbug {
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; public const string GLIB_LIBRARY        = &quot;glib-2.0&quot;;
</I>&gt;<i> &gt; public const string STRLEN_LIBRARY      = &quot;pango-1.0&quot;;
</I>&gt;<i> &gt; public const string MEMMOVE_LIBRARY     = &quot;gtk-x11-2.0&quot;;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [DllImport(GLIB_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern int g_utf16_to_utf8(char[] str, int len, int[]
</I>&gt;<i> &gt; items_read, int[] items_written, int[] error);
</I>&gt;<i> &gt; [DllImport(GLIB_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern int g_utf8_to_utf16(byte[] str, int len, int[]
</I>&gt;<i> &gt; items_read, int[] items_written, int[] error);
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [DllImport(STRLEN_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern int strlen(int str);
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [DllImport(MEMMOVE_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern void memmove(int dest, int[] src, int size);
</I>&gt;<i> &gt; [DllImport(MEMMOVE_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern void memmove(int dest, byte[] src, int size);
</I>&gt;<i> &gt; [DllImport(MEMMOVE_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern void memmove(int[] dest, byte[] src, int size);
</I>&gt;<i> &gt; [DllImport(MEMMOVE_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern void memmove(byte[] dest, int src, int size);
</I>&gt;<i> &gt; [DllImport(MEMMOVE_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern void memmove(char[] dest, int src, int size);
</I>&gt;<i> &gt; [DllImport(MEMMOVE_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern void memmove(int[] dest, int src, int size); 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [DllImport(GLIB_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern void g_free(int mem);
</I>&gt;<i> &gt; [DllImport(GLIB_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern int g_malloc(int size); 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [DllImport(GLIB_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern int g_list_append(int list, int data); 
</I>&gt;<i> &gt; [DllImport(GLIB_LIBRARY, CharSet = CharSet.Unicode)]
</I>&gt;<i> &gt; public static extern int g_list_nth_data(int list, int n);
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt; public static void Main ()
</I>&gt;<i> &gt; { 
</I>&gt;<i> &gt;         string str = &quot;Let's i18n, baby...do it hard!&quot;;
</I>&gt;<i> &gt;         int glist = 0; 
</I>&gt;<i> &gt;         bool terminate = true;
</I>&gt;<i> &gt;         char [] strchar = str.ToCharArray(); 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;         int [] items_read = new int [1], items_written = new int [1];
</I>&gt;<i> &gt;         int ptr = g_utf16_to_utf8 (strchar, str.Length, items_read, 
</I>&gt;<i> &gt; items_written, null);
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;         int written = items_written [0];
</I>&gt;<i> &gt;         //TEMPORARY CODE - convertion stops at the first NULL 
</I>&gt;<i> &gt;         if (items_read [0] != strchar.Length) written++;
</I>&gt;<i> &gt;         byte [] buffer = new byte [written + (terminate ? 1 : 0)]; 
</I>&gt;<i> &gt;         memmove (buffer, ptr, written);
</I>&gt;<i> &gt;         g_free (ptr); 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;         int data = g_malloc (buffer.Length);
</I>&gt;<i> &gt;         memmove (data, buffer, buffer.Length); 
</I>&gt;<i> &gt;         glist = g_list_append (glist, data);
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt;         data = g_list_nth_data (glist, 0);
</I>&gt;<i> &gt;         int length = strlen (data); 
</I>&gt;<i> &gt;         byte [] buffer1 = new byte [length];
</I>&gt;<i> &gt;         memmove (buffer1, data, length); 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;         ptr = g_utf8_to_utf16 (buffer1, buffer1.Length, null,
</I>&gt;<i> &gt; items_written, null); 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;         length = items_written [0]; 
</I>&gt;<i> &gt;         char [] chars = new char [length];
</I>&gt;<i> &gt;         memmove (chars, ptr, length * 2); 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;         Console.WriteLine (chars); 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;         g_free (ptr); 
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; ------------------------------------------------------------------
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; That worked till mono 0.28, but doesn't work with current mono from CVS. Now I was testing things and found that this other approach to the problem works:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; ------------------------------CODE--------------------------------
</I>&gt;<i> &gt; using System;
</I>&gt;<i> &gt; using System.Runtime.InteropServices;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; class testbug {
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; public const string GLIB_LIBRARY        = &quot;glib-2.0&quot;;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [DllImport(GLIB_LIBRARY, CharSet = CharSet.Unicode)] 
</I>&gt;<i> &gt; public static extern int g_list_append(int list, IntPtr data);
</I>&gt;<i> &gt; [DllImport(GLIB_LIBRARY, CharSet = CharSet.Unicode)] 
</I>&gt;<i> &gt; public static extern string g_list_nth_data(int list, int n);
</I>&gt;<i> &gt;  
</I>&gt;<i> &gt; public static void Main ()
</I>&gt;<i> &gt; { 
</I>&gt;<i> &gt;         string str = &quot;Let's i18n, baby...do it hard!&quot;;
</I>&gt;<i> &gt;         int glist = 0; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 	glist = g_list_append (glist, Marshal.StringToHGlobalAnsi (str)); 
</I>&gt;<i> &gt;         string data2 = g_list_nth_data (glist, 0); 
</I>&gt;<i> &gt; 	Console.WriteLine (data2);
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 	return;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; ----------------------------------------------------------------
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Now I was wondering what are the advantages of the latest approach in contrast with SWT's. Can you give me some advice?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Thank you very much!
</I>&gt;<i> &gt; Pablo
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-list maillist  -  <A HREF="mailto:Mono-list@lists.ximian.com">Mono-list@lists.ximian.com</A>
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@lists.ximian.com">Mono-list@lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>
</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="016564.html">[Mono-list] Beginners Questions: How to...
</A></li>
	<LI> Next message: <A HREF="016551.html">[Mono-list] Marshaling bug?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16550">[ date ]</a>
              <a href="thread.html#16550">[ thread ]</a>
              <a href="subject.html#16550">[ subject ]</a>
              <a href="author.html#16550">[ author ]</a>
         </LI>
       </UL>
</body></html>
