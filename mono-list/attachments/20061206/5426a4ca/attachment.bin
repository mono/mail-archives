Index: UdpClient.cs
===================================================================
--- UdpClient.cs	(revision 69142)
+++ UdpClient.cs	(working copy)
@@ -335,16 +335,119 @@
 			return newArray;
 		}
 #endregion
+
+#region Async Data I/O
+	
+		
+	public IAsyncResult BeginReceive (AsyncCallback requestCallback, Object state)
+ 	{
+    	CheckDisposed ();
+		
+		byte[] Buffer = new byte[64*1024];
+		
+		return socket.BeginReceive(Buffer, 0, 64*1024, SocketFlags.None, requestCallback, state);
+	}
+	
+	// asyncResult is of type Socket.SocketAsyncResult
+	public byte[] EndReceive (IAsyncResult asyncResult, ref IPEndPoint remoteEP)
+	{
+		CheckDisposed ();
+		
+		int PacketSize;
+		EndPoint EP = (EndPoint)remoteEP;
+		
+		PacketSize = socket.EndReceiveFrom(asyncResult, ref EP);
+				
+		byte [] Result = new byte[PacketSize];
+		Array.Copy(((Socket.SocketAsyncResult)asyncResult).Buffer, 0, Result, 0, PacketSize);
+		return Result;
+	}
+	
+	public IAsyncResult BeginSend (byte[] datagram, int bytes, 
+								   AsyncCallback requestCallback, Object state)
+	{
+		CheckDisposed ();
+
+		if (datagram == null)
+			throw new ArgumentNullException ("dgram is null");
+
+        if (!active)
+            throw new InvalidOperationException ("Operation not allowed on " + 
+                                                 "non-connected sockets.");				
+
+		return socket.BeginSend(datagram, 0, bytes, SocketFlags.None, requestCallback, state);
+	}
+	
+	public IAsyncResult BeginSend (byte[] datagram, int bytes, IPEndPoint endPoint,
+    							   AsyncCallback requestCallback, Object state)
+	{
+		CheckDisposed ();
+
+		if (datagram == null)
+			throw new ArgumentNullException ("datagram is null");
+
+        if (!active)
+            throw new InvalidOperationException ("Operation not allowed on " + 
+                                                 "connected sockets.");     		
+
+		EndPoint EP = (EndPoint)endPoint;
+		return socket.BeginSendTo(datagram, 0, bytes, SocketFlags.None, EP,
+								  requestCallback, state);	
+	}
+
+	public IAsyncResult BeginSend (byte[] datagram, int bytes, 
+	                               string hostname, int port,
+    							   AsyncCallback requestCallback, Object state)
+	{
+		CheckDisposed ();
+		
+		if (datagram == null)
+			throw new ArgumentNullException ("datagram is null");
+    
+        if (!active)
+            throw new InvalidOperationException ("Operation not allowed on " + 
+                                                 "connected sockets.");     			
+
+		IPEndPoint RemoteEP = new IPEndPoint(IPAddress.Parse(hostname), port);
+		
+		return BeginSend(datagram, bytes, RemoteEP, requestCallback, state);						  
+	}
+	
+	
+	public int EndSend (IAsyncResult asyncResult)
+	{
+		CheckDisposed ();
+		return socket.EndSend(asyncResult);
+	}
+
+	
+#endregion
+
+
 #region Properties
 		protected bool Active {
 			get { return active; }
 			set { active = value; }
 		}
 
-		protected Socket Client {
+		public Socket Client {
 			get { return socket; }
 			set { socket = value; }
 		}
+		
+		public bool MulticastLoopback { 
+			get {  
+				return (bool)socket.GetSocketOption(SocketOptionLevel.IP,
+				                                    SocketOptionName.MulticastLoopback);
+			}
+			set { 
+				int OptionValue = (value?1:0); // since when is (int)bool not allowed?
+				socket.SetSocketOption(SocketOptionLevel.IP, 
+				                       SocketOptionName.MulticastLoopback, 
+				                       OptionValue);
+			}
+		}
+		
 #endregion
 #region Disposing
 		void IDisposable.Dispose ()
Index: Socket.cs
===================================================================
--- Socket.cs	(revision 69142)
+++ Socket.cs	(working copy)
@@ -45,7 +45,7 @@
 {
 	public class Socket : IDisposable 
 	{
-		enum SocketOperation {
+		internal enum SocketOperation {
 			Accept,
 			Connect,
 			Receive,
@@ -59,7 +59,7 @@
 		}
 
 		[StructLayout (LayoutKind.Sequential)]
-		private sealed class SocketAsyncResult: IAsyncResult 
+		internal sealed class SocketAsyncResult: IAsyncResult 
 		{
 			/* Same structure in the runtime */
 			public Socket Sock;
