Index: class/Mono.Posix/Mono.Unix.Native/LibMagic.cs
===================================================================
--- class/Mono.Posix/Mono.Unix.Native/LibMagic.cs	(revision 0)
+++ class/Mono.Posix/Mono.Unix.Native/LibMagic.cs	(revision 0)
@@ -0,0 +1,50 @@
+using System;
+using System.Runtime.InteropServices;
+using Mono.Unix.Native;
+
+namespace Mono.Unix.Native
+{
+    
+    [Flags]
+    public enum MAGIC_FLAGS
+    {
+        MAGIC_NONE              = 0,
+        MAGIC_DEBUG             = 1,
+        MAGIC_SYMLINK           = 1 << 1,
+        MAGIC_COMPRESS          = 1 << 2,
+        MAGIC_DEVICES           = 1 << 3,
+        MAGIC_MIME              = 1 << 4,
+        MAGIC_CONTINUE          = 1 << 5,
+        MAGIC_CHECK             = 1 << 6,
+        MAGIC_PRESERVE_ATIME    = 1 << 7,
+        MAGIC_RAW               = 1 << 8,
+        MAGIC_ERROR             = 1 << 9
+    }
+
+    public static class LibMagic
+    {
+        [DllImport("magic")]
+        public extern static IntPtr magic_open(MAGIC_FLAGS flags);
+
+        [DllImport("magic")]
+        public extern static void magic_close(IntPtr magic_cookie);
+
+        [DllImport("magic")]
+        public extern static int magic_setflags(IntPtr magic_cookie, MAGIC_FLAGS flags);
+
+        [DllImport("magic")]
+        public extern static IntPtr magic_file(IntPtr magic_cookie,
+                                                [MarshalAs (UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(FileNameMarshaler))] string filename);
+
+        [DllImport("magic")]
+        public extern static IntPtr magic_buffer(IntPtr magic_cookie, Byte[] data, int len);
+
+        [DllImport("magic")]
+        public extern static IntPtr magic_error(IntPtr magic_cookie);
+
+        [DllImport("magic")]
+        public extern static int magic_load(IntPtr magic_cookie,
+                                             [MarshalAs (UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(FileNameMarshaler))] string filename);
+        
+    }
+}
Index: class/Mono.Posix/Mono.Posix.dll.sources
===================================================================
--- class/Mono.Posix/Mono.Posix.dll.sources	(revision 65832)
+++ class/Mono.Posix/Mono.Posix.dll.sources	(working copy)
@@ -6,6 +6,7 @@
 ./Mono.Unix/FileAccessPermissions.cs
 ./Mono.Unix/FileAccessPattern.cs
 ./Mono.Unix/FileHandleOperations.cs
+./Mono.Unix/FileMagicDb.cs
 ./Mono.Unix/FileSpecialAttributes.cs
 ./Mono.Unix/FileTypes.cs
 ./Mono.Unix/MapAttribute.cs
@@ -32,6 +33,7 @@
 ./Mono.Unix.Native/CdeclFunction.cs
 ./Mono.Unix.Native/FileNameMarshaler.cs
 ./Mono.Unix.Native/HeaderAttribute.cs
+./Mono.Unix.Native/LibMagic.cs
 ./Mono.Unix.Native/NativeConvert.cs
 ./Mono.Unix.Native/NativeConvert.generated.cs
 ./Mono.Unix.Native/Stdlib.cs
Index: class/Mono.Posix/Mono.Unix/FileMagicDb.cs
===================================================================
--- class/Mono.Posix/Mono.Unix/FileMagicDb.cs	(revision 0)
+++ class/Mono.Posix/Mono.Unix/FileMagicDb.cs	(revision 0)
@@ -0,0 +1,163 @@
+using System;
+using System.IO;
+using System.Runtime.InteropServices;
+using Mono.Unix.Native;
+
+namespace Mono.Unix {
+
+    public class MagicDbException : Exception
+    {
+        string _text;
+        
+        public MagicDbException(string text) : base()
+        {
+            _text = text;
+        }
+
+        override public string ToString()
+        {
+            return _text;
+        }
+    }
+
+    public class FileMagicDb : IDisposable
+    {
+        IntPtr  _magic = IntPtr.Zero;
+        bool    _followSymlinks = false;
+
+        // open the magic database with default database files
+        public FileMagicDb(bool ReturnMime)
+        {
+            _magic = LibMagic.magic_open((ReturnMime) ? DefaultFlags | MAGIC_FLAGS.MAGIC_MIME : DefaultFlags);
+            if (_magic == IntPtr.Zero)
+                throw new MagicDbException("Unable to open the magic database");
+
+            if (LibMagic.magic_load(_magic, null) != 0)
+                throw new MagicDbException(this.Error);
+                
+        }
+
+        // open the magic database with a custom database file list
+        public FileMagicDb(bool ReturnMime, string[] dblist)
+        {
+            _magic = LibMagic.magic_open((ReturnMime) ? DefaultFlags | MAGIC_FLAGS.MAGIC_MIME : DefaultFlags);
+            if (_magic == IntPtr.Zero)
+                throw new MagicDbException("Unable to open the magic database");
+
+            foreach(string file in dblist) {
+                if (LibMagic.magic_load(_magic, file) != 0)
+                    throw new MagicDbException(this.Error);
+            }
+            
+        }
+
+        ~FileMagicDb()
+        {
+            if (_magic != IntPtr.Zero) {
+                LibMagic.magic_close(_magic);
+                 _magic = IntPtr.Zero;
+            }
+        }
+
+        public void Dispose ()
+        {
+            if (_magic != IntPtr.Zero) {
+                LibMagic.magic_close(_magic);
+                _magic = IntPtr.Zero;
+            }
+
+            GC.SuppressFinalize(this);
+        }
+
+        public void AddDefaultDbFiles()
+        {
+            if (LibMagic.magic_load(_magic, null) != 0)
+                throw new MagicDbException(this.Error); 
+        }
+
+        public void AddDbFile(string file)
+        {
+            if (LibMagic.magic_load(_magic, file) != 0)
+                throw new MagicDbException(this.Error); 
+        }
+
+        public bool FollowSymlinks
+        {
+            get {
+                return _followSymlinks;
+            }
+
+            set {
+                LibMagic.magic_setflags(_magic, (value) ? DefaultFlags | MAGIC_FLAGS.MAGIC_MIME : DefaultFlags);
+                _followSymlinks = value;
+            }
+            
+        }
+
+        private string Error
+        {
+            get {
+                return Marshal.PtrToStringAuto(LibMagic.magic_error(_magic));
+            }
+        }
+
+        public string Lookup(string filename)
+        {
+            string text;
+            
+            text = Marshal.PtrToStringAuto(LibMagic.magic_file(_magic, filename));
+            if (text == null)
+                throw new MagicDbException(this.Error);
+
+            return text;
+        }
+
+        public string Lookup(FileInfo fi)
+        {
+            return Lookup(fi.FullName);
+        }
+
+        public string Lookup(byte[] data)
+        {
+            string text;
+
+            text = Marshal.PtrToStringAuto(LibMagic.magic_buffer(_magic, data, data.Length));
+            if (text == null)
+                throw new MagicDbException(this.Error);
+
+            return text;   
+        }
+
+        static public string Mime(string filename)
+        {
+            string mime;
+            FileMagicDb m = new FileMagicDb(true);
+
+            mime = Marshal.PtrToStringAuto(LibMagic.magic_file(m._magic, filename)); 
+            if (mime == null) {
+                throw new MagicDbException(m.Error);
+            }
+
+            return mime;
+        }
+
+        static public string Description(string filename)
+        {
+            string desc;
+            FileMagicDb m = new FileMagicDb(false);
+
+            desc = Marshal.PtrToStringAuto(LibMagic.magic_file(m._magic, filename)); 
+            if (desc == null) {
+                throw new MagicDbException(m.Error);
+            }
+
+            return desc;
+        }
+
+        private static MAGIC_FLAGS DefaultFlags{
+            get {
+                return MAGIC_FLAGS.MAGIC_NONE | MAGIC_FLAGS.MAGIC_PRESERVE_ATIME;
+            }
+        }        
+    }
+}
