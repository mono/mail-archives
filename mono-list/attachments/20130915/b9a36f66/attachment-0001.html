<tt>
&lt;div&nbsp;dir=&quot;ltr&quot;&gt;&lt;pre&gt;I&nbsp;wondered&nbsp;if&nbsp;it&nbsp;would&nbsp;be&nbsp;possible&nbsp;to&nbsp;have&nbsp;some&nbsp;advice&nbsp;on&nbsp;how&nbsp;tail<br>
recursion&nbsp;elimination&nbsp;works&nbsp;in&nbsp;Mono.&nbsp;I&nbsp;would&nbsp;like&nbsp;to&nbsp;understand&nbsp;under<br>
what&nbsp;circumstances&nbsp;Mono&nbsp;can&nbsp;do&nbsp;a&nbsp;tail&nbsp;recursive&nbsp;call&nbsp;without&nbsp;leaving<br>
the&nbsp;caller&nbsp;on&nbsp;the&nbsp;stack,&nbsp;and&nbsp;when&nbsp;it&nbsp;cannot.&nbsp;I&nbsp;am&nbsp;afraid&nbsp;I&nbsp;could&nbsp;not<br>
find&nbsp;this&nbsp;information&nbsp;anywhere,&nbsp;though&nbsp;I&nbsp;did&nbsp;not&nbsp;try&nbsp;reading&nbsp;the<br>
sources.&nbsp;Many&nbsp;thanks&nbsp;in&nbsp;advance.<br>
<br>
I&nbsp;have&nbsp;a&nbsp;large&nbsp;F#&nbsp;project&nbsp;that&nbsp;I&nbsp;want&nbsp;to&nbsp;run&nbsp;under&nbsp;Mono,&nbsp;and&nbsp;was<br>
pleased&nbsp;to&nbsp;see&nbsp;that&nbsp;all&nbsp;1500+&nbsp;unit&nbsp;tests&nbsp;passed&nbsp;the&nbsp;first&nbsp;time&nbsp;under<br>
3.2.1.&nbsp;However,&nbsp;my&nbsp;code&nbsp;runs&nbsp;out&nbsp;of&nbsp;stack&nbsp;once&nbsp;applied&nbsp;to&nbsp;non-trivial<br>
input,&nbsp;even&nbsp;when&nbsp;I&nbsp;allocate&nbsp;a&nbsp;gigabyte&nbsp;of&nbsp;stack.<br>
<br>
Here&nbsp;is&nbsp;a&nbsp;cut-down&nbsp;example&nbsp;that&nbsp;started&nbsp;its&nbsp;life&nbsp;as&nbsp;a&nbsp;much&nbsp;larger&nbsp;fold<br>
(which&nbsp;would&nbsp;be&nbsp;prohibitively&nbsp;expensive&nbsp;to&nbsp;rewrite&nbsp;in&nbsp;imperative<br>
style).&nbsp;Under&nbsp;.net&nbsp;it&nbsp;runs&nbsp;to&nbsp;completion,&nbsp;whereas&nbsp;under&nbsp;Mono&nbsp;it&nbsp;dies<br>
after&nbsp;i&nbsp;reaches&nbsp;17.&nbsp;Is&nbsp;there&nbsp;a&nbsp;way&nbsp;of&nbsp;rewriting&nbsp;the&nbsp;map&nbsp;so&nbsp;that&nbsp;it<br>
would&nbsp;not&nbsp;leave&nbsp;anything&nbsp;on&nbsp;the&nbsp;stack&nbsp;when&nbsp;evaluating&nbsp;f?<br>
<br>
[I&nbsp;cannot&nbsp;just&nbsp;use&nbsp;List.map&nbsp;because&nbsp;it&nbsp;stays&nbsp;on&nbsp;the&nbsp;stack&nbsp;while<br>
applying&nbsp;f,&nbsp;and&nbsp;so&nbsp;would&nbsp;cause&nbsp;an&nbsp;overflow&nbsp;e.g.&nbsp;if&nbsp;given&nbsp;a&nbsp;function<br>
that&nbsp;uses&nbsp;the&nbsp;same&nbsp;call&nbsp;to&nbsp;map&nbsp;again&nbsp;over&nbsp;and&nbsp;over&nbsp;as&nbsp;it&nbsp;descends&nbsp;down<br>
a&nbsp;data&nbsp;structure.]<br>
<br>
fsharpc&nbsp;--tailcalls+&nbsp;tailtest.fs<br>
mono&nbsp;--optimize=tailc&nbsp;tailtest.exe<br>
<br>
&nbsp;&nbsp;&nbsp;let&nbsp;rec&nbsp;mapk&nbsp;f&nbsp;xs&nbsp;k&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;xs&nbsp;with<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[]&nbsp;-&gt;&nbsp;k&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;x::xs&nbsp;-&gt;&nbsp;mapk&nbsp;f&nbsp;xs&nbsp;(fun&nbsp;xs&#39;&nbsp;-&gt;&nbsp;f&nbsp;x&nbsp;(fun&nbsp;x&#39;&nbsp;-&gt;&nbsp;(x&#39;&nbsp;::&nbsp;xs&#39;)&nbsp;|&gt;&nbsp;k))<br>
<br>
&nbsp;&nbsp;&nbsp;let&nbsp;test_tail&nbsp;n&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;&quot;Testing&nbsp;depth&nbsp;%u\n&quot;&nbsp;n<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;xs&nbsp;=&nbsp;[1..n]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;expected&nbsp;=&nbsp;List.map&nbsp;(fun&nbsp;x&nbsp;-&gt;&nbsp;x&nbsp;+&nbsp;1)&nbsp;xs<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;actual&nbsp;=&nbsp;mapk&nbsp;(fun&nbsp;x&nbsp;k&nbsp;-&gt;&nbsp;k&nbsp;(x&nbsp;+&nbsp;1))&nbsp;xs&nbsp;id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;expected&nbsp;&lt;&gt;&nbsp;actual&nbsp;then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;failwithf&nbsp;&quot;Something&nbsp;went&nbsp;badly&nbsp;wrong&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;for&nbsp;i=0&nbsp;to&nbsp;25&nbsp;do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_tail&nbsp;(1&lt;&lt;&lt;i)<br>
&lt;/pre&gt;&lt;/div&gt;<br>

</tt>
