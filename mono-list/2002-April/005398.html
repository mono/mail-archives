<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] RFC: Corlib Unit Test on Linux How-To
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:linus%40linus.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="005397.html">
   <LINK REL="Next"  HREF="005372.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] RFC: Corlib Unit Test on Linux How-To
   </H1>
    <B>Linus Upson
    </B> 
    <A HREF="mailto:linus%40linus.com"
       TITLE="[Mono-list] RFC: Corlib Unit Test on Linux How-To">linus@linus.com
       </A><BR>
    <I>Tue, 30 Apr 2002 15:17:55 -0700</I>
    <P><UL>
        <LI> Previous message: <A HREF="005397.html">[Mono-list] RFC: Corlib Unit Test on Linux How-To
</A></li>
        <LI> Next message: <A HREF="005372.html">[Mono-list] baselabs binaries + Red Hat Skipjack 7.2.93, segfault
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5398">[ date ]</a>
              <a href="thread.html#5398">[ thread ]</a>
              <a href="subject.html#5398">[ subject ]</a>
              <a href="author.html#5398">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Here is a test case that shows that the .Net runtime looks for a
matching catch block before executing the finally blocks:

// FinallyTest.cs

using System;

public class FinallyTest {
    public static void MyHandler(object sender,
        UnhandledExceptionEventArgs args) {

        Console.WriteLine(&quot;UnhandledExceptionEventHandler called&quot;);
    }

    public static void Main() {
        Console.WriteLine(&quot;Top level block&quot;);

        AppDomain domain = AppDomain.CurrentDomain;
        domain.UnhandledException +=
            new UnhandledExceptionEventHandler(MyHandler);

        try {
            Console.WriteLine(&quot;First try block&quot;);
            try {
                Console.WriteLine(&quot;Second try block&quot;);
                throw new Exception();
            } finally {
                Console.WriteLine(&quot;Second finally block&quot;);
            }
        } finally {
            Console.WriteLine(&quot;First finally block&quot;);
        }

        Console.WriteLine(&quot;Back to top level block&quot;);
    }
}

When compiled and run on .Net it outputs the following:

$ FinallyTest.exe
Top level block
First try block
Second try block
UnhandledExceptionEventHandler called
Second finally block
First finally block
(null)

Without the custom UnhandledExceptionEventHandler installed, you get the
standard unhandled exception message between the second try block and
the second finally block. .Net also brings up a panel asking if you want
to debug the program. Only after you dismiss the panel do the finally
blocks run.

I'm not sure why they chose to do this, but it does look intentional. My
only guess so far is that they wanted to allow developers the
opportunity to inspect the program's state with a debugger before any of
the finally blocks ran.

Linus


-----Original Message-----
From: <A HREF="mailto:mono-list-admin@ximian.com">mono-list-admin@ximian.com</A> [mailto:<A HREF="mailto:mono-list-admin@ximian.com">mono-list-admin@ximian.com</A>] On
Behalf Of Martijn Stegeman
Sent: Tuesday, April 30, 2002 10:25 AM
To: Mono List
Subject: RE: [Mono-list] RFC: Corlib Unit Test on Linux How-To


&quot;The code inside the finally block is guaranteed to execute before the
exit
of the function, whether there is an exception or not.&quot; - Eric
Gunnerson, A
Programmer's Introduction to C#.

&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="mailto:mono-list-admin@ximian.com">mono-list-admin@ximian.com</A> [mailto:<A HREF="mailto:mono-list-admin@ximian.com">mono-list-admin@ximian.com</A>]On
</I>&gt;<i> Behalf Of Charles Wiltgen
</I>&gt;<i> Sent: Tuesday, April 30, 2002 7:01 PM
</I>&gt;<i> To: Mono List
</I>&gt;<i> Subject: Re: [Mono-list] RFC: Corlib Unit Test on Linux How-To
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Dietmar Maurer wrote...
</I>&gt;<i>
</I>&gt;<i> &gt;&gt; I have a vague recollection of reading somewhere that .Net doesn't
</I>run
&gt;<i> &gt;&gt; finally clauses until it finds a matching catch block for the
</I>&gt;<i> exception.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; really - that sounds strange.
</I>&gt;<i>
</I>&gt;<i> &quot;Applied Microsoft .NET Framework Programming&quot; says that finally is
</I>&gt;<i> guaranteed to execute no mater what kind of exception is thrown,
</I>whether
&gt;<i> or not the try statement has any catch blocks.
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> Charles Wiltgen
</I>&gt;<i>
</I>&gt;<i>   &quot;Love is a snowmobile racing across the tundra and
</I>&gt;<i>    then suddenly it flips over, pinning you underneath.
</I>&gt;<i>    At night, the ice weasels come.&quot; - Nietzsche (Groening)
</I>


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="005397.html">[Mono-list] RFC: Corlib Unit Test on Linux How-To
</A></li>
	<LI> Next message: <A HREF="005372.html">[Mono-list] baselabs binaries + Red Hat Skipjack 7.2.93, segfault
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5398">[ date ]</a>
              <a href="thread.html#5398">[ thread ]</a>
              <a href="subject.html#5398">[ subject ]</a>
              <a href="author.html#5398">[ author ]</a>
         </LI>
       </UL>
</body></html>
