<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Re: mono/mint on powerpc
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="005613.html">
   <LINK REL="Next"  HREF="005614.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Re: mono/mint on powerpc
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="[Mono-list] Re: mono/mint on powerpc">miguel@ximian.com
       </A><BR>
    <I>09 May 2002 22:32:22 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="005613.html">[Mono-list] Re: mono/mint on powerpc
</A></li>
        <LI> Next message: <A HREF="005614.html">[Mono-list] Thinking in C#
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5617">[ date ]</a>
              <a href="thread.html#5617">[ thread ]</a>
              <a href="subject.html#5617">[ subject ]</a>
              <a href="author.html#5617">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> Another big task is to port mono jitter to ppc. I've been waiting some
</I>&gt;<i> time before things stabilize enough, one time it looked like we will
</I>&gt;<i> maybe start another jitter, but lately it looks like current gets better
</I>&gt;<i> and better. Ask jitter dudes if they think that jitter is ready for
</I>&gt;<i> porting.
</I>
My current feeling is that the JIT architecture we have is fine, but if
your risc CPU has some unusual instruction scheduling restrictions, then
I suggest that you write a &quot;layer&quot; that would perform instruction
scheduling after selection.

Imagine (for a second) that you are writing the JIT production rules for
the sparc, and you have something like this:

reg: coni4 1 {
	sparc_sethi (s-&gt;code, tree-&gt;reg1, tree-&gt;data.i &gt;&gt; 10);
	sparc_or_imm (s-&gt;code, FALSE, tree-&gt;reg1, tree-&gt;data.i &amp; 1023, tree-&gt;reg1);
}

and consider the following &quot;x86&quot; definition:

stmt: BR {
	mono_add_jump_info (s, s-&gt;code + 1, MONO_JUMP_INFO_BB, tree-&gt;data.bb);
	x86_jump32 (s-&gt;code, 0); 
}

Since the SPARC will always execute the next instruction, you would
write the second example for the sparc  like this (given the current JIT
framework):

stmt: BR {
	mono_add_jump_info (s, s-&gt;code + 1, MONO_JUMP_INFO_BB, tree-&gt;data.bb);
	sparc_jmpl (s-&gt;code, 0);
	sparc_nop (s-&gt;code);
}

Notice the ugly extra nop in there.  So what I propose for those
architectures that need instruction scheduling is to not generate code
directly there, but instead write a &quot;list&quot; of operations to generate,
like this:

void sparc_sethi (int reg, int value)
{
	instructions [pc].type = sethi;
	instructions [pc].reg = reg;
	instructions [pc].value = value;
	instructions [pc].is_jmp = false;
	pc++;
}

void sparc_jmpl (int target)
{
	instructions [pc].type = jump;
	instructions [pc].value = target;
	pc++;
}

Then a second phase walks through the list of instructions to generate,
and since it &quot;knows&quot; what registers are used in each instruction, it can
schedule and move things around (where &quot;is_jmp&quot; is used as a re-order
barrier). 

Now, this is just a general overview of the idea;  Seasoned hackers are
probably replying point-by-point to this email pointing out that all the
information we are encoding can be retrieved from the instruction
stream.  And they are right, in the SPARC case, it is so simple to
decode everything we generate, that all we need to do is generate the
code in the first pass (and possibly track in an out-of-band structure a
`do-not-shuffle-things-around-here' barrier) and then do a scheduling
pass that shuffles things around so you can kill that `nop' after a
jump, or you can put another instruction after the sethi and the or.

Miguel.


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="005613.html">[Mono-list] Re: mono/mint on powerpc
</A></li>
	<LI> Next message: <A HREF="005614.html">[Mono-list] Thinking in C#
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5617">[ date ]</a>
              <a href="thread.html#5617">[ thread ]</a>
              <a href="subject.html#5617">[ subject ]</a>
              <a href="author.html#5617">[ author ]</a>
         </LI>
       </UL>
</body></html>
