<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> FW: [Mono-list] Buffering for StreamWriter
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="005757.html">
   <LINK REL="Next"  HREF="005758.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>FW: [Mono-list] Buffering for StreamWriter
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="FW: [Mono-list] Buffering for StreamWriter">miguel@ximian.com
       </A><BR>
    <I>18 May 2002 00:49:23 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="005757.html">FW: [Mono-list] Buffering for StreamWriter
</A></li>
        <LI> Next message: <A HREF="005758.html">FW: [Mono-list] Buffering for StreamWriter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5782">[ date ]</a>
              <a href="thread.html#5782">[ thread ]</a>
              <a href="subject.html#5782">[ subject ]</a>
              <a href="author.html#5782">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> In the future it's been said that the C# compiler itself will detect a
</I>&gt;<i> foreach on an array and instead emit a for loop in IL so that users don't
</I>&gt;<i> need to know about this little JIT optimization trick.
</I>
Actually, that has been in .NET ever since I recall (you can check the
code generated by foreach for single-dimension arrays and
multiple-dimension arrays as well as IEnumerables).  The Mono C#
compiler implements all the semantics of foreach.

Indeed, when foreach can be used, it will always generate code which is
as good or better than the equivalent for code.

&gt;<i> The JIT will do away with bounds checking which will obviously result in a
</I>&gt;<i> signifigant performance increase. Gunnerson claims 5x faster than foreach in
</I>&gt;<i> his example[1]. It's all about the explicit use of .Length in the
</I>&gt;<i> conditional of the for statement.
</I>
Yeah, bound checking elimination is a common compiler optimization.  The
Intel ORP Java JIT engine is a great source of ideas and inspiration for
anyone interested in the topic of JITs.

There is no extra metadata generated for foreach loops, so JITers have
to discover by themselves this invariant from the IL representation.

Btw, the same trick for strings is implemented by the Mono C# compiler,
look in mcs/mcs/statement.cs and scan for 'class Foreach' to see the
implementation: foreach turns out to be six or seven different beasts
depending on its arguments.

Miguel.


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="005757.html">FW: [Mono-list] Buffering for StreamWriter
</A></li>
	<LI> Next message: <A HREF="005758.html">FW: [Mono-list] Buffering for StreamWriter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5782">[ date ]</a>
              <a href="thread.html#5782">[ thread ]</a>
              <a href="subject.html#5782">[ subject ]</a>
              <a href="author.html#5782">[ author ]</a>
         </LI>
       </UL>
</body></html>
