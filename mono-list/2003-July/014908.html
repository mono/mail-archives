<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] need some help with PInvoke..
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="014907.html">
   <LINK REL="Next"  HREF="014910.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] need some help with PInvoke..
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] need some help with PInvoke..">jonpryor@vt.edu
       </A><BR>
    <I>10 Jul 2003 14:13:33 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="014907.html">[Mono-list] need some help with PInvoke..
</A></li>
        <LI> Next message: <A HREF="014910.html">[Mono-list] IntPtr safety (was: need some help with PInvoke..)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14908">[ date ]</a>
              <a href="thread.html#14908">[ thread ]</a>
              <a href="subject.html#14908">[ subject ]</a>
              <a href="author.html#14908">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Comments inline...

On Thu, 2003-07-10 at 13:13, David Jeske wrote:
&gt;<i> Thanks for the help Jonathan, it's just what I needed!
</I>&gt;<i> 
</I>&gt;<i> On Thu, Jul 10, 2003 at 10:58:16AM -0400, Jonathan Pryor wrote:
</I>&gt;<i> &gt; First of all, IntPtrs, shouldn't be exposed to client code, if at all
</I>&gt;<i> &gt; possible.  Granted, this isn't always possible (S.W.F exposes them
</I>&gt;<i> &gt; everywhere so you can manually call Win32 functions, and the Gtk#
</I>&gt;<i> &gt; wrapper also exposes them), but ideally you could provide a complete
</I>&gt;<i> &gt; wrapper around a type, and not need to expose an IntPtr.
</I>&gt;<i> 
</I>&gt;<i> We can all see that the reality is that they need to be exposed in
</I>&gt;<i> many places. 
</I>&gt;<i> 
</I>&gt;<i> IMHO, DllImport should always be &quot;unsafe&quot;, and HWND handles should be
</I>&gt;<i> unsafe struct pointers. That way any code that wanted to load some new
</I>&gt;<i> function and call it directly would have had to be marked unsafe to
</I>&gt;<i> use both the struct pointer and DllImport. That seems to mirror the
</I>&gt;<i> real world since that code will in fact be pretty unsafe.
</I>
I think the real problem is that &quot;unsafe&quot; is an overloaded term.  It can
refer to the use of the &quot;unsafe&quot; C# keyword, and it can be used as
&quot;anything that isn't safe&quot;, which, as you note, doesn't require the
&quot;unsafe&quot; keyword.

&gt;<i> I'm not sure what benefit we get by letting &quot;safe&quot; code mess around
</I>&gt;<i> with IntPtr, or call DllImported functions with &quot;allegedly correct&quot;
</I>&gt;<i> marshaling options.
</I>&gt;<i> 
</I>&gt;<i> It seems like currently the unsafe definition means &quot;may violate the
</I>&gt;<i> type system&quot;, which makes it pretty odd that IntPtrs can be touched by
</I>&gt;<i> &quot;safe&quot; code. If I had my way (fat chance), I would change that
</I>&gt;<i> definition to &quot;safe code should never cause a segfault&quot;. Anywhere that
</I>&gt;<i> DllImport is being used can easily cause a segfault, and anywhere
</I>&gt;<i> IntPtrs are passed to the wrong place can also cause a segfault
</I>&gt;<i> (although it will occur elsewhere), thus they are pretty &quot;unsafe&quot; in
</I>&gt;<i> my book. :)
</I>&gt;<i> 
</I>&gt;<i> However, we're not redesigning .NET here, so none of that matters too
</I>&gt;<i> much. Back to the regularly scheduled programming...
</I>
Well, to speak on .NET's behalf, .NET has a highly flexible security
system.  You can't invoke DllImported functions unless your app has the
appropriate security rights -- generally, that the app is running on the
local machine.  If you're running it from a network share, or from a web
site (similar to Java Applets), then your app will get a
SecurityException.

You can get lots of security exceptions for various things, actually. 
Opening files can generate a security exception, for example.

So, &quot;unsafe&quot; can mean (a) C# keyword; (b) violates .NET type system
(similar to (a)); (c) may be insecure (reading files from a web client);
(d) capable of causing a segfault.  There are likely other meanings
people can dream up as well.  Note that (d) doesn't imply (b), as far as
.NET is concerned.  The runtime could itself have a bug that generates a
segfault, but this doesn't violate the type system.

IntPtr doesn't require a violation of the type system, as you can't get
the address of a .NET object (unless you &quot;pin&quot; it, which would require
the appropriate Security rights), and is thus principally useful for
interacting with unmanaged code, which exists outside of the .NET type
system.

Surely, this is pure semantics, but I can see the designers perspective.

&gt;<i> &gt; Alternatively, creating a new struct that just has an IntPtr member
</I>&gt;<i> &gt; should be an equivalent, which would allow some type safety.  I'm
</I>&gt;<i> &gt; surprised I don't see this more often.
</I>&gt;<i> 
</I>&gt;<i> That's what I tried to do initially in my code, but since all the
</I>&gt;<i> marshal examples I had used classes, I was making the mistake of using
</I>&gt;<i> classes also. My take away is this:
</I>&gt;<i> 
</I>&gt;<i>  - If I want to copy the data into managed memory by marshaling, I use
</I>&gt;<i>    a class.
</I>
Structures can also be used, as passing a structure by value results in
a copy, which must be marshaled.

&gt;<i>  - If I want to reference the data in-place in unmanaged memory, I use
</I>&gt;<i>    an unsafe struct and a struct pointer.
</I>&gt;<i> 
</I>&gt;<i>  - Since an IntPtr is basically a void*, I don't see why I would ever
</I>&gt;<i>    use it, unless the external call actually takes a void*.
</I>
You would use it if you need to expose the member to languages other
than C#/C++.  For example, Visual Basic has no syntax for &quot;unsafe&quot; code,
and thus you couldn't use Visual Basic to perform your 2nd option.  If
you want your code to be usable by other languages, you'll need to
provide an appropriate wrapper.

Now, whether IntPtr can be considered an appropriate wrapper or not is
outside the bounds of this discussion. :-)  The answer likely depends
upon expected &quot;real-world&quot; usage.  Lots of S.W.F. programs are in VB, so
IntPtr is useful for that, as an example.

&gt;<i> &gt; The `char' type is an unsigned 16-bit type.  Your other functions
</I>&gt;<i> &gt; specify that string marshaling should be done as LPStrs (an 8 bit
</I>&gt;<i> &gt; type).  Which means there's a mismatch between your structure and method
</I>&gt;<i> &gt; signatures.
</I>&gt;<i> 
</I>&gt;<i> Actually, I used:
</I>&gt;<i> 
</I>&gt;<i>   Marshal.PtrToStringAnsi((IntPtr)p-&gt;name);
</I>&gt;<i> 
</I>&gt;<i> Which did exactly the right thing even though you are correct about my
</I>&gt;<i> mis-use of char *. I'll change it to &quot;byte*&quot;. 
</I>&gt;<i> 
</I>&gt;<i> &gt; You can convert it into a System.String by using the
</I>&gt;<i> &gt; System.String.String(sbyte*) constructor
</I>&gt;<i> 
</I>&gt;<i> Oohh! That's exactly what I was looking for. My strings are actually
</I>&gt;<i> in UTF, so I can do:
</I>&gt;<i> 
</I>&gt;<i>   string name = new String.String(p-&gt;name,0,strlen(p-&gt;name),UTF8Encoding);
</I>&gt;<i> 
</I>&gt;<i> I was worried that I was going to have to marshal the byte* into a
</I>&gt;<i> managed byte[], use convert to go from UTF8 to UCS2 in a byte[], and
</I>&gt;<i> then convert to a String. Too many copies. Using String.String() is
</I>&gt;<i> much better, thanks! (although the underlying implemenation might
</I>&gt;<i> still do the copies, it theoretically can be optimized someday)
</I>&gt;<i> 
</I>&gt;<i> &gt; Going from System.String to a sbyte* would likely require that you
</I>&gt;<i> &gt; P/Invoke to malloc/free (or whatever memory management functions your C
</I>&gt;<i> &gt; code uses), allocate unmanaged memory, and do the copy yourself (or use
</I>&gt;<i> &gt; System.Runtime.InteropServices.Marshal.Copy(byte[], int, IntPtr, int)). 
</I>&gt;<i> &gt; You'll have to convert the System.String to a byte[] first, though,
</I>&gt;<i> &gt; which will likely require using the System.Text.Encoding class (making
</I>&gt;<i> &gt; sure that you use the same encoding as your C code does).
</I>&gt;<i> 
</I>&gt;<i> It looks like I can write a Custom Marshaler which handles UTF8:
</I>&gt;<i> 
</I>&gt;<i>  <A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemruntimeinteropservicesicustommarshalerclasstopic.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemruntimeinteropservicesicustommarshalerclasstopic.asp</A>
</I>&gt;<i> 
</I>&gt;<i> However, based on what I can find in Convert, it looks like I'll have
</I>&gt;<i> to do the copying I talked about above (in reverse). My strings are
</I>&gt;<i> pretty small, so this shouldn't be too big a deal. However, I'm going
</I>&gt;<i> to be pushing strings out alot more often than I'm pulling strings
</I>&gt;<i> back in, so this is unfortunate.
</I>&gt;<i> 
</I>&gt;<i> If anyone knows of a way to marshal a .NET string into a UTF8 encoded
</I>&gt;<i> sbyte* in a single copy, speak up. :)
</I>
Haven't tried compiling, but this might work:

	UTF8Encoding enc = new UTF8Encoding (false, true);
	string input = GetSomeString ();
	byte[] marshalled = enc.GetBytes (input);
	IntPtr dest = malloc (marshalled.Length);
	Marshal.Copy (marshalled, 0, dest, marshalled.Length);

Not ideal, by any means, primarily because GetBytes() calls
String.ToCharArray(), which allocates a copy, and itself allocates the
byte[] array, and you have to call malloc and copy again, so you wind up
having 4 different copies of the string in memory (original
System.String, char[] array from GetBytes(), byte[] array, and unmanaged
copy).  Yech.

Even worse, it looks like this is the best that a Custom Marshaller
could do, assuming a C# custom marshaller.

In theory, the class library could optimize this so that the char[] copy
can be removed (probably through the introduction of some internal
calls), but I don't see any portable way of removing the other extra
copies.

Well, I suppose Marshal.StringToCoTaskMemAnsi() would work, except (1)
it's unimplemented in Mono, and (2) it assumes a Unicode-&gt;Ansi
conversion, not Unicode-&gt;UTF-8 conversion. 
Marshal.StringToCoTaskMemUni() would output UTF-16 characters, so this
isn't appropriate for you either.

 - Jon



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="014907.html">[Mono-list] need some help with PInvoke..
</A></li>
	<LI> Next message: <A HREF="014910.html">[Mono-list] IntPtr safety (was: need some help with PInvoke..)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14908">[ date ]</a>
              <a href="thread.html#14908">[ thread ]</a>
              <a href="subject.html#14908">[ subject ]</a>
              <a href="author.html#14908">[ author ]</a>
         </LI>
       </UL>
</body></html>
