<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] need some help with PInvoke..
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:jonpryor%40vt.edu">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="014900.html">
   <LINK REL="Next"  HREF="014907.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] need some help with PInvoke..
   </H1>
    <B>Jonathan Pryor
    </B> 
    <A HREF="mailto:jonpryor%40vt.edu"
       TITLE="[Mono-list] need some help with PInvoke..">jonpryor@vt.edu
       </A><BR>
    <I>10 Jul 2003 10:58:16 -0400</I>
    <P><UL>
        <LI> Previous message: <A HREF="014900.html">[Mono-list] need some help with PInvoke..
</A></li>
        <LI> Next message: <A HREF="014907.html">[Mono-list] need some help with PInvoke..
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14905">[ date ]</a>
              <a href="thread.html#14905">[ thread ]</a>
              <a href="subject.html#14905">[ subject ]</a>
              <a href="author.html#14905">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>You've already answered your GC questions in a later email.  There are
just two things I'd like to clarify.

First of all, IntPtrs, shouldn't be exposed to client code, if at all
possible.  Granted, this isn't always possible (S.W.F exposes them
everywhere so you can manually call Win32 functions, and the Gtk#
wrapper also exposes them), but ideally you could provide a complete
wrapper around a type, and not need to expose an IntPtr.

Alternatively, creating a new struct that just has an IntPtr member
should be an equivalent, which would allow some type safety.  I'm
surprised I don't see this more often.

The second thing is in your sample code, in particular:

	[StructLayout(LayoutKind.Sequential)]
	public unsafe struct HDF {
	  public int link;
	  public int alloc_value;
	  public char *name;
	  public int name_len;
	  public char *value;
	  // ...
	};

The `char' type is an unsigned 16-bit type.  Your other functions
specify that string marshaling should be done as LPStrs (an 8 bit
type).  Which means there's a mismatch between your structure and method
signatures.

The fix is to use &quot;sbyte*&quot; or &quot;byte*&quot; (depending on whether your
compiler uses signed or unsigned characters by default) instead of
&quot;char*&quot; in your structures.  You can convert it into a System.String by
using the System.String.String(sbyte*) constructor, or cast the byte* to
an IntPtr and pass the pointer to
System.Runtime.InteropServices.Marshal.PtrToStringAnsi(IntPtr).

Going from System.String to a sbyte* would likely require that you
P/Invoke to malloc/free (or whatever memory management functions your C
code uses), allocate unmanaged memory, and do the copy yourself (or use
System.Runtime.InteropServices.Marshal.Copy(byte[], int, IntPtr, int)). 
You'll have to convert the System.String to a byte[] first, though,
which will likely require using the System.Text.Encoding class (making
sure that you use the same encoding as your C code does).

 - Jon

On Thu, 2003-07-10 at 04:22, David Jeske wrote:
&gt;<i> On Wed, Jul 09, 2003 at 02:15:09PM -0400, Jonathan Pryor wrote:
</I>&gt;<i> &gt; The first way is similar to what's done in Gtk# -- use System.IntPtr
</I>&gt;<i> &gt; instead of &quot;void*&quot; and use the IntPtr exclusively as a pointer into
</I>&gt;<i> &gt; managed memory:
</I>&gt;<i> 
</I>&gt;<i> For opaque stuff, I like the IntPtr concept. However, I want specific
</I>&gt;<i> types of IntPtrs. I have a bunch of different opaque types and turning
</I>&gt;<i> everything into an IntPtr is too dangerous.
</I>&gt;<i> 
</I>&gt;<i> You'd think they would have wanted to have a more specific type than
</I>&gt;<i> IntPtr on all those HWND elements. I can easily crash the world with
</I>&gt;<i> supposedly &quot;safe&quot; code just by handing an IntPtr of the wrong type
</I>&gt;<i> somewhere.
</I>&gt;<i> 
</I>&gt;<i> However, unless I'm totally misunderstanding something, it seems like
</I>&gt;<i> I can do what I want with unsafe code. 
</I>&gt;<i> 
</I>&gt;<i> &gt; However, what you posted doesn't exactly match the above.  You have a
</I>&gt;<i> &gt; &quot;mostly opaque&quot; data structure (given that your C code directly
</I>&gt;<i> &gt; references the `desc' member of the NOERR class).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; There's a problem with this.  The .NET/mono runtime systems make two
</I>&gt;<i> &gt; assumptions: structs are located on the stack, and classes are allocated
</I>&gt;<i> &gt; in garbage-collected, .NET-controlled, memory.  Non-stack, non-garbage
</I>&gt;<i> &gt; collected memory doesn't enter the picture AT ALL.
</I>&gt;<i> 
</I>&gt;<i> That's fine. What I want to do shouldn't conflict with this
</I>&gt;<i> concept. For non-opaque types (C-structs), I just want .NET to keep a
</I>&gt;<i> pointer in managed memory, but I want it to point to unmanaged data
</I>&gt;<i> (which it can clearly already handle). Then want the ability to use a
</I>&gt;<i> C-style struct definition to get at elements in the unmanaged struct
</I>&gt;<i> memory. I'm fine if I have to do this inside unsafe code blocks.
</I>&gt;<i> 
</I>&gt;<i> I used unsafe structs and it seems to do exactly what I
</I>&gt;<i> want. Accessing structure members in the unmanaged memory works
</I>&gt;<i> correctly. There is no object machinery around structs, so the offsets
</I>&gt;<i> match the unmanaged data just fine. The only question is, does the GC
</I>&gt;<i> ignore a struct pointer or an unsafe struct pointer? 
</I>&gt;<i> 
</I>&gt;<i> For example, given this code:
</I>&gt;<i> 
</I>&gt;<i>   unsafe struct DATA {};
</I>&gt;<i> 
</I>&gt;<i>   unsafe class Foo {
</I>&gt;<i>     unsafe DATA *bar;
</I>&gt;<i>   }
</I>&gt;<i> 
</I>&gt;<i> Will the GC have any problems if bar points to unmanaged memory?
</I>&gt;<i> 
</I>&gt;<i> I can see why it would want to take a look at the location bar is
</I>&gt;<i> pointing to, because there are cases where you are allowed to have
</I>&gt;<i> pointers which point to the interior of managed objects. However, it
</I>&gt;<i> can't go walking the bar pointer, because there is no object machinery
</I>&gt;<i> on the other end. Because of this, I can't see why it would crash the
</I>&gt;<i> GC if this pointed to unmanaged memory.
</I>&gt;<i> 
</I>&gt;<i> Can anyone more in the know confirm what happens here?
</I>&gt;<i> 
</I>&gt;<i> I've attached my most recent test code which uses unsafe structs and
</I>&gt;<i> seems to do the right thing. (i.e. it can correctly access internal
</I>&gt;<i> structure members of the data sitting in unmanaged memory)
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="014900.html">[Mono-list] need some help with PInvoke..
</A></li>
	<LI> Next message: <A HREF="014907.html">[Mono-list] need some help with PInvoke..
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14905">[ date ]</a>
              <a href="thread.html#14905">[ thread ]</a>
              <a href="subject.html#14905">[ subject ]</a>
              <a href="author.html#14905">[ author ]</a>
         </LI>
       </UL>
</body></html>
