<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Scripting the Linux OS with Mono
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Scripting%20the%20Linux%20OS%20with%20Mono&In-Reply-To=a6d397e30511101647q80028edr2a6c036353fe4d77%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029434.html">
   <LINK REL="Next"  HREF="029444.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Scripting the Linux OS with Mono</H1>
    <B>Elliott Draper</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Scripting%20the%20Linux%20OS%20with%20Mono&In-Reply-To=a6d397e30511101647q80028edr2a6c036353fe4d77%40mail.gmail.com"
       TITLE="[Mono-list] Scripting the Linux OS with Mono">el at eldiablo.co.uk
       </A><BR>
    <I>Fri Nov 11 14:34:51 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="029434.html">[Mono-list] Scripting the Linux OS with Mono
</A></li>
        <LI>Next message: <A HREF="029444.html">[Mono-list] Scripting the Linux OS with Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29443">[ date ]</a>
              <a href="thread.html#29443">[ thread ]</a>
              <a href="subject.html#29443">[ subject ]</a>
              <a href="author.html#29443">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi Abe,

Abe Gillespie wrote:

&gt;<i>*snip
</I>&gt;<i>mono script_host.exe MyScript.cs myarg1 myarg2
</I>&gt;<i>
</I>&gt;<i>*snip
</I>&gt;<i>Has anyone out there done something or started a project like this?
</I>&gt;<i>  
</I>&gt;<i>
</I>Give the attached source code a try :-) I'm not claiming it's perfect, 
but it's something I knocked up while I was bored this afternoon, and 
you may be able to use it or tweak it to what you need. It uses the 
features of CodeDom, available both in .Net and Mono, to compile the 
source file to an in-memory assembly, where the code can then be 
executed. The file &quot;MonoScript.cs&quot; can be compiled on its own to provide 
the actual script execution tool, and also attached is a sample &quot;script&quot; 
file (&quot;Test.cs&quot;) that you can use to give it a bash. Simply compile the 
MonoScript tool:

mcs MonoScript.cs

And then it's as easy as running:

mono MonoScript.exe --sourceFile:Test.cs

If for example your source file has a reference to System.Data then you 
can simply run:

mono MonoScript.exe --sourceFile:Test.cs --references:System.Data.dll

For the full usage of the program, run:

mono MonoScript.exe --displayUsage:true

Any arguments you specify that MonoScript doesn't recognize will be 
forwarded onto the &quot;script&quot; application, you can see this by appending 
as many arguments as you want to the test script:

mono MonoScript.exe --sourceFile:Test.cs test1 test2 test3

Have a play, and give me a shout if you run into any bugs or problems 
with it and I'll do my best to fix them, failing that, jump right in and 
tweak the code yourself ;-)

If anyone else finds the code useful, let me know and I'll get the 
entire thing (project files, a build file maybe, a bigger testsuite 
perhaps?) up on my website as a package. Likewise if anyone has any 
comments, let me have 'em!

&gt;<i>-Abe
</I>&gt;<i>  
</I>&gt;<i>
</I>Cheers,
-= El =-

&gt;<i>On 11/10/05, Korn&#233;l P&#225;l &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">kornelpal at hotmail.com</A>&gt; wrote:
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>Hi,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>You have to compile C# code using mcs that will result in a .exe assembly
</I>&gt;&gt;<i>that can be executed using mono:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>$mcs some.cs
</I>&gt;&gt;<i>$mono some.exe
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>If you prefer you can write a shell script that will do this as a single
</I>&gt;&gt;<i>step.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Korn&#233;l
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>----- Original Message -----
</I>&gt;&gt;<i>From: &quot;Abe Gillespie&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">abe.gillespie at gmail.com</A>&gt;
</I>&gt;&gt;<i>To: &quot;MonoList&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">mono-list at lists.ximian.com</A>&gt;
</I>&gt;&gt;<i>Sent: Friday, November 11, 2005 1:02 AM
</I>&gt;&gt;<i>Subject: [Mono-list] Scripting the Linux OS with Mono
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Hey all,
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>I was wondering if there's any easy way to run C# scripts in Mono.
</I>&gt;&gt;<i>I'm fairly new to Linux (just at about a year) and I'd like to avoid
</I>&gt;&gt;<i>learning yet another language (Perl, sh, etc.).  Has anyone written a
</I>&gt;&gt;<i>.Net program that takes a file as input and runs that code?  Perhaps
</I>&gt;&gt;<i>Mono can do this natively?  How cool would it be to have startup
</I>&gt;&gt;<i>scripts written in C#?!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Thanks for the help as always.
</I>&gt;&gt;<i>-Abe
</I>&gt;&gt;<i>_______________________________________________
</I>&gt;&gt;<i>Mono-list maillist  -  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">Mono-list at lists.ximian.com</A>
</I>&gt;&gt;<i><A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>_______________________________________________
</I>&gt;<i>Mono-list maillist  -  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">Mono-list at lists.ximian.com</A>
</I>&gt;<i><A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i>  
</I>&gt;<i>
</I>
-------------- next part --------------
using System;

public class MonoScriptTest
{
	//This simply displays the amount of arguments passed into it
	public static void Main(string[] args)
	{
		Console.WriteLine(string.Format(&quot;MonoScript: test script, {0} arguments&quot;,args.Length.ToString()));
	}
}
-------------- next part --------------
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Specialized;
using System.Reflection;

namespace MonoScript
{
    /// &lt;summary&gt;
    /// This allows the execution of a .cs file as if it were a program, compiling it on the fly then executing it
    /// 
    /// Example syntax:
    /// 
    /// MonoScript /s:myscript.cs /r:System.Drawing.dll                 This would execute the code within the
    /// file myscript.cs, and reference System.Drawing.dll when compiling it
    /// 
    /// MonoScript /s:myscript.cs /r:System.Data.dll /n:true /v:true    This would compile the code within the
    /// file myscript.cs, reference System.Data.dll when doing it, stop the MonoScript logo from displaying
    /// when run, and also ensure that ONLY compilation takes place, not execution, for validation purposes
    /// &lt;/summary&gt;
    class MonoScript
    {
        /// &lt;summary&gt;
        /// These are our options for the script to execute
        /// &lt;/summary&gt;
        static MonoScriptOptions Options;

        /// &lt;summary&gt;
        /// Main entry point
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;
        static void Main(string[] args)
        {
            //Create our options from the command line args
            Options = new MonoScriptOptions(args);

            //Only show the logo if we haven't been told not to
            if(!Options.NoLogo)
                Logo();

            //If the user has requested the program usage, then show it here
            if (Options.DisplayUsage)
            {
                Usage();
                return;
            }

            //This will hold our in-memory compiled assembly
            Assembly assembly = null;

            try
            {
                //Compile our script to an assembly
                assembly = CompileFile();

                //Ensure we have an assembly
                if (assembly == null)
                    throw new Exception(&quot;No assembly generated!&quot;);
            }
            catch (Exception ex)
            {
                //Display any errors found while compiling
                Console.WriteLine(string.Format(
                    &quot;Exception caught while compiling script:{0}{1}{0}&quot;,
                    Environment.NewLine,
                    ex.ToString()));

                return;
            }

            //If we are only validating (compiling) the script, then exit here
            if (Options.ValidateOnly)
            {
                Console.WriteLine(&quot;Validation complete&quot;);
                return;
            }

            try
            {
                //Execute the script
                ExecuteAssembly(assembly);
            }
            catch (Exception ex)
            {
                //Catch any errors while executing it
                Console.WriteLine(string.Format(
                    &quot;Exception caught while executing script:{0}{1}{0}&quot;,
                    Environment.NewLine,
                    ex.ToString()));

                return;
            }
        }

        /// &lt;summary&gt;
        /// This outputs the program logo
        /// &lt;/summary&gt;
        static void Logo()
        {
            Console.WriteLine(&quot;MonoScript: (c) 2005, Elliott Draper &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">el at eldiablo.co.uk</A>&gt;&quot;);
        }

        /// &lt;summary&gt;
        /// This outputs the usage of the app
        /// &lt;/summary&gt;
        static void Usage()
        {
            Console.WriteLine(&quot;Usage: MonoScript --sourceFile:[VALUE] [ARGS] where [ARGS] can optionally be one of the following:&quot;);
            Console.WriteLine(&quot;--references:[VALUE], -r:[VALUE], /r:[VALUE]     :       any references needed to compile the script&quot;);
            Console.WriteLine(&quot;--noLogo:[VALUE], -n:[VALUE], /n:[VALUE]         :       stops from showing the MonoScript logo&quot;);
            Console.WriteLine(&quot;--displayUsage:[VALUE], -d:[VALUE], /d:[VALUE]   :       displays this usage info&quot;);
            Console.WriteLine(&quot;--validateOnly:[VALUE], -v:[VALUE], /v:[VALUE]   :       validates the script by compiling it, but doesn't execute it&quot;);
        }

        /// &lt;summary&gt;
        /// This compiles the specified file into an assembly, exceptioning on error
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        static Assembly CompileFile()
        {
            //Setup the parameters
            CompilerParameters parameters = new CompilerParameters();
            foreach (string reference in Options.References)
                parameters.ReferencedAssemblies.Add(reference);
	        parameters.GenerateInMemory = true;

            //Create the provider and compiler
            CodeDomProvider provider = new Microsoft.CSharp.CSharpCodeProvider();
            if (provider == null)
                throw new Exception(&quot;Cannot create C# code provider!&quot;);
            ICodeCompiler compiler = provider.CreateCompiler();
            if (compiler == null)
                throw new Exception(&quot;Cannot create C# compiler!&quot;);
            //Compile the file with the specified parameters
            CompilerResults results = compiler.CompileAssemblyFromFile(
                parameters,
                Options.SourceFile);
            //Grab and validate the results
            if (results == null)
                throw new Exception(&quot;Could not retrieve results from compilation!&quot;);
            if (results.Errors.HasErrors)
                throw new Exception(results.Errors[0].ErrorText);
            //Return the compiled assembly            
            return results.CompiledAssembly;
        }

        /// &lt;summary&gt;
        /// This executes the specified compiled assembly
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;assembly&quot;&gt;&lt;/param&gt;
        static void ExecuteAssembly(Assembly assembly)
        {
            //Invoke the entry point found for the assembly, with the specified arguments
            GetEntryPoint(assembly).GetMethod(&quot;Main&quot;).Invoke(null, new object[1] { Options.ScriptArgs });
        }

        /// &lt;summary&gt;
        /// This attempts to locate a type with a static &quot;Main&quot; method within the generated script assembly
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;assembly&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        static Type GetEntryPoint(Assembly assembly)
        {
            //Loop through all of the generated types
            foreach (Type type in assembly.GetTypes())
            {
                //If we find one that has a static Main method, lets return it
                if (type.GetMethod(&quot;Main&quot;) != null &amp;&amp; type.GetMethod(&quot;Main&quot;).IsStatic)
                    return type;
            }
            //If we get to here, we got no entry point :-(
            throw new Exception(&quot;Unable to find a class with a valid entry point within the script!&quot;);
        }
    }

    /// &lt;summary&gt;
    /// This contains options for calling MonoScript with
    /// &lt;/summary&gt;
    class MonoScriptOptions
    {
        #region Private Variables

        private string[] _references = new string[0];
        private string _sourceFile;
        private bool _noLogo = false;
        private bool _displayUsage = false;
        private bool _validateOnly = false;
        private StringCollection optionArgs = new StringCollection();

        #endregion

        #region Properties

        /// &lt;summary&gt;
        /// This specifies that no logo should be shown for the MonoScript app
        /// &lt;/summary&gt;
        public bool NoLogo
        {
            get
            {
                return _noLogo;
            }
        }

        /// &lt;summary&gt;
        /// This specifies that the MonoScript usage should be displayed
        /// &lt;/summary&gt;
        public bool DisplayUsage
        {
            get
            {
                return _displayUsage;
            }
        }

        /// &lt;summary&gt;
        /// This specifies that the source file shouldn't be executed as a script; just that it should be 
        /// compiled and validated to ensure it is a valid source file
        /// &lt;/summary&gt;
        public bool ValidateOnly
        {
            get
            {
                return _validateOnly;
            }
        }

        /// &lt;summary&gt;
        /// Any assembly references needed to compile the script
        /// &lt;/summary&gt;
        public string[] References
        {
            get
            {
                return _references;
            }
        }

        /// &lt;summary&gt;
        /// The source file acting as the script
        /// &lt;/summary&gt;
        public string SourceFile
        {
            get
            {
		if(_sourceFile==null)
			throw new Exception(&quot;No source file specified!&quot;);
                return _sourceFile;
            }
        }

        /// &lt;summary&gt;
        /// The arguments to call the script with
        /// &lt;/summary&gt;
        public string[] ScriptArgs
        {
            get
            {
                string[] args = new string[optionArgs.Count];
                for (int i = 0; i &lt; args.Length; i++)
                    args[i] = optionArgs[i];
                return args;
            }
        }

        #endregion

        #region Constructor

        /// &lt;summary&gt;
        /// Default constructor
        /// &lt;/summary&gt;
        public MonoScriptOptions(string[] args)
        {
            //Validate
            if(args==null||args.Length==0)
                throw new Exception(&quot;No arguments specified!&quot;);

            //Add in args
            optionArgs.AddRange(args);

            //Fill out options
            _sourceFile = GetArgument(&quot;sourceFile&quot;);

            string noLogo = GetArgument(&quot;noLogo&quot;);
            _noLogo = (noLogo != null &amp;&amp; noLogo.ToLower() == &quot;true&quot;) ? true : false;

            string displayUsage = GetArgument(&quot;displayUsage&quot;);
            _displayUsage = (displayUsage != null &amp;&amp; displayUsage.ToLower() == &quot;true&quot;) ? true : false;

            string validateOnly = GetArgument(&quot;validateOnly&quot;);
            _validateOnly = (validateOnly != null &amp;&amp; validateOnly.ToLower() == &quot;true&quot;) ? true : false;

            string references = GetArgument(&quot;references&quot;);
            if(references!=null)
                _references = references.Split(Convert.ToChar(&quot;,&quot;));
        }

        #endregion

        #region Methods

        /// &lt;summary&gt;
        /// This retrieves an argument value from the list of arguments
        /// If it finds a requested argument, it then removes it from the list of arguments
        /// 
        /// If you request the argument for the command &quot;references&quot;, any argument such as:
        /// --references:[VALUE]
        /// -r:[VALUE]
        /// /r:[VALUE]
        /// 
        /// will all result in the returning of &quot;[VALUE]&quot;
        /// If more than one is specified, they will be taken in the above order
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;requestedCmd&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private string GetArgument(string requestedCmd)
        {
            //These variables are used throughout
            string value = null;
            string arg = null;
            //Loop through all arguments
            for(int i=0;i&lt;optionArgs.Count;i++)
            {
                arg = optionArgs[i];
                //Prepare the first format of the requested command to search for
                string cmd = string.Format(&quot;--{0}:&quot;, requestedCmd);
                if (arg.IndexOf(cmd) != -1)
                {
                    //If it's found, then set the value, and break the loop
                    value = arg.Substring(
                        0 + cmd.Length,
                        arg.Length - cmd.Length);
                    break;
                }
                //Try the next format of the requested command
                cmd = string.Format(&quot;-{0}:&quot;, requestedCmd[0]);
                if (arg.IndexOf(cmd) != -1)
                {
                    //Again, if found, set the value and break out of the loop
                    value = arg.Substring(
                        0 + cmd.Length,
                        arg.Length - cmd.Length);
                    break;
                }
                //Finally try the last format of the requested command
                cmd = string.Format(&quot;/{0}:&quot;, requestedCmd[0]);
                if (arg.IndexOf(cmd) != -1)
                {
                    //Set value, break loop
                    value = arg.Substring(
                        0 + cmd.Length,
                        arg.Length - cmd.Length);
                    break;
                }
            }

            //If we have got here with a value set, then we found our argument value, so remove the argument,
            //and return our value
            if (value != null)
            {
                optionArgs.Remove(arg);
                return value;
            }

            //Otherwise, return null
            return null;
        }

        #endregion
    }
}
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029434.html">[Mono-list] Scripting the Linux OS with Mono
</A></li>
	<LI>Next message: <A HREF="029444.html">[Mono-list] Scripting the Linux OS with Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29443">[ date ]</a>
              <a href="thread.html#29443">[ thread ]</a>
              <a href="subject.html#29443">[ subject ]</a>
              <a href="author.html#29443">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
