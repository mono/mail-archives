<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Scripting the Linux OS with Mono
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Scripting%20the%20Linux%20OS%20with%20Mono&In-Reply-To=4374F25B.3000001%40eldiablo.co.uk">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="029444.html">
   <LINK REL="Next"  HREF="029435.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Scripting the Linux OS with Mono</H1>
    <B>Abe Gillespie</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Scripting%20the%20Linux%20OS%20with%20Mono&In-Reply-To=4374F25B.3000001%40eldiablo.co.uk"
       TITLE="[Mono-list] Scripting the Linux OS with Mono">abe.gillespie at gmail.com
       </A><BR>
    <I>Fri Nov 11 16:39:43 EST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="029444.html">[Mono-list] Scripting the Linux OS with Mono
</A></li>
        <LI>Next message: <A HREF="029435.html">[Mono-list] Scripting the Linux OS with Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29445">[ date ]</a>
              <a href="thread.html#29445">[ thread ]</a>
              <a href="subject.html#29445">[ subject ]</a>
              <a href="author.html#29445">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Dude, you totally rock!  I'll be giving this a try this weekend.

-Abe

On 11/11/05, Elliott Draper &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">el at eldiablo.co.uk</A>&gt; wrote:
&gt;<i> Hi Abe,
</I>&gt;<i>
</I>&gt;<i> Abe Gillespie wrote:
</I>&gt;<i>
</I>&gt;<i> &gt;*snip
</I>&gt;<i> &gt;mono script_host.exe MyScript.cs myarg1 myarg2
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;*snip
</I>&gt;<i> &gt;Has anyone out there done something or started a project like this?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> Give the attached source code a try :-) I'm not claiming it's perfect,
</I>&gt;<i> but it's something I knocked up while I was bored this afternoon, and
</I>&gt;<i> you may be able to use it or tweak it to what you need. It uses the
</I>&gt;<i> features of CodeDom, available both in .Net and Mono, to compile the
</I>&gt;<i> source file to an in-memory assembly, where the code can then be
</I>&gt;<i> executed. The file &quot;MonoScript.cs&quot; can be compiled on its own to provide
</I>&gt;<i> the actual script execution tool, and also attached is a sample &quot;script&quot;
</I>&gt;<i> file (&quot;Test.cs&quot;) that you can use to give it a bash. Simply compile the
</I>&gt;<i> MonoScript tool:
</I>&gt;<i>
</I>&gt;<i> mcs MonoScript.cs
</I>&gt;<i>
</I>&gt;<i> And then it's as easy as running:
</I>&gt;<i>
</I>&gt;<i> mono MonoScript.exe --sourceFile:Test.cs
</I>&gt;<i>
</I>&gt;<i> If for example your source file has a reference to System.Data then you
</I>&gt;<i> can simply run:
</I>&gt;<i>
</I>&gt;<i> mono MonoScript.exe --sourceFile:Test.cs --references:System.Data.dll
</I>&gt;<i>
</I>&gt;<i> For the full usage of the program, run:
</I>&gt;<i>
</I>&gt;<i> mono MonoScript.exe --displayUsage:true
</I>&gt;<i>
</I>&gt;<i> Any arguments you specify that MonoScript doesn't recognize will be
</I>&gt;<i> forwarded onto the &quot;script&quot; application, you can see this by appending
</I>&gt;<i> as many arguments as you want to the test script:
</I>&gt;<i>
</I>&gt;<i> mono MonoScript.exe --sourceFile:Test.cs test1 test2 test3
</I>&gt;<i>
</I>&gt;<i> Have a play, and give me a shout if you run into any bugs or problems
</I>&gt;<i> with it and I'll do my best to fix them, failing that, jump right in and
</I>&gt;<i> tweak the code yourself ;-)
</I>&gt;<i>
</I>&gt;<i> If anyone else finds the code useful, let me know and I'll get the
</I>&gt;<i> entire thing (project files, a build file maybe, a bigger testsuite
</I>&gt;<i> perhaps?) up on my website as a package. Likewise if anyone has any
</I>&gt;<i> comments, let me have 'em!
</I>&gt;<i>
</I>&gt;<i> &gt;-Abe
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> Cheers,
</I>&gt;<i> -= El =-
</I>&gt;<i>
</I>&gt;<i> &gt;On 11/10/05, Korn&#233;l P&#225;l &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">kornelpal at hotmail.com</A>&gt; wrote:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;&gt;Hi,
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;You have to compile C# code using mcs that will result in a .exe assembly
</I>&gt;<i> &gt;&gt;that can be executed using mono:
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;$mcs some.cs
</I>&gt;<i> &gt;&gt;$mono some.exe
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;If you prefer you can write a shell script that will do this as a single
</I>&gt;<i> &gt;&gt;step.
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;Korn&#233;l
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;----- Original Message -----
</I>&gt;<i> &gt;&gt;From: &quot;Abe Gillespie&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">abe.gillespie at gmail.com</A>&gt;
</I>&gt;<i> &gt;&gt;To: &quot;MonoList&quot; &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">mono-list at lists.ximian.com</A>&gt;
</I>&gt;<i> &gt;&gt;Sent: Friday, November 11, 2005 1:02 AM
</I>&gt;<i> &gt;&gt;Subject: [Mono-list] Scripting the Linux OS with Mono
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;Hey all,
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;I was wondering if there's any easy way to run C# scripts in Mono.
</I>&gt;<i> &gt;&gt;I'm fairly new to Linux (just at about a year) and I'd like to avoid
</I>&gt;<i> &gt;&gt;learning yet another language (Perl, sh, etc.).  Has anyone written a
</I>&gt;<i> &gt;&gt;.Net program that takes a file as input and runs that code?  Perhaps
</I>&gt;<i> &gt;&gt;Mono can do this natively?  How cool would it be to have startup
</I>&gt;<i> &gt;&gt;scripts written in C#?!
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;Thanks for the help as always.
</I>&gt;<i> &gt;&gt;-Abe
</I>&gt;<i> &gt;&gt;_______________________________________________
</I>&gt;<i> &gt;&gt;Mono-list maillist  -  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">Mono-list at lists.ximian.com</A>
</I>&gt;<i> &gt;&gt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;&gt;
</I>&gt;<i> &gt;_______________________________________________
</I>&gt;<i> &gt;Mono-list maillist  -  <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">Mono-list at lists.ximian.com</A>
</I>&gt;<i> &gt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> using System;
</I>&gt;<i>
</I>&gt;<i> public class MonoScriptTest
</I>&gt;<i> {
</I>&gt;<i>         //This simply displays the amount of arguments passed into it
</I>&gt;<i>         public static void Main(string[] args)
</I>&gt;<i>         {
</I>&gt;<i>                 Console.WriteLine(string.Format(&quot;MonoScript: test script, {0} arguments&quot;,args.Length.ToString()));
</I>&gt;<i>         }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> using System;
</I>&gt;<i> using System.CodeDom;
</I>&gt;<i> using System.CodeDom.Compiler;
</I>&gt;<i> using System.Collections.Specialized;
</I>&gt;<i> using System.Reflection;
</I>&gt;<i>
</I>&gt;<i> namespace MonoScript
</I>&gt;<i> {
</I>&gt;<i>     /// &lt;summary&gt;
</I>&gt;<i>     /// This allows the execution of a .cs file as if it were a program, compiling it on the fly then executing it
</I>&gt;<i>     ///
</I>&gt;<i>     /// Example syntax:
</I>&gt;<i>     ///
</I>&gt;<i>     /// MonoScript /s:myscript.cs /r:System.Drawing.dll                 This would execute the code within the
</I>&gt;<i>     /// file myscript.cs, and reference System.Drawing.dll when compiling it
</I>&gt;<i>     ///
</I>&gt;<i>     /// MonoScript /s:myscript.cs /r:System.Data.dll /n:true /v:true    This would compile the code within the
</I>&gt;<i>     /// file myscript.cs, reference System.Data.dll when doing it, stop the MonoScript logo from displaying
</I>&gt;<i>     /// when run, and also ensure that ONLY compilation takes place, not execution, for validation purposes
</I>&gt;<i>     /// &lt;/summary&gt;
</I>&gt;<i>     class MonoScript
</I>&gt;<i>     {
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// These are our options for the script to execute
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         static MonoScriptOptions Options;
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// Main entry point
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;
</I>&gt;<i>         static void Main(string[] args)
</I>&gt;<i>         {
</I>&gt;<i>             //Create our options from the command line args
</I>&gt;<i>             Options = new MonoScriptOptions(args);
</I>&gt;<i>
</I>&gt;<i>             //Only show the logo if we haven't been told not to
</I>&gt;<i>             if(!Options.NoLogo)
</I>&gt;<i>                 Logo();
</I>&gt;<i>
</I>&gt;<i>             //If the user has requested the program usage, then show it here
</I>&gt;<i>             if (Options.DisplayUsage)
</I>&gt;<i>             {
</I>&gt;<i>                 Usage();
</I>&gt;<i>                 return;
</I>&gt;<i>             }
</I>&gt;<i>
</I>&gt;<i>             //This will hold our in-memory compiled assembly
</I>&gt;<i>             Assembly assembly = null;
</I>&gt;<i>
</I>&gt;<i>             try
</I>&gt;<i>             {
</I>&gt;<i>                 //Compile our script to an assembly
</I>&gt;<i>                 assembly = CompileFile();
</I>&gt;<i>
</I>&gt;<i>                 //Ensure we have an assembly
</I>&gt;<i>                 if (assembly == null)
</I>&gt;<i>                     throw new Exception(&quot;No assembly generated!&quot;);
</I>&gt;<i>             }
</I>&gt;<i>             catch (Exception ex)
</I>&gt;<i>             {
</I>&gt;<i>                 //Display any errors found while compiling
</I>&gt;<i>                 Console.WriteLine(string.Format(
</I>&gt;<i>                     &quot;Exception caught while compiling script:{0}{1}{0}&quot;,
</I>&gt;<i>                     Environment.NewLine,
</I>&gt;<i>                     ex.ToString()));
</I>&gt;<i>
</I>&gt;<i>                 return;
</I>&gt;<i>             }
</I>&gt;<i>
</I>&gt;<i>             //If we are only validating (compiling) the script, then exit here
</I>&gt;<i>             if (Options.ValidateOnly)
</I>&gt;<i>             {
</I>&gt;<i>                 Console.WriteLine(&quot;Validation complete&quot;);
</I>&gt;<i>                 return;
</I>&gt;<i>             }
</I>&gt;<i>
</I>&gt;<i>             try
</I>&gt;<i>             {
</I>&gt;<i>                 //Execute the script
</I>&gt;<i>                 ExecuteAssembly(assembly);
</I>&gt;<i>             }
</I>&gt;<i>             catch (Exception ex)
</I>&gt;<i>             {
</I>&gt;<i>                 //Catch any errors while executing it
</I>&gt;<i>                 Console.WriteLine(string.Format(
</I>&gt;<i>                     &quot;Exception caught while executing script:{0}{1}{0}&quot;,
</I>&gt;<i>                     Environment.NewLine,
</I>&gt;<i>                     ex.ToString()));
</I>&gt;<i>
</I>&gt;<i>                 return;
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// This outputs the program logo
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         static void Logo()
</I>&gt;<i>         {
</I>&gt;<i>             Console.WriteLine(&quot;MonoScript: (c) 2005, Elliott Draper &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">el at eldiablo.co.uk</A>&gt;&quot;);
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// This outputs the usage of the app
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         static void Usage()
</I>&gt;<i>         {
</I>&gt;<i>             Console.WriteLine(&quot;Usage: MonoScript --sourceFile:[VALUE] [ARGS] where [ARGS] can optionally be one of the following:&quot;);
</I>&gt;<i>             Console.WriteLine(&quot;--references:[VALUE], -r:[VALUE], /r:[VALUE]     :       any references needed to compile the script&quot;);
</I>&gt;<i>             Console.WriteLine(&quot;--noLogo:[VALUE], -n:[VALUE], /n:[VALUE]         :       stops from showing the MonoScript logo&quot;);
</I>&gt;<i>             Console.WriteLine(&quot;--displayUsage:[VALUE], -d:[VALUE], /d:[VALUE]   :       displays this usage info&quot;);
</I>&gt;<i>             Console.WriteLine(&quot;--validateOnly:[VALUE], -v:[VALUE], /v:[VALUE]   :       validates the script by compiling it, but doesn't execute it&quot;);
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// This compiles the specified file into an assembly, exceptioning on error
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         /// &lt;returns&gt;&lt;/returns&gt;
</I>&gt;<i>         static Assembly CompileFile()
</I>&gt;<i>         {
</I>&gt;<i>             //Setup the parameters
</I>&gt;<i>             CompilerParameters parameters = new CompilerParameters();
</I>&gt;<i>             foreach (string reference in Options.References)
</I>&gt;<i>                 parameters.ReferencedAssemblies.Add(reference);
</I>&gt;<i>                 parameters.GenerateInMemory = true;
</I>&gt;<i>
</I>&gt;<i>             //Create the provider and compiler
</I>&gt;<i>             CodeDomProvider provider = new Microsoft.CSharp.CSharpCodeProvider();
</I>&gt;<i>             if (provider == null)
</I>&gt;<i>                 throw new Exception(&quot;Cannot create C# code provider!&quot;);
</I>&gt;<i>             ICodeCompiler compiler = provider.CreateCompiler();
</I>&gt;<i>             if (compiler == null)
</I>&gt;<i>                 throw new Exception(&quot;Cannot create C# compiler!&quot;);
</I>&gt;<i>             //Compile the file with the specified parameters
</I>&gt;<i>             CompilerResults results = compiler.CompileAssemblyFromFile(
</I>&gt;<i>                 parameters,
</I>&gt;<i>                 Options.SourceFile);
</I>&gt;<i>             //Grab and validate the results
</I>&gt;<i>             if (results == null)
</I>&gt;<i>                 throw new Exception(&quot;Could not retrieve results from compilation!&quot;);
</I>&gt;<i>             if (results.Errors.HasErrors)
</I>&gt;<i>                 throw new Exception(results.Errors[0].ErrorText);
</I>&gt;<i>             //Return the compiled assembly
</I>&gt;<i>             return results.CompiledAssembly;
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// This executes the specified compiled assembly
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         /// &lt;param name=&quot;assembly&quot;&gt;&lt;/param&gt;
</I>&gt;<i>         static void ExecuteAssembly(Assembly assembly)
</I>&gt;<i>         {
</I>&gt;<i>             //Invoke the entry point found for the assembly, with the specified arguments
</I>&gt;<i>             GetEntryPoint(assembly).GetMethod(&quot;Main&quot;).Invoke(null, new object[1] { Options.ScriptArgs });
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// This attempts to locate a type with a static &quot;Main&quot; method within the generated script assembly
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         /// &lt;param name=&quot;assembly&quot;&gt;&lt;/param&gt;
</I>&gt;<i>         /// &lt;returns&gt;&lt;/returns&gt;
</I>&gt;<i>         static Type GetEntryPoint(Assembly assembly)
</I>&gt;<i>         {
</I>&gt;<i>             //Loop through all of the generated types
</I>&gt;<i>             foreach (Type type in assembly.GetTypes())
</I>&gt;<i>             {
</I>&gt;<i>                 //If we find one that has a static Main method, lets return it
</I>&gt;<i>                 if (type.GetMethod(&quot;Main&quot;) != null &amp;&amp; type.GetMethod(&quot;Main&quot;).IsStatic)
</I>&gt;<i>                     return type;
</I>&gt;<i>             }
</I>&gt;<i>             //If we get to here, we got no entry point :-(
</I>&gt;<i>             throw new Exception(&quot;Unable to find a class with a valid entry point within the script!&quot;);
</I>&gt;<i>         }
</I>&gt;<i>     }
</I>&gt;<i>
</I>&gt;<i>     /// &lt;summary&gt;
</I>&gt;<i>     /// This contains options for calling MonoScript with
</I>&gt;<i>     /// &lt;/summary&gt;
</I>&gt;<i>     class MonoScriptOptions
</I>&gt;<i>     {
</I>&gt;<i>         #region Private Variables
</I>&gt;<i>
</I>&gt;<i>         private string[] _references = new string[0];
</I>&gt;<i>         private string _sourceFile;
</I>&gt;<i>         private bool _noLogo = false;
</I>&gt;<i>         private bool _displayUsage = false;
</I>&gt;<i>         private bool _validateOnly = false;
</I>&gt;<i>         private StringCollection optionArgs = new StringCollection();
</I>&gt;<i>
</I>&gt;<i>         #endregion
</I>&gt;<i>
</I>&gt;<i>         #region Properties
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// This specifies that no logo should be shown for the MonoScript app
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         public bool NoLogo
</I>&gt;<i>         {
</I>&gt;<i>             get
</I>&gt;<i>             {
</I>&gt;<i>                 return _noLogo;
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// This specifies that the MonoScript usage should be displayed
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         public bool DisplayUsage
</I>&gt;<i>         {
</I>&gt;<i>             get
</I>&gt;<i>             {
</I>&gt;<i>                 return _displayUsage;
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// This specifies that the source file shouldn't be executed as a script; just that it should be
</I>&gt;<i>         /// compiled and validated to ensure it is a valid source file
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         public bool ValidateOnly
</I>&gt;<i>         {
</I>&gt;<i>             get
</I>&gt;<i>             {
</I>&gt;<i>                 return _validateOnly;
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// Any assembly references needed to compile the script
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         public string[] References
</I>&gt;<i>         {
</I>&gt;<i>             get
</I>&gt;<i>             {
</I>&gt;<i>                 return _references;
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// The source file acting as the script
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         public string SourceFile
</I>&gt;<i>         {
</I>&gt;<i>             get
</I>&gt;<i>             {
</I>&gt;<i>                 if(_sourceFile==null)
</I>&gt;<i>                         throw new Exception(&quot;No source file specified!&quot;);
</I>&gt;<i>                 return _sourceFile;
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// The arguments to call the script with
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         public string[] ScriptArgs
</I>&gt;<i>         {
</I>&gt;<i>             get
</I>&gt;<i>             {
</I>&gt;<i>                 string[] args = new string[optionArgs.Count];
</I>&gt;<i>                 for (int i = 0; i &lt; args.Length; i++)
</I>&gt;<i>                     args[i] = optionArgs[i];
</I>&gt;<i>                 return args;
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         #endregion
</I>&gt;<i>
</I>&gt;<i>         #region Constructor
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// Default constructor
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         public MonoScriptOptions(string[] args)
</I>&gt;<i>         {
</I>&gt;<i>             //Validate
</I>&gt;<i>             if(args==null||args.Length==0)
</I>&gt;<i>                 throw new Exception(&quot;No arguments specified!&quot;);
</I>&gt;<i>
</I>&gt;<i>             //Add in args
</I>&gt;<i>             optionArgs.AddRange(args);
</I>&gt;<i>
</I>&gt;<i>             //Fill out options
</I>&gt;<i>             _sourceFile = GetArgument(&quot;sourceFile&quot;);
</I>&gt;<i>
</I>&gt;<i>             string noLogo = GetArgument(&quot;noLogo&quot;);
</I>&gt;<i>             _noLogo = (noLogo != null &amp;&amp; noLogo.ToLower() == &quot;true&quot;) ? true : false;
</I>&gt;<i>
</I>&gt;<i>             string displayUsage = GetArgument(&quot;displayUsage&quot;);
</I>&gt;<i>             _displayUsage = (displayUsage != null &amp;&amp; displayUsage.ToLower() == &quot;true&quot;) ? true : false;
</I>&gt;<i>
</I>&gt;<i>             string validateOnly = GetArgument(&quot;validateOnly&quot;);
</I>&gt;<i>             _validateOnly = (validateOnly != null &amp;&amp; validateOnly.ToLower() == &quot;true&quot;) ? true : false;
</I>&gt;<i>
</I>&gt;<i>             string references = GetArgument(&quot;references&quot;);
</I>&gt;<i>             if(references!=null)
</I>&gt;<i>                 _references = references.Split(Convert.ToChar(&quot;,&quot;));
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         #endregion
</I>&gt;<i>
</I>&gt;<i>         #region Methods
</I>&gt;<i>
</I>&gt;<i>         /// &lt;summary&gt;
</I>&gt;<i>         /// This retrieves an argument value from the list of arguments
</I>&gt;<i>         /// If it finds a requested argument, it then removes it from the list of arguments
</I>&gt;<i>         ///
</I>&gt;<i>         /// If you request the argument for the command &quot;references&quot;, any argument such as:
</I>&gt;<i>         /// --references:[VALUE]
</I>&gt;<i>         /// -r:[VALUE]
</I>&gt;<i>         /// /r:[VALUE]
</I>&gt;<i>         ///
</I>&gt;<i>         /// will all result in the returning of &quot;[VALUE]&quot;
</I>&gt;<i>         /// If more than one is specified, they will be taken in the above order
</I>&gt;<i>         /// &lt;/summary&gt;
</I>&gt;<i>         /// &lt;param name=&quot;requestedCmd&quot;&gt;&lt;/param&gt;
</I>&gt;<i>         /// &lt;returns&gt;&lt;/returns&gt;
</I>&gt;<i>         private string GetArgument(string requestedCmd)
</I>&gt;<i>         {
</I>&gt;<i>             //These variables are used throughout
</I>&gt;<i>             string value = null;
</I>&gt;<i>             string arg = null;
</I>&gt;<i>             //Loop through all arguments
</I>&gt;<i>             for(int i=0;i&lt;optionArgs.Count;i++)
</I>&gt;<i>             {
</I>&gt;<i>                 arg = optionArgs[i];
</I>&gt;<i>                 //Prepare the first format of the requested command to search for
</I>&gt;<i>                 string cmd = string.Format(&quot;--{0}:&quot;, requestedCmd);
</I>&gt;<i>                 if (arg.IndexOf(cmd) != -1)
</I>&gt;<i>                 {
</I>&gt;<i>                     //If it's found, then set the value, and break the loop
</I>&gt;<i>                     value = arg.Substring(
</I>&gt;<i>                         0 + cmd.Length,
</I>&gt;<i>                         arg.Length - cmd.Length);
</I>&gt;<i>                     break;
</I>&gt;<i>                 }
</I>&gt;<i>                 //Try the next format of the requested command
</I>&gt;<i>                 cmd = string.Format(&quot;-{0}:&quot;, requestedCmd[0]);
</I>&gt;<i>                 if (arg.IndexOf(cmd) != -1)
</I>&gt;<i>                 {
</I>&gt;<i>                     //Again, if found, set the value and break out of the loop
</I>&gt;<i>                     value = arg.Substring(
</I>&gt;<i>                         0 + cmd.Length,
</I>&gt;<i>                         arg.Length - cmd.Length);
</I>&gt;<i>                     break;
</I>&gt;<i>                 }
</I>&gt;<i>                 //Finally try the last format of the requested command
</I>&gt;<i>                 cmd = string.Format(&quot;/{0}:&quot;, requestedCmd[0]);
</I>&gt;<i>                 if (arg.IndexOf(cmd) != -1)
</I>&gt;<i>                 {
</I>&gt;<i>                     //Set value, break loop
</I>&gt;<i>                     value = arg.Substring(
</I>&gt;<i>                         0 + cmd.Length,
</I>&gt;<i>                         arg.Length - cmd.Length);
</I>&gt;<i>                     break;
</I>&gt;<i>                 }
</I>&gt;<i>             }
</I>&gt;<i>
</I>&gt;<i>             //If we have got here with a value set, then we found our argument value, so remove the argument,
</I>&gt;<i>             //and return our value
</I>&gt;<i>             if (value != null)
</I>&gt;<i>             {
</I>&gt;<i>                 optionArgs.Remove(arg);
</I>&gt;<i>                 return value;
</I>&gt;<i>             }
</I>&gt;<i>
</I>&gt;<i>             //Otherwise, return null
</I>&gt;<i>             return null;
</I>&gt;<i>         }
</I>&gt;<i>
</I>&gt;<i>         #endregion
</I>&gt;<i>     }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I></PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="029444.html">[Mono-list] Scripting the Linux OS with Mono
</A></li>
	<LI>Next message: <A HREF="029435.html">[Mono-list] Scripting the Linux OS with Mono
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29445">[ date ]</a>
              <a href="thread.html#29445">[ thread ]</a>
              <a href="subject.html#29445">[ subject ]</a>
              <a href="author.html#29445">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
