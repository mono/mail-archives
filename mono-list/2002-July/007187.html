<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Re: From one Cyber Wiz to others
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:j0k3rin%40yahoo.co.in">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="007186.html">
   <LINK REL="Next"  HREF="007181.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Re: From one Cyber Wiz to others
   </H1>
    <B>Zaphod
    </B> 
    <A HREF="mailto:j0k3rin%40yahoo.co.in"
       TITLE="[Mono-list] Re: From one Cyber Wiz to others">j0k3rin@yahoo.co.in
       </A><BR>
    <I>Sun, 21 Jul 2002 17:54:44 +0530</I>
    <P><UL>
        <LI> Previous message: <A HREF="007186.html">[Mono-list] Re: From one Cyber Wiz to others
</A></li>
        <LI> Next message: <A HREF="007181.html">[Mono-list] gtk-sharp problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7187">[ date ]</a>
              <a href="thread.html#7187">[ thread ]</a>
              <a href="subject.html#7187">[ subject ]</a>
              <a href="author.html#7187">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sun, Jul 21, 2002 at 02:43:27AM -0400, BioChem333 wrote:
&gt;<i> The design of gcc is such that you have to split away from the normal 
</I>&gt;<i> compilation path before it reaches the frontend-&gt;rtl process. 
</I>
Typically it requires you to take up the work from the parse tree stage
and do the whole semantic analysis/codegen ...

&gt;<i> The gcj execution path splits from the normal gcc path early on for 
</I>&gt;<i> just this reason, and, afaik, still doesn't produce very good
</I>&gt;<i> bytecode.
</I>
The point is gcj works only for Java ? (ie does not allow C to be 
compiled to bytecode or so I understand).

&gt;<i> The first is, you can invent an intermediate language like rtl which 
</I>&gt;<i> is designed for stack machines, and redesign gcc (which means rewriting 
</I>&gt;<i> frontends)
</I>
Well the egcs-jvm author has said that it was easier developing a Register
based abstract machine than rewriting gcc for outputing JVM code ... (maybe
we'll soon see Parrot output for gcc ... which is a register based engine)

&gt;<i> The translation: you would have to replace most of gcc.
</I>
Well there is a definite possibility of somebody doing this :-)

&gt;<i> should consider taking a look at Rhys Weatherly's treecc program; 
</I>
This is a tool for operating on tree based languages ... and codegens ...

&gt;<i> It helps to deal with a lot of the complexity of writing compilers 
</I>&gt;<i> (and, considering that pnet is almost as far along as mcs but
</I>&gt;<i> only has one hacker really working on it, it works). 
</I>
Well of course , treecc is just a program to autogenerate a lot of code
especially for inheritance and visitor mode operation ... Of course you
still need the dragon book by your side and a good large cup of coffee ..
But it is ideal if you want to rip out the guts of GCC and redo semantic
analysis ... (Rhys Weatherly has mentioned the problems implementing a
CIL output for GCC in his FAQ ... that it was easier doing a C# compiler
in whole ;-)


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="007186.html">[Mono-list] Re: From one Cyber Wiz to others
</A></li>
	<LI> Next message: <A HREF="007181.html">[Mono-list] gtk-sharp problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7187">[ date ]</a>
              <a href="thread.html#7187">[ thread ]</a>
              <a href="subject.html#7187">[ subject ]</a>
              <a href="author.html#7187">[ author ]</a>
         </LI>
       </UL>
</body></html>
