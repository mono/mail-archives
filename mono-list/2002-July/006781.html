<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] MCS -cppoutput C# to C++ generator work in progress
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:bencooley%40cinematix.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="006774.html">
   <LINK REL="Next"  HREF="006782.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] MCS -cppoutput C# to C++ generator work in progress
   </H1>
    <B>Ben Cooley
    </B> 
    <A HREF="mailto:bencooley%40cinematix.com"
       TITLE="[Mono-list] MCS -cppoutput C# to C++ generator work in progress">bencooley@cinematix.com
       </A><BR>
    <I>Fri, 5 Jul 2002 12:19:10 +0900</I>
    <P><UL>
        <LI> Previous message: <A HREF="006774.html">[Mono-list] MCS -cppoutput C# to C++ generator work in progress
</A></li>
        <LI> Next message: <A HREF="006782.html">[Mono-list] MCS -cppoutput C# to C++ generator work in progress
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6781">[ date ]</a>
              <a href="thread.html#6781">[ thread ]</a>
              <a href="subject.html#6781">[ subject ]</a>
              <a href="author.html#6781">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> Hello!
</I>&gt;<i>
</I>&gt;<i> &gt; Since porting last may's rev of mono to MSVC , I've been working on the
</I>C++
&gt;<i> &gt; output module for mcs.  Basically, cppoutput.cs is added to the mcs
</I>core,
&gt;<i> &gt; and from the parse tree generated by the main compiler, it generates a
</I>&gt;<i> &gt; compatible set of .cpp, .h, and .inl files complete with nice #line
</I>&gt;<i> &gt; directives for .cs debugging, and with the limited set of statements
</I>&gt;<i> &gt; compiling, it seems to work nicely.
</I>&gt;<i>
</I>&gt;<i> I am not sure that you will be able to do a complete translator by using
</I>&gt;<i> the internal parse tree, as this parse tree is lacking the semantic
</I>&gt;<i> analysis phase.
</I>&gt;<i>
</I>&gt;<i> For instance, during the `DoResolve' phase, names are resolved to their
</I>&gt;<i> actual meaning.  For instance:
</I>&gt;<i>
</I>&gt;<i> A += X;
</I>&gt;<i>
</I>&gt;<i> A could mean a number of things depending on its context.  An assignment
</I>&gt;<i> to field variable;  An assignment to a property;  An event addition or
</I>&gt;<i> even an error if A is a type.
</I>&gt;<i>
</I>&gt;<i> My suggestion would be to add a different &quot;Emit&quot; method to the Statement
</I>&gt;<i> and Expression base classes (EmitCpp) that would generate the code that
</I>&gt;<i> you want, but the resulting code would look less than C#, and more close
</I>&gt;<i> to the real internal representation.
</I>&gt;<i>
</I>&gt;<i> Btw, someone could also write an EmitJava method, and for some cases
</I>&gt;<i> generate code for a JVM.
</I>
Actually the call to the cpp output stuff comes right before the code
generation
phase of the compiler, when all of the type information, etc. has been
deduced
and all of the pre-types have been generated, so that's really not a
problem.   The only
thing I needed to do was to make one or two internal properties in
expresions.cs
have a public interface.

Also, I thought about adding a CppEmit() method to the various mono classes,
figured that would dirty up the code something fierce.  Primarily the
problem is
in storing all of the necessary internal state variables and whatnot in your
classes.  So I decided the best and probably cleanest way to implement the
system would be to pack it into a single (or small set) of Cpp generator
classes
in my own file.  That requires only the tiniest changes in the core
compiler, and
makes the whole thing more self contained.  To add the --cppoutput to the
mcs compiler, all you need to do is add the cppoutput.cs file, and change
the
compiler options to support it, and then call the output methods in the main
compiler driver function right before the &quot;EmitCode&quot; stuff, (and right after
emit code again to grab the metadata .exe and .dll files generated by the
main
compiler.)  Small footprint, and everybody working on the core compiler
need not worry about it.

&gt;<i> &gt; I tweaked mono's and binary vtable representations to coexist with C++
</I>&gt;<i> &gt; efficiently so that mono could easily marshall and call c++ code as if
</I>it
&gt;<i> &gt; was doing an &quot;internal_call&quot;, and c++ could call mono as well using
</I>&gt;<i> &gt; mono_execute().  The solution I came up with was to put mono's vtable
</I>&gt;<i> &gt; &quot;before&quot; the vtable structure, and the c++ vtable after it.   When you
</I>&gt;<i> &gt; inherit in C++ from the Object class, you automatically get a set of 6
</I>&gt;<i> &gt; vtable entries which reserve space in the C++ vtable for the mono vtable
</I>&gt;<i> &gt; structure.  That way mono objects are C++ objects, and vica-versa, and
</I>each
&gt;<i> &gt; side conveniently marshals to the other transparently.
</I>&gt;<i>
</I>&gt;<i> Pretty cool hack, I am reading with excitement the rest of your
</I>&gt;<i> message.  It looks really interesting.
</I>
Thanks.  I'll have more of the manual processes (metadata inclusion) working
automatically by this weekend, and possibly support for more statements.
I'm
still working with my ancient MSVC build of mono, so I need to do a merge
eventually.  I use a program called &quot;beyond compare&quot; to do complex merges
in Windows.. works extremely well.  Don't know if it produces diff or patch
output though.

Question: What precisely does the &quot;internal call&quot; marshaling/trampoline code
do in the JIT?  Can mono be technically made to directly call the C++
code directly (and vica versa) if careful control of the C++ stack is
excercised?

Ben




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="006774.html">[Mono-list] MCS -cppoutput C# to C++ generator work in progress
</A></li>
	<LI> Next message: <A HREF="006782.html">[Mono-list] MCS -cppoutput C# to C++ generator work in progress
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6781">[ date ]</a>
              <a href="thread.html#6781">[ thread ]</a>
              <a href="subject.html#6781">[ subject ]</a>
              <a href="author.html#6781">[ author ]</a>
         </LI>
       </UL>
</body></html>
