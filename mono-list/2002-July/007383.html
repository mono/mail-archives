<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Announce: A .NET assembly -&gt; native codegenerationtool (ala ngen for MONO)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:Zoltan.2.Varga%40nokia.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="007400.html">
   <LINK REL="Next"  HREF="007385.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Announce: A .NET assembly -&gt; native codegenerationtool (ala ngen for MONO)
   </H1>
    <B>Zoltan.2.Varga@nokia.com
    </B> 
    <A HREF="mailto:Zoltan.2.Varga%40nokia.com"
       TITLE="[Mono-list] Announce: A .NET assembly -&gt; native codegenerationtool (ala ngen for MONO)">Zoltan.2.Varga@nokia.com
       </A><BR>
    <I>Mon, 29 Jul 2002 12:40:03 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="007400.html">[Mono-list] Announce: A .NET assembly -&gt; native code
 generationtool (ala ngen for MONO)
</A></li>
        <LI> Next message: <A HREF="007385.html">[Mono-list] Announce: A .NET assembly -&gt; native
 codegenerationtool (ala ngen for MONO)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7383">[ date ]</a>
              <a href="thread.html#7383">[ thread ]</a>
              <a href="subject.html#7383">[ subject ]</a>
              <a href="author.html#7383">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>					Hi,

&gt;<i> -----Original Message-----
</I>&gt;<i> From: ext Dietmar Maurer [mailto:<A HREF="mailto:dietmar@ximian.com">dietmar@ximian.com</A>]
</I>&gt;<i> Sent: 29. July 2002 12:10
</I>&gt;<i> To: Varga Zoltan.2 (NMP/Budapest)
</I>&gt;<i> Cc: Miguel de Icaza; Mono List
</I>&gt;<i> Subject: RE: [Mono-list] Announce: A .NET assembly -&gt; native
</I>&gt;<i> codegenerationtool (ala ngen for MONO)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On Mon, 2002-07-29 at 11:12, <A HREF="mailto:Zoltan.2.Varga@nokia.com">Zoltan.2.Varga@nokia.com</A> wrote:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt;         1. It does not work with exceptions: The current code is
</I>&gt;<i> &gt; &gt;            incorrect because it does not save/restore the LMF when
</I>&gt;<i> &gt; &gt;            calling precompiled methods - but 
</I>&gt;<i> saving/restoring the LMF
</I>&gt;<i> &gt; &gt;            would lead to serious performance problems.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Can you explain what the LMF is? I looked at the code, but 
</I>&gt;<i> I can't understand what it is.
</I>&gt;<i> 
</I>&gt;<i> Sure. The Problem is that unmanaged code can raise exception, and we
</I>&gt;<i> must be able to recover from such exception and print a stack 
</I>&gt;<i> trace for
</I>&gt;<i> example (you can find some docu in mono/docs/exceptions). One 
</I>&gt;<i> (compiler
</I>&gt;<i> independent) way to do that is to save a data structure with all
</I>&gt;<i> necessary info on the stack each time you call an unmanaged 
</I>&gt;<i> method - we
</I>&gt;<i> call that info Last Managed Frame (MonoLMF).
</I>&gt;<i> 
</I>&gt;<i> If a exception occurs in unmanaged code we simply use the data in the
</I>&gt;<i> LMF to unwind the stack.
</I>&gt;<i> 
</I>
Since the precompiled code does not contain exception handlers, it only needs to propagate exceptions, which means restoring
callee saved registers. This is done by examining the prelude of the function to determine which registers are saved and
in which order, then restoring these registers from stack counting back from EBP. This works because the prelude generated
by gcc has a simple structure (after you turn off certain optimizations). So the current code can handle exceptions without
saving/restoring an LMF.

&gt;<i> &gt; 
</I>&gt;<i> &gt; BTW: I started this as a hobby project to learn about 
</I>&gt;<i> .NET/compilers etc. I wouldn't be suprised if it turned to be unusable
</I>&gt;<i> &gt; due to problems such as the one above...
</I>&gt;<i> 
</I>&gt;<i> Such code is always usable. If it turns out that we cant solve all
</I>&gt;<i> problems we simply need to find another Solution. But I 
</I>&gt;<i> imagine you have
</I>&gt;<i> learned a lot about mono when you wrote that code!
</I>&gt;<i> 
</I>&gt;<i> &gt; &gt;         2. Array bound checking: There is no array bound 
</I>&gt;<i> &gt; &gt; checking at the
</I>&gt;<i> &gt; &gt;            moment and maybe that is the only reason why 
</I>&gt;<i> it speeds up
</I>&gt;<i> &gt; &gt;            pnetmark? gcc is unable to do bound check 
</I>&gt;<i> removal, so array
</I>&gt;<i> &gt; &gt;            access will be slow (or you have to remove that 
</I>&gt;<i> &gt; &gt; checks before
</I>&gt;<i> &gt; &gt;            you emit C code).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; You are right. I somehow throught that mono does not do 
</I>&gt;<i> bound checking (perhaps an earlier version didn't) so I put that
</I>&gt;<i> &gt; on the TODO list instead of implementing it right away.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt;         3. I wonder if gcc is really able to optimize the 
</I>&gt;<i> emitted C#
</I>&gt;<i> &gt; &gt;            very much.
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; gcc is designed to optimize procedural code, so of course 
</I>&gt;<i> it has problems with virtual calls, bound checks, delegates etc. 
</I>&gt;<i> &gt; But every program contains a mix of high level and low 
</I>&gt;<i> level code, so some performance gains can be expected ever for
</I>&gt;<i> &gt; programs written in an object-oriented style such as mcs.
</I>&gt;<i> 
</I>&gt;<i> Is it difficult to implement array bound checking? If not I would like
</I>&gt;<i> to have some real benchmark results (including bound checking).
</I>
Not at all. I added bound checking to the latest snapshot and put it onto the web. I re-ran pnetmark and the mcs self
compiling tests, but there was no noticable slowdown.

&gt;<i> 
</I>&gt;<i> - Dietmar
</I>&gt;<i> 
</I>&gt;<i> 
</I>
				bye

					Zoltan


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="007400.html">[Mono-list] Announce: A .NET assembly -&gt; native code
 generationtool (ala ngen for MONO)
</A></li>
	<LI> Next message: <A HREF="007385.html">[Mono-list] Announce: A .NET assembly -&gt; native
 codegenerationtool (ala ngen for MONO)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7383">[ date ]</a>
              <a href="thread.html#7383">[ thread ]</a>
              <a href="subject.html#7383">[ subject ]</a>
              <a href="author.html#7383">[ author ]</a>
         </LI>
       </UL>
</body></html>
