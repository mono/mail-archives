<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Application port to .Net, including Mono
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Application%20port%20to%20.Net%2C%20including%20Mono&In-Reply-To=1288724378036-3024209.post%40n4.nabble.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="046008.html">
   <LINK REL="Next"  HREF="046011.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Application port to .Net, including Mono</H1>
    <B>Danny</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20Application%20port%20to%20.Net%2C%20including%20Mono&In-Reply-To=1288724378036-3024209.post%40n4.nabble.com"
       TITLE="[Mono-list] Application port to .Net, including Mono">dgortonii at gmail.com
       </A><BR>
    <I>Tue Nov  2 16:24:54 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="046008.html">[Mono-list] Application port to .Net, including Mono
</A></li>
        <LI>Next message: <A HREF="046011.html">[Mono-list] Mono v2.8 Linux Installer download link location
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46009">[ date ]</a>
              <a href="thread.html#46009">[ thread ]</a>
              <a href="subject.html#46009">[ subject ]</a>
              <a href="author.html#46009">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>FWIW, I have used interop on both MS.NET and Mono on Ubuntu with no
problems.  I think you're more likely to run into interop problems due
to the native library signatures than any platform oddities.  Just leave
off the DLL extension in your DllImport declarations and build one
version of the native code for Windows, the other for *nix and deploy
accordingly.  I think there is some weirdness there WRT to MAC (Apple)
OS's file naming, but I've no direct experience there.

As for #2, I'd make an wrapper assembly that is solely responsible for
interoping your native library.  That leaves the web service code
responsible for ONLY web service necessities, and gives you the ability
to host your component in a non-web-service host, such as a Windows
service (daemon) without copying core code around - or having to
refactor later - and the only real worrisome part being managing object
serialization properly, which is no big deal really.

Use interfaces to define your messages and your client side component
becomes a proxy object to the remoted server, web service or otherwise.
With web services you get proxy generation for free based on the WSDL
and with standard remoting you just use the configuration infrastucture
to get your proxy object instance of your interface.  This is more
nuts-n-bolts than WCF, which I never bothered to really learn, but we
use this approach alot and it works well.  Though you have more
components to manage in the long run, it gives you almost complete
control over how you can deploy the service using a once-and-only-once
and separation-of-concerns paradigm.


On 11/02/2010 02:59 PM, SaulToc wrote:
&gt;<i> 
</I>&gt;<i> Hi Folks,
</I>&gt;<i> 
</I>&gt;<i> I have been tasked with &quot;modernizing&quot; a complex, distributed application.
</I>&gt;<i> Part of that modernization involves discarding a proprietary TCP/IP-based
</I>&gt;<i> messaging protocol and, in its stead, using Web Services.
</I>&gt;<i> 
</I>&gt;<i> As a proof of concept, I am considering taking a very small part of the
</I>&gt;<i> application and writing a WS version thereof. For the sake of discussion I
</I>&gt;<i> would describe the current implementation of this part as follows:
</I>&gt;<i> 
</I>&gt;<i> a. UI on nodeA connects to an inetd-like process on nodeB, asking this
</I>&gt;<i> process to start another process,   
</I>&gt;<i>     let's call it a &quot;filesystem browser.&quot;
</I>&gt;<i> b. the inetd-like process launches the filesystem browser and hands off the
</I>&gt;<i> connection to the UI
</I>&gt;<i> c. the UI can now obtain and display the contents of nodeB's filesystem.
</I>&gt;<i> Note that the UI uses a dll that implements the aforementioned proprietary
</I>&gt;<i> messaging.
</I>&gt;<i> 
</I>&gt;<i> Part of this POC is to not completely rewrite the application. The intent is
</I>&gt;<i> to preserve, where possible, the existing application code and to replace
</I>&gt;<i> only the plumbing. My current thinking is to realize this functionality via
</I>&gt;<i> .Net as follows:
</I>&gt;<i> 
</I>&gt;<i> 1. Build the fileystem browser as a .dll (it is presently an .exe)
</I>&gt;<i> 2. Implement the inetd-like process as a Web Service &quot;wrapper&quot; around this
</I>&gt;<i> dll (interop implicated here)
</I>&gt;<i> 3. Replace the client-side messaging dll with a .Net dll that offers the
</I>&gt;<i> same entry points as the original dll.
</I>&gt;<i> 4. This .Net dll would function as a client to the Web Service.
</I>&gt;<i> 
</I>&gt;<i> So the new implementation, at least its steady-state, would look something
</I>&gt;<i> like this:
</I>&gt;<i> 
</I>&gt;<i> i.  UI sends a proprietary message to nodeB by calling into the new client
</I>&gt;<i> dll of step 3. 
</I>&gt;<i> ii.  client dll sends this propriety message via MTOM to the Web Service
</I>&gt;<i> wrapper at nodeB
</I>&gt;<i> iii. Web Service at nodeB makes an interop call to the dll version of the
</I>&gt;<i> .exe file of step 1, passing the proprietary message to the same code that
</I>&gt;<i> has always processed this message.
</I>&gt;<i> iv. data returned by the dll, perhaps including a reply message, is returned
</I>&gt;<i> by the Web Service to the 
</I>&gt;<i>     client, thence to the UI
</I>&gt;<i> 
</I>&gt;<i> That's about as far as I've gotten. Some questions:
</I>&gt;<i> 
</I>&gt;<i> A. Does this seem a reasonable approach to this POC?
</I>&gt;<i> B. Will the use of interop lend itself to Mono? I have read the FAQs and see
</I>&gt;<i> that there seems to be pretty 
</I>&gt;<i>     robust support for interop.
</I>&gt;<i> C. Will the use of WCF lend itself to Mono?
</I>&gt;<i> 
</I>&gt;<i> I try to evangelize for .Net but am routinely and reflexively shot down
</I>&gt;<i> because of a perceived lack of *nix support. This is my first foray into the
</I>&gt;<i> Mono world and alot depends on it.
</I>&gt;<i> 
</I>&gt;<i> At any rate, I would be most grateful if folks who have dealt with similar
</I>&gt;<i> problems, or those who simply can shed some light on such a matter, would
</I>&gt;<i> offer their opinions.
</I>&gt;<i> 
</I>&gt;<i> Thank you.
</I>&gt;<i> 
</I>&gt;<i> -Saul
</I>&gt;<i> company?
</I>&gt;<i> 
</I></PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="046008.html">[Mono-list] Application port to .Net, including Mono
</A></li>
	<LI>Next message: <A HREF="046011.html">[Mono-list] Mono v2.8 Linux Installer download link location
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#46009">[ date ]</a>
              <a href="thread.html#46009">[ thread ]</a>
              <a href="subject.html#46009">[ subject ]</a>
              <a href="author.html#46009">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
