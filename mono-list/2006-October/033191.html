<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] GTK# DataGrid sample
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20GTK%23%20DataGrid%20sample&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033212.html">
   <LINK REL="Next"  HREF="033199.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] GTK# DataGrid sample</H1>
    <B>Andrus</B> 
    <A HREF="mailto:mono-list%40lists.ximian.com?Subject=%5BMono-list%5D%20GTK%23%20DataGrid%20sample&In-Reply-To="
       TITLE="[Mono-list] GTK# DataGrid sample">kobruleht2 at hot.ee
       </A><BR>
    <I>Sun Oct 29 05:01:00 EST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="033212.html">[Mono-list] Learning ASP.NET?
</A></li>
        <LI>Next message: <A HREF="033199.html">[Mono-list] Building mono-basic from the sources
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33191">[ date ]</a>
              <a href="thread.html#33191">[ thread ]</a>
              <a href="subject.html#33191">[ subject ]</a>
              <a href="author.html#33191">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Daniel,

thank you.
I found the following disadvantages of this code compared to SWF:

1. As you wrote, this is only one-way binding.
2. Requires lot of manually written code.
3. Unfinished, not documented and tested.

In case of WinForms I need to write manually only 3 lines for two-way data 
binding:

Command1.CommandText = &quot;select * FROM mytable&quot;;
DataAdapter1.Fill(dataSet1);
DataSource = dataSet1.Tables[0];

Other code is generated by free Visual C# Express 2005  automatically and 
works in MONO.

I have no experience to develop this in GTK#
So I think I will try use WinForms data binding.

Thank you very much for this sample. Now I understand that this can be 
implemented in GTK# also

Andrus.

----- Original Message ----- 

&gt;<i>I have something I have worked on for awhile.
</I>&gt;<i>
</I>&gt;<i> Here are the source files I included:
</I>&gt;<i> DataGrid.cs - creates a DataGrid for Gtk# with data
</I>&gt;<i> binding support.
</I>&gt;<i> TestDataGrid.cs - tests the gtk# data grid
</I>&gt;<i>
</I>&gt;<i> Basically, you can take a pre-loaded DataTable, and
</I>&gt;<i> then &quot;data bind&quot; it to the DataGrid.  It may not be
</I>&gt;<i> true data binding like SWF or webforms, but its an
</I>&gt;<i> attempt.
</I>&gt;<i>
</I>&gt;<i> A change to the data in the DataGrid will update the
</I>&gt;<i> data in the DataTable.
</I>&gt;<i> If you add a row or delete a row in the DataGrid, it
</I>&gt;<i> will be reflected in the DataTable.  If you modify a
</I>&gt;<i> cell in the DataGrid, the row and column in the
</I>&gt;<i> DataTable will be updated.  However, modifying
</I>&gt;<i> something in the DataTable does not update the
</I>&gt;<i> DataGrid.
</I>&gt;<i>
</I>&gt;<i> In the test, there are four menu items:
</I>&gt;<i> 1. Add Row - adds a row
</I>&gt;<i> 2. Dump Table - dumps to the console what's in the
</I>&gt;<i> DataTable
</I>&gt;<i> 3. Editable - sets the DataGrid editable or not
</I>&gt;<i> 4. Delete Selected Row - deletes the highlighted row
</I>&gt;<i>
</I>&gt;<i> The DataGrid is implemented using a Gtk# TreeView
</I>&gt;<i> using the ListStore tree model.
</I>&gt;<i>
</I>&gt;&gt;<i> I need to edit DataTable returned by Npgsql in grid.
</I>&gt;&gt;<i> I'm studying GTK# and WinForms DataGrid  for this.
</I>&gt;&gt;<i> It would be nice if sqlsharpgtk allows edit tables
</I>&gt;&gt;<i> in grid.
</I>&gt;&gt;<i> I was looking for a sample GTK# code which allows to
</I>&gt;&gt;<i> edit DataTable in grid
</I>&gt;&gt;<i> but have'nt found any.
</I>&gt;&gt;<i> So I think I will use WinForms.
</I>


--------------------------------------------------------------------------------


&gt;<i> // DataGrid.cs
</I>&gt;<i> namespace Mono.Data.GtkSharp
</I>&gt;<i> {
</I>&gt;<i> // notice System.Data is not references here
</I>&gt;<i>
</I>&gt;<i> using System;
</I>&gt;<i> using System.Collections;
</I>&gt;<i> using System.ComponentModel;
</I>&gt;<i> using System.Reflection;
</I>&gt;<i> using System.Runtime.InteropServices;
</I>&gt;<i> using System.Text;
</I>&gt;<i>
</I>&gt;<i> using GLib;
</I>&gt;<i> using Gtk;
</I>&gt;<i>
</I>&gt;<i> public class DataGridColumn
</I>&gt;<i> {
</I>&gt;<i> private string columnName = &quot;&quot;;
</I>&gt;<i> private TreeViewColumn treeViewColumn = null;
</I>&gt;<i> public CellRendererText Renderer = null; // should be internal
</I>&gt;<i>
</I>&gt;<i> public string ColumnName {
</I>&gt;<i> get {
</I>&gt;<i> return columnName;
</I>&gt;<i> }
</I>&gt;<i> set {
</I>&gt;<i> columnName = value;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public TreeViewColumn TreeViewColumn {
</I>&gt;<i> get {
</I>&gt;<i> return treeViewColumn;
</I>&gt;<i> }
</I>&gt;<i> set {
</I>&gt;<i> treeViewColumn = value;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public class DataGrid : VBox {
</I>&gt;<i> private ListStore store;
</I>&gt;<i> private TreeView treeView;
</I>&gt;<i>
</I>&gt;<i> public ArrayList gridColumns; // TODO: make Columns a collection
</I>&gt;<i>
</I>&gt;<i> public DataGrid () : base(false, 4) {
</I>&gt;<i> ScrolledWindow sw = new ScrolledWindow ();
</I>&gt;<i> this.PackStart (sw, true, true, 0);
</I>&gt;<i>
</I>&gt;<i> treeView = new TreeView (store);
</I>&gt;<i> treeView.HeadersVisible = true;
</I>&gt;<i> //treeView.ModifyFont (Pango.FontDescription.FromString (&quot;courier new&quot;));
</I>&gt;<i>
</I>&gt;<i> gridColumns = new ArrayList(0);
</I>&gt;<i>
</I>&gt;<i> sw.Add (treeView);
</I>&gt;<i>
</I>&gt;<i> store = new ListStore (GLib.GType.String);
</I>&gt;<i>
</I>&gt;<i> treeView.EnableSearch = true;
</I>&gt;<i> treeView.HeadersClickable = true;
</I>&gt;<i> dataMember = &quot;&quot;;
</I>&gt;<i> dataSource = null;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> ArrayList bindrows = null;
</I>&gt;<i> object resolvedDataSource = null;
</I>&gt;<i>
</I>&gt;<i> private bool editable = true;
</I>&gt;<i>
</I>&gt;<i> private object dataSource;
</I>&gt;<i>
</I>&gt;<i> private string dataMember;
</I>&gt;<i>
</I>&gt;<i> public int SelectedRow {
</I>&gt;<i> get {
</I>&gt;<i> TreeIter iter;
</I>&gt;<i> TreeModel model;
</I>&gt;<i> TreeSelection selection = treeView.Selection;
</I>&gt;<i> if (selection.GetSelected (out model, out iter)) {
</I>&gt;<i> TreePath[] path = selection.GetSelectedRows (out model);
</I>&gt;<i> return path[0].Indices[0]; // return selected row
</I>&gt;<i> }
</I>&gt;<i> else
</I>&gt;<i> return -1; // not selected
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public TreeIter SelectedIter {
</I>&gt;<i> get {
</I>&gt;<i> TreeIter iter;
</I>&gt;<i> TreeModel model;
</I>&gt;<i> TreeSelection selection = treeView.Selection;
</I>&gt;<i> if (selection.GetSelected (out model, out iter))
</I>&gt;<i> return iter; // return seelcted iter
</I>&gt;<i> else
</I>&gt;<i> return TreeIter.Zero; // not selected
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public TreeView View
</I>&gt;<i> {
</I>&gt;<i> get
</I>&gt;<i> {
</I>&gt;<i> return treeView;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public object DataSource
</I>&gt;<i> {
</I>&gt;<i> get
</I>&gt;<i> {
</I>&gt;<i> return dataSource;
</I>&gt;<i> }
</I>&gt;<i> set
</I>&gt;<i> {
</I>&gt;<i> dataSource = value;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public string DataMember
</I>&gt;<i> {
</I>&gt;<i> get
</I>&gt;<i> {
</I>&gt;<i> return dataMember;
</I>&gt;<i> }
</I>&gt;<i> set
</I>&gt;<i> {
</I>&gt;<i> dataMember = value;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public ListStore Store
</I>&gt;<i> {
</I>&gt;<i> get
</I>&gt;<i> {
</I>&gt;<i> return store;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public ArrayList Columns
</I>&gt;<i> {
</I>&gt;<i> get
</I>&gt;<i> {
</I>&gt;<i> return gridColumns;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public bool Editable {
</I>&gt;<i> get {
</I>&gt;<i> return editable; // not a good way to see if its editable or not
</I>&gt;<i> // because various columns could be editable and others non-editable
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> set {
</I>&gt;<i> editable = value;
</I>&gt;<i> if (value == true) {
</I>&gt;<i> for(int c = 0; c &lt; gridColumns.Count; c++) {
</I>&gt;<i> DataGridColumn col = (DataGridColumn) gridColumns[c];
</I>&gt;<i> col.TreeViewColumn.Clickable = true;
</I>&gt;<i> col.Renderer.Mode = CellRendererMode.Editable;
</I>&gt;<i> col.Renderer.Editable = true;
</I>&gt;<i> }
</I>&gt;<i> treeView.RulesHint = true;
</I>&gt;<i> treeView.Selection.Mode = SelectionMode.Single;
</I>&gt;<i> }
</I>&gt;<i> else {
</I>&gt;<i> for(int c = 0; c &lt; gridColumns.Count; c++) {
</I>&gt;<i> DataGridColumn col = (DataGridColumn) gridColumns[c];
</I>&gt;<i> col.TreeViewColumn.Clickable = false;
</I>&gt;<i> col.Renderer.Mode = CellRendererMode.Inert;
</I>&gt;<i> col.Renderer.Editable = false;
</I>&gt;<i> }
</I>&gt;<i> treeView.RulesHint = false;
</I>&gt;<i> treeView.Selection.Mode = SelectionMode.Single;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public int AddNew()
</I>&gt;<i> {
</I>&gt;<i> // TODO: need to check if resolved data source is not null
</I>&gt;<i>
</I>&gt;<i> IBindingList b = (IBindingList) resolvedDataSource;
</I>&gt;<i>
</I>&gt;<i> if (b.AllowNew) {
</I>&gt;<i> object obj = b.AddNew();
</I>&gt;<i> if (obj == null) {
</I>&gt;<i> //Console.Error.WriteLine(&quot;obj is null&quot;);
</I>&gt;<i> }
</I>&gt;<i> else {
</I>&gt;<i> //Console.Error.WriteLine(&quot;Type: &quot; + obj.GetType().ToString());
</I>&gt;<i> bindrows.Add(obj);
</I>&gt;<i>
</I>&gt;<i> TreeIter iter = NewRow();
</I>&gt;<i> for(int i = 0; i &lt; gridColumns.Count; i++)
</I>&gt;<i> SetColumnValue (iter, i, String.Empty);
</I>&gt;<i>
</I>&gt;<i> return bindrows.Count - 1;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> return -1;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public int DeleteRow(int row)
</I>&gt;<i> {
</I>&gt;<i> if (row &lt; 0)
</I>&gt;<i> return -1; // should throw an exception - out of range
</I>&gt;<i>
</I>&gt;<i> TreeIter iter = TreeIter.Zero;
</I>&gt;<i> if (store.IterNthChild(out iter, row) == false)
</I>&gt;<i> return -1;
</I>&gt;<i>
</I>&gt;<i> IBindingList b = (IBindingList) resolvedDataSource;
</I>&gt;<i> if (b.AllowRemove) {
</I>&gt;<i> IList list = (IList) resolvedDataSource;
</I>&gt;<i> bindrows.RemoveAt(row);
</I>&gt;<i> store.Remove (ref iter);
</I>&gt;<i> list.RemoveAt (row);
</I>&gt;<i>
</I>&gt;<i> return row;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> return -1;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> // sets the column count.  beware, it clears
</I>&gt;<i> // use this if you are going to load each column and row yourself
</I>&gt;<i> // instead of using DataBind() or DataLoad()
</I>&gt;<i> public void SetColumnCount (int columnCount)
</I>&gt;<i> {
</I>&gt;<i> Clear ();
</I>&gt;<i> dataMember = &quot;&quot;;
</I>&gt;<i> dataSource = null;
</I>&gt;<i>
</I>&gt;<i> GLib.GType[] theTypes = new GLib.GType[columnCount];
</I>&gt;<i> gridColumns = new ArrayList ();
</I>&gt;<i> for (int col = 0; col &lt; columnCount; col++)
</I>&gt;<i> {
</I>&gt;<i> theTypes[col] = GLib.GType.String;
</I>&gt;<i> gridColumns.Add (new DataGridColumn ());
</I>&gt;<i> }
</I>&gt;<i> store.ColumnTypes = theTypes;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> // load data from a data table or data set
</I>&gt;<i> public long DataBind ()
</I>&gt;<i> {
</I>&gt;<i> long rowsRetrieved = 0;
</I>&gt;<i>
</I>&gt;<i> Clear ();
</I>&gt;<i>
</I>&gt;<i> System.Object o = null;
</I>&gt;<i> o = GetResolvedDataSource (DataSource, DataMember);
</I>&gt;<i> resolvedDataSource = o;
</I>&gt;<i> IEnumerable ie = (IEnumerable) o;
</I>&gt;<i> ITypedList tlist = (ITypedList) o;
</I>&gt;<i> TreeIter iter = new TreeIter ();
</I>&gt;<i>
</I>&gt;<i> PropertyDescriptorCollection pdc = tlist.GetItemProperties (new
</I>&gt;<i> PropertyDescriptor[0]);
</I>&gt;<i> gridColumns = new ArrayList(pdc.Count);
</I>&gt;<i>
</I>&gt;<i> // define the columns in the treeview store
</I>&gt;<i> // based on the schema of the result
</I>&gt;<i> GLib.GType[] theTypes = new GLib.GType[pdc.Count];
</I>&gt;<i> for (int col = 0; col &lt; pdc.Count; col++) {
</I>&gt;<i> theTypes[col] = GLib.GType.String;
</I>&gt;<i> }
</I>&gt;<i> store.ColumnTypes = theTypes;
</I>&gt;<i>
</I>&gt;<i> bindrows = new ArrayList();
</I>&gt;<i>
</I>&gt;<i> int colndx = -1;
</I>&gt;<i> foreach (PropertyDescriptor pd in pdc) {
</I>&gt;<i>
</I>&gt;<i> colndx ++;
</I>&gt;<i>
</I>&gt;<i> DataGridColumn gridCol = new DataGridColumn ();
</I>&gt;<i> gridCol.ColumnName = pd.Name;
</I>&gt;<i> gridColumns.Add (gridCol);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> bindrows = new ArrayList();
</I>&gt;<i>
</I>&gt;<i> foreach (System.Object obj in ie) {
</I>&gt;<i> ICustomTypeDescriptor custom = (ICustomTypeDescriptor) obj;
</I>&gt;<i> PropertyDescriptorCollection properties = custom.GetProperties ();
</I>&gt;<i>
</I>&gt;<i> bindrows.Add(obj);
</I>&gt;<i>
</I>&gt;<i> rowsRetrieved ++;
</I>&gt;<i> iter = NewRow ();
</I>&gt;<i> int cv = 0;
</I>&gt;<i> foreach (PropertyDescriptor property in properties) {
</I>&gt;<i> object oPropValue = property.GetValue (obj);
</I>&gt;<i> string sPropValue = &quot;&quot;;
</I>&gt;<i> if (oPropValue.GetType ().ToString ().Equals(&quot;System.Byte[]&quot;))  {
</I>&gt;<i> //sPropValue = SqlSharpGtk.GetHexString ((byte[]) oPropValue);
</I>&gt;<i> Console.Error.WriteLine(&quot;Byte[]  value&quot;);
</I>&gt;<i> }
</I>&gt;<i> else
</I>&gt;<i> sPropValue = oPropValue.ToString ();
</I>&gt;<i>
</I>&gt;<i> SetColumnValue (iter, cv, sPropValue);
</I>&gt;<i> cv++;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> treeView.Model = store;
</I>&gt;<i> AutoCreateTreeViewColumns ();
</I>&gt;<i> return rowsRetrieved;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> // borrowed from Mono's System.Web implementation
</I>&gt;<i> protected IEnumerable GetResolvedDataSource(object source, string member)
</I>&gt;<i> {
</I>&gt;<i> if (source != null &amp;&amp; source is IListSource) {
</I>&gt;<i> IListSource src = (IListSource) source;
</I>&gt;<i> IList list = src.GetList ();
</I>&gt;<i> if (!src.ContainsListCollection) {
</I>&gt;<i> return list;
</I>&gt;<i> }
</I>&gt;<i> if (list != null &amp;&amp; list is ITypedList) {
</I>&gt;<i>
</I>&gt;<i> ITypedList tlist = (ITypedList) list;
</I>&gt;<i> PropertyDescriptorCollection pdc = tlist.GetItemProperties (new
</I>&gt;<i> PropertyDescriptor[0]);
</I>&gt;<i> if (pdc != null &amp;&amp; pdc.Count &gt; 0) {
</I>&gt;<i> PropertyDescriptor pd = null;
</I>&gt;<i> if (member != null &amp;&amp; member.Length &gt; 0) {
</I>&gt;<i> pd = pdc.Find (member, true);
</I>&gt;<i> } else {
</I>&gt;<i> pd = pdc[0];
</I>&gt;<i> }
</I>&gt;<i> if (pd != null) {
</I>&gt;<i> object rv = pd.GetValue (list[0]);
</I>&gt;<i> if (rv != null &amp;&amp; rv is IEnumerable) {
</I>&gt;<i> return (IEnumerable)rv;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> throw new Exception (&quot;ListSource_Missing_DataMember&quot;);
</I>&gt;<i> }
</I>&gt;<i> throw new Exception (&quot;ListSource_Without_DataMembers&quot;);
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> if (source is IEnumerable) {
</I>&gt;<i> return (IEnumerable)source;
</I>&gt;<i> }
</I>&gt;<i> return null;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public void Clear ()
</I>&gt;<i> {
</I>&gt;<i> if (store != null)
</I>&gt;<i> {
</I>&gt;<i> store.Clear ();
</I>&gt;<i> store = null;
</I>&gt;<i> store = new ListStore (GLib.GType.String);
</I>&gt;<i> }
</I>&gt;<i> else
</I>&gt;<i> store = new ListStore (GLib.GType.String);
</I>&gt;<i>
</I>&gt;<i> if (gridColumns != null)
</I>&gt;<i> {
</I>&gt;<i> for (int c = 0; c &lt; gridColumns.Count; c++)
</I>&gt;<i> {
</I>&gt;<i> DataGridColumn gridCol = (DataGridColumn) gridColumns[c];
</I>&gt;<i> if (gridCol.TreeViewColumn != null)
</I>&gt;<i> {
</I>&gt;<i> treeView.RemoveColumn (gridCol.TreeViewColumn);
</I>&gt;<i> gridCol.TreeViewColumn = null;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> gridColumns.Clear ();
</I>&gt;<i> gridColumns = null;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public TreeIter NewRow ()
</I>&gt;<i> {
</I>&gt;<i> return store.Append();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public void AddRow (object[] columnValues)
</I>&gt;<i> {
</I>&gt;<i> TreeIter iter = NewRow ();
</I>&gt;<i> for(int col = 0; col &lt; columnValues.Length; col++) {
</I>&gt;<i> string cellValue = columnValues[col].ToString ();
</I>&gt;<i> SetColumnValue (iter, col, cellValue);
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public void SetColumnValue (TreeIter iter, int column, string value)
</I>&gt;<i> {
</I>&gt;<i> GLib.Value cell = new GLib.Value (value);
</I>&gt;<i> store.SetValue (iter, column, cell);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public void SetColumnValue (TreeIter iter, int column, byte[] value)
</I>&gt;<i> {
</I>&gt;<i> //string svalue = SqlSharpGtk.GetHexString (value);
</I>&gt;<i> //SetColumnValue (iter, column, svalue);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> private void AutoCreateTreeViewColumns ()
</I>&gt;<i> {
</I>&gt;<i> for(int col = 0; col &lt; gridColumns.Count; col++) {
</I>&gt;<i> // escape underscore _ because it is used
</I>&gt;<i> // as the underline in menus and labels
</I>&gt;<i> StringBuilder name = new StringBuilder ();
</I>&gt;<i> foreach (char ch in ((DataGridColumn) gridColumns[col]).ColumnName) {
</I>&gt;<i> if (ch == '_')
</I>&gt;<i> name.Append (&quot;__&quot;);
</I>&gt;<i> else
</I>&gt;<i> name.Append (ch);
</I>&gt;<i> }
</I>&gt;<i> TreeViewColumn tvc = CreateColumn (col, name.ToString ());
</I>&gt;<i> AppendColumn (tvc);
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public int AppendColumn(TreeViewColumn tvc)
</I>&gt;<i> {
</I>&gt;<i> return treeView.AppendColumn (tvc);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> private void TextCellEdited (object o, EditedArgs args)
</I>&gt;<i> {
</I>&gt;<i> IBindingList b = (IBindingList) resolvedDataSource;
</I>&gt;<i> if (b.AllowEdit) {
</I>&gt;<i> // ITypedList may help you figure out how to convert
</I>&gt;<i> // between different data types
</I>&gt;<i> // such as, how to display numbers, dates, etc...
</I>&gt;<i>
</I>&gt;<i> TreePath path = new TreePath (args.Path);
</I>&gt;<i> TreeIter iter;
</I>&gt;<i> store.GetIter (out iter, path);
</I>&gt;<i> int i = path.Indices[0];
</I>&gt;<i>
</I>&gt;<i> TreePath cpath;
</I>&gt;<i> string cellValue = args.NewText;
</I>&gt;<i>
</I>&gt;<i> TreeViewColumn tvcolumn;
</I>&gt;<i> treeView.GetCursor (out cpath, out tvcolumn);
</I>&gt;<i> int c = 0;
</I>&gt;<i> for(c = 0; c &lt; gridColumns.Count; c++) {
</I>&gt;<i> TreeViewColumn tvc = ((DataGridColumn) gridColumns[c]).TreeViewColumn;
</I>&gt;<i> if (tvcolumn == tvc) {
</I>&gt;<i> Console.Error.WriteLine(&quot;Column clicked:  Column Name: &quot; +
</I>&gt;<i> tvcolumn.Title);
</I>&gt;<i> Console.Error.WriteLine(&quot;     Ordinal: &quot; + c.ToString());
</I>&gt;<i> break;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> if (c &gt;= gridColumns.Count)
</I>&gt;<i> Console.Error.WriteLine(&quot;tv col not found&quot;);
</I>&gt;<i>
</I>&gt;<i> ICustomTypeDescriptor custom = (ICustomTypeDescriptor) bindrows[i];
</I>&gt;<i> PropertyDescriptorCollection properties = custom.GetProperties ();
</I>&gt;<i> PropertyDescriptor pd = properties[c];
</I>&gt;<i> pd.SetValue(bindrows[i], cellValue);
</I>&gt;<i>
</I>&gt;<i> Console.Error.WriteLine(&quot;    Row number: &quot; + path.Indices[0].ToString());
</I>&gt;<i> Console.Error.WriteLine(&quot;    Cell Value: &quot; + cellValue);
</I>&gt;<i>
</I>&gt;<i> ((IEditableObject) bindrows[i]).BeginEdit();
</I>&gt;<i> SetColumnValue(iter, c, cellValue);
</I>&gt;<i> ((IEditableObject) bindrows[i]).EndEdit();
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public TreeViewColumn CreateColumn (int columnNum, string columnName)
</I>&gt;<i> {
</I>&gt;<i> TreeViewColumn treeViewCol = new TreeViewColumn ();
</I>&gt;<i> CellRendererText renderer = new CellRendererText ();
</I>&gt;<i> treeViewCol.Clickable = true;
</I>&gt;<i> treeView.RulesHint = true;
</I>&gt;<i>
</I>&gt;<i> treeView.Selection.Mode = SelectionMode.Single;
</I>&gt;<i> //treeView.Selection.Mode = SelectionMode.Multiple;
</I>&gt;<i>
</I>&gt;<i> // Editable, Activatable, Inert
</I>&gt;<i> renderer.Mode = CellRendererMode.Editable;
</I>&gt;<i> //renderer.Family = &quot;courier new&quot;;
</I>&gt;<i> renderer.Editable = true;
</I>&gt;<i> renderer.Edited += new EditedHandler (TextCellEdited);
</I>&gt;<i> treeViewCol.Title = columnName;
</I>&gt;<i> treeViewCol.PackStart (renderer, true);
</I>&gt;<i> treeViewCol.AddAttribute (renderer, &quot;text&quot;, columnNum);
</I>&gt;<i>
</I>&gt;<i> DataGridColumn gridCol = (DataGridColumn) gridColumns[columnNum];
</I>&gt;<i> gridCol.Renderer = renderer;
</I>&gt;<i> gridCol.TreeViewColumn = treeViewCol;
</I>&gt;<i>
</I>&gt;<i> return treeViewCol;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>

--------------------------------------------------------------------------------


&gt;<i> // $ mcs /out:TestDataGrid.exe TestDataGrid.cs
</I>&gt;<i> DataGrid.cs -pkg:gtk-sharp-2.0 /r:System.Data.dll
</I>&gt;<i> // TestDataGrid.cs
</I>&gt;<i> namespace Mono.Data.GtkSharp
</I>&gt;<i> {
</I>&gt;<i> using System;
</I>&gt;<i> using System.Collections;
</I>&gt;<i> using System.Collections.Specialized;
</I>&gt;<i> using System.Configuration;
</I>&gt;<i> using System.Data;
</I>&gt;<i> using System.Data.Common;
</I>&gt;<i> using System.Data.SqlTypes;
</I>&gt;<i> using System.Text;
</I>&gt;<i> using System.IO;
</I>&gt;<i> using System.Reflection;
</I>&gt;<i> using System.Runtime.Remoting;
</I>&gt;<i> using System.Runtime.InteropServices;
</I>&gt;<i> using System.Diagnostics;
</I>&gt;<i>
</I>&gt;<i> using Gdk;
</I>&gt;<i> using Gtk;
</I>&gt;<i>
</I>&gt;<i> public class TestDataGrid
</I>&gt;<i> {
</I>&gt;<i> private DataTable table;
</I>&gt;<i> private Gtk.Window win;
</I>&gt;<i> private DataGrid grid;
</I>&gt;<i> //private TextView textView;
</I>&gt;<i>
</I>&gt;<i> public static readonly string ApplicationName = &quot;Gtk# DataGrid Test&quot;;
</I>&gt;<i>
</I>&gt;<i> public TestDataGrid ()
</I>&gt;<i> {
</I>&gt;<i> CreateGui ();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public DataGrid Grid {
</I>&gt;<i> get {
</I>&gt;<i> return grid;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public void Show ()
</I>&gt;<i> {
</I>&gt;<i> win.ShowAll ();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public void CreateGui ()
</I>&gt;<i> {
</I>&gt;<i> win = new Gtk.Window (ApplicationName);
</I>&gt;<i> win.DeleteEvent += new Gtk.DeleteEventHandler (OnWindow_Delete);
</I>&gt;<i> win.BorderWidth = 4;
</I>&gt;<i> win.SetDefaultSize (600, 500);
</I>&gt;<i>
</I>&gt;<i> VBox vbox = new VBox (false, 4);
</I>&gt;<i> win.Add (vbox);
</I>&gt;<i>
</I>&gt;<i> MenuBar mb = CreateMenuBar ();
</I>&gt;<i> vbox.PackStart (mb, false, false, 0);
</I>&gt;<i>
</I>&gt;<i> VPaned vpaned = new VPaned ();
</I>&gt;<i> vbox.PackStart (vpaned, true, true, 0);
</I>&gt;<i> grid = CreateOutputResultsDataGrid();
</I>&gt;<i> vpaned.Add1 (grid);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> DataGrid CreateOutputResultsDataGrid ()
</I>&gt;<i> {
</I>&gt;<i> DataGrid grid = new DataGrid ();
</I>&gt;<i>
</I>&gt;<i> //grid.View.ButtonReleaseEvent +=
</I>&gt;<i> // new Gtk.ButtonReleaseEventHandler (OnDataGridButtonRelease);
</I>&gt;<i> //grid.Editable = false;
</I>&gt;<i>
</I>&gt;<i> return grid;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void OnWindow_Delete (object o, Gtk.DeleteEventArgs args)
</I>&gt;<i> {
</I>&gt;<i> QuitApplication();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void QuitApplication ()
</I>&gt;<i> {
</I>&gt;<i> Application.Quit ();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public static void DoEvents ()
</I>&gt;<i> {
</I>&gt;<i> while (Application.EventsPending ())
</I>&gt;<i> Application.RunIteration ();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public DataTable BuildDataTableSample()
</I>&gt;<i> {
</I>&gt;<i> table = new DataTable();
</I>&gt;<i>
</I>&gt;<i> int maxColumns = 5;
</I>&gt;<i> int maxRows = 3;
</I>&gt;<i>
</I>&gt;<i> for(int i = 0; i &lt; maxColumns; i++) {
</I>&gt;<i> string columnName = String.Format(&quot;Column{0}&quot;, i);
</I>&gt;<i> table.Columns.Add(columnName);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> for(int r = 0; r &lt; maxRows; r++) {
</I>&gt;<i> DataRow row = table.NewRow();
</I>&gt;<i> for(int c = 0; c &lt; table.Columns.Count; c++) {
</I>&gt;<i> string cellValue = String.Format(&quot;(Row{0},Column{1})&quot;, r, c);
</I>&gt;<i> row[c] = cellValue;
</I>&gt;<i> }
</I>&gt;<i> table.Rows.Add(row);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> return table;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void OnMenu_DumpTable (object o, EventArgs args)
</I>&gt;<i> {
</I>&gt;<i> Console.Error.WriteLine(&quot;__===========  T a b l e     D u m p
</I>&gt;<i> =========__&quot;);
</I>&gt;<i> Console.Error.WriteLine(&quot;Row Count: &quot; + table.Rows.Count.ToString());
</I>&gt;<i> for(int r = 0; r &lt; table.Rows.Count; r++) {
</I>&gt;<i> DataRow row = table.Rows[r];
</I>&gt;<i> StringBuilder sb = new StringBuilder();
</I>&gt;<i> for(int c = 0; c &lt; table.Columns.Count; c++) {
</I>&gt;<i> string s = row[c].ToString();
</I>&gt;<i> sb.Append(s);
</I>&gt;<i> sb.Append(&quot; &quot;);
</I>&gt;<i> }
</I>&gt;<i> Console.Error.WriteLine(sb.ToString());
</I>&gt;<i> }
</I>&gt;<i> Console.Error.WriteLine(&quot;=-----------------------------------------------=&quot;);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void OnMenu_Editable (object o, EventArgs args)
</I>&gt;<i> {
</I>&gt;<i> grid.Editable = !grid.Editable;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void OnMenu_AddNew (object o, EventArgs args)
</I>&gt;<i> {
</I>&gt;<i> AddNew();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void OnMenu_DeleteSelectedRow (object o, EventArgs args)
</I>&gt;<i> {
</I>&gt;<i> int selectedRow = 0;
</I>&gt;<i> selectedRow = grid.SelectedRow;
</I>&gt;<i> if (selectedRow &gt;= 0)
</I>&gt;<i> grid.DeleteRow (selectedRow);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> void AddNew()
</I>&gt;<i> {
</I>&gt;<i> grid.AddNew();
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public MenuBar CreateMenuBar () {
</I>&gt;<i> MenuBar menuBar = new MenuBar ();
</I>&gt;<i> Menu menu;
</I>&gt;<i> MenuItem item;
</I>&gt;<i> MenuItem barItem;
</I>&gt;<i>
</I>&gt;<i> menu = new Menu ();
</I>&gt;<i>
</I>&gt;<i> item = new MenuItem (&quot;Add Row&quot;);
</I>&gt;<i> item.Activated += new EventHandler (OnMenu_AddNew);
</I>&gt;<i> menu.Append (item);
</I>&gt;<i>
</I>&gt;<i> item = new MenuItem (&quot;Dump Table&quot;);
</I>&gt;<i> item.Activated += new EventHandler (OnMenu_DumpTable);
</I>&gt;<i> menu.Append (item);
</I>&gt;<i>
</I>&gt;<i> item = new MenuItem (&quot;Editable&quot;);
</I>&gt;<i> item.Activated += new EventHandler (OnMenu_Editable);
</I>&gt;<i> menu.Append (item);
</I>&gt;<i>
</I>&gt;<i> item = new MenuItem (&quot;Delete Selected Row&quot;);
</I>&gt;<i> item.Activated += new EventHandler (OnMenu_DeleteSelectedRow);
</I>&gt;<i> menu.Append (item);
</I>&gt;<i>
</I>&gt;<i> barItem = new MenuItem (&quot;Test&quot;);
</I>&gt;<i> barItem.Submenu = menu;
</I>&gt;<i> menuBar.Append (barItem);
</I>&gt;<i>
</I>&gt;<i> return menuBar;
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> public static int Main (string[] args)
</I>&gt;<i> {
</I>&gt;<i> Application.Init ();
</I>&gt;<i> TestDataGrid test = new TestDataGrid ();
</I>&gt;<i> DataTable sampleTable = test.BuildDataTableSample();
</I>&gt;<i> test.Grid.DataSource = sampleTable;
</I>&gt;<i> test.Grid.DataBind();
</I>&gt;<i> test.Show ();
</I>&gt;<i> DoEvents ();
</I>&gt;<i> //test.Grid.Editable = false;
</I>&gt;<i> Application.Run ();
</I>&gt;<i> return 0;
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i>
</I>
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033212.html">[Mono-list] Learning ASP.NET?
</A></li>
	<LI>Next message: <A HREF="033199.html">[Mono-list] Building mono-basic from the sources
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33191">[ date ]</a>
              <a href="thread.html#33191">[ thread ]</a>
              <a href="subject.html#33191">[ subject ]</a>
              <a href="author.html#33191">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-list">More information about the Mono-list
mailing list</a><br>
</body></html>
