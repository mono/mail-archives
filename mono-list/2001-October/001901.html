<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Class library developers: locking issues to keep in mind
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:serge%40wildwestsoftware.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001900.html">
   <LINK REL="Next"  HREF="001905.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Class library developers: locking issues to keep in mind
   </H1>
    <B>Serge
    </B> 
    <A HREF="mailto:serge%40wildwestsoftware.com"
       TITLE="[Mono-list] Class library developers: locking issues to keep in mind">serge@wildwestsoftware.com
       </A><BR>
    <I>Sun, 28 Oct 2001 13:16:57 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="001900.html">[Mono-list] Class library developers: locking issues to keep in mind
</A></li>
        <LI> Next message: <A HREF="001905.html">[Mono-list] Class library developers: locking issues to keep in
 mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1901">[ date ]</a>
              <a href="thread.html#1901">[ thread ]</a>
              <a href="subject.html#1901">[ subject ]</a>
              <a href="author.html#1901">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.

------=_NextPart_000_0050_01C15FB2.D21B33A0
Content-Type: text/plain;
	charset=&quot;ISO-8859-1&quot;
Content-Transfer-Encoding: 7bit

The main problem with DCL for static singleton initialization is that caller
may get reference to partially initialized object - some_object may be
non-null, _before_  SomeObject ctor is finished. This is because JIT can
reorder instructions to write object address before executing constructor's
body (or maybe I'm wrong here?).

However, runtime has some means to deal with delayed initialization.
Note that we're talking only about _static_ properties here (perhaps,
volatile prefix will help with instance fields?)
If beforefieldinit flag is omited from type signature, then cctor will be
called only at the first access to type's static field or at invoking static
method of the class. This is similar to Java semantics for static field
initialization. And cctor is called only once.

However, I have no idea how to force C# compiler to generate such signatures
or prefixes.
I'm attaching IL source code to demonstrate how beforefieldinit influences
when the type constructor is invoked (try to uncomment beforefield init to
see the difference).



----- Original Message -----
From: &quot;Alexander Klyubin&quot; &lt;<A HREF="mailto:klyubin@aqris.com">klyubin@aqris.com</A>&gt;
To: &lt;<A HREF="mailto:mono-list@ximian.com">mono-list@ximian.com</A>&gt;
Sent: Sunday, October 28, 2001 12:20 PM
Subject: Re: [Mono-list] Class library developers: locking issues to keep in
mind


&gt;<i> I don't know that much about .NET memory model as of Java's one, but in
</I>&gt;<i> Java the code with on-demand locking you provided is called
</I>&gt;<i> Double-checked Locking (DCL). The problem with it is that it is not
</I>&gt;<i> guaranteed to work in all JVMs as synchronizing memory thread's own
</I>&gt;<i> local memory with shared main memory accessible to all threads can work
</I>&gt;<i> differently in different JVMs. Maybe memory model is organized
</I>&gt;<i> differently in .NET languages compared to Java. But as similarity
</I>&gt;<i> between C# and Java is realy big, I suspect memory model should be quite
</I>&gt;<i> similar if not the same.
</I>&gt;<i>
</I>&gt;<i> Here are good articles on this topic for Java. You migh also want to
</I>&gt;<i> find out more by simply searching JavaWorld (www.javaworld.com) for
</I>&gt;<i> &quot;DCL&quot;. But these two are the core ones to understand the problem:
</I>&gt;<i>
</I>&gt;<i> 1. Double-checked locking: Clever, but broken
</I>&gt;<i> <A HREF="http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html">http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html</A>
</I>&gt;<i>
</I>&gt;<i> 2. Can double-checked locking be fixed?
</I>&gt;<i> <A HREF="http://www.javaworld.com/javaworld/jw-05-2001/jw-0525-double.html">http://www.javaworld.com/javaworld/jw-05-2001/jw-0525-double.html</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Regards,
</I>&gt;<i> Alexander Klyubin
</I>&gt;<i>
</I>&gt;<i> Miguel de Icaza wrote:
</I>&gt;<i>
</I>&gt;<i> &gt;    I noticed today that I have been writing thread-unsafe code in my
</I>&gt;<i> &gt; code that goes into the class libraries.  Some classes for example
</I>&gt;<i> &gt; provide static properties, and to avoid a costly initialization at
</I>&gt;<i> &gt; bootstrap time, you want to create some of those values on demand
</I>&gt;<i> &gt; instead of doing it constructor, like this:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    class Sample {
</I>&gt;<i> &gt; static SomeObject MyProperty {
</I>&gt;<i> &gt; get {
</I>&gt;<i> &gt; if (some_object == null)
</I>&gt;<i> &gt; some_object = new SomeObject ();
</I>&gt;<i> &gt; return some_object;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;    }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    Well, it turns out that the code above is not thread safe, because
</I>&gt;<i> &gt; two threads might be hitting the same spot at the same time and two
</I>&gt;<i> &gt; copies of SomeObject would be created.  Then later on, comparissions
</I>&gt;<i> &gt; would not work (if p == MyProperty).  To correct that situation, you
</I>&gt;<i> &gt; have to lock on either the instance (this) or the class (typeof (this)),
</I>&gt;<i> &gt; like this:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;     class Sample {
</I>&gt;<i> &gt; static SomeObject MyProperty {
</I>&gt;<i> &gt; get {
</I>&gt;<i> &gt; if (some_object != null)
</I>&gt;<i> &gt; return some_object;
</I>&gt;<i> &gt; lock (typeof (Sample)){
</I>&gt;<i> &gt; if (some_object == null)
</I>&gt;<i> &gt; some_object = new SomeObject ();
</I>&gt;<i> &gt; return some_object;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt;     }
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    Notice that you first test for initialization: if it is not null, you
</I>&gt;<i> &gt; can return the value without ever locking.  You only lock (which is an
</I>&gt;<i> &gt; expensive operation) if the value needs to be computed.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;    Now, notice how we test for the value *inside* the lock.  This is
</I>&gt;<i> &gt; important because the value might have been initialized in a separate
</I>&gt;<i> &gt; thread before we reach lock.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; Miguel.
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Mono-list maillist  -  <A HREF="mailto:Mono-list@ximian.com">Mono-list@ximian.com</A>
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@ximian.com">Mono-list@ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i>
</I>




------=_NextPart_000_0050_01C15FB2.D21B33A0
Content-Type: application/octet-stream;
	name=&quot;Memtest.il&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
	filename=&quot;Memtest.il&quot;

.assembly memtest {}

.class public auto ansi sealed /*beforefieldinit*/ Singleton {

	.field public static initonly object Instance
	.field public static initonly int32 Num


	.method private hidebysig specialname rtspecialname static
       	void .cctor() cil managed /*synchronized*/
	{
		newobj instance void [mscorlib]System.Object::.ctor()
		stsfld object Singleton::Instance

		ldc.i4 0xACDC
		stsfld int32 Singleton::Num

		ldstr &quot;Static init!&quot;
		call void [mscorlib]System.Console::WriteLine(string)
		ret
	}


}



.class public auto ansi sealed beforefieldinit Test {

	.method static public void Main() il managed {
		.entrypoint

		ldstr &quot;Started...&quot;
		call void [mscorlib]System.Console::WriteLine(string)

		ldsfld object Singleton::Instance
		pop

		ldsfld object Singleton::Instance
		pop

		ret
	}

}

------=_NextPart_000_0050_01C15FB2.D21B33A0--



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001900.html">[Mono-list] Class library developers: locking issues to keep in mind
</A></li>
	<LI> Next message: <A HREF="001905.html">[Mono-list] Class library developers: locking issues to keep in
 mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1901">[ date ]</a>
              <a href="thread.html#1901">[ thread ]</a>
              <a href="subject.html#1901">[ subject ]</a>
              <a href="author.html#1901">[ author ]</a>
         </LI>
       </UL>
</body></html>
