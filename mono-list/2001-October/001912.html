<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Class library developers: locking issues to keep in	mind
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:klyubin%40aqris.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001909.html">
   <LINK REL="Next"  HREF="001913.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Class library developers: locking issues to keep in	mind
   </H1>
    <B>Alexander Klyubin
    </B> 
    <A HREF="mailto:klyubin%40aqris.com"
       TITLE="[Mono-list] Class library developers: locking issues to keep in	mind">klyubin@aqris.com
       </A><BR>
    <I>Mon, 29 Oct 2001 08:23:44 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="001909.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
        <LI> Next message: <A HREF="001913.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1912">[ date ]</a>
              <a href="thread.html#1912">[ thread ]</a>
              <a href="subject.html#1912">[ subject ]</a>
              <a href="author.html#1912">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Clever, but broken :)

Step by step (once again from Java point of view):
1. Classloading ensures that static initializer is called only once and 
no thread can access the class before it it initialized. Hence, every 
thread has initializer poiting to RealInit at first.
2. One thread (A) executes RealInit, making initializer point to 
DummyInit and singleton to Singleton instance in SHARED MEMORY. Local 
copies of other threads need not yet point to DummyInit as they have not 
executed any read barrier on this initializer field. So, depending on 
JVM implementations other threads can in principle keep on having 
initializer point to RealInit and singleton to null until RealInit for 
that thread is called.

Flaw #1: Now, the order in which JVM sends updates from local memory to 
shared mememory is arbitrary. So, when thread A sends its updates of 
initializer and singleton to shared memory, they can arrive in different 
order. Let's say, first initializer, then singleton. In this case, some 
other thread might execute following code:

public static object GetHeavyObject() {
   DummyInit();
   return singleton; // local copy of singleton still null
}

This is because no read barrier is done in GetHeavyObject to ensure that 
both initializer and singleton have been loaded from shared memory to 
thread local memory.

Flaw #2: Assuming that initializer points to DummyInit, singleton may 
still point not to null but to a incompletely initialized instance of 
Singleton instance.

Flaw #3: A minor one. The order of sending updated to shared memory 
might be vice versa: first singleton, then initializer. In that case, 
RealInit might be executed several times for one thread, because 
initializer is not always changed to DummyInit inside RealInit. If 
singleton is not null, initializer will still keep on poiting to ReadInit.

Regards,
Alexander Klyubin

Serge wrote:

&gt;&gt;<i>making reference volatile does not save you from the situation
</I>&gt;&gt;<i>when the reference is OK, but the object it points to has not been
</I>&gt;&gt;<i>completely initialized
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> That's right, it wont help. This is true for both UP and MP machines.
</I>&gt;<i> As long as constructor inlining is a valid optimization for JIT (and I
</I>&gt;<i> suppose it is).
</I>&gt;<i> I guess, it is possible to fix this by disabling inlining using
</I>&gt;<i> MethodImplAttribute:
</I>&gt;<i> 
</I>&gt;<i>    [MethodImplAttribute(MethodImplOptions.NoInlining)]
</I>&gt;<i>    private static MyObject Create () {
</I>&gt;<i>         return new MyObject ();
</I>&gt;<i>    }
</I>&gt;<i> 
</I>&gt;<i> then
</I>&gt;<i> 
</I>&gt;<i>  get {
</I>&gt;<i>     if (obj != null) return obj;
</I>&gt;<i>       lock (typeof (X)) {
</I>&gt;<i>          if (obj == null) obj = Create ();
</I>&gt;<i>          return obj;
</I>&gt;<i>       }
</I>&gt;<i>  }
</I>&gt;<i> 
</I>&gt;<i> This won't solve SMP issues though,
</I>&gt;<i> one way is to use Threading.Interlocked methods and have an additional int
</I>&gt;<i> to flag object initialization. Using TLS is another way (but I don't think
</I>&gt;<i> this is faster than mere synchronization).
</I>&gt;<i> 
</I>&gt;<i> However, I have an idea for DCL replacement.
</I>&gt;<i> Why not use function pointers (or delegates) to replace the original
</I>&gt;<i> (locked) initializer after its first execution with empty non-synched
</I>&gt;<i> method?
</I>&gt;<i> See attached sources (OneShot.il/cs) - IL code uses raw function pointers
</I>&gt;<i> and C# version uses delegates, but I think this should work for Java too
</I>&gt;<i> with two object references (for example two Runnable objects).
</I>&gt;<i> This pattern can be applied to both static and instance fields.
</I>&gt;<i> 
</I>&gt;<i> Have fun,
</I>&gt;<i> Sergey
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001909.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
	<LI> Next message: <A HREF="001913.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1912">[ date ]</a>
              <a href="thread.html#1912">[ thread ]</a>
              <a href="subject.html#1912">[ subject ]</a>
              <a href="author.html#1912">[ author ]</a>
         </LI>
       </UL>
</body></html>
