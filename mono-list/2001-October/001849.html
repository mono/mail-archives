<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] today's patch
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:ravi%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001852.html">
   <LINK REL="Next"  HREF="001853.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] today's patch
   </H1>
    <B>Ravi Pratap M
    </B> 
    <A HREF="mailto:ravi%40ximian.com"
       TITLE="[Mono-list] today's patch">ravi@ximian.com
       </A><BR>
    <I>Sun, 21 Oct 2001 19:43:40 +0530</I>
    <P><UL>
        <LI> Previous message: <A HREF="001852.html">[Mono-list] python scripting
</A></li>
        <LI> Next message: <A HREF="001853.html">[Mono-list] today's patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1849">[ date ]</a>
              <a href="thread.html#1849">[ thread ]</a>
              <a href="subject.html#1849">[ subject ]</a>
              <a href="author.html#1849">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.

------=_NextPart_000_0007_01C15A68.AF5FBBF0
Content-Type: text/plain;
	charset=&quot;iso-8859-1&quot;
Content-Transfer-Encoding: 7bit

Hey Miguel,

    So here's some work I did today. I wrote the tests for implicit and
explicit reference conversions and accordingly re-wrote the code as using
IsAssignableFrom turned out to be wrong. It just wasn't working the way it
was supposed to be.

    Anyway, all tests pass now. Since we don't have arrays done yet, I
haven't written tests for array conversions.

    There are however two cases in explicit conversions which are supposed
to work according to the spec but don't  : they cause an
InvalidCastException :-)

    I am still trying to figure that out. Just see test-27.cs and see if you
can help me there :)

    That's it for now. Will continue working on attributes :-)

    Regards,

                    Ravi


------=_NextPart_000_0007_01C15A68.AF5FBBF0
Content-Type: application/octet-stream;
	name=&quot;mcs-oct-21&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename=&quot;mcs-oct-21&quot;

? mcs.pdb=0A=
Index: ChangeLog=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/ChangeLog,v=0A=
retrieving revision 1.140=0A=
diff -u -r1.140 ChangeLog=0A=
--- ChangeLog	2001/10/20 21:22:56	1.140=0A=
+++ ChangeLog	2001/10/21 10:09:36=0A=
@@ -1,3 +1,25 @@=0A=
+2001-10-21  Ravi Pratap  &lt;<A HREF="mailto:ravi@ximian.com">ravi@ximian.com</A>&gt;=0A=
+=0A=
+	* interface.cs (FindMembers): Implement to work around S.R.E=0A=
+	lameness.=0A=
+=0A=
+	* typemanager.cs (IsInterfaceType): Implement.=0A=
+=0A=
+	(FindMembers): Update to handle interface types too.=0A=
+=0A=
+	* expression.cs (ImplicitReferenceConversion): Re-write bits which=0A=
+	use IsAssignableFrom as that is not correct - it doesn't work.=0A=
+=0A=
+	* delegate.cs (DelegateInvocation): Derive from ExpressionStatement=0A=
+	and accordinly override EmitStatement.=0A=
+=0A=
+	* expression.cs (ConvertReferenceExplicit): Re-write similary, this =
time=0A=
+	using the correct logic :-)=0A=
+=0A=
+2001-10-19  Ravi Pratap  &lt;<A HREF="mailto:ravi@ximian.com">ravi@ximian.com</A>&gt;=0A=
+=0A=
+	* ../errors/cs-11.cs : Add to demonstrate error -11 =0A=
+=0A=
 2001-10-17  Miguel de Icaza  &lt;<A HREF="mailto:miguel@ximian.com">miguel@ximian.com</A>&gt;=0A=
 =0A=
 	* assign.cs (Assign::Resolve): Resolve right hand side first, and=0A=
Index: class.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/class.cs,v=0A=
retrieving revision 1.78=0A=
diff -u -r1.78 class.cs=0A=
--- class.cs	2001/10/17 09:25:26	1.78=0A=
+++ class.cs	2001/10/21 10:09:44=0A=
@@ -1817,7 +1817,8 @@=0A=
 				ec.TypeContainer.TypeBuilder.BaseType, &quot;.ctor&quot;, false,=0A=
 				MemberTypes.Constructor,=0A=
 				BindingFlags.Public | BindingFlags.Instance, location);=0A=
-=0A=
+			=0A=
+			//Console.WriteLine (&quot;Base type : &quot; + =
ec.TypeContainer.TypeBuilder.BaseType);=0A=
 			if (parent_constructor_group =3D=3D null){=0A=
 				Console.WriteLine (&quot;Could not find a constructor in our parent&quot;);=0A=
 				return false;=0A=
Index: delegate.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/delegate.cs,v=0A=
retrieving revision 1.10=0A=
diff -u -r1.10 delegate.cs=0A=
--- delegate.cs	2001/10/18 12:34:51	1.10=0A=
+++ delegate.cs	2001/10/21 10:09:44=0A=
@@ -439,7 +439,7 @@=0A=
 		}
 	}
=20
-	public class DelegateInvocation : Expression {
+	public class DelegateInvocation : ExpressionStatement {
=20
 		public Expression InstanceExpr;
 		public ArrayList  Arguments;
@@ -489,6 +489,18 @@=0A=
 		{
 			Delegate del =3D TypeManager.LookupDelegate (InstanceExpr.Type);
 			Invocation.EmitCall (ec, del.TargetMethod.IsStatic, InstanceExpr, =
method, Arguments);
+		}
+
+		public override void EmitStatement (EmitContext ec)
+		{
+			Emit (ec);
+			//=20
+			// Pop the return value if there is one
+			//
+			if (method is MethodInfo){
+				if (((MethodInfo) method).ReturnType !=3D TypeManager.void_type)
+					ec.ig.Emit (OpCodes.Pop);
+			}
 		}
=20
 	}
Index: expression.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/expression.cs,v=0A=
retrieving revision 1.90=0A=
diff -u -r1.90 expression.cs=0A=
--- expression.cs	2001/10/20 21:47:40	1.90=0A=
+++ expression.cs	2001/10/21 10:09:56=0A=
@@ -386,18 +386,31 @@=0A=
 			} else {=0A=
 				// from any class-type S to any interface-type T.=0A=
 				if (expr_type.IsClass &amp;&amp; target_type.IsInterface) {=0A=
-					Type [] interfaces =3D expr_type.FindInterfaces =
(Module.FilterTypeName,=0A=
-										       target_type.FullName);=0A=
-					if (interfaces !=3D null)=0A=
-						return new EmptyCast (expr, target_type);=0A=
-				}	=0A=
+=0A=
+					Type [] ifaces =3D expr_type.GetInterfaces ();=0A=
+=0A=
+					for (int i =3D ifaces.Length; i &gt; 0;) {=0A=
+						i--;=0A=
+						if (ifaces [i] =3D=3D target_type)=0A=
+							return new EmptyCast (expr, target_type);=0A=
+					}=0A=
+=0A=
+					return null;=0A=
+				}=0A=
 =0A=
 				// from any interface type S to interface-type T.=0A=
-				// FIXME : Is it right to use IsAssignableFrom ?=0A=
-				if (expr_type.IsInterface &amp;&amp; target_type.IsInterface)=0A=
-					if (target_type.IsAssignableFrom (expr_type))=0A=
-						return new EmptyCast (expr, target_type);=0A=
-				=0A=
+				if (expr_type.IsInterface &amp;&amp; target_type.IsInterface) {=0A=
+=0A=
+					Type [] ifaces =3D expr_type.GetInterfaces ();=0A=
+=0A=
+					for (int i =3D ifaces.Length; i &gt; 0;) {=0A=
+						i--;=0A=
+						if (ifaces [i] =3D=3D target_type)=0A=
+							return new EmptyCast (expr, target_type);=0A=
+					}=0A=
+=0A=
+					return null;=0A=
+				}=0A=
 				=0A=
 				// from an array-type S to an array-type of type T=0A=
 				if (expr_type.IsArray &amp;&amp; target_type.IsArray) {=0A=
@@ -415,14 +428,13 @@=0A=
 				=0A=
 				=0A=
 				// from an array-type to System.Array=0A=
-				if (expr_type.IsArray &amp;&amp; target_type.IsAssignableFrom (expr_type))=0A=
+				if (expr_type.IsArray &amp;&amp; target_type =3D=3D TypeManager.array_type)=0A=
 					return new EmptyCast (expr, target_type);=0A=
 				=0A=
 				// from any delegate type to System.Delegate=0A=
 				if (expr_type.IsSubclassOf (TypeManager.delegate_type) &amp;&amp;=0A=
 				    target_type =3D=3D TypeManager.delegate_type)=0A=
-					if (target_type.IsAssignableFrom (expr_type))=0A=
-						return new EmptyCast (expr, target_type);=0A=
+					return new EmptyCast (expr, target_type);=0A=
 					=0A=
 				// from any array-type or delegate type into System.ICloneable.=0A=
 				if (expr_type.IsArray || expr_type.IsSubclassOf =
(TypeManager.delegate_type))=0A=
@@ -1459,26 +1471,58 @@=0A=
 			// From any interface type S to any interface T provided S is not =
derived from T=0A=
 			//=0A=
 			if (source_type.IsInterface &amp;&amp; target_type.IsInterface){=0A=
-				if (!target_type.IsSubclassOf (source_type))=0A=
-					return new ClassCast (source, target_type);=0A=
+=0A=
+				Type [] ifaces =3D source_type.GetInterfaces ();=0A=
+=0A=
+				for (int i =3D ifaces.Length; i &gt; 0; ) {=0A=
+					i--;=0A=
+=0A=
+					if (ifaces [i] =3D=3D target_type)=0A=
+						return null;=0A=
+				}	=0A=
+				=0A=
+				return new ClassCast (source, target_type);=0A=
 			}=0A=
 			    =0A=
 			//=0A=
 			// From any class type S to any interface T, provides S is not sealed=0A=
 			// and provided S does not implement T.=0A=
 			//=0A=
-			if (target_type.IsInterface &amp;&amp; !source_type.IsSealed &amp;&amp;=0A=
-			    !target_type.IsAssignableFrom (source_type))=0A=
+			if (target_type.IsInterface &amp;&amp; !source_type.IsSealed) {=0A=
+=0A=
+				Type [] ifaces =3D source_type.GetInterfaces ();=0A=
+				=0A=
+				for (int i =3D ifaces.Length; i &gt; 0; ) {=0A=
+					i--;=0A=
+					=0A=
+					if (ifaces [i] =3D=3D target_type)=0A=
+						return null;=0A=
+				}	=0A=
+				=0A=
 				return new ClassCast (source, target_type);=0A=
+			}=0A=
 =0A=
 			//=0A=
 			// From any interface-type S to to any class type T, provided T is =
not=0A=
 			// sealed, or provided T implements S.=0A=
 			//=0A=
-			if (source_type.IsInterface &amp;&amp;=0A=
-			    (!target_type.IsSealed || source_type.IsAssignableFrom =
(target_type)))=0A=
-				return new ClassCast (source, target_type);=0A=
+			if (source_type.IsInterface) {=0A=
 =0A=
+				if (target_type.IsSealed)=0A=
+					return null;=0A=
+				=0A=
+				Type [] ifaces =3D target_type.GetInterfaces ();=0A=
+				=0A=
+				for (int i =3D ifaces.Length; i &gt; 0; ) {=0A=
+					i--;=0A=
+					=0A=
+					if (ifaces [i] =3D=3D source_type)=0A=
+						return new ClassCast (source, target_type);=0A=
+				}	=0A=
+				=0A=
+				return null;=0A=
+			}=0A=
+			=0A=
 			// From an array type S with an element type Se to an array type T =
with an =0A=
 			// element type Te provided all the following are true:=0A=
 			//     * S and T differe only in element type, in other words, S and =
T=0A=
Index: interface.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/interface.cs,v=0A=
retrieving revision 1.15=0A=
diff -u -r1.15 interface.cs=0A=
--- interface.cs	2001/10/11 16:46:46	1.15=0A=
+++ interface.cs	2001/10/21 10:09:56=0A=
@@ -39,7 +39,9 @@=0A=
 		ArrayList defined_indexer;=0A=
 		ArrayList defined_events;=0A=
 		ArrayList defined_properties;=0A=
+=0A=
 		ArrayList method_builders;=0A=
+		ArrayList property_builders;=0A=
 		=0A=
 		TypeContainer parent;=0A=
 =0A=
@@ -71,6 +73,7 @@=0A=
 			RootContext =3D rc;=0A=
 			=0A=
 			method_builders =3D new ArrayList ();=0A=
+			property_builders =3D new ArrayList ();=0A=
 		}=0A=
 =0A=
 		public AdditionResult AddMethod (InterfaceMethod imethod)=0A=
@@ -242,6 +245,37 @@=0A=
 =0A=
 			return mi;=0A=
 		}=0A=
+=0A=
+		// Hack around System.Reflection as found everywhere else=0A=
+		public MemberInfo [] FindMembers (MemberTypes mt, BindingFlags bf, =
MemberFilter filter, object criteria)=0A=
+		{=0A=
+			ArrayList members =3D new ArrayList ();=0A=
+=0A=
+			if ((mt &amp; MemberTypes.Method) !=3D 0) {=0A=
+				foreach (MethodBuilder mb in method_builders)=0A=
+					if (filter (mb, criteria))=0A=
+						members.Add (mb);=0A=
+			}=0A=
+=0A=
+			if ((mt &amp; MemberTypes.Property) !=3D 0) {=0A=
+				foreach (PropertyBuilder pb in property_builders)=0A=
+				        if (filter (pb, criteria))=0A=
+				                members.Add (pb);=0A=
+			}=0A=
+=0A=
+			// The rest of the cases, if any, are unhandled at present.=0A=
+=0A=
+			int count =3D members.Count;=0A=
+=0A=
+			if (count &gt; 0) {=0A=
+				MemberInfo [] mi =3D new MemberInfo [count];=0A=
+				members.CopyTo (mi, 0);=0A=
+				return mi;=0A=
+			}=0A=
+=0A=
+			return null;=0A=
+		}=0A=
+		=0A=
 		=0A=
 		//=0A=
 		// Populates the methods in the interface=0A=
@@ -325,6 +359,8 @@=0A=
 				//=0A=
 				RegisterMethod (mb, setter_args);=0A=
 			}=0A=
+=0A=
+			property_builders.Add (pb);=0A=
 		}=0A=
 =0A=
 		//=0A=
Index: typemanager.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/typemanager.cs,v=0A=
retrieving revision 1.33=0A=
diff -u -r1.33 typemanager.cs=0A=
--- typemanager.cs	2001/10/20 21:22:56	1.33=0A=
+++ typemanager.cs	2001/10/21 10:09:56=0A=
@@ -322,6 +322,11 @@=0A=
 =0A=
 		if (IsDelegateType (t))=0A=
 		        return null;=0A=
+=0A=
+		Interface iface =3D (Interface) builder_to_interface [t];=0A=
+=0A=
+		if (iface !=3D null) =0A=
+		        return iface.FindMembers (mt, bf, filter, criteria);=0A=
 		=0A=
 		tc =3D (TypeContainer) builder_to_container [t];=0A=
 		=0A=
@@ -337,6 +342,16 @@=0A=
 		Delegate del =3D (Delegate) delegate_types [t];=0A=
 =0A=
 		if (del !=3D null)=0A=
+			return true;=0A=
+		else=0A=
+			return false;=0A=
+	}=0A=
+=0A=
+	public static bool IsInterfaceType (Type t)=0A=
+	{=0A=
+		Interface iface =3D (Interface) builder_to_interface [t];=0A=
+=0A=
+		if (iface !=3D null)=0A=
 			return true;=0A=
 		else=0A=
 			return false;=0A=

------=_NextPart_000_0007_01C15A68.AF5FBBF0--



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001852.html">[Mono-list] python scripting
</A></li>
	<LI> Next message: <A HREF="001853.html">[Mono-list] today's patch
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1849">[ date ]</a>
              <a href="thread.html#1849">[ thread ]</a>
              <a href="subject.html#1849">[ subject ]</a>
              <a href="author.html#1849">[ author ]</a>
         </LI>
       </UL>
</body></html>
