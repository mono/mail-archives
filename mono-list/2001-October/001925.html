<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Class library developers: locking issues to keep
 in	mind
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:miguel%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001917.html">
   <LINK REL="Next"  HREF="001958.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Class library developers: locking issues to keep
 in	mind
   </H1>
    <B>Miguel de Icaza
    </B> 
    <A HREF="mailto:miguel%40ximian.com"
       TITLE="[Mono-list] Class library developers: locking issues to keep
 in	mind">miguel@ximian.com
       </A><BR>
    <I>29 Oct 2001 11:56:21 -0500</I>
    <P><UL>
        <LI> Previous message: <A HREF="001917.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
        <LI> Next message: <A HREF="001958.html">[Mono-list] Class library developers: locking issues to keepin	mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1925">[ date ]</a>
              <a href="thread.html#1925">[ thread ]</a>
              <a href="subject.html#1925">[ subject ]</a>
              <a href="author.html#1925">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Sun, 2001-10-28 at 16:43, Alexander Klyubin wrote:
&gt;<i> Hm... As far as I remember how volatile works in Java, even making 
</I>&gt;<i> reference volatile does not save you from the situation when the 
</I>&gt;<i> reference is OK, but the object it points to has not been completely 
</I>&gt;<i> initialized from point of view of a thread where some code accesses the 
</I>&gt;<i> object using this reference... But I'm not 100% sure on this.
</I>
I think we are now talking about wildly different things here :-)

The problem was the double check, and the fact that a thread in a
different CPU might have assigned a value to the variable on a separate
thread, but the change is living in the other cpu's cache.

All of this is happening inside a *lock* statement.

So conceptually:

	lock (typeof (this)){
		if (val != 0)
			return;
		val = 1;
        }

The problem still exists there with integers.  

Migue


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001917.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
	<LI> Next message: <A HREF="001958.html">[Mono-list] Class library developers: locking issues to keepin	mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1925">[ date ]</a>
              <a href="thread.html#1925">[ thread ]</a>
              <a href="subject.html#1925">[ subject ]</a>
              <a href="author.html#1925">[ author ]</a>
         </LI>
       </UL>
</body></html>
