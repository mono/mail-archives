<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Class library developers: locking issues to keep in mind
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:klyubin%40aqris.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001913.html">
   <LINK REL="Next"  HREF="001916.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Class library developers: locking issues to keep in mind
   </H1>
    <B>Alexander Klyubin
    </B> 
    <A HREF="mailto:klyubin%40aqris.com"
       TITLE="[Mono-list] Class library developers: locking issues to keep in mind">klyubin@aqris.com
       </A><BR>
    <I>Mon, 29 Oct 2001 11:36:09 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="001913.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
        <LI> Next message: <A HREF="001916.html">[Mono-list] Class library developers: locking issues to keep in mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1914">[ date ]</a>
              <a href="thread.html#1914">[ thread ]</a>
              <a href="subject.html#1914">[ subject ]</a>
              <a href="author.html#1914">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Flaw #2:

I see your point about the lock and flushing of data from local copies 
of thread to shared main memory.
Consider following situation: &quot;initializer&quot; is flushed first to main 
memory. A thread executes GetHeavyObject. It already got initializer 
pointing to DummyInit from shared memory. Now, what happens is that this 
thread does NOT perform an explicit read barrier and hence may end up 
with incompletely initialized singleton instance. This is because the 
data of singleton instance may not yet been fully flushed to shared main 
memory.

What I don't understand, is whether JVM is allowed to load local copies 
from shared memory without explicit read barriers? This happens in 
GetHeavyObject method. You do not have an explicit memory barrier there. 
Anwering this might make the picture clearer and mark the preconditions 
to flaw #2 as impossible.

Flaw #3:

What I was saying is not that several instances of singleton will be 
created, but that thread will be executing in case singleton != null:

lock (typeof (Singleton)) {
   ++Count;
}

This is not that big an issue, but anyway.

Regards,
Alexander Klyubin

Serge wrote:

&gt;&gt;<i>Clever, but broken :)
</I>&gt;&gt;<i>
</I>&gt;<i> Well, let's try to repair ;-)
</I>&gt;<i> 
</I>&gt;<i> Let's use Java model, since NET's locking semantics are not clear at the
</I>&gt;<i> moment :)
</I>&gt;<i> Quotes are taken from Doug Lea's &quot;Concurrent Programmin in Java (2nd ed.)&quot;
</I>&gt;<i> chapter 2.2.7.2 pp 94-95, this chapter is also available online ([1]).
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>Flaw #1: Now, the order in which JVM sends updates from local memory to
</I>&gt;&gt;<i>shared mememory is arbitrary.
</I>&gt;&gt;<i>
</I>&gt;<i> That's right. Good point.
</I>&gt;<i> &quot;If a field is declared as volatile, any value written to it is flushed and
</I>&gt;<i> made visible by the writer thread before the writer thread performs any
</I>&gt;<i> further memory operation (i.e., for the purposes at hand it is flushed
</I>&gt;<i> immediately).&quot;
</I>&gt;<i> So declaring them volatile would help (but see below, flaw #2). And Miguel
</I>&gt;<i> confirmed that volatile has essentially the same semantics in .NET.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>Flaw #2: Assuming that initializer points to DummyInit, singleton may
</I>&gt;&gt;<i>still point not to null but to a incompletely initialized instance of
</I>&gt;&gt;<i>Singleton instance
</I>&gt;&gt;<i>
</I>&gt;<i> Nope, there are only two possibilities - either fully initialized singleton
</I>&gt;<i> or null. Instance is only created inside the fully synchronized method
</I>&gt;<i> (RealInit):
</I>&gt;<i> &quot;In essence, releasing a lock forces a flush of all writes from working
</I>&gt;<i> memory employed by the thread, and acquiring a lock forces a (re)load of the
</I>&gt;<i> values of accessible fields.&quot; But this is only in the case if &quot;writing
</I>&gt;<i> thread releases a synchronization lock and a reading thread subsequently
</I>&gt;<i> acquires that same synchronization lock&quot;, so you're right, due to
</I>&gt;<i> unspecified flushing sequence another thread that sees DummyInit, could see
</I>&gt;<i> (singleton == null) but never incompletely initialized singleton.
</I>&gt;<i> Volatile should help with that (changes are immediately visible).
</I>&gt;<i> Other possible fixes (in absence of volatile for example, or if volatile
</I>&gt;<i> doesn't guaranties immediate flushing):
</I>&gt;<i> 1) Add yet another check:
</I>&gt;<i>      public static object GetHeavyObject ()
</I>&gt;<i>      {
</I>&gt;<i>           // calling either RealInit or DummyInit
</I>&gt;<i>           initializer  ();
</I>&gt;<i> 
</I>&gt;<i>           // at this point singleton is either null
</I>&gt;<i>           // or fully initialized object
</I>&gt;<i> 
</I>&gt;<i>           // now check it again
</I>&gt;<i>           if (singleton == null) RealInit ();
</I>&gt;<i> 
</I>&gt;<i>           // if RealInit invoked here, then
</I>&gt;<i>           // all values will be reloaded.
</I>&gt;<i>           // That's because RealInit is fully-synched,
</I>&gt;<i>           // see quote for Flow 2
</I>&gt;<i> 
</I>&gt;<i>           return singleton;
</I>&gt;<i>      }
</I>&gt;<i> 
</I>&gt;<i> It is safe to call RealInit, because it is a) fully-synchronized b) contains
</I>&gt;<i> it's own check so singleton will be created only once in any case.
</I>&gt;<i> 
</I>&gt;<i> 2) Spawn yet another thread inside the RealInit, that will perform
</I>&gt;<i> initialization and exit. Then Join.
</I>&gt;<i> &quot;As a thread terminates, all written variables are flushed to main memory.&quot;
</I>&gt;<i> Of course, thread only spawned if (singleton == null)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>Flaw #3: A minor one. The order of sending updated to shared memory
</I>&gt;&gt;<i>might be vice versa: first singleton, then initializer. In that case,
</I>&gt;&gt;<i>RealInit might be executed several times for one thread, because
</I>&gt;&gt;<i>initializer is not always changed to DummyInit inside RealInit. If
</I>&gt;&gt;<i>singleton is not null, initializer will still keep on poiting to ReadInit.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> Nope, it will never execute more than once for one thread - RealInit is
</I>&gt;<i> entirely locked, if (sinleton == null) branch is only executed exactly one
</I>&gt;<i> in any case.
</I>&gt;<i> However, different thread(s) could enter RealInit before it's completed, it
</I>&gt;<i> will wait on method's lock held by the first thread. After the first thread
</I>&gt;<i> finishes executing RealInit and releases lock all changes are visible to the
</I>&gt;<i> second thread (see quote from Flow 2).
</I>&gt;<i> Actually, this one is the main problem. Theoretically, there could be
</I>&gt;<i> arbitrary number of thread waiting for RealInit lock. Those are the threads
</I>&gt;<i> started during the time RealInit's body is executed. This will work
</I>&gt;<i> correctly though - RealInit acts just like simple initializer with
</I>&gt;<i> serialized access (without DCL). But this will have performance impact of
</I>&gt;<i> course.
</I>&gt;<i> 
</I>&gt;<i> Anyhow, I think either volatile access or above two fixes should eliminate
</I>&gt;<i> any issues (sure, it's quite possible that I'm wrong :-)
</I>&gt;<i> 
</I>&gt;<i> Any thoughts?
</I>&gt;<i> 
</I>&gt;<i> Sergey
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> [1] <A HREF="http://gee.cs.oswego.edu/dl/cpj/jmm.html">http://gee.cs.oswego.edu/dl/cpj/jmm.html</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@ximian.com">Mono-list@ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i> 
</I>



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001913.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
	<LI> Next message: <A HREF="001916.html">[Mono-list] Class library developers: locking issues to keep in mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1914">[ date ]</a>
              <a href="thread.html#1914">[ thread ]</a>
              <a href="subject.html#1914">[ subject ]</a>
              <a href="author.html#1914">[ author ]</a>
         </LI>
       </UL>
</body></html>
