<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Class library developers: locking issues to keep in mind
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:serge%40wildwestsoftware.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001914.html">
   <LINK REL="Next"  HREF="001918.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Class library developers: locking issues to keep in mind
   </H1>
    <B>Serge
    </B> 
    <A HREF="mailto:serge%40wildwestsoftware.com"
       TITLE="[Mono-list] Class library developers: locking issues to keep in mind">serge@wildwestsoftware.com
       </A><BR>
    <I>Mon, 29 Oct 2001 12:44:03 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="001914.html">[Mono-list] Class library developers: locking issues to keep in mind
</A></li>
        <LI> Next message: <A HREF="001918.html">[Mono-list] Class library developers: locking issues to keep in mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1916">[ date ]</a>
              <a href="thread.html#1916">[ thread ]</a>
              <a href="subject.html#1916">[ subject ]</a>
              <a href="author.html#1916">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> Now, what happens is that this
</I>&gt;<i> thread does NOT perform an explicit read barrier
</I>&gt;<i> and hence may end up
</I>&gt;<i> with incompletely initialized singleton instance.
</I>
Well, I see your point.
This situation is possible when JIT inlines constructor's body and reorders
instructions so that object reference is non-null before constructors body
is executed;
Well, under .NET we could ensure valid execution sequence by disabling
inlining and using Create helper as I described in previous posts.
Hmm, it seems using volatile is ineffective here.
But I think applying the following patches should help (see previous post):
1) Extra check in the getter after initializer;
2) Extra thread fork/join in RealInit (all memory will be flushed upon
termination);
3) Using non-inlined helper to create singleton;
To ensure singleton and initializer will be created in the correct order we
could use dummy check for non-null value returned by helper, such as:
   if (singleton == null) {
      singleton = Create ();

      // This dummy check ensures that JIT
      // won't place initializer's constructor
      // before singleton creation
      if (singleton != null)
         initializer = new Call (DummyInit);
   }
Perhaps it's also needed to move DummyInit creation into non-inlined helper.
The above fix will ensure that singleton will be only visible when it's
fully constructed;
This still implies that RealInit could be called more than once, but at
least for any given thread it's guaranteed to be called only once.

As for Java, there is no way to explicitly disable inlining, right?
So perhaps, for Java it's just as hopelessly broken as DCL.
Maybe spawing separate thread for the helper will help?

What do you think?

Sergey











</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001914.html">[Mono-list] Class library developers: locking issues to keep in mind
</A></li>
	<LI> Next message: <A HREF="001918.html">[Mono-list] Class library developers: locking issues to keep in mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1916">[ date ]</a>
              <a href="thread.html#1916">[ thread ]</a>
              <a href="subject.html#1916">[ subject ]</a>
              <a href="author.html#1916">[ author ]</a>
         </LI>
       </UL>
</body></html>
