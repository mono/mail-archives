<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Class library developers: locking issues to keep in	mind
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:klyubin%40aqris.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001903.html">
   <LINK REL="Next"  HREF="001909.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Class library developers: locking issues to keep in	mind
   </H1>
    <B>Alexander Klyubin
    </B> 
    <A HREF="mailto:klyubin%40aqris.com"
       TITLE="[Mono-list] Class library developers: locking issues to keep in	mind">klyubin@aqris.com
       </A><BR>
    <I>Sun, 28 Oct 2001 21:43:22 +0000</I>
    <P><UL>
        <LI> Previous message: <A HREF="001903.html">[Mono-list] Class library developers: locking issues to keep in
 mind
</A></li>
        <LI> Next message: <A HREF="001909.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1908">[ date ]</a>
              <a href="thread.html#1908">[ thread ]</a>
              <a href="subject.html#1908">[ subject ]</a>
              <a href="author.html#1908">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hm... As far as I remember how volatile works in Java, even making 
reference volatile does not save you from the situation when the 
reference is OK, but the object it points to has not been completely 
initialized from point of view of a thread where some code accesses the 
object using this reference... But I'm not 100% sure on this.

Regards,
Alexander Klyubin

Miguel de Icaza wrote:

&gt;<i> On Sun, 2001-10-28 at 05:20, Alexander Klyubin wrote:
</I>&gt;<i> 
</I>&gt;&gt;<i>I don't know that much about .NET memory model as of Java's one, but in 
</I>&gt;&gt;<i>Java the code with on-demand locking you provided is called 
</I>&gt;&gt;<i>Double-checked Locking (DCL). The problem with it is that it is not 
</I>&gt;&gt;<i>guaranteed to work in all JVMs as synchronizing memory thread's own 
</I>&gt;&gt;<i>local memory with shared main memory accessible to all threads can work 
</I>&gt;&gt;<i>differently in different JVMs. Maybe memory model is organized 
</I>&gt;&gt;<i>differently in .NET languages compared to Java. But as similarity 
</I>&gt;&gt;<i>between C# and Java is realy big, I suspect memory model should be quite 
</I>&gt;&gt;<i>similar if not the same.
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i> This is a good point.
</I>&gt;<i> 
</I>&gt;<i> The problem comes not from the language, but from modern computer
</I>&gt;<i> architectures in SMP scenarios (the second link in your post goes into
</I>&gt;<i> detail about this)
</I>&gt;<i> 
</I>&gt;<i> Sadly none of the articles offers a good solution to the problem. Maybe
</I>&gt;<i> we need to discuss with the .NET people the semantics of lock in C# (we
</I>&gt;<i> could have explicit read/write barriers generated) or use volatiles.
</I>&gt;<i> 
</I>&gt;<i> Miguel.
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-list maillist  -  <A HREF="mailto:Mono-list@ximian.com">Mono-list@ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-list">http://lists.ximian.com/mailman/listinfo/mono-list</A>
</I>&gt;<i> 
</I>




</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001903.html">[Mono-list] Class library developers: locking issues to keep in
 mind
</A></li>
	<LI> Next message: <A HREF="001909.html">[Mono-list] Class library developers: locking issues to keep in	mind
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1908">[ date ]</a>
              <a href="thread.html#1908">[ thread ]</a>
              <a href="subject.html#1908">[ subject ]</a>
              <a href="author.html#1908">[ author ]</a>
         </LI>
       </UL>
</body></html>
