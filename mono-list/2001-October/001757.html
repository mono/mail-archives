<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] Some code for System.Text.UTF8Encoding
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:rafaelteixeirabr%40hotmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001756.html">
   <LINK REL="Next"  HREF="001758.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] Some code for System.Text.UTF8Encoding
   </H1>
    <B>A Rafael D Teixeira
    </B> 
    <A HREF="mailto:rafaelteixeirabr%40hotmail.com"
       TITLE="[Mono-list] Some code for System.Text.UTF8Encoding">rafaelteixeirabr@hotmail.com
       </A><BR>
    <I>Tue, 02 Oct 2001 18:42:05 -0300</I>
    <P><UL>
        <LI> Previous message: <A HREF="001756.html">[Mono-list] Fwd: RAND-modified: Can a clause o ETERNAL waiving of licensing fees for
 open-source implementations for RAND?
</A></li>
        <LI> Next message: <A HREF="001758.html">[Mono-list] Submissions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1757">[ date ]</a>
              <a href="thread.html#1757">[ thread ]</a>
              <a href="subject.html#1757">[ subject ]</a>
              <a href="author.html#1757">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Sean, here is some code to advance the state of System.Text.UTF8Encoding. I 
hope it is of some help.

&lt;code&gt;
//
// System.Text.UTF8Encoding.cs
//
// Authors:
//   Sean MacIsaac (<A HREF="mailto:macisaac@ximian.com">macisaac@ximian.com</A>)
//
// (C) Ximian, Inc.  <A HREF="http://www.ximian.com">http://www.ximian.com</A>
//


namespace System.Text
{

	public class UTF8Encoding : Encoding
	{
		public override int GetByteCount(char[] chars, int index, int count)
		{
			// FIXME
			return count*6;
		}

		public override int GetBytes(char[] chars, int charIndex, int charCount, 
byte[] bytes, int byteIndex)
		{
			if (chars == null || bytes == null)
				throw new ArgumentNullException();

			if (charIndex &lt; 0 || charCount &lt; 0 || byteIndex &lt; 0 ||
			    charIndex + charCount &gt; chars.Length ||
			    byteIndex + GetByteCount(chars, charIndex, charCount) &gt; bytes.Length)
				throw new ArgumentOutOfRangeException();

			// this is slow implementation just to get the things going
			int outputIndex = byteIndex;
			for (int i = 0; i &lt; charCount; i++)
			{
				int charCode = (int)chars[charIndex + i];

				if (charCode &lt; 0)  // negative chars are invalid
					throw new ArgumentOutOfRangeException();

				if (charCode &lt; 0x80)
					bytes [outputIndex++] = (byte)charCode;
				else
					if (charCode &lt; 0x800)
					{
						bytes [outputIndex++] = (byte)((charCode &gt;&gt; 6) | 0xC0);
						bytes [outputIndex++] = (byte)((charCode &amp; 0x3F) | 0x80);
					}
					else
					{
						// LAME: if chars[] come as UTF-16 - here we have to decode the 
surrogate pair, before proceeding
						// charCode = some magic with charCode and (int)chars[++i + charIndex] 
if needed
						if (charCode &lt; 0x10000)
						{
							bytes [outputIndex++] = (byte)((charCode &gt;&gt; 12) | 0xE0);
							bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 6) &amp; 0x3F) | 0x80);
							bytes [outputIndex++] = (byte)((charCode &amp; 0x3F) | 0x80);
						}
						else
							if (charCode &lt; 0x200000)
							{
								bytes [outputIndex++] = (byte)((charCode &gt;&gt; 18) | 0xF0);
								bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 12) &amp; 0x3F) | 0x80);
								bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 6) &amp; 0x3F) | 0x80);
								bytes [outputIndex++] = (byte)((charCode &amp; 0x3F) | 0x80);
							}
							else
								if (charCode &lt; 0x4000000)
								{
									bytes [outputIndex++] = (byte)((charCode &gt;&gt; 24) | 0xF8);
									bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 18) &amp; 0x3F) | 0x80);
									bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 12) &amp; 0x3F) | 0x80);
									bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 6) &amp; 0x3F) | 0x80);
									bytes [outputIndex++] = (byte)((charCode &amp; 0x3F) | 0x80);
								}
								else
								{
									bytes [outputIndex++] = (byte)((charCode &gt;&gt; 30) | 0xFC);
									bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 24) &amp; 0x3F) | 0x80);
									bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 18) &amp; 0x3F) | 0x80);
									bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 12) &amp; 0x3F) | 0x80);
									bytes [outputIndex++] = (byte)(((charCode &gt;&gt; 6) &amp; 0x3F) | 0x80);
									bytes [outputIndex++] = (byte)((charCode &amp; 0x3F) | 0x80);
								}
					}
			}

			return (outputIndex - byteIndex);
		}

		public override int GetBytes(string s, int charIndex, int charCount, 
byte[] bytes, int byteIndex)
		{
				char[] chars = s.ToCharArray(charIndex, charCount);
				return 	GetBytes(chars, 0, charCount, bytes, byteIndex);
		}

		public override byte[] GetBytes(string s)
		{
			char[] chars = s.ToCharArray();
			byte[] bytes = new byte[GetByteCount(chars, 0, chars.Length)];

			GetBytes(chars, 0, chars.Length, bytes, bytes.Length);

			return bytes;
		}

		public override int GetCharCount(byte[] bytes, int byteIndex, int 
byteCount)
		{
			int count = 0;
			for (int i = byteIndex; i &lt; byteIndex + byteCount; i++)
				if ((bytes[i] &amp; 0xC0) != 0x80)
					count++;

			return count;
		}

		public override int GetChars(byte[] bytes, int byteIndex, int byteCount, 
char[] chars, int charIndex)
		{
			if (chars == null || bytes == null)
				throw new ArgumentNullException();

			if (charIndex &lt; 0 || byteCount &lt; 0 || byteIndex &lt; 0 ||
			    charIndex + GetCharCount(bytes, byteIndex, byteCount) &gt; chars.Length 
||<i>
</I>			    byteIndex + byteCount &gt; bytes.Length)
				throw new ArgumentOutOfRangeException();

			// FIXME
			return 0;
		}

		public override int GetMaxByteCount(int charCount)
		{
			return charCount*6;
		}

		public override int GetMaxCharCount(int byteCount)
		{
			return byteCount;
		}
	}
}

&lt;/code&gt;

It compiled well with csc, but I couldn´t test if it does what is needed.

Miguel, when compiled with mcs (based on snapshot Sep-25) it gave:

===========================
Parsing successful

Unhandled Exception: System.NullReferenceException: Value null was found 
where an instance of an object was required.
   at CIR.TypeManager.FindMembers(Type t, MemberTypes mt, BindingFlags bf, 
MemberFilter filter, Object criteria) in 
C:\cygwin\tmp\mcs\typemanager.cs:line 197
   at CIR.Expression.MemberLookup(RootContext rc, Type t, String name, 
Boolean same_type, MemberTypes mt, BindingFlags bf) in 
C:\cygwin\tmp\mcs\expression.cs:line 132
   at CIR.Binary.ResolveOperator(TypeContainer tc) in 
C:\cygwin\tmp\mcs\expression.cs:line 1355
   at CIR.Binary.Resolve(TypeContainer tc) in 
C:\cygwin\tmp\mcs\expression.cs:line 1446
   at CIR.Binary.Resolve(TypeContainer tc) in 
C:\cygwin\tmp\mcs\expression.cs:line 1440
   at CIR.Binary.Resolve(TypeContainer tc) in 
C:\cygwin\tmp\mcs\expression.cs:line 1440
   at CIR.EmitContext.EmitBoolExpression(Expression e) in 
C:\cygwin\tmp\mcs\codegen.cs:line 110
   at CIR.EmitContext.EmitIf(If s) in C:\cygwin\tmp\mcs\codegen.cs:line 148
   at CIR.EmitContext.EmitStatement(Statement s) in 
C:\cygwin\tmp\mcs\codegen.cs:line 265
   at CIR.EmitContext.EmitBlock(Block block) in 
C:\cygwin\tmp\mcs\codegen.cs:line 298
   at CIR.EmitContext.EmitTopBlock(Block block) in 
C:\cygwin\tmp\mcs\codegen.cs:line 310
   at CIR.Method.Emit(TypeContainer parent) in 
C:\cygwin\tmp\mcs\class.cs:line 1010
   at CIR.TypeContainer.Emit() in C:\cygwin\tmp\mcs\class.cs:line 646
   at CIR.RootContext.EmitCode() in C:\cygwin\tmp\mcs\rootcontext.cs:line 
615
   at CIR.Driver..ctor(String[] args) in C:\cygwin\tmp\mcs\driver.cs:line 
374
   at CIR.Driver.Main(String[] args) in C:\cygwin\tmp\mcs\driver.cs:line 119

===========================

Rafael Teixeira
Brazilian Developer


_________________________________________________________________
Get your FREE download of MSN Explorer at <A HREF="http://explorer.msn.com/intl.asp">http://explorer.msn.com/intl.asp</A>



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001756.html">[Mono-list] Fwd: RAND-modified: Can a clause o ETERNAL waiving of licensing fees for
 open-source implementations for RAND?
</A></li>
	<LI> Next message: <A HREF="001758.html">[Mono-list] Submissions
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1757">[ date ]</a>
              <a href="thread.html#1757">[ thread ]</a>
              <a href="subject.html#1757">[ subject ]</a>
              <a href="author.html#1757">[ author ]</a>
         </LI>
       </UL>
</body></html>
