<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] delegate support
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:ravi%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001820.html">
   <LINK REL="Next"  HREF="001825.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] delegate support
   </H1>
    <B>Ravi Pratap M
    </B> 
    <A HREF="mailto:ravi%40ximian.com"
       TITLE="[Mono-list] delegate support">ravi@ximian.com
       </A><BR>
    <I>Wed, 17 Oct 2001 18:54:08 +0530</I>
    <P><UL>
        <LI> Previous message: <A HREF="001820.html">[Mono-list] work done tonight
</A></li>
        <LI> Next message: <A HREF="001825.html">[Mono-list] Initial draft of document for beginning testers..
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1822">[ date ]</a>
              <a href="thread.html#1822">[ thread ]</a>
              <a href="subject.html#1822">[ subject ]</a>
              <a href="author.html#1822">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.

------=_NextPart_000_0007_01C1573D.19E7D590
Content-Type: text/plain;
	charset=&quot;iso-8859-1&quot;
Content-Transfer-Encoding: 7bit

Hey Miguel,

    Okay, so this patch gives us complete delegate support ! Instantiation
and invocation :-)

    The only case left is when you instantiate a delegate from another
delegate type but that should also be easy to do. Will work on that next.

    Meanwhile, I shall write the tests for reference conversions as you
asked yesterday.

    Regards,

                Ravi

------=_NextPart_000_0007_01C1573D.19E7D590
Content-Type: application/octet-stream;
	name=&quot;mcs-oct-17&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename=&quot;mcs-oct-17&quot;

? mcs.pdb=0A=
Index: ChangeLog=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/ChangeLog,v=0A=
retrieving revision 1.136=0A=
diff -u -r1.136 ChangeLog=0A=
--- ChangeLog	2001/10/16 00:57:41	1.136=0A=
+++ ChangeLog	2001/10/17 09:22:58=0A=
@@ -1,3 +1,55 @@=0A=
+2001-10-17  Ravi Pratap  &lt;<A HREF="mailto:ravi@ximian.com">ravi@ximian.com</A>&gt;=0A=
+=0A=
+	* expression.cs (New::DoResolve): Implement delegate creation fully=0A=
+	and according to the spec.=0A=
+=0A=
+	(New::DoEmit): Update to handle delegates differently.=0A=
+=0A=
+	(Invocation::FullMethodDesc): Fix major stupid bug thanks to me=0A=
+	because of which we were printing out arguments in reverse order !=0A=
+=0A=
+	* delegate.cs (VerifyMethod): Implement to check if the given method=0A=
+	matches the delegate.=0A=
+=0A=
+	(FullDelegateDesc): Implement.=0A=
+=0A=
+	(VerifyApplicability): Implement.=0A=
+=0A=
+	* expression.cs (Invocation::DoResolve): Update to accordingly handle=0A=
+	delegate invocations too.=0A=
+=0A=
+	(Invocation::Emit): Ditto.=0A=
+=0A=
+	* ../errors/cs1593.cs : Added.=0A=
+=0A=
+	* ../errors/cs1594.cs : Added.=0A=
+=0A=
+	* delegate.cs (InstanceExpression, TargetMethod): New properties.=0A=
+=0A=
+2001-10-16  Ravi Pratap  &lt;<A HREF="mailto:ravi@ximian.com">ravi@ximian.com</A>&gt;=0A=
+=0A=
+	* typemanager.cs (intptr_type): Core type for System.IntPtr=0A=
+=0A=
+	(InitCoreTypes): Update for the same.=0A=
+=0A=
+	(iasyncresult_type, asynccallback_type): Ditto.=0A=
+=0A=
+	* delegate.cs (Populate): Fix to use System.Intptr as it is indeed=0A=
+	correct.=0A=
+=0A=
+	* typemanager.cs (AddDelegateType): Store a pointer to the Delegate =
class=0A=
+	too.=0A=
+=0A=
+	* delegate.cs (ConstructorBuilder, InvokeBuilder, ...): New members to =
hold=0A=
+	the builders for the 4 members of a delegate type :-)=0A=
+=0A=
+	(Populate): Define the BeginInvoke and EndInvoke methods on the =
delegate=0A=
+	type.=0A=
+=0A=
+	* expression.cs (New::DoResolve): Implement guts for delegate creation.=0A=
+=0A=
+	* ../errors/errors.txt : Update for an error (-11) which only we catch =
:<i>-)=0A=
</I>+=0A=
 2001-10-15  Miguel de Icaza  &lt;<A HREF="mailto:miguel@ximian.com">miguel@ximian.com</A>&gt;=0A=
 =0A=
 	* statement.cs (Break::Emit): Implement.   =0A=
Index: class.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/class.cs,v=0A=
retrieving revision 1.77=0A=
diff -u -r1.77 class.cs=0A=
--- class.cs	2001/10/15 14:41:52	1.77=0A=
+++ class.cs	2001/10/17 09:23:06=0A=
@@ -994,7 +994,7 @@=0A=
 			}=0A=
 =0A=
 			if (Delegates !=3D null) {=0A=
-				foreach (Delegate d in Delegates)=0A=
+				foreach (Delegate d in Delegates) =0A=
 					d.Populate (this);=0A=
 			}=0A=
 			=0A=
Index: cs-parser.jay=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/cs-parser.jay,v=0A=
retrieving revision 1.67=0A=
diff -u -r1.67 cs-parser.jay=0A=
--- cs-parser.jay	2001/10/16 00:57:41	1.67=0A=
+++ cs-parser.jay	2001/10/17 09:23:13=0A=
@@ -1419,7 +1419,8 @@=0A=
 	  CLOSE_PARENS =0A=
 	  SEMICOLON=0A=
 	  {=0A=
-		Delegate del =3D new Delegate (rc, (string) $4, (int) $2, MakeName =
((string) $5), (Parameters) $7, =0A=
+		Delegate del =3D new Delegate (rc, (string) $4, (int) $2, =0A=
+		                             MakeName ((string) $5), (Parameters) $7, =0A=
 					     (Attributes) $1, lexer.Location);=0A=
 		  =0A=
 		CheckDef (current_container.AddDelegate (del), del.Name);=0A=
Index: delegate.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/delegate.cs,v=0A=
retrieving revision 1.7=0A=
diff -u -r1.7 delegate.cs=0A=
--- delegate.cs	2001/10/15 14:41:52	1.7=0A=
+++ delegate.cs	2001/10/17 09:23:13=0A=
@@ -13,6 +13,7 @@=0A=
 using System.Collections;
 using System.Reflection;
 using System.Reflection.Emit;
+using System.Text;
=20
 namespace CIR {
 =09
@@ -20,13 +21,24 @@=0A=
=20
 		public readonly string Name;
 		public readonly string ReturnType;
-		public int    mod_flags;
-		public Parameters Parameters;
-		public Attributes OptAttributes;
-		public TypeBuilder TypeBuilder;
-
+		public int             mod_flags;
+		public Parameters      Parameters;
+		public Attributes      OptAttributes;
+		public TypeBuilder     TypeBuilder;
+
+		public ConstructorBuilder ConstructorBuilder;
+		public MethodBuilder      InvokeBuilder;
+		public MethodBuilder      BeginInvokeBuilder;
+		public MethodBuilder      EndInvokeBuilder;
+	=09
 		public readonly RootContext RootContext;
+
+		Type [] param_types;
+		Type ret_type;
 	=09
+		Expression instance_expr;
+		MethodBase delegate_method;
+=09
 		Location loc;
=20
 		const int AllowedModifiers =3D
@@ -68,43 +80,179 @@=0A=
=20
 			}
=20
-			RootContext.TypeManager.AddDelegateType (Name, TypeBuilder);
+			RootContext.TypeManager.AddDelegateType (Name, TypeBuilder, this);
 		}
=20
 		public void Populate (TypeContainer parent)
 		{
=20
+			MethodAttributes mattr;
+		=09
 			Type [] const_arg_types =3D new Type [2];
=20
 			const_arg_types [0] =3D TypeManager.object_type;
+			const_arg_types [1] =3D TypeManager.intptr_type;
+
+			mattr =3D MethodAttributes.RTSpecialName | =
MethodAttributes.SpecialName |
+				MethodAttributes.HideBySig | MethodAttributes.Public;
=20
-			// FIXME : How do I specify a &quot;native int&quot; or void * here ?
-			// This is surely not right !
-			const_arg_types [1] =3D TypeManager.int32_type;
-		=09
-			ConstructorBuilder cb =3D TypeBuilder.DefineConstructor (
-						    MethodAttributes.RTSpecialName | MethodAttributes.SpecialName =
|<i>
</I>-						    MethodAttributes.HideBySig | MethodAttributes.Public,
-						    CallingConventions.Standard,
-						    const_arg_types);
+			ConstructorBuilder =3D TypeBuilder.DefineConstructor (mattr,
+									    CallingConventions.Standard,
+									    const_arg_types);
 		=09
-			cb.SetImplementationFlags (MethodImplAttributes.Runtime);
+			ConstructorBuilder.SetImplementationFlags =
(MethodImplAttributes.Runtime);
 		=09
 			// Here the various methods like Invoke, BeginInvoke etc are defined
+
+ 			param_types =3D Parameters.GetParameterInfo (parent);
+  			ret_type =3D parent.LookupType (ReturnType, false);
+  			CallingConventions cc =3D Parameters.GetCallingConvention ();
+
+ 			mattr =3D MethodAttributes.Public | MethodAttributes.HideBySig | =
MethodAttributes.Virtual;
+
+ 			InvokeBuilder =3D TypeBuilder.DefineMethod (&quot;Invoke&quot;,=20
+ 								  mattr,		    =20
+ 								  cc,
+ 								  ret_type,		    =20
+ 								  param_types);
+		=09
+			InvokeBuilder.SetImplementationFlags (MethodImplAttributes.Runtime);
+
+			int params_num =3D param_types.Length;
+			Type [] async_param_types =3D new Type [params_num + 2];
+
+			param_types.CopyTo (async_param_types, 0);
+
+			async_param_types [params_num] =3D TypeManager.asynccallback_type;
+			async_param_types [params_num + 1] =3D TypeManager.object_type;
+
+			mattr =3D MethodAttributes.Public | MethodAttributes.HideBySig | =
MethodAttributes.Virtual |
+				MethodAttributes.NewSlot;
+		=09
+			BeginInvokeBuilder =3D TypeBuilder.DefineMethod (&quot;BeginInvoke&quot;,
+								       mattr,
+								       cc,
+								       TypeManager.iasyncresult_type,
+								       async_param_types);
+		=09
+			BeginInvokeBuilder.SetImplementationFlags =
(MethodImplAttributes.Runtime);
+
+			Type [] end_param_types =3D new Type [1];
+
+			end_param_types [0] =3D TypeManager.iasyncresult_type;
+		=09
+			EndInvokeBuilder =3D TypeBuilder.DefineMethod (&quot;EndInvoke&quot;,
+								     mattr,
+								     cc,
+								     ret_type,
+								     end_param_types);
+
+			EndInvokeBuilder.SetImplementationFlags =
(MethodImplAttributes.Runtime);
+		=09
+		}
+
+		public MethodBase VerifyMethod (MethodBase mb, Location loc)
+		{
+			ParameterData pd =3D Invocation.GetParameterData (mb);
+
+			bool mismatch =3D false;
+			for (int i =3D param_types.Length; i &gt; 0; ) {
+				i--;
+
+				if (param_types [i] =3D=3D pd.ParameterType (i))
+					continue;
+				else {
+					mismatch =3D true;
+					break;
+				}
+			}
+
+			if (mismatch) {
+				Report.Error (123, loc, &quot;Method '&quot; + Invocation.FullMethodDesc (mb) =
+ &quot;' does not match &quot; +
+					      &quot;delegate '&quot; + FullDelegateDesc () + &quot;'&quot;);
+				return null;
+			}
+
+			if (ret_type =3D=3D ((MethodInfo) mb).ReturnType)
+				return mb;
+			else
+				mismatch =3D true;
+
+			if (mismatch) {
+				Report.Error (123, loc, &quot;Method '&quot; + Invocation.FullMethodDesc (mb) =
+ &quot;' does not match &quot; +
+					      &quot;delegate '&quot; + FullDelegateDesc () + &quot;'&quot;);
+				return null;
+			}
=20
-			Type [] param_types =3D Parameters.GetParameterInfo (parent);
-			Type ret_type =3D parent.LookupType (ReturnType, false);
+			return null;
+		}
=20
-			MethodBuilder mb =3D TypeBuilder.DefineMethod (&quot;Invoke&quot;,=20
-					       MethodAttributes.Public | MethodAttributes.HideBySig,		     =

-					       Parameters.GetCallingConvention (),
-					       ret_type,		    =20
-					       param_types);
+		public bool VerifyApplicability (EmitContext ec, ArrayList args, =
Location loc)
+		{
+			int arg_count;
=20
-			mb.SetImplementationFlags (MethodImplAttributes.Runtime);
+			if (args =3D=3D null)
+				arg_count =3D 0;
+			else
+				arg_count =3D args.Count;
+		=09
+			if (param_types.Length !=3D arg_count) {
+				Report.Error (1593, loc,
+					      &quot;Delegate '&quot; + Name + &quot;' does not take '&quot; + arg_count + &quot;' =
arguments&quot;);
+				return false;
+			}
+
+			for (int i =3D arg_count; i &gt; 0;) {
+				i--;
+				Expression conv;
+				Argument a =3D (Argument) args [i];
+				Expression a_expr =3D a.Expr;
+			=09
+				if (param_types [i] !=3D a_expr.Type) {
+				=09
+					conv =3D Expression.ConvertImplicitStandard (ec, a_expr, =
param_types [i], loc);
+
+					if (conv =3D=3D null) {
+						Report.Error (1594, loc,
+							      &quot;Delegate '&quot; + Name + &quot;' has some invalid arguments.&quot;);
+
+						Report.Error (1503, loc,
+						       &quot;Argument &quot; + (i+1) +
+						       &quot;: Cannot convert from '&quot; +
+						       TypeManager.CSharpName (a_expr.Type)
+						       + &quot;' to '&quot; + TypeManager.CSharpName (param_types [i]) + =
&quot;'&quot;);
+						return false;
+					}
+
+					if (a_expr !=3D conv)
+						a.Expr =3D conv;
+				}
+			}
=20
-			// FIXME : The asynchronous ones BeginInvoke, EndInvoke come here
+			return true;
 		}
+  	=09
+		public string FullDelegateDesc ()
+		{
+			StringBuilder sb =3D new StringBuilder (TypeManager.CSharpName =
(System.Type.GetType (ReturnType)));
+		=09
+			sb.Append (&quot; &quot; + Name);
+			sb.Append (&quot; (&quot;);
+
+			int length =3D param_types.Length;
+		=09
+			for (int i =3D length; i &gt; 0; ) {
+				i--;
+			=09
+				sb.Append (TypeManager.CSharpName (param_types [length - i - 1]));
+				if (i !=3D 0)
+					sb.Append (&quot;, &quot;);
+			}
+		=09
+			sb.Append (&quot;)&quot;);
+			return sb.ToString ();
+		=09
+		}
 	=09
 		public void CloseDelegate ()
 		{
@@ -116,8 +264,24 @@=0A=
 				return mod_flags;
 			}
 		}
-	=09
=20
+		public Expression InstanceExpression {
+			get {
+				return instance_expr;
+			}
+			set {
+				instance_expr =3D value;
+			}
+		}
+
+		public MethodBase TargetMethod {
+			get {
+				return delegate_method;
+			}
+			set {
+				delegate_method =3D value;
+			}
+		}
 	}
 =09
 }
Index: expression.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/expression.cs,v=0A=
retrieving revision 1.86=0A=
diff -u -r1.86 expression.cs=0A=
--- expression.cs	2001/10/16 00:57:41	1.86=0A=
+++ expression.cs	2001/10/17 09:23:24=0A=
@@ -3567,7 +3567,8 @@=0A=
 	public class Invocation : ExpressionStatement {=0A=
 		public readonly ArrayList Arguments;=0A=
 		public readonly Location Location;=0A=
-		=0A=
+=0A=
+		public bool IsDelegate;=0A=
 		Expression expr;=0A=
 		MethodBase method =3D null;=0A=
 			=0A=
@@ -3872,11 +3873,14 @@=0A=
 		{=0A=
 			StringBuilder sb =3D new StringBuilder (mb.Name);=0A=
 			ParameterData pd =3D GetParameterData (mb);=0A=
-			=0A=
+=0A=
+			int count =3D pd.Count;=0A=
 			sb.Append (&quot; (&quot;);=0A=
-			for (int i =3D pd.Count; i &gt; 0;) {=0A=
+			=0A=
+			for (int i =3D count; i &gt; 0; ) {=0A=
 				i--;=0A=
-				sb.Append (TypeManager.CSharpName (pd.ParameterType (i)));=0A=
+				=0A=
+				sb.Append (TypeManager.CSharpName (pd.ParameterType (count - i - =
1)));=0A=
 				if (i !=3D 0)=0A=
 					sb.Append (&quot;, &quot;);=0A=
 			}=0A=
@@ -4073,6 +4077,7 @@=0A=
 			=0A=
 		public override Expression DoResolve (EmitContext ec)=0A=
 		{=0A=
+			IsDelegate =3D false;=0A=
 			//=0A=
 			// First, resolve the expression that is used to=0A=
 			// trigger the invocation=0A=
@@ -4081,6 +4086,37 @@=0A=
 			if (this.expr =3D=3D null)=0A=
 				return null;=0A=
 =0A=
+			Type expr_type =3D null;=0A=
+			if (!(this.expr is MethodGroupExpr)) {=0A=
+				expr_type =3D this.expr.Type;=0A=
+				IsDelegate =3D TypeManager.IsDelegateType (expr_type);=0A=
+			}=0A=
+			=0A=
+			if (IsDelegate) {=0A=
+				=0A=
+				Delegate del =3D TypeManager.LookupDelegate (expr_type);=0A=
+=0A=
+				if (Arguments !=3D null){=0A=
+					for (int i =3D Arguments.Count; i &gt; 0;){=0A=
+						--i;=0A=
+						Argument a =3D (Argument) Arguments [i];=0A=
+						=0A=
+						if (!a.Resolve (ec))=0A=
+							return null;=0A=
+					}=0A=
+				}=0A=
+				=0A=
+				if (!del.VerifyApplicability (ec, Arguments, Location))=0A=
+					return null;=0A=
+=0A=
+				method =3D del.InvokeBuilder;=0A=
+				type =3D ((MethodInfo) method).ReturnType;=0A=
+=0A=
+				eclass =3D ExprClass.Value;=0A=
+=0A=
+				return this;=0A=
+			}=0A=
+			=0A=
 			if (!(this.expr is MethodGroupExpr)){=0A=
 				report118 (Location, this.expr, &quot;method group&quot;);=0A=
 				return null;=0A=
@@ -4192,11 +4228,16 @@=0A=
 		=0A=
 		public override void Emit (EmitContext ec)=0A=
 		{=0A=
-			MethodGroupExpr mg =3D (MethodGroupExpr) this.expr;=0A=
-			=0A=
-			EmitCall (ec, method.IsStatic, mg.InstanceExpression, method, =
Arguments);=0A=
-		}=0A=
+			if (IsDelegate) {=0A=
+				Delegate del =3D TypeManager.LookupDelegate (this.expr.Type);=0A=
+				EmitCall (ec, del.TargetMethod.IsStatic, this.expr, method, =
Arguments);=0A=
 =0A=
+			} else {=0A=
+				MethodGroupExpr mg =3D (MethodGroupExpr) this.expr;=0A=
+				EmitCall (ec, method.IsStatic, mg.InstanceExpression, method, =
Arguments);=0A=
+			}=0A=
+		}=0A=
+		=0A=
 		public override void EmitStatement (EmitContext ec)=0A=
 		{=0A=
 			Emit (ec);=0A=
@@ -4226,10 +4267,14 @@=0A=
 		public readonly string    Rank;=0A=
 		public readonly ArrayList Initializers;=0A=
 =0A=
+		public bool IsDelegate;=0A=
+		=0A=
+		Expression delegate_instance_expr =3D null;=0A=
+		MethodBase delegate_method =3D null;=0A=
+		=0A=
 		Location Location;=0A=
 		MethodBase method =3D null;=0A=
 =0A=
-=0A=
 		//=0A=
 		// If set, the new expression is for a value_target, and=0A=
 		// we will not leave anything on the stack.=0A=
@@ -4286,62 +4331,120 @@=0A=
 		public override Expression DoResolve (EmitContext ec)=0A=
 		{=0A=
 			if (NewType =3D=3D NType.Object) {=0A=
+=0A=
 				type =3D ec.TypeContainer.LookupType (RequestedType, false);=0A=
 				=0A=
 				if (type =3D=3D null)=0A=
 					return null;=0A=
 =0A=
-				if (TypeManager.IsDelegateType (type)) {=0A=
-					Report.Error (-100, &quot;No support for delegate instantiation yet !&quot;);=0A=
-					return null;=0A=
-				}=0A=
+				IsDelegate =3D TypeManager.IsDelegateType (type);=0A=
 				=0A=
-				Expression ml;=0A=
+				if (IsDelegate) {=0A=
+					// So we have a delegate creation expression=0A=
+					=0A=
+					Delegate del =3D TypeManager.LookupDelegate (type);=0A=
+					method =3D del.ConstructorBuilder;=0A=
 =0A=
-				ml =3D MemberLookup (ec, type, &quot;.ctor&quot;, false,=0A=
-						   MemberTypes.Constructor, AllBindingsFlags, Location);=0A=
+					if (Arguments =3D=3D null) {=0A=
+						Report.Error (-11, Location,=0A=
+							      &quot;Delegate creation expression takes only one argument&quot;);=0A=
+						return null;=0A=
+					}=0A=
+					=0A=
+					if (Arguments.Count !=3D 1) {=0A=
+						Report.Error (-11, Location,=0A=
+							      &quot;Delegate creation expression takes only one argument&quot;);=0A=
+						return null;=0A=
+					}=0A=
+					=0A=
+					Argument a =3D (Argument) Arguments [0];=0A=
 =0A=
-				bool is_struct;=0A=
-				is_struct =3D type.IsSubclassOf (TypeManager.value_type);=0A=
+					if (!a.Resolve (ec))=0A=
+						return null;=0A=
+					=0A=
+					Expression e =3D a.Expr;=0A=
+					=0A=
+					if (e is MethodGroupExpr) {=0A=
+						MethodGroupExpr mg =3D (MethodGroupExpr) e;=0A=
+						=0A=
+						delegate_method  =3D del.VerifyMethod (mg.Methods [0], Location);=0A=
+=0A=
+						if (delegate_method =3D=3D null)=0A=
+							return null;=0A=
+						=0A=
+						if (mg.InstanceExpression !=3D null)=0A=
+							delegate_instance_expr =3D mg.InstanceExpression.Resolve (ec);=0A=
+						else=0A=
+							delegate_instance_expr =3D null;=0A=
+						=0A=
+						if (delegate_instance_expr !=3D null) {=0A=
+							if (delegate_instance_expr.Type.IsValueType)=0A=
+							      delegate_instance_expr =3D new BoxedCast=0A=
+								      (delegate_instance_expr);=0A=
+						}=0A=
+=0A=
+						del.InstanceExpression =3D delegate_instance_expr;=0A=
+						del.TargetMethod =3D delegate_method;=0A=
 =0A=
-				if (! (ml is MethodGroupExpr)){=0A=
-					if (!is_struct){=0A=
-						report118 (Location, ml, &quot;method group&quot;);=0A=
+						eclass =3D ExprClass.Value;=0A=
+						return this;=0A=
+						=0A=
+					} else {=0A=
+						Report.Error (-200, Location,=0A=
+							      &quot;Cannot handle delegate creation from another delegate =
yet&quot;);=0A=
 						return null;=0A=
 					}=0A=
-				}=0A=
+					=0A=
+				} else {=0A=
+					=0A=
+					Expression ml;=0A=
+					=0A=
+					ml =3D MemberLookup (ec, type, &quot;.ctor&quot;, false,=0A=
+							   MemberTypes.Constructor, AllBindingsFlags, Location);=0A=
 =0A=
-				if (ml !=3D null){=0A=
-					if (Arguments !=3D null){=0A=
-						for (int i =3D Arguments.Count; i &gt; 0;){=0A=
-							--i;=0A=
-							Argument a =3D (Argument) Arguments [i];=0A=
-							=0A=
-							if (!a.Resolve (ec))=0A=
-								return null;=0A=
+					bool is_struct =3D false;=0A=
+					is_struct =3D type.IsSubclassOf (TypeManager.value_type);=0A=
+					=0A=
+					if (! (ml is MethodGroupExpr)){=0A=
+						if (!is_struct){=0A=
+							report118 (Location, ml, &quot;method group&quot;);=0A=
+							return null;=0A=
 						}=0A=
 					}=0A=
 					=0A=
-					method =3D Invocation.OverloadResolve (=0A=
-						ec, (MethodGroupExpr) ml,=0A=
-						Arguments, Location);=0A=
-				=0A=
+					if (ml !=3D null) {=0A=
+						if (Arguments !=3D null){=0A=
+							for (int i =3D Arguments.Count; i &gt; 0;){=0A=
+								--i;=0A=
+								Argument a =3D (Argument) Arguments [i];=0A=
+								=0A=
+								if (!a.Resolve (ec))=0A=
+									return null;=0A=
+							}=0A=
+						}=0A=
+						=0A=
+						method =3D Invocation.OverloadResolve (ec, (MethodGroupExpr) ml,=0A=
+										     Arguments, Location);=0A=
+					}=0A=
+					=0A=
+					=0A=
 					if (method =3D=3D null &amp;&amp; !is_struct) {=0A=
 						Error (-6, Location,=0A=
 						       &quot;New invocation: Can not find a constructor for &quot; +=0A=
 						       &quot;this argument list&quot;);=0A=
 						return null;=0A=
 					}=0A=
-				} =0A=
-				=0A=
-				eclass =3D ExprClass.Value;=0A=
-				return this;=0A=
-			}=0A=
+					=0A=
+					eclass =3D ExprClass.Value;=0A=
+					return this;=0A=
+				}=0A=
 =0A=
+			}=0A=
+			=0A=
 			if (NewType =3D=3D NType.Array) {=0A=
 				throw new Exception (&quot;Finish array creation&quot;);=0A=
 			}=0A=
-=0A=
+			=0A=
 			return null;=0A=
 		}=0A=
 =0A=
@@ -4363,6 +4466,18 @@=0A=
 =0A=
 				ml.AddressOf (ec);=0A=
 			} else {=0A=
+=0A=
+				if (IsDelegate) {=0A=
+					if (delegate_instance_expr =3D=3D null)=0A=
+						ec.ig.Emit (OpCodes.Ldnull);=0A=
+					else=0A=
+						delegate_instance_expr.Emit (ec);=0A=
+=0A=
+					ec.ig.Emit (OpCodes.Ldftn, (MethodInfo) delegate_method);=0A=
+					ec.ig.Emit (OpCodes.Newobj, (ConstructorInfo) method);=0A=
+					return true;=0A=
+				} =0A=
+				=0A=
 				Invocation.EmitArguments (ec, method, Arguments);=0A=
 				ec.ig.Emit (OpCodes.Newobj, (ConstructorInfo) method);=0A=
 				return true;=0A=
Index: rootcontext.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/rootcontext.cs,v=0A=
retrieving revision 1.35=0A=
diff -u -r1.35 rootcontext.cs=0A=
--- rootcontext.cs	2001/10/15 14:41:52	1.35=0A=
+++ rootcontext.cs	2001/10/17 09:23:24=0A=
@@ -172,7 +172,7 @@=0A=
 		public Type LookupType (TypeContainer tc, string name, bool silent)=0A=
 		{=0A=
 			Type t;=0A=
-			=0A=
+=0A=
 			t =3D TypeManager.LookupType (MakeFQN (tc.Namespace.Name, name));=0A=
 			if (t !=3D null)=0A=
 				return t;=0A=
Index: typemanager.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/typemanager.cs,v=0A=
retrieving revision 1.30=0A=
diff -u -r1.30 typemanager.cs=0A=
--- typemanager.cs	2001/10/15 14:41:52	1.30=0A=
+++ typemanager.cs	2001/10/17 09:23:24=0A=
@@ -43,6 +43,10 @@=0A=
 	static public Type type_type;=0A=
 	static public Type ienumerator_type;=0A=
 	static public Type idisposable_type;=0A=
+	static public Type iasyncresult_type;=0A=
+	static public Type asynccallback_type;=0A=
+=0A=
+	static public Type intptr_type;=0A=
 	=0A=
 	static public MethodInfo string_concat_string_string;=0A=
 	static public MethodInfo string_concat_object_object;=0A=
@@ -124,10 +128,10 @@=0A=
 		typecontainers.Add (name, tc);=0A=
 	}=0A=
 =0A=
-	public void AddDelegateType (string name, TypeBuilder t)=0A=
+	public void AddDelegateType (string name, TypeBuilder t, Delegate del)=0A=
 	{=0A=
 		types.Add (name, t);=0A=
-		delegate_types.Add (t, name);=0A=
+		delegate_types.Add (t, del);=0A=
 	}=0A=
 =0A=
 	public void AddUserInterface (string name, TypeBuilder t, Interface i)=0A=
@@ -149,6 +153,11 @@=0A=
 	{=0A=
 		return (Interface) builder_to_interface [t];=0A=
 	}=0A=
+=0A=
+	public static Delegate LookupDelegate (Type t)=0A=
+	{=0A=
+		return (Delegate) delegate_types [t];=0A=
+	}=0A=
 	=0A=
 	// &lt;summary&gt;=0A=
 	//   Registers an assembly to load types from.=0A=
@@ -279,6 +288,10 @@=0A=
 		ienumerator_type    =3D CoreLookupType =
(&quot;System.Collections.IEnumerator&quot;);=0A=
 		icloneable_type     =3D CoreLookupType (&quot;System.ICloneable&quot;);=0A=
 		idisposable_type    =3D CoreLookupType (&quot;System.IDisposable&quot;);=0A=
+		iasyncresult_type   =3D CoreLookupType (&quot;System.IAsyncResult&quot;);=0A=
+		asynccallback_type =3D CoreLookupType  (&quot;System.AsyncCallback&quot;);=0A=
+		=0A=
+		intptr_type =3D CoreLookupType (&quot;System.IntPtr&quot;);=0A=
 		=0A=
 		//=0A=
 		// Now load the default methods that we use.=0A=
@@ -317,9 +330,9 @@=0A=
 =0A=
 	public static bool IsDelegateType (Type t)=0A=
 	{=0A=
-		string name =3D (string) delegate_types [t];=0A=
+		Delegate del =3D (Delegate) delegate_types [t];=0A=
 =0A=
-		if (name !=3D null)=0A=
+		if (del !=3D null)=0A=
 			return true;=0A=
 		else=0A=
 			return false;=0A=

------=_NextPart_000_0007_01C1573D.19E7D590--



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001820.html">[Mono-list] work done tonight
</A></li>
	<LI> Next message: <A HREF="001825.html">[Mono-list] Initial draft of document for beginning testers..
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1822">[ date ]</a>
              <a href="thread.html#1822">[ thread ]</a>
              <a href="subject.html#1822">[ subject ]</a>
              <a href="author.html#1822">[ author ]</a>
         </LI>
       </UL>
</body></html>
