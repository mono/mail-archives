<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-list] today's work
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:ravi%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001817.html">
   <LINK REL="Next"  HREF="001812.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-list] today's work
   </H1>
    <B>Ravi Pratap M
    </B> 
    <A HREF="mailto:ravi%40ximian.com"
       TITLE="[Mono-list] today's work">ravi@ximian.com
       </A><BR>
    <I>Tue, 16 Oct 2001 00:10:04 +0530</I>
    <P><UL>
        <LI> Previous message: <A HREF="001817.html">[Mono-list] GTK bindings
</A></li>
        <LI> Next message: <A HREF="001812.html">[Mono-list] break, continue implemented.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1811">[ date ]</a>
              <a href="thread.html#1811">[ thread ]</a>
              <a href="subject.html#1811">[ subject ]</a>
              <a href="author.html#1811">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.

------=_NextPart_000_000D_01C155D6.E7F91E70
Content-Type: text/plain;
	charset=&quot;iso-8859-1&quot;
Content-Transfer-Encoding: 7bit

Hey guys,

    Here;s the patch for today. So we have now :

        * The beginnings of delegate support
        * implicit reference conversions for array types
        * explicit reference conversions for array types


    Should be done with delegates soon ;-)


    Regards,

                    Ravi





------=_NextPart_000_000D_01C155D6.E7F91E70
Content-Type: application/octet-stream;
	name=&quot;mcs-oct-15-2&quot;
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename=&quot;mcs-oct-15-2&quot;

? mcs.pdb=0A=
Index: ChangeLog=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/ChangeLog,v=0A=
retrieving revision 1.134=0A=
diff -u -r1.134 ChangeLog=0A=
--- ChangeLog	2001/10/15 00:03:43	1.134=0A=
+++ ChangeLog	2001/10/15 14:39:07=0A=
@@ -1,3 +1,68 @@=0A=
+2001-10-15  Ravi Pratap  &lt;<A HREF="mailto:ravi@ximian.com">ravi@ximian.com</A>&gt;=0A=
+=0A=
+	* delegate.cs (Emit): Get rid of it as there doesn't seem to be any =
ostensible=0A=
+	use of emitting anything at all.=0A=
+=0A=
+	* class.cs, rootcontext.cs : Get rid of calls to the same.=0A=
+=0A=
+	* delegate.cs (DefineDelegate): Make sure the class we define is also =
sealed.=0A=
+=0A=
+	(Populate): Define the constructor correctly and set the implementation=0A=
+	attributes.=0A=
+=0A=
+	* typemanager.cs (delegate_types): New hashtable to hold delegates that=0A=
+	have been defined.=0A=
+=0A=
+	(AddDelegateType): Implement.=0A=
+=0A=
+	(IsDelegateType): Implement helper method.=0A=
+=0A=
+	* delegate.cs (DefineDelegate): Use AddDelegateType instead of =
AddUserType.=0A=
+=0A=
+	* expression.cs (New::DoResolve): Check if we are trying to =
instantiate a delegate type=0A=
+	and accordingly handle it.=0A=
+=0A=
+	* delegate.cs (Populate): Take TypeContainer argument.=0A=
+	Implement bits to define the Invoke method. However, I still haven't =
figured out=0A=
+	how to take care of the native int bit :-(=0A=
+=0A=
+	* cs-parser.jay (delegate_declaration): Fixed the bug that I had =
introduced :-) =0A=
+	Qualify the name of the delegate, not its return type !=0A=
+=0A=
+	* expression.cs (ImplicitReferenceConversion): Implement guts of =
implicit array=0A=
+	conversion.=0A=
+=0A=
+	(StandardConversionExists): Checking for array types turns out to be =
recursive.=0A=
+=0A=
+	(ConvertReferenceExplicit): Implement array conversion.=0A=
+=0A=
+	(ExplicitReferenceConversionExists): New method to determine precisely =
that :-)=0A=
+	=0A=
+2001-10-12  Ravi Pratap  &lt;<A HREF="mailto:ravi@ximian.com">ravi@ximian.com</A>&gt;=0A=
+=0A=
+	* cs-parser.jay (delegate_declaration): Store the fully qualified=0A=
+	name as it is a type declaration.=0A=
+=0A=
+	* delegate.cs (ReturnType, Name): Rename members to these. Make them =0A=
+	readonly.=0A=
+=0A=
+	(DefineDelegate): Renamed from Define. Does the same thing essentially,=0A=
+	as TypeContainer::DefineType.=0A=
+=0A=
+	(Populate): Method in which all the definition of the various methods =
(Invoke)=0A=
+	etc is done.=0A=
+=0A=
+	(Emit): Emit any code, if necessary. I am not sure about this really, =
but let's=0A=
+	see.=0A=
+	=0A=
+	(CloseDelegate): Finally creates the delegate.=0A=
+=0A=
+	* class.cs (TypeContainer::DefineType): Update to define delegates.=0A=
+	(Populate, Emit and CloseType): Do the same thing here too.=0A=
+=0A=
+	* rootcontext.cs (ResolveTree, PopulateTypes, EmitCode, CloseTypes): =
Include=0A=
+	delegates in all these operations.=0A=
+=0A=
 2001-10-14  Miguel de Icaza  &lt;<A HREF="mailto:miguel@ximian.com">miguel@ximian.com</A>&gt;=0A=
 =0A=
 	* expression.cs: LocalTemporary: a new expression used to=0A=
Index: class.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/class.cs,v=0A=
retrieving revision 1.76=0A=
diff -u -r1.76 class.cs=0A=
--- class.cs	2001/10/15 00:03:43	1.76=0A=
+++ class.cs	2001/10/15 14:39:15=0A=
@@ -869,6 +869,11 @@=0A=
 				foreach (TypeContainer tc in Types)=0A=
 					tc.DefineType (TypeBuilder);=0A=
 			}=0A=
+=0A=
+			if (Delegates !=3D null) {=0A=
+				foreach (Delegate d in Delegates)=0A=
+					d.DefineDelegate (TypeBuilder);=0A=
+			}=0A=
 			=0A=
 			InTransit =3D false;=0A=
 			return TypeBuilder;=0A=
@@ -990,13 +995,14 @@=0A=
 =0A=
 			if (Delegates !=3D null) {=0A=
 				foreach (Delegate d in Delegates)=0A=
-					d.Define (this);=0A=
+					d.Populate (this);=0A=
 			}=0A=
 			=0A=
 			if (Types !=3D null) {=0A=
 				foreach (TypeContainer tc in Types)=0A=
 					tc.Populate ();=0A=
 			}=0A=
+			=0A=
 		}=0A=
 =0A=
 		//=0A=
@@ -1291,7 +1297,7 @@=0A=
 			if (types !=3D null)=0A=
 				foreach (TypeContainer tc in types)=0A=
 					tc.Emit ();=0A=
-			=0A=
+=0A=
 		}=0A=
 =0A=
 		public void CloseType ()=0A=
@@ -1300,6 +1306,10 @@=0A=
 			=0A=
 			foreach (TypeContainer tc in Types)=0A=
 				tc.CloseType ();=0A=
+=0A=
+			if (Delegates !=3D null)=0A=
+				foreach (Delegate d in Delegates)=0A=
+					d.CloseDelegate ();=0A=
 		}=0A=
 =0A=
 		string MakeName (string n)=0A=
Index: cs-parser.jay=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/cs-parser.jay,v=0A=
retrieving revision 1.65=0A=
diff -u -r1.65 cs-parser.jay=0A=
--- cs-parser.jay	2001/10/12 14:18:21	1.65=0A=
+++ cs-parser.jay	2001/10/15 14:39:21=0A=
@@ -1419,9 +1419,9 @@=0A=
 	  CLOSE_PARENS =0A=
 	  SEMICOLON=0A=
 	  {=0A=
-		Delegate del =3D new Delegate ((string) $4, (int) $2, (string) $5, =
(Parameters) $7, =0A=
+		Delegate del =3D new Delegate (rc, (string) $4, (int) $2, MakeName =
((string) $5), (Parameters) $7, =0A=
 					     (Attributes) $1, lexer.Location);=0A=
-=0A=
+		  =0A=
 		CheckDef (current_container.AddDelegate (del), del.Name);=0A=
 	  }	=0A=
 	| opt_attributes=0A=
@@ -1432,7 +1432,7 @@=0A=
 	  CLOSE_PARENS =0A=
 	  SEMICOLON=0A=
 	  {=0A=
-		Delegate del =3D new Delegate (null, (int) $2, (string) $5, =
(Parameters) $7, =0A=
+		Delegate del =3D new Delegate (rc, &quot;System.Void&quot;, (int) $2, (string) =
$5, (Parameters) $7, =0A=
 					     (Attributes) $1, lexer.Location);=0A=
 =0A=
 		CheckDef (current_container.AddDelegate (del), del.Name);=0A=
Index: delegate.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/delegate.cs,v=0A=
retrieving revision 1.6=0A=
diff -u -r1.6 delegate.cs=0A=
--- delegate.cs	2001/10/11 16:46:46	1.6=0A=
+++ delegate.cs	2001/10/15 14:39:21=0A=
@@ -18,13 +18,15 @@=0A=
 =09
 	public class Delegate {
=20
-		public string Name;
-		public string type;
+		public readonly string Name;
+		public readonly string ReturnType;
 		public int    mod_flags;
 		public Parameters Parameters;
 		public Attributes OptAttributes;
-		public TypeBuilder DelegateBuilder;
+		public TypeBuilder TypeBuilder;
=20
+		public readonly RootContext RootContext;
+	=09
 		Location loc;
=20
 		const int AllowedModifiers =3D
@@ -34,43 +36,81 @@=0A=
 			Modifiers.INTERNAL |
 			Modifiers.PRIVATE;
=20
-		public Delegate (string type, int mod_flags, string name, Parameters =
param_list,
+		public Delegate (RootContext rc, string type, int mod_flags, string =
name, Parameters param_list,
 				 Attributes attrs, Location loc)
 		{
+			this.RootContext =3D rc;
 			this.Name       =3D name;
-			this.type       =3D type;
+			this.ReturnType =3D type;
 			this.mod_flags  =3D Modifiers.Check (AllowedModifiers, mod_flags, =
Modifiers.PUBLIC);
 			Parameters      =3D param_list;
 			OptAttributes   =3D attrs;
 			this.loc        =3D loc;
 		}
=20
-		public void Define (TypeContainer parent)
+		public void DefineDelegate (object parent_builder)
 		{
 			TypeAttributes attr;
 		=09
-			if (parent.IsTopLevel)
-				attr =3D TypeAttributes.NestedPublic | TypeAttributes.Class;
-			else
-				attr =3D TypeAttributes.Public | TypeAttributes.Class;
+			if (parent_builder is ModuleBuilder) {
+				ModuleBuilder builder =3D (ModuleBuilder) parent_builder;
+			=09
+				attr =3D TypeAttributes.Public | TypeAttributes.Class | =
TypeAttributes.Sealed;
+
+				TypeBuilder =3D builder.DefineType (Name, attr, =
TypeManager.delegate_type);
+								 =20
+			} else {
+				TypeBuilder builder =3D (TypeBuilder) parent_builder;
+			=09
+				attr =3D TypeAttributes.NestedPublic | TypeAttributes.Class | =
TypeAttributes.Sealed;
+
+				TypeBuilder =3D builder.DefineNestedType (Name, attr, =
TypeManager.delegate_type);
+
+			}
+
+			RootContext.TypeManager.AddDelegateType (Name, TypeBuilder);
+		}
+
+		public void Populate (TypeContainer parent)
+		{
+
+			Type [] const_arg_types =3D new Type [2];
+
+			const_arg_types [0] =3D TypeManager.object_type;
+
+			// FIXME : How do I specify a &quot;native int&quot; or void * here ?
+			// This is surely not right !
+			const_arg_types [1] =3D TypeManager.int32_type;
+		=09
+			ConstructorBuilder cb =3D TypeBuilder.DefineConstructor (
+						    MethodAttributes.RTSpecialName | MethodAttributes.SpecialName =
|<i>
</I>+						    MethodAttributes.HideBySig | MethodAttributes.Public,
+						    CallingConventions.Standard,
+						    const_arg_types);
+		=09
+			cb.SetImplementationFlags (MethodImplAttributes.Runtime);
 		=09
-			Type t =3D parent.LookupType (type, false);
+			// Here the various methods like Invoke, BeginInvoke etc are defined
+
 			Type [] param_types =3D Parameters.GetParameterInfo (parent);
-			Type base_type =3D System.Type.GetType (&quot;System.MulticastDelegate&quot;);
+			Type ret_type =3D parent.LookupType (ReturnType, false);
=20
-			DelegateBuilder =3D parent.TypeBuilder.DefineNestedType (Name, attr, =
base_type);
+			MethodBuilder mb =3D TypeBuilder.DefineMethod (&quot;Invoke&quot;,=20
+					       MethodAttributes.Public | MethodAttributes.HideBySig,		     =

+					       Parameters.GetCallingConvention (),
+					       ret_type,		    =20
+					       param_types);
=20
-			//DelegateBuilder.CreateType ();
+			mb.SetImplementationFlags (MethodImplAttributes.Runtime);
=20
+			// FIXME : The asynchronous ones BeginInvoke, EndInvoke come here
 		}
-	=09
 	=09
-		public string Type {
-			get {
-				return type;
-			}
+		public void CloseDelegate ()
+		{
+			TypeBuilder.CreateType ();
 		}
-
+	=09
 		public int ModFlags {
 			get {
 				return mod_flags;
Index: expression.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/expression.cs,v=0A=
retrieving revision 1.84=0A=
diff -u -r1.84 expression.cs=0A=
--- expression.cs	2001/10/15 00:03:43	1.84=0A=
+++ expression.cs	2001/10/15 14:39:31=0A=
@@ -408,12 +408,19 @@=0A=
 				=0A=
 				// from an array-type S to an array-type of type T=0A=
 				if (expr_type.IsArray &amp;&amp; target_type.IsArray) {=0A=
+					if (expr_type.GetArrayRank () =3D=3D target_type.GetArrayRank ()) {=0A=
 =0A=
-					Console.WriteLine (&quot;{0} -&gt; {1}&quot;, expr_type, target_type);=0A=
-					throw new Exception (&quot;Implement array conversion&quot;);=0A=
-					=0A=
+						Type expr_element_type =3D expr_type.GetElementType ();=0A=
+						Type target_element_type =3D target_type.GetElementType ();=0A=
+=0A=
+						if (!expr_element_type.IsValueType &amp;&amp; =
!target_element_type.IsValueType)=0A=
+							if (StandardConversionExists (expr_element_type,=0A=
+										      target_element_type))=0A=
+								return new EmptyCast (expr, target_type);=0A=
+					}=0A=
 				}=0A=
 				=0A=
+				=0A=
 				// from an array-type to System.Array=0A=
 				if (expr_type.IsArray &amp;&amp; target_type.IsAssignableFrom (expr_type))=0A=
 					return new EmptyCast (expr, target_type);=0A=
@@ -427,7 +434,7 @@=0A=
 				// from any array-type or delegate type into System.ICloneable.=0A=
 				if (expr_type.IsArray || expr_type.IsSubclassOf =
(TypeManager.delegate_type))=0A=
 					if (target_type =3D=3D TypeManager.icloneable_type)=0A=
-						throw new Exception (&quot;Implement conversion to System.ICloneable&quot;);=0A=
+						return new EmptyCast (expr, target_type);=0A=
 				=0A=
 				// from the null type to any reference-type.=0A=
 				if (expr is NullLiteral)=0A=
@@ -764,8 +771,18 @@=0A=
 						return true;=0A=
 				=0A=
 				// from an array-type S to an array-type of type T=0A=
-				if (expr_type.IsArray &amp;&amp; target_type.IsArray) =0A=
-					return true;=0A=
+				if (expr_type.IsArray &amp;&amp; target_type.IsArray) {=0A=
+					if (expr_type.GetArrayRank () =3D=3D target_type.GetArrayRank ()) {=0A=
+						=0A=
+						Type expr_element_type =3D expr_type.GetElementType ();=0A=
+						Type target_element_type =3D target_type.GetElementType ();=0A=
+						=0A=
+						if (!expr_element_type.IsValueType &amp;&amp; =
!target_element_type.IsValueType)=0A=
+							if (StandardConversionExists (expr_element_type,=0A=
+										      target_element_type))=0A=
+								return true;=0A=
+					}=0A=
+				}=0A=
 				=0A=
 				// from an array-type to System.Array=0A=
 				if (expr_type.IsArray &amp;&amp; target_type.IsAssignableFrom (expr_type))=0A=
@@ -969,7 +986,7 @@=0A=
 				// by target.=0A=
 				//=0A=
 				if (look_for_explicit)=0A=
-					source=3DConvertExplicit (ec, source, most_specific_source, loc);=0A=
+					source =3D ConvertExplicitStandard (ec, source, =
most_specific_source, loc);=0A=
 				else=0A=
 					source =3D ConvertImplicitStandard (ec, source,=0A=
 									  most_specific_source, loc);=0A=
@@ -1333,6 +1350,98 @@=0A=
 		}=0A=
 =0A=
 		// &lt;summary&gt;=0A=
+		//  Returns whether an explicit reference conversion can be performed=0A=
+		//  from source_type to target_type=0A=
+		// &lt;/summary&gt;=0A=
+		static bool ExplicitReferenceConversionExists (Type source_type, Type =
target_type)=0A=
+		{=0A=
+			bool target_is_value_type =3D target_type.IsValueType;=0A=
+			=0A=
+			if (source_type =3D=3D target_type)=0A=
+				return true;=0A=
+			=0A=
+			//=0A=
+			// From object to any reference type=0A=
+			//=0A=
+			if (source_type =3D=3D TypeManager.object_type &amp;&amp; =
!target_is_value_type)=0A=
+				return true;=0A=
+					=0A=
+			//=0A=
+			// From any class S to any class-type T, provided S is a base class =
of T=0A=
+			//=0A=
+			if (target_type.IsSubclassOf (source_type))=0A=
+				return true;=0A=
+=0A=
+			//=0A=
+			// From any interface type S to any interface T provided S is not =
derived from T=0A=
+			//=0A=
+			if (source_type.IsInterface &amp;&amp; target_type.IsInterface){=0A=
+				if (!target_type.IsSubclassOf (source_type))=0A=
+					return true;=0A=
+			}=0A=
+			    =0A=
+			//=0A=
+			// From any class type S to any interface T, provides S is not sealed=0A=
+			// and provided S does not implement T.=0A=
+			//=0A=
+			if (target_type.IsInterface &amp;&amp; !source_type.IsSealed &amp;&amp;=0A=
+			    !target_type.IsAssignableFrom (source_type))=0A=
+				return true;=0A=
+=0A=
+			//=0A=
+			// From any interface-type S to to any class type T, provided T is =
not=0A=
+			// sealed, or provided T implements S.=0A=
+			//=0A=
+			if (source_type.IsInterface &amp;&amp;=0A=
+			    (!target_type.IsSealed || source_type.IsAssignableFrom =
(target_type)))=0A=
+				return true;=0A=
+=0A=
+			// From an array type S with an element type Se to an array type T =
with an =0A=
+			// element type Te provided all the following are true:=0A=
+			//     * S and T differe only in element type, in other words, S and =
T=0A=
+			//       have the same number of dimensions.=0A=
+			//     * Both Se and Te are reference types=0A=
+			//     * An explicit referenc conversions exist from Se to Te=0A=
+			//=0A=
+			if (source_type.IsArray &amp;&amp; target_type.IsArray) {=0A=
+				if (source_type.GetArrayRank () =3D=3D target_type.GetArrayRank ()) =
{=0A=
+					=0A=
+					Type source_element_type =3D source_type.GetElementType ();=0A=
+					Type target_element_type =3D target_type.GetElementType ();=0A=
+					=0A=
+					if (!source_element_type.IsValueType &amp;&amp; =
!target_element_type.IsValueType)=0A=
+						if (ExplicitReferenceConversionExists (source_element_type,=0A=
+										       target_element_type))=0A=
+							return true;=0A=
+				}=0A=
+			}=0A=
+			=0A=
+=0A=
+			// From System.Array to any array-type=0A=
+			if (source_type =3D=3D TypeManager.array_type &amp;&amp;=0A=
+			    target_type.IsSubclassOf (TypeManager.array_type)){=0A=
+				return true;=0A=
+			}=0A=
+=0A=
+			//=0A=
+			// From System delegate to any delegate-type=0A=
+			//=0A=
+			if (source_type =3D=3D TypeManager.delegate_type &amp;&amp;=0A=
+			    target_type.IsSubclassOf (TypeManager.delegate_type))=0A=
+				return true;=0A=
+=0A=
+			//=0A=
+			// From ICloneable to Array or Delegate types=0A=
+			//=0A=
+			if (source_type =3D=3D TypeManager.icloneable_type &amp;&amp;=0A=
+			    (target_type =3D=3D TypeManager.array_type ||=0A=
+			     target_type =3D=3D TypeManager.delegate_type))=0A=
+				return true;=0A=
+			=0A=
+			return false;=0A=
+		}=0A=
+=0A=
+		// &lt;summary&gt;=0A=
 		//   Implements Explicit Reference conversions=0A=
 		// &lt;/summary&gt;=0A=
 		static Expression ConvertReferenceExplicit (Expression source, Type =
target_type)=0A=
@@ -1376,18 +1485,27 @@=0A=
 			if (source_type.IsInterface &amp;&amp;=0A=
 			    (!target_type.IsSealed || source_type.IsAssignableFrom =
(target_type)))=0A=
 				return new ClassCast (source, target_type);=0A=
-=0A=
-			//=0A=
-			// FIXME: Implemet=0A=
-			//=0A=
 =0A=
-			// From an array typ eS with an element type Se to an array type T =
with an =0A=
+			// From an array type S with an element type Se to an array type T =
with an =0A=
 			// element type Te provided all the following are true:=0A=
 			//     * S and T differe only in element type, in other words, S and =
T=0A=
 			//       have the same number of dimensions.=0A=
 			//     * Both Se and Te are reference types=0A=
 			//     * An explicit referenc conversions exist from Se to Te=0A=
 			//=0A=
+			if (source_type.IsArray &amp;&amp; target_type.IsArray) {=0A=
+				if (source_type.GetArrayRank () =3D=3D target_type.GetArrayRank ()) =
{=0A=
+					=0A=
+					Type source_element_type =3D source_type.GetElementType ();=0A=
+					Type target_element_type =3D target_type.GetElementType ();=0A=
+					=0A=
+					if (!source_element_type.IsValueType &amp;&amp; =
!target_element_type.IsValueType)=0A=
+						if (ExplicitReferenceConversionExists (source_element_type,=0A=
+										       target_element_type))=0A=
+							return new ClassCast (source, target_type);=0A=
+				}=0A=
+			}=0A=
+			=0A=
 =0A=
 			// From System.Array to any array-type=0A=
 			if (source_type =3D=3D TypeManager.array_type &amp;&amp;=0A=
@@ -4159,6 +4277,11 @@=0A=
 				=0A=
 				if (type =3D=3D null)=0A=
 					return null;=0A=
+=0A=
+				if (TypeManager.IsDelegateType (type)) {=0A=
+					Report.Error (-100, &quot;No support for delegate instantiation yet !&quot;);=0A=
+					return null;=0A=
+				}=0A=
 				=0A=
 				Expression ml;=0A=
 =0A=
Index: rootcontext.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/rootcontext.cs,v=0A=
retrieving revision 1.34=0A=
diff -u -r1.34 rootcontext.cs=0A=
--- rootcontext.cs	2001/10/11 16:46:46	1.34=0A=
+++ rootcontext.cs	2001/10/15 14:39:31=0A=
@@ -128,6 +128,10 @@=0A=
 					type_container_resolve_order.Add (tc);=0A=
 			}=0A=
 =0A=
+			if (root.Delegates !=3D null)=0A=
+				foreach (Delegate d in root.Delegates) =0A=
+					d.DefineDelegate (mb);=0A=
+			=0A=
 		}=0A=
 			=0A=
 		// &lt;summary&gt;=0A=
@@ -152,6 +156,10 @@=0A=
 			=0A=
 			foreach (TypeContainer tc in root.Types)=0A=
 				tc.CloseType ();=0A=
+=0A=
+			if (root.Delegates !=3D null)=0A=
+				foreach (Delegate d in root.Delegates)=0A=
+					d.CloseDelegate ();=0A=
 			=0A=
 		}=0A=
 		=0A=
@@ -238,6 +246,12 @@=0A=
 			if (type_container_resolve_order !=3D null)=0A=
 				foreach (TypeContainer tc in type_container_resolve_order)=0A=
 					tc.Populate ();=0A=
+=0A=
+			ArrayList delegates =3D Tree.Types.Delegates;=0A=
+			if (delegates !=3D null)=0A=
+				foreach (Delegate d in delegates)=0A=
+					d.Populate (Tree.Types);=0A=
+		       =0A=
 		}=0A=
 =0A=
 		public void EmitCode ()=0A=
@@ -245,7 +259,7 @@=0A=
 			if (type_container_resolve_order !=3D null)=0A=
 				foreach (TypeContainer tc in type_container_resolve_order)=0A=
 					tc.Emit ();=0A=
-			=0A=
+=0A=
 		}=0A=
 		=0A=
 		// &lt;summary&gt;=0A=
Index: typemanager.cs=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /cvs/public/mcs/mcs/typemanager.cs,v=0A=
retrieving revision 1.29=0A=
diff -u -r1.29 typemanager.cs=0A=
--- typemanager.cs	2001/10/12 18:52:18	1.29=0A=
+++ typemanager.cs	2001/10/15 14:39:31=0A=
@@ -88,6 +88,12 @@=0A=
 	static Hashtable method_arguments;=0A=
 =0A=
 	static Hashtable builder_to_interface;=0A=
+=0A=
+	// &lt;remarks&gt;=0A=
+	//  Keeps track of delegate types=0A=
+	// &lt;/remarks&gt;=0A=
+=0A=
+	static Hashtable delegate_types;=0A=
 	=0A=
 	public TypeManager ()=0A=
 	{=0A=
@@ -96,6 +102,7 @@=0A=
 		types =3D new Hashtable ();=0A=
 		typecontainers =3D new Hashtable ();=0A=
 		builder_to_interface =3D new Hashtable ();=0A=
+		delegate_types =3D new Hashtable ();=0A=
 	}=0A=
 =0A=
 	static TypeManager ()=0A=
@@ -109,7 +116,7 @@=0A=
 		types.Add (name, t);=0A=
 		user_types.Add (t);=0A=
 	}=0A=
-=0A=
+	=0A=
 	public void AddUserType (string name, TypeBuilder t, TypeContainer tc)=0A=
 	{=0A=
 		AddUserType (name, t);=0A=
@@ -117,6 +124,12 @@=0A=
 		typecontainers.Add (name, tc);=0A=
 	}=0A=
 =0A=
+	public void AddDelegateType (string name, TypeBuilder t)=0A=
+	{=0A=
+		types.Add (name, t);=0A=
+		delegate_types.Add (t, name);=0A=
+	}=0A=
+=0A=
 	public void AddUserInterface (string name, TypeBuilder t, Interface i)=0A=
 	{=0A=
 		AddUserType (name, t);=0A=
@@ -257,7 +270,7 @@=0A=
 		decimal_type  =3D CoreLookupType (&quot;System.Decimal&quot;);=0A=
 		bool_type     =3D CoreLookupType (&quot;System.Boolean&quot;);=0A=
 		enum_type     =3D CoreLookupType (&quot;System.Enum&quot;);=0A=
-		delegate_type =3D CoreLookupType (&quot;System.Delegate&quot;);=0A=
+		delegate_type =3D CoreLookupType (&quot;System.MulticastDelegate&quot;);=0A=
 		array_type    =3D CoreLookupType (&quot;System.Array&quot;);=0A=
 		void_type     =3D CoreLookupType (&quot;System.Void&quot;);=0A=
 		type_type     =3D CoreLookupType (&quot;System.Type&quot;);=0A=
@@ -295,13 +308,23 @@=0A=
 		=0A=
 		tc =3D (TypeContainer) builder_to_container [t];=0A=
 		=0A=
-		if (tc =3D=3D null)=0A=
-			return t.FindMembers (mt, bf, filter, criteria);=0A=
+		if (tc =3D=3D null) =0A=
+		        return t.FindMembers (mt, bf, filter, criteria);=0A=
 		else =0A=
-			return tc.FindMembers (mt, bf, filter, criteria);=0A=
+		        return tc.FindMembers (mt, bf, filter, criteria);=0A=
 		=0A=
 	}=0A=
 =0A=
+	public static bool IsDelegateType (Type t)=0A=
+	{=0A=
+		string name =3D (string) delegate_types [t];=0A=
+=0A=
+		if (name !=3D null)=0A=
+			return true;=0A=
+		else=0A=
+			return false;=0A=
+	}=0A=
+	=0A=
 	// &lt;summary&gt;=0A=
 	//   Returns the User Defined Types=0A=
 	// &lt;/summary&gt;=0A=

------=_NextPart_000_000D_01C155D6.E7F91E70--



</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001817.html">[Mono-list] GTK bindings
</A></li>
	<LI> Next message: <A HREF="001812.html">[Mono-list] break, continue implemented.
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1811">[ date ]</a>
              <a href="thread.html#1811">[ thread ]</a>
              <a href="subject.html#1811">[ subject ]</a>
              <a href="author.html#1811">[ author ]</a>
         </LI>
       </UL>
</body></html>
