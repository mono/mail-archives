<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-osx] MonoMac parser.cs
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-osx%40lists.ximian.com?Subject=%5BMono-osx%5D%20MonoMac%20parser.cs&In-Reply-To=i2y24242a3e1004200703s1c9971d0pca90a2d44655d142%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002827.html">
   <LINK REL="Next"  HREF="002829.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-osx] MonoMac parser.cs</H1>
    <B>Duane Wandless</B> 
    <A HREF="mailto:mono-osx%40lists.ximian.com?Subject=%5BMono-osx%5D%20MonoMac%20parser.cs&In-Reply-To=i2y24242a3e1004200703s1c9971d0pca90a2d44655d142%40mail.gmail.com"
       TITLE="[Mono-osx] MonoMac parser.cs">duane at wandless.net
       </A><BR>
    <I>Tue Apr 20 10:59:19 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002827.html">[Mono-osx] MonoMac parser.cs
</A></li>
        <LI>Next message: <A HREF="002829.html">[Mono-osx] MonoMac parser.cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2828">[ date ]</a>
              <a href="thread.html#2828">[ thread ]</a>
              <a href="subject.html#2828">[ subject ]</a>
              <a href="author.html#2828">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i>
</I>&gt;<i> In the particular case of NSArray and NSMutableArray our runtime has been
</I>&gt;<i> extended to natively convert NSArrays to C# arrays and back so the only code
</I>&gt;<i> that we bound is the required interop code for NSArray.
</I>&gt;<i>
</I>
That is an interesting strategy and is limiting (I think).  How I use
NSMutableArrays is to populate them in C# then send then to the native obj-c
UI NSArrayControllers, etc.  I then can manipulate the array in C# and the
UI updates as expected.  If the only bindings exposed are to convert from a
List to NSArray then this use would not be possible.

Many bits from Foundation make sense for Objective-C programmers as they are
&gt;<i> dealing with a low-level language and are redundant with C#.
</I>&gt;<i>
</I>
I believe this statement is not true, given how I use NSArrays.  I need to
be able to manipulate the underlying object so the UI is automatically
updated.

We do not currently support a mapping to categories as they do not really
&gt;<i> have a counter part in C#.
</I>&gt;<i>
</I>
I may be too simple... but I view a category as nothing but additional
methods on the class.  But I may be missing some nuance of a category.

At a minimum I believe the bindings must expose the addObject, insertObject,
remove etc selectors on the arrays.

Duane

On Tue, Apr 20, 2010 at 10:03 AM, Miguel de Icaza &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-osx">miguel at novell.com</A>&gt; wrote:

&gt;<i> Hello Duane,
</I>&gt;<i>
</I>&gt;<i> I have taken parser.cs and extended it to handle categories.  To start I
</I>&gt;&gt;<i> tested parsing NSArray.h.  This produced NSArray.cs and NSMutableArray.cs.
</I>&gt;&gt;<i> I have &quot;full&quot; bindings for these obj-c classes.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> We do not currently support a mapping to categories as they do not really
</I>&gt;<i> have a counter part in C#.
</I>&gt;<i>
</I>&gt;<i> They are *similar* to interfaces, but they can be interfaces with optional
</I>&gt;<i> components so there is no direct mapping to them.
</I>&gt;<i>
</I>&gt;<i> For the delegate pattern we settled on classes that have been labeled as
</I>&gt;<i> &quot;Models&quot; (read more about that on our binding page).
</I>&gt;<i>
</I>&gt;<i> NSMutableArray:  <A HREF="http://monobin.com/__m335d328c">http://monobin.com/__m335d328c</A>
</I>&gt;&gt;<i> NSArray:  <A HREF="http://monobin.com/__m36c66b6e">http://monobin.com/__m36c66b6e</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Nice.  For the particular case of Foundation, we have taken an approach to
</I>&gt;<i> only bind what is actually *required* as opposed to binding everything.
</I>&gt;<i> Many bits from Foundation make sense for Objective-C programmers as they are
</I>&gt;<i> dealing with a low-level language and are redundant with C#.
</I>&gt;<i>
</I>&gt;<i> In the particular case of NSArray and NSMutableArray our runtime has been
</I>&gt;<i> extended to natively convert NSArrays to C# arrays and back so the only code
</I>&gt;<i> that we bound is the required interop code for NSArray.
</I>&gt;<i>
</I>&gt;<i> So we suggest to work instead on the AppKit bindings.
</I>&gt;<i>
</I>&gt;<i> However not all the bindings generated are valid.  For example I do not
</I>&gt;&gt;<i> know how to generate a binding for this selector (note I do not use this
</I>&gt;&gt;<i> selector, just an example):
</I>&gt;&gt;<i> - (void)sortUsingFunction:(NSInteger (*)(id, id, void *))compare
</I>&gt;&gt;<i> context:(void *)context;
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Correct, the parser does the heavy lifting, but requires human intervention
</I>&gt;<i> to fix the output.
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Then comes the question of constructors.  Take these two (the 2nd is not
</I>&gt;&gt;<i> really a constructor I know) from NSMutableArray for example:
</I>&gt;&gt;<i> + (id)arrayWithCapacity:(NSUInteger)numItems;
</I>&gt;&gt;<i> - (id)initWithCapacity:(NSUInteger)numItems;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> My parser exposes these as:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         [Static]
</I>&gt;&gt;<i>         [Export (&quot;arrayWithCapacity:&quot;)]
</I>&gt;&gt;<i>         IntPtr ArrayWithCapacity (uint numItems);
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>         [Export (&quot;initWithCapacity:&quot;)]
</I>&gt;&gt;<i>         IntPtr InitWithCapacity (uint numItems);
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> This is a great question.
</I>&gt;<i>
</I>&gt;<i> Factory methods should be declared as static methods, and we *typically*
</I>&gt;<i> use the FromXXXX or CreateXXX naming pattern for them, so the above would
</I>&gt;<i> look like this:
</I>&gt;<i>
</I>&gt;<i> [Static, Export (&quot;arrayWithCapacity:&quot;)]
</I>&gt;<i> NSArray CreateArray (int items);
</I>&gt;<i>
</I>&gt;<i> Notice that I took the liberty of changing the uint to int because that
</I>&gt;<i> makes the method CLS compliant.
</I>&gt;<i>
</I>&gt;<i> In this case it is a debatable change as there could be arrays with more
</I>&gt;<i> than 2 gig elements, but in many other places in the API this is not the
</I>&gt;<i> case, uint has been used to get an extra bit that is not required.
</I>&gt;<i>
</I>&gt;<i> So how can we support the extra 2 gigs of elements while still allowing
</I>&gt;<i> other languages the most common use case?  We keep the signature as it was
</I>&gt;<i> originally produced, and introduce a new overload:
</I>&gt;<i>
</I>&gt;<i> [Static, Export (&quot;arrayWithCapacity:&quot;)]
</I>&gt;<i> NSArray CreateArray (uint items);
</I>&gt;<i>
</I>&gt;<i> And then on a helper class in Foundation/NSArray.cs we would do:
</I>&gt;<i>
</I>&gt;<i> partial class NSArray {
</I>&gt;<i>      static NSArray CreateArray (int items){
</I>&gt;<i>           if (items &lt; 0) throw new ArgumentException ();
</I>&gt;<i>           return CreateArray ((uint) items);
</I>&gt;<i>      }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Now to the second question:
</I>&gt;<i>
</I>&gt;<i> First I do not think returning an IntPtr is correct.  It should return
</I>&gt;&gt;<i> NSMutableArray.  But IntPtr follows what was started with MT.  Returning an
</I>&gt;&gt;<i> IntPtr will require calling GetNSObject which seems cumbersome.  Unless I'm
</I>&gt;&gt;<i> missing something.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> In the specific case of *constructors*  the binding generator recognizes
</I>&gt;<i> the pattern:
</I>&gt;<i>
</I>&gt;<i> IntPtr Constructor (ARGS)
</I>&gt;<i>
</I>&gt;<i> As being the constructor for the class.   This is required because
</I>&gt;<i> constructors generate different code than regular method bindings.
</I>&gt;<i>
</I>&gt;<i> So you will see in all of our APIs that we expose that pattern, but that
</I>&gt;<i> this is never translated into an actual exposed IntPtr, it is always
</I>&gt;<i> translated into the correct method name.
</I>&gt;<i>
</I>&gt;<i> Miguel.
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-osx/attachments/20100420/fff5762e/attachment.html">http://lists.ximian.com/pipermail/mono-osx/attachments/20100420/fff5762e/attachment.html</A> 
</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002827.html">[Mono-osx] MonoMac parser.cs
</A></li>
	<LI>Next message: <A HREF="002829.html">[Mono-osx] MonoMac parser.cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2828">[ date ]</a>
              <a href="thread.html#2828">[ thread ]</a>
              <a href="subject.html#2828">[ subject ]</a>
              <a href="author.html#2828">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-osx">More information about the Mono-osx
mailing list</a><br>
</body></html>
