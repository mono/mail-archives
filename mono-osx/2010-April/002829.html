<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-osx] MonoMac parser.cs
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-osx%40lists.ximian.com?Subject=%5BMono-osx%5D%20MonoMac%20parser.cs&In-Reply-To=j2id57001c11004200759s4061a65fhe4c842eb4658d8b5%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002828.html">
   <LINK REL="Next"  HREF="002834.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-osx] MonoMac parser.cs</H1>
    <B>Michael Bluestein</B> 
    <A HREF="mailto:mono-osx%40lists.ximian.com?Subject=%5BMono-osx%5D%20MonoMac%20parser.cs&In-Reply-To=j2id57001c11004200759s4061a65fhe4c842eb4658d8b5%40mail.gmail.com"
       TITLE="[Mono-osx] MonoMac parser.cs">mike.bluestein at gmail.com
       </A><BR>
    <I>Tue Apr 20 11:26:11 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002828.html">[Mono-osx] MonoMac parser.cs
</A></li>
        <LI>Next message: <A HREF="002834.html">[Mono-osx] MonoMac parser.cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2829">[ date ]</a>
              <a href="thread.html#2829">[ thread ]</a>
              <a href="subject.html#2829">[ subject ]</a>
              <a href="author.html#2829">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>categories are similar to extension methods perhaps

On Apr 20, 2010, at 10:59 AM, Duane Wandless &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-osx">duane at wandless.net</A>&gt; wrote:

&gt;<i> In the particular case of NSArray and NSMutableArray our runtime has  
</I>&gt;<i> been extended to natively convert NSArrays to C# arrays and back so  
</I>&gt;<i> the only code that we bound is the required interop code for NSArray.
</I>&gt;<i>
</I>&gt;<i> That is an interesting strategy and is limiting (I think).  How I  
</I>&gt;<i> use NSMutableArrays is to populate them in C# then send then to the  
</I>&gt;<i> native obj-c UI NSArrayControllers, etc.  I then can manipulate the  
</I>&gt;<i> array in C# and the UI updates as expected.  If the only bindings  
</I>&gt;<i> exposed are to convert from a List to NSArray then this use would  
</I>&gt;<i> not be possible.
</I>&gt;<i>
</I>&gt;<i> Many bits from Foundation make sense for Objective-C programmers as  
</I>&gt;<i> they are dealing with a low-level language and are redundant with C#.
</I>&gt;<i>
</I>&gt;<i> I believe this statement is not true, given how I use NSArrays.  I  
</I>&gt;<i> need to be able to manipulate the underlying object so the UI is  
</I>&gt;<i> automatically updated.
</I>&gt;<i>
</I>&gt;<i> We do not currently support a mapping to categories as they do not  
</I>&gt;<i> really have a counter part in C#.
</I>&gt;<i>
</I>&gt;<i> I may be too simple... but I view a category as nothing but  
</I>&gt;<i> additional methods on the class.  But I may be missing some nuance  
</I>&gt;<i> of a category.
</I>&gt;<i>
</I>&gt;<i> At a minimum I believe the bindings must expose the addObject,  
</I>&gt;<i> insertObject, remove etc selectors on the arrays.
</I>&gt;<i>
</I>&gt;<i> Duane
</I>&gt;<i>
</I>&gt;<i> On Tue, Apr 20, 2010 at 10:03 AM, Miguel de Icaza  
</I>&gt;<i> &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/mono-osx">miguel at novell.com</A>&gt; wrote:
</I>&gt;<i> Hello Duane,
</I>&gt;<i>
</I>&gt;<i> I have taken parser.cs and extended it to handle categories.  To  
</I>&gt;<i> start I tested parsing NSArray.h.  This produced NSArray.cs and  
</I>&gt;<i> NSMutableArray.cs.  I have &quot;full&quot; bindings for these obj-c classes.
</I>&gt;<i>
</I>&gt;<i> We do not currently support a mapping to categories as they do not  
</I>&gt;<i> really have a counter part in C#.
</I>&gt;<i>
</I>&gt;<i> They are *similar* to interfaces, but they can be interfaces with  
</I>&gt;<i> optional components so there is no direct mapping to them.
</I>&gt;<i>
</I>&gt;<i> For the delegate pattern we settled on classes that have been  
</I>&gt;<i> labeled as &quot;Models&quot; (read more about that on our binding page).
</I>&gt;<i>
</I>&gt;<i> NSMutableArray:  <A HREF="http://monobin.com/__m335d328c">http://monobin.com/__m335d328c</A>
</I>&gt;<i> NSArray:  <A HREF="http://monobin.com/__m36c66b6e">http://monobin.com/__m36c66b6e</A>
</I>&gt;<i>
</I>&gt;<i> Nice.  For the particular case of Foundation, we have taken an  
</I>&gt;<i> approach to only bind what is actually *required* as opposed to  
</I>&gt;<i> binding everything.   Many bits from Foundation make sense for  
</I>&gt;<i> Objective-C programmers as they are dealing with a low-level  
</I>&gt;<i> language and are redundant with C#.
</I>&gt;<i>
</I>&gt;<i> In the particular case of NSArray and NSMutableArray our runtime has  
</I>&gt;<i> been extended to natively convert NSArrays to C# arrays and back so  
</I>&gt;<i> the only code that we bound is the required interop code for NSArray.
</I>&gt;<i>
</I>&gt;<i> So we suggest to work instead on the AppKit bindings.
</I>&gt;<i>
</I>&gt;<i> However not all the bindings generated are valid.  For example I do  
</I>&gt;<i> not know how to generate a binding for this selector (note I do not  
</I>&gt;<i> use this selector, just an example):
</I>&gt;<i> - (void)sortUsingFunction:(NSInteger (*)(id, id, void *))compare  
</I>&gt;<i> context:(void *)context;
</I>&gt;<i>
</I>&gt;<i> Correct, the parser does the heavy lifting, but requires human  
</I>&gt;<i> intervention to fix the output.
</I>&gt;<i>
</I>&gt;<i> Then comes the question of constructors.  Take these two (the 2nd is  
</I>&gt;<i> not really a constructor I know) from NSMutableArray for example:
</I>&gt;<i> + (id)arrayWithCapacity:(NSUInteger)numItems;
</I>&gt;<i> - (id)initWithCapacity:(NSUInteger)numItems;
</I>&gt;<i>
</I>&gt;<i> My parser exposes these as:
</I>&gt;<i>
</I>&gt;<i>         [Static]
</I>&gt;<i>         [Export (&quot;arrayWithCapacity:&quot;)]
</I>&gt;<i>         IntPtr ArrayWithCapacity (uint numItems);
</I>&gt;<i>
</I>&gt;<i>         [Export (&quot;initWithCapacity:&quot;)]
</I>&gt;<i>         IntPtr InitWithCapacity (uint numItems);
</I>&gt;<i>
</I>&gt;<i> This is a great question.
</I>&gt;<i>
</I>&gt;<i> Factory methods should be declared as static methods, and we  
</I>&gt;<i> *typically* use the FromXXXX or CreateXXX naming pattern for them,  
</I>&gt;<i> so the above would look like this:
</I>&gt;<i>
</I>&gt;<i> [Static, Export (&quot;arrayWithCapacity:&quot;)]
</I>&gt;<i> NSArray CreateArray (int items);
</I>&gt;<i>
</I>&gt;<i> Notice that I took the liberty of changing the uint to int because  
</I>&gt;<i> that makes the method CLS compliant.
</I>&gt;<i>
</I>&gt;<i> In this case it is a debatable change as there could be arrays with  
</I>&gt;<i> more than 2 gig elements, but in many other places in the API this  
</I>&gt;<i> is not the case, uint has been used to get an extra bit that is not  
</I>&gt;<i> required.
</I>&gt;<i>
</I>&gt;<i> So how can we support the extra 2 gigs of elements while still  
</I>&gt;<i> allowing other languages the most common use case?  We keep the  
</I>&gt;<i> signature as it was originally produced, and introduce a new overload:
</I>&gt;<i>
</I>&gt;<i> [Static, Export (&quot;arrayWithCapacity:&quot;)]
</I>&gt;<i> NSArray CreateArray (uint items);
</I>&gt;<i>
</I>&gt;<i> And then on a helper class in Foundation/NSArray.cs we would do:
</I>&gt;<i>
</I>&gt;<i> partial class NSArray {
</I>&gt;<i>      static NSArray CreateArray (int items){
</I>&gt;<i>           if (items &lt; 0) throw new ArgumentException ();
</I>&gt;<i>           return CreateArray ((uint) items);
</I>&gt;<i>      }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Now to the second question:
</I>&gt;<i>
</I>&gt;<i> First I do not think returning an IntPtr is correct.  It should  
</I>&gt;<i> return NSMutableArray.  But IntPtr follows what was started with  
</I>&gt;<i> MT.  Returning an IntPtr will require calling GetNSObject which  
</I>&gt;<i> seems cumbersome.  Unless I'm missing something.
</I>&gt;<i>
</I>&gt;<i> In the specific case of *constructors*  the binding generator  
</I>&gt;<i> recognizes the pattern:
</I>&gt;<i>
</I>&gt;<i> IntPtr Constructor (ARGS)
</I>&gt;<i>
</I>&gt;<i> As being the constructor for the class.   This is required because  
</I>&gt;<i> constructors generate different code than regular method bindings.
</I>&gt;<i>
</I>&gt;<i> So you will see in all of our APIs that we expose that pattern, but  
</I>&gt;<i> that this is never translated into an actual exposed IntPtr, it is  
</I>&gt;<i> always translated into the correct method name.
</I>&gt;<i>
</I>&gt;<i> Miguel.
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Mono-osx mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-osx">Mono-osx at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/mono-osx">http://lists.ximian.com/mailman/listinfo/mono-osx</A>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="http://lists.ximian.com/pipermail/mono-osx/attachments/20100420/3c2b8f10/attachment-0001.html">http://lists.ximian.com/pipermail/mono-osx/attachments/20100420/3c2b8f10/attachment-0001.html</A> 
</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002828.html">[Mono-osx] MonoMac parser.cs
</A></li>
	<LI>Next message: <A HREF="002834.html">[Mono-osx] MonoMac parser.cs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2829">[ date ]</a>
              <a href="thread.html#2829">[ thread ]</a>
              <a href="subject.html#2829">[ subject ]</a>
              <a href="author.html#2829">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-osx">More information about the Mono-osx
mailing list</a><br>
</body></html>
