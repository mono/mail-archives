<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [Mono-osx] Delphi Prism and all those Cocoa bridges
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mono-osx%40lists.ximian.com?Subject=%5BMono-osx%5D%20Delphi%20Prism%20and%20all%20those%20Cocoa%20bridges&In-Reply-To=22227864.post%40talk.nabble.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002111.html">
   <LINK REL="Next"  HREF="002115.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mono-osx] Delphi Prism and all those Cocoa bridges</H1>
    <B>Matt Emson</B> 
    <A HREF="mailto:mono-osx%40lists.ximian.com?Subject=%5BMono-osx%5D%20Delphi%20Prism%20and%20all%20those%20Cocoa%20bridges&In-Reply-To=22227864.post%40talk.nabble.com"
       TITLE="[Mono-osx] Delphi Prism and all those Cocoa bridges">memsom at interalpha.co.uk
       </A><BR>
    <I>Fri Feb 27 05:27:26 EST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002111.html">[Mono-osx] Delphi Prism and all those Cocoa bridges
</A></li>
        <LI>Next message: <A HREF="002115.html">[Mono-osx] Delphi Prism and all those Cocoa bridges
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2114">[ date ]</a>
              <a href="thread.html#2114">[ thread ]</a>
              <a href="subject.html#2114">[ subject ]</a>
              <a href="author.html#2114">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Andrew Brehm wrote:

I was off the radar yesterday, so apologies for tardy reply:

&gt;<i>
</I>&gt;<i> The only downside is that using that method I won't have a single EXE with
</I>&gt;<i> no DLL requirement that will run on both platforms (and look terrible on the
</I>&gt;<i> Mac).
</I>&gt;<i>   
</I>This is a DOS mentality, unfortunately. Long gone are the days of 
2single exe&quot;. Even with Win32 pure development, the programmer relied on 
underlying DLL's existing. This should never be an issue, but often was. 
Windows didn't really address this issue properly - it made it easy to 
continue with the practice of &quot;hope the user installed the right version 
of DLL X&quot;. From Win 2000 onwards, we've been pushed towards using 
installers. Installers should create a subdirectory containing support 
files that is completely opaque to the user of the system. Indeed in XP 
onwards, users are discouraged from looking in the Program Files 
directory by default (all users, even Administrator.) The contents of 
that directory can contain whatever the developer wants - there's no set 
rules. Indeed, iTunes, for example, contains a structure not unlike an 
App Bundle to varying degrees (there was a version around 6 that was 
almost identical, but the directory contents varies between major 
revisions.) Visual Studio 2005 has a mess of folders, Delphi 5.0 used to 
have a structure that split files between folders like {$InstallDir}\bin 
and {$InstallDir}\lib. Putting the App bundle in to a directory and 
creating a shortcut to the executable is not a crime. I don't see this 
as an issue at all.


&gt;<i> But I can add a fourth project if I want to support Linux and Gtk#.
</I>&gt;<i>   
</I>
I have an app I work on at work. Parts are legacy VB, parts are C#. I 
have over 30 projects for various chunks of business logic and support 
functionality. If using Visual Studio, embrace the project concept. It 
really works well. One solution, many projects makes for a happy camper. 
The fact you can then add project references - genius! Debugging is then 
seamless between languages and projects.

&gt;<i> Cocoa lacks the regular expressions and portability but has the best
</I>&gt;<i> right-to-left script support. (But it wants me to understand memory
</I>&gt;<i> management, which is always a bad move for a programming language.)
</I>&gt;<i>   
</I>Objective-C 2.0 has garbage collection properly integrated, so that is 
not entirely true. Having used the Compact Framework version of .Net on 
memory constricted devices (Pocket PC) you do begin to hit a memory wall 
after a while. There's a big trade-off to throwing away the explicit 
memory management in a low memory situation. The programmer still has to 
know how to force garbage collection to happen to free up memory, but 
then has to rely on the Garbage collection to actually work properly and 
quickly enough to not hang the system due to low memory.. It only takes 
a bit of badly written/memory leaking code (*cough* Mobile SQL Server 
*cough*) to throw the &quot;cat amongst the pidgins&quot; and cause radical and 
sometimes overly elaborate memory clearing scheme to be necessary. It 
sometimes makes you wonder if Garbage collection is all it is cracked up 
to be. Indeed, even though I just mentioned Objective-C 2.0 allows auto 
deletion in a much more effective way (proper Garbage collection), the 
iPhone SDK does not seem to allow auto deletion to be used, which makes 
a lot of sense and corresponds to what I've just said.

M
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002111.html">[Mono-osx] Delphi Prism and all those Cocoa bridges
</A></li>
	<LI>Next message: <A HREF="002115.html">[Mono-osx] Delphi Prism and all those Cocoa bridges
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2114">[ date ]</a>
              <a href="thread.html#2114">[ thread ]</a>
              <a href="subject.html#2114">[ subject ]</a>
              <a href="author.html#2114">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/mono-osx">More information about the Mono-osx
mailing list</a><br>
</body></html>
