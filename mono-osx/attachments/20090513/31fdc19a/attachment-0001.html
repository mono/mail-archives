<tt>
&lt;div&gt;&amp;gt;Do&nbsp;you&nbsp;mean:&lt;br&gt;<br>
&amp;gt;&lt;br&gt;<br>
&nbsp;&amp;gt;&nbsp; &nbsp; struct&nbsp;MyBase&nbsp;{&lt;br&gt;<br>
&nbsp;&amp;gt;&nbsp; &nbsp; }&lt;br&gt;<br>
&amp;gt;&lt;br&gt;<br>
&nbsp;&amp;gt; &nbsp; &nbsp;struct&nbsp;Derived&nbsp;{&lt;br&gt;<br>
&nbsp;&amp;gt; &nbsp; &nbsp; &nbsp; &nbsp;MyBase&nbsp;xxx;&lt;br&gt;<br>
&nbsp;&amp;gt; &nbsp; &nbsp; &nbsp; &nbsp;foo&nbsp;bar;&lt;br&gt;<br>
&nbsp;&amp;gt;&nbsp; &nbsp; }&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;///===================&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;No,&nbsp;I&nbsp;mean:&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;struct&nbsp;NSObject&nbsp;{&nbsp;//&nbsp;for&nbsp;base&nbsp;classes&nbsp;in&nbsp;Objc&nbsp;hierarchy&nbsp;we&nbsp;holds&nbsp;pointer&nbsp;to&nbsp;Objective-C&nbsp;object&nbsp;in&nbsp;C#&nbsp;proxy&lt;/div&gt;<br>
&lt;div&gt; &nbsp; &nbsp;public&nbsp;IntPtr&nbsp;_handle;&lt;/div&gt;&lt;div&gt; &nbsp;  &lt;/div&gt;&lt;div&gt; &nbsp; &nbsp;public&nbsp;void&nbsp;SomeMethodAvailableForDerivedStructs()&nbsp;{&nbsp;somePInvoke(&nbsp;_handle&nbsp;);&nbsp;}&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;struct&nbsp;SomeBaseObjcProxy&nbsp;:&nbsp;NSObject&nbsp;{&nbsp;//&nbsp;that&nbsp;not&nbsp;available&nbsp;in&nbsp;C#,&nbsp;but&nbsp;such&nbsp;inheritance&nbsp;work&nbsp;well&nbsp;on&nbsp;CLR&nbsp;(MS&nbsp;VES&nbsp;implementation)&lt;/div&gt;<br>
&lt;div&gt; &nbsp; &nbsp;public&nbsp;void&nbsp;AnotherMethodAvailableForDerivedStructs()&nbsp;{&nbsp;somePInvoke(&nbsp;_handle&nbsp;);&nbsp;}&nbsp;//&nbsp;note&nbsp;that&nbsp;&amp;quot;_handle&amp;quot;&nbsp;is&nbsp;field&nbsp;of&nbsp;NSObject&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;///===================&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;<br>
In&nbsp;raw&nbsp;Objective-C&nbsp;you&nbsp;can&amp;#39;t&nbsp;work&nbsp;with&nbsp;OBJECTS&nbsp;directly&nbsp;but&nbsp;can&nbsp;work&nbsp;with&nbsp;them&nbsp;via&nbsp;POINTERS&nbsp;to&nbsp;OBJECTS.&nbsp;My&nbsp;approach&nbsp;-&nbsp;is&nbsp;represent&nbsp;such&nbsp;pointers&nbsp;via&nbsp;structs&nbsp;with&nbsp;size&nbsp;of&nbsp;such&nbsp;pointer.&nbsp;Creating&nbsp;classes&nbsp;(&nbsp;mobjc,monobjc,cocoa#&nbsp;)&nbsp;for&nbsp;such&nbsp;case&nbsp;leads&nbsp;to&nbsp;unnecessary&nbsp;GC&nbsp;overheads,&nbsp;structs&nbsp;there&nbsp;perform&nbsp;better.&lt;/div&gt;<br>
&lt;div&gt;&lt;/div&gt;&lt;div&gt;///===================&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&amp;gt;I&nbsp;took&nbsp;a&nbsp;more&nbsp;serious&nbsp;look&nbsp;at&nbsp;NObjective,&nbsp;and&nbsp;I&nbsp;have&nbsp;to&nbsp;say&nbsp;that&lt;br&gt;&amp;gt;even&nbsp;if&nbsp;it&nbsp;is&nbsp;fast,&nbsp;it&nbsp;does&nbsp;not&nbsp;support&nbsp;the&nbsp;C#&nbsp;override&nbsp;model&nbsp;to&lt;br&gt;&amp;gt;override&nbsp;settings&nbsp;in&nbsp;a&nbsp;base&nbsp;class. &nbsp;&nbsp;So&nbsp;it&nbsp;is&nbsp;not&nbsp;really&nbsp;suitable&nbsp;as&nbsp;a&nbsp;general&nbsp;purpose&nbsp;framework.&lt;br&gt;<br>
&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;All&nbsp;Objective-C&nbsp;methods&nbsp;are&nbsp;virtual&nbsp;by&nbsp;default&nbsp;in&nbsp;Objective-C&nbsp;runtime,&nbsp;so&nbsp;if&nbsp;method&nbsp;is&nbsp;redefined&nbsp;in&nbsp;derived&nbsp;Objective-C&nbsp;class&nbsp;there&nbsp;is&nbsp;no&nbsp;need&nbsp;to&nbsp;&amp;#39;override&amp;#39;&nbsp;it&nbsp;in&nbsp;generated&nbsp;proxy.&lt;/div&gt;&lt;div&gt;&lt;br&gt;<br>
&lt;/div&gt;&lt;div&gt;WBR,&lt;br&gt;Eugeny&nbsp;Grishul&lt;br&gt;&lt;/div&gt;<br>

</tt>
