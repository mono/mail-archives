<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] Ideas for a new command system
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:lluis%40ximian.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001897.html">
   <LINK REL="Next"  HREF="001895.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] Ideas for a new command system
   </H1>
    <B>Lluis Sanchez
    </B> 
    <A HREF="mailto:lluis%40ximian.com"
       TITLE="[MonoDevelop] Ideas for a new command system">lluis@ximian.com
       </A><BR>
    <I>Sun, 10 Apr 2005 13:05:53 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="001897.html">[MonoDevelop] Ideas for a new command system
</A></li>
        <LI> Next message: <A HREF="001895.html">[MonoDevelop] Problem running monodevelop on linux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1899">[ date ]</a>
              <a href="thread.html#1899">[ thread ]</a>
              <a href="subject.html#1899">[ subject ]</a>
              <a href="author.html#1899">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On dg, 2005-04-10 at 00:04 -0300, Rafael Teixeira wrote:
&gt;<i> Looks very nice. Just performance-wise I would be carefull to
</I>&gt;<i> transform the attributes metadata into some indexed form when first
</I>&gt;<i> scanning for command handlers to avoid repetitive reflection costs...
</I>
Yeah, that's the plan.

&gt;<i> May be a premature optimization, but I can't help thinking it will
</I>&gt;<i> effectively be needed to attain adequate UI responsiveness.
</I>&gt;<i> 
</I>&gt;<i> Have fun, 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> On Apr 8, 2005 9:22 PM, Lluis Sanchez &lt;<A HREF="mailto:lluis@ximian.com">lluis@ximian.com</A>&gt; wrote:
</I>&gt;<i> &gt; Hi!
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The next target in my quest for improving the architecture of MD is the
</I>&gt;<i> &gt; command system. There are two reasons why I don't like the current
</I>&gt;<i> &gt; design:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt;       * It is not possible to change the behavior of a command depending
</I>&gt;<i> &gt;         on the context in which it is run. For example, the Delete
</I>&gt;<i> &gt;         command deletes the selected text in the editor, but we should
</I>&gt;<i> &gt;         be able to use the same command for deleting the selected file
</I>&gt;<i> &gt;         in the solution pad (if the pad has the focus), or whatever. Any
</I>&gt;<i> &gt;         addin should be able to provide a custom behavior for an
</I>&gt;<i> &gt;         existing command.
</I>&gt;<i> &gt;       * It is not easy to handle the status of commands. Commands can be
</I>&gt;<i> &gt;         enabled/disabled using conditions, but conditions must be
</I>&gt;<i> &gt;         specified in the addin XML file and are very limited.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; What I propose is a very different approach, so feedback is greatly
</I>&gt;<i> &gt; welcome (BTW, the main concept is taken from MS's MFC class library, not
</I>&gt;<i> &gt; a great library, but I like the approach it uses for command handling).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; First of all, there is a global list of commands, which is independent
</I>&gt;<i> &gt; from where those commands are used. The command list would be
</I>&gt;<i> &gt; defined/extended in the addin xml like this:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &lt;Extension path = &quot;/SharpDevelop/Commands&quot;&gt;
</I>&gt;<i> &gt;         &lt;Command id = &quot;EditCommands.Copy&quot;
</I>&gt;<i> &gt;                         _label = &quot;Copy&quot;
</I>&gt;<i> &gt;                         icon = &quot;Icons.16x16.CopyIcon&quot;
</I>&gt;<i> &gt;                         shortcut = &quot;Control|C&quot;/&gt;
</I>&gt;<i> &gt;         &lt;Command id = &quot;EditCommands.Paste&quot;
</I>&gt;<i> &gt;                         _label = &quot;_Paste&quot;
</I>&gt;<i> &gt;                         icon = &quot;Icons.16x16.PasteIcon&quot;
</I>&gt;<i> &gt;                         shortcut = &quot;Control|V&quot;/&gt;
</I>&gt;<i> &gt;         &lt;Command id = &quot;EditCommands.Delete&quot;
</I>&gt;<i> &gt;                         _label = &quot;_Delete&quot;
</I>&gt;<i> &gt;                         icon = &quot;Icons.16x16.DeleteIcon&quot;
</I>&gt;<i> &gt;                         shortcut = &quot;Del&quot;/&gt;
</I>&gt;<i> &gt; &lt;/Extension&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Then, we can define menus and toolbars by refering those commands:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &lt;Extension path =
</I>&gt;<i> &gt; &quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/ProjectFileNode&quot;&gt;
</I>&gt;<i> &gt;         &lt;MenuItem id = &quot;Copy&quot; command = &quot;EditCommands.Copy&quot;/&gt;
</I>&gt;<i> &gt;         &lt;MenuItem id = &quot;Paste&quot; command = &quot;EditCommands.Paste&quot;/&gt;
</I>&gt;<i> &gt;         &lt;MenuItem id = &quot;Delete&quot; command = &quot;EditCommands.Delete&quot;/&gt;
</I>&gt;<i> &gt; &lt;/Extension&gt;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The big change is how commands are executed. Instead of implementing a
</I>&gt;<i> &gt; single class for each command, we can implement command handler methods
</I>&gt;<i> &gt; in any class. For example, to handle the Delete command in the text
</I>&gt;<i> &gt; editor I would write a handler like this:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [CommandHandler (EditCommands.Delete)]
</I>&gt;<i> &gt; void OnDeleteCommand ()
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt;         // Delete the selection
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; If we want to implement the Delete command in a custom pad, we would add
</I>&gt;<i> &gt; a similar command handler in that pad. So, we have two handlers for the
</I>&gt;<i> &gt; same command in two different classes. Which one of them will be
</I>&gt;<i> &gt; executed when clicking on the Delete menu item? It depends on the
</I>&gt;<i> &gt; context.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; When the command is clicked, the command manager looks for a command
</I>&gt;<i> &gt; handler by following a command route. This route begins at the widget
</I>&gt;<i> &gt; that has the focus and goes up in the parent chain. This means that if
</I>&gt;<i> &gt; we are editing some text in the editor, the delete command handler in
</I>&gt;<i> &gt; the editor will be executed. If we move the focus to the solution pad,
</I>&gt;<i> &gt; then the pad will get the commands.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The command manager will also automatically disable or hide commands for
</I>&gt;<i> &gt; which there isn't a handler in the active command route. This gives a
</I>&gt;<i> &gt; lot a consistency to the menu and toolbars, since options and buttons
</I>&gt;<i> &gt; will be grayed out when they can't be used (and there is no need to
</I>&gt;<i> &gt; write code for this, it comes for free).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; If the status of a command depends on some internal logic, we can
</I>&gt;<i> &gt; implement that logic in some special command update handlers. For
</I>&gt;<i> &gt; example:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; [CommandUpdateHandler (EditCommands.Delete)]
</I>&gt;<i> &gt; void OnUpdateDeleteCommand (CommandInfo commandInfo)
</I>&gt;<i> &gt; {
</I>&gt;<i> &gt;         if (the_selected_tree_node_can_be_deleted()) {
</I>&gt;<i> &gt;                 commandInfo.Enabled = true;
</I>&gt;<i> &gt;                 commandInfo.Text = &quot;Delete &quot; + current_node.Name;
</I>&gt;<i> &gt;         } else {
</I>&gt;<i> &gt;                 commandInfo.Enabled = false;
</I>&gt;<i> &gt;         }
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The command manager will look for a command update handler in the
</I>&gt;<i> &gt; current command route. If found, it will call the handler and will
</I>&gt;<i> &gt; update the menu items and buttons linked to that command accordingly. If
</I>&gt;<i> &gt; not found, it will disable them.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; This is more or less the idea. There are many more details, such as
</I>&gt;<i> &gt; being able to customize the command route, defining global command
</I>&gt;<i> &gt; handlers for global commands, menu builders for the &quot;Windows&quot; menu list,
</I>&gt;<i> &gt; etc., but I just described the fundamental idea.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Comments?
</I>&gt;<i> &gt; Lluis.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; _______________________________________________
</I>&gt;<i> &gt; Monodevelop-list mailing list
</I>&gt;<i> &gt; <A HREF="mailto:Monodevelop-list@lists.ximian.com">Monodevelop-list@lists.ximian.com</A>
</I>&gt;<i> &gt; <A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-list">http://lists.ximian.com/mailman/listinfo/monodevelop-list</A>
</I>&gt;<i> &gt; 
</I>&gt;<i> 
</I>&gt;<i> 
</I>

</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001897.html">[MonoDevelop] Ideas for a new command system
</A></li>
	<LI> Next message: <A HREF="001895.html">[MonoDevelop] Problem running monodevelop on linux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1899">[ date ]</a>
              <a href="thread.html#1899">[ thread ]</a>
              <a href="subject.html#1899">[ subject ]</a>
              <a href="author.html#1899">[ author ]</a>
         </LI>
       </UL>
</body></html>
