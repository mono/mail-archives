<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] monoquery patch for svn r2117
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:chris%40mosaix.net">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001587.html">
   <LINK REL="Next"  HREF="001589.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] monoquery patch for svn r2117
   </H1>
    <B>Christian Hergert
    </B> 
    <A HREF="mailto:chris%40mosaix.net"
       TITLE="[MonoDevelop] monoquery patch for svn r2117">chris@mosaix.net
       </A><BR>
    <I>Thu, 06 Jan 2005 15:01:41 -0800</I>
    <P><UL>
        <LI> Previous message: <A HREF="001587.html">[MonoDevelop] Changes in SVN
</A></li>
        <LI> Next message: <A HREF="001589.html">[MonoDevelop] monoquery patch for svn r2117
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1588">[ date ]</a>
              <a href="thread.html#1588">[ thread ]</a>
              <a href="subject.html#1588">[ subject ]</a>
              <a href="author.html#1588">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>--=-xeykHfuLZqTBWgiH/78s
Content-Type: text/plain
Content-Transfer-Encoding: 7bit

MD Team,

attached is a test patch for monoquery to svn release 2117. It is now
placed in /Extras since todd has done significant source layout changes.
Please test it out and send suggestions/comments. im usually available
on irc as chrish01.

~ chris

--=-xeykHfuLZqTBWgiH/78s
Content-Disposition: attachment; filename=monoquery_0.4.0_r2117.patch
Content-Type: text/x-patch; name=monoquery_0.4.0_r2117.patch; charset=us-ascii
Content-Transfer-Encoding: 8bit

Index: configure.in
===================================================================
--- configure.in	(revision 2117)
+++ configure.in	(working copy)
@@ -207,6 +207,8 @@
 Core/src/AddIns/prj2make-sharp-lib/AssemblyInfo.cs
 Core/src/AddIns/BackendBindings/NemerleBinding/NemerleBindingExecutionServices.cs
 Core/src/AddIns/BackendBindings/CSharpBinding/CSharpBindingExecutionManager.cs
+Extras/Makefile
+Extras/MonoQuery/Makefile
 ])
 
 echo &quot;---&quot;
Index: Core/src/MonoDevelop.Gui.Widgets/DataGrid/DataGrid.cs
===================================================================
--- Core/src/MonoDevelop.Gui.Widgets/DataGrid/DataGrid.cs	(revision 0)
+++ Core/src/MonoDevelop.Gui.Widgets/DataGrid/DataGrid.cs	(revision 0)
@@ -0,0 +1,305 @@
+//
+// DataGrid - attempt at creating a DataGrid for GTK#
+//            using a GTK# TreeView.  The goal is to have similar
+//            functionality to a System.Windows.Forms.DataGrid
+//            or System.Web.UI.WebControls.DataGrid.  This includes
+//            data binding support.
+//    
+// Based on the sample/TreeViewDemo.cs
+//
+// Author: Kristian Rietveld &lt;<A HREF="mailto:kris@gtk.org">kris@gtk.org</A>&gt;
+//         Daniel Morgan &lt;<A HREF="mailto:danmorg@sc.rr.com">danmorg@sc.rr.com</A>&gt;
+//         Christian Hergert &lt;<A HREF="mailto:chris@mosaix.net">chris@mosaix.net</A>&gt;
+//
+// (c) 2002 Kristian Rietveld
+// (c) 2002 Daniel Morgan
+// (c) 2004 Christian Hergert
+
+using System;
+using System.Collections;
+using System.ComponentModel;
+using System.Reflection;
+using System.Text;
+using GLib;
+using Gtk;
+using GtkSharp;
+using System.Runtime.InteropServices;
+
+namespace MonoDevelop.Gui.Widgets
+{
+	/// &lt;summary&gt;
+	/// Column for inserting into a DataGrid
+	/// &lt;/summary&gt;
+	public class DataGridColumn 
+	{
+		private string columnName = &quot;&quot;;
+		private Gtk.TreeViewColumn treeViewColumn = null;
+		
+		/// &lt;summary&gt;
+		/// Title for the Column
+		/// &lt;/summary&gt;
+		public string ColumnName {
+			get {
+				return columnName;
+			}
+			set {
+				columnName = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// Gtk Column widget
+		/// &lt;/summary&gt;
+		public Gtk.TreeViewColumn TreeViewColumn {
+			get {
+				return treeViewColumn;
+			}
+			set {
+				treeViewColumn = value;
+			}
+		}
+	}
+
+	public class DataGrid : Gtk.VBox
+	{
+		private Gtk.ListStore store = null;
+		private Gtk.TreeView treeView = null;
+
+		public DataGridColumn[] gridColumns = null;
+
+		public DataGrid () : base(false, 4) 
+		{		
+			ScrolledWindow sw = new ScrolledWindow ();
+			this.PackStart (sw, true, true, 0);
+
+			treeView = new Gtk.TreeView (store);
+
+			sw.Add (treeView);
+		}
+
+		// FIXME: need to place in a base class
+		//        the DataSource, DataMember, DataBind()
+		//        public members.
+		//        maybe we can call the base class
+		//        BaseDataList for GTK#?
+
+		private object dataSource = null;
+
+		private string dataMember = &quot;&quot;;
+
+		public object DataSource {
+			get {
+				return dataSource;
+			}
+			set {
+				dataSource = value;
+			}
+		}
+
+		public string DataMember {
+			get {
+				return dataMember;
+			}
+			set {
+				dataMember = value;
+			}
+		}
+
+		public void DataBind () 
+		{
+			Clear ();
+
+			System.Object o = null;
+			o = GetResolvedDataSource (DataSource, DataMember);
+			IEnumerable ie = (IEnumerable) o;
+			ITypedList tlist = (ITypedList) o;
+
+			// FIXME: does not belong in this base method
+			Gtk.TreeIter iter = new Gtk.TreeIter ();
+									
+			PropertyDescriptorCollection pdc = tlist.GetItemProperties (new PropertyDescriptor[0]);
+
+			// FIXME: does not belong in this base method
+			gridColumns = new DataGridColumn[pdc.Count];
+
+			// FIXME: does not belong in base method
+			// define the columns in the treeview store
+			// based on the schema of the result
+			/*
+			uint[] theTypes = new uint[pdc.Count];
+			for (int col = 0; col &lt; pdc.Count; col++) {
+				theTypes[col] = (int) TypeFundamentals.TypeString;
+			}
+			*/
+			GType [] theTypes = new GType[pdc.Count];
+			for ( int col=0; col&lt;pdc.Count; col++ ) {
+				theTypes[col] = (GType)GType.String;
+			}
+			store.SetColumnTypes (theTypes);
+
+			// FIXME: does not belong in this base method
+			int colndx = -1;
+			foreach (PropertyDescriptor pd in pdc) {
+				colndx ++;
+				gridColumns[colndx] = new DataGridColumn ();
+				gridColumns[colndx].ColumnName = pd.Name;				
+			}
+
+			foreach (System.Object obj in ie) {
+				ICustomTypeDescriptor custom = (ICustomTypeDescriptor) obj;
+				PropertyDescriptorCollection properties;
+				properties = custom.GetProperties ();
+				
+				iter = NewRow ();
+				int cv = 0;
+				foreach (PropertyDescriptor property in properties) {
+					object oPropValue = property.GetValue (obj);
+					string sPropValue = oPropValue.ToString ();
+					
+					// FIXME: does not belong in this base method
+					SetColumnValue (iter, cv, sPropValue);
+
+					cv++;
+				}
+			}
+
+			// FIXME: does not belong in this base method
+			treeView.Model = store;
+			AutoCreateTreeViewColumns ( treeView );
+		}
+
+		// borrowed from Mono's System.Web implementation
+		protected IEnumerable GetResolvedDataSource(object source, string member) 
+		{
+			if (source != null &amp;&amp; source is IListSource) {
+				IListSource src = (IListSource) source;
+				IList list = src.GetList ();
+				if (!src.ContainsListCollection) {
+					return list;
+				}
+				if (list != null &amp;&amp; list is ITypedList) {
+
+					ITypedList tlist = (ITypedList) list;
+					PropertyDescriptorCollection pdc = tlist.GetItemProperties (new PropertyDescriptor[0]);
+					if (pdc != null &amp;&amp; pdc.Count &gt; 0) {
+						PropertyDescriptor pd = null;
+						if (member != null &amp;&amp; member.Length &gt; 0) {
+							pd = pdc.Find (member, true);
+						} else {
+							pd = pdc[0];
+						}
+						if (pd != null) {
+							object rv = pd.GetValue (list[0]);
+							if (rv != null &amp;&amp; rv is IEnumerable) {
+								return (IEnumerable)rv;
+							}
+						}
+						throw new Exception (&quot;ListSource_Missing_DataMember&quot;);
+					}
+					throw new Exception (&quot;ListSource_Without_DataMembers&quot;);
+				}
+			}
+			if (source is IEnumerable) {
+				return (IEnumerable)source;
+			}
+			return null;
+		}
+
+		public void Clear () 
+		{
+			if (store != null) {
+				store.Clear ();
+				store = null;
+				//store = new ListStore ((int)TypeFundamentals.TypeString);
+				store = new ListStore( GType.String );
+			}
+			else {
+				//store = new ListStore ((int)TypeFundamentals.TypeString);
+				store = new ListStore( GType.String );
+			}	
+
+			if (gridColumns != null) {
+				for (int c = 0; c &lt; gridColumns.Length; c++) {
+					if (gridColumns[c] != null) {
+						if (gridColumns[c].TreeViewColumn != null) {
+							treeView.RemoveColumn (gridColumns[c].TreeViewColumn);
+							gridColumns[c].TreeViewColumn = null;
+						}
+						gridColumns[c] = null;
+					}
+				}
+				gridColumns = null;
+			}
+		}
+
+		// for DEBUG only
+		public void AppendText (string text) 
+		{
+			Console.WriteLine (&quot;DataGrid DEBUG: &quot; + text);
+			Console.Out.Flush ();
+		}
+
+		public TreeIter NewRow () 
+		{ 
+			/*
+			TreeIter rowTreeIter = new TreeIter();
+			store.Append (out rowTreeIter);
+			return rowTreeIter;
+			*/
+			return store.Append();
+		}
+
+		public void AddRow (object[] columnValues) 
+		{	
+			TreeIter iter = NewRow ();			
+			for(int col = 0; col &lt; columnValues.Length; col++) {
+				string cellValue = columnValues[col].ToString ();
+				SetColumnValue (iter, col, cellValue);
+			}
+		}
+
+		public void SetColumnValue (TreeIter iter, int column, string value) 
+		{
+			GLib.Value cell = new GLib.Value (value);
+			store.SetValue (iter, column, cell);	
+		}
+
+		private void AutoCreateTreeViewColumns (Gtk.TreeView theTreeView) 
+		{
+			for(int col = 0; col &lt; gridColumns.Length; col++) {
+				// escape underscore _ because it is used
+				// as the underline in menus and labels
+				StringBuilder name = new StringBuilder ();
+				foreach (char ch in gridColumns[col].ColumnName) {
+					if (ch == '_')
+						name.Append (&quot;__&quot;);
+					else
+						name.Append (ch);
+				}
+				TreeViewColumn tvc;
+				tvc = CreateColumn (theTreeView, col, 
+						name.ToString ());
+				theTreeView.AppendColumn (tvc);
+			}
+		}
+
+		// TODO: maybe need to create 
+		// a DataGridColumnCollection of DataGridColumn
+		// and a DataGridColumn contain a TreeViewColumn
+		public TreeViewColumn CreateColumn (Gtk.TreeView theTreeView, int col, 
+						string columnName) 
+		{
+			TreeViewColumn NameCol = new TreeViewColumn ();		 
+			CellRenderer NameRenderer = new CellRendererText ();
+			
+			NameCol.Title = columnName;
+			NameCol.PackStart (NameRenderer, true);
+			NameCol.AddAttribute (NameRenderer, &quot;text&quot;, col);
+
+			gridColumns[col].TreeViewColumn = NameCol;
+			
+			return NameCol;
+		}
+	}
+}
+
Index: Core/src/MonoDevelop.Gui.Widgets/Makefile.am
===================================================================
--- Core/src/MonoDevelop.Gui.Widgets/Makefile.am	(revision 2117)
+++ Core/src/MonoDevelop.Gui.Widgets/Makefile.am	(working copy)
@@ -25,7 +25,8 @@
 Navbar/Navbar.cs \
 TabLabel/TabLabel.cs \
 GladeWidgetExtract/GladeWidgetExtract.cs \
-DragNotebook/DragNotebook.cs
+DragNotebook/DragNotebook.cs \
+DataGrid/DataGrid.cs
 
 
 build_sources = $(addprefix $(srcdir)/, $(FILES))
Index: Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs
===================================================================
--- Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs	(revision 2117)
+++ Core/src/MonoDevelop.Base/Gui/Workbench/Layouts/SdiWorkspaceLayout.cs	(working copy)
@@ -273,7 +273,8 @@
 				&quot;MonoDevelop.Gui.Pads.HelpTree&quot;,
 				&quot;MonoDevelop.EditorBindings.Gui.Pads.CompilerMessageView&quot;,
 				//&quot;MonoDevelop.Gui.Pads.TerminalPad&quot;,
-				&quot;MonoDevelop.Gui.Pads.HelpBrowser&quot;
+				&quot;MonoDevelop.Gui.Pads.HelpBrowser&quot;,
+				&quot;MonoQuery.Pads.MonoQueryView&quot;
 			};
 
 			string[] debugPads = new string[] {
Index: Core/src/MonoDevelop.Core/AddIn.xsd
===================================================================
--- Core/src/MonoDevelop.Core/AddIn.xsd	(revision 2117)
+++ Core/src/MonoDevelop.Core/AddIn.xsd	(working copy)
@@ -39,6 +39,7 @@
 			&lt;xs:element ref=&quot;MenuItem&quot;/&gt;
 			&lt;xs:element ref=&quot;FileTemplate&quot;/&gt;
 			&lt;xs:element ref=&quot;ProjectTemplate&quot;/&gt;
+			&lt;xs:element ref=&quot;MonoQueryConnection&quot;/&gt;
 		&lt;/xs:choice&gt;
 		&lt;xs:attribute name=&quot;path&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
 	&lt;/xs:complexType&gt;
@@ -214,6 +215,17 @@
 		&lt;/xs:complexContent&gt;
 	&lt;/xs:complexType&gt;
 	&lt;xs:element name=&quot;MenuItem&quot; type=&quot;MenuItem&quot;/&gt;
+	&lt;xs:complexType name=&quot;MonoQueryConnection&quot;&gt;
+		&lt;xs:complexContent&gt;
+			&lt;xs:extension base=&quot;AbstractCodon&quot;&gt;
+				&lt;xs:attribute name=&quot;schema&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+				&lt;xs:attribute name=&quot;node&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+				&lt;xs:attribute name=&quot;description&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
+				&lt;xs:attribute name=&quot;showUnsuported&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
+			&lt;/xs:extension&gt;
+		&lt;/xs:complexContent&gt;
+	&lt;/xs:complexType&gt;
+	&lt;xs:element name=&quot;MonoQueryConnection&quot; type=&quot;MonoQueryConnection&quot;/&gt;
 	&lt;xs:complexType name=&quot;ToolbarItem&quot;&gt;
 		&lt;xs:complexContent&gt;
 			&lt;xs:extension base=&quot;AbstractCodon&quot;&gt;
Index: Extras/Makefile.am
===================================================================
--- Extras/Makefile.am	(revision 0)
+++ Extras/Makefile.am	(revision 0)
@@ -0,0 +1,3 @@
+
+#SUBDIRS = PythonBinding MonoQuery
+SUBDIRS = MonoQuery
Index: Extras/MonoQuery/MonoQuery.prjx
===================================================================
--- Extras/MonoQuery/MonoQuery.prjx	(revision 0)
+++ Extras/MonoQuery/MonoQuery.prjx	(revision 0)
@@ -0,0 +1,86 @@
+&lt;Project name=&quot;MonoQuery&quot; description=&quot;&quot; newfilesearch=&quot;None&quot; enableviewstate=&quot;True&quot; version=&quot;1.1&quot; projecttype=&quot;C#&quot;&gt;
+  &lt;Contents&gt;
+    &lt;File name=&quot;./AssemblyInfo.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./MonoQueryView.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/MonoQueryPanel.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/MonoQueryTree/MonoQueryTree.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/MonoQueryTree&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/MonoQueryTree/MonoQueryNodesRoot.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./SchemaClass/MonoQuerySchemaClass.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Commands&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Commands/MonoQueryCommands.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Collection&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/Interface/IMonoQueryNode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/Abstract/AbstractMonoQueryNode.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/MonoQueryTree/MonoQueryDataNodes.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/Interface&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/DataView&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/DataView/MonoQueryDataView.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Connection&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Collection/MonoQueryStringDictionary.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./SchemaClass/Abstract/AbstractMonoQuerySchemaClass.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Connection/Abstract/AbstractMonoQueryConnectionWrapper.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Codons&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Codons/MonoQueryConnectionCodon.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./MonoQuery.addin.xml&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Connection/Interface&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./SchemaClass/Interface/ISchemaClass.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Collection/MonoQuerySchemaClassCollection.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Connection/Interface/IConnection.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Collection/MonoQueryListDictionary.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Commands/Abstract/AbstractMonoQueryCommand.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./SchemaClass&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./SchemaClass/Interface&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/DataView/SQLParameterInput.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Exceptions&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Exceptions/ConnectionStringException.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Exceptions/OpenConnectionException.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Exceptions/ExecuteSQLException.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Exceptions/ExecuteProcedureException.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Exceptions/Abstract/MonoQueryAbstractException.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Collection/MonoQueryParameterCollection.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/Forms&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/Forms/CreateConnectionDruid.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Services&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Services/MonoQueryService.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Connection/Npgsql&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Connection/Npgsql/NpgsqlConnectionWrapper.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/Forms/New Folder&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/Forms/Glade/monoquery.glade&quot; subtype=&quot;Code&quot; buildaction=&quot;Nothing&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Connection/Mysql/MysqlConnectionWrapper.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Collection/ConnectionProviderDescriptor.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/SqlQueryView&quot; subtype=&quot;Directory&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+    &lt;File name=&quot;./Gui/SqlQueryView/SqlQueryView.cs&quot; subtype=&quot;Code&quot; buildaction=&quot;Compile&quot; dependson=&quot;&quot; data=&quot;&quot; /&gt;
+  &lt;/Contents&gt;
+  &lt;References&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;System.Data, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;Npgsql, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;glade-sharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;ByteFX.Data, Version=0.7.6.1, Culture=neutral, PublicKeyToken=0738eb9f132ed756&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;gtksourceview-sharp, Version=1.0.0.1, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;../../build/bin/MonoDevelop.Base.dll&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;../../build/bin/MonoDevelop.Core.dll&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Assembly&quot; refto=&quot;../../build/bin/MonoDevelop.Gui.Widgets.dll&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;gtk-sharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; localcopy=&quot;True&quot; /&gt;
+    &lt;Reference type=&quot;Gac&quot; refto=&quot;gtksourceview-sharp, Version=1.0.0.2, Culture=neutral, PublicKeyToken=35e10195dab3c99f&quot; localcopy=&quot;True&quot; /&gt;
+  &lt;/References&gt;
+  &lt;DeploymentInformation target=&quot;&quot; script=&quot;&quot; strategy=&quot;File&quot; /&gt;
+  &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+    &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+    &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+    &lt;Output directory=&quot;../bin/Debug&quot; assembly=&quot;MonoQuery&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+  &lt;/Configuration&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Debug&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;../bin/Debug&quot; assembly=&quot;MonoQuery&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration runwithwarnings=&quot;False&quot; name=&quot;Release&quot;&gt;
+      &lt;CodeGeneration runtime=&quot;MsNet&quot; compiler=&quot;Csc&quot; warninglevel=&quot;4&quot; nowarn=&quot;&quot; includedebuginformation=&quot;True&quot; optimize=&quot;True&quot; unsafecodeallowed=&quot;False&quot; generateoverflowchecks=&quot;True&quot; mainclass=&quot;&quot; target=&quot;Library&quot; definesymbols=&quot;&quot; generatexmldocumentation=&quot;False&quot; win32Icon=&quot;&quot; /&gt;
+      &lt;Execution commandlineparameters=&quot;&quot; consolepause=&quot;True&quot; /&gt;
+      &lt;Output directory=&quot;../bin/Release&quot; assembly=&quot;MonoQuery&quot; executeScript=&quot;&quot; executeBeforeBuild=&quot;&quot; executeAfterBuild=&quot;&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Project&gt;
\ No newline at end of file
Index: Extras/MonoQuery/Exceptions/Abstract/MonoQueryAbstractException.cs
===================================================================
--- Extras/MonoQuery/Exceptions/Abstract/MonoQueryAbstractException.cs	(revision 0)
+++ Extras/MonoQuery/Exceptions/Abstract/MonoQueryAbstractException.cs	(revision 0)
@@ -0,0 +1,15 @@
+using System;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+using MonoQuery.SchemaClass;
+
+namespace MonoQuery.Exceptions
+{
+	public abstract class MonoQueryAbstractException : Exception
+	{					
+		
+	}
+	
+}
Index: Extras/MonoQuery/Exceptions/OpenConnectionException.cs
===================================================================
--- Extras/MonoQuery/Exceptions/OpenConnectionException.cs	(revision 0)
+++ Extras/MonoQuery/Exceptions/OpenConnectionException.cs	(revision 0)
@@ -0,0 +1,39 @@
+using System;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+using MonoQuery.SchemaClass;
+
+
+namespace MonoQuery.Exceptions
+{
+	public class OpenConnectionException : Exception
+	{								
+		public OpenConnectionException( ) : base( GettextCatalog.GetString( &quot;Open Error&quot; ) )
+		{			
+		}
+		
+		public OpenConnectionException( ISchemaClass schema ) : base( GettextCatalog.GetString( &quot;Open Error&quot; )
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;-----------------&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;(&quot; + schema.Connection.ConnectionString + &quot;)&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;(&quot; + schema.Connection.Name + &quot;)&quot;
+		                                                               )
+		{
+		}		
+		
+		public OpenConnectionException( string message ) : base( GettextCatalog.GetString( &quot;Open Error&quot; ) 
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;-----------------&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + message )
+       {		                                                               	
+       }
+		                                                               
+
+	}
+	
+}
Index: Extras/MonoQuery/Exceptions/ExecuteSQLException.cs
===================================================================
--- Extras/MonoQuery/Exceptions/ExecuteSQLException.cs	(revision 0)
+++ Extras/MonoQuery/Exceptions/ExecuteSQLException.cs	(revision 0)
@@ -0,0 +1,38 @@
+using System;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+using MonoQuery.SchemaClass;
+
+namespace MonoQuery.Exceptions
+{
+	public class ExecuteSQLException : Exception
+	{		
+		
+		public ExecuteSQLException( ) : base( GettextCatalog.GetString( &quot;SQL Exception&quot; ) )
+		{			
+		}
+		
+		public ExecuteSQLException( ISchemaClass schema ) : base( GettextCatalog.GetString( &quot;SQL Exception&quot; ) 
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;-----------------&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;(&quot; + schema.Connection.ConnectionString + &quot;)&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;(&quot; + schema.Connection.Name + &quot;)&quot;
+		                                                               )
+		{
+		}		
+		
+		public ExecuteSQLException( string message ) : base( GettextCatalog.GetString( &quot;SQL Exception&quot; ) 
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;-----------------&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + message )	
+       {		                                                               	
+       }
+		                                                               
+	}
+	
+}
Index: Extras/MonoQuery/Exceptions/ConnectionStringException.cs
===================================================================
--- Extras/MonoQuery/Exceptions/ConnectionStringException.cs	(revision 0)
+++ Extras/MonoQuery/Exceptions/ConnectionStringException.cs	(revision 0)
@@ -0,0 +1,36 @@
+using System;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+using MonoQuery.SchemaClass;
+
+namespace MonoQuery.Exceptions
+{
+	public class ConnectionStringException : Exception
+	{				
+		public ConnectionStringException( ) : base( GettextCatalog.GetString( &quot;Wrong Connection String&quot; ) )
+		{			
+		}
+		
+		public ConnectionStringException( ISchemaClass schema ) : base( GettextCatalog.GetString( &quot;Wrong Connection String&quot; )
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;-----------------&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;(&quot; + schema.Connection.ConnectionString + &quot;)&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;(&quot; + schema.Connection.Name + &quot;)&quot;
+		                                                               )
+		{
+		}		
+		
+		public ConnectionStringException( string message ) : base( GettextCatalog.GetString( &quot;Wrong Connection String&quot; )
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;-----------------&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + message )
+		{
+		}					
+	}
+	
+}
Index: Extras/MonoQuery/Exceptions/ExecuteProcedureException.cs
===================================================================
--- Extras/MonoQuery/Exceptions/ExecuteProcedureException.cs	(revision 0)
+++ Extras/MonoQuery/Exceptions/ExecuteProcedureException.cs	(revision 0)
@@ -0,0 +1,36 @@
+using System;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+using MonoQuery.SchemaClass;
+
+namespace MonoQuery.Exceptions
+{
+	public class ExecuteProcedureException : Exception
+	{								
+		public ExecuteProcedureException( ) : base( GettextCatalog.GetString( &quot;Procedure Exception&quot; ) )
+		{			
+		}
+		
+		public ExecuteProcedureException( ISchemaClass schema ) : base( GettextCatalog.GetString( &quot;Procedure Exception&quot; ) 
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;-----------------&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;(&quot; + schema.Connection.ConnectionString + &quot;)&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;(&quot; + schema.Connection.Name + &quot;)&quot;
+		                                                               )
+		{
+		}		
+		
+		public ExecuteProcedureException( string message ) : base( GettextCatalog.GetString( &quot;Procedure Exception&quot; ) 
+		                                                               + &quot;\n\r&quot;
+		                                                               + &quot;-----------------&quot;
+		                                                               + &quot;\n\r&quot;
+		                                                               + message )			
+       {		                                                               	
+       }
+	}
+	
+}
Index: Extras/MonoQuery/Services/MonoQueryService.cs
===================================================================
--- Extras/MonoQuery/Services/MonoQueryService.cs	(revision 0)
+++ Extras/MonoQuery/Services/MonoQueryService.cs	(revision 0)
@@ -0,0 +1,78 @@
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Core.AddIns;
+
+using MonoQuery.Collections;
+using MonoQuery.Codons;
+using MonoQuery.Gui.TreeView;
+
+namespace MonoQuery.Services
+{
+	public class MonoQueryService : AbstractService
+	{
+		#region Private Properties
+		private ArrayList providers;
+		private MonoQueryTree tree;
+		#endregion
+		
+		#region Public Properties
+		public ArrayList Providers
+		{
+			get { return providers; }
+		}
+		public MonoQueryTree Tree
+		{
+			get { return tree; }
+			set { tree = value; }
+		}
+		#endregion
+		
+		#region Constructors
+		public MonoQueryService() : base()
+		{
+			// Build Providers List
+			this.providers = new ArrayList();
+			this.BuildProviders();
+			
+			// Load saved connections
+			LoadConnections();
+		}
+		#endregion
+		
+		#region Private Methods
+		private void BuildProviders()
+		{
+			IAddInTreeNode AddinNode;
+			
+			AddinNode = (IAddInTreeNode)AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/MonoQuery/Connection&quot;);
+			foreach ( DictionaryEntry entryChild in AddinNode.ChildNodes)
+			{
+				IAddInTreeNode ChildNode = entryChild.Value as IAddInTreeNode;
+				if ( ChildNode != null )
+				{
+					MonoQueryConnectionCodon codon = ChildNode.Codon as MonoQueryConnectionCodon;
+					if ( codon != null )
+					{
+						if ( codon.Node == &quot;MonoQuery.Gui.TreeView.MonoQueryNodeConnection&quot; )
+						{
+							Type type = System.Type.GetType( codon.Schema );
+							if ( type != null ) {
+								this.Providers.Add( new ConnectionProviderDescriptor( codon.Description, type ) );
+							}
+						}
+					}					
+				}
+			}
+		}
+		
+		private void LoadConnections()
+		{
+// FIXME: Load connections from monodevelop serialization system.
+			
+		}
+		#endregion
+	}
+}
\ No newline at end of file
Index: Extras/MonoQuery/Gui/Interface/IMonoQueryNode.cs
===================================================================
--- Extras/MonoQuery/Gui/Interface/IMonoQueryNode.cs	(revision 0)
+++ Extras/MonoQuery/Gui/Interface/IMonoQueryNode.cs	(revision 0)
@@ -0,0 +1,60 @@
+namespace MonoQuery.Gui.TreeView
+{	
+	using MonoQuery.SchemaClass;
+	using MonoQuery.Connection;
+	using MonoQuery.Collections;
+	
+public interface IMonoQueryNode
+{
+	///&lt;summary&gt;
+	/// &lt;returns&gt; Path to a string #develop menu command object.&lt;/returns&gt;
+	/// &lt;remarks&gt;You should add this extension path in the addin file.&lt;/remarks&gt;
+	/// &lt;/summary&gt;
+   	string AddinContextMenu { get; }
+   	
+   	///&lt;summary&gt;
+   	/// His schema class from wich to displayed data informations.
+   	///&lt;/summary&gt;
+   	ISchemaClass SchemaClass { get; }   	   	
+   	
+   	///&lt;summary&gt;
+   	/// the &lt;see cref=&quot;.IMonoQueryNode.SchemaClass&quot;&gt;SchemaClass&lt;/see&gt;'s connection.
+   	///&lt;/summary&gt;
+   	IConnection  Connection { get; }
+   	
+	///&lt;summary&gt;
+	/// Those, are list of the childs schema.( columns, etc etc )
+	/// i am using a dictionnary because is more simplest to write 
+	/// &lt;code&gt;Entities[&quot;PROCEDURES&quot;]&lt;/code&gt; than &lt;code&gt;Entities[0]&lt;/code&gt;.
+	///&lt;/summary&gt;		
+	MonoQueryListDictionary Entities { get; }
+   	
+   	
+	///&lt;summary&gt;
+	/// Calls the &lt;see cref=&quot;.IMonoQueryNode.Clear()&quot;&gt;Clear()&lt;/see&gt; method.
+	/// Calls the &lt;see cref=&quot;.ISchemaClass.Refresh()&quot;&gt;Refresh()&lt;/see&gt; method of his &lt;see cref=&quot;.IMonoQueryNode.SchemaClass&quot;&gt;SchemaClass&lt;/see&gt; member.
+	/// Calls the &lt;see cref=&quot;.ISchemaClass.BuildsChilds()&quot;&gt;BuildsChild()&lt;/see&gt; method.
+	/// &lt;/summary&gt;   	
+   	void Refresh();	
+	
+	///&lt;summary&gt;
+	/// Calls the &lt;code&gt;Clear()&lt;/code&gt; method of each child nodes.
+	/// Calls the &lt;see cref=&quot;.ISchemaClass.Clear()&quot;&gt;Clear()&lt;/see&gt; methode of his &lt;see cref=&quot;.IMonoQueryNode.SchemaClass&quot;&gt;SchemaClass&lt;/see&gt; member.
+	/// Remove each child nodes.
+	/// &lt;/summary&gt;
+	void Clear();
+	
+	///&lt;summary&gt;
+	/// For a Table or a View extract data.
+	/// For a stocked procedure, execute it :o).
+	/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+	/// &lt;/summary&gt;
+	void Execute( int rows );
+	
+	///&lt;summary&gt;
+	/// Builds childs &lt;see cref=&quot;.IMonoQueryNode&quot;&gt;IMonoQueryNode&lt;/see&gt;
+	/// &lt;/summary&gt;
+	void BuildsChilds();	
+}
+
+}
Index: Extras/MonoQuery/Gui/SqlQueryView/SqlQueryView.cs
===================================================================
--- Extras/MonoQuery/Gui/SqlQueryView/SqlQueryView.cs	(revision 0)
+++ Extras/MonoQuery/Gui/SqlQueryView/SqlQueryView.cs	(revision 0)
@@ -0,0 +1,141 @@
+
+using System;
+using System.Data;
+
+using Gtk;
+using GtkSourceView;
+
+using MonoQuery.Connection;
+using MonoDevelop;
+using MonoDevelop.Gui;
+
+namespace MonoQuery.Gui.SqlQueryView
+{
+	/// &lt;summary&gt;
+	/// SQL Query View to execute sql queries from a MonoQuery IConnection.
+	/// &lt;/summary&gt;
+	public class SqlQueryView : AbstractViewContent
+	{
+		#region // Private Properties
+		
+		private IConnection connection = null;
+		private VPaned vpaned = null;
+		private SourceView sourceView = null;
+		private SourceBuffer sourceBuffer = null;
+		private ScrolledWindow sourceScroller = null;
+		private VBox vbox1 = null;
+		private Notebook notebook = null;
+		private TextView logView = null;
+		private ScrolledWindow logScroller = null;
+		private MonoDevelop.Gui.Widgets.DataGrid outputView = null;
+		private SqlQueryViewToolbar toolbar = null; 
+		
+		#endregion // End Private Properties
+		
+		/// &lt;summary&gt;
+		/// Default constructor. Setup our gui widgets and IConnection
+		/// &lt;/summary&gt;
+		public SqlQueryView( IConnection conn ) : base()
+		{
+			this.connection = conn;
+			this.UntitledName = Connection.Name;
+			
+			this.vpaned = new VPaned();
+			
+			this.vbox1 = new VBox();
+			this.toolbar = new SqlQueryViewToolbar();
+			this.toolbar.Run += new EventHandler( OnQueryRun );
+			this.vbox1.PackStart( this.toolbar, false, false, 0 );
+			
+			SourceLanguagesManager lm = new SourceLanguagesManager();
+			this.sourceBuffer = new SourceBuffer(
+				lm.GetLanguageFromMimeType(&quot;text/x-sql&quot;) );
+			this.sourceBuffer.Highlight = true;
+			
+			this.sourceView = new SourceView( sourceBuffer );
+			this.sourceScroller = new ScrolledWindow();
+			this.sourceScroller.Add( sourceView );
+			this.vbox1.PackStart( this.sourceScroller, true, true, 0 );
+			this.vpaned.Pack1( vbox1, true, true );
+			
+			this.notebook = new Notebook();
+			this.notebook.TabPos = PositionType.Bottom;
+			this.logView = new TextView();
+			this.logView.Editable = false;
+			this.logScroller = new ScrolledWindow();
+			this.logScroller.Add( logView );
+			this.outputView = new MonoDevelop.Gui.Widgets.DataGrid();
+			this.notebook.AppendPage( logScroller, new Label(&quot;Log&quot;) );
+			this.notebook.AppendPage( outputView, new Label(&quot;Output&quot;) );
+			
+			this.vpaned.Pack2( notebook, true, true );
+			
+			this.vpaned.ShowAll();
+		}
+		
+		public override Gtk.Widget Control {
+			get { return this.vpaned; }
+		}
+		
+		public override void Load( string fileName )
+		{
+			// Load contents of file into the sourceView
+			// TODO:
+		}
+		
+		public IConnection Connection {
+			get { return this.connection; }
+		}
+		
+		public void OnQueryRun( object o, EventArgs e )
+		{
+			DateTime start = DateTime.Now;
+			
+			try
+			{
+				this.logView.Buffer.Text +=
+					  &quot;\n\n-------------------------------------------&quot;
+					+ &quot;\n Attempting Query\n                     &quot;;
+				DataSet ds = (DataSet)this.Connection.ExecuteSQL(
+					this.sourceView.Buffer.Text, 0 );
+				this.outputView.DataSource = ds;
+				this.outputView.DataBind();
+				this.notebook.Page = 1;
+			}
+			catch ( Exception err )
+			{
+				this.logView.Buffer.Text +=
+					  &quot;\n Exception caught during query.             &quot;
+					+ &quot;\n &quot; + err.StackTrace;
+				this.notebook.Page = 0;
+			}
+			finally
+			{
+				this.logView.Buffer.Text +=
+					  &quot;\n Query completed in &quot; + (DateTime.Now - start)
+					+ &quot;\n-------------------------------------------&quot;;
+				this.logView.ScrollToMark( this.logView.Buffer.InsertMark, 0.4,
+					true, 0.0, 1.0);
+			}
+		}
+	}
+	
+	public class SqlQueryViewToolbar : Gtk.Toolbar
+	{
+		public event EventHandler Run;
+		
+		public SqlQueryViewToolbar() : base()
+		{
+			this.ToolbarStyle = ToolbarStyle.Icons;
+			this.AppendItem (String.Empty, &quot;Execute SQL Commands.&quot;,
+				String.Empty,
+				new Gtk.Image (Gtk.Stock.Execute, IconSize.SmallToolbar),
+				new Gtk.SignalFunc ( OnRun ));
+		}
+		
+		private void OnRun()
+		{
+			this.Run( this, new EventArgs() );
+		}
+	}
+}
\ No newline at end of file
Index: Extras/MonoQuery/Gui/MonoQueryPanel.cs
===================================================================
--- Extras/MonoQuery/Gui/MonoQueryPanel.cs	(revision 0)
+++ Extras/MonoQuery/Gui/MonoQueryPanel.cs	(revision 0)
@@ -0,0 +1,87 @@
+
+// TODO: Port to GTK#
+
+using System;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+namespace MonoQuery.Gui
+{
+	/*
+	public class MonoQueryPanel : System.Windows.Forms.Panel
+	{		
+		private MonoQuery.Gui.TreeView.MonoQueryTree monoQueryTreeView;
+		private System.Windows.Forms.ImageList monoQueryImageList;
+		private System.Windows.Forms.ToolBar monoQueryToolBar;	
+		private System.Windows.Forms.ToolBarButton btnRefresh;
+		private System.Windows.Forms.ToolBarButton btnAddConnection;
+		private System.Windows.Forms.ToolBarButton btnSep;
+		
+		
+		public MonoQueryPanel() : base()
+		{		
+			IconService iconService = (IconService)ServiceManager.GetService(typeof(IconService));
+			StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+			
+			this.monoQueryToolBar = new System.Windows.Forms.ToolBar();
+			this.monoQueryImageList = new System.Windows.Forms.ImageList();
+			this.monoQueryTreeView = new MonoQuery.Gui.TreeView.MonoQueryTree();
+			this.btnRefresh = new System.Windows.Forms.ToolBarButton();
+			this.btnAddConnection = new System.Windows.Forms.ToolBarButton();
+			this.btnSep = new System.Windows.Forms.ToolBarButton();
+			this.SuspendLayout();
+					
+			// 
+			// monoQueryImageList
+			// 
+			this.monoQueryImageList.ColorDepth = System.Windows.Forms.ColorDepth.Depth24Bit;
+			this.monoQueryImageList.ImageSize = new System.Drawing.Size(16, 16);
+			this.monoQueryImageList.TransparentColor = System.Drawing.Color.DarkCyan;
+			
+			this.monoQueryImageList.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.AddConnection&quot;));
+			this.monoQueryImageList.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.Refresh&quot;));								
+						
+			// 
+			// toolBar
+			// 
+			this.monoQueryToolBar.Appearance = System.Windows.Forms.ToolBarAppearance.Flat;
+			this.monoQueryToolBar.Buttons.AddRange(new System.Windows.Forms.ToolBarButton[] {
+								this.btnRefresh, this.btnSep, this.btnAddConnection});
+			this.monoQueryToolBar.DropDownArrows = true;
+			this.monoQueryToolBar.Location = new System.Drawing.Point(0, 0);
+			this.monoQueryToolBar.Name = &quot;toolBar&quot;;
+			this.monoQueryToolBar.ShowToolTips = true;
+			this.monoQueryToolBar.Size = new System.Drawing.Size(292, 42);
+			this.monoQueryToolBar.TabIndex = 0;						
+			this.monoQueryToolBar.ImageList = this.monoQueryImageList;
+			
+			this.btnRefresh.ImageIndex = 1;
+			this.btnRefresh.ToolTipText = stringParserService.Parse(&quot;${res:MonoQuery.ToolTip.Refresh}&quot;);
+
+			this.btnSep.Style = System.Windows.Forms.ToolBarButtonStyle.Separator;
+
+			this.btnAddConnection.ImageIndex = 0;
+			this.btnAddConnection.ToolTipText = stringParserService.Parse(&quot;${res:MonoQuery.ToolTip.AddConnection}&quot;);			
+			
+			// 
+			// treeView
+			// 
+			this.monoQueryTreeView.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.monoQueryTreeView.ImageIndex = -1;
+			this.monoQueryTreeView.Location = new System.Drawing.Point(0, 42);
+			this.monoQueryTreeView.Name = &quot;treeView&quot;;
+			this.monoQueryTreeView.SelectedImageIndex = -1;
+			this.monoQueryTreeView.Size = new System.Drawing.Size(292, 224);
+			this.monoQueryTreeView.TabIndex = 1;
+			// 
+			// CreatedForm
+			// 
+			this.ClientSize = new System.Drawing.Size(292, 266);
+			this.Controls.Add(this.monoQueryTreeView);
+			this.Controls.Add(this.monoQueryToolBar);
+			this.Name = &quot;MonoQueryPanel&quot;;
+			this.ResumeLayout(false);									
+		}		
+	}*/
+}
Index: Extras/MonoQuery/Gui/Abstract/AbstractMonoQueryNode.cs
===================================================================
--- Extras/MonoQuery/Gui/Abstract/AbstractMonoQueryNode.cs	(revision 0)
+++ Extras/MonoQuery/Gui/Abstract/AbstractMonoQueryNode.cs	(revision 0)
@@ -0,0 +1,297 @@
+
+namespace MonoQuery.Gui.TreeView
+{
+	using System;
+	using System.Reflection;
+	using System.Collections;
+	using System.Data;
+	using System.ComponentModel;
+
+	using MonoQuery.Collections;
+	using MonoDevelop.Core.Services;
+	using MonoDevelop.Services;
+	using MonoDevelop.Gui;
+	using MonoDevelop.Core.AddIns.Conditions;
+	using MonoDevelop.Core.AddIns.Codons;
+	using MonoDevelop.Core.AddIns;
+	using MonoDevelop.Gui.Widgets;
+	
+	using MonoQuery.SchemaClass;		
+	using MonoQuery.Connection;	
+	using MonoQuery.Gui.DataView;
+	using MonoQuery.Exceptions;
+	using MonoQuery.Codons;
+	using MonoQuery.Services;
+	
+	public abstract class AbstractMonoQueryNode : TreeNode, IMonoQueryNode
+	{
+		internal static SQLParameterInput inputform = null;
+		
+		///&lt;summary&gt;
+		/// this variable force to have a &quot;plus&quot; near the node.
+		/// &lt;/summary&gt;
+		public static StringParserService stringParserService = stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));	
+		protected Assembly ass = null;
+
+		protected ISchemaClass pSchemaClass = null;	
+
+		///&lt;summary&gt; force to displayed a &quot;+&quot; for the node&lt;/summary&gt;
+		protected virtual bool NullChildAllowed
+		{
+			get
+			{
+				return true;
+			}
+		}
+			
+		public virtual string AddinContextMenu { 
+			get{
+				return &quot;&quot;;
+			}
+		}				
+		
+		public virtual string entityNormalizedName
+		{
+			get
+			{
+				if ( this.SchemaClass != null )
+				{
+					return AbstractMonoQuerySchemaClass.RemoveBracket( this.SchemaClass.NormalizedName );
+				}
+				else
+				{
+					return &quot;&quot;;
+				}
+			}
+		}
+		
+		public virtual string entityName
+		{
+			get
+			{
+				if ( this.SchemaClass != null )
+				{
+					return this.SchemaClass.InternalName;
+				}
+				else
+				{
+					return &quot;&quot;;
+				}				
+			}
+		}
+		
+		public ISchemaClass SchemaClass{
+			get
+			{
+				if ( this.pSchemaClass != null )
+				{
+					return this.pSchemaClass;
+				}
+				else
+				{
+					return null;
+				}
+			}
+		}
+		
+		public virtual IConnection  Connection{ 
+			get
+			{
+				if ( this.SchemaClass != null )
+				{
+					return this.SchemaClass.Connection;
+				}
+				else
+				{
+					return null;
+				}
+			}
+		}				
+		
+		public virtual MonoQueryListDictionary Entities { 
+			get{
+				if ( this.SchemaClass != null )
+				{
+					return this.SchemaClass.Entities;
+				}
+				else
+				{
+					return null;
+				}
+			}
+		}
+				
+		public AbstractMonoQueryNode() : base()
+		{
+			ass = System.Reflection.Assembly.GetExecutingAssembly();			
+		}
+				
+		public AbstractMonoQueryNode(ISchemaClass schemaclass) : this()
+		{						
+			this.pSchemaClass = schemaclass;						
+		}
+		
+		///&lt;summary&gt;
+		/// called by &lt;see cref=&quot;.Refresh()&quot;&gt;Refresh&lt;/see&gt; just after the &lt;see cref=&quot;.Clear()&quot;&gt;Clear&lt;/see&gt; and before &lt;see cref=&quot;.Refresh()&quot;&gt;childs'refresh&lt;/see&gt;.
+		/// In this, you could change the &lt;see cref=&quot;.Entities&quot;&gt;Entities dicntionnary.&lt;/see&gt;
+		///&lt;/summary&gt;
+		protected virtual void OnRefresh()
+		{
+			// Nothing !
+		}
+		
+		public virtual void Refresh()
+		{
+			try
+			{
+				if ( this.TreeView != null )
+				{
+					this.TreeView.BeginUpdate();
+				}
+				
+				this.Clear();				
+	
+				this.OnRefresh();
+				
+				if ( this.Connection.IsOpen )
+				{
+					this.Text = this.entityName;
+					
+//						if ( this.IsExpanded == true )
+//						{
+						if ( this.SchemaClass != null )
+						{
+							this.SchemaClass.Refresh();
+						}								
+						this.BuildsChilds();				
+//						}						
+				}
+			}
+			finally
+			{
+				if ( this.TreeView != null )
+				{
+					this.TreeView.EndUpdate();					
+				}				
+			}
+		}
+		
+		public virtual void Clear()
+		{	
+			if ( this.SchemaClass != null )
+			{
+				this.SchemaClass.Clear();
+			}
+			
+			if ( SchemaClass != null )
+			
+			this.Nodes.Clear();
+			
+			if ( ( this.IsExpanded == false ) &amp;&amp; (this.NullChildAllowed == true) )
+			{
+				this.Nodes.Add( new TreeNode() );
+			}
+		}
+		
+		///&lt;summary&gt;
+		/// allow the user to add some parameters while executing an SQL command
+		/// &lt;/summary&gt;
+		protected virtual MonoQuerySchemaClassCollection OnExecute( CancelEventArgs e )
+		{
+			return null;
+		}
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;/summary&gt;
+		public void Execute( int rows )
+		{			
+			try
+			{
+				if ( this.SchemaClass != null )
+				{					
+					CancelEventArgs e = new CancelEventArgs();
+					MonoQuerySchemaClassCollection ret = this.OnExecute( e );
+					if ( e.Cancel == false )
+					{
+						WorkbenchSingleton.Workbench.ShowView( new MonoQueryDataView( this.SchemaClass, rows, ret ) );
+					}
+				}
+			}
+			catch( Exception e)
+			{
+				IMessageService messageService =(IMessageService)ServiceManager.GetService(typeof(IMessageService));
+				messageService.ShowError( e.Message );																			
+			}						
+		}
+		
+		public virtual void BuildsChilds()
+		{		
+			string childclass = &quot;&quot;;
+			IMonoQueryNode ChildNode = null;
+
+			if ( this.Entities != null )
+			{
+				this.Nodes.Clear();
+				
+				foreach( DictionaryEntry DicEntry in this.Entities )
+				{												
+					if ( DicEntry.Value != null)							
+					{									
+						CollectionBase entitieslist = DicEntry.Value as CollectionBase;
+												
+						foreach ( ISchemaClass entity in entitieslist )
+						{
+							childclass = MonoQueryTree.SchemaClassDict[ entity.GetType().FullName ];
+							if ( ( childclass != null) &amp;&amp; (childclass != &quot;&quot;) )
+							{
+								ChildNode = (IMonoQueryNode)ass.CreateInstance(childclass, false, BindingFlags.CreateInstance, null, new object[] {entity}, null, null);
+								if ( ChildNode != null )
+								{
+									bool addNode = true;
+									
+									if ( ChildNode is MonoQueryNodeNotSupported )
+									{
+										addNode = this.ShowUnsupported();
+									}
+									if ( addNode == true )
+									{
+										this.Nodes.Add( ChildNode as TreeNode );
+										ChildNode.Refresh();
+									}									
+								}									
+							}												
+						}						
+					}
+				}
+			}			
+		}
+		
+		protected bool ShowUnsupported()
+		{
+			IAddInTreeNode AddinNode;	
+			bool ret = true;
+			
+			AddinNode = (IAddInTreeNode)AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/MonoQuery/Connection&quot;);
+			foreach ( DictionaryEntry entryChild in AddinNode.ChildNodes)
+			{
+				IAddInTreeNode ChildNode = entryChild.Value as IAddInTreeNode;
+				if ( ChildNode != null )
+				{
+					MonoQueryConnectionCodon codon = ChildNode.Codon as MonoQueryConnectionCodon;
+					if ( codon != null )
+					{
+						if ( codon.Node == this.GetType().FullName )
+						{
+							ret = bool.Parse( codon.ShowUnsuported );
+						}
+					}					
+				}
+			}
+			
+			return ret;
+		}
+	}
+}
\ No newline at end of file
Index: Extras/MonoQuery/Gui/DataView/SQLParameterInput.cs
===================================================================
--- Extras/MonoQuery/Gui/DataView/SQLParameterInput.cs	(revision 0)
+++ Extras/MonoQuery/Gui/DataView/SQLParameterInput.cs	(revision 0)
@@ -0,0 +1,71 @@
+using System;
+using System.Data;
+using System.Data.OleDb;
+using System.ComponentModel;
+
+using MonoDevelop.Gui;
+using MonoDevelop.Gui.Widgets;
+using MonoDevelop.Core.Services;
+
+using MonoQuery.SchemaClass;
+using MonoQuery.Collections;
+
+namespace MonoQuery.Gui.DataView
+{
+	public class SQLParameterInput //: XmlForm
+	{
+		private DataGrid _dataGrid = null;
+
+		public DataGrid dataGrid
+		{
+			get
+			{
+				if ( this._dataGrid == null )
+				{
+//					this._dataGrid = this.ControlDictionary[&quot;dataGrid&quot;] as DataGrid;
+				}
+				return this._dataGrid;
+			}
+		}
+
+		private void ResetClick( object sender, EventArgs e )
+		{
+
+		}
+
+		protected void FillParameters( MonoQueryParameterCollection parameters )
+		{
+			MonoQueryParameter par = null;
+			for( int i = 0; i &lt; parameters.Count; i++)
+			{
+				par = parameters[i];
+				if ( par.Type == ParameterDirection.ReturnValue )
+				{
+					i--;
+					parameters.Remove( par );
+				}
+			}
+//			this.dataGrid.CaptionVisible = true;
+			this.dataGrid.DataSource = parameters;
+	 		this.dataGrid.DataMember = null;
+//	 		this.dataGrid.AllowNavigation = false;
+		}
+
+//		static PropertyService propertyService = (PropertyService)ServiceManager.GetService(typeof(PropertyService));
+//		public SQLParameterInput() : base(propertyService.DataDirectory + @&quot;\resources\dialogs\MonoQuery\SqlParametersInput.xfrm&quot;)
+//		{
+//		}
+//
+//		public SQLParameterInput( MonoQueryParameterCollection parameters ) : this()
+//		{
+//			this.FillParameters( parameters );
+//		}
+//
+//		protected override void SetupXmlLoader()
+//		{
+//			xmlLoader.StringValueFilter    = new MonoDevelopStringValueFilter();
+//			xmlLoader.PropertyValueCreator = new MonoDevelopPropertyValueCreator();
+//		}
+	}
+}
+
Index: Extras/MonoQuery/Gui/DataView/MonoQueryDataView.cs
===================================================================
--- Extras/MonoQuery/Gui/DataView/MonoQueryDataView.cs	(revision 0)
+++ Extras/MonoQuery/Gui/DataView/MonoQueryDataView.cs	(revision 0)
@@ -0,0 +1,225 @@
+
+using System;
+using System.Data;
+//using System.Windows.Forms;
+using MonoDevelop.Gui;
+using MonoQuery.SchemaClass;
+using MonoQuery.Collections;
+using MonoDevelop.Gui.Widgets;
+
+namespace MonoQuery.Gui.DataView
+{
+	/// &lt;summary&gt;
+	/// Description of the view content
+	/// &lt;/summary&gt;
+	public class MonoQueryDataView : AbstractViewContent
+	{
+		DataGrid pDataGrid;
+		ISchemaClass  pSchema;
+		
+#region AbstractViewContent requirements
+		/// &lt;summary&gt;
+		/// The &lt;see cref=&quot;System.Windows.Forms.Control&quot;/&gt; representing the view
+		/// &lt;/summary&gt;
+		/// 
+		public override Gtk.Widget Control {
+			get {
+				return this.pDataGrid;
+			}
+		}		
+		
+		/// &lt;summary&gt;
+		/// Creates a new MyView object
+		/// &lt;/summary&gt;
+		public MonoQueryDataView( ISchemaClass entity, int lines, MonoQuerySchemaClassCollection parameters )
+		{
+			if ( entity == null )
+			{
+				throw new ArgumentNullException(&quot;entity&quot;);
+			}
+
+			this.ContentName = MonoQuery.SchemaClass.AbstractMonoQuerySchemaClass.RemoveBracket( entity.NormalizedName );
+
+			this.pDataGrid = new DataGrid();
+			
+//			this.pDataGrid.CaptionVisible = true;
+			this.pDataGrid.DataMember = &quot;&quot;;
+//			this.pDataGrid.Dock = System.Windows.Forms.DockStyle.Fill;
+//			this.pDataGrid.HeaderForeColor = System.Drawing.SystemColors.ControlText;
+//			this.pDataGrid.Location = new System.Drawing.Point(0, 0);
+			this.pDataGrid.Name = &quot;dataGrid&quot;;
+//			this.pDataGrid.Size = new System.Drawing.Size(292, 266);
+//			this.pDataGrid.TabIndex = 0;
+			this.Schema = entity;
+			this.Datatable = this.Schema.Execute( lines, parameters );
+//			if ( this.Datatable == null )
+//			{
+//				WorkbenchSingleton.Workbench.ViewContentCollection.Remove( this );			
+//			}
+		}	
+		
+		/// &lt;summary&gt;
+		/// Loads a new file into MyView
+		/// &lt;/summary&gt;
+		public override void Load(string fileName)
+		{
+			// TODO
+			throw new System.NotImplementedException();
+		}
+
+		/// &lt;summary&gt;
+		/// Refreshes the view
+		/// &lt;/summary&gt;
+		public override void RedrawContent()
+		{
+			// TODO: Refresh the whole view control here, renew all resource strings whatever
+			//       Note that you do not need to recreate the control.
+		}
+		
+		/// &lt;summary&gt;
+		/// Cleans up all used resources
+		/// &lt;/summary&gt;
+		public override void Dispose()
+		{
+			// TODO: Clean up resources in this method
+			 Control.Dispose();
+		}
+#endregion
+
+		public ISchemaClass Schema
+		{
+			get
+			{
+				return this.pSchema;
+			}
+			set
+			{
+				this.pSchema = value;
+			}
+		}
+		
+		///&lt;summary&gt;
+		/// &lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; to display in the 
+		/// &lt;see cref=&quot;System.Windows.Forms.DataGrid&quot;&gt;DataGrid&lt;/see&gt;
+		/// &lt;/summary&gt;
+		public object Datatable
+		{
+			get
+			{
+				return this.pDataGrid.DataSource;
+			}
+			
+			set
+			{	
+				removeChangedHandler();				
+
+				this.pDataGrid.DataSource = value;								
+				this.pDataGrid.DataMember = null;
+//				this.pDataGrid.AllowNavigation = true;
+				
+				DataSet dataset = this.pDataGrid.DataSource as DataSet;
+				
+				if ( dataset != null )
+				{
+				 	if ( dataset.Tables.Count == 1 )
+				 	{
+				 		this.pDataGrid.DataMember = dataset.Tables[0].TableName;
+//				 		this.pDataGrid.AllowNavigation = false;
+						this.pDataGrid.DataBind();
+				 	}
+				}
+				
+				addChangedHandler();				
+			}
+		}
+		
+		private void removeChangedHandler()
+		{						
+			if ( this.pDataGrid.DataSource != null )
+			{
+				DataSet dataset = this.pDataGrid.DataSource as DataSet;
+				
+				if ( dataset != null )
+				{
+					foreach( DataTable table in dataset.Tables )
+					{
+						table.RowChanged -= new DataRowChangeEventHandler( this.UpdateTable );
+						table.RowDeleted -= new DataRowChangeEventHandler( this.DeleteRow );
+					}
+				}
+				else
+				{
+				  ( this.pDataGrid.DataSource as DataTable).RowChanged -= new DataRowChangeEventHandler( this.UpdateTable );
+				  ( this.pDataGrid.DataSource as DataTable).RowDeleted -= new DataRowChangeEventHandler( this.DeleteRow );					
+				}
+			}			
+		}
+		
+		private void addChangedHandler()
+		{
+			if ( this.pDataGrid.DataSource != null )
+			{
+				DataSet dataset = this.pDataGrid.DataSource as DataSet;
+				
+				if ( dataset != null )
+				{
+					foreach( DataTable table in dataset.Tables )
+					{
+						table.RowChanged += new DataRowChangeEventHandler( this.UpdateTable );
+						table.RowDeleted += new DataRowChangeEventHandler( this.DeleteRow );
+					}
+				}
+				else
+				{
+				  ( this.pDataGrid.DataSource as DataTable).RowChanged += new DataRowChangeEventHandler( this.UpdateTable );
+				  ( this.pDataGrid.DataSource as DataTable).RowDeleted += new DataRowChangeEventHandler( this.DeleteRow );
+				}
+			}			
+		}		
+		
+		public void UpdateTable( object sender, DataRowChangeEventArgs e)
+		{			
+			if ( Datatable != null )
+			{
+				switch ( e.Action )
+				{
+					case DataRowAction.Add:
+						this.Schema.Connection.InsertRow( this.Schema, e.Row );
+						break;
+					case DataRowAction.Change: 
+						this.Schema.Connection.UpDateRow( this.Schema, e.Row );
+						break;						
+				}
+			}
+		}
+		
+		public void DeleteRow( object sender, DataRowChangeEventArgs e )
+		{
+				switch ( e.Action )
+				{
+					case DataRowAction.Delete: 
+						this.Schema.Connection.DeleteRow( this.Schema, e.Row );
+						break;
+				}
+			
+		}
+		
+		public override void Save(string fileName)
+		{
+			DataSet dataset = this.pDataGrid.DataSource as DataSet;
+			if ( dataset == null )
+			{
+				DataTable dataTable = this.pDataGrid.DataSource as DataTable;
+				if ( dataTable != null )
+				{
+					dataset = new DataSet();
+					dataset.Tables.Add( dataTable );					
+				}
+			}
+			
+			dataset. WriteXml( fileName );
+		}		
+
+	}
+	
+}
Index: Extras/MonoQuery/Gui/Forms/CreateConnectionDruid.cs
===================================================================
--- Extras/MonoQuery/Gui/Forms/CreateConnectionDruid.cs	(revision 0)
+++ Extras/MonoQuery/Gui/Forms/CreateConnectionDruid.cs	(revision 0)
@@ -0,0 +1,201 @@
+
+using System;
+
+using Gnome;
+using Glade;
+using Gtk;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+using MonoQuery.Gui.TreeView;
+using MonoQuery.Collections;
+using MonoQuery.Connection;
+using MonoQuery.Services;
+
+namespace MonoQuery.Gui
+{
+	public class CreateConnectionDruid
+	{
+		/// &lt;summary&gt;Window container&lt;/summary&gt;
+		[Widget]
+		private Gtk.Window winAddconnectionDruid = null;
+		
+		/// &lt;summary&gt;druid widget&lt;/summary&gt;
+		[Widget]
+		private Gnome.Druid druidAddconnection = null;
+		
+		/// &lt;summary&gt;&lt;/summary&gt;
+		[Widget]
+		private Gnome.DruidPageEdge pageAddconnectionStart = null;
+		
+		/// &lt;summary&gt;&lt;/summary&gt;
+		[Widget]
+		private Gnome.DruidPageStandard druidAddconnectionPage1 = null;
+		
+		/// &lt;summary&gt;&lt;/summary&gt;
+		[Widget]
+		private Gtk.ComboBox cmbProviders = null;
+		
+		/// &lt;summary&gt;&lt;/summary&gt;
+		[Widget]
+		private Gtk.TextView textview1 = null;
+		
+		/// &lt;summary&gt;&lt;/summary&gt;
+		[Widget]
+		private Gnome.DruidPageEdge druidpagefinish1 = null;
+		
+		/// &lt;summary&gt;
+		/// Root node of the TreeView
+		/// &lt;/summary&gt;
+		private MonoQueryNodeDatabaseRoot rootNode = null;
+		
+		/// &lt;summary&gt;
+		/// List store for providers
+		/// &lt;/summary&gt;
+		private ListStore store = null;
+		
+		/// &lt;summary&gt;
+		/// Constructor. Loads our druid for display.
+		/// &lt;/summary&gt;
+		public CreateConnectionDruid( MonoQuery.Gui.TreeView.MonoQueryNodeDatabaseRoot node )
+		{
+			this.rootNode = node;
+			Glade.XML gxml = new Glade.XML( null, &quot;monoquery.glade&quot;, &quot;winAddconnectionDruid&quot;, null );
+			gxml.Autoconnect( this );
+			
+			this.pageAddconnectionStart.ShowAll();
+			this.druidAddconnectionPage1.ShowAll();
+			this.druidpagefinish1.ShowAll();
+			
+			BuildProviderList();
+		}
+		
+		#region // Private Methods
+		private void OnCancelClicked( object o, EventArgs e )
+		{
+			this.winAddconnectionDruid.Destroy();
+		}
+		
+		/// &lt;summary&gt;
+		/// This method will get our list of providers and enter them into the
+		/// combo box.
+		/// &lt;/summary&gt;
+		private void BuildProviderList()
+		{
+			MonoQueryService monoQueryService = (MonoQueryService)
+				ServiceManager.GetService( typeof( MonoQueryService ) );
+			
+			store = new ListStore( typeof( string ),
+				typeof( ConnectionProviderDescriptor ) );
+			
+			foreach( ConnectionProviderDescriptor descriptor in monoQueryService.Providers )
+			{
+				store.AppendValues( descriptor.Name, descriptor );
+			}
+			
+			CellRendererText colr = new CellRendererText();
+			this.cmbProviders.Model = store;
+			this.cmbProviders.PackStart( colr, true );
+			this.cmbProviders.AddAttribute( colr, &quot;text&quot;, 0 );
+			
+			// Set to first provider
+			// This is where we could put some autolearning
+			this.cmbProviders.Active = 0;
+		}
+		
+		/// &lt;summary&gt;
+		/// Event handler for when we should test the connection to the
+		/// database.
+		/// &lt;/summary&gt;
+		private void OnTestConnection( object o, EventArgs e )
+		{
+			MessageService service = (MessageService)ServiceManager.GetService(
+				typeof( MessageService ) );
+			
+			bool successful = false;
+			
+			try
+			{
+				TreeIter iter;
+				this.cmbProviders.GetActiveIter( out iter );
+				ConnectionProviderDescriptor descriptor = (ConnectionProviderDescriptor)
+					store.GetValue( iter, 1 );
+				IConnection conn = CreateConnectionObject(
+					descriptor.ProviderType,
+					this.textview1.Buffer.Text );
+				successful = conn.Open(); // returns true on success
+			}
+			catch ( Exception err )
+			{
+				successful = false;
+			}
+			
+			if ( successful ) {
+				service.ShowMessage( GettextCatalog.GetString(
+					&quot;Connection was successful.&quot; ) );
+			} else {
+				service.ShowError( GettextCatalog.GetString(
+						&quot;Error connecting to server.&quot; )
+					+ &quot;\n------------------------------\n&quot;
+					+ this.textview1.Buffer.Text );
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// Creates an instance of a connection from a few settings.
+		/// &lt;/summary&gt;
+		private IConnection CreateConnectionObject( System.Type type, string connString )
+		{
+			System.Reflection.Assembly ass = System.Reflection.Assembly.GetExecutingAssembly();
+			IConnection conn = (IConnection)ass.CreateInstance( type.FullName );
+			try
+			{
+				conn.ConnectionString = connString;
+			}
+			catch ( Exception e ) {}
+			
+			return conn;
+		}
+		
+		/// &lt;summary&gt;
+		/// Create our node and connection objects. Add them to the root node
+		/// of our treeview.
+		/// &lt;/summary&gt;
+		private void OnFinishClicked( object o, FinishClickedArgs e )
+		{
+			TreeIter iter;
+			MonoQueryNodeConnection node = null;
+			
+			try
+			{
+				this.cmbProviders.GetActiveIter( out iter );
+				ConnectionProviderDescriptor descriptor = (ConnectionProviderDescriptor)
+					store.GetValue( iter, 1 );
+				IConnection conn = CreateConnectionObject(
+					descriptor.ProviderType,
+					this.textview1.Buffer.Text );
+			
+			
+				node = new MonoQueryNodeConnection( conn );
+			
+				rootNode.Nodes.Add( node as MonoDevelop.Gui.Widgets.TreeNode );
+				
+				conn.Open();
+				node.Expand();
+			}
+			catch ( Exception err )
+			{
+				MessageService service = (MessageService)ServiceManager.GetService(typeof(MessageService));
+				service.ShowError( GettextCatalog.GetString(&quot;There was an error adding your connection. &quot;
+					+ &quot;Please check your connection string.&quot;) );
+			}
+			finally
+			{
+				this.druidAddconnection.Destroy();
+				this.winAddconnectionDruid.Destroy();
+			}
+		}
+		#endregion // End Private Methods
+	}
+}
\ No newline at end of file
Index: Extras/MonoQuery/Gui/Forms/Glade/monoquery.glade
===================================================================
--- Extras/MonoQuery/Gui/Forms/Glade/monoquery.glade	(revision 0)
+++ Extras/MonoQuery/Gui/Forms/Glade/monoquery.glade	(revision 0)
@@ -0,0 +1,278 @@
+&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt; &lt;!--*- mode: xml -*--&gt;
+&lt;!DOCTYPE glade-interface SYSTEM &quot;<A HREF="http://glade.gnome.org/glade-2.0.dtd"">http://glade.gnome.org/glade-2.0.dtd&quot;</A>&gt;
+
+&lt;glade-interface&gt;
+&lt;requires lib=&quot;gnome&quot;/&gt;
+
+&lt;widget class=&quot;GtkWindow&quot; id=&quot;winAddconnectionDruid&quot;&gt;
+  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;Add Connection Wizard&lt;/property&gt;
+  &lt;property name=&quot;type&quot;&gt;GTK_WINDOW_TOPLEVEL&lt;/property&gt;
+  &lt;property name=&quot;window_position&quot;&gt;GTK_WIN_POS_NONE&lt;/property&gt;
+  &lt;property name=&quot;modal&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;resizable&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;destroy_with_parent&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;decorated&quot;&gt;True&lt;/property&gt;
+  &lt;property name=&quot;skip_taskbar_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;skip_pager_hint&quot;&gt;False&lt;/property&gt;
+  &lt;property name=&quot;type_hint&quot;&gt;GDK_WINDOW_TYPE_HINT_NORMAL&lt;/property&gt;
+  &lt;property name=&quot;gravity&quot;&gt;GDK_GRAVITY_NORTH_WEST&lt;/property&gt;
+
+  &lt;child&gt;
+    &lt;widget class=&quot;GnomeDruid&quot; id=&quot;druidAddconnection&quot;&gt;
+      &lt;property name=&quot;border_width&quot;&gt;4&lt;/property&gt;
+      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+      &lt;property name=&quot;show_help&quot;&gt;False&lt;/property&gt;
+      &lt;signal name=&quot;cancel&quot; handler=&quot;OnCancelClicked&quot; last_modification_time=&quot;Sun, 07 Nov 2004 07:27:30 GMT&quot;/&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GnomeDruidPageEdge&quot; id=&quot;pageAddconnectionStart&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;position&quot;&gt;GNOME_EDGE_START&lt;/property&gt;
+	  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;Add new connection&lt;/property&gt;
+	  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;This wizard will help you create a new connection for use within MonoDevelop. You will need to select your connection provider as well as your proper connection string.&lt;/property&gt;
+	&lt;/widget&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GnomeDruidPageStandard&quot; id=&quot;druidAddconnectionPage1&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;Select connection provider&lt;/property&gt;
+
+	  &lt;child internal-child=&quot;vbox&quot;&gt;
+	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;druid-vbox1&quot;&gt;
+	      &lt;property name=&quot;border_width&quot;&gt;16&lt;/property&gt;
+	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+	      &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
+
+	      &lt;child&gt;
+		&lt;widget class=&quot;GtkVBox&quot; id=&quot;vbox1&quot;&gt;
+		  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label1&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Select your connection provider&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkComboBox&quot; id=&quot;cmbProviders&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;12&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkScrolledWindow&quot; id=&quot;scrolledwindow1&quot;&gt;
+		      &lt;property name=&quot;height_request&quot;&gt;75&lt;/property&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;hscrollbar_policy&quot;&gt;GTK_POLICY_NEVER&lt;/property&gt;
+		      &lt;property name=&quot;vscrollbar_policy&quot;&gt;GTK_POLICY_NEVER&lt;/property&gt;
+		      &lt;property name=&quot;shadow_type&quot;&gt;GTK_SHADOW_IN&lt;/property&gt;
+		      &lt;property name=&quot;window_placement&quot;&gt;GTK_CORNER_TOP_LEFT&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkTextView&quot; id=&quot;textview1&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;editable&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;overwrite&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;accepts_tab&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;justification&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap_mode&quot;&gt;GTK_WRAP_NONE&lt;/property&gt;
+			  &lt;property name=&quot;cursor_visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;pixels_above_lines&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;pixels_below_lines&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;pixels_inside_wrap&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;left_margin&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;right_margin&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;indent&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			&lt;/widget&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkLabel&quot; id=&quot;lblSpacer1&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+		      &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+		      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+		      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+
+		  &lt;child&gt;
+		    &lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox1&quot;&gt;
+		      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+		      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkLabel&quot; id=&quot;label3&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
+			  &lt;property name=&quot;use_underline&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+			  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+
+		      &lt;child&gt;
+			&lt;widget class=&quot;GtkButton&quot; id=&quot;cmdTestConnection&quot;&gt;
+			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;relief&quot;&gt;GTK_RELIEF_NORMAL&lt;/property&gt;
+			  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
+			  &lt;signal name=&quot;clicked&quot; handler=&quot;OnTestConnection&quot; last_modification_time=&quot;Sun, 07 Nov 2004 22:54:55 GMT&quot;/&gt;
+
+			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkAlignment&quot; id=&quot;alignment1&quot;&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+			      &lt;property name=&quot;xscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;yscale&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;top_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;bottom_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;left_padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;right_padding&quot;&gt;0&lt;/property&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkHBox&quot; id=&quot;hbox2&quot;&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;spacing&quot;&gt;2&lt;/property&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkImage&quot; id=&quot;image1&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;stock&quot;&gt;gtk-execute&lt;/property&gt;
+				      &lt;property name=&quot;icon_size&quot;&gt;4&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+
+				  &lt;child&gt;
+				    &lt;widget class=&quot;GtkLabel&quot; id=&quot;label2&quot;&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;Test Connection&lt;/property&gt;
+				      &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+				      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				      &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				    &lt;/widget&gt;
+				    &lt;packing&gt;
+				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				      &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				    &lt;/packing&gt;
+				  &lt;/child&gt;
+				&lt;/widget&gt;
+			      &lt;/child&gt;
+			    &lt;/widget&gt;
+			  &lt;/child&gt;
+			&lt;/widget&gt;
+			&lt;packing&gt;
+			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+			  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+			&lt;/packing&gt;
+		      &lt;/child&gt;
+		    &lt;/widget&gt;
+		    &lt;packing&gt;
+		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		    &lt;/packing&gt;
+		  &lt;/child&gt;
+		&lt;/widget&gt;
+		&lt;packing&gt;
+		  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+		  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+		&lt;/packing&gt;
+	      &lt;/child&gt;
+	    &lt;/widget&gt;
+	  &lt;/child&gt;
+	&lt;/widget&gt;
+      &lt;/child&gt;
+
+      &lt;child&gt;
+	&lt;widget class=&quot;GnomeDruidPageEdge&quot; id=&quot;druidpagefinish1&quot;&gt;
+	  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+	  &lt;property name=&quot;position&quot;&gt;GNOME_EDGE_FINISH&lt;/property&gt;
+	  &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;Ready to create connection&lt;/property&gt;
+	  &lt;property name=&quot;text&quot; translatable=&quot;yes&quot;&gt;We are now ready to create the connection. Click Apply to create and start using the connection.&lt;/property&gt;
+	  &lt;signal name=&quot;finish&quot; handler=&quot;OnFinishClicked&quot; last_modification_time=&quot;Sun, 07 Nov 2004 23:29:49 GMT&quot;/&gt;
+	&lt;/widget&gt;
+      &lt;/child&gt;
+    &lt;/widget&gt;
+  &lt;/child&gt;
+&lt;/widget&gt;
+
+&lt;/glade-interface&gt;
Index: Extras/MonoQuery/Gui/Forms/Glade/monoquery.gladep
===================================================================
--- Extras/MonoQuery/Gui/Forms/Glade/monoquery.gladep	(revision 0)
+++ Extras/MonoQuery/Gui/Forms/Glade/monoquery.gladep	(revision 0)
@@ -0,0 +1,7 @@
+&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt; &lt;!--*- mode: xml -*--&gt;
+&lt;!DOCTYPE glade-project SYSTEM &quot;<A HREF="http://glade.gnome.org/glade-project-2.0.dtd"">http://glade.gnome.org/glade-project-2.0.dtd&quot;</A>&gt;
+
+&lt;glade-project&gt;
+  &lt;name&gt;MonoQuery&lt;/name&gt;
+  &lt;program_name&gt;monoquery&lt;/program_name&gt;
+&lt;/glade-project&gt;
Index: Extras/MonoQuery/Gui/MonoQueryTree/MonoQueryNodesRoot.cs
===================================================================
--- Extras/MonoQuery/Gui/MonoQueryTree/MonoQueryNodesRoot.cs	(revision 0)
+++ Extras/MonoQuery/Gui/MonoQueryTree/MonoQueryNodesRoot.cs	(revision 0)
@@ -0,0 +1,392 @@
+// created on 04/11/2003 at 17:29
+
+using System;
+using System.Xml;
+using System.Reflection;
+using System.Collections;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Gui.Widgets;
+using MonoDevelop.Gui;
+
+using MonoQuery.SchemaClass;
+using MonoQuery.Collections;
+using MonoQuery.Connection;
+using MonoQuery.Exceptions;
+
+namespace MonoQuery.Gui.TreeView
+{	
+	///&lt;summary&gt;
+	/// this is the root of all others nodes!
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeDatabaseRoot :  AbstractMonoQueryNode
+	{										
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/DatabaseRoot&quot;;
+			}
+		}						
+					
+		public override string entityName
+		{
+			get
+			{
+				StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+				return GettextCatalog.GetString( &quot;Database Connections&quot; ); 
+			}
+		}
+		
+		public MonoQueryNodeDatabaseRoot() : base()
+		{
+			this.Text = this.entityName;
+			this.Image = &quot;md-network&quot;;
+			
+//			this.ImageIndex = 0;
+//			this.SelectedImageIndex = 0;
+		}		
+
+		public override void Refresh()
+		{			
+			this.Text = this.entityName;
+			
+			foreach( IMonoQueryNode node in this.Nodes )
+			{
+				node.Refresh();
+			}
+		}		
+		
+		public override void Clear()
+		{		
+			foreach( IMonoQueryNode node in this.Nodes )
+			{
+				node.Clear();
+			}
+		}
+						
+		public override void BuildsChilds()
+		{
+			// We now do this from a druid
+			/*			
+			IConnection connection = null;
+			IMonoQueryNode node = null;
+			
+			try
+			{			
+				connection = AbstractMonoQueryConnectionWrapper.CreateFromDataConnectionLink();
+				
+				if (connection != null)
+				{										
+					string ChildClass = &quot;&quot;;
+					
+					if ( MonoQueryTree.SchemaClassDict.Contains( connection.GetType().FullName ) == true )
+					{
+						ChildClass = MonoQueryTree.SchemaClassDict[ connection.GetType().FullName ];
+					}
+					
+					if ( (ChildClass != null) &amp;&amp; (ChildClass != &quot;&quot; ) )
+					{					
+						node = (IMonoQueryNode)ass.CreateInstance(ChildClass, false, BindingFlags.CreateInstance, null, new object[] {connection}, null, null);				
+					}
+					else
+					{
+						node = new MonoQueryNodeNotSupported( new MonoQueryNotSupported( connection, &quot;&quot;, &quot;&quot;, &quot;&quot;, connection.GetType().FullName ) );
+					}
+					
+
+					//TODO : do an interface for the node connection!
+					(node as MonoQueryNodeConnection).Connect();
+					this.Nodes.Add( node as TreeNode );
+					node.Refresh();
+					
+					if ( node.Connection.IsConnectionStringWrong == true )
+					{
+						this.Nodes.Remove( node as TreeNode);	
+					}
+					else
+					{
+						this.Expand();
+					}					
+				}
+			}
+			catch( ConnectionStringException e )
+			{
+				if ( this.Nodes.Contains( node as TreeNode) == true )
+				{
+					this.Nodes.Remove( node as TreeNode);
+				}
+				IMessageService messageService =(IMessageService)ServiceManager.GetService(typeof(IMessageService));
+				messageService.ShowError( e.Message );															
+			}*/	
+		}
+		
+		/// &lt;summary&gt;
+		/// This will show a window so that the user can select their settings
+		/// for the new connection.
+		/// &lt;/summary&gt;
+		public void AddConnection()
+		{
+			new CreateConnectionDruid( this );
+		}
+	}
+
+	///&lt;summary&gt;
+	/// Root nodes for a connection to a database
+	///&lt;/summary&gt;		
+	public class MonoQueryNodeConnection : AbstractMonoQueryNode
+	{			
+		IConnection pConnection = null;
+		
+		public override string entityNormalizedName
+		{
+			get
+			{
+				if ( this.pConnection != null )
+				{
+					return this.pConnection.NormalizedName;
+				}
+				else
+				{
+					return &quot;&quot;;
+				}
+			}
+		}
+		
+		public override string entityName
+		{
+			get
+			{
+				if ( this.pConnection != null )
+				{
+					return this.pConnection.Name;
+				}
+				else
+				{
+					return &quot;&quot;;
+				}				
+			}
+		}		
+		
+		public override IConnection Connection{ 
+			get
+			{
+				if ( this.pConnection != null )
+				{
+					return this.pConnection;
+				}
+				else
+				{
+					return null;
+				}
+			}
+		}	
+		
+		public override MonoQueryListDictionary Entities { 
+			get{
+				if ( this.Connection != null )
+				{
+					return this.Connection.Entities;
+				}
+				else
+				{
+					return null;
+				}
+			}
+		}		
+		
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/DatabaseConnection&quot;;
+			}
+		}
+						
+		public MonoQueryNodeConnection( IConnection dataConnection ) : base( null )
+		{								
+			this.pConnection = dataConnection;
+			this.Image = &quot;md-mono-query-database&quot;;
+			this.Text = this.pConnection.Name;
+			
+			this.Nodes.Add( &quot;&quot; ); // dummy
+			
+//			this.ImageIndex = 1;
+//			this.SelectedImageIndex = 1;				
+		}			
+		
+		public bool IsConnected
+		{
+			get 
+			{
+				return this.Connection.IsOpen;
+			}
+		}
+		
+		public void Disconnect()
+		{
+			if (this.IsConnected == true)
+			{
+//				this.Collapse();
+				this.Nodes.Clear();
+				this.Clear();
+				this.Connection.Close();
+//				this.ImageIndex = 1;
+//				this.SelectedImageIndex = 1;
+			}
+		}
+		
+		public void Connect()
+		{
+			try
+			{
+				if ( this.IsConnected == false )
+				{				
+					if ( this.Connection.Open() )
+					{
+						this.Refresh();
+//						this.ImageIndex = 2;
+//						this.SelectedImageIndex = 2;																				
+					}				
+				}
+			}
+			catch( Exception e )
+			{
+				IMessageService messageService =(IMessageService)ServiceManager.GetService(typeof(IMessageService));
+				messageService.ShowError( e.Message );
+			}			
+		}
+		
+		protected override void OnRefresh()
+		{
+			if ( this.IsConnected != true )
+				this.Connect();
+
+			this.Clear();
+			this.Connection.Refresh();
+		}
+		
+		public override void Clear()
+		{			
+			if ( this.Connection != null )
+			{
+				this.Connection.Clear();
+			}
+			
+			base.Clear();
+		}
+				
+		public void RemoveConnection()
+		{
+			this.Disconnect();
+			this.pConnection = null;
+			
+			this.Parent.Nodes.Remove( this );
+		}		
+		
+		public void ModifyConnection()
+		{	
+			IConnection Oldconnection = this.pConnection;
+			bool error = false;
+			try
+			{
+				IConnection connection = null;
+				
+				connection = AbstractMonoQueryConnectionWrapper.UpDateFromDataConnectionLink( this.Connection );
+				
+				if ( connection != null )
+				{
+					this.Disconnect();
+					this.pConnection = connection;
+					this.Refresh();	
+					error = this.pConnection.IsConnectionStringWrong;
+				}				
+			}
+			catch( ConnectionStringException e )
+			{				
+				error = true;
+				IMessageService messageService =(IMessageService)ServiceManager.GetService(typeof(IMessageService));
+				messageService.ShowError( e.Message );
+			}	
+			finally
+			{
+				if ( error == true )
+				{
+					this.pConnection = Oldconnection;
+					this.Connect();
+					this.Refresh();
+				}
+			}
+		}
+	}
+					
+	
+	///&lt;summary&gt;
+	/// Tables Root Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeTableRoot : AbstractMonoQueryNode
+	{						
+		///&lt;summary&gt;
+		/// Addin Path of the node's context menu
+		///&lt;/summary&gt;	
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/TablesRoot&quot;;
+			}
+		}
+				
+		public MonoQueryNodeTableRoot( AbstractMonoQuerySchemaClass databaseclass) : base( databaseclass )
+		{
+			this.Image = &quot;md-mono-query-tables&quot;;
+			
+//			this.ImageIndex = 3;
+//			this.SelectedImageIndex = 3;
+		}
+						
+	}
+
+	///&lt;summary&gt;
+	/// Views Root Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeViewRoot : AbstractMonoQueryNode
+	{					
+		///&lt;summary&gt;
+		/// Addin Path of the node's context menu
+		///&lt;/summary&gt;	
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/ViewsRoot&quot;;
+			}
+		}
+
+		public MonoQueryNodeViewRoot( AbstractMonoQuerySchemaClass databaseclass) : base( databaseclass )
+		{
+			this.Image = &quot;md-mono-query-tables&quot;;
+			
+//			this.ImageIndex = 4;
+//			this.SelectedImageIndex = 4;	
+		}				
+	}
+		
+	///&lt;summary&gt;
+	/// Procedure Root Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeProcedureRoot : AbstractMonoQueryNode
+	{							
+		///&lt;summary&gt;
+		/// Addin Path of the node's context menu
+		///&lt;/summary&gt;	
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/ProceduresRoot&quot;;
+			}
+		}
+		
+		public MonoQueryNodeProcedureRoot( AbstractMonoQuerySchemaClass databaseclass) : base( databaseclass )
+		{
+			this.Image = &quot;md-mono-query-procedure&quot;;
+			
+//			this.ImageIndex = 5;
+//			this.SelectedImageIndex = 5;	
+		}						
+	}
+	
+	
+}
Index: Extras/MonoQuery/Gui/MonoQueryTree/MonoQueryTree.cs
===================================================================
--- Extras/MonoQuery/Gui/MonoQueryTree/MonoQueryTree.cs	(revision 0)
+++ Extras/MonoQuery/Gui/MonoQueryTree/MonoQueryTree.cs	(revision 0)
@@ -0,0 +1,212 @@
+// created on 04/11/2003 at 16:05
+
+namespace MonoQuery.Gui.TreeView
+{
+
+using System;
+using System.Xml;
+using System.Collections;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Core.AddIns.Conditions;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoDevelop.Core.AddIns;
+using MonoDevelop.Gui.Widgets;
+
+using MonoQuery.Gui;
+using MonoQuery.Collections;
+using MonoQuery.Codons;
+
+using RS = MonoDevelop.Core.Services.ResourceService;
+
+	///&lt;summary&gt;
+	/// This class shows all databases connections in a treeview. 
+	///&lt;/summary&gt;	
+	public class MonoQueryTree : TreeView
+	{									
+//		private System.Windows.Forms.ImageList pNodeImages;
+		private MenuService menuService = null;
+
+		public static MonoQueryStringDictionary SchemaClassDict;		
+
+		///&lt;summary&gt;
+		/// Create a MonoQueryTree objec 
+		///&lt;/summary&gt;			
+		public MonoQueryTree() : base()
+		{		
+			IconService iconService = (IconService)ServiceManager.GetService(typeof(IconService));
+			
+			this.menuService = (MenuService)ServiceManager.GetService(typeof(MenuService));
+			
+//			this.pNodeImages = new ImageList();
+//			this.pNodeImages.ColorDepth = System.Windows.Forms.ColorDepth.Depth24Bit;
+//			this.pNodeImages.ImageSize = new System.Drawing.Size(16, 16);
+//			this.pNodeImages.TransparentColor = System.Drawing.Color.DarkCyan;
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.DataBaseRoot&quot;));
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.DatabaseConnectionClose&quot;));
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.DatabaseConnection&quot;));
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.TablesRoot&quot;));	
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.ViewsRoot&quot;));
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.ProceduresRoot&quot;));
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.Table&quot;));
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.View&quot;));
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.Procedure&quot;));
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.Column&quot;));
+//			this.pNodeImages.Images.Add(iconService.GetBitmap(&quot;Icons.16x16.MonoQuery.NodeError&quot;));
+//			this.ImageList = this.pNodeImages;
+			
+			SchemaClassDict = new MonoQueryStringDictionary();
+						
+			LoadMonoQueryConnectionCodon();
+			
+			//Add the Root Node.
+			this.Nodes.Add( new MonoQueryNodeDatabaseRoot() );
+			
+			// Wire click event
+			this.ButtonReleaseEvent += new Gtk.ButtonReleaseEventHandler( OnButtonRelease );		
+		}
+		
+		protected void LoadMonoQueryConnectionCodon()
+		{
+			IAddInTreeNode AddinNode;		
+			
+			AddinNode = (IAddInTreeNode)AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/MonoQuery/Connection&quot;);
+			foreach ( DictionaryEntry entryChild in AddinNode.ChildNodes)
+			{
+				IAddInTreeNode ChildNode = entryChild.Value as IAddInTreeNode;
+				if ( ChildNode != null )
+				{
+					MonoQueryConnectionCodon codon = ChildNode.Codon as MonoQueryConnectionCodon;
+					if ( codon != null )
+					{
+					  if ( SchemaClassDict.Contains( codon.Schema ) )
+					  {
+					  	SchemaClassDict[codon.Schema] = codon.Node;
+					  }
+					  else
+					  {
+					  	SchemaClassDict.Add(codon.Schema,codon.Node);
+					  }					  	
+					}					
+				}
+			}			
+		}
+		
+//		///&lt;summary&gt;
+//		/// Select the node under the mouse cursor
+//		///&lt;/summary&gt;		
+//		protected override void OnMouseDown(MouseEventArgs e)
+//		{						
+//			if (e.Button == MouseButtons.Right || e.Button == MouseButtons.Left)
+//			{
+//				this.SelectedNode = this.GetNodeAt( e.X, e.Y );
+//			}
+//			
+//			
+//			base.OnMouseDown(e);
+//		}
+//		
+//		///&lt;summary&gt;
+//		/// Display the context menu associated with a node type 
+//		///&lt;/summary&gt;		
+//		protected override void OnMouseUp(MouseEventArgs e)
+//		{						
+//			if (e.Button == MouseButtons.Right &amp;&amp; this.SelectedNode != null &amp;&amp; SelectedNode is IMonoQueryNode) {
+//				IMonoQueryNode selectedBrowserNode = SelectedNode as IMonoQueryNode;		
+//				if ( selectedBrowserNode.AddinContextMenu != &quot;&quot; )
+//				{
+//					menuService.ShowContextMenu(this, selectedBrowserNode.AddinContextMenu, this, e.X, e.Y);
+//				}
+//			}
+//
+//			base.OnMouseUp(e);
+//		}
+
+		/// &lt;summary&gt;
+		/// Display the context menu associated with a node type
+		/// &lt;/summary&gt;
+		public void OnButtonRelease( object o, Gtk.ButtonReleaseEventArgs args )
+		{
+			if ( args.Event.Button == 3			// Right Click
+				&amp;&amp; this.SelectedNode != null
+				&amp;&amp; this.SelectedNode is IMonoQueryNode )
+			{
+				IMonoQueryNode selectedBrowserNode = SelectedNode as IMonoQueryNode;
+				if ( selectedBrowserNode.AddinContextMenu != &quot;&quot; )
+				{
+					menuService.ShowContextMenu( this, selectedBrowserNode.AddinContextMenu, this );
+				}
+			}
+		}
+
+//		
+//		protected override void OnItemDrag(ItemDragEventArgs e)
+//		{
+//			base.OnItemDrag(e);
+//			AbstractMonoQueryNode node = e.Item as AbstractMonoQueryNode;
+//			if (node != null) 
+//			{
+//				DataObject dataObject = null;
+//				
+//				if ( node.SchemaClass != null )
+//				{
+//					dataObject = node.SchemaClass.DragObject;
+//					
+//					if (dataObject != null )
+//					{
+//						dataObject.SetData(node.GetType() , node);
+//						DoDragDrop(dataObject, DragDropEffects.All);
+//					}
+//				}												
+//			}
+//		}
+		
+		protected override void OnBeforeExpand( TreeViewCancelEventArgs e )
+		{
+			MonoQueryNodeConnection node = e.Node as MonoQueryNodeConnection;
+			
+			if ( node != null )
+			{
+				if ( node.IsConnected == false )
+				{
+					node.Connect();
+				}
+			}
+
+			IMonoQueryNode myNode = e.Node as IMonoQueryNode;
+			
+			if ( myNode != null )
+			{
+				myNode.Refresh();
+			}
+
+			base.OnBeforeExpand( e );
+		}
+
+		
+//		protected override void OnAfterExpand(TreeViewEventArgs e)
+//		{	
+//			IMonoQueryNode node = e.Node as IMonoQueryNode;
+//
+//			if ( node != null )
+//			{
+//				node.Refresh();
+//			}
+//			
+//			base.OnAfterExpand( e );
+//		}	
+//				
+//		protected override void OnAfterCollapse( TreeViewEventArgs e )
+//		{
+//			IMonoQueryNode node = e.Node as IMonoQueryNode;
+//			
+//			if ( node != null )
+//			{
+//				node.Clear();
+//			}
+//			
+//			base.OnAfterCollapse( e );
+//		}
+	}
+}
Index: Extras/MonoQuery/Gui/MonoQueryTree/MonoQueryDataNodes.cs
===================================================================
--- Extras/MonoQuery/Gui/MonoQueryTree/MonoQueryDataNodes.cs	(revision 0)
+++ Extras/MonoQuery/Gui/MonoQueryTree/MonoQueryDataNodes.cs	(revision 0)
@@ -0,0 +1,240 @@
+// created on 07/11/2003 at 10:15
+using System;
+using System.Xml;
+using System.ComponentModel;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoQuery.SchemaClass;
+using MonoQuery.Collections;
+using System.Collections;
+using MonoQuery.Gui.DataView;
+using MonoDevelop.Gui;
+using MonoDevelop.Gui.Dialogs;
+
+namespace MonoQuery.Gui.TreeView
+{
+	
+	///&lt;summary&gt;
+	/// Column Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeColumn : AbstractMonoQueryNode
+	{						
+		///&lt;summary&gt; force to displayed a &quot;+&quot; for the node&lt;/summary&gt;
+		protected override bool NullChildAllowed
+		{
+			get
+			{
+				return false;
+			}
+		}
+		
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/Coulmn&quot;;
+			}
+		}
+		
+		public MonoQueryNodeColumn( MonoQueryColumn monoQueryColumn ) : base( monoQueryColumn )
+		{
+			//this.Image = &quot;&quot;;
+			
+//			this.ImageIndex = 9;
+//			this.SelectedImageIndex = 9;
+		}				
+	}	
+	
+	///&lt;summary&gt;
+	/// Parameter Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeParameter : AbstractMonoQueryNode
+	{		
+		
+		///&lt;summary&gt; force to displayed a &quot;+&quot; for the node&lt;/summary&gt;
+		protected override bool NullChildAllowed
+		{
+			get
+			{
+				return false;
+			}
+		}
+		
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/Parameter&quot;;
+			}
+		}
+		
+		public MonoQueryNodeParameter( MonoQueryParameter monoQueryParameter ) : base( monoQueryParameter )
+		{
+			//this.Image = &quot;&quot;;
+			
+//			this.ImageIndex = 9;
+//			this.SelectedImageIndex = 9;
+		}				
+	}	
+
+	///&lt;summary&gt;
+	/// Table Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeTable : AbstractMonoQueryNode
+	{		
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/Table&quot;;
+			}
+		}
+		
+		public MonoQueryNodeTable( MonoQueryTable monoQueryTable ) : base( monoQueryTable )
+		{
+			this.Image = &quot;md-mono-query-table&quot;;
+			
+//			this.ImageIndex = 6;
+//			this.SelectedImageIndex = 6;	
+		}						
+	}
+	
+	///&lt;summary&gt;
+	/// View Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeView : AbstractMonoQueryNode
+	{									
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/View&quot;;
+			}
+		}
+		
+		public MonoQueryNodeView( MonoQueryView monoQueryView ) : base( monoQueryView )
+		{
+			this.Image = &quot;md-mono-query-table&quot;;
+			
+//			this.ImageIndex = 7;
+//			this.SelectedImageIndex = 7;
+		}						
+	}
+	
+	///&lt;summary&gt;
+	/// Procedure Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeProcedure: AbstractMonoQueryNode
+	{		
+
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/Procedure&quot;;
+			}
+		}
+		
+		public MonoQueryNodeProcedure( MonoQueryProcedure monoQueryProcedure ) : base( monoQueryProcedure )
+		{
+			this.Image = &quot;md-mono-query-procedure&quot;;
+			
+//			this.ImageIndex = 8;
+//			this.SelectedImageIndex = 8;		
+		}					
+		
+		///&lt;summary&gt;
+		/// allow the user to add some parameters while executing an SQL command
+		/// &lt;/summary&gt;
+		protected override MonoQuerySchemaClassCollection OnExecute( CancelEventArgs e )
+		{
+			MonoQuerySchemaClassCollection tmp = this.SchemaClass.GetSchemaParameters();
+			MonoQueryParameterCollection parameters = null;			
+			MonoQuerySchemaClassCollection returnValue = null;
+			
+//			if ( tmp.Count == 1 &amp;&amp; tmp[0] is MonoQueryNotSupported )
+//			{
+//				parameters = new MonoQueryParameterCollection();
+//			}
+//			else
+//			{
+//				parameters = new MonoQueryParameterCollection( tmp );
+//			}
+//			
+//			if ( parameters != null &amp;&amp; parameters.Count &gt; 0 )
+//			{
+//				inputform = new SQLParameterInput( parameters );
+//				inputform.Owner = (Form)WorkbenchSingleton.Workbench;
+//				
+//				if ( inputform.ShowDialog() != DialogResult.OK )
+//				{
+//					returnValue = null;
+//					e.Cancel = true;
+//				}
+//				else
+//				{
+//					returnValue	= parameters.ToBaseSchemaCollection();
+//				}
+//			}
+			
+			return returnValue;
+		}
+	}
+	
+	///&lt;summary&gt;
+	/// Node displayed when a function is not supported by the provider!
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeNotSupported: AbstractMonoQueryNode
+	{		
+		
+		///&lt;summary&gt; force to displayed a &quot;+&quot; for the node&lt;/summary&gt;
+		protected override bool NullChildAllowed
+		{
+			get
+			{
+				return false;				
+			}
+		}
+		
+		public MonoQueryNodeNotSupported( MonoQueryNotSupported monoQueryNotSupported ) : base( monoQueryNotSupported )
+		{
+//			this.ImageIndex = 10;
+//			this.SelectedImageIndex = 10;		
+		}										
+	}
+	
+
+	///&lt;summary&gt;
+	/// Schema Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeSchema : AbstractMonoQueryNode
+	{		
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/Schema&quot;;
+			}
+		}
+								
+		public MonoQueryNodeSchema( MonoQuerySchema schema ) : base(schema)
+		{
+			//this.Image = &quot;&quot;;
+			
+//			this.ImageIndex = 1;
+//			this.SelectedImageIndex = 1;				
+		}		
+		
+	}
+
+	///&lt;summary&gt;
+	/// Catalog Node
+	///&lt;/summary&gt;	
+	public class MonoQueryNodeCatalog : AbstractMonoQueryNode
+	{		
+		public override string AddinContextMenu { 
+			get{
+				return &quot;/MonoQuery/ContextMenu/Catalog&quot;;
+			}
+		}
+								
+		public MonoQueryNodeCatalog( MonoQueryCatalog catalog ) : base(catalog)
+		{
+			//this.Image = &quot;&quot;;
+			
+//			this.ImageIndex = 1;
+//			this.SelectedImageIndex = 1;							
+		}														
+	}
+	
+	
+}
Index: Extras/MonoQuery/Codons/MonoQueryConnectionCodon.cs
===================================================================
--- Extras/MonoQuery/Codons/MonoQueryConnectionCodon.cs	(revision 0)
+++ Extras/MonoQuery/Codons/MonoQueryConnectionCodon.cs	(revision 0)
@@ -0,0 +1,76 @@
+
+using System;
+using System.Collections;
+
+using MonoDevelop.Core.AddIns.Conditions;
+using MonoDevelop.Core.AddIns;
+
+using MonoDevelop.Core.AddIns.Codons;
+
+namespace MonoQuery.Codons
+{
+	[CodonName(&quot;MonoQueryConnection&quot;)]	
+	public class MonoQueryConnectionCodon : AbstractCodon
+	{			
+		[XmlMemberAttributeAttribute(&quot;schema&quot;, IsRequired=true)]
+		string pSchema = null;
+		[XmlMemberAttributeAttribute(&quot;node&quot;, IsRequired=true)]
+		string pNode   = null;
+		[XmlMemberAttributeAttribute(&quot;showUnsuported&quot;, IsRequired=true)]
+		string pshowUnsuported   = &quot;True&quot;;		
+		[XmlMemberAttributeAttribute(&quot;description&quot;, IsRequired=false)]
+		string pDescription = &quot;&quot;;
+		
+		public string Schema{
+			get{
+				return pSchema;
+			}
+			
+			set{
+				pSchema = value;
+			}
+		}
+		
+		public string Node{
+			get{
+				return pNode;
+			}
+			
+			set{
+				pNode = value;
+			}
+		}		
+		
+		public string ShowUnsuported{
+			get{
+				return pshowUnsuported;
+			}
+			
+			set{
+				pshowUnsuported = value;
+			}
+		}
+		
+		public string Description
+		{
+			get { return pDescription; }
+			set { pDescription = value; }
+		}	
+				
+		public override bool HandleConditions {
+			get {
+				return true;
+			}
+		}				
+				
+		/// &lt;summary&gt;
+		/// Creates an item with the specified sub items. And the current
+		/// Condition status for this item.
+		/// &lt;/summary&gt;
+		public override object BuildItem(object owner, ArrayList subItems, ConditionCollection conditions)
+		{
+			return this.Class;
+		}
+
+	}
+}
Index: Extras/MonoQuery/MonoQuery.cmbx
===================================================================
--- Extras/MonoQuery/MonoQuery.cmbx	(revision 0)
+++ Extras/MonoQuery/MonoQuery.cmbx	(revision 0)
@@ -0,0 +1,16 @@
+&lt;Combine fileversion=&quot;1.0&quot; name=&quot;MonoQuery&quot; description=&quot;&quot;&gt;
+  &lt;StartMode startupentry=&quot;MonoQuery&quot; single=&quot;True&quot;&gt;
+    &lt;Execute entry=&quot;MonoQuery&quot; type=&quot;None&quot; /&gt;
+  &lt;/StartMode&gt;
+  &lt;Entries&gt;
+    &lt;Entry filename=&quot;./MonoQuery.prjx&quot; /&gt;
+  &lt;/Entries&gt;
+  &lt;Configurations active=&quot;Debug&quot;&gt;
+    &lt;Configuration name=&quot;Release&quot;&gt;
+      &lt;Entry name=&quot;MonoQuery&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+    &lt;Configuration name=&quot;Debug&quot;&gt;
+      &lt;Entry name=&quot;MonoQuery&quot; configurationname=&quot;Debug&quot; build=&quot;False&quot; /&gt;
+    &lt;/Configuration&gt;
+  &lt;/Configurations&gt;
+&lt;/Combine&gt;
\ No newline at end of file
Index: Extras/MonoQuery/SchemaClass/Interface/ISchemaClass.cs
===================================================================
--- Extras/MonoQuery/SchemaClass/Interface/ISchemaClass.cs	(revision 0)
+++ Extras/MonoQuery/SchemaClass/Interface/ISchemaClass.cs	(revision 0)
@@ -0,0 +1,140 @@
+namespace MonoQuery.SchemaClass
+{
+	using System.Collections;
+	using System.Data;
+	
+	using MonoQuery.Collections;
+	using MonoQuery.Connection;	
+	
+	///&lt;summary&gt;
+	/// This interface is used by any schema class in sharp query. 
+	/// A schema class is a class that is the database definition of a &lt;code&gt;table&lt;/code&gt;,
+	/// a &lt;code&gt;view&lt;/code&gt;, a &lt;code&gt;column&lt;/code&gt;, etc etc ...
+	/// &lt;remarks&gt;
+	/// &lt;code&gt;entity&lt;/code&gt; is &lt;code&gt;table&lt;/code&gt;, a &lt;code&gt;view&lt;/code&gt; or other database struct.
+	/// &lt;code&gt;schema&lt;/code&gt;'s names are displayed between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;
+	/// &lt;/remarks&gt;
+	///&lt;/summary&gt;
+	public interface ISchemaClass
+	{	
+		///&lt;summary&gt;
+		/// get the connection object
+		///&lt;/summary&gt;
+		IConnection Connection{ get; }
+		
+		///&lt;summary&gt;
+		/// get the &lt;code&gt;entity&lt;/code&gt;'s &lt;code&gt;catalog&lt;/code&gt; name.
+		///&lt;/summary&gt;	
+		string CatalogName{ get; }
+	
+		///&lt;summary&gt;
+		/// get the &lt;code&gt;entity&lt;/code&gt;'s &lt;code&gt;schema&lt;/code&gt; name.
+		///&lt;/summary&gt;	
+		string SchemaName{ get; }
+		
+		///&lt;summary&gt;
+		/// Get the &lt;code&gt;entity&lt;/code&gt;'s owner name
+		/// &lt;example&gt;
+		///  for exemple, the owner of a &lt;code&gt;column&lt;/code&gt; is a &lt;code&gt;table&lt;/code&gt;,
+		/// and this property return the name of the &lt;code&gt;table&lt;/code&gt;
+		///&lt;/example&gt;
+		///&lt;/summary&gt;	
+		string OwnerName{ get; }
+		
+		///&lt;summary&gt;
+		/// get the &lt;code&gt;entity&lt;/code&gt;'s name
+		///&lt;/summary&gt;	
+		string Name{ get; }
+
+		/// &lt;summary&gt;
+		/// Internal name, used internally
+		/// &lt;/summary&gt;
+		string InternalName{ get; }
+		
+		///&lt;summary&gt;
+		/// &lt;code&gt;entity&lt;/code&gt;'s normalized name.
+		/// &lt;example&gt;
+		/// there are a database &lt;code&gt;test&lt;/code&gt;. In this database there are a &lt;code&gt;schema&lt;/code&gt; 
+		/// named &lt;code&gt;fool&lt;/code&gt;. In this &lt;code&gt;schema&lt;/code&gt; there are a &lt;code&gt;table&lt;/code&gt; named &lt;code&gt;fooltable&lt;/code&gt;
+		/// and a in this &lt;code&gt;table&lt;/code&gt; there are a &lt;code&gt;column&lt;/code&gt; named &lt;code&gt;foolcolumn&lt;/code&gt;.
+		/// So, the normalized name of the &lt;code&gt;schema&lt;/code&gt; is &lt;code&gt;test.[fool]&lt;/code&gt;.
+		/// The normalized name of the &lt;code&gt;table&lt;/code&gt; is &lt;code&gt;test.[fool].fooltable&lt;/code&gt;.
+		/// The normalized name of the &lt;code&gt;column&lt;/code&gt; is &lt;code&gt;test.[fool].fooltable.foolcolumn&lt;/code&gt;.
+		///&lt;/example&gt;
+		///&lt;/summary&gt;			
+		string NormalizedName{ get; }
+				
+		///&lt;summary&gt;
+		/// Those, are list of the childs schema.( columns, etc etc )
+		/// i am using a dictionnary because is more simplest to write 
+		/// &lt;code&gt;Entities[&quot;PROCEDURES&quot;]&lt;/code&gt; than &lt;code&gt;Entities[0]&lt;/code&gt;.
+		///&lt;/summary&gt;		
+		MonoQueryListDictionary Entities { get; }
+		
+		///&lt;summary&gt; return a &lt;see cref=&quot;System.Windows.Forms.DataObject&quot;&gt;DataObject&lt;/see&gt; &lt;/summary&gt;
+		//DataObject DragObject{ get; }		
+		
+		///&lt;summary&gt;
+		/// Refresh child schemas from the database.
+		///&lt;/summary&gt;
+		void Refresh();
+		
+		///&lt;summary&gt;
+		/// Erase all child schemas
+		///&lt;/summary&gt;
+		void Clear();	
+						
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		object Execute( int rows, MonoQuerySchemaClassCollection parameters ); 
+				
+		///&lt;summary&gt;
+		/// Get &lt;seealso cref='.ISchemaClass.Connection'/&gt;'s catalogs.
+		///&lt;/summary&gt;
+		MonoQuerySchemaClassCollection GetSchemaCatalogs();
+		
+		///&lt;summary&gt;
+		/// Get &lt;seealso cref='.ISchemaClass.Connection'/&gt;'s Schemas.
+		///&lt;/summary&gt;
+		MonoQuerySchemaClassCollection GetSchemaSchemas();
+		
+		///&lt;summary&gt;
+		/// From a catalog object, get tables from all schemas.
+		/// From a schema object get tables from all this schema.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaTables();
+		
+		///&lt;summary&gt;
+		/// From a catalog object, get views from all schemas.
+		/// From a schema object get views from all this schema.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaViews();
+		
+		///&lt;summary&gt;
+		/// From a catalog object, get procedures from all schemas.
+		/// From a schema object get procedures from all this schema.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaProcedures();
+		
+		///&lt;summary&gt;
+		/// From a table or a view or procedure object, get columns from the table.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaColumns();
+		
+		///&lt;summary&gt;
+		/// Get parameters from the procedure.
+		/// If parameters are not supported by the schema, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaParameters();
+	}
+	
+}
Index: Extras/MonoQuery/SchemaClass/Abstract/AbstractMonoQuerySchemaClass.cs
===================================================================
--- Extras/MonoQuery/SchemaClass/Abstract/AbstractMonoQuerySchemaClass.cs	(revision 0)
+++ Extras/MonoQuery/SchemaClass/Abstract/AbstractMonoQuerySchemaClass.cs	(revision 0)
@@ -0,0 +1,281 @@
+
+namespace MonoQuery.SchemaClass
+{
+	using System;
+	using System.Collections;
+	using System.Data;
+	using System.ComponentModel;
+	
+	using MonoQuery.Collections;
+	
+	using MonoDevelop.Core.Services;
+	using MonoDevelop.Services;
+	using MonoDevelop.Core.AddIns.Conditions;
+	using MonoDevelop.Core.AddIns.Codons;
+	using MonoDevelop.Core.AddIns;
+	
+	using MonoQuery.Connection;
+	
+	public abstract class AbstractMonoQuerySchemaClass : ISchemaClass
+	{			
+		static StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));								
+				
+		protected string pCatalogName	= null;
+		protected string pSchemaName	= null;
+		protected string pOwnerName		= null;
+		protected string pName			= null;
+		
+		protected IConnection pDataConnection = null;
+		
+		///&lt;summary&gt;
+		/// check if there are white spaces into the string.
+		/// if yes, then add &quot;[&quot; at the begin and &quot;]&quot; at the end.
+		///&lt;/summary&gt;
+		internal static string CheckWhiteSpace( string str )
+		{
+			string returnStr = str;
+			
+				if ( returnStr.IndexOf(&quot; &quot;) &gt; -1 )
+				{
+					if ( returnStr.StartsWith( &quot;[&quot; ) == false )
+					{
+						returnStr = &quot;[&quot; + returnStr;
+					}
+					if ( returnStr.EndsWith( &quot;]&quot; ) == false )
+					{
+						returnStr = returnStr + &quot;]&quot;;
+					}					
+				}	
+				
+			return returnStr;
+		}
+
+		///&lt;summary&gt;remove &quot;[&quot; at the begin and at the end of the str&lt;/summary&gt;
+		internal static string RemoveBracket( string str )
+		{
+			string returnStr = str;
+			if ( returnStr.StartsWith( &quot;[&quot; ) == true )
+			{
+				returnStr = returnStr.Remove(0, 1);
+			}
+			if ( returnStr.EndsWith( &quot;]&quot; ) == true )
+			{
+				returnStr = returnStr.Remove( returnStr.Length - 1 , 1);
+			}		
+			return returnStr;
+		}
+
+		
+		///&lt;summary&gt;
+		/// those, are list of the childs schema.
+		/// i am using a dictionnary (&lt;see cref=&quot;MonoQuery.Collections.MonoQueryListDictionary&quot;&gt;&lt;/see&gt;) because is more simplest to write 
+		/// &lt;code&gt;Entities[&quot;PROCEDURES&quot;]&lt;/code&gt; than &lt;code&gt;Entities[0]&lt;/code&gt;.
+		///&lt;/summary&gt;
+		protected MonoQueryListDictionary pEntities = null;
+		
+		public string CatalogName{
+			get{
+				return CheckWhiteSpace( this.pCatalogName );
+			}
+		}
+		
+		public string SchemaName{
+			get{
+				return CheckWhiteSpace( this.pSchemaName );
+			}
+		}	
+		
+		public string OwnerName{
+			get{
+				return CheckWhiteSpace( this.pOwnerName );
+			}
+		}				
+		
+		public string Name{
+			get{				
+				return CheckWhiteSpace( this.pName );
+			}
+		}
+
+		public string InternalName
+		{
+			get
+			{
+				return RemoveBracket( this.Name );
+			}
+		}
+		
+		public virtual string NormalizedName 
+		{
+			get 
+			{
+				return CheckWhiteSpace( Name );
+			}
+		}	
+						
+		///&lt;summary&gt;
+		/// those, are list of the childs schema.
+		/// i am using a dictionnary (&lt;see cref=&quot;MonoQuery.Collections.MonoQueryListDictionary&quot;&gt;&lt;/see&gt;) because is more simplest to write 
+		/// &lt;code&gt;Entities[&quot;PROCEDURES&quot;]&lt;/code&gt; than &lt;code&gt;Entities[0]&lt;/code&gt;.
+		///&lt;/summary&gt;		
+		public MonoQueryListDictionary Entities
+		{
+			get
+			{
+				return pEntities;
+			}
+		}
+		
+		public IConnection Connection
+		{
+			get
+			{
+				return this.pDataConnection;
+			}
+		}
+		
+//		///&lt;summary&gt; return a &lt;see cref=&quot;System.Windows.Forms.DataObject&quot;&gt;DataObject&lt;/see&gt;
+//		///&lt;/summary&gt;
+//		public virtual DataObject DragObject
+//		{
+//			get
+//			{
+//				return null;
+//			}
+//		}						
+		
+		//create the entities list
+		protected virtual void CreateEntitiesList()
+		{
+			if ( this.pEntities == null )
+			{
+				this.pEntities = new MonoQueryListDictionary();
+			}			
+		}
+		
+		///&lt;summary&gt;
+		/// construtor
+		/// &lt;list type=&quot;bullet&quot;&gt;
+		///	&lt;listheader&gt;
+		///		&lt;term&gt;parameters&lt;/term&gt;
+		///		&lt;description&gt;&lt;/description&gt;
+		///	&lt;/listheader&gt;
+		///	&lt;item&gt;
+		///		&lt;term&gt;&lt;code&gt;connection&lt;/code&gt;&lt;/term&gt;
+		///		&lt;description&gt;connection object from wich this schema is extracted&lt;/description&gt;
+		///	&lt;/item&gt;
+		///	&lt;item&gt;
+		///		&lt;term&gt;&lt;code&gt;catalogName&lt;/code&gt;&lt;/term&gt;
+		///		&lt;description&gt; this is the catalog of this schema entity &lt;/description&gt;
+		///	&lt;/item&gt;
+		///	&lt;item&gt;
+		///		&lt;term&gt;&lt;code&gt;schemaName&lt;/code&gt;&lt;/term&gt;
+		///		&lt;description&gt; this is the schema of this schema entity &lt;/description&gt;
+		///	&lt;/item&gt;
+		///	&lt;item&gt;
+		///		&lt;term&gt;&lt;code&gt;ownerName&lt;/code&gt;&lt;/term&gt;
+		///		&lt;description&gt; this is the owner name of this schema entity &lt;/description&gt;
+		///	&lt;/item&gt;
+		///	&lt;item&gt;
+		///		&lt;term&gt;&lt;code&gt;name&lt;/code&gt;&lt;/term&gt;
+		///		&lt;description&gt; this is the name of this schema entity &lt;/description&gt;
+		///	&lt;/item&gt;
+		/// &lt;/list&gt;
+		///&lt;/summary&gt;							
+		public AbstractMonoQuerySchemaClass( IConnection connection, string catalogName, string schemaName, string ownerName, string name ) : base()
+		{
+			this.pCatalogName = catalogName;
+			this.pSchemaName = schemaName;	
+			this.pOwnerName = ownerName;			
+			this.pName = name;						
+			this.pDataConnection = connection;		
+			
+			this.CreateEntitiesList();
+		}						
+			
+		///&lt;summary&gt;
+		/// called by &lt;see cref=&quot;.Refresh()&quot;&gt;Refresh&lt;/see&gt; just after the &lt;see cref=&quot;.Clear()&quot;&gt;Clear&lt;/see&gt; and before &lt;see cref=&quot;.Refresh()&quot;&gt;childs'refresh&lt;/see&gt;.
+		/// In this, you could change the &lt;see cref=&quot;.Entities&quot;&gt;Entities dicntionnary.&lt;/see&gt;
+		///&lt;/summary&gt;
+		protected abstract void OnRefresh();
+			
+		public void Refresh()
+		{
+			this.Clear();
+			this.CreateEntitiesList();
+			
+			if (this.Connection.IsOpen == true )
+			{				
+				this.OnRefresh();				
+			}
+		}
+		
+		public void Clear()
+		{
+			if (this.pEntities != null )
+			{
+				this.pEntities.Clear();
+			}			
+		}
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public abstract object Execute( int rows, MonoQuerySchemaClassCollection parameters );
+		
+		///&lt;summary&gt; if &lt;see cref=&quot;.Dataconnection.CatalogName&quot;&gt;CatalogName&lt;/see&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;empty&lt;/code&gt;
+		/// enumerate all catalogs from the database.
+		/// Else enumerate the current catalog's properties.
+		/// &lt;/summary&gt;
+		public virtual MonoQuerySchemaClassCollection GetSchemaCatalogs()
+		{
+			return this.pDataConnection.GetSchemaCatalogs(this);
+		}
+		
+		///&lt;summary&gt; if &lt;see cref=&quot;.Dataconnection.CatalogName&quot;&gt;CatalogName&lt;/see&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;empty&lt;/code&gt;
+		/// enumerate all shcema from the database.
+		/// Else enumerate schemas from the current catalog.
+		/// &lt;/summary&gt;		
+		public virtual MonoQuerySchemaClassCollection GetSchemaSchemas()
+		{
+			return this.pDataConnection.GetSchemaSchemas(this);
+		}		
+		
+		///&lt;summary&gt; Enumerate the &lt;see cref=&quot;.CatalogName&quot;&gt;CatalogName&lt;see cref=&quot;.SchemaName&quot;&gt;.SchemaName&lt;/see&gt;&lt;/see&gt;'s tables
+		/// &lt;/summary&gt;		
+		public virtual MonoQuerySchemaClassCollection GetSchemaTables()
+		{
+			return this.pDataConnection.GetSchemaTables( this );		
+		}
+		
+		///&lt;summary&gt; Enumerate the &lt;see cref=&quot;.CatalogName&quot;&gt;CatalogName&lt;see cref=&quot;.SchemaName&quot;&gt;.SchemaName&lt;/see&gt;&lt;/see&gt;'s views
+		/// &lt;/summary&gt;		
+		public virtual MonoQuerySchemaClassCollection GetSchemaViews()
+		{
+			return this.pDataConnection.GetSchemaViews( this );		
+		}
+		
+		///&lt;summary&gt; Enumerate the &lt;see cref=&quot;.CatalogName&quot;&gt;CatalogName&lt;see cref=&quot;.SchemaName&quot;&gt;.SchemaName&lt;/see&gt;&lt;/see&gt;'s procedures
+		/// &lt;/summary&gt;		
+		public virtual MonoQuerySchemaClassCollection GetSchemaProcedures()
+		{
+			return this.pDataConnection.GetSchemaProcedures( this );
+		}
+				
+		public virtual MonoQuerySchemaClassCollection GetSchemaColumns()
+		{	
+			MonoQuerySchemaClassCollection	list = new MonoQuerySchemaClassCollection();			
+			return list;
+		}
+		
+		public virtual MonoQuerySchemaClassCollection GetSchemaParameters()
+		{
+			MonoQuerySchemaClassCollection	list = new MonoQuerySchemaClassCollection();			
+			return list;			
+		}
+	}
+}
Index: Extras/MonoQuery/SchemaClass/MonoQuerySchemaClass.cs
===================================================================
--- Extras/MonoQuery/SchemaClass/MonoQuerySchemaClass.cs	(revision 0)
+++ Extras/MonoQuery/SchemaClass/MonoQuerySchemaClass.cs	(revision 0)
@@ -0,0 +1,772 @@
+// created on 04/11/2003 at 18:15
+
+using System;
+using System.Collections;
+using System.Data;
+using System.Data.OleDb;
+using System.Reflection;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+using MonoQuery.Connection;
+using MonoQuery.Collections;
+
+namespace MonoQuery.SchemaClass
+{	
+	
+//
+// Childs
+//
+			
+	///&lt;summary&gt;
+	/// Column class
+	///&lt;/summary&gt;	
+	public class MonoQueryColumn : AbstractMonoQuerySchemaClass
+	{			
+		public override string NormalizedName 
+		{
+			get {
+				string normalizedName = &quot;&quot;;
+								
+				if ( (this.OwnerName != &quot;&quot;) &amp;&amp; (this.OwnerName != null) ){
+					normalizedName +=  this.OwnerName +  &quot;.&quot;;
+				} 				
+				
+				normalizedName +=  this.Name;
+				
+				return normalizedName;
+			}
+		}
+		
+		protected override void CreateEntitiesList()
+		{		
+		}
+		
+		public MonoQueryColumn( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{			
+		}
+		
+		protected override void OnRefresh()		
+		{
+			//nothing !
+		}		
+
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			//nothing
+			return null;
+		}	
+		
+//		///&lt;summary&gt; return a &lt;see cref=&quot;System.Windows.Forms.DataObject&quot;&gt;DataObject&lt;/see&gt; 
+//		///&lt;/summary&gt;		
+//		public override DataObject DragObject
+//		{
+//			get
+//			{
+//				DataObject returnValue = new DataObject();			
+//				string extract = this.NormalizedName;
+//				returnValue.SetData(typeof(string) , extract );
+//				return returnValue;
+//			}
+//		}			
+	}
+	
+	///&lt;summary&gt;
+	/// Procedurre's parameters class
+	///&lt;/summary&gt;	
+	public class MonoQueryParameter : AbstractMonoQuerySchemaClass
+	{				
+		private DbType _dataType;
+		private object _value = null;
+		private ParameterDirection _type;
+		
+		///&lt;summary&gt;
+		/// Data Type of the parameter
+		/// ( used only while extracting data or executing procedure )
+		///&lt;/summary&gt;
+		public DbType DataType
+		{
+			get
+			{
+				return this._dataType;
+			}
+			set
+			{
+				this._dataType = value;
+				switch( value )
+				{
+					//string type
+					case DbType.AnsiString				: 
+					case DbType.AnsiStringFixedLength	: 
+					case DbType.String					: 
+					case DbType.StringFixedLength		: this._value = new string( (char[])null ); break;
+					//array type
+					case DbType.Binary					: this._value = new byte[8000]; break;
+					//bool type
+					case DbType.Boolean					: this._value = new bool(); break;
+					//interger type
+					case DbType.SByte					: this._value = new sbyte(); break;
+					case DbType.Byte					: this._value = new byte(); break;					 
+					case DbType.Int16					: this._value = new short(); break;
+					case DbType.Int32					: this._value = new int(); break;
+					case DbType.Int64					: this._value = new long(); break;
+					case DbType.UInt16					: this._value = new ushort(); break;
+					case DbType.UInt32					: this._value = new uint(); break;
+					case DbType.UInt64					: this._value = new long(); break;					
+					//Date type
+					case DbType.Date					: 
+					case DbType.DateTime				:
+					case DbType.Time					: this._value = new DateTime(); break;
+					//float type
+					case DbType.Decimal					: this._value = new decimal(); break;
+					case DbType.Currency				: 
+					case DbType.VarNumeric				: 
+					case DbType.Double					: this._value = new double(); break;
+					case DbType.Single					: this._value = new float(); break;
+					//user defined
+					case DbType.Object					: this._value = new object(); break;
+					//Guid
+					case DbType.Guid					: this._value = new Guid(); break;															
+					default								: throw new ArgumentOutOfRangeException(&quot;value&quot;);
+				}
+			}
+		}
+		
+		protected void SetValue( string value )
+		{
+				switch( this.DataType )
+				{
+					//string type
+					case DbType.Object					:					
+					case DbType.Binary					: 											
+					case DbType.AnsiString				: 
+					case DbType.AnsiStringFixedLength	: 
+					case DbType.String					: 
+					case DbType.StringFixedLength		: this._value = value; break;
+
+					case DbType.Boolean					: this._value = bool.Parse( value ); break;
+
+					case DbType.SByte					: this._value = sbyte.Parse( value ); break;
+					case DbType.Byte					: this._value = byte.Parse( value ); break;					 
+					case DbType.Int16					: this._value = short.Parse( value ); break;
+					case DbType.Int32					: this._value = int.Parse( value ); break;
+					case DbType.Int64					: this._value = long.Parse( value ); break;
+					case DbType.UInt16					: this._value = ushort.Parse( value ); break;
+					case DbType.UInt32					: this._value = uint.Parse( value ); break;
+					case DbType.UInt64					: this._value = long.Parse( value ); break;					
+
+					case DbType.Date					: 
+					case DbType.DateTime				:
+					case DbType.Time					: this._value = DateTime.Parse( value ); break;
+
+					case DbType.Decimal					: this._value = decimal.Parse( value ); break;
+					case DbType.Currency				: 
+					case DbType.VarNumeric				: 
+					case DbType.Double					: this._value = double.Parse( value ); break;
+					case DbType.Single					: this._value = float.Parse( value );  break;
+
+					case DbType.Guid					: this._value = new Guid( value ); break;															
+					default								: throw new ArgumentOutOfRangeException(&quot;value&quot;);
+				}			
+		}
+		
+		///&lt;summary&gt;
+		/// Value of the parameter
+		/// ( used only while extracting data or executing procedure )
+		///&lt;/summary&gt;
+		public object Value
+		{
+			get
+			{
+				return this._value;
+			}
+			set
+			{
+				this.SetValue( value.ToString() );
+			}
+		}
+		
+		///&lt;summary&gt;
+		/// Value of the parameter
+		/// ( used only while extracting data or executing procedure )
+		///&lt;/summary&gt;
+		public ParameterDirection Type
+		{
+			get
+			{
+				return this._type;
+			}
+			set
+			{
+				this._type = value;
+			}
+		}
+		
+		public override string NormalizedName 
+		{
+			get {
+				string normalizedName = &quot;&quot;;
+								
+				if ( (this.OwnerName != &quot;&quot;) &amp;&amp; (this.OwnerName != null) ){
+					normalizedName +=  this.OwnerName +  &quot;.&quot;;
+				} 				
+				
+				normalizedName +=  this.Name;
+				
+				return normalizedName;
+			}
+		}
+		
+		protected override void CreateEntitiesList()
+		{		
+		}
+		
+		public MonoQueryParameter( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{
+			this.pEntities = null;
+		}			
+		
+		protected override void OnRefresh()		
+		{
+			//nothing !
+		}
+
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt;&lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			//nothing
+			return null;
+		}	
+		
+//		///&lt;summary&gt; return a &lt;see cref=&quot;System.Windows.Forms.DataObject&quot;&gt;DataObject&lt;/see&gt; 
+//		///&lt;/summary&gt;		
+//		public override DataObject DragObject
+//		{
+//			get
+//			{
+//				DataObject returnValue = new DataObject();			
+//				string extract = NormalizedName;
+//				returnValue.SetData(typeof(string) , extract );
+//				return returnValue;
+//			}
+//		}		
+	}	
+	
+	///&lt;summary&gt;
+	/// Table class
+	///&lt;/summary&gt;	
+	public class MonoQueryProcedure : AbstractMonoQuerySchemaClass
+	{		
+		public override string NormalizedName 
+		{
+			get 
+			{
+				if ( (this.CatalogName != &quot;&quot;) &amp;&amp; (this.CatalogName != null) )
+				{
+					return this.CatalogName + &quot;.&quot; + this.Name;
+				}
+				else
+				{
+					return CheckWhiteSpace(this.Connection.GetProperty( MonoQueryPropertyEnum.DataSource ).ToString()) + &quot;.&quot; + this.Name;
+				}
+			}
+		}
+		
+		protected override void CreateEntitiesList()
+		{
+			base.CreateEntitiesList();
+			this.pEntities.Add(&quot;PROCEDURE_COLUMNS&quot;, new MonoQuerySchemaClassCollection() );
+			this.pEntities.Add(&quot;PROCEDURE_PARAMETERS&quot;, new MonoQuerySchemaClassCollection() );
+		}
+				
+		public MonoQueryProcedure( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{
+		}					
+		
+		public override MonoQuerySchemaClassCollection GetSchemaParameters()
+		{
+			return this.pDataConnection.GetSchemaProcedureParameters( this );			
+		}
+		
+		public override MonoQuerySchemaClassCollection GetSchemaColumns()
+		{
+			return this.pDataConnection.GetSchemaProcedureColumns( this );			
+		}		
+				
+		protected override void OnRefresh()
+		{
+			this.Entities[&quot;PROCEDURE_COLUMNS&quot;].AddRange( this.GetSchemaColumns() );
+			this.Entities[&quot;PROCEDURE_PARAMETERS&quot;].AddRange( this.GetSchemaParameters() );
+		}	
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			return this.Connection.ExecuteProcedure( this, rows, parameters );			
+		}		
+		
+//		///&lt;summary&gt; return a &lt;see cref=&quot;System.Windows.Forms.DataObject&quot;&gt;DataObject&lt;/see&gt; 
+//		///&lt;/summary&gt;		
+//		public override DataObject DragObject
+//		{
+//			get
+//			{
+//				DataObject returnValue = new DataObject();			
+//				string extract = &quot;EXECUTE &quot; + NormalizedName;
+//				returnValue.SetData(typeof(string) , extract );
+//				return returnValue;
+//			}
+//		}		
+	}
+	
+	///&lt;summary&gt;
+	/// Table class
+	///&lt;/summary&gt;	
+	public class MonoQueryTable : AbstractMonoQuerySchemaClass
+	{
+		public override string NormalizedName 
+		{
+			get 
+			{
+				if ( (this.CatalogName != &quot;&quot;) &amp;&amp; (this.CatalogName != null) )
+				{
+					return this.CatalogName + &quot;.&quot; + this.Name;
+				}
+				else
+				{
+					return CheckWhiteSpace(this.Connection.GetProperty( MonoQueryPropertyEnum.DataSource ).ToString()) + &quot;.&quot; + this.Name;
+				}
+			}
+		}
+		
+		protected override void CreateEntitiesList()
+		{
+			base.CreateEntitiesList();
+			this.pEntities.Add(&quot;TABLE_COLUMNS&quot;, new MonoQuerySchemaClassCollection() );
+		}		
+				
+		public MonoQueryTable( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{
+		}		
+		
+		public override MonoQuerySchemaClassCollection GetSchemaColumns()
+		{	
+			return this.pDataConnection.GetSchemaTableColumns( this );
+		}	
+		
+		protected override void OnRefresh()
+		{
+			this.Entities[&quot;TABLE_COLUMNS&quot;].AddRange( this.GetSchemaColumns() );			
+		}		
+
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			return this.Connection.ExtractData( this, rows );
+		}	
+		
+//		///&lt;summary&gt; return a &lt;see cref=&quot;System.Windows.Forms.DataObject&quot;&gt;DataObject&lt;/see&gt; 
+//		///&lt;/summary&gt;		
+//		public override DataObject DragObject
+//		{
+//			get
+//			{		
+//				string SQLSelect = &quot;SELECT &quot;;
+//				string SQLFrom  = &quot;FROM &quot;;	
+//				
+//				MonoQuerySchemaClassCollection entitieslist = null;
+//			 
+//				SQLFrom += this.Name;
+//			
+//				this.Refresh();
+//				
+//				//we have only a table or view :o)
+//				foreach( DictionaryEntry DicEntry in Entities )
+//				{
+//				  entitieslist = DicEntry.Value as MonoQuerySchemaClassCollection;
+//			      break;
+//				}
+//						
+//				if ( entitieslist == null )
+//				{
+//					throw new System.ArgumentNullException(&quot;entitieslist&quot;);
+//				}					
+//						
+//				foreach( ISchemaClass column in entitieslist )
+//				{
+//					SQLSelect += column.NormalizedName;					
+//					SQLSelect += &quot;,&quot;;
+//				}																		
+//
+//				SQLSelect = SQLSelect.TrimEnd( new Char[]{','} );
+//				SQLSelect += &quot; &quot;;
+//
+//				DataObject returnValue = new DataObject();							
+//				
+//				returnValue.SetData(typeof(string) , SQLSelect + SQLFrom );
+//				return returnValue;
+//			}
+//		}		
+	}
+	
+	///&lt;summary&gt;
+	/// View class
+	///&lt;/summary&gt;	
+	public class MonoQueryView : AbstractMonoQuerySchemaClass
+	{
+		public override string NormalizedName 
+		{
+			get 
+			{
+				if ( (this.CatalogName != &quot;&quot;) &amp;&amp; (this.CatalogName != null) )
+				{
+					return this.CatalogName + &quot;.&quot; + this.Name;
+				}
+				else
+				{
+					return CheckWhiteSpace(this.Connection.GetProperty( MonoQueryPropertyEnum.DataSource ).ToString()) + &quot;.&quot; + this.Name;
+				}
+			}
+		}
+		
+		protected override void CreateEntitiesList()
+		{
+			base.CreateEntitiesList();
+			this.pEntities.Add(&quot;VIEWS_COLUMNS&quot;, new MonoQuerySchemaClassCollection() );
+		}		
+		
+		public MonoQueryView( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{
+		}		
+
+		public override MonoQuerySchemaClassCollection GetSchemaColumns()
+		{	
+			return this.pDataConnection.GetSchemaViewColumns( this );
+		}		
+
+		protected override void OnRefresh()
+		{
+			this.Entities[&quot;VIEWS_COLUMNS&quot;].AddRange( this.GetSchemaColumns() );			
+		}	
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			return this.Connection.ExtractData( this, rows );
+		}	
+		
+//		///&lt;summary&gt; return a &lt;see cref=&quot;System.Windows.Forms.DataObject&quot;&gt;DataObject&lt;/see&gt; 
+//		///&lt;/summary&gt;		
+//		public override DataObject DragObject
+//		{
+//			get
+//			{		
+//				string SQLSelect = &quot;SELECT &quot;;
+//				string SQLFrom  = &quot;FROM &quot;;	
+//				
+//				MonoQuerySchemaClassCollection entitieslist = null;
+//			 
+//				SQLFrom += this.Name;
+//			
+//				this.Refresh();
+//				
+//				//we have only a table or view :o)
+//				foreach( DictionaryEntry DicEntry in Entities )
+//				{
+//				  entitieslist = DicEntry.Value as MonoQuerySchemaClassCollection;
+//			      break;
+//				}
+//						
+//				if ( entitieslist == null )
+//				{
+//					throw new System.ArgumentNullException(&quot;entitieslist&quot;);
+//				}					
+//						
+//				foreach( ISchemaClass column in entitieslist )
+//				{
+//					SQLSelect += column.NormalizedName;					
+//					SQLSelect += &quot;,&quot;;
+//				}																		
+//
+//				SQLSelect = SQLSelect.TrimEnd( new Char[]{','} );
+//				SQLSelect += &quot; &quot;;
+//
+//				DataObject returnValue = new DataObject();							
+//				
+//				returnValue.SetData(typeof(string) , SQLSelect + SQLFrom );
+//				return returnValue;
+//			}
+//		}		
+	}	
+	
+	///&lt;summary&gt;
+	/// Class for unsupported functions
+	///&lt;/summary&gt;	
+	public class MonoQueryNotSupported : AbstractMonoQuerySchemaClass
+	{		
+		protected override void CreateEntitiesList()
+		{
+		}
+		
+		public MonoQueryNotSupported( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{			
+			StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+			this.pName += &quot; &quot; + GettextCatalog.GetString( &quot;Not Supported&quot; )  + &quot; &quot; + connection.Provider;			
+
+		}
+		
+		protected override void OnRefresh()
+		{
+			//nothing !
+		}	
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			//nothing
+			return null;
+		}	
+	}	
+	
+	
+	///&lt;summary&gt;
+	/// Class lis of Tables
+	///&lt;/summary&gt;	
+	public class MonoQueryTables : AbstractMonoQuerySchemaClass	
+	{
+		protected override void CreateEntitiesList()
+		{
+			base.CreateEntitiesList();
+			this.pEntities.Add(&quot;TABLES&quot;, new MonoQuerySchemaClassCollection() );
+		}
+		
+		public MonoQueryTables( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{
+			this.pName = GettextCatalog.GetString( &quot;Tables&quot; ) ;
+		}		
+		
+		protected override void OnRefresh()
+		{
+			this.Entities[&quot;TABLES&quot;].AddRange( this.GetSchemaTables() );
+		}	
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			//nothing
+			return null;
+		}		
+	}	
+	
+	///&lt;summary&gt;
+	/// Class lis of Views
+	///&lt;/summary&gt;	
+	public class MonoQueryViews : AbstractMonoQuerySchemaClass
+	{		
+		
+		protected override void CreateEntitiesList()
+		{
+			base.CreateEntitiesList();
+			this.pEntities.Add(&quot;VIEWS&quot;, new MonoQuerySchemaClassCollection() );
+		}
+		
+		public MonoQueryViews( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{			
+			StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+			this.pName = GettextCatalog.GetString( &quot;Views&quot; );
+		}
+		
+		protected override void OnRefresh()
+		{
+			this.Entities[&quot;VIEWS&quot;].AddRange( this.GetSchemaViews() );					
+		}
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			//nothing
+			return null;
+		}		
+	}
+	
+	///&lt;summary&gt;
+	/// Class lis of Procedures
+	///&lt;/summary&gt;	
+	public class MonoQueryProcedures : AbstractMonoQuerySchemaClass
+	{			
+		protected override void CreateEntitiesList()
+		{
+			base.CreateEntitiesList();
+			this.pEntities.Add(&quot;PROCEDURES&quot;, new MonoQuerySchemaClassCollection() );
+		}
+		
+		public MonoQueryProcedures( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{			
+			StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+			this.pName = GettextCatalog.GetString( &quot;Procedures&quot; );
+		}
+		
+		protected override void OnRefresh()
+		{
+			this.Entities[&quot;PROCEDURES&quot;].AddRange( this.GetSchemaProcedures() );			
+		}	
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			//nothing
+			return null;
+		}			
+	}	
+	
+	///&lt;summary&gt;
+	/// Class lis of Schemas
+	///&lt;/summary&gt;	
+	public class MonoQuerySchema : AbstractMonoQuerySchemaClass
+	{						
+		protected override void CreateEntitiesList()
+		{
+			base.CreateEntitiesList();
+			this.pEntities.Add(&quot;TABLES&quot;, new MonoQuerySchemaClassCollection( new ISchemaClass[] { new MonoQueryTables(this.pDataConnection, this.CatalogName, this.Name, &quot;&quot;, &quot;&quot;) } ) );
+			this.pEntities.Add(&quot;VIEWS&quot;, new MonoQuerySchemaClassCollection( new ISchemaClass[] { new MonoQueryViews(this.pDataConnection, this.CatalogName, this.Name, &quot;&quot;, &quot;&quot;) } ) );
+			this.pEntities.Add(&quot;PROCEDURES&quot;, new MonoQuerySchemaClassCollection( new ISchemaClass[] { new MonoQueryProcedures(this.pDataConnection, this.CatalogName, this.Name, &quot;&quot;, &quot;&quot;) } ) );
+		}
+		
+		public MonoQuerySchema( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{		
+		}		
+
+		protected override void OnRefresh()
+		{	
+			// Nothing !
+		}		
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			//nothing
+			return null;
+		}	
+		
+//		///&lt;summary&gt; return a &lt;see cref=&quot;System.Windows.Forms.DataObject&quot;&gt;DataObject&lt;/see&gt; 
+//		///&lt;/summary&gt;		
+//		public override DataObject DragObject
+//		{
+//			get
+//			{
+//				DataObject returnValue = new DataObject();			
+//				string extract = NormalizedName;
+//				returnValue.SetData(typeof(string) , extract );
+//				return returnValue;
+//			}		
+//		}
+	}	
+	
+	///&lt;summary&gt;
+	/// Class for a catalog
+	///&lt;/summary&gt;	
+	public class MonoQueryCatalog : AbstractMonoQuerySchemaClass
+	{							
+		protected override void CreateEntitiesList()
+		{
+			base.CreateEntitiesList();
+			this.pEntities.Add(&quot;SCHEMAS&quot;, new MonoQuerySchemaClassCollection() );			
+		}
+		
+		public MonoQueryCatalog( IConnection connection, string catalogName, string schemaName, string ownerName, string name  ) : base(connection, catalogName, schemaName, ownerName, name )
+		{			
+		}		
+		
+		protected override void OnRefresh()
+		{
+			this.Entities[&quot;SCHEMAS&quot;].AddRange( this.GetSchemaSchemas() );			
+		}
+		
+		///&lt;summary&gt;
+		/// For a Table or a View extract data.
+		/// For a stocked procedure, execute it :o).
+		/// &lt;param name=&quot;rows&quot;&gt;Number of row to extract. if &quot;0&quot;, extract all rows.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt; 
+		/// or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object Execute( int rows, MonoQuerySchemaClassCollection parameters )
+		{
+			//nothing
+			return null;
+		}
+		
+//		///&lt;summary&gt; return a &lt;see cref=&quot;System.Windows.Forms.DataObject&quot;&gt;DataObject&lt;/see&gt; 
+//		///&lt;/summary&gt;		
+//		public override DataObject DragObject
+//		{
+//			get
+//			{
+//				DataObject returnValue = new DataObject();			
+//				string extract = NormalizedName;
+//				returnValue.SetData(typeof(string) , extract );
+//				return returnValue;
+//			}
+//		}	
+	}
+}
Index: Extras/MonoQuery/ChangeLog
===================================================================
--- Extras/MonoQuery/ChangeLog	(revision 0)
+++ Extras/MonoQuery/ChangeLog	(revision 0)
@@ -0,0 +1,3 @@
+2005-01-06  Christian Hergert &lt;<A HREF="mailto:chris@mosaix.net">chris@mosaix.net</A>&gt;
+
+	* Initial creation of MonoQuery AddIn
Index: Extras/MonoQuery/Collection/MonoQueryParameterCollection.cs
===================================================================
--- Extras/MonoQuery/Collection/MonoQueryParameterCollection.cs	(revision 0)
+++ Extras/MonoQuery/Collection/MonoQueryParameterCollection.cs	(revision 0)
@@ -0,0 +1,258 @@
+// ------------------------------------------------------------------------------
+// This file was autogenerated.
+// ------------------------------------------------------------------------------
+// 
+namespace MonoQuery.Collections {
+	using System;
+	using System.Collections;
+	using MonoQuery.SchemaClass;
+	
+	
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.MonoQueryParameter'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.MonoQueryParameterCollection'/&gt;
+	[Serializable()]
+	public class MonoQueryParameterCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.MonoQueryParameterCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public MonoQueryParameterCollection() {
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.MonoQueryParameterCollection'/&gt; based on another &lt;see cref='.MonoQueryParameterCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.MonoQueryParameterCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public MonoQueryParameterCollection(MonoQueryParameterCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.MonoQueryParameterCollection'/&gt; containing any array of &lt;see cref='.MonoQueryParameter'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.MonoQueryParameter'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public MonoQueryParameterCollection(MonoQueryParameter[] value) {
+			this.AddRange(value);
+		}
+		
+		
+		public MonoQueryParameterCollection(MonoQuerySchemaClassCollection value) {
+			this.AddRange( value );
+		}						
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.MonoQueryParameter'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public MonoQueryParameter this[int index] {
+			get {
+				return ((MonoQueryParameter)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		public MonoQuerySchemaClassCollection ToBaseSchemaCollection()
+		{
+			MonoQuerySchemaClassCollection returnValues = new MonoQuerySchemaClassCollection();
+			foreach( MonoQueryParameter par in this )
+			{
+				returnValues.Add( par );	
+			}
+			
+			return returnValues;
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.MonoQueryParameter'/&gt; with the specified value to the 
+		///    &lt;see cref='.MonoQueryParameterCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.MonoQueryParameter'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQueryParameterCollection.AddRange'/&gt;
+		public int Add(MonoQueryParameter value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.MonoQueryParameterCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.MonoQueryParameter'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQueryParameterCollection.Add'/&gt;
+		public void AddRange(MonoQueryParameter[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.MonoQueryParameterCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.MonoQueryParameterCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQueryParameterCollection.Add'/&gt;
+		public void AddRange(MonoQueryParameterCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		
+		public void AddRange(MonoQuerySchemaClassCollection value) 
+		{
+			foreach( MonoQueryParameter par in value ) 
+			{
+				this.Add( par );				
+			}
+		}						
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the 
+		///    &lt;see cref='.MonoQueryParameterCollection'/&gt; contains the specified &lt;see cref='.MonoQueryParameter'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.MonoQueryParameter'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.MonoQueryParameter'/&gt; is contained in the collection; 
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQueryParameterCollection.IndexOf'/&gt;
+		public bool Contains(MonoQueryParameter value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.MonoQueryParameterCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the 
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.MonoQueryParameterCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.MonoQueryParameterCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(MonoQueryParameter[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.MonoQueryParameter'/&gt; in 
+		///       the &lt;see cref='.MonoQueryParameterCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.MonoQueryParameter'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.MonoQueryParameter'/&gt; of &lt;paramref name='value'/&gt; in the 
+		/// &lt;see cref='.MonoQueryParameterCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQueryParameterCollection.Contains'/&gt;
+		public int IndexOf(MonoQueryParameter value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.MonoQueryParameter'/&gt; into the &lt;see cref='.MonoQueryParameterCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.MonoQueryParameter'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQueryParameterCollection.Add'/&gt;
+		public void Insert(int index, MonoQueryParameter value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through 
+		///       the &lt;see cref='.MonoQueryParameterCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new MonoQueryParameterEnumerator GetEnumerator() {
+			return new MonoQueryParameterEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.MonoQueryParameter'/&gt; from the 
+		///    &lt;see cref='.MonoQueryParameterCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.MonoQueryParameter'/&gt; to remove from the &lt;see cref='.MonoQueryParameterCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(MonoQueryParameter value) {
+			List.Remove(value);
+		}
+		
+		public class MonoQueryParameterEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public MonoQueryParameterEnumerator(MonoQueryParameterCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public MonoQueryParameter Current {
+				get {
+					return ((MonoQueryParameter)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}
Index: Extras/MonoQuery/Collection/MonoQueryStringDictionary.cs
===================================================================
--- Extras/MonoQuery/Collection/MonoQueryStringDictionary.cs	(revision 0)
+++ Extras/MonoQuery/Collection/MonoQueryStringDictionary.cs	(revision 0)
@@ -0,0 +1,83 @@
+using  System;
+using  System.Collections;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+namespace MonoQuery.Collections {
+	///&lt;summary&gt;String dictionnary
+	/// &lt;param name='key'&gt; this a string is defining the key&lt;/param&gt;
+	/// &lt;param name='value'&gt; this a string is defining the value&lt;/param&gt;
+	/// &lt;/summary&gt;
+	public class MonoQueryStringDictionary : DictionaryBase  {
+	
+	readonly StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+	
+	public string this[ string key ]  {
+	      get  {
+	         return( (string) Dictionary[key] );
+	      }
+	      set  {
+	         Dictionary[key] = value;
+	      }
+	   }
+	
+	   public ICollection Keys  {
+	      get  {
+	         return( Dictionary.Keys );
+	      }
+	   }
+	
+	   public ICollection Values  {
+	      get  {
+	         return( Dictionary.Values );
+	      }
+	   }
+	
+	   public void Add( string key, string value )  {
+	      Dictionary.Add( key, value );
+	   }
+	
+	   public bool Contains( string key )  {
+	      return( Dictionary.Contains( key ) );
+	   }
+	
+	   public void Remove( string key )  {
+	      Dictionary.Remove( key );
+	   }
+	
+	   protected override void OnInsert( object key, object value )  {
+	      StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+	      if ( !(key is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Key Type&quot; ), &quot;key&quot; );
+	
+	      if ( !(value is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Value Type&quot; ), &quot;value&quot; );
+	   }
+	
+	   protected override void OnRemove( object key, object value )  {
+		StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+	      if ( !(key is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Key Type&quot; ), &quot;key&quot; );
+	      }
+	
+	   protected override void OnSet( object key, object oldValue, object newValue )  {
+		  StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));	 
+	 	  if (!(key is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Key Type&quot; ), &quot;key&quot; );
+	
+	      if ( !(newValue is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Value Type&quot; ), &quot;newValue&quot; );
+	   }
+	
+	   protected override void OnValidate( object key, object value )  {
+		  StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));	   	
+	      if ( !(key is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Key Type&quot; ), &quot;key&quot; );
+	   	
+	      if ( !(value is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Value Type&quot; ), &quot;value&quot; );
+	   }
+	
+	}
+}
Index: Extras/MonoQuery/Collection/MonoQueryListDictionary.cs
===================================================================
--- Extras/MonoQuery/Collection/MonoQueryListDictionary.cs	(revision 0)
+++ Extras/MonoQuery/Collection/MonoQueryListDictionary.cs	(revision 0)
@@ -0,0 +1,85 @@
+// created on 11/11/2003 at 11:20
+
+using  System;
+using  System.Collections;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+
+namespace MonoQuery.Collections {
+	
+	///&lt;summary&gt;List dictionnary.
+	/// &lt;param name='key'&gt; this a string is defining the key&lt;/param&gt;
+	/// &lt;param name='value'&gt; this a  &lt;see cref=&quot;.MonoQuerySchemaClassCollection&quot;&gt;&lt;/see&gt; is defining the value&lt;/param&gt;
+	/// &lt;/summary&gt;
+
+	public class MonoQueryListDictionary : DictionaryBase
+	{	
+		public MonoQuerySchemaClassCollection this[ string key ]  {
+	    	get  {
+	    		return( (MonoQuerySchemaClassCollection) Dictionary[key] );
+	    	}
+	    	set {
+				Dictionary[key] = value;
+	    	}
+	    }
+	
+	   public ICollection Keys  {
+	      get  {
+	         return( Dictionary.Keys );
+	      }
+	   }
+	
+	   public ICollection Values  {
+	      get  {
+	         return( Dictionary.Values );
+	      }
+	   }
+	
+	   public void Add( string key, MonoQuerySchemaClassCollection value )  {
+	      Dictionary.Add( key, value );
+	   }
+	
+	   public bool Contains( string key )  {
+	      return( Dictionary.Contains( key ) );
+	   }
+	
+	   public void Remove( string key )  {
+	      Dictionary.Remove( key );
+	   }
+	
+	   protected override void OnInsert( object key, object value )  {
+	      StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+	      if ( !(key is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Key Type&quot; ), &quot;key&quot; );
+	
+	      if ( !(value is MonoQuerySchemaClassCollection) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Value Type&quot; ), &quot;value&quot; );
+	   }
+	
+	   protected override void OnRemove( object key, object value )  {
+		StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));
+	      if ( !(key is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Key Type&quot; ), &quot;key&quot; );
+	      }
+	
+	   protected override void OnSet( object key, object oldValue, object newValue )  {
+		  StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));	 
+	 	  if (!(key is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Key Type&quot; ), &quot;key&quot; );
+	
+	      if ( !(newValue is MonoQuerySchemaClassCollection) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Value Type&quot; ), &quot;newValue&quot; );
+	   }
+	
+	   protected override void OnValidate( object key, object value )  {
+		  StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));	   	
+	      if ( !(key is string) )
+	         throw new ArgumentException( GettextCatalog.GetString( &quot;Wrong Key Type&quot; ), &quot;key&quot; );
+	   	
+	      if ( !(value is MonoQuerySchemaClassCollection) )
+	         throw new ArgumentException(  GettextCatalog.GetString( &quot;Wrong Value Type&quot; ), &quot;value&quot; );
+	   }
+	
+	}
+}
Index: Extras/MonoQuery/Collection/MonoQuerySchemaClassCollection.cs
===================================================================
--- Extras/MonoQuery/Collection/MonoQuerySchemaClassCollection.cs	(revision 0)
+++ Extras/MonoQuery/Collection/MonoQuerySchemaClassCollection.cs	(revision 0)
@@ -0,0 +1,233 @@
+// ------------------------------------------------------------------------------
+// This file was autogenerated.
+// ------------------------------------------------------------------------------
+// 
+namespace MonoQuery.Collections {
+	using System;
+	using System.Collections;
+	using MonoQuery.SchemaClass;
+	
+	
+	/// &lt;summary&gt;
+	///     &lt;para&gt;
+	///       A collection that stores &lt;see cref='.ISchemaClass'/&gt; objects.
+	///    &lt;/para&gt;
+	/// &lt;/summary&gt;
+	/// &lt;seealso cref='.MonoQuerySchemaClassCollection'/&gt;
+	[Serializable()]
+	public class MonoQuerySchemaClassCollection : CollectionBase {
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.MonoQuerySchemaClassCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		public MonoQuerySchemaClassCollection() {			
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; based on another &lt;see cref='.MonoQuerySchemaClassCollection'/&gt;.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; from which the contents are copied
+		/// &lt;/param&gt;
+		public MonoQuerySchemaClassCollection(MonoQuerySchemaClassCollection value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Initializes a new instance of &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; containing any array of &lt;see cref='.ISchemaClass'/&gt; objects.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///       A array of &lt;see cref='.ISchemaClass'/&gt; objects with which to intialize the collection
+		/// &lt;/param&gt;
+		public MonoQuerySchemaClassCollection(ISchemaClass[] value) {
+			this.AddRange(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Represents the entry at the specified index of the &lt;see cref='.ISchemaClass'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;&lt;para&gt;The zero-based index of the entry to locate in the collection.&lt;/para&gt;&lt;/param&gt;
+		/// &lt;value&gt;
+		///    &lt;para&gt; The entry at the specified index of the collection.&lt;/para&gt;
+		/// &lt;/value&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='index'/&gt; is outside the valid range of indexes for the collection.&lt;/exception&gt;
+		public ISchemaClass this[int index] {
+			get {
+				return ((ISchemaClass)(List[index]));
+			}
+			set {
+				List[index] = value;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Adds a &lt;see cref='.ISchemaClass'/&gt; with the specified value to the 
+		///    &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.ISchemaClass'/&gt; to add.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///    &lt;para&gt;The index at which the new element was inserted.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQuerySchemaClassCollection.AddRange'/&gt;
+		public int Add(ISchemaClass value) {
+			return List.Add(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the elements of an array to the end of the &lt;see cref='.MonoQuerySchemaClassCollection'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    An array of type &lt;see cref='.ISchemaClass'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQuerySchemaClassCollection.Add'/&gt;
+		public void AddRange(ISchemaClass[] value) {
+			for (int i = 0; (i &lt; value.Length); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		///     &lt;para&gt;
+		///       Adds the contents of another &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; to the end of the collection.
+		///    &lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;
+		///    A &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; containing the objects to add to the collection.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQuerySchemaClassCollection.Add'/&gt;
+		public void AddRange(MonoQuerySchemaClassCollection value) {
+			for (int i = 0; (i &lt; value.Count); i = (i + 1)) {
+				this.Add(value[i]);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Gets a value indicating whether the 
+		///    &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; contains the specified &lt;see cref='.ISchemaClass'/&gt;.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.ISchemaClass'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;&lt;see langword='true'/&gt; if the &lt;see cref='.ISchemaClass'/&gt; is contained in the collection; 
+		///   otherwise, &lt;see langword='false'/&gt;.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQuerySchemaClassCollection.IndexOf'/&gt;
+		public bool Contains(ISchemaClass value) {
+			return List.Contains(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Copies the &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; values to a one-dimensional &lt;see cref='System.Array'/&gt; instance at the 
+		///    specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='array'&gt;&lt;para&gt;The one-dimensional &lt;see cref='System.Array'/&gt; that is the destination of the values copied from &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; .&lt;/para&gt;&lt;/param&gt;
+		/// &lt;param name='index'&gt;The index in &lt;paramref name='array'/&gt; where copying begins.&lt;/param&gt;
+		/// &lt;returns&gt;
+		///   &lt;para&gt;None.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;para&gt;&lt;paramref name='array'/&gt; is multidimensional.&lt;/para&gt; &lt;para&gt;-or-&lt;/para&gt; &lt;para&gt;The number of elements in the &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; is greater than the available space between &lt;paramref name='arrayIndex'/&gt; and the end of &lt;paramref name='array'/&gt;.&lt;/para&gt;&lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentNullException'&gt;&lt;paramref name='array'/&gt; is &lt;see langword='null'/&gt;. &lt;/exception&gt;
+		/// &lt;exception cref='System.ArgumentOutOfRangeException'&gt;&lt;paramref name='arrayIndex'/&gt; is less than &lt;paramref name='array'/&gt;'s lowbound. &lt;/exception&gt;
+		/// &lt;seealso cref='System.Array'/&gt;
+		public void CopyTo(ISchemaClass[] array, int index) {
+			List.CopyTo(array, index);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns the index of a &lt;see cref='.ISchemaClass'/&gt; in 
+		///       the &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.ISchemaClass'/&gt; to locate.&lt;/param&gt;
+		/// &lt;returns&gt;
+		/// &lt;para&gt;The index of the &lt;see cref='.ISchemaClass'/&gt; of &lt;paramref name='value'/&gt; in the 
+		/// &lt;see cref='.MonoQuerySchemaClassCollection'/&gt;, if found; otherwise, -1.&lt;/para&gt;
+		/// &lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQuerySchemaClassCollection.Contains'/&gt;
+		public int IndexOf(ISchemaClass value) {
+			return List.IndexOf(value);
+		}
+		
+		/// &lt;summary&gt;
+		/// &lt;para&gt;Inserts a &lt;see cref='.ISchemaClass'/&gt; into the &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; at the specified index.&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='index'&gt;The zero-based index where &lt;paramref name='value'/&gt; should be inserted.&lt;/param&gt;
+		/// &lt;param name=' value'&gt;The &lt;see cref='.ISchemaClass'/&gt; to insert.&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='.MonoQuerySchemaClassCollection.Add'/&gt;
+		public void Insert(int index, ISchemaClass value) {
+			List.Insert(index, value);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt;Returns an enumerator that can iterate through 
+		///       the &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;seealso cref='System.Collections.IEnumerator'/&gt;
+		public new ISchemaClassEnumerator GetEnumerator() {
+			return new ISchemaClassEnumerator(this);
+		}
+		
+		/// &lt;summary&gt;
+		///    &lt;para&gt; Removes a specific &lt;see cref='.ISchemaClass'/&gt; from the 
+		///    &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; .&lt;/para&gt;
+		/// &lt;/summary&gt;
+		/// &lt;param name='value'&gt;The &lt;see cref='.ISchemaClass'/&gt; to remove from the &lt;see cref='.MonoQuerySchemaClassCollection'/&gt; .&lt;/param&gt;
+		/// &lt;returns&gt;&lt;para&gt;None.&lt;/para&gt;&lt;/returns&gt;
+		/// &lt;exception cref='System.ArgumentException'&gt;&lt;paramref name='value'/&gt; is not found in the Collection. &lt;/exception&gt;
+		public void Remove(ISchemaClass value) {
+			List.Remove(value);
+		}
+		
+		public class ISchemaClassEnumerator : object, IEnumerator {
+			
+			private IEnumerator baseEnumerator;
+			
+			private IEnumerable temp;
+			
+			public ISchemaClassEnumerator(MonoQuerySchemaClassCollection mappings) {
+				this.temp = ((IEnumerable)(mappings));
+				this.baseEnumerator = temp.GetEnumerator();
+			}
+			
+			public ISchemaClass Current {
+				get {
+					return ((ISchemaClass)(baseEnumerator.Current));
+				}
+			}
+			
+			object IEnumerator.Current {
+				get {
+					return baseEnumerator.Current;
+				}
+			}
+			
+			public bool MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			bool IEnumerator.MoveNext() {
+				return baseEnumerator.MoveNext();
+			}
+			
+			public void Reset() {
+				baseEnumerator.Reset();
+			}
+			
+			void IEnumerator.Reset() {
+				baseEnumerator.Reset();
+			}
+		}
+	}
+}
Index: Extras/MonoQuery/Collection/ConnectionProviderDescriptor.cs
===================================================================
--- Extras/MonoQuery/Collection/ConnectionProviderDescriptor.cs	(revision 0)
+++ Extras/MonoQuery/Collection/ConnectionProviderDescriptor.cs	(revision 0)
@@ -0,0 +1,33 @@
+
+using System;
+
+namespace MonoQuery.Collections
+{
+	public class ConnectionProviderDescriptor
+	{
+		private Type providerType;
+		private string name;
+		private string connectionStringExample;
+		
+		public Type ProviderType
+		{
+			get { return providerType; }
+		}
+		public string Name
+		{
+			get { return name; }
+		}
+		public string ConnectionStringExample
+		{
+			get { return connectionStringExample; }
+		}
+		
+		public ConnectionProviderDescriptor( string name, Type type ) : this ( name, type, null ) {}
+		public ConnectionProviderDescriptor( string name, Type type, string example )
+		{
+			this.name = name;
+			this.providerType = type;
+			this.connectionStringExample = example;
+		}
+	}
+}
\ No newline at end of file
Index: Extras/MonoQuery/MonoQueryView.cs
===================================================================
--- Extras/MonoQuery/MonoQueryView.cs	(revision 0)
+++ Extras/MonoQuery/MonoQueryView.cs	(revision 0)
@@ -0,0 +1,87 @@
+
+using System;
+using System.Xml;
+using System.Xml.Serialization;
+using System.IO;
+
+using MonoDevelop.Gui;
+using MonoQuery.Gui;
+using MonoQuery.Gui.TreeView;
+using MonoQuery.Services;
+
+using MonoDevelop.Core.Services;
+using MonoDevelop.Services;
+using MonoDevelop.Core.AddIns;
+
+//TODO : dans les MonoQueryList faire correspondre les restrictions vec les objets ajoutés
+//TODO : dans les MonoQueryList faire correspondre les dataconnection avec les objets ajoutés
+//TODO : ajout statistiques.
+
+namespace MonoQuery.Pads
+{
+	/// &lt;summary&gt;
+	/// This Pad Show a tree where you can add/remove databases connections.
+	/// You can administrate databases from this tree.
+	/// &lt;/summary&gt;
+	public class MonoQueryView : AbstractPadContent
+	{		
+		private static MonoQueryTree monoQueryTree = null;
+		private static Gtk.ScrolledWindow scroller = null;
+#region AbstractPadContent requirements
+		/// &lt;summary&gt;
+		/// The &lt;see cref=&quot;System.Windows.Forms.Control&quot;/&gt; representing the pad
+		/// &lt;/summary&gt;
+		public override Gtk.Widget Control {
+			get {
+				return scroller;
+			}
+		}
+				
+		/// &lt;summary&gt;
+		/// Creates a new MonoQueryView object
+		/// &lt;/summary&gt;
+		public MonoQueryView()
+			: base( GettextCatalog.GetString( &quot;Database&quot; ), &quot;Icons.16x16.MonoQuery.DatabaseConnection&quot;)
+		{
+			CreateDefaultMonoQuery();
+//			monoQueryTree.Dock = DockStyle.Fill;
+		}
+		
+		void CreateDefaultMonoQuery()
+		{
+			scroller = new Gtk.ScrolledWindow();
+			scroller.ShadowType = Gtk.ShadowType.In;
+			monoQueryTree = new MonoQueryTree();
+			scroller.Add( monoQueryTree );
+			
+			MonoQueryService service = (MonoQueryService)ServiceManager.GetService(
+				typeof(MonoQueryService));
+			service.Tree = monoQueryTree;
+		}		
+		
+		public void SaveMonoQueryView()
+		{
+		}		
+		
+		/// &lt;summary&gt;
+		/// Refreshes the pad
+		/// &lt;/summary&gt;
+		public override void RedrawContent()
+		{
+			OnTitleChanged(null);
+			OnIconChanged(null);	
+//			monoQueryTree.Refresh();
+		}
+		
+		/// &lt;summary&gt;
+		/// Cleans up all used resources
+		/// &lt;/summary&gt;
+		public override void Dispose()
+		{
+			this.SaveMonoQueryView();
+			monoQueryTree.Dispose();
+		}
+#endregion
+	}
+	
+}
Index: Extras/MonoQuery/Connection/Interface/IConnection.cs
===================================================================
--- Extras/MonoQuery/Connection/Interface/IConnection.cs	(revision 0)
+++ Extras/MonoQuery/Connection/Interface/IConnection.cs	(revision 0)
@@ -0,0 +1,222 @@
+namespace MonoQuery.Connection
+{
+	using System.Collections;
+	using MonoQuery.Collections;
+	using MonoQuery.SchemaClass;
+	using System.Data;
+	
+	///&lt;summary&gt;
+	/// This interface is used by any connection wrapper class. 
+	///&lt;/summary&gt;
+	public interface IConnection
+	{				
+		///&lt;summary&gt;
+		/// return &lt;c&gt;true&lt;/c&gt; if the connection string is invalid.
+		///&lt;/summary&gt;
+		bool IsConnectionStringWrong
+		{
+			get;
+		}		
+		///&lt;summary&gt;Return the connection string.&lt;/summary&gt;
+		string ConnectionString{ get; set;}
+		
+		///&lt;summary&gt;Provider'sname.
+		/// &lt;/summary&gt;		
+		string Provider{ get; }
+		
+		///&lt;summary&gt;
+		/// get the &lt;code&gt;connection&lt;/code&gt;'s &lt;code&gt;catalog&lt;/code&gt; name.
+		///&lt;/summary&gt;	
+		string CatalogName{ get; }
+	
+		///&lt;summary&gt;
+		/// get the &lt;code&gt;connection&lt;/code&gt;'s &lt;code&gt;schema&lt;/code&gt; name.
+		///&lt;/summary&gt;	
+		string SchemaName{ get; }	
+				
+		///&lt;summary&gt;
+		/// get the &lt;code&gt;entity&lt;/code&gt;'s name
+		///&lt;/summary&gt;	
+		string Name{ get; }
+		
+		///&lt;summary&gt;
+		/// &lt;code&gt;entity&lt;/code&gt;'s normalized name.
+		/// &lt;example&gt;
+		/// there are a database &lt;code&gt;test&lt;/code&gt;. In this database there are a &lt;code&gt;schema&lt;/code&gt; 
+		/// named &lt;code&gt;fool&lt;/code&gt;. In this &lt;code&gt;schema&lt;/code&gt; there are a &lt;code&gt;table&lt;/code&gt; named &lt;code&gt;fooltable&lt;/code&gt;
+		/// and a in this &lt;code&gt;table&lt;/code&gt; there are a &lt;code&gt;column&lt;/code&gt; named &lt;code&gt;foolcolumn&lt;/code&gt;.
+		/// So, the normalized name of the &lt;code&gt;schema&lt;/code&gt; is &lt;code&gt;test.[fool]&lt;/code&gt;.
+		/// The normalized name of the &lt;code&gt;table&lt;/code&gt; is &lt;code&gt;test.[fool].fooltable&lt;/code&gt;.
+		/// The normalized name of the &lt;code&gt;column&lt;/code&gt; is &lt;code&gt;test.[fool].fooltable.foolcolumn&lt;/code&gt;.
+		///&lt;/example&gt;
+		///&lt;/summary&gt;			
+		string NormalizedName{ get; }		
+		
+		///&lt;summary&gt;
+		/// &lt;returns&gt; 
+		///	&lt;code&gt;true&lt;/code&gt; if the connection is opened.
+		/// &lt;code&gt;false&lt;/code&gt; if the connection is not opened.
+		/// &lt;/returns&gt;
+		/// &lt;/summary&gt;		
+		bool IsOpen{ get; }
+		
+		///&lt;summary&gt;
+		/// Those, are list of the childs schema.( columns, etc etc )
+		/// i am using a dictionnary because is more simplest to write 
+		/// &lt;code&gt;Entities[&quot;PROCEDURES&quot;]&lt;/code&gt; than &lt;code&gt;Entities[0]&lt;/code&gt;.
+		///&lt;/summary&gt;		
+		MonoQueryListDictionary Entities { get; }		
+		
+		///&lt;summary&gt;
+		/// &lt;returns&gt; 
+		///	an array of string with the string properties's provider
+		/// &lt;/returns&gt;
+		/// &lt;remarks&gt; properties are indexed ans sorted with &lt;see cref=&quot; MonoQuery.SchemaClass.AbstractMonoQueryConnectionWrapper.MonoQueryPropertyEnum&quot;&gt;MonoQueryPropertyEnum&lt;/see&gt;&lt;/remarks&gt;
+		/// &lt;/summary&gt;		
+		object GetProperty( MonoQueryPropertyEnum property );
+		
+		///&lt;summary&gt;
+		/// Open a connection with the &lt;seealso cref='.IConnection.ConnectionString'/&gt;
+		/// &lt;returns&gt; 
+		///	&lt;code&gt;true&lt;/code&gt; if the connection is opened.
+		/// &lt;code&gt;false&lt;/code&gt; if the connection is not opened.
+		/// &lt;/returns&gt;
+		/// &lt;/summary&gt;		
+		bool Open();
+
+		///&lt;summary&gt;
+		/// Close the connection with the server.
+		/// &lt;/summary&gt;
+		void Close();	
+		
+		///&lt;summary&gt;
+		/// Refresh child schemas from the database.
+		///&lt;/summary&gt;
+		void Refresh();
+		
+		///&lt;summary&gt;
+		/// Erase all child schemas
+		///&lt;/summary&gt;
+		void Clear();	
+		
+		///&lt;summary&gt;
+		/// Execute a SQL command
+		/// &lt;param name=&quot;SQLText&quot;&gt;
+		/// SQL command to execute
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;rows&quot;&gt;
+		/// Maximum number of row to extract. If is &quot;0&quot; then all rows are extracted.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt; return a &lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt;  
+		///or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; object.
+		/// &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		object ExecuteSQL( string SQLText, int rows );
+		
+		///&lt;summary&gt;
+		/// Execute a stocked procedure.
+		/// &lt;param name=&quot;schema&quot;&gt;
+		/// &lt;see cref=&quot;MonoQuery.SchemaClass&quot;&gt;SchemaClass&lt;/see&gt; object.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;rows&quot;&gt;
+		/// Maximum number of row to extract. If is &quot;0&quot; then all rows are extracted.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt; return a &lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt;  
+		///or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; object.
+		/// &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		object ExecuteProcedure( ISchemaClass schema, int rows, MonoQuerySchemaClassCollection parameters );
+		
+		///&lt;summary&gt;
+		/// Extract Data from a Table or a View
+		/// &lt;param name=&quot;schema&quot;&gt;
+		/// &lt;see cref=&quot;MonoQuery.SchemaClass&quot;&gt;SchemaClass&lt;/see&gt; object.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;rows&quot;&gt;
+		/// Maximum number of row to extract. If is &quot;0&quot; then all rows are extracted.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt; return a &lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt;  
+		///or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; object.
+		/// &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		object ExtractData( ISchemaClass schema, int rows );										
+				
+		///&lt;summary&gt;
+		/// Update &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt;'s fields into the current opened database.
+		/// &lt;param name=&quot;row&quot;&gt;a &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; &lt;/param&gt;
+		/// &lt;param name=&quot;schema&quot;&gt; a &lt;see cref=&quot;MonoQuery.SchemaClass.ISchema&quot;&gt;schema&lt;/see&gt; &lt;/param&gt; 
+		///&lt;/summary&gt;
+		void UpDateRow( ISchemaClass schema, DataRow row );		
+		
+		///&lt;summary&gt;
+		/// Delete &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; into the current opened database.
+		/// &lt;param name=&quot;row&quot;&gt;a &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; &lt;/param&gt;
+		/// &lt;param name=&quot;schema&quot;&gt; a &lt;see cref=&quot;MonoQuery.SchemaClass.ISchema&quot;&gt;schema&lt;/see&gt; &lt;/param&gt; 
+		///&lt;/summary&gt;
+		void DeleteRow( ISchemaClass schema, DataRow row );
+		
+		///&lt;summary&gt;
+		/// Insert &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; into the current opened database.
+		/// &lt;param name=&quot;row&quot;&gt;a &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; &lt;/param&gt;
+		/// &lt;param name=&quot;schema&quot;&gt; a &lt;see cref=&quot;MonoQuery.SchemaClass.ISchema&quot;&gt;schema&lt;/see&gt; &lt;/param&gt; 
+		///&lt;/summary&gt;
+		void InsertRow( ISchemaClass schema, DataRow row );		
+								
+		
+		///&lt;summary&gt;
+		/// Get &lt;seealso cref='.ISchemaClass.Connection'/&gt;'s catalogs.
+		///&lt;/summary&gt;
+		MonoQuerySchemaClassCollection GetSchemaCatalogs( ISchemaClass schema );
+		
+		///&lt;summary&gt;
+		/// Get &lt;seealso cref='.ISchemaClass.Connection'/&gt;'s Schemas.
+		///&lt;/summary&gt;
+		MonoQuerySchemaClassCollection GetSchemaSchemas( ISchemaClass schema );
+		
+		///&lt;summary&gt;
+		/// From a catalog object, get tables from all schemas.
+		/// From a schema object get tables from all this schema.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaTables( ISchemaClass schema );
+		
+		///&lt;summary&gt;
+		/// From a catalog object, get views from all schemas.
+		/// From a schema object get views from all this schema.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaViews( ISchemaClass schema );
+		
+		///&lt;summary&gt;
+		/// From a catalog object, get procedures from all schemas.
+		/// From a schema object get procedures from all this schema.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaProcedures( ISchemaClass schema );
+		
+		///&lt;summary&gt;
+		/// From a table object, get columns from the table.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaTableColumns( ISchemaClass schema );
+		
+		///&lt;summary&gt;
+		/// From a view object, get columns from the view.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaViewColumns( ISchemaClass schema );		
+		
+		///&lt;summary&gt;
+		/// From a procedure object , get columns from the procedure.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaProcedureColumns( ISchemaClass schema );
+		
+		///&lt;summary&gt;
+		/// From a procedure object , get parameters from the procedure.
+		/// From other object, return an empty list.
+		///&lt;/summary&gt;		
+		MonoQuerySchemaClassCollection GetSchemaProcedureParameters( ISchemaClass schema );		
+	}
+	
+}
Index: Extras/MonoQuery/Connection/Abstract/AbstractMonoQueryConnectionWrapper.cs
===================================================================
--- Extras/MonoQuery/Connection/Abstract/AbstractMonoQueryConnectionWrapper.cs	(revision 0)
+++ Extras/MonoQuery/Connection/Abstract/AbstractMonoQueryConnectionWrapper.cs	(revision 0)
@@ -0,0 +1,1002 @@
+// created on 11/11/2003 at 14:06
+namespace MonoQuery.Connection
+{	
+	
+	using System;
+	using System.Collections;
+	using System.Data;
+	using System.Data.OleDb;
+	using System.Reflection;
+	
+	using MonoDevelop.Core.Services;
+	using MonoDevelop.Services;
+	using MonoDevelop.Core.AddIns.Conditions;
+	using MonoDevelop.Core.AddIns.Codons;
+	using MonoDevelop.Core.AddIns;
+
+	using MonoQuery.Collections;
+	using MonoQuery.SchemaClass;
+	using MonoQuery.Codons;	
+	using MonoQuery.Exceptions;
+	
+	///&lt;summary&gt;
+	/// Connection properties
+	///&lt;/summary&gt;		
+	public enum MonoQueryPropertyEnum
+	{	
+		Catalog,
+		ConnectionString,
+		DataSource,
+		DataSourceName,
+		DBMSName,
+		ProviderName
+	}
+	
+	///&lt;summary&gt;
+	/// MonoQuery schema enumeration.
+	///&lt;/summary&gt;		
+	public enum MonoQuerySchemaEnum {
+		
+		Asserts,
+		Catalogs, 
+		CharacterSets,
+		CheckConstraints,
+		Collations,
+		ColumnPrivileges,
+		Columns,
+		ColumnsDomainUsage,
+		ConstraintColumnUsage,
+		ConstaintTableUsage,
+		Cubes,
+		DBInfoKeyWords,
+		DBInfoLiterals,
+		Dimensions,
+		ForeignKeys,
+		Hierarchies,
+		Indexes,
+		KeyColumnUsage,
+		Levels,
+		Measures,
+		Members,
+		Null, // ask for an empty list
+		PrimaryKeys,
+		ProcedureColumns,
+		ProcedureParameters,
+		Procedures,
+		Properties,
+		ProviderSpecific,
+		ProviderTypes,
+		ReferentialConstraints,
+		Schemata,
+		SQLLanguages,
+		Statistics,
+		TableConstraints,
+		TablePrivileges,
+		Tables,
+		Tanslations,
+		Trustees,
+		UsagePrivileges,
+		ViewColumnUsage,
+		Views,
+		ViewColumns,
+		ViewTableUsage			
+	}
+	
+	///&lt;summary&gt;
+	/// this is a wrapper abstract class for connection with a database server.
+	///&lt;/summary&gt;
+	public abstract class AbstractMonoQueryConnectionWrapper : IConnection
+	{		
+		//constants
+		internal string SELECT		= &quot;SELECT&quot;;
+		internal string FROM		= &quot;FROM&quot;;
+		internal string WHERE		= &quot;WHERE&quot;;
+		internal string UPDATE		= &quot;UPDATE&quot;;
+		internal string SET			= &quot;SET&quot;;
+		internal string DELETE		= &quot;DELETE&quot;;
+		internal string INSERINTO	= &quot;INSERT INTO&quot;;
+		internal string VALUES		= &quot;VALUES&quot;;
+		internal string AND			= &quot;AND&quot;;
+				
+		protected bool wrongConnectionString = false;
+		static StringParserService stringParserService = (StringParserService)ServiceManager.GetService(typeof(StringParserService));		
+		protected MonoQueryListDictionary pEntities = null;										
+		private string name = &quot;&quot;;
+
+		///&lt;summary&gt;
+		/// return &lt;c&gt;true&lt;/c&gt; if the connection string is invalid.
+		///&lt;/summary&gt;
+		public bool IsConnectionStringWrong
+		{
+			get
+			{
+				return this.wrongConnectionString;
+			}
+		}
+		///&lt;summary&gt;return the catalog name. If there aren't a ctalog name
+		/// in the &lt;see cref=&quot;.ConnectionString&quot;&gt;ConnectionString&lt;/see&gt;, return &quot;&quot;.
+		/// &lt;/summary&gt;
+		public virtual string CatalogName
+		{
+			get
+			{
+				object returnValue = this.GetProperty( MonoQueryPropertyEnum.Catalog);
+				
+				if ( returnValue == null )
+				{
+					returnValue = &quot;&quot;; 
+				}
+				
+				return returnValue.ToString();
+			}			
+		}
+		
+		/// &lt;summary&gt;
+		/// Example connection string
+		/// &lt;/summary&gt;
+		public virtual string ExampleConnectionString
+		{
+			get
+			{
+				return ( &quot;&quot; );
+			}
+		}
+		
+		public virtual string SchemaName
+		{
+			get
+			{
+				return &quot;&quot;;//&quot;INFORMATION_SCHEMA&quot;;
+			}
+		}			
+		
+		public virtual string Name
+		{
+			get { return this.name; }		
+		}
+		
+		///&lt;summary&gt;return  : &lt;see cref=&quot;.Name&quot;&gt;Name&lt;/see&gt;.&lt;see cref=&quot;.ConnectionString&quot;&gt;&lt;/see&gt;&lt;/summary&gt;
+		public string NormalizedName
+		{
+			get
+			{
+				return this.Name + &quot;.&quot; + this.ConnectionString;
+			}
+		}
+		
+		public MonoQueryListDictionary Entities 
+		{ 
+			get
+			{
+				return this.pEntities;
+			}
+		}
+		
+		///&lt;summary&gt;
+		///  OLEDB connection String.	
+		/// i use this for speed up the code writing ...
+		///&lt;/summary&gt;
+		public virtual string ConnectionString  
+		{
+		   get
+		   {
+		   	 return this.GetProperty( MonoQueryPropertyEnum.ConnectionString ).ToString();
+		   }
+		   
+		   set
+		   {		   	
+		   }
+		}	
+				
+		public virtual string Provider
+		{
+			get
+			{
+				return this.GetProperty( MonoQueryPropertyEnum.ProviderName ).ToString();
+			}
+		}
+		
+		public abstract bool IsOpen
+		{
+			get;
+		}	
+		
+		
+		public abstract object GetProperty( MonoQueryPropertyEnum property );
+				
+		/// &lt;summary&gt;
+		/// Creates a new DataConnection object
+		/// &lt;/summary&gt;		
+		public AbstractMonoQueryConnectionWrapper()
+		{					
+			this.pEntities = new MonoQueryListDictionary();
+		}		
+		
+		/// &lt;summary&gt;
+		/// Creates a new DataConnection object from a connection string
+		/// &lt;/summary&gt;		
+		public AbstractMonoQueryConnectionWrapper( string connectionString ) : this()
+		{				
+		}						
+		
+		static private IConnection CreateConnectionObject( string connectionstring )
+		{	
+			//try
+			//{
+				Assembly ass = System.Reflection.Assembly.GetExecutingAssembly();
+				
+				IAddInTreeNode AddinNode;
+				IAddInTreeNode ChildNode = null;
+				
+				string ClassWrapper = &quot;&quot;;
+				
+				AddinNode = (IAddInTreeNode)AddInTreeSingleton.AddInTree.GetTreeNode(&quot;/MonoQuery/Connection&quot;);
+				ChildNode = (IAddInTreeNode)AddinNode.ChildNodes[&quot;ConnectionWrapper&quot;];
+				ClassWrapper = ChildNode.Codon.Class;
+				
+				if ( (ClassWrapper != null) &amp;&amp; (ClassWrapper != &quot;&quot;) )
+				{								
+					IConnection conn = (IConnection)ass.CreateInstance( ClassWrapper,
+					                                       	false,
+					                                       	BindingFlags.CreateInstance,
+					                                       	null,
+					                                       	//new object[] {connectionstring},
+										null,
+					                                       	null,
+					                                       	null
+					                                       );
+					conn.ConnectionString = connectionstring;
+					return conn;
+				}
+				else
+				{
+					return null;
+				}			
+			//}
+			//catch ( System.Exception e )
+			//{
+			//	throw new ConnectionStringException( e.Message );
+			//}		   					
+		}
+		
+		static public IConnection CreateFromDataConnectionLink()
+		{
+//				ADODB._Connection AdoConnection;
+//				MSDASC.DataLinks dataLink = new MSDASC.DataLinks();			
+				IConnection connection = null;
+//				
+//				AdoConnection = null;
+//				AdoConnection = (ADODB._Connection) dataLink.PromptNew();						
+//				
+//				if ( ( AdoConnection != null ) &amp;&amp; ( AdoConnection.ConnectionString != &quot;&quot; ) )
+//				{												
+//					connection = CreateConnectionObject( AdoConnection.ConnectionString );
+//				}
+//				
+				return connection;
+		}
+		
+		static  public IConnection UpDateFromDataConnectionLink( IConnection oldConnection )
+		{
+//				object AdoConnection;
+//				MSDASC.DataLinks dataLink = new MSDASC.DataLinks();
+				IConnection connection = null;
+//				
+//				AdoConnection = new ADODB.Connection();
+//				(AdoConnection as ADODB.Connection).ConnectionString = oldConnection.ConnectionString;
+//				
+//				if ( dataLink.PromptEdit( ref AdoConnection ) )
+//				{
+//					connection = CreateConnectionObject( (AdoConnection as ADODB.Connection).ConnectionString );								
+//				}
+//				
+				return connection;
+		}
+		
+		static  public IConnection CreateFromConnectionString( string stringConnection )		
+		{
+				IConnection connection = null;
+				
+				if ( ( stringConnection != null ) &amp;&amp; ( stringConnection != &quot;&quot; ) )
+				{
+					connection = CreateConnectionObject( stringConnection );
+				}
+				
+				return connection;
+		}
+																				
+		public abstract bool Open();
+		public abstract void Close();
+				
+		///&lt;summary&gt;
+		/// called by &lt;see cref=&quot;.Refresh()&quot;&gt;Refresh&lt;/see&gt; just after the &lt;see cref=&quot;.Clear()&quot;&gt;Clear&lt;/see&gt; and before &lt;see cref=&quot;.Refresh()&quot;&gt;childs'refresh&lt;/see&gt;.
+		/// In this, you could change the &lt;see cref=&quot;.Entities&quot;&gt;Entities dicntionnary.&lt;/see&gt;
+		///&lt;/summary&gt;
+		protected virtual void OnRefresh()
+		{
+			if (this.pEntities != null )
+			{
+				this.pEntities.Add( &quot;TABLES&quot;, new MonoQuerySchemaClassCollection( new ISchemaClass[] { new MonoQueryTables(this, this.CatalogName, this.SchemaName, this.Name,  &quot;TABLES&quot;) } ) );
+				this.pEntities.Add( &quot;VIEWS&quot;, new MonoQuerySchemaClassCollection( new ISchemaClass[] { new MonoQueryViews( this, this.CatalogName, this.SchemaName, this.Name,  &quot;VIEWS&quot; ) } ) );
+				this.pEntities.Add( &quot;PROCEDURES&quot;, new MonoQuerySchemaClassCollection( new ISchemaClass[] { new MonoQueryProcedures( this, this.CatalogName, this.SchemaName, this.Name,  &quot;PROCEDURES&quot; ) } ) );
+			}		
+		}
+		
+		///&lt;summary&gt;Refresh all dynamic properties of this connection&lt;/summary&gt;
+		public void Refresh()
+		{			
+			this.Clear();
+						
+			if ( this.IsOpen == true )
+			{
+				this.OnRefresh();
+			}
+		}
+
+		public void Clear()
+		{	
+			if (this.pEntities != null )
+			{
+				this.pEntities.Clear();
+				
+				//Let do the Garbage collector to clear the MonoQuerySchmaClassCollection childs.
+				// It wil be do in a thread (by the garbage collector), it will be better								
+			}			
+		}
+				
+		///&lt;summary&gt;
+		/// Execute a SQL command
+		/// &lt;param name=&quot;SQLText&quot;&gt;
+		/// SQL command to execute
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;rows&quot;&gt;
+		/// Maximum number of row to extract. If is &quot;0&quot; then all rows are extracted.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt; return a &lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt;  
+		///or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; object.
+		/// &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public abstract object ExecuteSQL( string SQLText, int rows);
+		//TODO : Parameter param.
+		
+		///&lt;summary&gt;
+		/// Execute a stocked procedure.
+		/// &lt;param name=&quot;schema&quot;&gt;
+		/// &lt;see cref=&quot;MonoQuery.SchemaClass&quot;&gt;SchemaClass&lt;/see&gt; object.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;rows&quot;&gt;
+		/// Maximum number of row to extract. If is &quot;0&quot; then all rows are extracted.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt; return a &lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt;  
+		///or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; object.
+		/// &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public abstract object ExecuteProcedure( ISchemaClass schema, int rows, MonoQuerySchemaClassCollection parameters );
+		
+		///&lt;summary&gt;
+		/// Extract Data from a Table or a View
+		/// &lt;param name=&quot;schema&quot;&gt;
+		/// &lt;see cref=&quot;MonoQuery.SchemaClass&quot;&gt;SchemaClass&lt;/see&gt; object.
+		/// &lt;/param&gt;
+		/// &lt;param name=&quot;rows&quot;&gt;
+		/// Maximum number of row to extract. If is &quot;0&quot; then all rows are extracted.
+		/// &lt;/param&gt;
+		/// &lt;returns&gt; return a &lt;see cref=&quot;System.Data.DataTable&quot;&gt;DataTable&lt;/see&gt;  
+		///or a &lt;see cref=&quot;System.Data.DataSet&quot;&gt;DataSet&lt;/see&gt; object.
+		/// &lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public object ExtractData( ISchemaClass schema, int rows )
+		{
+						
+			if ( schema == null )
+			{
+				throw new System.ArgumentNullException(&quot;schema&quot;);
+			}
+			
+			string SQLSelect = this.SELECT + &quot; &quot;;
+			string SQLFrom  = this.FROM + &quot; &quot;;	
+			MonoQuerySchemaClassCollection entitieslist = null;
+			 			
+			SQLFrom += schema.Name;			
+			
+			schema.Refresh();
+			//we have only a table or view :o) //TODO : find a better way !
+			foreach( DictionaryEntry DicEntry in schema.Entities )
+			{
+			  entitieslist = DicEntry.Value as MonoQuerySchemaClassCollection;
+		      break;
+			}
+					
+			if ( entitieslist == null )
+			{
+				throw new System.ArgumentNullException(&quot;entitieslist&quot;);
+			}					
+					
+			foreach( ISchemaClass column in entitieslist )
+			{
+				SQLSelect += column.NormalizedName;
+				SQLSelect += &quot;,&quot;;
+			}			
+			
+			SQLSelect = SQLSelect.TrimEnd( new Char[]{','} );
+			if ( entitieslist.Count == 0) 
+			{
+				SQLSelect += &quot;*&quot;;
+			}
+			SQLSelect += &quot; &quot;;
+						
+			return this.ExecuteSQL( SQLSelect + SQLFrom , 0);
+		}
+		
+				
+		///&lt;summary&gt;
+		/// Update &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt;'s fields into the current opened database.
+		/// &lt;param name=&quot;row&quot;&gt;a &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; &lt;/param&gt;
+		/// &lt;param name=&quot;schema&quot;&gt; a &lt;see cref=&quot;MonoQuery.SchemaClass.ISchema&quot;&gt;schema&lt;/see&gt; &lt;/param&gt; 
+		/// &lt;remarks&gt; it use a transaction for each row, so it's a very long process 
+		/// if you should update something like 10 000 lines ;o). It's used only by the DataView.
+		/// If you need a better way write a &quot;BatchUpdate&quot; function
+		/// &lt;/remarks&gt;
+		///&lt;/summary&gt;
+		public void UpDateRow( ISchemaClass schema, DataRow row )
+		{
+			if ( schema == null )
+			{
+				throw new System.ArgumentNullException(&quot;schema&quot;);
+			}
+			
+			if ( row == null )
+			{
+				throw new System.ArgumentNullException(&quot;row&quot;);
+			}
+			
+			string SQLUpdate = this.UPDATE + &quot; &quot;;
+			string SQLWhere  = this.WHERE + &quot; &quot;;
+			string SQLValues = this.SET + &quot; &quot;;
+			
+			SQLUpdate += schema.Name;
+			SQLUpdate += &quot; &quot;;
+			
+			foreach( DataColumn column in row.Table.Columns )
+			{
+				if ( column.ReadOnly == false 
+				     &amp;&amp; column.AutoIncrement == false				   
+				   )
+				{
+					SQLValues += schema.Name + &quot;.&quot; + AbstractMonoQuerySchemaClass.CheckWhiteSpace(column.ColumnName);
+					SQLValues += &quot;=&quot;;
+					if (  column.DataType.Equals( System.Type.GetType(&quot;System.String&quot;) )
+					   || column.DataType.Equals( System.Type.GetType(&quot;System.Char&quot;) )
+					   )
+					{
+						SQLValues +=&quot;'&quot;;
+					}
+					SQLValues += row[column.ColumnName];
+					if (  column.DataType.Equals( System.Type.GetType(&quot;System.String&quot;) )
+					   || column.DataType.Equals( System.Type.GetType(&quot;System.Char&quot;) )
+					   )
+					{
+						SQLValues +=&quot;'&quot;;
+					}	
+					
+					SQLValues += &quot;,&quot;;
+				}
+				
+				SQLWhere += MonoQuery.SchemaClass.AbstractMonoQuerySchemaClass.CheckWhiteSpace(column.ColumnName);
+				SQLWhere += &quot;=&quot;;
+				if (  column.DataType.Equals( System.Type.GetType(&quot;System.String&quot;) )
+				   || column.DataType.Equals( System.Type.GetType(&quot;System.Char&quot;) )
+				   )
+				{
+					SQLWhere +=&quot;'&quot;;
+				}				
+				SQLWhere += row[column.ColumnName, DataRowVersion.Original];
+				if (  column.DataType.Equals( System.Type.GetType(&quot;System.String&quot;) )
+				   || column.DataType.Equals( System.Type.GetType(&quot;System.Char&quot;) )
+				   )
+				{
+					SQLWhere +=&quot;'&quot;;
+				}				
+				
+				if ( row.Table.Columns.IndexOf( column ) != (row.Table.Columns.Count -1) )
+				{					
+					SQLWhere  += &quot; &quot; + this.AND + &quot; &quot;;					
+				}		
+			}
+			
+			SQLValues =SQLValues.TrimEnd(new Char[]{','});
+						
+			this.ExecuteSQL( SQLUpdate + SQLValues + SQLWhere , 0);
+			row.AcceptChanges();
+		}
+		
+		///&lt;summary&gt;
+		/// Delete &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; into the current opened database.
+		/// &lt;param name=&quot;row&quot;&gt;a &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; &lt;/param&gt;
+		/// &lt;param name=&quot;schema&quot;&gt; a &lt;see cref=&quot;MonoQuery.SchemaClass.ISchema&quot;&gt;schema&lt;/see&gt; &lt;/param&gt; 
+		/// &lt;remarks&gt; it use a transaction for each row, so it's a very long process 
+		/// if you should update something like 10 000 lines ;o). It's used only by the DataView.
+		/// If you need a better way write a &quot;BatchUpdate&quot; function
+		/// &lt;/remarks&gt;
+		///&lt;/summary&gt;
+		public void DeleteRow( ISchemaClass schema, DataRow row )
+		{		
+			if ( schema == null )
+			{
+				throw new System.ArgumentNullException(&quot;schema&quot;);
+			}
+			
+			if ( row == null )
+			{
+				throw new System.ArgumentNullException(&quot;row&quot;);
+			}
+			
+			string SQLDelete = this.DELETE + &quot; &quot;;
+			string SQLWhere  = this.WHERE +&quot; &quot;;
+			string SQLFrom 	 = this.FROM +&quot; &quot;;
+			
+			SQLFrom += schema.Name;
+			SQLFrom += &quot; &quot;;
+			
+			foreach( DataColumn column in row.Table.Columns )
+			{
+				//SQLDelete += schema.Name + &quot;.&quot; + column.ColumnName;
+				
+				SQLWhere += MonoQuery.SchemaClass.AbstractMonoQuerySchemaClass.CheckWhiteSpace(column.ColumnName);
+				SQLWhere += &quot;=&quot;;
+				if (  column.DataType.Equals( System.Type.GetType(&quot;System.String&quot;) )
+				   || column.DataType.Equals( System.Type.GetType(&quot;System.Char&quot;) )
+				   )
+				{
+					SQLWhere +=&quot;'&quot;;
+				}				
+				SQLWhere += row[column.ColumnName, DataRowVersion.Original];
+				if (  column.DataType.Equals( System.Type.GetType(&quot;System.String&quot;) )
+				   || column.DataType.Equals( System.Type.GetType(&quot;System.Char&quot;) )
+				   )
+				{
+					SQLWhere +=&quot;'&quot;;
+				}				
+				
+				if ( row.Table.Columns.IndexOf( column ) != (row.Table.Columns.Count -1) )
+				{
+					//SQLDelete += &quot;,&quot;;
+					SQLWhere  += &quot; &quot; + this.AND + &quot; &quot;;					
+				}		
+				else
+				{
+					//SQLDelete += &quot; &quot;;
+				}				
+			}			
+						
+			this.ExecuteSQL( SQLDelete + SQLFrom + SQLWhere , 0);
+			row.AcceptChanges();
+		}		
+		
+		///&lt;summary&gt;
+		/// Insert &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; into the current opened database.
+		/// &lt;param name=&quot;row&quot;&gt;a &lt;see cref=&quot;System.Data.DataRow&quot;&gt;row&lt;/see&gt; &lt;/param&gt;
+		/// &lt;param name=&quot;schema&quot;&gt; a &lt;see cref=&quot;MonoQuery.SchemaClass.ISchema&quot;&gt;schema&lt;/see&gt; &lt;/param&gt; 
+		/// &lt;remarks&gt; it use a transaction for each row, so it's a very long process 
+		/// if you should update something like 10 000 lines ;o). It's used only by the DataView.
+		/// If you need a better way write a &quot;BatchUpdate&quot; function
+		/// &lt;/remarks&gt;
+		///&lt;/summary&gt;
+		public void InsertRow( ISchemaClass schema, DataRow row )
+		{	
+			if ( schema == null )
+			{
+				throw new System.ArgumentNullException(&quot;schema&quot;);
+			}
+			
+			if ( row == null )
+			{
+				throw new System.ArgumentNullException(&quot;row&quot;);
+			}			
+			
+			string SQLInsert = this.INSERINTO + &quot; &quot;;
+			string SQLValues = this.VALUES +&quot; (&quot;;
+			
+			SQLInsert += schema.Name;
+			SQLInsert += &quot; (&quot;;
+			
+			foreach( DataColumn column in row.Table.Columns )
+			{				
+				if ( column.ReadOnly == false 
+				     &amp;&amp; column.AutoIncrement == false				   
+				   )
+				{				
+					SQLInsert += /*schema.Name + &quot;.&quot; + //Full qualified name not supported by some provider*/ MonoQuery.SchemaClass.AbstractMonoQuerySchemaClass.CheckWhiteSpace(column.ColumnName);
+					
+					if (  column.DataType.Equals( System.Type.GetType(&quot;System.String&quot;) )
+					   || column.DataType.Equals( System.Type.GetType(&quot;System.Char&quot;) )
+					   )
+					{
+						SQLValues +=&quot;'&quot;;
+					}				
+					SQLValues += row[column.ColumnName, DataRowVersion.Current ];
+					if (  column.DataType.Equals( System.Type.GetType(&quot;System.String&quot;) )
+					   || column.DataType.Equals( System.Type.GetType(&quot;System.Char&quot;) )
+					   )
+					{
+						SQLValues +=&quot;'&quot;;
+					}	
+					
+					SQLValues  += &quot;,&quot;;
+					SQLInsert += &quot;,&quot;;
+				}				
+			}
+			
+			SQLValues = SQLValues.TrimEnd(new Char[]{','});
+			SQLInsert = SQLInsert.TrimEnd(new Char[]{','});
+			
+			SQLInsert += &quot;) &quot;;	
+			SQLValues += &quot;)&quot;;
+
+						
+			this.ExecuteSQL( SQLInsert + SQLValues, 0);
+			row.AcceptChanges();
+		}		
+		
+		///&lt;summary&gt; throw a exception if the &lt;seealso cref='.AbstractMonoQueryConnectionWrapper.Connection'/&gt; is &lt;code&gt;null&lt;/code&gt; &lt;/summary&gt;
+		protected abstract void CheckConnectionObject();
+
+		///&lt;summary&gt; each elements of the restrictions array which are an empty string is replaced with a &lt;code&gt;null&lt;/code&gt; reference&lt;/summary&gt;		
+		protected object[] NormalizeRestrictions( object[] restrictions)
+		{	
+			object[] newRestrictions = null;
+			
+			if ( restrictions != null )
+			{
+				newRestrictions = new object[ restrictions.Length ];
+				object restriction;
+				
+				for( int i = 0; i &lt; restrictions.Length; i++)
+				{
+					restriction =  restrictions[i];
+	
+					if ( restriction != null )
+					{
+						if ( (restriction is string) &amp;&amp; ( (restriction as string) == &quot;&quot;) )
+						{
+							restriction = null;
+						}
+					}
+					
+					newRestrictions[i] = restriction;			
+				}
+			}
+			return newRestrictions;
+		}		
+
+		/// &lt;summary&gt;
+		/// return a schema matching &lt;code&gt;restrictions&lt;/code&gt;
+		/// &lt;param name=&quot;schema&quot;&gt; a &lt;see cref=&quot;.MonoQuerySchemaEnum&quot;&gt;MonoQuerySchemaEnum&lt;/see&gt;.&lt;/param&gt;
+		/// &lt;param name=&quot;restrictions&quot;&gt; Restrictions matching the schema&lt;/param&gt;
+		/// &lt;/summary&gt;				
+		protected abstract DataTable GetSchema( MonoQuerySchemaEnum schema, object[] restrictions );
+		
+		
+//
+// IConnection methods
+//
+		
+		public MonoQuerySchemaClassCollection GetSchemaCatalogs( ISchemaClass schema )
+		{
+			MonoQuerySchemaClassCollection list = new MonoQuerySchemaClassCollection( );
+			DataTable record = null;
+			MonoQuerySchemaEnum schematype = MonoQuerySchemaEnum.Catalogs;
+			object[] restrictions = new object[]{ schema.InternalName };
+			
+			try
+			{
+				record = this.GetSchema( schematype , restrictions );
+	
+				//TODO : add not supported schema code!
+				
+				if ( record != null )
+				{					
+					foreach (DataRow row in record.Rows )
+					{
+						list.Add( new MonoQueryCatalog( this, row[&quot;CATALOG_NAME&quot;].ToString(), &quot;&quot;, &quot;&quot;, row[&quot;CATALOG_NAME&quot;].ToString()) );
+					}					
+				}
+			}
+			catch( System.Exception )
+			{	
+				list.Add( new MonoQueryNotSupported(this, &quot;&quot; , &quot;&quot;, &quot;&quot;, &quot;MonoQuerySchemaEnum.Catalogs&quot;) );
+			}
+			
+			return list;
+		}
+		
+		public MonoQuerySchemaClassCollection GetSchemaSchemas( ISchemaClass schema )
+		{			
+			MonoQuerySchemaClassCollection list = new MonoQuerySchemaClassCollection( );
+			DataTable record = null;		
+			MonoQuerySchemaEnum schematype = MonoQuerySchemaEnum.Schemata;
+			object[] restrictions = new object[]{ schema.CatalogName, &quot;&quot;, &quot;&quot; };
+			
+			try
+			{
+				record = this.GetSchema( schematype, restrictions );
+				
+				if ( record != null )
+				{
+					foreach (DataRow row in record.Rows )
+					{
+						list.Add( new MonoQuerySchema( this, row[&quot;CATALOG_NAME&quot;].ToString(), row[&quot;SCHEMA_NAME&quot;].ToString(), &quot;&quot;, row[&quot;SCHEMA_NAME&quot;].ToString()) );
+					}
+
+				}
+			}
+			catch( System.Exception )
+			{		
+				list.Add( new MonoQueryNotSupported(this, &quot;&quot; , &quot;&quot;, &quot;&quot;, &quot;MonoQuerySchemaEnum.Schemata&quot;) );
+			}
+			
+			return list;						
+		}		
+		
+		public MonoQuerySchemaClassCollection GetSchemaTables( ISchemaClass schema )
+		{			
+			MonoQuerySchemaClassCollection list = new MonoQuerySchemaClassCollection( );
+			DataTable record = null;
+			MonoQuerySchemaEnum schematype = MonoQuerySchemaEnum.Tables;
+			object[] restrictions = new object[]{ schema.CatalogName, schema.SchemaName, &quot;&quot;, &quot;TABLE&quot; };
+			
+			try
+			{
+				record = this.GetSchema( schematype, restrictions );
+				
+				if ( record != null )
+				{
+					foreach (DataRow row in record.Rows )
+					{
+						list.Add( new MonoQueryTable( this, row[&quot;TABLE_CATALOG&quot;].ToString(), row[&quot;TABLE_SCHEMA&quot;].ToString(), &quot;&quot;, row[&quot;TABLE_NAME&quot;].ToString()) );
+					}					
+				}
+			}
+			catch( System.Exception )
+			{		
+				list.Add( new MonoQueryNotSupported(this, &quot;&quot; , &quot;&quot;, &quot;&quot;, &quot;MonoQuerySchemaEnum.Tables&quot;) );
+			}
+			
+			return list;
+		}
+		
+		public MonoQuerySchemaClassCollection GetSchemaViews( ISchemaClass schema )
+		{
+			MonoQuerySchemaClassCollection list = new MonoQuerySchemaClassCollection( );
+			DataTable record = null;		
+			MonoQuerySchemaEnum schematype = MonoQuerySchemaEnum.Views;
+			object[] restrictions = new object[]{ schema.CatalogName, schema.SchemaName, &quot;&quot;, &quot;VIEW&quot; };
+			
+			try
+			{
+				record = this.GetSchema( schematype, restrictions );
+				
+				if ( record != null )
+				{
+					foreach (DataRow row in record.Rows )
+					{
+						list.Add( new MonoQueryView( this, row[&quot;TABLE_CATALOG&quot;].ToString(), row[&quot;TABLE_SCHEMA&quot;].ToString(), &quot;&quot;, row[&quot;TABLE_NAME&quot;].ToString()) );
+					}					
+				}
+			}
+			catch( System.Exception )
+			{		
+				list.Add( new MonoQueryNotSupported(this, &quot;&quot; , &quot;&quot;, &quot;&quot;, &quot;MonoQuerySchemaEnum.Views&quot;) );
+			}
+			
+			return list;
+		}
+		
+		public MonoQuerySchemaClassCollection GetSchemaProcedures( ISchemaClass schema )
+		{
+			MonoQuerySchemaClassCollection list = new MonoQuerySchemaClassCollection( );
+			DataTable record = null;		
+			MonoQuerySchemaEnum schematype = MonoQuerySchemaEnum.Procedures;
+			object[] restrictions = new object[]{ schema.CatalogName, schema.SchemaName, &quot;&quot;, &quot;&quot;};
+			
+			try
+			{
+				record = this.GetSchema( schematype, restrictions );
+				
+				if ( record != null )
+				{
+					foreach (DataRow row in record.Rows )
+					{
+						list.Add( new MonoQueryProcedure( this, row[&quot;PROCEDURE_CATALOG&quot;].ToString(), row[&quot;PROCEDURE_SCHEMA&quot;].ToString(), &quot;&quot;, row[&quot;PROCEDURE_NAME&quot;].ToString().Split(';')[0] ) );
+					}					
+				}
+			}
+			catch( System.Exception )
+			{		
+				list.Add( new MonoQueryNotSupported(this, &quot;&quot; , &quot;&quot;, &quot;&quot;, &quot;MonoQuerySchemaEnum.Procedures&quot;) );
+			}
+			
+			return list;			
+		}
+		
+		public MonoQuerySchemaClassCollection GetSchemaTableColumns( ISchemaClass schema )
+		{
+			MonoQuerySchemaClassCollection list = new MonoQuerySchemaClassCollection( );
+			DataTable record = null;	
+			MonoQuerySchemaEnum schematype = MonoQuerySchemaEnum.Columns;
+			object[] restrictions = new object[]{ schema.CatalogName, schema.SchemaName, schema.InternalName, &quot;&quot; };
+			
+			try
+			{
+				record = this.GetSchema( schematype, restrictions );
+				
+				if ( record != null )
+				{
+					foreach (DataRow row in record.Rows )
+					{
+						list.Add( new MonoQueryColumn( this, schema.CatalogName, schema.SchemaName,schema.Name, row[&quot;COLUMN_NAME&quot;].ToString()) );
+					}					
+				}
+			}
+			catch( System.Exception )
+			{		
+				list.Add( new MonoQueryNotSupported(this, &quot;&quot; , &quot;&quot;, &quot;&quot;, &quot;MonoQuerySchemaEnum.Columns&quot;) );
+			}
+			
+			return list;
+		}
+		
+		public MonoQuerySchemaClassCollection GetSchemaViewColumns( ISchemaClass schema )
+		{
+			MonoQuerySchemaClassCollection list = new MonoQuerySchemaClassCollection( );
+			DataTable record = null;		
+			MonoQuerySchemaEnum schematype = MonoQuerySchemaEnum.ViewColumns;
+			object[] restrictions = new object[]{ schema.CatalogName, schema.SchemaName, schema.InternalName, &quot;&quot; };
+			
+			try
+			{
+				record = this.GetSchema( schematype, restrictions );
+				
+				if ( record != null )
+				{
+					foreach (DataRow row in record.Rows )
+					{
+						list.Add( new MonoQueryColumn( this, schema.CatalogName, schema.SchemaName, schema.Name, row[&quot;COLUMN_NAME&quot;].ToString()) );
+					}					
+				}
+			}
+			catch( System.Exception )
+			{		
+				list.Add( new MonoQueryNotSupported(this, &quot;&quot; , &quot;&quot;, &quot;&quot;, &quot;MonoQuerySchemaEnum.Columns&quot;) );
+			}
+			
+			return list;
+		}		
+		
+		public MonoQuerySchemaClassCollection GetSchemaProcedureColumns( ISchemaClass schema )
+		{
+			MonoQuerySchemaClassCollection list = new MonoQuerySchemaClassCollection( );
+			DataTable record = null;	
+			MonoQuerySchemaEnum schematype = MonoQuerySchemaEnum.ProcedureColumns;
+			object[] restrictions = new object[]{ schema.CatalogName, schema.SchemaName, schema.InternalName, &quot;&quot; };
+			
+			try
+			{
+				record = this.GetSchema( schematype, restrictions );
+				
+				if ( record != null )
+				{
+					foreach (DataRow row in record.Rows )
+					{
+						list.Add( new MonoQueryColumn( this, schema.CatalogName, schema.SchemaName, schema.Name, row[&quot;COLUMN_NAME&quot;].ToString()) );
+					}					
+				}
+			}
+			catch( System.Exception)
+			{		
+				list.Add( new MonoQueryNotSupported(this, &quot;&quot; , &quot;&quot;, &quot;&quot;, &quot;MonoQuerySchemaEnum.ProcedureColumns&quot;) );
+			}
+			
+			return list;
+		}
+		
+		public MonoQuerySchemaClassCollection GetSchemaProcedureParameters( ISchemaClass schema )
+		{
+			MonoQuerySchemaClassCollection list = new MonoQuerySchemaClassCollection( );
+			DataTable record = null;		
+			MonoQuerySchemaEnum schematype = MonoQuerySchemaEnum.ProcedureParameters;
+			object[] restrictions = new object[]{ schema.CatalogName, schema.SchemaName, schema.InternalName, &quot;&quot; };
+			
+			try
+			{
+				record = this.GetSchema( schematype, restrictions );
+				MonoQueryParameter par = null;
+				if ( record != null )
+				{
+					foreach (DataRow row in record.Rows )
+					{
+						par = new MonoQueryParameter( this, schema.CatalogName, schema.SchemaName, schema.Name, row[&quot;PARAMETER_NAME&quot;].ToString());
+						par.DataType = StringToDbType( row[&quot;DATA_TYPE&quot;].ToString() );
+						par.Type     = StringToParamDirection( row[&quot;PARAMETER_TYPE&quot;].ToString() );
+						
+						if ( par.Type != ParameterDirection.ReturnValue )
+						{
+							list.Add( par );
+						}
+					}									
+				}
+			}
+			catch( System.Exception )
+			{		
+				list.Add( new MonoQueryNotSupported(this, &quot;&quot; , &quot;&quot;, &quot;&quot;, &quot;MonoQuerySchemaEnum.ProcedureParameters&quot;) );
+			}
+			
+			return list;
+		}
+		
+		
+		protected DbType StringToDbType( string value )
+		{
+			return IntToDbType( int.Parse( value ) );
+		}
+		
+		protected DbType IntToDbType( int value )
+		{
+			DbType retValue;
+			switch( value )
+			{	
+				case 129	: retValue = DbType.AnsiString; break;
+				//case 1	: retValue = DbType.AnsiStringFixedLength; break;
+				case 128	: retValue = DbType.Binary; break;
+				case 11		: retValue = DbType.Boolean; break;
+				case 17		: retValue = DbType.Byte; break;
+				case 6		: retValue = DbType.Currency; break;
+				case 7		:
+				case 133	: retValue = DbType.Date; break;
+				case 135	: retValue = DbType.DateTime; break;
+				case 14		: retValue = DbType.Decimal; break;
+				case 5		: retValue = DbType.Double; break;
+				case 72		: retValue = DbType.Guid; break;
+				case 2		: retValue = DbType.Int16; break;
+				case 3		: retValue = DbType.Int32; break;
+				case 20		: retValue = DbType.Int64; break;
+				case 12		:
+				case 132	: retValue = DbType.Object; break;
+				case 16		: retValue = DbType.SByte; break;
+				case 4		: retValue = DbType.Single; break;
+				case 130	: retValue = DbType.String; break;
+				case 8		: retValue = DbType.StringFixedLength; break;
+				case 134	: retValue = DbType.Time; break;
+				case 18		: retValue = DbType.UInt16; break;
+				case 19		: retValue = DbType.UInt32; break;
+				case 21		: retValue = DbType.UInt64; break;
+				case 131	: retValue = DbType.VarNumeric; break;
+				default : throw new ArgumentOutOfRangeException(&quot;value&quot;);				
+			}
+			
+			return retValue;			
+		}
+		
+		protected ParameterDirection StringToParamDirection( string value )
+		{
+			return 	IntToParamDirection( int.Parse( value ) );
+		}
+		
+		protected ParameterDirection IntToParamDirection( int value )
+		{
+			ParameterDirection retValue;
+			switch( value )
+			{
+				case 1 : retValue = ParameterDirection.Input; break;
+				case 2 : retValue = ParameterDirection.InputOutput; break;
+				case 3 : retValue = ParameterDirection.Output; break;
+				case 4 : retValue = ParameterDirection.ReturnValue; break;
+				default : throw new ArgumentOutOfRangeException(&quot;value&quot;);
+				
+			}
+			
+			return retValue;
+		}
+		
+	}
+}
Index: Extras/MonoQuery/Connection/Npgsql/NpgsqlConnectionWrapper.cs
===================================================================
--- Extras/MonoQuery/Connection/Npgsql/NpgsqlConnectionWrapper.cs	(revision 0)
+++ Extras/MonoQuery/Connection/Npgsql/NpgsqlConnectionWrapper.cs	(revision 0)
@@ -0,0 +1,521 @@
+//  MonoQuery - SharpQuery port to MonoDevelop (+ More)
+//  Copyright (C) Christian Hergert &lt;<A HREF="mailto:chris@mosaix.net">chris@mosaix.net</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 2 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+using System;
+using System.Collections;
+using System.Data;
+
+using Npgsql;
+
+using MonoQuery.Collections;
+using MonoQuery.SchemaClass;
+using MonoQuery.Exceptions;
+
+namespace MonoQuery.Connection
+{
+	public class NpgsqlConnectionWrapper : AbstractMonoQueryConnectionWrapper //IConnection
+	{
+		#region // Private Properties
+		/// &lt;summary&gt;
+		/// This property stores whether the current connection string is
+		/// wrong. This helps us determine connection errors for the
+		/// monodevelop user.
+		/// &lt;/summary&gt;
+		private 	bool		pIsConnectionStringWrong = false;
+		
+		/// &lt;summary&gt;
+		/// Name of class providing the connection.
+		/// &lt;/summary&gt;
+		protected	string		pProvider = &quot;NpgsqlConnectionWrapper&quot;;
+		
+		/// &lt;summary&gt;
+		/// Npgsql Connection object
+		/// &lt;/summary&gt;
+		protected	NpgsqlConnection pConnection = null;
+		
+		/// &lt;summary&gt;
+		/// Child entities of this connection.
+		/// &lt;/summary&gt;
+//		protected MonoQueryListDictionary pEntities = null;	
+		#endregion // End Private Properties
+		
+		#region // Public Properties
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override string Name
+		{
+			get
+			{
+				return &quot;Npgsql: &quot; + this.pConnection.Database;
+			}
+		}
+		
+		public override bool IsOpen
+		{
+			get
+			{
+				return (this.pConnection.State == ConnectionState.Open);
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override string CatalogName
+		{
+			get
+			{
+				if ( IsOpen == false ) {
+					this.Open();
+				}
+				
+				return this.pConnection.Database;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override string SchemaName
+		{
+			get { return &quot;public&quot;; } // we should fix this =X
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override string ConnectionString
+		{
+			get { return this.pConnection.ConnectionString; }
+			set
+			{
+				if ( IsOpen == true ) {
+					pConnection.Close();
+				}
+				
+				try
+				{
+					this.pConnection.ConnectionString = value;
+					this.pIsConnectionStringWrong = false;
+				}
+				catch ( NpgsqlException )
+				{
+					this.pIsConnectionStringWrong = true;
+				}
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// The LastSystemOID is the last internal OID used by postgresql.
+		/// Since this number changes from release to release, this can
+		/// can be a fucking nightmare.
+		/// &lt;/summary&gt;
+		protected virtual string LastSystemOID
+		{
+			get
+			{
+				if ( IsOpen != true ) Open();
+				
+				string retval = &quot;&quot;;
+				String version = pConnection.ServerVersion.ToString();
+				switch( version.Substring(0,3) ) { // Get Major Version
+					case &quot;7.4&quot;:
+						retval = &quot;17137&quot;;
+						break;
+					case &quot;7.3&quot;:
+						retval = &quot;16974&quot;;
+						break;
+					case &quot;7.2&quot;:
+						retval = &quot;16554&quot;;
+						break;
+					case &quot;7.1&quot;:
+						retval = &quot;18539&quot;;
+						break;
+					default:
+						retval = &quot;17137&quot;;
+						break;
+				}
+				
+				return retval;
+			}
+		}
+		#endregion // End Public Properties
+		
+		#region // Constructors
+		/// &lt;summary&gt;
+		/// Default constructor.
+		/// &lt;/summary&gt;
+		public NpgsqlConnectionWrapper()
+		{
+			this.pEntities = new MonoQueryListDictionary();
+			this.pConnection = new NpgsqlConnection();
+		}
+		
+		/// &lt;summary&gt;
+		/// Constructor with connstring support.
+		/// &lt;/summary&gt;
+		public NpgsqlConnectionWrapper( string connectionString )
+			: this ()
+		{
+			this.ConnectionString = connectionString;
+		}
+		#endregion // End Constructors
+		
+		#region // Public Methods
+		/// &lt;summary&gt;
+		/// Open connection to the database server.
+		/// &lt;/summary&gt;
+		public override bool Open()
+		{
+			try
+			{
+				if ( this.pConnection != null ) {
+					this.pConnection.Open();
+				}
+			}
+			catch  ( Exception err )
+			{
+				throw ( new OpenConnectionException( this.ConnectionString ) );
+			}
+			
+			return ( this.IsOpen );
+		}
+		
+		/// &lt;summary&gt;
+		/// Close database connection
+		/// &lt;/summary&gt;
+		public override void Close()
+		{
+			if ( this.pConnection != null ) {
+				this.pConnection.Close();
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// Execute a SQL Statement.
+		/// &lt;returns&gt;System.Data.DataSet&lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object ExecuteSQL( string SQLText, int maxRows )
+		{
+			NpgsqlCommand command = new NpgsqlCommand();
+			DataSet returnValues = new DataSet();
+			NpgsqlDataAdapter da = new NpgsqlDataAdapter();
+			
+			command.Connection = this.pConnection;
+			command.CommandText = SQLText;
+			command.CommandType = System.Data.CommandType.Text;
+			
+			command.Transaction = pConnection.BeginTransaction(
+				System.Data.IsolationLevel.ReadCommitted );
+			
+			try
+			{
+				da.SelectCommand = command;
+				if ( maxRows &gt; 0 ) {
+					da.Fill( returnValues, 0, maxRows, null );
+				} else {
+					da.Fill( returnValues );
+				}
+			}
+			catch ( NpgsqlException e )
+			{
+				command.Transaction.Rollback();
+				
+				string mes = SQLText + &quot;\n&quot;;
+				
+				foreach ( NpgsqlError err in e.Errors )
+				{
+					mes += &quot;-----------------\n&quot;;
+					mes += err.Message + &quot;\n&quot;;
+					mes += err.Hint + &quot;\n&quot;;					
+				}				
+				throw new ExecuteSQLException( mes );
+			}
+			catch ( Exception e )
+			{
+				command.Transaction.Rollback();
+				throw new ExecuteSQLException( SQLText );
+			}
+			finally
+			{
+				command.Transaction.Commit();
+			}
+			
+			return returnValues;
+		}
+		
+		/// &lt;summary&gt;
+		/// This will call the proper method depending on the schema
+		/// that is being asked for.
+		/// &lt;/summary&gt;
+		protected override DataTable GetSchema( MonoQuerySchemaEnum schema, object [] restrictions )
+		{
+			DataTable returnValues = new DataTable();
+			
+			switch( schema ) {
+				case MonoQuerySchemaEnum.Tables:
+					returnValues = this.GetTables( restrictions );
+					break;
+				case MonoQuerySchemaEnum.Columns:
+					returnValues = this.GetTableColumns( restrictions );
+					break;
+				case MonoQuerySchemaEnum.Views:
+					returnValues = this.GetViews( restrictions );
+					break;
+				case MonoQuerySchemaEnum.ViewColumns:
+					returnValues = this.GetViewColumns( restrictions );
+					break;
+				case MonoQuerySchemaEnum.Procedures:
+					returnValues = this.GetProcedures( restrictions );
+					break;
+				default:
+					break;
+			}
+			
+			return returnValues;
+		}
+		
+		/// &lt;summary&gt;
+		/// Return settings on this connection.
+		/// &lt;/summary&gt;
+		public override object GetProperty( MonoQueryPropertyEnum property )
+		{
+			object returnValues = null;
+			
+			switch( property ) {
+				case MonoQueryPropertyEnum.ProviderName:
+					returnValues = this.Provider;
+					break;
+				case MonoQueryPropertyEnum.Catalog:
+					returnValues = this.CatalogName;
+					break;
+				case MonoQueryPropertyEnum.ConnectionString:
+					returnValues = this.ConnectionString;
+					break;
+				default:
+					break;
+			}
+			
+			return returnValues;
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override object ExecuteProcedure( ISchemaClass schema, int rows,
+			MonoQuerySchemaClassCollection parameters )
+		{
+			return (object) null;
+		}
+		#endregion // End Public Methods
+		
+		#region // Private Methods
+		/// &lt;summary&gt;
+		/// This method will get the tables from the server where
+		/// restrictions match. This should work for all versions of postgresql
+		/// that i am aware of. (7.1+)
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetTables( object [] restrictions )
+		{
+			if ( IsOpen == false ) {
+				this.Open();
+			}
+			
+			string commandText = &quot;SELECT NULL AS TABLE_SCHEMA, c.relname AS TABLE_NAME, &quot;
+				+ &quot;'&quot; + this.CatalogName + &quot;' AS TABLE_CATALOG &quot;
+				+ &quot;FROM pg_class c &quot;
+				+ &quot;WHERE c.relkind='r' &quot;
+				+ &quot;AND NOT EXISTS (SELECT 1 FROM pg_rewrite r WHERE r.ev_class = c.oid AND r.ev_type = '1') &quot;
+				+ &quot;AND c.relname NOT LIKE 'pg\\_%' &quot;
+				+ &quot;AND c.relname NOT LIKE 'sql\\_%' &quot;
+				+ &quot;ORDER BY relname;&quot;;
+			
+			NpgsqlCommand command = new NpgsqlCommand( commandText, this.pConnection );
+			NpgsqlDataAdapter adapter = new NpgsqlDataAdapter();
+			adapter.SelectCommand = command;
+			DataSet ds = new DataSet();
+			adapter.Fill( ds );
+			
+			return ds.Tables[0];
+		}
+		
+		/// &lt;summary&gt;
+		/// This method will get our views from the current catalog. should work
+		/// on postgres 7.1+ (havent checked 8.0 series)
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetViews( object [] restrictions )
+		{
+			if ( IsOpen == false ) {
+				this.Open();
+			}
+			
+			string commandText = &quot;SELECT c.relname AS TABLE_NAME, &quot;
+				+ &quot;'&quot; + this.CatalogName + &quot;' AS TABLE_CATALOG, &quot;
+				+ &quot;n.nspname AS TABLE_SCHEMA &quot;
+				+ &quot;FROM pg_catalog.pg_class c &quot;
+				+ &quot;LEFT JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace) &quot;
+				+ &quot;WHERE (c.relkind = 'v'::\&quot;char\&quot;) &quot;
+				+ &quot;AND n.nspname NOT IN ('information_schema', 'pg_catalog', 'pg_toast') &quot;
+				+ &quot;ORDER BY TABLE_NAME;&quot;;
+			
+			NpgsqlCommand command = new NpgsqlCommand( commandText, this.pConnection );
+			NpgsqlDataAdapter adapter = new NpgsqlDataAdapter();
+			adapter.SelectCommand = command;
+			DataSet ds = new DataSet();
+			adapter.Fill( ds );
+			
+			return ds.Tables[0];
+		}
+		
+		/// &lt;summary&gt;
+		/// This will get a list of procedures from the current database.
+		/// It requires that LastSystemOID is properly set for server
+		/// version.
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetProcedures( object [] restrictions )
+		{
+			if ( this.IsOpen == false ) {
+				this.Open();
+			}
+			
+			string commandText = &quot;SELECT &quot;
+				+ &quot;proname AS PROCEDURE_NAME, &quot;
+				+ &quot;'&quot; + this.CatalogName + &quot;' AS PROCEDURE_CATALOG, &quot;
+				+ &quot;'&quot; + this.SchemaName + &quot;' AS PROCEDURE_SCHEMA &quot;
+				+ &quot;FROM &quot;
+				+ &quot;pg_proc pc, pg_user pu, pg_type pt &quot;
+				+ &quot;WHERE &quot;
+				+ &quot;pc.proowner = pu.usesysid &quot;
+				+ &quot;AND pc.prorettype = pt.oid &quot;
+				+ &quot;AND pc.oid &gt; '&quot; + this.LastSystemOID + &quot;'::oid &quot;
+				+ &quot;UNION &quot;
+				+ &quot;SELECT &quot;
+				+ &quot;proname AS PROCEDURE_NAME, &quot;
+				+ &quot;'&quot; + this.CatalogName + &quot;' AS PROCEDURE_CATALOG, &quot;
+				+ &quot;'&quot; + this.SchemaName + &quot;' AS PROCEDURE_SCHEMA &quot;
+				+ &quot;FROM &quot;
+				+ &quot;pg_proc pc, pg_user pu, pg_type pt &quot;
+				+ &quot;WHERE &quot;
+				+ &quot;pc.proowner = pu.usesysid &quot;
+				+ &quot;AND pc.prorettype = 0 &quot;
+				+ &quot;AND pc.oid &gt; '&quot; + this.LastSystemOID + &quot;'::oid &quot;
+				+ &quot;ORDER BY &quot;
+				+ &quot;PROCEDURE_NAME;&quot;;
+			
+			NpgsqlCommand command = new NpgsqlCommand( commandText, this.pConnection );
+			NpgsqlDataAdapter adapter = new NpgsqlDataAdapter();
+			adapter.SelectCommand = command;
+			DataSet ds = new DataSet();
+			adapter.Fill( ds );
+			
+			return ds.Tables[0];
+		}
+		
+		/// &lt;summary&gt;
+		/// This method will get the columns for a table.
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetTableColumns( object [] restrictions )
+		{
+			if ( !IsOpen ) this.Open();
+			
+			DataSet ds = new DataSet();
+			string commandText = &quot;SELECT a.attname AS COLUMN_NAME &quot;
+                        + &quot;FROM &quot;
+                        + &quot;  pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_attrdef adef &quot;
+                        + &quot;  ON a.attrelid=adef.adrelid &quot;
+                        + &quot;  AND a.attnum=adef.adnum &quot;
+                        + &quot;  LEFT JOIN pg_catalog.pg_type t ON a.atttypid=t.oid &quot;
+                        + &quot;WHERE &quot;
+                        + &quot;  a.attrelid = (SELECT oid FROM pg_catalog.pg_class WHERE relname='&quot; + restrictions[2].ToString() + &quot;') &quot;
+                        + &quot;  AND a.attnum &gt; 0 AND NOT a.attisdropped &quot;
+                        + &quot;     ORDER BY a.attnum;&quot;;
+			NpgsqlCommand command = new NpgsqlCommand( commandText, this.pConnection );
+			NpgsqlDataAdapter da = new NpgsqlDataAdapter();
+			da.SelectCommand = command;
+			da.Fill( ds );
+			
+			return ds.Tables[0];
+		}
+		
+		/// &lt;summary&gt;
+		/// Get the columns associated with a view.
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetViewColumns( object [] restrictions )
+		{
+			if ( IsOpen == false ) {
+				this.Open();
+			}
+			
+			DataSet ds = new DataSet();
+			string commandText = &quot;SELECT a.attname AS COLUMN_NAME &quot;
+				+ &quot;FROM &quot;
+				+ &quot;  pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_attrdef adef &quot;
+				+ &quot;  ON a.attrelid=adef.adrelid &quot;
+				+ &quot;  AND a.attnum=adef.adnum &quot;
+				+ &quot;  LEFT JOIN pg_catalog.pg_type t ON a.atttypid=t.oid &quot;
+				+ &quot;WHERE &quot;
+				+ &quot;  a.attrelid = (SELECT oid FROM pg_catalog.pg_class WHERE relname='&quot;
+				+ restrictions[2].ToString() + &quot;') &quot;
+				+ &quot;  AND a.attnum &gt; 0 AND NOT a.attisdropped &quot;
+				+ &quot;     ORDER BY a.attnum;&quot;;
+			NpgsqlCommand command = new NpgsqlCommand( commandText, this.pConnection );
+			NpgsqlDataAdapter da = new NpgsqlDataAdapter();
+			da.SelectCommand = command;
+			da.Fill( ds );
+			
+			return ds.Tables[0];
+		}
+		
+		/// &lt;summary&gt;
+		/// This method will get a table filled with the returning columns
+		/// for a procedure.
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetProcedureColumns( object [] restrictions )
+		{
+			if ( IsOpen == false ) {
+				this.Open();
+			}
+			
+			// Get procedures OID
+			// FIXME:
+			int oid = 0;
+			
+			DataSet ds = new DataSet();
+			string commandText = &quot;SELECT &quot;
+				+ &quot;format_type(prorettype, NULL) as COLUMN_NAME, &quot;
+				+ &quot;FROM &quot;
+				+ &quot;pg_catalog.pg_proc pc, pg_catalog.pg_language pl &quot;
+				+ &quot;WHERE &quot;
+				+ &quot;pc.oid = '&quot; + oid + &quot;'::oid &quot;
+				+ &quot;AND pc.prolang = pl.oid&quot;;
+			NpgsqlCommand command = new NpgsqlCommand( commandText, this.pConnection );
+			NpgsqlDataAdapter da = new NpgsqlDataAdapter();
+			da.SelectCommand = command;
+			da.Fill( ds );
+			
+			return ds.Tables[0];
+		}
+		
+		protected override void CheckConnectionObject()
+		{
+			if ( this.pConnection == null )
+				throw new Exception(&quot;Bad connection object&quot;);
+		}
+		#endregion // End Private Methods
+	}
+}
Index: Extras/MonoQuery/Connection/Mysql/MysqlConnectionWrapper.cs
===================================================================
--- Extras/MonoQuery/Connection/Mysql/MysqlConnectionWrapper.cs	(revision 0)
+++ Extras/MonoQuery/Connection/Mysql/MysqlConnectionWrapper.cs	(revision 0)
@@ -0,0 +1,393 @@
+//  MonoQuery - SharpQuery port to MonoDevelop (+ More)
+//  Copyright (C) Christian Hergert &lt;<A HREF="mailto:chris@mosaix.net">chris@mosaix.net</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 2 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+using System;
+using System.Collections;
+using System.Data;
+
+using ByteFX.Data.MySqlClient;
+
+using MonoQuery.Collections;
+using MonoQuery.SchemaClass;
+using MonoQuery.Exceptions;
+
+namespace MonoQuery.Connection
+{
+	/// &lt;summary&gt;
+	/// Mysql connection wrapper using the ByteFX mysql driver.
+	/// &lt;/summary&gt;
+	public class MysqlConnectionWrapper : AbstractMonoQueryConnectionWrapper
+	{
+		#region // Private Properties
+		/// &lt;summary&gt;
+		/// This property stores whether the current connection string is
+		/// wrong. This helps us determine connection errors for the
+		/// monodevelop user.
+		/// &lt;/summary&gt;
+		private		bool		pIsConnectionStringWrong = false;
+		
+		/// &lt;summary&gt;
+		/// Name of class providing the connection. This isnt really used
+		/// and is legacy from the SharpQuery.
+		/// &lt;/summary&gt;
+		protected	string		pProvider = &quot;MysqlConnectionWrapper&quot;;
+		
+		/// &lt;summary&gt;
+		/// Mysql connection object
+		/// &lt;/summary&gt;
+		protected	MySqlConnection		pConnection = null;
+		#endregion // End Private Properties
+		
+		#region // Public Properties
+		/// &lt;summary&gt;
+		/// Name of database
+		/// &lt;/summary&gt;
+		public override string Name
+		{
+			get { return &quot;MySQL: &quot; + this.pConnection.Database; }
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override string CatalogName
+		{
+			get
+			{
+				if ( IsOpen == false ) {
+					this.Open();
+				}
+				
+				return this.pConnection.Database;
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override string SchemaName {
+			get { return &quot;&quot;; }
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override bool IsOpen
+		{
+			get
+			{
+				try
+				{
+					return ( this.pConnection.State == ConnectionState.Open );
+				}
+				catch ( Exception e )
+				{
+					return false;
+				}
+			}
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override string ConnectionString
+		{
+			get { return this.pConnection.ConnectionString; }
+			set
+			{
+				if ( IsOpen == true ) {
+					pConnection.Close();
+				}
+				
+				try
+				{
+					this.pConnection.ConnectionString = value;
+					this.pIsConnectionStringWrong = false;
+				}
+				catch ( MySqlException e )
+				{
+					this.pIsConnectionStringWrong = true;
+				}
+			}
+		}
+		#endregion // End Public Properties
+		
+		#region // Constructors
+		/// &lt;summary&gt;
+		/// Default constructor.
+		/// &lt;/summary&gt;
+		public MysqlConnectionWrapper()
+		{
+			this.pEntities = new MonoQueryListDictionary();
+			this.pConnection = new MySqlConnection();
+		}
+		
+		/// &lt;summary&gt;
+		/// Constructor with connection string
+		/// &lt;/summary&gt;
+		public MysqlConnectionWrapper( string connString ) : this()
+		{
+			this.ConnectionString = connString;
+		}
+		#endregion // End Constructors
+		
+		#region // Public Methods
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override bool Open()
+		{
+			this.pConnection.Open();
+			return IsOpen;
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override void Close()
+		{
+			this.pConnection.Close();
+		}
+		
+		/// &lt;summary&gt;
+		/// Execute a SQL Statement.
+		/// &lt;returns&gt;System.Data.DataSet&lt;/returns&gt;
+		/// &lt;/summary&gt;
+		public override object ExecuteSQL( string SQLText, int maxRows )
+		{
+			MySqlCommand command = new MySqlCommand();
+			DataSet ds = new DataSet();
+			MySqlDataAdapter da = new MySqlDataAdapter();
+			
+			command.Connection = this.pConnection;
+			command.CommandText = SQLText;
+			command.CommandType = System.Data.CommandType.Text;
+			
+			command.Transaction = pConnection.BeginTransaction(
+				System.Data.IsolationLevel.ReadCommitted );
+			
+			try
+			{
+				da.SelectCommand = command;
+				if ( maxRows &gt; 0 ) {
+					da.Fill( ds, 0, maxRows, null );
+				} else {
+					da.Fill( ds );
+				}
+			}
+			catch ( MySqlException e )
+			{
+				command.Transaction.Rollback();
+				
+				string mes = SQLText + &quot;\n&quot;;
+							
+				throw new ExecuteSQLException( mes );
+			}
+			catch ( Exception e )
+			{
+				command.Transaction.Rollback();
+				throw new ExecuteSQLException( SQLText );
+			}
+			finally
+			{
+				command.Transaction.Commit();
+			}
+			
+			return ds;
+		}
+		
+		/// &lt;summary&gt;
+		/// Return settings on this connection.
+		/// &lt;/summary&gt;
+		public override object GetProperty( MonoQueryPropertyEnum property )
+		{
+			object returnValues = null;
+			
+			switch( property ) {
+				case MonoQueryPropertyEnum.ProviderName:
+					returnValues = this.Provider;
+					break;
+				case MonoQueryPropertyEnum.Catalog:
+					returnValues = this.CatalogName;
+					break;
+				case MonoQueryPropertyEnum.ConnectionString:
+					returnValues = this.ConnectionString;
+					break;
+				case MonoQueryPropertyEnum.DataSource:
+					returnValues = this.pConnection.DataSource;
+					break;
+				default:
+					break;
+			}
+			
+			return returnValues;
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override object ExecuteProcedure( ISchemaClass schema, int rows,
+			MonoQuerySchemaClassCollection parameters )
+		{
+			return (object) null;
+		}
+		
+		/// &lt;summary&gt;
+		/// This will call the proper method depending on the schema
+		/// that is being asked for.
+		/// &lt;/summary&gt;
+		protected override DataTable GetSchema( MonoQuerySchemaEnum schema, object [] restrictions )
+		{
+			DataTable returnValues = new DataTable();
+			
+			switch( schema ) {
+				case MonoQuerySchemaEnum.Tables:
+					returnValues = this.GetTables( restrictions );
+					break;
+				case MonoQuerySchemaEnum.Columns:
+					returnValues = this.GetTableColumns( restrictions );
+					break;
+				case MonoQuerySchemaEnum.Views:
+					returnValues = this.GetViews( restrictions );
+					break;
+				case MonoQuerySchemaEnum.ViewColumns:
+					returnValues = this.GetViewColumns( restrictions );
+					break;
+				case MonoQuerySchemaEnum.Procedures:
+					returnValues = this.GetProcedures( restrictions );
+					break;
+				default:
+					break;
+			}
+			
+			return returnValues;
+		}
+		#endregion // End Public Methods
+		
+		#region // Private Methods
+		/// &lt;summary&gt;
+		/// Retrieve the tables for the currently connected database.
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetTables( object [] restrictions )
+		{
+			if ( IsOpen == false )
+				this.Open();
+			
+			MySqlCommand command = new MySqlCommand();
+			command.CommandText = &quot;SHOW TABLES&quot;;
+			command.Connection = this.pConnection;
+			
+			MySqlDataAdapter da = new MySqlDataAdapter();
+			da.SelectCommand = command;
+			DataSet ds = new DataSet();
+			da.Fill( ds );
+			
+			ds.Tables[0].Columns[0].ColumnName = &quot;TABLE_NAME&quot;;
+			
+			// Hack to get around there only being one of the columns in the
+			// select statement.
+			ds.Tables[0].Columns.Add( new DataColumn(&quot;TABLE_SCHEMA&quot;, typeof(string)) );
+			ds.Tables[0].Columns.Add( new DataColumn(&quot;TABLE_CATALOG&quot;, typeof(string)) );
+			foreach( DataRow row in ds.Tables[0].Rows ) {
+				row.ItemArray[1] = this.SchemaName;
+				row.ItemArray[2] = this.CatalogName;
+			}
+			// End hack
+			
+			return ds.Tables[0];
+		}
+		
+		/// &lt;summary&gt;
+		/// MySQL does not support this yet (will in 5.0)
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetViews( object [] restrictions )
+		{
+			return new DataTable();
+		}
+		
+		/// &lt;summary&gt;
+		/// MySQL does not support this yet (will in 5.0)
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetProcedures( object [] restrictions )
+		{
+			return new DataTable();
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetTableColumns( object [] restrictions )
+		{
+			if ( IsOpen == false )
+				this.Open();
+			
+			MySqlCommand command = new MySqlCommand();
+			command.CommandText = &quot;DESCRIBE &quot; + restrictions[2];
+			command.Connection = this.pConnection;
+			
+			MySqlDataAdapter da = new MySqlDataAdapter();
+			da.SelectCommand = command;
+			DataSet ds = new DataSet();
+			da.Fill( ds );
+			
+			// Hack: the Collection bullshit requires it to be *named*.
+			ds.Tables[0].Columns[0].ColumnName = &quot;COLUMN_NAME&quot;;
+			// End Hack
+			
+			return ds.Tables[0];
+		}
+		
+		/// &lt;summary&gt;
+		/// MySQL does not support views yet (will in 5.0)
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetViewColumns( object [] restrictions )
+		{
+			return new DataTable();
+		}
+		
+		/// &lt;summary&gt;
+		/// MySQL does not support procs yet (will in 5.0)
+		/// &lt;/summary&gt;
+		protected virtual DataTable GetProcedureColumns( object [] restrictions )
+		{
+			return new DataTable();
+		}
+		
+		/// &lt;summary&gt;
+		/// Overridable method for extending class to control what happens on
+		/// a connection refresh.
+		/// &lt;/summary&gt;
+		protected override void OnRefresh()
+		{
+			if (this.pEntities != null )
+			{
+				this.pEntities.Add( &quot;TABLES&quot;, new MonoQuerySchemaClassCollection( new ISchemaClass[] { new MonoQueryTables(this, this.CatalogName, this.SchemaName, this.Name,  &quot;TABLES&quot;) } ) );
+				
+				// Not yet supported
+				//this.pEntities.Add( &quot;VIEWS&quot;, new MonoQuerySchemaClassCollection( new ISchemaClass[] { new MonoQueryViews( this, this.CatalogName, this.SchemaName, this.Name,  &quot;VIEWS&quot; ) } ) );
+				//this.pEntities.Add( &quot;PROCEDURES&quot;, new MonoQuerySchemaClassCollection( new ISchemaClass[] { new MonoQueryProcedures( this, this.CatalogName, this.SchemaName, this.Name,  &quot;PROCEDURES&quot; ) } ) );
+			}
+		}
+		
+		protected override void CheckConnectionObject()
+		{
+			if ( this.pConnection == null )
+				throw new Exception(&quot;Bad connection object&quot;);
+		}
+		#endregion // End Private Methods
+	}
+}
\ No newline at end of file
Index: Extras/MonoQuery/AssemblyInfo.cs
===================================================================
--- Extras/MonoQuery/AssemblyInfo.cs	(revision 0)
+++ Extras/MonoQuery/AssemblyInfo.cs	(revision 0)
@@ -0,0 +1,49 @@
+// MonoQuery.MonoQuery.dll - Addin for #Develop for database design
+// Copyright (C) 2003  Denis ERCHOFF
+// 
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 2
+// of the License, or (at your option) any later version.
+// 
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+using System.Reflection;
+using System.Runtime.CompilerServices;
+
+// Information about this assembly is defined by the following
+// attributes.
+//
+// change them to the information which is associated with the assembly
+// you compile.
+
+[assembly: AssemblyTitle(&quot;MonoQuery&quot;)]
+[assembly: AssemblyDescription(&quot;Database addin for MonoDevelop&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;#Develop, MonoDevelop&quot;)]
+[assembly: AssemblyProduct(&quot;Mono Query&quot;)]
+[assembly: AssemblyCopyright(&quot;Copyright (C) 2003  Denis ERCHOFF, 2004 Christian Hergert&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
+
+// The assembly version has following format :
+//
+// Major.Minor.Build.Revision
+//
+// You can specify all values by your own or you can build default build and revision
+// numbers with the '*' character (the default):
+
+[assembly: AssemblyVersion(&quot;0.4.0.*&quot;)]
+
+// The following attributes specify the key for the sign of your assembly. See the
+// .NET Framework documentation for more information about signing.
+// This is not required, if you don't want signing let these attributes like they're.
+[assembly: AssemblyDelaySign(false)]
+[assembly: AssemblyKeyFile(&quot;&quot;)]
Index: Extras/MonoQuery/Commands/Abstract/AbstractMonoQueryCommand.cs
===================================================================
--- Extras/MonoQuery/Commands/Abstract/AbstractMonoQueryCommand.cs	(revision 0)
+++ Extras/MonoQuery/Commands/Abstract/AbstractMonoQueryCommand.cs	(revision 0)
@@ -0,0 +1,52 @@
+
+using System;
+
+using MonoDevelop.Core.AddIns.Codons;
+
+using MonoQuery.Gui.TreeView;
+
+namespace MonoQuery.Commands
+{
+	/// &lt;summary&gt;
+	/// Base class of all commands of MonoQuery Addin
+	/// &lt;/summary&gt;
+	public abstract class AbstractMonoQueryCommand : AbstractMenuCommand
+	{	
+		protected IMonoQueryNode monoQueryNode = null;
+				
+		/// &lt;summary&gt;
+		/// get the selected &lt;see cref=&quot;MonoQuery.Gui.TreeView.IMonoQueryNode&quot;&gt; MonoQuery node &lt;/see&gt;
+		/// and Enabled or disabled the command
+		/// &lt;remarks&gt; If the selected node is &lt;code&gt;null&lt;/code&gt; or this is not a &lt;see cref=&quot;MonoQuery.Gui.TreeView.IMonoQueryNode&quot;&gt; MonoQuery node &lt;/see&gt;, return &lt;code&gt;false&lt;/code&gt; (disable the menu)&lt;/remarks&gt;
+		/// &lt;/summary&gt;				
+		public override bool IsEnabled
+		{
+			get
+			{
+				MonoQueryTree monoQueryTree;
+				monoQueryTree = this.Owner as MonoQueryTree;								
+				
+				if ( (monoQueryTree != null) &amp;&amp; ( monoQueryTree.SelectedNode != null ) )
+				{			
+					this.monoQueryNode = monoQueryTree.SelectedNode as IMonoQueryNode;				
+				}
+				else
+				{
+					this.monoQueryNode = null;
+				}
+				
+				return (this.monoQueryNode != null);				
+			}			
+			set{}
+			
+		}
+		
+		/// &lt;summary&gt;
+		/// Create a new MonoQueryCommand
+		/// &lt;/summary&gt;		
+		public AbstractMonoQueryCommand() : base()
+		{
+		}		
+		
+	}
+}
Index: Extras/MonoQuery/Commands/MonoQueryCommands.cs
===================================================================
--- Extras/MonoQuery/Commands/MonoQueryCommands.cs	(revision 0)
+++ Extras/MonoQuery/Commands/MonoQueryCommands.cs	(revision 0)
@@ -0,0 +1,199 @@
+
+using System;
+using MonoDevelop.Core.AddIns.Codons;
+using MonoQuery.Gui.TreeView;
+
+namespace MonoQuery.Commands
+{
+	public class MonoQueryRefreshCommand : AbstractMonoQueryCommand
+	{	
+		public override bool IsEnabled
+		{
+			get
+			{				
+				return base.IsEnabled &amp;&amp; (this.monoQueryNode  is AbstractMonoQueryNode)
+									  &amp;&amp; (this.monoQueryNode  as AbstractMonoQueryNode).Connection != null
+									  &amp;&amp; (this.monoQueryNode  as AbstractMonoQueryNode).Connection.IsOpen == true;
+			}			
+			set{}
+		}
+		/// &lt;summary&gt;
+		/// Refresh the selected &lt;see cref=&quot;MonoQuery.Gui.TreeView.IMonoQueryNode&quot;&gt;node&lt;/see&gt; of the &lt;see cref=&quot;MonoQuery.Gui.TreeView.MonoQueryTree&quot;&gt; MonoQuery Tree.&lt;/see&gt;
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			( this.monoQueryNode as IMonoQueryNode).Refresh();
+		}
+	}
+
+	/// &lt;summary&gt;
+	/// Add a connection to a database server into the &lt;see cref=&quot;MonoQuery.Gui.TreeView.MonoQueryTree&quot;&gt;&lt;/see&gt;
+	/// &lt;/summary&gt;
+	public class MonoQueryAddconnectionCommand : AbstractMonoQueryCommand
+	{			
+		
+		public override bool IsEnabled
+		{
+			get
+			{				
+				return base.IsEnabled &amp;&amp; (this.monoQueryNode  is MonoQueryNodeDatabaseRoot);				
+			}			
+			set{}
+		}		
+		
+		/// &lt;summary&gt;
+		/// Add a connection to a database server into the &lt;see cref=&quot;MonoQuery.Gui.TreeView.MonoQueryTree&quot;&gt;&lt;/see&gt;
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			( this.monoQueryNode as MonoQueryNodeDatabaseRoot ).AddConnection();
+		}
+	}
+	
+	/// &lt;summary&gt;
+	/// Remove a connection from a database server into the &lt;see cref=&quot;MonoQuery.Gui.TreeView.MonoQueryTree&quot;&gt;&lt;/see&gt;
+	/// &lt;/summary&gt;	
+	public class MonoQueryRemoveConnectionCommand : AbstractMonoQueryCommand
+	{			
+		public override bool IsEnabled
+		{
+			get
+			{				
+				return base.IsEnabled &amp;&amp; (this.monoQueryNode  is MonoQueryNodeConnection);				
+			}			
+			set{}
+		}		
+		
+		/// &lt;summary&gt;
+		/// Remove a connection from a database server into the &lt;see cref=&quot;MonoQuery.Gui.TreeView.MonoQueryTree&quot;&gt;&lt;/see&gt;
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			( this.monoQueryNode as MonoQueryNodeConnection).RemoveConnection();
+		}
+	}	
+	
+	
+	/// &lt;summary&gt;
+	/// Remove a connection from a database server into the &lt;see cref=&quot;MonoQuery.Gui.TreeView.MonoQueryTree&quot;&gt;&lt;/see&gt;
+	/// &lt;/summary&gt;	
+	public class MonoQueryModifyConnectionCommand : AbstractMonoQueryCommand
+	{			
+		
+		public override bool IsEnabled
+		{
+			get
+			{				
+				return base.IsEnabled &amp;&amp; (this.monoQueryNode  is MonoQueryNodeConnection);				
+			}			
+			set{}
+		}
+		
+		/// &lt;summary&gt;
+		/// Remove a connection from a database server into the &lt;see cref=&quot;MonoQuery.Gui.TreeView.MonoQueryTree&quot;&gt;&lt;/see&gt;
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			( this.monoQueryNode as MonoQueryNodeConnection).ModifyConnection();
+		}
+	}	
+		
+	/// &lt;summary&gt;
+	/// Disconnect From a database server
+	/// &lt;/summary&gt;		
+	public class MonoQueryDisconnectCommand : AbstractMonoQueryCommand	
+	{
+
+		public override bool IsEnabled
+		{
+			get
+			{				
+				return base.IsEnabled &amp;&amp; (this.monoQueryNode  is MonoQueryNodeConnection)
+									  &amp;&amp; (this.monoQueryNode  as MonoQueryNodeConnection).IsConnected == true;
+			}			
+			set{}
+		}
+		
+		public MonoQueryDisconnectCommand() : base()
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Disconnect From a database server
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			(this.monoQueryNode as MonoQueryNodeConnection).Disconnect();
+		}
+	}
+	
+	/// &lt;summary&gt;
+	/// Disconnect From a database server
+	/// &lt;/summary&gt;		
+	public class MonoQueryConnectCommand : AbstractMonoQueryCommand	
+	{
+
+		public override bool IsEnabled
+		{
+			get
+			{				
+				return base.IsEnabled &amp;&amp; (this.monoQueryNode  is MonoQueryNodeConnection)
+									  &amp;&amp; (this.monoQueryNode  as MonoQueryNodeConnection).IsConnected == false;
+			}			
+			set{}
+		}
+		
+		public MonoQueryConnectCommand() : base()
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Disconnect From a database server
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			(this.monoQueryNode as MonoQueryNodeConnection).Connect();
+		}
+	}
+	
+	
+	/// &lt;summary&gt;
+	/// Disconnect From a database server
+	/// &lt;/summary&gt;		
+	public class MonoQueryExecuteCommand : AbstractMonoQueryCommand	
+	{		
+		public MonoQueryExecuteCommand() : base()
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// Disconnect From a database server
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			this.monoQueryNode.Execute(0);
+		}
+	}
+	
+	/// &lt;summary&gt;
+	/// Show the sql editor
+	/// &lt;/summary&gt;
+	public class MonoQueryShowSqlViewCommand : AbstractMonoQueryCommand
+	{
+		public MonoQueryShowSqlViewCommand() : base()
+		{
+		}
+		
+		/// &lt;summary&gt;
+		/// 
+		/// &lt;/summary&gt;
+		public override void Run()
+		{
+			IMonoQueryNode node = this.monoQueryNode;
+			
+			MonoDevelop.Gui.WorkbenchSingleton.Workbench.ShowView(
+				new MonoQuery.Gui.SqlQueryView.SqlQueryView(
+					node.Connection ) );
+		}
+	}
+}
Index: Extras/MonoQuery/MonoQuery.mdsx
===================================================================
--- Extras/MonoQuery/MonoQuery.mdsx	(revision 0)
+++ Extras/MonoQuery/MonoQuery.mdsx	(revision 0)
@@ -0,0 +1,3 @@
+&lt;MonoDevelopSolution fileversion=&quot;1.0&quot;&gt;
+  &lt;RelativeOutputPath&gt;./&lt;/RelativeOutputPath&gt;
+&lt;/MonoDevelopSolution&gt;
\ No newline at end of file
Index: Extras/MonoQuery/Makefile.am
===================================================================
--- Extras/MonoQuery/Makefile.am	(revision 0)
+++ Extras/MonoQuery/Makefile.am	(revision 0)
@@ -0,0 +1,79 @@
+
+monoquerydir = $(libdir)/monodevelop/AddIns/MonoQuery
+monoquery_DATA = $(ASSEMBLY) MonoQuery.addin.xml
+
+FILES = \
+AssemblyInfo.cs \
+Codons/MonoQueryConnectionCodon.cs \
+Collection/MonoQuerySchemaClassCollection.cs \
+Collection/MonoQueryStringDictionary.cs \
+Collection/MonoQueryListDictionary.cs \
+Collection/MonoQueryParameterCollection.cs \
+Collection/ConnectionProviderDescriptor.cs \
+Commands/Abstract/AbstractMonoQueryCommand.cs \
+Commands/MonoQueryCommands.cs \
+Connection/Abstract/AbstractMonoQueryConnectionWrapper.cs \
+Connection/Interface/IConnection.cs \
+Connection/Npgsql/NpgsqlConnectionWrapper.cs \
+Connection/Mysql/MysqlConnectionWrapper.cs \
+Exceptions/Abstract/MonoQueryAbstractException.cs \
+Exceptions/ConnectionStringException.cs \
+Exceptions/ExecuteProcedureException.cs \
+Exceptions/ExecuteSQLException.cs \
+Exceptions/OpenConnectionException.cs \
+SchemaClass/Abstract/AbstractMonoQuerySchemaClass.cs \
+SchemaClass/Interface/ISchemaClass.cs \
+SchemaClass/MonoQuerySchemaClass.cs \
+MonoQueryView.cs \
+Gui/Abstract/AbstractMonoQueryNode.cs \
+Gui/DataView/SQLParameterInput.cs \
+Gui/DataView/MonoQueryDataView.cs \
+Gui/Interface/IMonoQueryNode.cs \
+Gui/MonoQueryTree/MonoQueryNodesRoot.cs \
+Gui/MonoQueryTree/MonoQueryTree.cs \
+Gui/MonoQueryTree/MonoQueryDataNodes.cs \
+Gui/MonoQueryPanel.cs \
+Gui/Forms/CreateConnectionDruid.cs \
+Gui/SqlQueryView/SqlQueryView.cs \
+Services/MonoQueryService.cs
+
+ASSEMBLY = MonoQuery.dll
+
+REFERENCES = \
+System.Data \
+Npgsql \
+ByteFX.Data \
+../../build/bin/MonoDevelop.Base.dll \
+../../build/bin/MonoDevelop.Core.dll \
+../../build/bin/MonoDevelop.Gui.Widgets.dll
+
+RESOURCES = \
+Gui/Forms/Glade/monoquery.glade
+
+PACKAGES = \
+gtk-sharp-2.0 \
+gnome-sharp-2.0 \
+glade-sharp-2.0 \
+gtksourceview-sharp
+
+BUILD_SOURCES = $(addprefix $(srcdir)/, $(FILES))
+BUILD_REFERENCES = $(addprefix /r:, $(REFERENCES))
+BUILD_PACKAGES = $(addprefix /pkg:, $(PACKAGES))
+BUILD_RESOURCES = $(addprefix /resource:, $(RESOURCES))
+
+all: $(ASSEMBLY)
+
+$(ASSEMBLY): mkdirs $(BUILD_SOURCES) ../../build/AddIns/MonoQuery/MonoQuery.addin.xml
+	mcs -out:MonoQuery.dll -target:library $(BUILD_SOURCES) \
+	$(BUILD_REFERENCES) $(BUILD_PACKAGES) $(BUILD_RESOURCES) \
+	&amp;&amp; cp MonoQuery.dll ../../build/AddIns/MonoQuery/
+
+../../build/AddIns/MonoQuery/MonoQuery.addin.xml:
+	cp MonoQuery.addin.xml ../../build/AddIns/MonoQuery/
+
+mkdirs:
+	mkdir -p ../../build/AddIns/MonoQuery
+
+CLEANFILES=$(ASSEMBLY) $(ASSEMBLY).mdb
+
+EXTRADIST=$(FILES) MonoQuery.addin.xml
Index: Extras/MonoQuery/MonoQuery.addin.xml
===================================================================
--- Extras/MonoQuery/MonoQuery.addin.xml	(revision 0)
+++ Extras/MonoQuery/MonoQuery.addin.xml	(revision 0)
@@ -0,0 +1,245 @@
+&lt;AddIn name        = &quot;MonoQuery&quot;
+       author      = &quot;Christian Hergert, Denis ERCHOFF of SharpQuery&quot;
+       copyright   = &quot;GPL&quot;
+       url         = &quot;<A HREF="http://www.monodevelop.com"">http://www.monodevelop.com&quot;</A>
+       description = &quot;MonoQuery&quot;
+       version     = &quot;0.0.1&quot;&gt;
+    
+    &lt;Runtime&gt;
+        &lt;Import assembly=&quot;MonoQuery.dll&quot;/&gt;
+    &lt;/Runtime&gt;
+	
+	&lt;Extension path = &quot;/Workspace/Services&quot;&gt;
+		&lt;Class id = &quot;MonoQueryService&quot;
+			class = &quot;MonoQuery.Services.MonoQueryService&quot;/&gt;
+	&lt;/Extension&gt;
+	
+    &lt;Extension path = &quot;/MonoQuery/Connection&quot;&gt;
+    
+		 &lt;Class id = &quot;NpgsqlConnectionWrapper&quot; 
+		    	class = &quot;MonoQuery.Connection.NpgsqlConnectionWrapper&quot;/&gt;
+		 &lt;!--
+		 &lt;Class id = &quot;MysqlConnectionWrapper&quot;
+		 		class = &quot;MonoQuery.Connection.MysqlConnectionWrapper&quot;/&gt;
+		 --&gt;
+		 &lt;Class id = &quot;OledbConnectionWrapper&quot;
+		 		class = &quot;MonoQuery.Connection.OLEDBConnectionWrapper&quot;/&gt;
+
+	&lt;MonoQueryConnection id =&quot;Column&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryColumn&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeColumn&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;Parameter&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryParameter&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeParameter&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;Procedure&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryProcedure&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeProcedure&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;Table&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryTable&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeTable&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;View&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryView&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeView&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;NotSupported&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryNotSupported&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeNotSupported&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;Tables&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryTables&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeTableRoot&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;Views&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryViews&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeViewRoot&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;Procedures&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryProcedures&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeProcedureRoot&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;Schema&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQuerySchema&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeSchema&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;Catalog&quot;
+	 		schema=&quot;MonoQuery.SchemaClass.MonoQueryCatalog&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeCatalog&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+			
+	 &lt;MonoQueryConnection id =&quot;Npgsql&quot;
+	 		schema=&quot;MonoQuery.Connection.NpgsqlConnectionWrapper&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeConnection&quot;
+	 		description = &quot;PostgreSQL 7.x Database Server&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+	 &lt;MonoQueryConnection id =&quot;Mysql&quot;
+	 		schema=&quot;MonoQuery.Connection.MysqlConnectionWrapper&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeConnection&quot;
+	 		description = &quot;MySQL Database Server&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+&lt;!--
+	 &lt;MonoQueryConnection id =&quot;OLEDB&quot;
+	 		schema=&quot;MonoQuery.Connection.OLEDBConnectionWrapper&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeConnection&quot;
+	 		description = &quot;OleDB Connection Provider&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+	 &lt;MonoQueryConnection id =&quot;ADO&quot;
+	 		schema=&quot;MonoQuery.Connection.ADOConnectionWrapper&quot;
+	 		node =&quot;MonoQuery.Gui.TreeView.MonoQueryNodeConnection&quot;
+			showUnsuported = &quot;False&quot;/&gt;
+--&gt;
+    &lt;/Extension&gt;
+
+    &lt;Extension path = &quot;/SharpDevelop/Workbench/Views&quot;&gt;
+		&lt;Class    id    = &quot;MonoQuery&quot; 
+	    	insertafter = &quot;HelpBrowser&quot;
+            class		= &quot;MonoQuery.Pads.MonoQueryView&quot;/&gt;
+    &lt;/Extension&gt;
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/DatabaseRoot&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+		&lt;MenuItem id = &quot;Separator1&quot; 
+			  _label = &quot;-&quot; /&gt;
+		&lt;MenuItem id = &quot;AddConnection&quot;
+		          _label = &quot;Add Connection&quot;
+		          icon = &quot;MonoQuery.Addconnection&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryAddconnectionCommand&quot;/&gt;		
+
+	&lt;/Extension&gt;
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/DatabaseConnection&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;
+		&lt;MenuItem id = &quot;ShowSqlView&quot;
+				  _label = &quot;Show SQL View&quot;
+				  class = &quot;MonoQuery.Commands.MonoQueryShowSqlViewCommand&quot;/&gt;		
+		&lt;MenuItem id = &quot;Separator1&quot; 
+			  _label = &quot;-&quot; /&gt;	
+		&lt;MenuItem id = &quot;Supprimer&quot;
+		          _label = &quot;Remove&quot;
+			  icon=&quot;Icons.16x16.Remove&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRemoveConnectionCommand&quot;/&gt;	
+		&lt;MenuItem id = &quot;Separator2&quot; 
+			  _label = &quot;-&quot; /&gt;
+&lt;!-- No Glade Druid made yet
+		&lt;MenuItem id = &quot;ModifyConnection&quot;
+		          _label = &quot;Modify Connection&quot;
+			  icon=&quot;Icons.16x16.Edit&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryModifyConnectionCommand&quot;/&gt;
+--&gt;
+		&lt;MenuItem id = &quot;Disconnect&quot;
+		          _label = &quot;Disconnect&quot;
+		          icon = &quot;MonoQuery.Disconnect&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryDisconnectCommand&quot;/&gt;
+		&lt;MenuItem id = &quot;Connect&quot;
+		          _label = &quot;Connect&quot;
+		          icon = &quot;MonoQuery.Connect&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryConnectCommand&quot;/&gt;
+	&lt;/Extension&gt;
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/TablesRoot&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+	&lt;/Extension&gt;
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/ViewsRoot&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+	&lt;/Extension&gt;
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/ProceduresRoot&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+	&lt;/Extension&gt;
+
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/Table&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+		&lt;MenuItem id = &quot;ExtractData&quot;
+		          _label = &quot;Extract Data&quot;
+			  icon = &quot;Icons.16x16.PreView&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryExecuteCommand&quot;/&gt;
+	&lt;/Extension&gt;
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/View&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+		&lt;MenuItem id = &quot;ExtractData&quot;
+		          _label = &quot;Extract Data&quot;
+			  icon = &quot;Icons.16x16.PreView&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryExecuteCommand&quot;/&gt;		          
+	&lt;/Extension&gt;
+
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/Procedure&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;
+&lt;!--
+		&lt;MenuItem id = &quot;ExecuteProcedure&quot;
+		          _label = &quot;Execute Procedure&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryExecuteCommand&quot;/&gt;
+--&gt;
+	&lt;/Extension&gt;
+
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/Coulmn&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+	&lt;/Extension&gt;
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/Parameter&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+	&lt;/Extension&gt;
+
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/Catalog&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+	&lt;/Extension&gt;
+	
+	&lt;Extension path = &quot;/MonoQuery/ContextMenu/Schema&quot;&gt;
+		&lt;MenuItem id = &quot;Refresh&quot;
+		          _label = &quot;Refresh&quot;
+		          icon = &quot;Icons.16x16.BrowserRefresh&quot;
+		          class = &quot;MonoQuery.Commands.MonoQueryRefreshCommand&quot;/&gt;		
+	&lt;/Extension&gt;
+	
+&lt;/AddIn&gt;
+
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 2117)
+++ Makefile.am	(working copy)
@@ -1,6 +1,6 @@
 # leave gdldock first
 # (mkdir ../../build/bin/ hack)
-SUBDIRS = Core build po
+SUBDIRS = Core build po Extras
 
 bin_SCRIPTS = monodevelop
 

--=-xeykHfuLZqTBWgiH/78s--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001587.html">[MonoDevelop] Changes in SVN
</A></li>
	<LI> Next message: <A HREF="001589.html">[MonoDevelop] monoquery patch for svn r2117
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1588">[ date ]</a>
              <a href="thread.html#1588">[ thread ]</a>
              <a href="subject.html#1588">[ subject ]</a>
              <a href="author.html#1588">[ author ]</a>
         </LI>
       </UL>
</body></html>
