<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] Code completion problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20Code%20completion%20problem&In-Reply-To=1150550687.3819.145.camel%40portatil.aticatac">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004017.html">
   <LINK REL="Next"  HREF="004016.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] Code completion problem</H1>
    <B>Matej Urbas</B> 
    <A HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20Code%20completion%20problem&In-Reply-To=1150550687.3819.145.camel%40portatil.aticatac"
       TITLE="[MonoDevelop] Code completion problem">matej.urbas at gmail.com
       </A><BR>
    <I>Sat Jun 17 11:51:44 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="004017.html">[MonoDevelop] Code completion problem
</A></li>
        <LI>Next message: <A HREF="004016.html">[MonoDevelop] Code completion problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4018">[ date ]</a>
              <a href="thread.html#4018">[ thread ]</a>
              <a href="subject.html#4018">[ subject ]</a>
              <a href="author.html#4018">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Lluis Sanchez wrote:
&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> I have stumbled upon a very disturbing problem...
</I>&gt;&gt;<i> ...serialized/deserialized as a whole (atomically). 
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> The problem is, there si no such 'whole'. Code completion information is
</I>&gt;<i> spread in many different .pidb files. Every referenced assembly and
</I>&gt;<i> every project has its own pidb file. When MonoDevelop opens a project it
</I>&gt;<i> &quot;opens&quot; its pidb file, and the pidb file of all the directly or
</I>&gt;<i> indirectly referenced assemblies. pidb files are not fully loaded in
</I>&gt;<i> memory, only a class index is initially loaded. Class information is
</I>&gt;<i> loaded from disk under demand. All this save a lot of memory when
</I>&gt;<i> dealing with big projects.
</I>&gt;<i>   
</I>
Yes, indeed. I concentrated more on the ParserDatabase (which seems to 
be the centralized store? - the 'whole' as we are referring to it), 
which I thought is broken into several pieces (on serialization) and 
then fully put together (on deserialization).  But what I didn't know is 
that there is a class index - and with it lazy loading of classes. (I 
have found it in the code now.) A very nice feature to have! Yep, it 
would be very hard (well, impossible) to do such a thing with normal 
serialization.

Very useful information!

&gt;<i>   
</I>&gt;&gt;<i> This is not 
</I>&gt;&gt;<i> only an unnecessary overhead far exceeding everything I've ever seen, 
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Nope, you've already seen something like this. When Mono loads an
</I>&gt;<i> assembly it has to resolve every language element it deserializes. The
</I>&gt;<i> concept is the same.
</I>&gt;<i>   
</I>
Yes, but I was thinking we could make this process void if we would use 
(de)serialized references to 'IClass' (and other constructs). Yes, in 
this case we would have other problems, such as 'What should be done if 
the definition of an 'IClass' changes?' - the answer 'all classes that 
reference it should be invalidated - and processed by a parser when 
actually accessed/needed' implies some logic that would have to be 
implemented (but I don't know if it needs to be very complicated 
either... - just resolving, as it is implemented now, would suffice).

Well, from what you said: I guess due to the drawbacks of using the 
'whole' serialization, this just isn't worth it...

&gt;<i>   
</I>&gt;&gt;<i> it's also a big problem for coders (like me), because adding only one 
</I>&gt;&gt;<i> piece of support for whatever new code completion feature (in my case 
</I>&gt;&gt;<i> generics) will result in inevitable neck breaking, endless coding and 
</I>&gt;&gt;<i> total breakage of interrelated code (code so interrelated that no 
</I>&gt;&gt;<i> foreign programmer will ever be capable having an oversight of it).
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Adding new information to classes means adding to IClass and related
</I>&gt;<i> classes, implement the serialization code and implement the resolving
</I>&gt;<i> code. Those basic operations need to be implement whatever serialization
</I>&gt;<i> model you use.
</I>&gt;<i>   
</I>
Yes, I have discovered that, and adding for example GenericArguments in 
IReturnType seems not to hurt much.

&gt;<i> Changing existing structures is a harder work, since you'll need to
</I>&gt;<i> change the parser and resolver code of the language bindings. Such is
</I>&gt;<i> life.
</I>&gt;<i>   
</I>
This, on the other hand, is a more delicate problem - the actual source 
of my panic attack ;-)

When I wanted to change the BaseTypes (in IClass) from StringCollection 
to ReturnTypeList, I discovered one problem after the other - it started 
to seem as an endless cascade... I also started to worry because I've 
seen how many heavy weight algorithms I will have to add. Like you said, 
c'est la vie.

Well, it will just take some more time for me to figure out what has to 
be done, but in the end it should be alright.

&gt;&gt;<i> My arguments underpinning the statement 'the current code completion 
</I>&gt;&gt;<i> architecture is fundamentally flawed':
</I>&gt;&gt;<i> - we get duplicated entries in the persistent storage (fully qualified 
</I>&gt;&gt;<i> names of types being just one of these)
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> I've already explained that parser information is spread in several pidb
</I>&gt;<i> files. If you agree in that this is necessary, then you must also agree
</I>&gt;<i> that storing fully qualified names is needed in this model. We can't
</I>&gt;<i> store 'pointers' from A.pidb to B.pidb because if B changes, pointer
</I>&gt;<i> values will change, and references in A.pidb will break with no chance
</I>&gt;<i> of recovery. Notice that B.pidb may change while A not being in memory
</I>&gt;<i> (for example, B may be loaded as part of another C project).
</I>&gt;<i>
</I>&gt;<i> The only way to keep a consistent structure of class references would
</I>&gt;<i> imply managing all parser information as a whole, so for example if a
</I>&gt;<i> class in mscorlib changes its location for some reason (it's pointer or
</I>&gt;<i> id), the parse information for all projects and all assemblies in your
</I>&gt;<i> hard disk would need to be updated. Keeping track of all this huge
</I>&gt;<i> amount of information would be something really hard to implement in an
</I>&gt;<i> efficient way (if possible at all).
</I>&gt;<i>   
</I>
Well, if we had a centralized store, keeping track of changes in 
projects of a solution wouldn't be hard. It is true that if we would 
open a project on its own - not in its solution, the pidb files would 
have to be recreated... but MonoDevelop currently only supports 
referencing projects that are opened in the parent solution. If we 
wanted to implement cross solution project references, we would have to 
add some 'file pointers' into pidb files anyways, wouldn't we?

If we would, however, say to a project that it should look for central 
class information store at a certain location on the disk, we would have 
many problems solved. If the central strore wouldn't be found, a new 
could be created easily...

With it, we would have the freedom of choice to use direct IClass 
references instead of fully qualified names. Resolving would still be 
the same, only that the result would not be a fully qualified name but 
an IClass reference.

&gt;<i> &gt;From the storage point of view, a pidb file has a string table where all
</I>&gt;<i> strings (including type names) are stored, so there is no string
</I>&gt;<i> duplication inside a pidb file. There is another string table in memory,
</I>&gt;<i> to avoid duplication when loading class information in memory.
</I>&gt;<i>   
</I>
Another thing I missed.

&gt;<i>   
</I>&gt;&gt;<i> - we get multiple utility classes which exist only because we have such 
</I>&gt;&gt;<i> a curious way of (de)serializing type information (look at all those 
</I>&gt;&gt;<i> 'Persistent&lt;Type&gt;' classes or the ITypeResolver) - making up the 
</I>&gt;&gt;<i> spaghetti I was talking about...
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> I admit that the class structure is a bit weird here, since it was an
</I>&gt;<i> incremental change from SharpDevelop code. All Persistent* classes were
</I>&gt;<i> real instances which implemented the serialization code. This was
</I>&gt;<i> changed to utility classes to be able to serialize any implementation of
</I>&gt;<i> IClass and related information. All those Abstract* base inheritance
</I>&gt;<i> relations in Persistent* could be removed.
</I>&gt;<i>   
</I>
Perhaps I could change that in the process?

&gt;<i>   
</I>&gt;&gt;<i> - many of these utility classes do per element array copies in 'foreach' 
</I>&gt;&gt;<i> loops and a lot of O(n^2) or even more heavy algorithms to do things 
</I>&gt;&gt;<i> that would otherwise never be needed &lt;-- this is done in the resolving 
</I>&gt;&gt;<i> process
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> ITypeResolver is not being used when loading parser information from
</I>&gt;<i> disk, but to resolve partial type names provided by the parser. That's
</I>&gt;<i> NEEDED, you can't avoid it.
</I>&gt;<i>   
</I>
Yes, I agree. When I saw the 'Resolve' method in 'PersistentClass' I 
immediately thought it is called in the 'Loading' stage.

&gt;<i> Let's say I have this code:
</I>&gt;<i>
</I>&gt;<i> public class MyClass: ArrayList
</I>&gt;<i> {
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> The parsing process is like this:
</I>&gt;<i>       * The c# language binding parses the source code. The result is an
</I>&gt;<i>         IClass instance which has &quot;ArrayList&quot; in the list of base
</I>&gt;<i>         classes.
</I>&gt;<i>       * The MD parser service takes the IClass and 'resolves' it. This
</I>&gt;<i>         means converting partial class names into fully qualified type
</I>&gt;<i>         names. In this process, ArrayList is converted into
</I>&gt;<i>         System.ArrayList.
</I>&gt;<i>       * The resolved IClass is added to the parser database, and will be
</I>&gt;<i>         stored to disk when the parser services decides it. This class
</I>&gt;<i>         will never be resolved again (until replaced by a new re-parsed
</I>&gt;<i>         instance).
</I>&gt;<i>   
</I>
I see! I will surely remember this - it will be needed when I have to 
resolve the list of IReturnTypes (which will represent the base types of 
an IClass).

&gt;<i> You can't avoid this process, although it might be improved. For
</I>&gt;<i> example, it might be possible to update the IClass instance instead of
</I>&gt;<i> crating a new one. It would require changes in all those interfaces
</I>&gt;<i> since many name setters are missing (honestly, I would enjoy seeing all
</I>&gt;<i> those interfaces being replaced by sealed classes).
</I>
Sealed classes? You mean that language bindings implementors wouldn't be 
able to create their own specialized language elements to store whatever 
additional info they need? I like those abstract classes more - which 
should be used in place of the interfaces...

What is ClassProxy needed for? Grep tells me, it's pretty much unused...

&gt;<i> In any case, I don't think this is a performance issue, since this
</I>&gt;<i> resolving process is only executed when parsing the file being edited
</I>&gt;<i> (which will often have only one class), or when parsing other project
</I>&gt;<i> files due for example to an SVN update (in this case the parser process
</I>&gt;<i> is done in background, so no big issue).
</I>&gt;<i>   
</I>
It's needed anyways.

&gt;<i>   
</I>&gt;&gt;<i> - we have a lot of statements like these: 'return new ArrayList()' where 
</I>&gt;&gt;<i> we create a lot of temporary arrays just because some utility classes 
</I>&gt;&gt;<i> don't check whether some properties are 'null' or not. 
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Only the utility classes? The whole IDE and all its add-ins have access
</I>&gt;<i> to IClass, and they expect to get collections even if they are empty,
</I>&gt;<i> instead of null.
</I>&gt;<i>
</I>&gt;<i>   
</I>&gt;&gt;<i> Now tell me, 
</I>&gt;&gt;<i> honestly, which operation is more expensive (speed- and memory-wise): 
</I>&gt;&gt;<i> creating a new ArrayList, or checking that it is 'null'?
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> Checking for null. However, in public APIs making a property return
</I>&gt;<i> either a collection of items OR null if there are no items is a bad
</I>&gt;<i> coding practice. It leads to user code more difficult to read (you have
</I>&gt;<i> to add a null check to every collection access) and buggy (soon or later
</I>&gt;<i> some user will forget to add the null check).
</I>&gt;<i>   
</I>
Yes, but null checks are the easiest things to notice and to fix... You 
see, I have already planned to add properties that may return 'null' to 
indicate that there is nothing there. Should I change that (for example 
if you look into my patch for IClass and IReturnType)?

&gt;<i>   
</I>&gt;&gt;<i> Errr, why did Mike Kr&#252;ger decide to store things this way? 
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> He did not. The original SharpDevelop code did not have the concept of
</I>&gt;<i> pidb files. I completely redesigned the way parser information is stored
</I>&gt;<i> and loaded. I also made some improvements in the resolving process.
</I>&gt;<i> However, the class structures (IClass and such), and the infrastructure
</I>&gt;<i> for language binding parsers are more or less the same.
</I>&gt;<i>   
</I>
And you have convinced me that your design is reasonable and the only 
way to go.

&gt;<i>   
</I>&gt;&gt;<i> Is .NET's 
</I>&gt;&gt;<i> serialization so ineffective (bloated, slow?) that he wanted to 
</I>&gt;&gt;<i> sacrifice speed and in-memory space in favour of on-disk space 
</I>&gt;&gt;<i> consumption? 
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> I once implemented a project reader for MonoDevelop which was able to
</I>&gt;<i> understand Mono's makefile format. So I could click on &quot;Open File&quot;,
</I>&gt;<i> select the root Mono makefile, and that would load the entire Mono tree
</I>&gt;<i> of projects into MonoDevelop. The first time I tried it, the CPU jumped
</I>&gt;<i> to 100%, memory started growing, and MD crashed after several minutes
</I>&gt;<i> after filling all the available memory. And all this was because of the
</I>&gt;<i> parser information.
</I>&gt;<i>
</I>&gt;<i> With the current design, the entire MD tree loads in a few seconds, and
</I>&gt;<i> takes a few megs of memory.
</I>&gt;<i>   
</I>
I'm convinced ;-)

&gt;<i>   
</I>&gt;&gt;<i> Well, if disk space is a problem, we can still compress the 
</I>&gt;&gt;<i> code completion database... But essentially, I doubt this is a 
</I>&gt;&gt;<i> problem... If there are some insiders among you guys, please, tell me if 
</I>&gt;&gt;<i> and why I'm wrong - what have I overlooked.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Do I have a go for designing a new architecture, or do you guys have any 
</I>&gt;&gt;<i> warnings or objections for me. I'm aware that I might be wrong with some 
</I>&gt;&gt;<i> (or all) of my above assumptions.
</I>&gt;&gt;<i>     
</I>&gt;<i>
</I>&gt;<i> You now have more info, judge it yourself. I'm open to ideas for
</I>&gt;<i> improving the performance and memory usage, as long as they have a good
</I>&gt;<i> cost/benefit trade-off (if not, there are other MD areas that need
</I>&gt;<i> work).
</I>&gt;<i>   
</I>
Yes, that's the info I needed.

I panicked because I've seen how many things will have to be changed 
when converting StringCollection of BaseTypes into a ReturnTypeList. I 
had to research other parts of MonoDevelop and I started seeing things I 
was't ready to see. I asked myself why are some of these things needed?

Don't be angry with me - I'm trying to gather as much information as 
will be needed to finally start doing something productive :-) I had to 
point out what I had on my mind. I didn't mean to sound offending.

In the end, generics have to be added before I can move on to other areas...

Enjoy,
---
Matej
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004017.html">[MonoDevelop] Code completion problem
</A></li>
	<LI>Next message: <A HREF="004016.html">[MonoDevelop] Code completion problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4018">[ date ]</a>
              <a href="thread.html#4018">[ thread ]</a>
              <a href="subject.html#4018">[ subject ]</a>
              <a href="author.html#4018">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-list">More information about the Monodevelop-list
mailing list</a><br>
</body></html>
