<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] Code completion problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20Code%20completion%20problem&In-Reply-To=4493DA55.4090300%40gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004015.html">
   <LINK REL="Next"  HREF="004018.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] Code completion problem</H1>
    <B>Lluis Sanchez</B> 
    <A HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20Code%20completion%20problem&In-Reply-To=4493DA55.4090300%40gmail.com"
       TITLE="[MonoDevelop] Code completion problem">lluis at ximian.com
       </A><BR>
    <I>Sat Jun 17 09:24:47 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="004015.html">[MonoDevelop] Code completion problem
</A></li>
        <LI>Next message: <A HREF="004018.html">[MonoDevelop] Code completion problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4017">[ date ]</a>
              <a href="thread.html#4017">[ thread ]</a>
              <a href="subject.html#4017">[ subject ]</a>
              <a href="author.html#4017">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

&gt;<i> I have stumbled upon a very disturbing problem. When I realized that 
</I>&gt;<i> IClass doesn't have a list of IReturnType for its base classes I thought 
</I>&gt;<i> 'why not changing the string collection of base types into a list of 
</I>&gt;<i> IReturnType' - surely, it is needed if we want generics in MonoDevelop. 
</I>&gt;<i> Well, since this was the first compromising change of the current 
</I>&gt;<i> architecture (the serialization process of IClass instances changed with 
</I>&gt;<i> this), I had to change some things in the Persistent&lt;Type&gt; classes. 
</I>&gt;<i> Soon, after having to change the behaviour of dozens of other classes, I 
</I>&gt;<i> have realized that we have a very serious problem.
</I>&gt;<i> 
</I>&gt;<i> Explanation: Currently the architecture's deserialization process has to 
</I>&gt;<i> resolve EVERY language element it deserializes from the persistent 
</I>&gt;<i> storage. Obviously this would not be necessary if the persistent storage 
</I>&gt;<i> would be serialized/deserialized as a whole (atomically). 
</I>
The problem is, there si no such 'whole'. Code completion information is
spread in many different .pidb files. Every referenced assembly and
every project has its own pidb file. When MonoDevelop opens a project it
&quot;opens&quot; its pidb file, and the pidb file of all the directly or
indirectly referenced assemblies. pidb files are not fully loaded in
memory, only a class index is initially loaded. Class information is
loaded from disk under demand. All this save a lot of memory when
dealing with big projects.

&gt;<i> This is not 
</I>&gt;<i> only an unnecessary overhead far exceeding everything I've ever seen, 
</I>
Nope, you've already seen something like this. When Mono loads an
assembly it has to resolve every language element it deserializes. The
concept is the same.

&gt;<i> it's also a big problem for coders (like me), because adding only one 
</I>&gt;<i> piece of support for whatever new code completion feature (in my case 
</I>&gt;<i> generics) will result in inevitable neck breaking, endless coding and 
</I>&gt;<i> total breakage of interrelated code (code so interrelated that no 
</I>&gt;<i> foreign programmer will ever be capable having an oversight of it).
</I>
Adding new information to classes means adding to IClass and related
classes, implement the serialization code and implement the resolving
code. Those basic operations need to be implement whatever serialization
model you use.

Changing existing structures is a harder work, since you'll need to
change the parser and resolver code of the language bindings. Such is
life.

&gt;<i> 
</I>&gt;<i> My arguments underpinning the statement 'the current code completion 
</I>&gt;<i> architecture is fundamentally flawed':
</I>&gt;<i> - we get duplicated entries in the persistent storage (fully qualified 
</I>&gt;<i> names of types being just one of these)
</I>
I've already explained that parser information is spread in several pidb
files. If you agree in that this is necessary, then you must also agree
that storing fully qualified names is needed in this model. We can't
store 'pointers' from A.pidb to B.pidb because if B changes, pointer
values will change, and references in A.pidb will break with no chance
of recovery. Notice that B.pidb may change while A not being in memory
(for example, B may be loaded as part of another C project).

The only way to keep a consistent structure of class references would
imply managing all parser information as a whole, so for example if a
class in mscorlib changes its location for some reason (it's pointer or
id), the parse information for all projects and all assemblies in your
hard disk would need to be updated. Keeping track of all this huge
amount of information would be something really hard to implement in an
efficient way (if possible at all).

&gt;<i>From the storage point of view, a pidb file has a string table where all
</I>strings (including type names) are stored, so there is no string
duplication inside a pidb file. There is another string table in memory,
to avoid duplication when loading class information in memory.

&gt;<i> - we get multiple utility classes which exist only because we have such 
</I>&gt;<i> a curious way of (de)serializing type information (look at all those 
</I>&gt;<i> 'Persistent&lt;Type&gt;' classes or the ITypeResolver) - making up the 
</I>&gt;<i> spaghetti I was talking about...
</I>
I admit that the class structure is a bit weird here, since it was an
incremental change from SharpDevelop code. All Persistent* classes were
real instances which implemented the serialization code. This was
changed to utility classes to be able to serialize any implementation of
IClass and related information. All those Abstract* base inheritance
relations in Persistent* could be removed.

&gt;<i> - many of these utility classes do per element array copies in 'foreach' 
</I>&gt;<i> loops and a lot of O(n^2) or even more heavy algorithms to do things 
</I>&gt;<i> that would otherwise never be needed &lt;-- this is done in the resolving 
</I>&gt;<i> process
</I>
ITypeResolver is not being used when loading parser information from
disk, but to resolve partial type names provided by the parser. That's
NEEDED, you can't avoid it.

Let's say I have this code:

public class MyClass: ArrayList
{
}

The parsing process is like this:
      * The c# language binding parses the source code. The result is an
        IClass instance which has &quot;ArrayList&quot; in the list of base
        classes.
      * The MD parser service takes the IClass and 'resolves' it. This
        means converting partial class names into fully qualified type
        names. In this process, ArrayList is converted into
        System.ArrayList.
      * The resolved IClass is added to the parser database, and will be
        stored to disk when the parser services decides it. This class
        will never be resolved again (until replaced by a new re-parsed
        instance).

You can't avoid this process, although it might be improved. For
example, it might be possible to update the IClass instance instead of
crating a new one. It would require changes in all those interfaces
since many name setters are missing (honestly, I would enjoy seeing all
those interfaces being replaced by sealed classes).

In any case, I don't think this is a performance issue, since this
resolving process is only executed when parsing the file being edited
(which will often have only one class), or when parsing other project
files due for example to an SVN update (in this case the parser process
is done in background, so no big issue).

&gt;<i> - we have a lot of statements like these: 'return new ArrayList()' where 
</I>&gt;<i> we create a lot of temporary arrays just because some utility classes 
</I>&gt;<i> don't check whether some properties are 'null' or not. 
</I>
Only the utility classes? The whole IDE and all its add-ins have access
to IClass, and they expect to get collections even if they are empty,
instead of null.

&gt;<i> Now tell me, 
</I>&gt;<i> honestly, which operation is more expensive (speed- and memory-wise): 
</I>&gt;<i> creating a new ArrayList, or checking that it is 'null'?
</I>
Checking for null. However, in public APIs making a property return
either a collection of items OR null if there are no items is a bad
coding practice. It leads to user code more difficult to read (you have
to add a null check to every collection access) and buggy (soon or later
some user will forget to add the null check).

&gt;<i> 
</I>&gt;<i> Errr, why did Mike Kr&#252;ger decide to store things this way? 
</I>
He did not. The original SharpDevelop code did not have the concept of
pidb files. I completely redesigned the way parser information is stored
and loaded. I also made some improvements in the resolving process.
However, the class structures (IClass and such), and the infrastructure
for language binding parsers are more or less the same.

&gt;<i> Is .NET's 
</I>&gt;<i> serialization so ineffective (bloated, slow?) that he wanted to 
</I>&gt;<i> sacrifice speed and in-memory space in favour of on-disk space 
</I>&gt;<i> consumption? 
</I>
I once implemented a project reader for MonoDevelop which was able to
understand Mono's makefile format. So I could click on &quot;Open File&quot;,
select the root Mono makefile, and that would load the entire Mono tree
of projects into MonoDevelop. The first time I tried it, the CPU jumped
to 100%, memory started growing, and MD crashed after several minutes
after filling all the available memory. And all this was because of the
parser information.

With the current design, the entire MD tree loads in a few seconds, and
takes a few megs of memory.

&gt;<i> Well, if disk space is a problem, we can still compress the 
</I>&gt;<i> code completion database... But essentially, I doubt this is a 
</I>&gt;<i> problem... If there are some insiders among you guys, please, tell me if 
</I>&gt;<i> and why I'm wrong - what have I overlooked.
</I>&gt;<i> 
</I>&gt;<i> Do I have a go for designing a new architecture, or do you guys have any 
</I>&gt;<i> warnings or objections for me. I'm aware that I might be wrong with some 
</I>&gt;<i> (or all) of my above assumptions.
</I>
You now have more info, judge it yourself. I'm open to ideas for
improving the performance and memory usage, as long as they have a good
cost/benefit trade-off (if not, there are other MD areas that need
work).

Thanks!
Lluis.



</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004015.html">[MonoDevelop] Code completion problem
</A></li>
	<LI>Next message: <A HREF="004018.html">[MonoDevelop] Code completion problem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4017">[ date ]</a>
              <a href="thread.html#4017">[ thread ]</a>
              <a href="subject.html#4017">[ subject ]</a>
              <a href="author.html#4017">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-list">More information about the Monodevelop-list
mailing list</a><br>
</body></html>
