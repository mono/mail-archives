<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] Larger set of stetic patches
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20Larger%20set%20of%20stetic%20patches&In-Reply-To=1151353390.16814.28.camel%40karnajkaj.egocentrix.net">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004062.html">
   <LINK REL="Next"  HREF="004106.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] Larger set of stetic patches</H1>
    <B>Lluis Sanchez</B> 
    <A HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20Larger%20set%20of%20stetic%20patches&In-Reply-To=1151353390.16814.28.camel%40karnajkaj.egocentrix.net"
       TITLE="[MonoDevelop] Larger set of stetic patches">lluis at ximian.com
       </A><BR>
    <I>Thu Jun 29 11:57:14 EDT 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="004062.html">[MonoDevelop] Larger set of stetic patches
</A></li>
        <LI>Next message: <A HREF="004106.html">[MonoDevelop] Larger set of stetic patches
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4091">[ date ]</a>
              <a href="thread.html#4091">[ thread ]</a>
              <a href="subject.html#4091">[ subject ]</a>
              <a href="author.html#4091">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ok, so right now Stetic gets the information about widgets from an
objects.xml file embedded in the library. What you are proposing is to
read that information, or at least part of it, from the widget classes
using reflection. That's an important change in the model, so it needs
some thinking.

There are at least two scenarios in which an xml description is
necessary and can't be replaced by reflection:

      * When we can't modify the widget library to add attributes.
        That's the case of gtk#.
      * When building a dll which implements both widgets and windows
        that contain instances of those widgets. The problem in this
        case is that we need to have the widget description before
        compiling, but we don't have a dll to reflect.

So we still need to support the xml model, and I'm not sure it is a good
idea to provide another model for describing widgets. In any case I
don't think that mixing both models is good. A library should describe a
widget either using xml or reflection, but not a mix of both.

&gt;<i> 
</I>&gt;<i> These patches include: 
</I>&gt;<i> 
</I>&gt;<i> 1. ToolboxItem kind of specifying of widgets (but you still have to
</I>&gt;<i> specify export widget in project options)
</I>&gt;<i> 
</I>&gt;<i> [ToolboxItem (true)]
</I>&gt;<i> [Category (&quot;widgetgroup&quot;)]
</I>&gt;<i> [Description (&quot;Description as posed as label to icon&quot;]
</I>&gt;<i> public class SomeWidget
</I>&gt;<i> {
</I>&gt;<i> ...
</I>&gt;<i> }
</I>
If widgets still have to be specified in the export widget option panel,
what's the point of using [ToolboxItem]?

&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 2. Adding new groups to stetic from code on loading library
</I>&gt;<i> (ToolboxItem(false) and abstract are conditions here). Original .Net
</I>&gt;<i> does not provide groups, stetic requires them
</I>&gt;<i> 
</I>&gt;<i> [ToolboxItem (false), Category (&quot;widgetgroup&quot;), Description (&quot;Group
</I>&gt;<i> Label&quot;]
</I>&gt;<i> public abstract class SomeClass { /* dummy abstract class */ }
</I>
This is really ugly. If a widget library needs to define new categories,
it should do it in the objects.xml file.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 3. Correction to objects.xml for SpinButton, second itemgroup &quot;Spin
</I>&gt;<i> Button Properties&quot; was not inheritable because it didn't provide name
</I>
Ok.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 4. Real loading when specifying -lib:&lt;somelibrary&gt;, previous code was
</I>&gt;<i> missing actual loading
</I>
Ok.

&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 5. Added possibility for control to specify CreateWrappedInstance
</I>&gt;<i> method, without this wrapped controls couldn't work without being
</I>&gt;<i> referenced to stetic. This enables stetic to use base wrapper and use
</I>&gt;<i> re
</I>&gt;<i> classed widget. It basically enables for widgets to be fully
</I>&gt;<i> functional
</I>&gt;<i> without being referenced to stetic.
</I>
Can you give an example in which is this needed?

More comments inline...

&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> m.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> fitxer adjunt
</I>&gt;<i> differences
</I>&gt;<i> between files
</I>&gt;<i> (toolboxitem_groups_few_errors.patch)
</I>&gt;<i> 
</I>
&gt;<i> (snip)
</I>
&gt;<i> stetic.clean/libstetic/ClassDescriptor.cs
</I>&gt;<i> --- stetic/libstetic/ClassDescriptor.cs 2006-06-09 22:59:49.000000000
</I>&gt;<i> +0200
</I>&gt;<i> +++ stetic.clean/libstetic/ClassDescriptor.cs   2006-06-24
</I>&gt;<i> 20:46:00.000000000 +0200
</I>&gt;<i> @@ -9,6 +9,20 @@
</I>&gt;<i>         
</I>&gt;<i>         public abstract class ClassDescriptor
</I>&gt;<i>         {
</I>&gt;<i> +               public struct ToolboxItemDefinitions
</I>&gt;<i> +               {
</I>&gt;<i> +                       public string Name;
</I>&gt;<i> +                       public string Category;
</I>&gt;<i> +                       public string Description;
</I>&gt;<i> +                       
</I>&gt;<i> +                       public ToolboxItemDefinitions (string aName,
</I>&gt;<i> string aCategory, string aDescription)
</I>&gt;<i> +                       {
</I>&gt;<i> +                               Name = aName;
</I>&gt;<i> +                               Category = aCategory;
</I>&gt;<i> +                               Description = aDescription;
</I>&gt;<i> +                       }
</I>&gt;<i> +               }
</I>
Why do you need this struct? class descriptors need a name, category and
description, doesn't matter if they have been described using attributes
or xml.

&gt;<i> (snip)
</I>
&gt;<i> diff -ruN stetic/libstetic/Registry.cs
</I>&gt;<i> stetic.clean/libstetic/Registry.cs
</I>&gt;<i> --- stetic/libstetic/Registry.cs        2006-03-15 16:40:40.000000000
</I>&gt;<i> +0100
</I>&gt;<i> +++ stetic.clean/libstetic/Registry.cs  2006-06-26 04:43:16.000000000
</I>&gt;<i> +0200
</I>&gt;<i> @@ -1,5 +1,6 @@
</I>&gt;<i>  using System;
</I>&gt;<i>  using System.Collections;
</I>&gt;<i> +using System.ComponentModel;
</I>&gt;<i>  using System.Reflection;
</I>&gt;<i>  using System.Xml;
</I>&gt;<i>  using System.Xml.Xsl;
</I>&gt;<i> @@ -7,15 +8,41 @@
</I>&gt;<i>  namespace Stetic {
</I>&gt;<i>         public static class Registry {
</I>&gt;<i>  
</I>&gt;<i> +               public delegate void PaletteGroupsChanged();
</I>&gt;<i> +
</I>&gt;<i> +               public class ControlGroup {
</I>&gt;<i> +                       public string Name;
</I>&gt;<i> +                       public string DisplayName;
</I>&gt;<i> +                       public int Ref;
</I>&gt;<i> +                       
</I>&gt;<i> +                       public ControlGroup (string name, string
</I>&gt;<i> displayname)
</I>&gt;<i> +                       {
</I>&gt;<i> +                               Name = name;
</I>&gt;<i> +                               DisplayName = displayname;
</I>&gt;<i> +                               Ref = 1;
</I>&gt;<i> +                       }
</I>&gt;<i> +               }
</I>
If the class is public, please use properties, not public fields.

&gt;<i> +               
</I>&gt;<i> +               public static void DoRegisterWidgetLibrary
</I>&gt;<i> (WidgetLibrary library, bool register)
</I>&gt;<i> +               {
</I>&gt;<i> +                       if (library is AssemblyWidgetLibrary) {
</I>&gt;<i> +                               AssemblyWidgetLibrary asm =
</I>&gt;<i> (AssemblyWidgetLibrary) library;
</I>&gt;<i> +                               bool onlygroup, group = false;
</I>&gt;<i> +                               bool ctrl, cat, desc = false;
</I>&gt;<i> +                               string name, category, description =
</I>&gt;<i> &quot;&quot;;
</I>&gt;<i> +                               foreach (System.Type type in
</I>&gt;<i> asm.Asm.GetExportedTypes()) {
</I>&gt;<i> +                                       Attribute[] attrs =
</I>&gt;<i> Attribute.GetCustomAttributes (type);
</I>&gt;<i> +                                       onlygroup = ((type.IsAbstract
</I>&gt;<i> == true) || (type.IsNotPublic == true));
</I>&gt;<i> +                                       
</I>&gt;<i> +                                       ctrl = false; cat = false;
</I>&gt;<i> desc = false; group = false;
</I>&gt;<i> +                                       name = &quot;&quot;; category = &quot;&quot;;
</I>&gt;<i> description = &quot;&quot;;
</I>&gt;<i> +                                       foreach (Attribute attr in
</I>&gt;<i> attrs) {
</I>&gt;<i> +                                               if (attr is
</I>&gt;<i> ToolboxItemAttribute) {
</I>&gt;<i> +                                                       name =
</I>&gt;<i> type.Name;
</I>&gt;<i> +                                                       if
</I>&gt;<i> (attr.Equals(ToolboxItemAttribute.Default) == true) {
</I>&gt;<i> +                                                               ctrl =
</I>&gt;<i> true;
</I>&gt;<i> +                                                               if
</I>&gt;<i> ((type.IsAbstract == true) || (type.IsNotPublic == true))
</I>&gt;<i> +                                                                       continue;
</I>&gt;<i> +                                                       }
</I>&gt;<i> +                                                       else
</I>&gt;<i> +                                                               //
</I>&gt;<i> Group specifiying class has to be abstract
</I>&gt;<i> +                                                               if
</I>&gt;<i> ((attr.Equals(ToolboxItemAttribute.None) == true) &amp;&amp; (type.IsAbstract
</I>&gt;<i> == true)) {
</I>&gt;<i> +                                                                       group = true;
</I>&gt;<i> +                                                                       ctrl = true;
</I>&gt;<i> +                                                               }
</I>&gt;<i> +                                                       if ((ctrl ==
</I>&gt;<i> false) &amp;&amp; (group == false))
</I>&gt;<i> +                                                               continue;
</I>&gt;<i> +                                               }
</I>&gt;<i> +                                               if (attr is
</I>&gt;<i> CategoryAttribute) {
</I>&gt;<i> +                                                       cat = true;
</I>&gt;<i> +                                                       category =
</I>&gt;<i> (attr as CategoryAttribute).Category;
</I>&gt;<i> +                                               }
</I>&gt;<i> +                                               if (attr is
</I>&gt;<i> DescriptionAttribute) {
</I>&gt;<i> +                                                       desc = true;
</I>&gt;<i> +                                                       description =
</I>&gt;<i> (attr as DescriptionAttribute).Description;
</I>&gt;<i> +                                               }
</I>&gt;<i> +                                       }
</I>&gt;<i> +
</I>&gt;<i> +                                       if (ctrl == true)
</I>&gt;<i> +                                               if (group == true) {
</I>&gt;<i> +                                                       if
</I>&gt;<i> (description == &quot;&quot;)
</I>&gt;<i> +                                                               description = category;
</I>&gt;<i> +                                                       if (register
</I>&gt;<i> == true)
</I>&gt;<i> +                                                               AddControlGroup (category, description);
</I>&gt;<i> +                                                       else
</I>&gt;<i> +                                                               RemoveControlGroup (category);
</I>&gt;<i> +                                               }
</I>&gt;<i> +                                               else
</I>&gt;<i> +                                                       if
</I>&gt;<i> (ControlGroupExists(category) == false) {
</I>&gt;<i> +                                                               category = &quot;unsorted&quot;;
</I>&gt;<i> +                                                               if
</I>&gt;<i> (ControlGroupExists(&quot;unsorted&quot;) == false)
</I>&gt;<i> +                                                                       AddControlGroup (&quot;unsorted&quot;, &quot;[Unsorted]&quot;);
</I>&gt;<i> +                                                       }
</I>&gt;<i> +                               }
</I>&gt;<i> +                       }
</I>&gt;<i> +               }
</I>
All the previous method is specific to AssemblyWidgetLibrary, so it
should be moved to that class.

And please, instead of &quot;if (group==true)...&quot; or &quot;if (group==false)...&quot;
use either &quot;if (group)...&quot; or &quot;if (!group)...&quot;.

Lluis.

</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004062.html">[MonoDevelop] Larger set of stetic patches
</A></li>
	<LI>Next message: <A HREF="004106.html">[MonoDevelop] Larger set of stetic patches
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4091">[ date ]</a>
              <a href="thread.html#4091">[ thread ]</a>
              <a href="subject.html#4091">[ subject ]</a>
              <a href="author.html#4091">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-list">More information about the Monodevelop-list
mailing list</a><br>
</body></html>
