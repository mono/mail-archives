<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] Code analysis soc project
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20Code%20analysis%20soc%20project&In-Reply-To=1269414379.2561.30.camel%40mkrueger-desktop">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011544.html">
   <LINK REL="Next"  HREF="011561.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] Code analysis soc project</H1>
    <B>nikhil sarda</B> 
    <A HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20Code%20analysis%20soc%20project&In-Reply-To=1269414379.2561.30.camel%40mkrueger-desktop"
       TITLE="[MonoDevelop] Code analysis soc project">diff.operator at gmail.com
       </A><BR>
    <I>Wed Mar 24 17:40:43 EDT 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="011544.html">[MonoDevelop] Code analysis soc project
</A></li>
        <LI>Next message: <A HREF="011561.html">[MonoDevelop] Code analysis soc project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11553">[ date ]</a>
              <a href="thread.html#11553">[ thread ]</a>
              <a href="subject.html#11553">[ subject ]</a>
              <a href="author.html#11553">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi,

On Wed, Mar 24, 2010 at 12:36 PM, Mike Kr&#252;ger &lt;<A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-list">mkrueger at novell.com</A>&gt; wrote:
&gt;<i> Hi
</I>&gt;<i>
</I>&gt;&gt;<i> That's great to hear!
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm a huge fan of the idea of on-the-fly analysis.
</I>
Do I earn brownie points if I make this my soc? :)

&gt;&gt;<i> As I see it, the core part is a framework for background analysers -
</I>&gt;&gt;<i> an extension point, a service to run the analysers on new
</I>&gt;&gt;<i> ParsedDocuments and report the errors and warnings, and some basic
</I>&gt;&gt;<i> configuration UI. This is the initial &quot;barrier&quot; that needs to be
</I>&gt;&gt;<i> implemented before anyone can write any analysis rules. This could
</I>&gt;&gt;<i> take quite a few weeks to fully implement and polish. &#160;It would also
</I>&gt;&gt;<i> be nice to have a way for rules to attach &quot;fixes&quot; to their results,
</I>&gt;&gt;<i> and this would need a UI too. All of this is completely language
</I>&gt;&gt;<i> agnostic. For example, I might want to write analysers for ASP.NET
</I>&gt;&gt;<i> documents or XML, not just C#.
</I>
What I thought was that the code analysis addin could be run in a
separate thread. It will periodically check the state of the project
and if it finds that documents
have been changed it will reconstruct the AST using the parser service
and feed it to the analysis engine. The engine will then run all the
valid rules on the parser units on another thread and then update the
editor accordingly. A time lag is inevitable, and obviously an initial
implementation will lag for very large code bases.

I have become quite familiar with the new DOM. I have partially
implemented a rule for CS5001 (source file must have Main) and
checking functions for invalid returns  <A HREF="http://pastebin.com/zPnNwvs3">http://pastebin.com/zPnNwvs3</A>
Again these are POCs, I had to do an ugly hack to workaround the non
availability of getting the ReturnType of a method. There are similar
problems getting their arguments as well.

&gt;&gt;<i> Beyond that, there are analysis rules, that scan the parsed documents
</I>&gt;&gt;<i> and report errors, warnings and suggestions. These rules can range
</I>&gt;&gt;<i> from trivial to very complex, and some are much more useful than
</I>&gt;&gt;<i> others.
</I>
I was thinking of implementing some of the rules as defined here
<A HREF="http://msdn.microsoft.com/en-us/library/ms228296%28VS.80%29.aspx">http://msdn.microsoft.com/en-us/library/ms228296%28VS.80%29.aspx</A>

&gt;&gt;<i> My favourite example of a rule is an API naming conventions checker.
</I>&gt;&gt;<i> This would check that any public symbols defined in the file follow
</I>&gt;&gt;<i> .NET naming conventions, e.g. interfaces begin with I, class and
</I>&gt;&gt;<i> member names are PascalCase, parameters are camelCase, and all
</I>&gt;&gt;<i> identifiers are made of CorrectlySpelledWords. This rule would work
</I>&gt;&gt;<i> for any parsed .NET DOM, not just C#, and would be great for teaching
</I>&gt;&gt;<i> the conventions to newcomers, but also to catch typos from seasoned
</I>&gt;&gt;<i> users. It could easily offer quick fixes too, as these would just be
</I>&gt;&gt;<i> rename refactorings. In fact, quite a few of the framework design
</I>&gt;&gt;<i> guideline rules could be checked in a language-agnostic way with the
</I>&gt;&gt;<i> current DOM, since they affect only public API.
</I>&gt;&gt;<i>
</I>
Won't this be a bit difficult (impossible?) to implement? I mean, how
can I tokenize Correct lySpel ledWords ? Will some sort of a
dictionary need to be incorporated?

&gt;<i> Maybe re-implementing all gendarme rules using the ParsedDocument ?
</I>&gt;<i> (including gendarme &gt;may&lt; be easier - hey gendarme developers: include
</I>&gt;<i> gendarme - this way more people will use it)
</I>&gt;<i>
</I>&gt;&gt;<i> Another idea is to show unresolved types and unused usings. This would
</I>&gt;&gt;<i> be C#-only, and require attempting to resolve all types, and could
</I>&gt;&gt;<i> offer the existing &quot;resolve&quot; command as a quick fix. Other easy yet
</I>&gt;&gt;<i> useful rules would be to warn about recursion in properties, error on
</I>&gt;&gt;<i> trivial (i.e. clearly infinite) property recursion, warn about catch
</I>&gt;&gt;<i> blocks that completely discard the exception, check that string.Format
</I>&gt;&gt;<i> format is correct, warn about string concatenation in a loop...
</I>
Many of these rules can be implemented quite straightforwardly if I
have the corresponding parse units.
For unresolved types and unused variables in classes and methods, I
will probably have to save it in some sort of a dictionary to store
and verify at each ExpressionStatement, VariableDeclaration, etc
whether or not they have been used. Ditto for methods, I will have to
create a dictionary first and then verify if they appear anywhere in
various InvocationExpression. Also note that this is a solution wide
rule. MHutch pointed out that I should focus on rules valid for
individual files for now, which is what I plan on doing.

&gt;&gt;<i> Of course there are *many* more complex rules that could be
</I>&gt;&gt;<i> implemented, but are beyond the scope of a single GSoC project. The
</I>&gt;&gt;<i> main thing would be to get the framework implemented and polished,
</I>&gt;&gt;<i> with some fairly simple yet very useful rules to prove it, which would
</I>&gt;&gt;<i> make it possible for other people to contribute individual rules
</I>&gt;&gt;<i> afterwards.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> (I didn't mention spellchecking strings and comments because I think
</I>&gt;&gt;<i> that *might* be better for the text editor to handle based on syntax
</I>&gt;&gt;<i> highlighting, as it would work for many more filetypes. But
</I>&gt;&gt;<i> specialized rules could do a better job because they'd have more
</I>&gt;&gt;<i> context).
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> The spellechecking should be done with red underlines ... the other
</I>&gt;<i> things are more complex. For example the unused usings/unresolved types
</I>&gt;<i> could be 'grayed out' by the C# syntax highlighting. More serve 'bugs'
</I>&gt;<i> may generate warnings or even errors for the task list.
</I>&gt;<i>
</I>&gt;<i> btw. doing this with the current NRefactory AST isn't easy/doable. I've
</I>&gt;<i> run into NRefactory AST problems while doing refactorings ... and I only
</I>&gt;<i> did very simple AST analyzation.
</I>&gt;<i>
</I>&gt;<i> Regards
</I>&gt;<i> Mike
</I>&gt;<i>
</I>&gt;<i>
</I>
The new DOM is quite familiar to me now. I think this would be a good
project because not only will it allow me to create a useful tool, but
it can provide a good test case and feedback regarding the new DOM.
Also, I plan to refactor the metrics addin to use the new DOM as soon
as it becomes 100% stable.

Regards
Nikhil Sarda
</PRE>













<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011544.html">[MonoDevelop] Code analysis soc project
</A></li>
	<LI>Next message: <A HREF="011561.html">[MonoDevelop] Code analysis soc project
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11553">[ date ]</a>
              <a href="thread.html#11553">[ thread ]</a>
              <a href="subject.html#11553">[ subject ]</a>
              <a href="author.html#11553">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-list">More information about the Monodevelop-list
mailing list</a><br>
</body></html>
