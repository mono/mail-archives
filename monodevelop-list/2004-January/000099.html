<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] RE:more compilation problems
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:bjennin1%40san.rr.com">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000100.html">
   <LINK REL="Next"  HREF="000101.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] RE:more compilation problems
   </H1>
    <B>Blair Jennings
    </B> 
    <A HREF="mailto:bjennin1%40san.rr.com"
       TITLE="[MonoDevelop] RE:more compilation problems">bjennin1@san.rr.com
       </A><BR>
    <I>Wed, 21 Jan 2004 13:37:36 -0800</I>
    <P><UL>
        <LI> Previous message: <A HREF="000100.html">[MonoDevelop] more compilation problems
</A></li>
        <LI> Next message: <A HREF="000101.html">[MonoDevelop] RE:more compilation problems
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#99">[ date ]</a>
              <a href="thread.html#99">[ thread ]</a>
              <a href="subject.html#99">[ subject ]</a>
              <a href="author.html#99">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.
--------------090601030603000909080208
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Here are the two main compile fixes. I came across these yesterday after 
doing a totally clean rebuild of my box (I have been out of town for the 
last week and a half). I checked the MenuItemCodon.cs against the .NET 
spec and the attribute was defined wrong (calling for as new char() is 
illegal in an attribute). The ConvertXml.cs issue is one of 
appropriateness the call in the one in the svn repository is .NET 
version 1.1 but mono 0.29 is still .NET 1.0 for the System.Xml.Xsl 
Namespace (I have confirmed this in the Ximian CVS for mcs).

Blair Jennings

--------------090601030603000909080208
Content-Type: text/plain;
 name=&quot;ConvertXml.cs&quot;
Content-Transfer-Encoding: 8bit
Content-Disposition: inline;
 filename=&quot;ConvertXml.cs&quot;

// &lt;file&gt;
//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt"/">prj:///doc/copyright.txt&quot;/</A>&gt;
//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt"/">prj:///doc/license.txt&quot;/</A>&gt;
//     &lt;owner name=&quot;Mike Krüger&quot; email=&quot;<A HREF="mailto:mike@icsharpcode.net">mike@icsharpcode.net</A>&quot;/&gt;
//     &lt;version value=&quot;$version&quot;/&gt;
// &lt;/file&gt;

using System;
using System.IO;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Xsl;
using System.Security;
using System.Security.Permissions;

namespace ICSharpCode.SharpDevelop.Internal.Project
{
	/// &lt;summary&gt;
	/// This class is used to convert xml files using xslt
	/// &lt;/summary&gt;
	public class ConvertXml
	{
		/// &lt;remarks&gt;
		/// The main module loads the three required input vars
		/// and performs the transform
		/// &lt;/remarks&gt;
		/// &lt;param name=&quot;args&quot;&gt;
		/// arg1 - the input file (preferably VS.NET .csproj)
		/// arg2 - path to XSL transform file
		/// arg3 - path to output file (preferably SD .prjx)
		/// &lt;/param&gt;
		public static void Convert(string inputFile, string xslPath, string outputFile)
		{
			Convert(inputFile, xslPath, outputFile, null);
		}
		public static void Convert(string inputFile, string xslPath, string outputFile, XsltArgumentList xsltArgList)
		{
			// Transform the file
			XmlReader reader = GetXML(inputFile);
			XmlReader oTransformed = TransformXmlToXml(reader, xslPath, xsltArgList);
			reader.Close();
			
			// Output results to file path
			XmlDocument myDoc = new XmlDocument();
			myDoc.Load(oTransformed);
			myDoc.Save(outputFile);
		}
		
		public static void Convert(string inputFile, XmlReader xslReader, string outputFile, XsltArgumentList xsltArgList)
		{
			// Transform the file
			XmlReader reader = GetXML(inputFile);
			XmlReader oTransformed = TransformXmlToXml(reader, xslReader, xsltArgList);
			reader.Close();
			
			// Output results to file path
			XmlDocument myDoc = new XmlDocument();
			myDoc.Load(oTransformed);
			myDoc.Save(outputFile);
		}

		public static string ConvertToString(string inputFile, string xslPath)
		{
			return ConvertToString(inputFile, xslPath, null);
		}
		
		public static string ConvertToString(string inputFile, string xslPath, XsltArgumentList xsltArgList)
		{
			// Transform the file
			XmlReader reader = GetXML(inputFile);
			XmlReader oTransformed = TransformXmlToXml(reader, xslPath, xsltArgList);
			reader.Close();
			
			// Output results to string
			XmlDocument myDoc = new XmlDocument();
			myDoc.Load(oTransformed);
			StringWriter sw = new StringWriter();
			myDoc.Save(sw);
			return sw.ToString();
		}
		
		public static string ConvertData(string inputXml, string xslPath, XsltArgumentList xsltArgList)
		{
			XmlReader reader = new XmlTextReader(new StringReader(inputXml));
			XmlReader oTransformed = TransformXmlToXml(reader, xslPath, xsltArgList);
			reader.Close();
			
			// Output results to string
			XmlDocument myDoc = new XmlDocument();
			myDoc.Load(oTransformed);
			StringWriter sw = new StringWriter();
			myDoc.Save(sw);
			return sw.ToString();
		}
		
		public static string ConvertData(string inputXml, XmlReader xslReader, XsltArgumentList xsltArgList)
		{
			XmlReader reader = new XmlTextReader(new StringReader(inputXml));
			XmlReader oTransformed = TransformXmlToXml(reader, xslReader, xsltArgList);
			reader.Close();
			
			// Output results to string
			XmlDocument myDoc = new XmlDocument();
			myDoc.Load(oTransformed);
			StringWriter sw = new StringWriter();
			myDoc.Save(sw);
			return sw.ToString();
		}
		
		public static XmlReader TransformXmlToXml(XmlReader oXML, string XSLPath, XsltArgumentList xsltArgList)
		{
			XslTransform xslt = new XslTransform();
			xslt.Load(XSLPath);
			
			XPathDocument inputData = new XPathDocument(oXML);
			xslt.XmlResolver = new XmlSecureResolver(new XmlUrlResolver(), new PermissionSet(PermissionState.Unrestricted));
			
			return xslt.Transform(inputData, xsltArgList);
		}
		
		public static XmlReader TransformXmlToXml(XmlReader oXML, XmlReader XSLReader, XsltArgumentList xsltArgList)
		{
			XslTransform xslt = new XslTransform();
			xslt.Load(XSLReader, new XmlSecureResolver(new XmlUrlResolver(), new PermissionSet(PermissionState.Unrestricted)), null);
			
			XPathDocument inputData = new XPathDocument(oXML);
			xslt.XmlResolver = new XmlSecureResolver(new XmlUrlResolver(), new PermissionSet(PermissionState.Unrestricted));
			return xslt.Transform(inputData, xsltArgList);
		}
		
		/// &lt;summary&gt;
		/// GetXML returns an XmlReader dependent on the contents
		/// of the passed input param.
		/// GetXML checks for the following conditions:
		/// blank string returns an empty XmlReader
		/// less-than at start assumes an XML file
		/// back-slash at start assumes UNC path
		/// otherwise, URL is assumed
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;strInput&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static XmlReader GetXML(string strInput)
		{
			// Check if string is blank
			if (strInput.Length == 0) {
				// Return the empty xml reader
				return new XmlTextReader(&quot;&quot;);
			} else {
					// Check if string starts with &quot;&lt;&quot;
					// If it does, it is an XML file
					if (strInput.Substring(0,1) == &quot;&lt;&quot;)
					{
						//String could be an xml file - load
						return new XmlTextReader(new StringReader(strInput));
					}
					else
						{
							// Assume this is a file path - return loaded XML
							return new XmlTextReader(strInput);
						}
				}
		}
	}
}

--------------090601030603000909080208
Content-Type: text/plain;
 name=&quot;MenuItemCodon.cs&quot;
Content-Transfer-Encoding: 8bit
Content-Disposition: inline;
 filename=&quot;MenuItemCodon.cs&quot;

// &lt;file&gt;
//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt"/">prj:///doc/copyright.txt&quot;/</A>&gt;
//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt"/">prj:///doc/license.txt&quot;/</A>&gt;
//     &lt;owner name=&quot;Mike Krüger&quot; email=&quot;<A HREF="mailto:mike@icsharpcode.net">mike@icsharpcode.net</A>&quot;/&gt;
//     &lt;version value=&quot;$version&quot;/&gt;
// &lt;/file&gt;

using System;
using System.Diagnostics;
using System.Collections;
using System.Reflection;
//using System.Windows.Forms;

using ICSharpCode.Core.Properties;
using ICSharpCode.Core.AddIns.Conditions;

using ICSharpCode.Core.Services;

using ICSharpCode.SharpDevelop.Services;
using ICSharpCode.SharpDevelop.Gui;
using ICSharpCode.SharpDevelop.Gui.Components;
using ICSharpCode.SharpDevelop.Commands;

namespace ICSharpCode.Core.AddIns.Codons
{
	[CodonName(&quot;MenuItem&quot;)]
	public class MenuItemCodon : AbstractCodon
	{
		[XmlMemberAttribute(&quot;label&quot;, IsRequired=true)]
		string label       = null;
		
		[XmlMemberAttribute(&quot;description&quot;)]
		string description = null;
		
		[XmlMemberArrayAttribute(&quot;shortcut&quot;,Separator='|')]
		string[] shortcut    = null;
		
		[XmlMemberAttribute(&quot;icon&quot;)]
		string icon        = null;
		
		[XmlMemberAttribute(&quot;link&quot;)]
		string link        = null;
		
		public string Link {
			get {
				return link;
			}
			set {
				link = value;
			}
		}
		
		public override bool HandleConditions {
			get {
				return true;
			}
		}
		
		public string Label {
			get {
				return label;
			}
			set {
				label = value;
			}
		}
		
		public string Description {
			get {
				return description;
			}
			set {
				description = value;
			}
		}
		
		public string Icon {
			get {
				return icon;
			}
			set {
				icon = value;
			}
		}
		
		public string[] Shortcut {
			get {
				return shortcut;
			}
			set {
				shortcut = value;
			}
		}
		
		/// &lt;summary&gt;
		/// Creates an item with the specified sub items. And the current
		/// Condition status for this item.
		/// &lt;/summary&gt;
		public override object BuildItem(object owner, ArrayList subItems, ConditionCollection conditions)
		{
			Gtk.MenuItem newItem = null;
			if (Label == &quot;-&quot;) {
				newItem = new SdMenuSeparator(conditions, owner);
			} else  if (Link != null) {
				newItem = new SdMenuCommand(conditions, null, Label,  Link.StartsWith(&quot;http&quot;) ? (IMenuCommand)new GotoWebSite(Link) : (IMenuCommand)new GotoLink(Link));
			} else {
				object o = null;
				if (Class != null) {
					o = AddIn.CreateObject(Class);
				}
				if (o != null) {
					if (o is IMenuCommand) {
						IMenuCommand menuCommand = (IMenuCommand)o;
						menuCommand.Owner = owner;
						if (o is ICheckableMenuCommand) {
							newItem = new SdMenuCheckBox(conditions, owner, Label, (ICheckableMenuCommand)menuCommand);
						} else {
							newItem = new SdMenuCommand(conditions, owner, Label, menuCommand);
						}
					} else if (o is ISubmenuBuilder) {
						return o;
					}
				}
			}
			if (newItem == null) {
				SdMenu newMenu = new SdMenu(conditions, owner, Label);
				if (subItems != null &amp;&amp; subItems.Count &gt; 0) {
					foreach (object item in subItems) {
						if (item != null) {
							newMenu.SubItems.Add(item);
						}
					}
				}
				newMenu.UpdateStatus ();
				newItem = newMenu;
			}
			Debug.Assert(newItem != null);
			
			if (Icon != null &amp;&amp; newItem is SdMenuCommand) {
				ResourceService resourceService = (ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
				((SdMenuCommand)newItem).Image = resourceService.GetImage(Icon, Gtk.IconSize.Menu);
			}
			
			if (newItem is SdMenuCommand) {
				((SdMenuCommand)newItem).Description = description;
			}
			
			if (Shortcut != null &amp;&amp; newItem is SdMenuCommand) {
				try {
					((SdMenuCommand)newItem).SetAccel (shortcut);
					//foreach (string key in this.shortcut) {
					//	((SdMenuCommand)newItem).Shortcut |= (System.Windows.Forms.Keys)Enum.Parse(typeof(System.Windows.Forms.Keys), key);
					//}
				} catch (Exception) {
					//((SdMenuCommand)newItem).Shortcut = System.Windows.Forms.Keys.None;
				}
			}
			//newItem.IsEnabled = true; //action != ConditionFailedAction.Disable;
			return newItem;
		}
	}
}

--------------090601030603000909080208--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000100.html">[MonoDevelop] more compilation problems
</A></li>
	<LI> Next message: <A HREF="000101.html">[MonoDevelop] RE:more compilation problems
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#99">[ date ]</a>
              <a href="thread.html#99">[ thread ]</a>
              <a href="subject.html#99">[ subject ]</a>
              <a href="author.html#99">[ author ]</a>
         </LI>
       </UL>
</body></html>
