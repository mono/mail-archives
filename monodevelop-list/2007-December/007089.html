<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] my work is almost done
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20my%20work%20is%20almost%20done&In-Reply-To=847483.41913.qm%40web90314.mail.mud.yahoo.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007068.html">
   <LINK REL="Next"  HREF="007071.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] my work is almost done</H1>
    <B>Lluis Sanchez</B> 
    <A HREF="mailto:monodevelop-list%40lists.ximian.com?Subject=%5BMonoDevelop%5D%20my%20work%20is%20almost%20done&In-Reply-To=847483.41913.qm%40web90314.mail.mud.yahoo.com"
       TITLE="[MonoDevelop] my work is almost done">lluis at ximian.com
       </A><BR>
    <I>Wed Dec 19 12:04:57 EST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="007068.html">[MonoDevelop] my work is almost done
</A></li>
        <LI>Next message: <A HREF="007071.html">[MonoDevelop] MonoDevelop branched
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7089">[ date ]</a>
              <a href="thread.html#7089">[ thread ]</a>
              <a href="subject.html#7089">[ subject ]</a>
              <a href="author.html#7089">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi!

Thanks for the patch. Here are some comments:

      * It is ok to use helper classes, but make them internal. Also all
        classes should start with uppercase.
      * In some cases there is an incorrect use of casing and
        whitespace. Take a look at
        <A HREF="http://www.mono-project.com/Coding_Guidelines.">http://www.mono-project.com/Coding_Guidelines.</A>
      * Always use 'int' instead of 'Int32'
      * The file has a mix of tab and space indents. Please use tabs for
        indentation.
      * The GetTextFromRegion method is not really needed. The same can
        be implemented in a more simple way:

        IEditableTextFile file = IdeApp.Workbench.ActiveDocument.GetContent &lt;IEditableTextFile&gt; ();
        int p1 = file.GetPositionFromLineColumn (region.BeginLine, region.BeginColumn);
        int p2 = file.GetPositionFromLineColumn (region.EndLine, region.EndColumn);
        string regionText = file.GetText (p1, p2);
        
      * You can also do the same for ExtractRegionFromFile.
      * Why 30000 in &quot;for (Int32 i = 2; i &lt; 30000; i++)&quot;? Use a &quot;while&quot;.
      * Remove commented code such as &quot;//sw.Close();&quot;. Those kind of
        comments should be removed from a patch.
      * Same for the Test() method. Please remove it.
      * We can't accept this kind of code in MonoDevelop.Ide:

        public static string[]GetNamespaces(IClass klass,String language)
        {
        	if(language.ToUpper()==&quot;C#&quot;)return helperClass.GetNamespacesInCSharp(klass);	
        	//		if(language.ToUpper()==&quot;VB&quot;)return helperClass.GetNamespacesInVB(klass);
        	else throw new Exception(&quot;language &quot;+language +&quot; is not suported&quot;);	
        }	
        
        If there is some operation which is specific to a language, it
        should be moved to the language binding. The same for
        GenerateUsings, GetHeareOfFile. Maybe it would be good to add
        the whole MoveTypeToFile operation to the IRefactorer interface,
        so that language bindings can fully implement it, instead of
        trying to split it in small language-specific operations.
        
      * There is no need to prefix your changes with //simion314. We can
        use svn to keep track of changes.
      * I don't understand why you remove the source file from the
        project. That's not necessary.

Lluis.

El dg 16 de 12 del 2007 a les 14:06 -0800, en/na Ploscariu Simion va
escriure:
&gt;<i> 
</I>&gt;<i> Hi all,this s my firs thing for MD ,i am just a
</I>&gt;<i> beginer but who wants to help you make this IDE
</I>&gt;<i> better.
</I>&gt;<i>  i am working to implement a method to move a class to
</I>&gt;<i> it's own file. The code is working but only for C# and
</I>&gt;<i> that is because i used some code already made and that
</I>&gt;<i> code does'not work in VB,at leats on my MD)( i made a
</I>&gt;<i> new entry in the menu to appear when you rightclick a
</I>&gt;<i> classand from there you can select to move that class
</I>&gt;<i> to it's own file)
</I>&gt;<i> Some posible problems:
</I>&gt;<i> 1. i read the class the data from the file not from
</I>&gt;<i> the editor  using a StreaReader and this mean that i
</I>&gt;<i> must save the file before starting the operation
</I>&gt;<i> 2. if the class has an xml comment this will be let
</I>&gt;<i> behing. I can make a test to see if there is a such
</I>&gt;<i> comment for c# and move it too(i used the IRegion
</I>&gt;<i> Region property of a IClass to get the data location
</I>&gt;<i> and maybe it will be betther to modify the code there
</I>&gt;<i> that the Region will contain the XML comments)
</I>&gt;<i> 3. i need a little help to place the string in the
</I>&gt;<i> menu in the catalog GettextCatalog , i belive that is
</I>&gt;<i> the best thing to do
</I>&gt;<i> 4.mybe it would be better do add an OK/Cancel dialog
</I>&gt;<i> before starting the operation and i am asking if MD
</I>&gt;<i> doesn't have such dialogs somewhere, i will need and a
</I>&gt;<i> Ok  dialog lik MessageBox from winforms
</I>&gt;<i> 5. maybe the code can be made more eficient or better
</I>&gt;<i> so if someone has somethme to analize it, i added a
</I>&gt;<i> class now named hellperClass where i put some
</I>&gt;<i> functions i need and my other entries in the code are
</I>&gt;<i> 2 methods one for adding the menu and other for the
</I>&gt;<i> method and i markthem with //simion314 to be easy to
</I>&gt;<i> find them 
</I>&gt;<i> 
</I>&gt;<i> I made my changes in place(lluis agreed).
</I>&gt;<i> The file is from MonoDevelop.Ide.Commands
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>       ____________________________________________________________________________________
</I>&gt;<i> Be a better friend, newshound, and 
</I>&gt;<i> know-it-all with Yahoo! Mobile.  Try it now.  <A HREF="http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ">http://mobile.yahoo.com/;_ylt=Ahu06i62sR8HDtDypao8Wcj9tAcJ</A> 
</I>&gt;<i> fitxer adjunt plain text document (RefactoryCommands.cs.txt),
</I>&gt;<i> &quot;2376211167-RefactoryCommands.cs.txt&quot;
</I>&gt;<i> //
</I>&gt;<i> // RefactoryCommands.cs
</I>&gt;<i> //
</I>&gt;<i> // Author:
</I>&gt;<i> //   Lluis Sanchez Gual
</I>&gt;<i> //
</I>&gt;<i> // Copyright (C) 2006 Novell, Inc (<A HREF="http://www.novell.com">http://www.novell.com</A>)
</I>&gt;<i> //
</I>&gt;<i> // Permission is hereby granted, free of charge, to any person obtaining
</I>&gt;<i> // a copy of this software and associated documentation files (the
</I>&gt;<i> // &quot;Software&quot;), to deal in the Software without restriction, including
</I>&gt;<i> // without limitation the rights to use, copy, modify, merge, publish,
</I>&gt;<i> // distribute, sublicense, and/or sell copies of the Software, and to
</I>&gt;<i> // permit persons to whom the Software is furnished to do so, subject to
</I>&gt;<i> // the following conditions:
</I>&gt;<i> // 
</I>&gt;<i> // The above copyright notice and this permission notice shall be
</I>&gt;<i> // included in all copies or substantial portions of the Software.
</I>&gt;<i> // 
</I>&gt;<i> // THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
</I>&gt;<i> // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
</I>&gt;<i> // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
</I>&gt;<i> // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
</I>&gt;<i> // LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
</I>&gt;<i> // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
</I>&gt;<i> // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</I>&gt;<i> //
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> using System;
</I>&gt;<i> using System.Text;
</I>&gt;<i> using System.CodeDom;
</I>&gt;<i> using System.Threading;
</I>&gt;<i> using System.IO;
</I>&gt;<i> 
</I>&gt;<i> using MonoDevelop.Core;
</I>&gt;<i> using MonoDevelop.Ide.Gui;
</I>&gt;<i> using MonoDevelop.Components.Commands;
</I>&gt;<i> using MonoDevelop.Projects;
</I>&gt;<i> using MonoDevelop.Projects.Text;
</I>&gt;<i> using MonoDevelop.Projects.Parser;
</I>&gt;<i> using MonoDevelop.Projects.Ambience;
</I>&gt;<i> using MonoDevelop.Ide.Gui.Content;
</I>&gt;<i> using MonoDevelop.Ide.Gui.Search;
</I>&gt;<i> using MonoDevelop.Projects.CodeGeneration;
</I>&gt;<i> using MonoDevelop.Ide.Gui.Dialogs;
</I>&gt;<i> 
</I>&gt;<i> namespace MonoDevelop.Ide.Commands
</I>&gt;<i> {
</I>&gt;<i> 	public class helperClass
</I>&gt;<i> 	{
</I>&gt;<i> 		
</I>&gt;<i> 		public static string ExtractTextFromRegion(IRegion Region,string tempfile)
</I>&gt;<i> 			{
</I>&gt;<i> return helperClass.ExtractRegionFromFile(Region.BeginLine,Region.BeginColumn,Region.EndLine,Region.EndColumn,Region.FileName,tempfile);
</I>&gt;<i> 			}
</I>&gt;<i> 		public static string GetTextFromRegion(IRegion Region)
</I>&gt;<i> 		{
</I>&gt;<i> 			return helperClass.GetTextFromRegion(Region.BeginLine,Region.BeginColumn,Region.EndLine,Region.EndColumn,Region.FileName);
</I>&gt;<i> 		}
</I>&gt;<i> 		public static String ExtractRegionFromFile(int BeginLine, int BeginColumn, int EndLine, int EndColumn, String FileName,String tempfile)
</I>&gt;<i>         {
</I>&gt;<i>             if (BeginColumn &lt; 1 || BeginLine &lt; 1 || EndColumn &lt; 1 || EndLine &lt; BeginLine)
</I>&gt;<i>             {
</I>&gt;<i>                 throw new ArgumentException(&quot;parameters that define the IRegion(line or column indexes are not valid) are invalid&quot;);
</I>&gt;<i>             }
</I>&gt;<i>             if (!System.IO.File.Exists(FileName))
</I>&gt;<i>             {
</I>&gt;<i>                 throw new ArgumentException(&quot;the file &quot; + FileName + &quot; doesn't exists&quot;);
</I>&gt;<i>             }
</I>&gt;<i>             String line = null;
</I>&gt;<i>             System.IO.StreamReader sr = null;
</I>&gt;<i>             System.IO.StreamWriter sw = null;
</I>&gt;<i>             try
</I>&gt;<i>             {
</I>&gt;<i>                 sr = new System.IO.StreamReader(FileName);
</I>&gt;<i>             }
</I>&gt;<i>             catch (Exception x)
</I>&gt;<i>             {
</I>&gt;<i>                 throw x;
</I>&gt;<i>             }
</I>&gt;<i>             //read all the lines before this region to move at the line with the region
</I>&gt;<i>             //TODO maybe find a more eficient way to do this
</I>&gt;<i> try{           
</I>&gt;<i> 			sw = new System.IO.StreamWriter(tempfile);
</I>&gt;<i> 			}
</I>&gt;<i> catch(Exception x)
</I>&gt;<i> 			{
</I>&gt;<i> throw new IOException(&quot;canot create file: &quot;+tempfile+&quot;  &quot;+x.Message);			
</I>&gt;<i> 			}			
</I>&gt;<i> 			if (BeginLine &gt; 1)
</I>&gt;<i>             {
</I>&gt;<i> 
</I>&gt;<i>                 for (Int32 i = 1; i &lt;= BeginLine - 1; i++)
</I>&gt;<i>                 {
</I>&gt;<i>                   line=sr.ReadLine();
</I>&gt;<i>                   if (line == null) throw new Exception(&quot;error unexpected end of file at line &quot; + i.ToString() + &quot; in fie &quot; + FileName);
</I>&gt;<i>                     sw.WriteLine(line);
</I>&gt;<i>                 }
</I>&gt;<i>             }
</I>&gt;<i>             //read the characters from the first line of the region before the begin column position
</I>&gt;<i>             if (BeginColumn &gt; 1)
</I>&gt;<i>             {//sw.WriteLine(&quot;the begin column is not 1&quot;);
</I>&gt;<i>                 
</I>&gt;<i>                 char[] text = new char[BeginColumn - 1];
</I>&gt;<i>                 sr.Read(text, 0, BeginColumn - 1);
</I>&gt;<i>                 
</I>&gt;<i>                     sw.Write(text);
</I>&gt;<i>                
</I>&gt;<i>             }
</I>&gt;<i> 
</I>&gt;<i>             //now will get the text from the region
</I>&gt;<i>             System.Text.StringBuilder sb = new System.Text.StringBuilder(1000);//i used a big value to prevent the resize of the String Buillder
</I>&gt;<i>             if (BeginLine == EndLine)
</I>&gt;<i>             {
</I>&gt;<i>                 //sw.WriteLine(&quot;the region has only 1 line&quot;);
</I>&gt;<i>                 char[] text = new char[EndColumn - BeginColumn + 1]; ;
</I>&gt;<i>                 sr.Read(text, 0, EndColumn - BeginColumn + 1);
</I>&gt;<i>                 sb.Append(text);
</I>&gt;<i>                 sw.Write(sr.ReadToEnd());
</I>&gt;<i>                 sr.Close();
</I>&gt;<i>                 sw.Close();
</I>&gt;<i>                 return sb.ToString();
</I>&gt;<i>             }
</I>&gt;<i>             else//if  beginline &lt;EndLine
</I>&gt;<i>             { //read the first line from the BeginColumn
</I>&gt;<i>                 //sw.Write(Environment.NewLine);
</I>&gt;<i>                 line = sr.ReadLine();
</I>&gt;<i>                 if (line == null) throw new Exception(&quot;unexpected end of file in file : &quot; + FileName+ &quot;at line : &quot;+BeginLine.ToString());
</I>&gt;<i>                 sb.Append(line + System.Environment.NewLine);
</I>&gt;<i>                 
</I>&gt;<i>                 //read the rest of the lines except the last one
</I>&gt;<i>                 if (EndLine - BeginLine &gt; 2)
</I>&gt;<i>                 {//if the region has more then 2 lines
</I>&gt;<i>                     		
</I>&gt;<i>                     for (Int32 i = BeginLine + 1; i &lt;= EndLine - 1; i++)
</I>&gt;<i>                     {
</I>&gt;<i>                         line = sr.ReadLine(); if (line == null) throw new Exception(&quot;unexpected end of file in file : &quot; + FileName+&quot;at line: &quot;+i.ToString());
</I>&gt;<i>                         sb.Append(line + System.Environment.NewLine);
</I>&gt;<i>                     }
</I>&gt;<i>                 }
</I>&gt;<i>                 //add the last line
</I>&gt;<i>                 char[] text = new char[EndColumn];
</I>&gt;<i>                 sr.Read(text, 0, EndColumn);
</I>&gt;<i>                 sb.Append(text);
</I>&gt;<i>                 sb.Append(System.Environment.NewLine);
</I>&gt;<i> 
</I>&gt;<i>                 //reading the rest of the file in the temp file
</I>&gt;<i>                 sw.Write(sr.ReadToEnd());
</I>&gt;<i>                 sw.Close();
</I>&gt;<i>                 sr.Close();			
</I>&gt;<i>                 return sb.ToString();
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i> public static string DetermineValidFileName(string originalname, string classname)
</I>&gt;<i>         {
</I>&gt;<i>             string dir;
</I>&gt;<i>            dir= Path.GetDirectoryName(originalname);
</I>&gt;<i>            string name;
</I>&gt;<i>             string ext;
</I>&gt;<i>             ext=Path.GetExtension(originalname);
</I>&gt;<i>             name = dir + Path.DirectorySeparatorChar  +classname+ ext;
</I>&gt;<i>             if (File.Exists(name))
</I>&gt;<i>             {
</I>&gt;<i>                 for (Int32 i = 2; i &lt; 30000; i++)
</I>&gt;<i>                 {
</I>&gt;<i>                     name = dir + Path.DirectorySeparatorChar + classname + i.ToString() + ext;
</I>&gt;<i>                     if (!File.Exists(name)) return name;
</I>&gt;<i>                 }
</I>&gt;<i>                 throw new Exception(&quot;can't create the filename, can't generate a valid name&quot;);
</I>&gt;<i>             }
</I>&gt;<i>             else 
</I>&gt;<i>             {
</I>&gt;<i>                 return name;
</I>&gt;<i>             }
</I>&gt;<i>         }
</I>&gt;<i>        
</I>&gt;<i> 		public static string GetTextFromRegion(int BeginLine,int BeginColumn,int EndLine,int EndColumn,String FileName)
</I>&gt;<i> 		{
</I>&gt;<i> 			if(BeginColumn&lt;1||BeginLine&lt;1||EndColumn&lt;1||EndLine&lt;BeginLine)
</I>&gt;<i> 			{
</I>&gt;<i> throw new ArgumentException(&quot;parameters that define the IRegion(line or column indexes are not valid) are invalid&quot;);			
</I>&gt;<i> 			}
</I>&gt;<i> 			if(!System.IO.File.Exists(FileName))
</I>&gt;<i> 			   {
</I>&gt;<i> throw new ArgumentException(&quot;the file &quot;+FileName+&quot; doesn't exists&quot;);			
</I>&gt;<i> 			}
</I>&gt;<i> 			System.IO.StreamReader sr=null;
</I>&gt;<i> 			try{
</I>&gt;<i> 		 sr=new System.IO.StreamReader(FileName);
</I>&gt;<i> 			}catch(Exception x)
</I>&gt;<i> 			{
</I>&gt;<i> throw x;	
</I>&gt;<i> 			}		
</I>&gt;<i> 			//read all the lines before this region to move at the line with the region
</I>&gt;<i> 			//TODO maybe find a more eficient way to do this
</I>&gt;<i> 			if(BeginLine&gt;1)
</I>&gt;<i> 			{
</I>&gt;<i> 				//sw.WriteLine(&quot;the begin line is not the first line&quot;);
</I>&gt;<i> 		for(Int32 i=1;i&lt;=BeginLine-1;i++)
</I>&gt;<i> 				{
</I>&gt;<i> 				sr.ReadLine();
</I>&gt;<i> 				//	sw.WriteLine(&quot;Read the line numer  &quot;+i.ToString());
</I>&gt;<i> 				}					
</I>&gt;<i> 			}
</I>&gt;<i> 			//read the characters from the first line of the region before the begin column position
</I>&gt;<i> 			if(BeginColumn&gt;1)
</I>&gt;<i> 			{//sw.WriteLine(&quot;the begin column is not 1&quot;);
</I>&gt;<i> 			for(Int32 i=1;i&lt;=BeginColumn-1;i++)
</I>&gt;<i> 				{
</I>&gt;<i> 					//sw.WriteLine(&quot;Read the  character number  &quot;+i.ToString());
</I>&gt;<i> 				sr.Read();//maybe here i can use an overload that can read more then one character
</I>&gt;<i> 				}	
</I>&gt;<i> 			}
</I>&gt;<i> 			
</I>&gt;<i> 			//now will get the text from the region
</I>&gt;<i> System.Text.StringBuilder sb=new System.Text.StringBuilder(1000);//i used a big value to prevent the resize of the String Buillder
</I>&gt;<i> 			if(BeginLine==EndLine)
</I>&gt;<i> 			{
</I>&gt;<i> 				//sw.WriteLine(&quot;the region has only 1 line&quot;);
</I>&gt;<i> 				char[] text=new char[EndColumn-BeginColumn+1];;
</I>&gt;<i> 				sr.Read( text,0,EndColumn-BeginColumn+1);
</I>&gt;<i> sb.Append(text);			
</I>&gt;<i> sr.Close();				
</I>&gt;<i> 				//sw.Close();
</I>&gt;<i> 				return sb.ToString();
</I>&gt;<i> 			}
</I>&gt;<i> 			else//the beginline &lt;EndLine
</I>&gt;<i> 			{ //read the first line from the BeginColumn
</I>&gt;<i> 				//sw.WriteLine(&quot;the region has more then 1 line&quot;);
</I>&gt;<i> 				
</I>&gt;<i> sb.Append(sr.ReadLine()+System.Environment.NewLine);
</I>&gt;<i> 				//sw.WriteLine(&quot;read the first line&quot;);
</I>&gt;<i> 				//read the rest of the lines except the last one
</I>&gt;<i> 				if(EndLine-BeginLine&gt;2)
</I>&gt;<i> 				{//if the region has more then 2 lines
</I>&gt;<i> //sw.WriteLine(&quot;we have more then 2 lines&quot;);			
</I>&gt;<i> 					for(Int32 i=BeginLine+1;i&lt;=EndLine-1;i++)
</I>&gt;<i> 				{
</I>&gt;<i> 						
</I>&gt;<i> sb.Append(sr.ReadLine()+System.Environment.NewLine);				
</I>&gt;<i> 				}
</I>&gt;<i> 				}
</I>&gt;<i> 					//add the last line
</I>&gt;<i> 					char[] text=new char[EndColumn];
</I>&gt;<i> 					sr.Read(text,0,EndColumn);
</I>&gt;<i> 					sb.Append(text);
</I>&gt;<i> 					sb.Append(System.Environment.NewLine);
</I>&gt;<i> 			sr.Close();
</I>&gt;<i> //sw.Close();			
</I>&gt;<i> 				return sb.ToString();
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 		public static string[]GetNamespaces(IClass klass,String language)
</I>&gt;<i> 		{
</I>&gt;<i> if(language.ToUpper()==&quot;C#&quot;)return helperClass.GetNamespacesInCSharp(klass);	
</I>&gt;<i> 	//		if(language.ToUpper()==&quot;VB&quot;)return helperClass.GetNamespacesInVB(klass);
</I>&gt;<i> else throw new Exception(&quot;language &quot;+language +&quot; is not suported&quot;);	}	
</I>&gt;<i> 		
</I>&gt;<i> 			private static string[] GetNamespacesInCSharp(IClass klass)
</I>&gt;<i> 			 {
</I>&gt;<i> 			 string[] result=new string[2];
</I>&gt;<i> 		result[0]=&quot;namespace &quot;+	klass.Namespace+&quot; { &quot;+Environment.NewLine;
</I>&gt;<i> 			result[1]=&quot;}&quot;;
</I>&gt;<i> 			return result;
</I>&gt;<i> 			 }
</I>&gt;<i> 			private static string[] GetNamespacesInVB(IClass klass)
</I>&gt;<i> 			 {
</I>&gt;<i> 			 string[] result=new string[2];
</I>&gt;<i> 		result[0]=&quot;Namespace &quot;+	klass.Namespace+Environment.NewLine;
</I>&gt;<i> 			result[1]=&quot;End Namespace&quot;;
</I>&gt;<i> 			return result;
</I>&gt;<i> 			 }
</I>&gt;<i> 		public static string GenerateUsings(MonoDevelop.Projects.Parser.IUsingCollection usings,string language)
</I>&gt;<i> 		{
</I>&gt;<i> 			if(language.ToUpper()==&quot;C#&quot;)return GenerateCSharpUsings(usings);
</I>&gt;<i> 		//	if(language.ToUpper()==&quot;VB&quot;) return GenerateVbUsings(usings);
</I>&gt;<i> 			else throw new Exception(&quot;language &quot;+language +&quot; is not suported&quot;);
</I>&gt;<i> 		}
</I>&gt;<i> private static string GenerateCSharpUsings(MonoDevelop.Projects.Parser.IUsingCollection usings)
</I>&gt;<i> 		{
</I>&gt;<i> 		if(usings==null)
</I>&gt;<i> 			{
</I>&gt;<i> throw new ArgumentNullException(&quot;the IUsingCollection is null&quot;);			
</I>&gt;<i> 			}
</I>&gt;<i> 			if(usings.Count==0)
</I>&gt;<i> 			{
</I>&gt;<i> 			return string.Empty;
</I>&gt;<i> 			}
</I>&gt;<i> 			System.Text.StringBuilder sb=new System.Text.StringBuilder();
</I>&gt;<i> 			for(int i=0;i&lt;usings.Count;i++)
</I>&gt;<i> 			{
</I>&gt;<i> 			System.Collections.Generic.IEnumerator&lt;string&gt; ie=	usings[i].Usings.GetEnumerator();
</I>&gt;<i>                 
</I>&gt;<i> 			while(	ie.MoveNext()){
</I>&gt;<i> 				Console.WriteLine(ie.Current);
</I>&gt;<i> sb.Append(&quot;using &quot;+ie.Current+&quot;;&quot;+System.Environment.NewLine);				
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 			return sb.ToString();
</I>&gt;<i> 		}		
</I>&gt;<i> 	
</I>&gt;<i> private static string GenerateVbUsings(MonoDevelop.Projects.Parser.IUsingCollection usings)
</I>&gt;<i> 		{
</I>&gt;<i> 		if(usings==null)
</I>&gt;<i> 			{
</I>&gt;<i> throw new ArgumentNullException(&quot;the IUsingCollection is null&quot;);			
</I>&gt;<i> 			}
</I>&gt;<i> 			if(usings.Count==0)
</I>&gt;<i> 			{
</I>&gt;<i> 			return string.Empty;
</I>&gt;<i> 			}
</I>&gt;<i> 			System.Text.StringBuilder sb=new System.Text.StringBuilder();
</I>&gt;<i> 			for(int i=0;i&lt;usings.Count;i++)
</I>&gt;<i> 			{
</I>&gt;<i> 			System.Collections.Generic.IEnumerator&lt;string&gt; ie=	usings[i].Usings.GetEnumerator();
</I>&gt;<i>                 
</I>&gt;<i> 			while(	ie.MoveNext()){
</I>&gt;<i> 				Console.WriteLine(ie.Current);
</I>&gt;<i> sb.Append(&quot;import &quot;+ie.Current+System.Environment.NewLine);				
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 			return sb.ToString();
</I>&gt;<i> 		}		
</I>&gt;<i> 		public static string GetHeareOfFile(string language)
</I>&gt;<i> 		{
</I>&gt;<i> 			if(language.ToUpper()==&quot;C#&quot;)
</I>&gt;<i> 				return &quot;//this file was generated by MonoDevelop in function MoveFunctionToSeparateFile&quot;;
</I>&gt;<i> 			else throw new Exception(&quot;Language &quot;+language.ToUpper()+&quot; is not suported&quot;);
</I>&gt;<i> 		}
</I>&gt;<i> 		public static void Test()
</I>&gt;<i> 		{
</I>&gt;<i> String FileName=&quot;/home/simi/hf.txt&quot;;	
</I>&gt;<i> //System.Text.StringBuilder sb=new System.Text.StringBuilder();
</I>&gt;<i> String classDesc=null;	
</I>&gt;<i> 			int bl,bc,el,ec;
</I>&gt;<i> 			bl=bc=1;
</I>&gt;<i> 			el=10;
</I>&gt;<i> 			ec=10;
</I>&gt;<i> 			try{
</I>&gt;<i> 		classDesc=helperClass.GetTextFromRegion(bl,bc,el,ec,FileName);
</I>&gt;<i> 			}catch(Exception x)
</I>&gt;<i> 			{
</I>&gt;<i> Console.WriteLine(&quot;eroare functia geteext&quot;+x.Message);			
</I>&gt;<i> 			}if(classDesc==null)
</I>&gt;<i> 			{
</I>&gt;<i> Console.WriteLine(&quot;Sb is null&quot;);		
</I>&gt;<i> 				return;
</I>&gt;<i> 			}
</I>&gt;<i> 			Console.Write(classDesc);
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> 
</I>&gt;<i> 	public enum RefactoryCommands
</I>&gt;<i> 	{
</I>&gt;<i> 		CurrentRefactoryOperations
</I>&gt;<i> 	}
</I>&gt;<i> 	
</I>&gt;<i> 	public class CurrentRefactoryOperationsHandler: CommandHandler
</I>&gt;<i> 	{
</I>&gt;<i> 		protected override void Run (object data)
</I>&gt;<i> 		{
</I>&gt;<i> 			RefactoryOperation del = (RefactoryOperation) data;
</I>&gt;<i> 			if (del != null)
</I>&gt;<i> 				del ();
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		protected override void Update (CommandArrayInfo ainfo)
</I>&gt;<i> 		{
</I>&gt;<i> 			Document doc = IdeApp.Workbench.ActiveDocument;
</I>&gt;<i> 			if (doc != null &amp;&amp; doc.FileName != null) {
</I>&gt;<i> 				ITextBuffer editor = IdeApp.Workbench.ActiveDocument.GetContent &lt;ITextBuffer&gt;();
</I>&gt;<i> 				if (editor != null) {
</I>&gt;<i> 					bool added = false;
</I>&gt;<i> 					int line, column;
</I>&gt;<i> 					
</I>&gt;<i> 					editor.GetLineColumnFromPosition (editor.CursorPosition, out line, out column);
</I>&gt;<i> 					IParseInformation pinfo;
</I>&gt;<i> 					IParserContext ctx;
</I>&gt;<i> 					if (doc.Project != null) {
</I>&gt;<i> 						ctx = IdeApp.ProjectOperations.ParserDatabase.GetProjectParserContext (doc.Project);
</I>&gt;<i> 						pinfo = IdeApp.ProjectOperations.ParserDatabase.UpdateFile (doc.Project, doc.FileName, editor.Text);
</I>&gt;<i> 					} else {
</I>&gt;<i> 						ctx = IdeApp.ProjectOperations.ParserDatabase.GetFileParserContext (doc.FileName);
</I>&gt;<i> 						pinfo = IdeApp.ProjectOperations.ParserDatabase.UpdateFile (doc.FileName, editor.Text);
</I>&gt;<i> 					}
</I>&gt;<i> 					
</I>&gt;<i> 					// Look for an identifier at the cursor position
</I>&gt;<i> 					
</I>&gt;<i> 					string id = editor.SelectedText;
</I>&gt;<i> 					if (id.Length == 0) {
</I>&gt;<i> 						IExpressionFinder finder = Services.ParserService.GetExpressionFinder (editor.Name);
</I>&gt;<i> 						if (finder == null)
</I>&gt;<i> 							return;
</I>&gt;<i> 						id = finder.FindFullExpression (editor.Text, editor.CursorPosition).Expression;
</I>&gt;<i> 						if (id == null) return;
</I>&gt;<i> 					}
</I>&gt;<i> 					
</I>&gt;<i> 					ILanguageItem item = ctx.ResolveIdentifier (id, line, column, editor.Name, null);
</I>&gt;<i> 					ILanguageItem eitem = ctx.GetEnclosingLanguageItem (line, column, editor);
</I>&gt;<i> 					
</I>&gt;<i> 					if (item != null &amp;&amp; eitem != null &amp;&amp; eitem.Name == item.Name &amp;&amp; !(eitem is IProperty) &amp;&amp; !(eitem is IMethod)) {
</I>&gt;<i> 						// If this occurs, then @item is the base-class version of @eitem
</I>&gt;<i> 						// in which case we don't want to show the base-class @item, we'd
</I>&gt;<i> 						// rather show the item the user /actually/ requested, @eitem.
</I>&gt;<i> 						item = eitem;
</I>&gt;<i> 						eitem = null;
</I>&gt;<i> 					}
</I>&gt;<i> 					
</I>&gt;<i> 					IClass eclass = null;
</I>&gt;<i> 					
</I>&gt;<i> 					if (item is IClass) {
</I>&gt;<i> 						if (((IClass) item).ClassType == ClassType.Interface)
</I>&gt;<i> 							eclass = FindEnclosingClass (ctx, editor.Name, line, column);
</I>&gt;<i> 						else
</I>&gt;<i> 							eclass = (IClass) item;
</I>&gt;<i> 					}
</I>&gt;<i> 					
</I>&gt;<i> 					while (item != null) {
</I>&gt;<i> 						CommandInfo ci;
</I>&gt;<i> 						
</I>&gt;<i> 						// Add the selected item
</I>&gt;<i> 						if ((ci = BuildRefactoryMenuForItem (ctx, pinfo, eclass, item)) != null) {
</I>&gt;<i> 							ainfo.Add (ci, null);
</I>&gt;<i> 							added = true;
</I>&gt;<i> 						}
</I>&gt;<i> 						
</I>&gt;<i> 						if (item is IParameter) {
</I>&gt;<i> 							// Add the encompasing method for the previous item in the menu
</I>&gt;<i> 							item = ((IParameter) item).DeclaringMember;
</I>&gt;<i> 							if (item != null &amp;&amp; (ci = BuildRefactoryMenuForItem (ctx, pinfo, null, item)) != null) {
</I>&gt;<i> 								ainfo.Add (ci, null);
</I>&gt;<i> 								added = true;
</I>&gt;<i> 							}
</I>&gt;<i> 						}
</I>&gt;<i> 						
</I>&gt;<i> 						if (item is IMember &amp;&amp; !(eitem != null &amp;&amp; eitem is IMember)) {
</I>&gt;<i> 							// Add the encompasing class for the previous item in the menu
</I>&gt;<i> 							item = ((IMember) item).DeclaringType;
</I>&gt;<i> 							if (item != null &amp;&amp; (ci = BuildRefactoryMenuForItem (ctx, pinfo, null, item)) != null) {
</I>&gt;<i> 								ainfo.Add (ci, null);
</I>&gt;<i> 								added = true;
</I>&gt;<i> 							}
</I>&gt;<i> 						}
</I>&gt;<i> 						
</I>&gt;<i> 						item = eitem;
</I>&gt;<i> 						eitem = null;
</I>&gt;<i> 						eclass = null;
</I>&gt;<i> 					}
</I>&gt;<i> 					
</I>&gt;<i> 					if (added)
</I>&gt;<i> 						ainfo.AddSeparator ();
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		// public class Funkadelic : IAwesomeSauce, IRockOn { ...
</I>&gt;<i> 		//        ----------------   -------------
</I>&gt;<i> 		// finds this ^ if you clicked on this ^
</I>&gt;<i> 		IClass FindEnclosingClass (IParserContext ctx, string fileName, int line, int col)
</I>&gt;<i> 		{
</I>&gt;<i> 			IClass [] classes = ctx.GetFileContents (fileName);
</I>&gt;<i> 			IClass klass = null;
</I>&gt;<i> 			
</I>&gt;<i> 			if (classes == null)
</I>&gt;<i> 				return null;
</I>&gt;<i> 			
</I>&gt;<i> 			for (int i = 0; i &lt; classes.Length; i++) {
</I>&gt;<i> 				if ((line &gt; classes[i].Region.BeginLine ||
</I>&gt;<i> 				     (line == classes[i].Region.BeginLine &amp;&amp; col &gt;= classes[i].Region.BeginColumn)) &amp;&amp;
</I>&gt;<i> 				    (line &lt; classes[i].Region.EndLine ||
</I>&gt;<i> 				     (line == classes[i].Region.EndLine &amp;&amp; col &lt;= classes[i].Region.EndColumn))) {
</I>&gt;<i> 					klass = classes[i];
</I>&gt;<i> 					break;
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 			
</I>&gt;<i> 			if (klass != null &amp;&amp; klass.ClassType != ClassType.Interface)
</I>&gt;<i> 				return klass;
</I>&gt;<i> 			
</I>&gt;<i> 			return null;
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		string EscapeName (string name)
</I>&gt;<i> 		{
</I>&gt;<i> 			if (name.IndexOf ('_') == -1)
</I>&gt;<i> 				return name;
</I>&gt;<i> 			
</I>&gt;<i> 			StringBuilder sb = new StringBuilder ();
</I>&gt;<i> 			for (int i = 0; i &lt; name.Length; i++) {
</I>&gt;<i> 				if (name[i] == '_')
</I>&gt;<i> 					sb.Append ('_');
</I>&gt;<i> 				sb.Append (name[i]);
</I>&gt;<i> 			}
</I>&gt;<i> 			
</I>&gt;<i> 			return sb.ToString ();
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		CommandInfo BuildRefactoryMenuForItem (IParserContext ctx, IParseInformation pinfo, IClass eclass, ILanguageItem item)
</I>&gt;<i> 		{
</I>&gt;<i> 			Refactorer refactorer = new Refactorer (ctx, pinfo, eclass, item, null);
</I>&gt;<i> 			CommandInfoSet ciset = new CommandInfoSet ();
</I>&gt;<i> 			Ambience ambience = null;
</I>&gt;<i> 			Project project = IdeApp.Workbench.ActiveDocument.Project;
</I>&gt;<i> 			if (project != null) {
</I>&gt;<i> 				ambience = project.Ambience;
</I>&gt;<i> 			} else 
</I>&gt;<i> 				ambience = new NetAmbience ();
</I>&gt;<i> 			string itemName = EscapeName (ambience.Convert (item, ConversionFlags.ShowGenericParameters | ConversionFlags.IncludeHTMLMarkup));
</I>&gt;<i> 			bool canRename = false;
</I>&gt;<i> 			string txt;
</I>&gt;<i> 			if (IdeApp.ProjectOperations.CanJumpToDeclaration (item))
</I>&gt;<i> 				ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;_Go to declaration&quot;), new RefactoryOperation (refactorer.GoToDeclaration));
</I>&gt;<i> 			
</I>&gt;<i> 			if ((item is IMember) &amp;&amp; !(item is IClass))
</I>&gt;<i> 				ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;_Find references&quot;), new RefactoryOperation (refactorer.FindReferences));
</I>&gt;<i> 			
</I>&gt;<i> 			// We can rename local variables (always), method params (always), 
</I>&gt;<i> 			// or class/members (if they belong to a project)
</I>&gt;<i> 			if ((item is LocalVariable) || (item is IParameter))
</I>&gt;<i> 				canRename = true;
</I>&gt;<i> 			else if (item is IClass)
</I>&gt;<i> 				canRename = ((IClass) item).SourceProject != null;
</I>&gt;<i> 			else if (item is IMember) {
</I>&gt;<i> 				IClass cls = ((IMember) item).DeclaringType;
</I>&gt;<i> 				canRename = cls != null &amp;&amp; cls.SourceProject != null;
</I>&gt;<i> 			}
</I>&gt;<i> 			
</I>&gt;<i> 			if (canRename &amp;&amp; !(item is IClass)) {
</I>&gt;<i> 				// Defer adding this item for Classes until later
</I>&gt;<i> 				ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;_Rename&quot;), new RefactoryOperation (refactorer.Rename));
</I>&gt;<i> 			}
</I>&gt;<i> 
</I>&gt;<i> 			if (item is IClass) {
</I>&gt;<i> 				IClass cls = (IClass) item;
</I>&gt;<i> 				
</I>&gt;<i> 				if (cls.ClassType == ClassType.Enum)
</I>&gt;<i> 					txt = GettextCatalog.GetString (&quot;Enum &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 				else if (cls.ClassType == ClassType.Struct)
</I>&gt;<i> 					txt = GettextCatalog.GetString (&quot;Struct &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 				else if (cls.ClassType == ClassType.Interface)
</I>&gt;<i> 					txt = GettextCatalog.GetString (&quot;Interface &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 				else
</I>&gt;<i> 					txt = GettextCatalog.GetString (&quot;Class &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 				
</I>&gt;<i> 				if (cls.BaseTypes.Count &gt; 0 &amp;&amp; cls.ClassType == ClassType.Class) {
</I>&gt;<i> 					foreach (IReturnType rt in cls.BaseTypes) {
</I>&gt;<i> 						IClass bc = ctx.GetClass (rt.FullyQualifiedName, null, true, true);
</I>&gt;<i> 						if (bc != null &amp;&amp; bc.ClassType != ClassType.Interface &amp;&amp; IdeApp.ProjectOperations.CanJumpToDeclaration (bc)) {
</I>&gt;<i> 							ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;Go to _base&quot;), new RefactoryOperation (refactorer.GoToBase));
</I>&gt;<i> 							break;
</I>&gt;<i> 						}
</I>&gt;<i> 					}
</I>&gt;<i> 				}
</I>&gt;<i> 				
</I>&gt;<i> 				
</I>&gt;<i> 				if ((cls.ClassType == ClassType.Class &amp;&amp; !cls.IsSealed) || cls.ClassType == ClassType.Interface)
</I>&gt;<i> 					ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;Find _derived classes&quot;), new RefactoryOperation (refactorer.FindDerivedClasses));
</I>&gt;<i> 				
</I>&gt;<i> 				ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;_Find references&quot;), new RefactoryOperation (refactorer.FindReferences));
</I>&gt;<i> 				
</I>&gt;<i> 				if (canRename)
</I>&gt;<i> 					ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;_Rename&quot;), new RefactoryOperation (refactorer.Rename));
</I>&gt;<i> 				
</I>&gt;<i> 
</I>&gt;<i> //simion314
</I>&gt;<i> 					
</I>&gt;<i> 				ciset.CommandInfos.Add(&quot;Move to separate file&quot;,new 	RefactoryOperation (refactorer.MoveClassToFile));				
</I>&gt;<i> 				
</I>&gt;<i> 				
</I>&gt;<i> 				if (canRename &amp;&amp; cls.ClassType == ClassType.Interface &amp;&amp; eclass != null) {
</I>&gt;<i> 					// An interface is selected, so just need to provide these 2 submenu items
</I>&gt;<i> 					ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;Implement Interface (implicit)&quot;), new RefactoryOperation (refactorer.ImplementImplicitInterface));
</I>&gt;<i> 					ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;Implement Interface (explicit)&quot;), new RefactoryOperation (refactorer.ImplementExplicitInterface));
</I>&gt;<i> 				} else if (canRename &amp;&amp; cls.BaseTypes.Count &gt; 0 &amp;&amp; cls.ClassType != ClassType.Interface &amp;&amp; cls == eclass) {
</I>&gt;<i> 				
</I>&gt;<i> 				
</I>&gt;<i> 					
</I>&gt;<i> 					
</I>&gt;<i> 					// Class might have interfaces... offer to implement them
</I>&gt;<i> 					CommandInfoSet impset = new CommandInfoSet ();
</I>&gt;<i> 					CommandInfoSet expset = new CommandInfoSet ();
</I>&gt;<i> 					bool added = false;
</I>&gt;<i> 					
</I>&gt;<i> 					foreach (IReturnType rt in cls.BaseTypes) {
</I>&gt;<i> 						IClass iface = ctx.GetClass (rt.FullyQualifiedName, rt.GenericArguments, true, true);
</I>&gt;<i> 						if (iface != null &amp;&amp; iface.ClassType == ClassType.Interface) {
</I>&gt;<i> 							Refactorer ifaceRefactorer = new Refactorer (ctx, pinfo, cls, iface, rt);
</I>&gt;<i> 							impset.CommandInfos.Add (ambience.Convert (rt, ConversionFlags.ShowGenericParameters), new RefactoryOperation (ifaceRefactorer.ImplementImplicitInterface));
</I>&gt;<i> 							expset.CommandInfos.Add (ambience.Convert (rt, ConversionFlags.ShowGenericParameters), new RefactoryOperation (ifaceRefactorer.ImplementExplicitInterface));
</I>&gt;<i> 							added = true;
</I>&gt;<i> 						}
</I>&gt;<i> 					}
</I>&gt;<i> 					
</I>&gt;<i> 					if (added) {
</I>&gt;<i> 						impset.Text = GettextCatalog.GetString (&quot;Implement Interface (implicit)&quot;);
</I>&gt;<i> 						ciset.CommandInfos.Add (impset, null);
</I>&gt;<i> 						
</I>&gt;<i> 						expset.Text = GettextCatalog.GetString (&quot;Implement Interface (explicit)&quot;);
</I>&gt;<i> 						ciset.CommandInfos.Add (expset, null);
</I>&gt;<i> 					}
</I>&gt;<i> 				}
</I>&gt;<i> 			} else if (item is IField) {
</I>&gt;<i> 				txt = GettextCatalog.GetString (&quot;Field &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 				if (canRename)
</I>&gt;<i> 					ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;Encapsulate Field&quot;), new RefactoryOperation (refactorer.EncapsulateField));
</I>&gt;<i> 				AddRefactoryMenuForClass (ctx, pinfo, ciset, ((IField) item).ReturnType.FullyQualifiedName);
</I>&gt;<i> 			} else if (item is IProperty) {
</I>&gt;<i> 				txt = GettextCatalog.GetString (&quot;Property &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 				AddRefactoryMenuForClass (ctx, pinfo, ciset, ((IProperty) item).ReturnType.FullyQualifiedName);
</I>&gt;<i> 			} else if (item is IEvent) {
</I>&gt;<i> 				txt = GettextCatalog.GetString (&quot;Event &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 			} else if (item is IMethod) {
</I>&gt;<i> 				IMethod method = item as IMethod;
</I>&gt;<i> 				
</I>&gt;<i> 				if (method.IsConstructor) {
</I>&gt;<i> 					txt = GettextCatalog.GetString (&quot;Constructor &lt;b&gt;{0}&lt;/b&gt;&quot;, EscapeName (method.DeclaringType.Name));
</I>&gt;<i> 				} else {
</I>&gt;<i> 					txt = GettextCatalog.GetString (&quot;Method &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 					if (method.IsOverride) 
</I>&gt;<i> 						ciset.CommandInfos.Add (GettextCatalog.GetString (&quot;Go to _base&quot;), new RefactoryOperation (refactorer.GoToBase));
</I>&gt;<i> 				}
</I>&gt;<i> 			} else if (item is IIndexer) {
</I>&gt;<i> 				txt = GettextCatalog.GetString (&quot;Indexer &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 			} else if (item is IParameter) {
</I>&gt;<i> 				txt = GettextCatalog.GetString (&quot;Parameter &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 				AddRefactoryMenuForClass (ctx, pinfo, ciset, ((IParameter) item).ReturnType.FullyQualifiedName);
</I>&gt;<i> 			} else if (item is LocalVariable) {
</I>&gt;<i> 				LocalVariable var = (LocalVariable) item;
</I>&gt;<i> 				AddRefactoryMenuForClass (ctx, pinfo, ciset, var.ReturnType.FullyQualifiedName);
</I>&gt;<i> 				txt = GettextCatalog.GetString (&quot;Variable &lt;b&gt;{0}&lt;/b&gt;&quot;, itemName);
</I>&gt;<i> 			} else {
</I>&gt;<i> 				return null;
</I>&gt;<i> 			}
</I>&gt;<i> 			
</I>&gt;<i> 			ciset.Text = txt;
</I>&gt;<i> 			ciset.UseMarkup = true;
</I>&gt;<i> 			return ciset;
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		void AddRefactoryMenuForClass (IParserContext ctx, IParseInformation pinfo, CommandInfoSet ciset, string className)
</I>&gt;<i> 		{
</I>&gt;<i> 			IClass cls = ctx.GetClass (className, true, true);
</I>&gt;<i> 			if (cls != null) {
</I>&gt;<i> 				CommandInfo ci = BuildRefactoryMenuForItem (ctx, pinfo, null, cls);
</I>&gt;<i> 				if (ci != null)
</I>&gt;<i> 					ciset.CommandInfos.Add (ci, null);
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		delegate void RefactoryOperation ();
</I>&gt;<i> 	}
</I>&gt;<i> 	
</I>&gt;<i> 	class Refactorer
</I>&gt;<i> 	{
</I>&gt;<i> 		MemberReferenceCollection references;
</I>&gt;<i> 		ISearchProgressMonitor monitor;
</I>&gt;<i> 		IParseInformation pinfo;
</I>&gt;<i> 		IParserContext ctx;
</I>&gt;<i> 		ILanguageItem item;
</I>&gt;<i> 		IClass klass;
</I>&gt;<i> 		IReturnType hintReturnType;
</I>&gt;<i> 		
</I>&gt;<i> 		public Refactorer (IParserContext ctx, IParseInformation pinfo, IClass klass, ILanguageItem item, IReturnType hintReturnType)
</I>&gt;<i> 		{
</I>&gt;<i> 			this.pinfo = pinfo;
</I>&gt;<i> 			this.klass = klass;
</I>&gt;<i> 			this.item = item;
</I>&gt;<i> 			this.ctx = ctx;
</I>&gt;<i> 			this.hintReturnType = hintReturnType;
</I>&gt;<i> 		}
</I>&gt;<i> 		//simion314
</I>&gt;<i> public void MoveClassToFile()
</I>&gt;<i> 		{
</I>&gt;<i> 	System.IO.StreamWriter sw=null;
</I>&gt;<i> 			Project project= IdeApp.Workbench.ActiveDocument.Project;
</I>&gt;<i> String directory=	System.IO.Path.GetDirectoryName(klass.Region.FileName);	
</I>&gt;<i> 		string newFname=helperClass.DetermineValidFileName(klass.Region.FileName,klass.Name);
</I>&gt;<i> 			string oldFile=klass.Region.FileName;
</I>&gt;<i> 			string backup=helperClass.DetermineValidFileName(oldFile,Path.GetFileName(oldFile+&quot;.bakup&quot;));
</I>&gt;<i> 			project.ProjectFiles.Remove(oldFile);			
</I>&gt;<i> 			
</I>&gt;<i> 			//here the new class data will be stored including import statements and namespace
</I>&gt;<i> 			System.Text.StringBuilder sb=new System.Text.StringBuilder(1000);;			
</I>&gt;<i> 		
</I>&gt;<i> 			//get the usings from the curent file	
</I>&gt;<i> 			ICompilationUnit unit=(ICompilationUnit)pinfo.MostRecentCompilationUnit;
</I>&gt;<i> 			MonoDevelop.Projects.Parser.IUsingCollection usings=  unit.Usings;
</I>&gt;<i> 
</I>&gt;<i> 			//in this string the usings statement will be placed			
</I>&gt;<i> 			String usingsStr;			
</I>&gt;<i> 			
</I>&gt;<i> 			//here will be placed the egin and end of the curent namespace
</I>&gt;<i> 			String[] theNamespace;
</I>&gt;<i> 
</I>&gt;<i> 			//get the language of the project
</I>&gt;<i> 			//i observed that the array contains an empty string at index 0 and the language
</I>&gt;<i> 			//is specified at index 1
</I>&gt;<i> 			string language=project.SupportedLanguages[1];			
</I>&gt;<i> //add a header to the generated file
</I>&gt;<i> 			
</I>&gt;<i> sb.Append( helperClass.GetHeareOfFile(language)+Environment.NewLine);
</I>&gt;<i> 			sb.Append(Environment.NewLine);
</I>&gt;<i> 			if(usings!=null&amp;&amp;usings.Count&gt;0)
</I>&gt;<i> 			{	
</I>&gt;<i> 			//create the strings that wil contain the imports 					
</I>&gt;<i> 				try
</I>&gt;<i> 				{
</I>&gt;<i> 			usingsStr=	helperClass.GenerateUsings(usings,language);
</I>&gt;<i> 				}
</I>&gt;<i> 				catch(Exception x)
</I>&gt;<i> 				{  
</I>&gt;<i> 					throw new Exception(&quot;error in generating usings method &quot;+x.Message);
</I>&gt;<i> 				}						
</I>&gt;<i> 				sb.Append(usingsStr);			
</I>&gt;<i> sb.Append(Environment.NewLine);			
</I>&gt;<i> 			}
</I>&gt;<i> 			else
</I>&gt;<i> 			{
</I>&gt;<i> //TODO the usings are null or 0			
</I>&gt;<i> 			}
</I>&gt;<i> 			string classDescription=null;
</I>&gt;<i> 			string tempfile=klass.Region.FileName+&quot;.tmp&quot;;
</I>&gt;<i> 			
</I>&gt;<i> 			//save the file before reading from it				
</I>&gt;<i>            IdeApp.Workbench.ActiveDocument.Save();			
</I>&gt;<i> 			try
</I>&gt;<i> 			{
</I>&gt;<i> 			classDescription=helperClass.ExtractTextFromRegion(klass.Region,tempfile);
</I>&gt;<i> 			}
</I>&gt;<i> 			catch(Exception x)
</I>&gt;<i> 			{
</I>&gt;<i> 				throw new Exception(&quot;error in ExtractingTextFromRegion &quot;+x.Message);			
</I>&gt;<i> 			}
</I>&gt;<i> 			if(classDescription!=null){
</I>&gt;<i> 				theNamespace=helperClass.GetNamespaces(klass,language);
</I>&gt;<i> 				sb.Append(theNamespace[0]);
</I>&gt;<i> 				sb.Append(Environment.NewLine);				
</I>&gt;<i> 				sb.Append(classDescription);
</I>&gt;<i> 				sb.Append(theNamespace[1]);			
</I>&gt;<i> 			}
</I>&gt;<i> 			else
</I>&gt;<i> 			{		
</I>&gt;<i> 				throw new Exception(&quot;a problem has ocured&quot;);
</I>&gt;<i> 			}
</I>&gt;<i> 			
</I>&gt;<i> 			//writing all to the file
</I>&gt;<i> 			try
</I>&gt;<i> 			{					
</I>&gt;<i> 			 sw=new System.IO.StreamWriter(newFname);
</I>&gt;<i> 			}
</I>&gt;<i> 			catch(Exception x)
</I>&gt;<i> 			{
</I>&gt;<i> 				throw new Exception(&quot;error when tring to create a new file &quot;+x.Message);
</I>&gt;<i> 			}
</I>&gt;<i> 			sw.Write(sb.ToString());
</I>&gt;<i> 			sw.Close();  
</I>&gt;<i> 			
</I>&gt;<i> 			//project.FileRemovedFromProject(this,null);
</I>&gt;<i> 			if(project!=null)
</I>&gt;<i> 			{//if the file belongs to a project we will remove it from the project			
</I>&gt;<i> 			try{
</I>&gt;<i> 					 IdeApp.Workbench.ActiveDocument.Close();
</I>&gt;<i> 					project.ProjectFiles.Remove(oldFile);
</I>&gt;<i> 					IdeApp.ProjectOperations.SaveProject(project);			
</I>&gt;<i> 			
</I>&gt;<i> 				}
</I>&gt;<i> 			catch(Exception x)
</I>&gt;<i> 			{
</I>&gt;<i> 				Console.WriteLine(&quot;error removeing file from project &quot;+x.Message);
</I>&gt;<i> 			}
</I>&gt;<i> 				Console.WriteLine(&quot;file &quot;+oldFile+&quot; removed from project&quot;);
</I>&gt;<i> 			}
</I>&gt;<i> 			else
</I>&gt;<i> 			{//the curent file is not belonging to a project
</I>&gt;<i> 			 IdeApp.Workbench.ActiveDocument.Close();
</I>&gt;<i> 			}
</I>&gt;<i> 			//backup the file
</I>&gt;<i> 			try
</I>&gt;<i> 			{			
</I>&gt;<i> 			File.Move(oldFile,backup);
</I>&gt;<i> 			}
</I>&gt;<i> 			catch(Exception x)
</I>&gt;<i> 				{if(project!=null)
</I>&gt;<i> 				{
</I>&gt;<i> 				project.AddFile(oldFile,BuildAction.Nothing);
</I>&gt;<i> 				}throw new IOException(&quot;can't move file &quot;+oldFile+&quot; to &quot;+backup+&quot;  &quot;+x.Message);				
</I>&gt;<i> 			}
</I>&gt;<i> 			//moving the temoray file /renaming it/ into the original file
</I>&gt;<i> 			try
</I>&gt;<i> 			{			
</I>&gt;<i> 				File.Move(tempfile,oldFile);			
</I>&gt;<i> 			}
</I>&gt;<i> 			catch
</I>&gt;<i> 				{
</I>&gt;<i> 				File.Move(backup,oldFile);
</I>&gt;<i> 				if(project!=null)
</I>&gt;<i> 				{
</I>&gt;<i> 				project.AddFile(oldFile,BuildAction.Nothing);
</I>&gt;<i> 				IdeApp.ProjectOperations.SaveProject(project);	
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> //adding files to project
</I>&gt;<i> 			if(project!=null){
</I>&gt;<i> try{			
</I>&gt;<i> 				
</I>&gt;<i> 			project.AddFile(newFname,BuildAction.Compile);	
</I>&gt;<i> 			project.AddFile(oldFile,BuildAction.Compile);
</I>&gt;<i> 			IdeApp.ProjectOperations.SaveProject(project);
</I>&gt;<i> 			}catch(Exception x)
</I>&gt;<i> 			{
</I>&gt;<i> 			throw new Exception(&quot;error adding the new file and readding the old file back to project &quot;+x.Message);
</I>&gt;<i> 			}
</I>&gt;<i> 			}
</I>&gt;<i> 			//open the files in the workspace
</I>&gt;<i> 			IdeApp.Workbench.OpenDocument(oldFile);
</I>&gt;<i> 			IdeApp.Workbench.OpenDocument(newFname);
</I>&gt;<i> 		}	
</I>&gt;<i> 			
</I>&gt;<i> 		
</I>&gt;<i> 		public void GoToDeclaration ()
</I>&gt;<i> 		{
</I>&gt;<i> 			IdeApp.ProjectOperations.JumpToDeclaration (item);
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		public void FindReferences ()
</I>&gt;<i> 		{
</I>&gt;<i> 			monitor = IdeApp.Workbench.ProgressMonitors.GetSearchProgressMonitor (true);
</I>&gt;<i> 			Thread t = new Thread (new ThreadStart (FindReferencesThread));
</I>&gt;<i> 			t.IsBackground = true;
</I>&gt;<i> 			t.Start ();
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		void FindReferencesThread ()
</I>&gt;<i> 		{
</I>&gt;<i> 			using (monitor) {
</I>&gt;<i> 				CodeRefactorer refactorer = IdeApp.ProjectOperations.CodeRefactorer;
</I>&gt;<i> 				
</I>&gt;<i> 				if (item is IMember) {
</I>&gt;<i> 					IMember member = (IMember) item;
</I>&gt;<i> 					
</I>&gt;<i> 					// private is filled only in keyword case
</I>&gt;<i> 					if (member.IsPrivate || (!member.IsProtectedOrInternal &amp;&amp; !member.IsPublic)) {
</I>&gt;<i> 						// look in project to be partial classes safe
</I>&gt;<i> 						references = refactorer.FindMemberReferences (monitor, member.DeclaringType, member,
</I>&gt;<i> 						                                              RefactoryScope.Project);
</I>&gt;<i> 					} else {
</I>&gt;<i> 						// for all other types look in solution because
</I>&gt;<i> 						// internal members can be used in friend assemblies
</I>&gt;<i> 						references = refactorer.FindMemberReferences (monitor, member.DeclaringType, member,
</I>&gt;<i> 						                                              RefactoryScope.Solution);
</I>&gt;<i> 					}
</I>&gt;<i> 				} else if (item is IClass) {
</I>&gt;<i> 					references = refactorer.FindClassReferences (monitor, (IClass)item, RefactoryScope.Solution);
</I>&gt;<i> 				}
</I>&gt;<i> 				
</I>&gt;<i> 				if (references != null) {
</I>&gt;<i> 					foreach (MemberReference mref in references) {
</I>&gt;<i> 						monitor.ReportResult (mref.FileName, mref.Line, mref.Column, mref.TextLine);
</I>&gt;<i> 					}
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		public void GoToBase ()
</I>&gt;<i> 		{
</I>&gt;<i> 			IClass cls = item as IClass;
</I>&gt;<i> 			if (cls != null &amp;&amp; cls.BaseTypes != null) {
</I>&gt;<i> 				foreach (IReturnType bc in cls.BaseTypes) {
</I>&gt;<i> 					IClass bcls = ctx.GetClass (bc.FullyQualifiedName, true, true);
</I>&gt;<i> 					if (bcls != null &amp;&amp; bcls.ClassType != ClassType.Interface &amp;&amp; bcls.Region != null) {
</I>&gt;<i> 						IdeApp.Workbench.OpenDocument (bcls.Region.FileName, bcls.Region.BeginLine, bcls.Region.BeginColumn, true);
</I>&gt;<i> 						return;
</I>&gt;<i> 					}
</I>&gt;<i> 				}
</I>&gt;<i> 				return;
</I>&gt;<i> 			}
</I>&gt;<i> 			IMethod method = item as IMethod;
</I>&gt;<i> 			if (method != null) {
</I>&gt;<i> 				foreach (IReturnType bc in method.DeclaringType.BaseTypes) {
</I>&gt;<i> 					IClass bcls = ctx.GetClass (bc.FullyQualifiedName, true, true);
</I>&gt;<i> 					if (bcls != null &amp;&amp; bcls.ClassType != ClassType.Interface &amp;&amp; bcls.Region != null) {
</I>&gt;<i> 						IMethod baseMethod = null;
</I>&gt;<i> 						foreach (IMethod m in bcls.Methods) {
</I>&gt;<i> 							if (m.Name == method.Name &amp;&amp; m.Parameters.Count == m.Parameters.Count) {
</I>&gt;<i> 								baseMethod = m;
</I>&gt;<i> 								break;
</I>&gt;<i> 							}
</I>&gt;<i> 						}
</I>&gt;<i> 						if (baseMethod != null)
</I>&gt;<i> 							IdeApp.Workbench.OpenDocument (bcls.Region.FileName, baseMethod.Region.BeginLine, baseMethod.Region.BeginColumn, true);
</I>&gt;<i> 						return;
</I>&gt;<i> 					}
</I>&gt;<i> 				}
</I>&gt;<i> 				return;
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		public void FindDerivedClasses ()
</I>&gt;<i> 		{
</I>&gt;<i> 			monitor = IdeApp.Workbench.ProgressMonitors.GetSearchProgressMonitor (true);
</I>&gt;<i> 			Thread t = new Thread (new ThreadStart (FindDerivedThread));
</I>&gt;<i> 			t.IsBackground = true;
</I>&gt;<i> 			t.Start ();
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		void FindDerivedThread ()
</I>&gt;<i> 		{
</I>&gt;<i> 			using (monitor) {
</I>&gt;<i> 				IClass cls = (IClass) item;
</I>&gt;<i> 				if (cls == null) return;
</I>&gt;<i> 			
</I>&gt;<i> 				IClass[] classes = IdeApp.ProjectOperations.CodeRefactorer.FindDerivedClasses (cls);
</I>&gt;<i> 				foreach (IClass sub in classes) {
</I>&gt;<i> 					if (sub.Region != null)
</I>&gt;<i> 						monitor.ReportResult (sub.Region.FileName, sub.Region.BeginLine, sub.Region.BeginColumn, sub.FullyQualifiedName);
</I>&gt;<i> 				}
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		void ImplementInterface (bool explicitly)
</I>&gt;<i> 		{
</I>&gt;<i> 			CodeRefactorer refactorer = IdeApp.ProjectOperations.CodeRefactorer;
</I>&gt;<i> 			IClass iface = item as IClass;
</I>&gt;<i> 			
</I>&gt;<i> 			if (klass == null)
</I>&gt;<i> 				return;
</I>&gt;<i> 			
</I>&gt;<i> 			if (iface == null)
</I>&gt;<i> 				return;
</I>&gt;<i> 				
</I>&gt;<i> 			IEditableTextBuffer editor = IdeApp.Workbench.ActiveDocument.GetContent &lt;IEditableTextBuffer&gt;();
</I>&gt;<i> 			if (editor != null)
</I>&gt;<i> 				editor.BeginAtomicUndo ();
</I>&gt;<i> 				
</I>&gt;<i> 			try {
</I>&gt;<i> 				refactorer.ImplementInterface (pinfo, klass, iface, explicitly, iface, this.hintReturnType);
</I>&gt;<i> 			} finally {
</I>&gt;<i> 				if (editor != null)
</I>&gt;<i> 					editor.EndAtomicUndo ();
</I>&gt;<i> 			}
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		public void ImplementImplicitInterface ()
</I>&gt;<i> 		{
</I>&gt;<i> 			ImplementInterface (false);
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		public void ImplementExplicitInterface ()
</I>&gt;<i> 		{
</I>&gt;<i> 			ImplementInterface (true);
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		public void EncapsulateField ()
</I>&gt;<i> 		{
</I>&gt;<i> 			IEditableTextBuffer editor = IdeApp.Workbench.ActiveDocument.GetContent &lt;IEditableTextBuffer&gt;();
</I>&gt;<i> 			if (editor != null)
</I>&gt;<i> 				editor.BeginAtomicUndo ();
</I>&gt;<i> 				
</I>&gt;<i> 			try {
</I>&gt;<i> 				EncapsulateFieldDialog dialog = new EncapsulateFieldDialog (ctx, (IField) item);
</I>&gt;<i> 				dialog.Show ();
</I>&gt;<i> 			} finally {
</I>&gt;<i> 				if (editor != null)
</I>&gt;<i> 					editor.EndAtomicUndo ();
</I>&gt;<i> 			}
</I>&gt;<i> 			
</I>&gt;<i> 		}
</I>&gt;<i> 		
</I>&gt;<i> 		public void Rename ()
</I>&gt;<i> 		{
</I>&gt;<i> 			RenameItemDialog dialog = new RenameItemDialog (ctx, item);
</I>&gt;<i> 			dialog.Show ();
</I>&gt;<i> 		}
</I>&gt;<i> 	}
</I>&gt;<i> }
</I>&gt;<i> 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Monodevelop-list mailing list
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-list">Monodevelop-list at lists.ximian.com</A>
</I>&gt;<i> <A HREF="http://lists.ximian.com/mailman/listinfo/monodevelop-list">http://lists.ximian.com/mailman/listinfo/monodevelop-list</A>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007068.html">[MonoDevelop] my work is almost done
</A></li>
	<LI>Next message: <A HREF="007071.html">[MonoDevelop] MonoDevelop branched
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7089">[ date ]</a>
              <a href="thread.html#7089">[ thread ]</a>
              <a href="subject.html#7089">[ subject ]</a>
              <a href="author.html#7089">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.ximian.com/mailman/listinfo/monodevelop-list">More information about the Monodevelop-list
mailing list</a><br>
</body></html>
