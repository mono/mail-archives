Index: Extras.mds
===================================================================
--- Extras.mds	(revision 76004)
+++ Extras.mds	(working copy)
@@ -22,6 +22,7 @@
       <Entry build="True" name="MonoDevelop.DesignerSupport" configuration="Debug" />
       <Entry build="True" name="MonoDevelop.Autotools" configuration="Debug" />
       <Entry build="True" name="MonoDevelop.WebReferences" configuration="Debug" />
+      <Entry build="True" name="MonoDevelop.Profiler" configuration="Debug" />
       <Entry build="True" name="Deployment" configuration="" />
     </Configuration>
     <Configuration name="Release" ctype="CombineConfiguration">
@@ -46,6 +47,7 @@
       <Entry build="True" name="MonoDevelop.DesignerSupport" configuration="Debug" />
       <Entry build="True" name="MonoDevelop.Autotools" configuration="Release" />
       <Entry build="True" name="MonoDevelop.WebReferences" configuration="Release" />
+      <Entry build="True" name="MonoDevelop.Profiler" configuration="Release" />
       <Entry build="True" name="Deployment" configuration="" />
     </Configuration>
   </Configurations>
@@ -71,6 +73,7 @@
     <Execute type="None" entry="MonoDevelop.DesignerSupport" />
     <Execute type="None" entry="MonoDevelop.Autotools" />
     <Execute type="None" entry="MonoDevelop.WebReferences" />
+    <Execute type="None" entry="MonoDevelop.Profiler" />
     <Execute type="None" entry="Deployment" />
   </StartMode>
   <Entries>
@@ -95,6 +98,7 @@
     <Entry filename="./MonoDevelop.DesignerSupport/MonoDevelop.DesignerSupport.mdp" />
     <Entry filename="./MonoDevelop.Autotools/MonoDevelop.Autotools.mdp" />
     <Entry filename="./MonoDevelop.WebReferences/MonoDevelop.WebReferences.mdp" />
+    <Entry filename="./MonoDevelop.Profiler/MonoDevelop.Profiler.mdp" />
     <Entry filename="./Deployment/Deployment.mds" />
   </Entries>
-</Combine>
\ No newline at end of file
+</Combine>
Index: MonoDevelop.Profiler/AssemblyInfo.cs
===================================================================
--- MonoDevelop.Profiler/AssemblyInfo.cs	(revision 0)
+++ MonoDevelop.Profiler/AssemblyInfo.cs	(revision 0)
@@ -0,0 +1,19 @@
+﻿using System;
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+[assembly: AssemblyTitle ("MonoDevelop.Profiler")]
+[assembly: AssemblyDescription ("")]
+[assembly: AssemblyConfiguration ("")]
+[assembly: AssemblyCompany ("")]
+[assembly: AssemblyProduct ("MonoDevelop.Profiler")]
+[assembly: AssemblyCopyright ("Copyright 2007 © Ben Motmans")]
+[assembly: AssemblyTrademark ("")]
+[assembly: AssemblyCulture ("")]
+
+[assembly: AssemblyVersion ("0.1.0.0")]
+[assembly: AssemblyFileVersion ("0.1.0.0")]
+
+[assembly: ComVisible (false)]
+[assembly: CLSCompliant (false)]
\ No newline at end of file
Index: MonoDevelop.Profiler/Commands/ProjectCommands.cs
===================================================================
--- MonoDevelop.Profiler/Commands/ProjectCommands.cs	(revision 0)
+++ MonoDevelop.Profiler/Commands/ProjectCommands.cs	(revision 0)
@@ -0,0 +1,100 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Threading;
+using System.Diagnostics;
+using MonoDevelop.Core;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Core.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Components;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Components.Commands;
+using MonoDevelop.Profiler.Codons;
+
+namespace MonoDevelop.Profiler.Commands
+{
+	public enum ProjectCommands
+	{
+		ProfilerList
+	}
+	
+	internal class ProfilerListHandler: CommandHandler
+	{
+		private IProfiler profiler;
+		private Document doc;
+
+		protected override void Update (CommandArrayInfo info)
+		{
+			foreach (ProfilerCodon codon in Services.ProfilerService.ProfilerCodons) {
+				CommandInfo cmd = new CommandInfo (codon.Label);
+				cmd.UseMarkup = true;
+				cmd.Icon = codon.Icon;
+				info.Add (cmd, codon.Profiler); 
+			}
+		}
+		
+		protected override void Run (object ob)
+		{
+			profiler = (IProfiler)ob;
+			
+			if (IdeApp.ProjectOperations.CurrentOpenCombine != null) {
+				IAsyncOperation op = IdeApp.ProjectOperations.Build (IdeApp.ProjectOperations.CurrentOpenCombine);
+				op.Completed += new OperationHandler (ExecuteCombine);
+			} else {
+				doc = IdeApp.Workbench.ActiveDocument;
+				if (doc != null) {
+					IAsyncOperation op = doc.Build ();
+					op.Completed += new OperationHandler (ExecuteFile);
+				}
+			}
+		}
+		
+		protected override void Update (CommandInfo info)
+		{
+			if (IdeApp.ProjectOperations.CurrentOpenCombine != null) {
+				info.Enabled = IdeApp.ProjectOperations.CurrentRunOperation.IsCompleted;
+			} else {
+				info.Enabled = (IdeApp.Workbench.ActiveDocument != null && IdeApp.Workbench.ActiveDocument.IsBuildTarget);
+			}
+		}
+		
+		void ExecuteCombine (IAsyncOperation op)
+		{
+			if (op.Success)
+				// FIXME: check RunWithWarnings
+				IdeApp.ProjectOperations.Profile (IdeApp.ProjectOperations.CurrentOpenCombine, profiler);
+		}
+		
+		void ExecuteFile (IAsyncOperation op)
+		{
+			if (op.Success)
+				doc.Profile (profiler);
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Gui/Widgets/HeapShotObjectMapViewer.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Widgets/HeapShotObjectMapViewer.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Widgets/HeapShotObjectMapViewer.cs	(revision 0)
@@ -0,0 +1,566 @@
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using Gtk;
+using Gdk;
+using Stock = MonoDevelop.Core.Gui.Stock;
+
+using MonoDevelop.Profiler.Profilers;
+using MonoDevelop.Profiler.Profilers.HeapShot;
+
+namespace MonoDevelop.Profiler
+{
+	public delegate void ProgressEventHandler (int current, int max, string message);
+	
+	public partial class HeapShotObjectMapViewer : Gtk.Bin
+	{
+		Gtk.TreeStore store;
+		const int ReferenceCol = 0;
+		const int ImageCol = 1;
+		const int TypeCol = 2;
+		const int FilledCol = 3;
+		const int SizeCol = 4;
+		const int AvgSizeCol = 5;
+		const int InstancesCol = 6;
+		const int RefsCol = 7;
+		const int RootRefsCol = 8;
+		const int RootMemCol = 9;
+		int TreeColRefs;
+		bool reloadRequested;
+		bool loading;
+		Gtk.Tooltips tips = new Gtk.Tooltips ();
+		TipWindow tipWindow;
+		bool showTipScheduled;
+		uint tipTimeoutId;
+		const int TipTimer = 800;
+		
+		ObjectMapReader file;
+		string typeName;
+		
+		public event ProgressEventHandler ProgressEvent;
+
+		public HeapShotObjectMapViewer ()
+		{
+			Build ();
+			store = new Gtk.TreeStore (typeof(object), typeof(string), typeof(string), typeof(bool), typeof(string), typeof(string), typeof(string), typeof(string), typeof(string), typeof(string));
+			treeview.Model = store;
+			treeview.HeadersClickable = true;
+			
+			Gtk.TreeViewColumn complete_column = new Gtk.TreeViewColumn ();
+			complete_column.Title = "Type";
+			complete_column.Resizable = true;
+
+			Gtk.CellRendererPixbuf pix_render = new Gtk.CellRendererPixbuf ();
+			complete_column.PackStart (pix_render, false);
+			complete_column.AddAttribute (pix_render, "stock-id", ImageCol);
+
+			Gtk.CellRendererText text_render = new Gtk.CellRendererText ();
+			complete_column.PackStart (text_render, true);
+			
+			complete_column.AddAttribute (text_render, "text", TypeCol);
+			complete_column.Clickable = true;
+	
+			treeview.AppendColumn (complete_column);
+			
+			AddColumn ("Instances", InstancesCol, "Number of instances of a type. Only instances that contain references are included.");
+			TreeColRefs = treeview.Columns.Length;
+			AddColumn ("References", RefsCol, "Number of references to the parent type.");
+			AddColumn ("Root Refs", RootRefsCol, "Number of indirect references to instances of the tree root type.");
+			AddColumn ("Root Mem", RootMemCol, "Amount of memory of the root instances indirectly referenced.");
+			AddColumn ("Memory Size", SizeCol, "Memory allocated by instances of the type.");
+			AddColumn ("Avg. Size", AvgSizeCol, "Average size of the instances.");
+			
+			treeview.TestExpandRow += new Gtk.TestExpandRowHandler (OnTestExpandRow);
+			treeview.RowActivated += new Gtk.RowActivatedHandler (OnNodeActivated);
+			treeview.AppendColumn (new Gtk.TreeViewColumn());
+			
+			int nc = 0;
+			foreach (TreeViewColumn c in treeview.Columns) {
+				store.SetSortFunc (nc, CompareNodes);
+				c.SortColumnId = nc++;
+			}
+			store.SetSortColumnId (1, Gtk.SortType.Descending);
+			treeview.RulesHint = true;
+			tips.Enable ();
+		}
+		
+		void AddColumn (string title, int ncol, string desc)
+		{
+			Gtk.TreeViewColumn col = new Gtk.TreeViewColumn ();
+			Gtk.Label lab = new Gtk.Label (title);
+			lab.Xalign = 1;
+			EventBox bx = new EventBox ();
+			bx.Add (lab);
+			bx.ShowAll ();
+			col.Widget = bx;
+			
+			CellRendererText crt = new CellRendererText ();
+			crt.Xalign = 1;
+			col.PackStart (crt, true);
+			col.AddAttribute (crt, "text", ncol);
+			
+			treeview.AppendColumn (col);
+			tips.SetTip (bx, desc, desc);
+		}
+		
+		public void Clear ()
+		{
+			entryFilter.Text = "";
+			store.Clear ();
+		}
+		
+		public bool InverseReferences {
+			get { return checkInverse.Active; }
+			set { checkInverse.Active = value; }
+		}
+		
+		public string RootTypeName {
+			get { return typeName; }
+		}
+		
+		public string SelectedType {
+			get {
+				Gtk.TreeModel foo;
+				Gtk.TreeIter iter;
+				if (!treeview.Selection.GetSelected (out foo, out iter))
+					return null;
+				ReferenceNode nod = store.GetValue (iter, 0) as ReferenceNode;
+				if (nod != null)
+					return nod.TypeName;
+				else
+					return null;
+			}
+		}
+		
+		public void FillAllTypes (ObjectMapReader file)
+		{
+			this.file = file;
+			this.typeName = null;
+			boxFilter.Visible = true;
+			treeview.Columns [TreeColRefs].Visible = InverseReferences;
+			treeview.Columns [TreeColRefs+1].Visible = InverseReferences;
+			treeview.Columns [TreeColRefs+2].Visible = InverseReferences;
+			
+			if (loading) {
+				// If the tree is already being loaded, notify that loading
+				// has to start again, since the file has changed.
+				reloadRequested = true;
+				return;
+			}
+
+			loading = true;
+			store.Clear ();
+			int n=0;
+			foreach (int t in file.GetTypes ()) {
+				if (++n == 20) {
+					if (ProgressEvent != null) {
+						ProgressEvent (n, file.GetTypeCount (), null);
+					}
+					while (Gtk.Application.EventsPending ())
+						Gtk.Application.RunIteration ();
+					if (reloadRequested) {
+						loading = false;
+						reloadRequested = false;
+						FillAllTypes (this.file);
+						return;
+					}
+					n = 0;
+				}
+				if (file.GetObjectCountForType (t) > 0)
+					InternalFillType (file, t);
+			}
+			loading = false;
+		}
+		
+		public void FillType (ObjectMapReader file, string typeName)
+		{
+			this.typeName = typeName;
+			this.file = file;
+			store.Clear ();
+			boxFilter.Visible = false;
+			treeview.Columns [TreeColRefs].Visible = InverseReferences;
+			treeview.Columns [TreeColRefs+1].Visible = InverseReferences;
+			treeview.Columns [TreeColRefs+2].Visible = InverseReferences;
+			TreeIter iter = InternalFillType (file, file.GetTypeFromName (typeName));
+			treeview.ExpandRow (store.GetPath (iter), false);
+		}
+		
+		TreeIter InternalFillType (ObjectMapReader file, int type)
+		{
+			ReferenceNode node = file.GetReferenceTree (type, checkInverse.Active);
+			return AddNode (TreeIter.Zero, node);
+		}
+		
+		void Refill ()
+		{
+			if (typeName != null)
+				FillType (file, typeName);
+			else
+				FillAllTypes (file);
+		}
+		
+		TreeIter AddNode (TreeIter parent, ReferenceNode node)
+		{
+			if (entryFilter.Text.Length > 0 && node.TypeName.IndexOf (entryFilter.Text) == -1)
+				return TreeIter.Zero;
+			
+			TreeIter iter;
+			if (parent.Equals (TreeIter.Zero)) {
+				iter = store.AppendValues (node, Stock.Class, node.TypeName, !node.HasReferences, node.TotalMemory.ToString("n0"), node.AverageSize.ToString("n0"), node.RefCount.ToString ("n0"), "", "", "");
+			} else {
+				string refs = (InverseReferences ? node.RefsToParent.ToString ("n0") : "");
+				string rootRefs = (InverseReferences ? node.RefsToRoot.ToString ("n0") : "");
+				string rootMem = (InverseReferences ? node.RootMemory.ToString ("n0") : "");
+				iter = store.AppendValues (parent, node, Stock.Class, node.TypeName, !node.HasReferences, node.TotalMemory.ToString("n0"), node.AverageSize.ToString("n0"), node.RefCount.ToString ("n0"), refs, rootRefs, rootMem);
+			}
+
+			if (node.HasReferences) {
+				// Add a dummy element to make the expansion icon visible
+				store.AppendValues (iter, null, "", "", true, "", "", "", "", "", "");
+			}
+			return iter;
+		}
+
+		TreeIter AddNode (TreeIter parent, FieldReference node)
+		{
+			if (parent.Equals (TreeIter.Zero))
+				return store.AppendValues (node, Stock.Field, node.FiledName, true, "", "", node.RefCount.ToString ("n0"), "", "");
+			else
+				return store.AppendValues (parent, node, Stock.Field, node.FiledName, true, "", "", node.RefCount.ToString ("n0"), "", "");
+		}
+
+		private void OnTestExpandRow (object sender, Gtk.TestExpandRowArgs args)
+		{
+			bool filled = (bool) store.GetValue (args.Iter, FilledCol);
+			ReferenceNode parent = (ReferenceNode) store.GetValue (args.Iter, ReferenceCol);
+			if (!filled) {
+				store.SetValue (args.Iter, FilledCol, true);
+				TreeIter iter;
+				store.IterChildren (out iter, args.Iter);
+				store.Remove (ref iter);
+				if (parent.References.Count > 0 || parent.FieldReferences.Count > 0) {
+					int nr = 0;
+					foreach (ReferenceNode nod in parent.References)
+						if (!AddNode (args.Iter, nod).Equals (TreeIter.Zero))
+							nr++;
+					foreach (FieldReference fref in parent.FieldReferences)
+						if (!AddNode (args.Iter, fref).Equals (TreeIter.Zero))
+							nr++;
+					if (nr == 0)
+						args.RetVal = true;
+				} else
+					args.RetVal = true;
+			}
+		}
+
+		protected virtual void OnNodeActivated (object sender, Gtk.RowActivatedArgs args)
+		{
+			if (TypeActivated != null && SelectedType != null)
+				TypeActivated (this, EventArgs.Empty);
+		}
+		
+		protected virtual void OnCheckInverseClicked(object sender, System.EventArgs e)
+		{
+			Refill ();
+		}
+
+		protected virtual void OnButtonFilterClicked(object sender, System.EventArgs e)
+		{
+			Refill ();
+		}
+
+		protected virtual void OnEntryFilterActivated(object sender, System.EventArgs e)
+		{
+			Refill ();
+		}
+		
+		int CompareNodes (Gtk.TreeModel model, Gtk.TreeIter a, Gtk.TreeIter b)
+		{
+			int col;
+			SortType type;
+			store.GetSortColumnId (out col, out type);
+			
+			object o1 = model.GetValue (a, ReferenceCol);
+			object o2 = model.GetValue (b, ReferenceCol);
+			
+			if (o1 is ReferenceNode && o2 is ReferenceNode) {
+				ReferenceNode nod1 = (ReferenceNode) o1;
+				ReferenceNode nod2 = (ReferenceNode) o2;
+				switch (col) {
+					case 0:
+						return string.Compare (nod1.TypeName, nod2.TypeName);
+					case 1:
+						return nod1.RefCount.CompareTo (nod2.RefCount);
+					case 2:
+						return nod1.RefsToParent.CompareTo (nod2.RefsToParent);
+					case 3:
+						return nod1.RefsToRoot.CompareTo (nod2.RefsToRoot);
+					case 4:
+						return nod1.RootMemory.CompareTo (nod2.RootMemory);
+					case 5:
+						return nod1.TotalMemory.CompareTo (nod2.TotalMemory);
+					case 6:
+						return nod1.AverageSize.CompareTo (nod2.AverageSize);
+					default:
+						return 1;
+	//					throw new InvalidOperationException ();
+				}
+			} else if (o1 is FieldReference && o2 is FieldReference) {
+				return ((FieldReference)o1).FiledName.CompareTo (((FieldReference)o2).FiledName);
+			} else if (o1 is FieldReference) {
+				return 1;
+			} else {
+				return -1;
+			}
+		}
+
+		[GLib.ConnectBefore]
+		protected void OnTreeviewMotionNotifyEvent(object o, Gtk.MotionNotifyEventArgs args)
+		{
+			UpdateTipWindow ((int)args.Event.X, (int)args.Event.Y);
+		}
+		
+		void UpdateTipWindow (int x, int y)
+		{
+			if (tipWindow != null) {
+				// Tip already being shown. Update it.
+				ShowTooltip (x, y);
+			}
+			else if (showTipScheduled) {
+				// Tip already scheduled. Reset the timer.
+				GLib.Source.Remove (tipTimeoutId);
+				tipTimeoutId = GLib.Timeout.Add (TipTimer, delegate { return ShowTooltip (x,y);} );
+			}
+			else {
+				// Start a timer to show the tip
+				showTipScheduled = true;
+				tipTimeoutId = GLib.Timeout.Add (TipTimer, delegate { return ShowTooltip (x,y);} );
+			}
+		}
+		
+		string lastTipTxt;
+		
+		bool ShowTooltip (int xloc, int yloc)
+		{
+			ModifierType mask; // ignored
+			int mxloc, myloc;
+
+			showTipScheduled = false;
+			
+			treeview.GdkWindow.GetPointer (out mxloc, out myloc, out mask);
+			
+			Gtk.TreePath path;
+			Gtk.TreeViewColumn col;
+			
+			treeview.GetPathAtPos (xloc, yloc, out path, out col);
+			if (col == null) {
+				HideTipWindow ();
+				return false;
+			}
+			
+			Gtk.TreeIter iter;
+			if (!store.GetIter (out iter, path)) {
+				HideTipWindow ();
+				return false;
+			}
+
+			object ob = store.GetValue (iter, ReferenceCol);
+			string txt = GetTipText (iter, col.SortColumnId, ob);
+			if (lastTipTxt != txt) {
+				HideTipWindow ();
+				tipWindow = new TipWindow (txt);
+			}
+			lastTipTxt = txt;
+			
+			int ox, oy;
+			treeview.GdkWindow.GetOrigin (out ox, out oy);
+			int w = tipWindow.Child.SizeRequest().Width;
+			tipWindow.Move (mxloc + ox - (w/2), myloc + oy + 20);
+			tipWindow.ShowAll ();
+
+			return false;
+		}
+		
+		string GetTipText (Gtk.TreeIter iter, int col, object ob)
+		{
+			ReferenceNode node = ob as ReferenceNode;
+			if (node != null) {
+				switch (col) {
+					case 0:
+						return "Type " + node.TypeName;
+					case 1: {
+						string pname = GetParentType (iter);
+						if (pname != null) {
+							if (InverseReferences)
+								return string.Format ("There are <b>{0:n0}</b> instances of type <b>{1}</b> which contain references to objects of type <b>{2}</b>", node.RefCount, GetShortName (node.TypeName), pname);
+							else
+								return string.Format ("There are <b>{0:n0}</b> instances of type <b>{1}</b> referenced by objects of type <b>{2}</b>", node.RefCount, GetShortName (node.TypeName), pname);
+						} else
+							return string.Format ("There are <b>{0:n0}</b> instances of type <b>{1}</b>.", node.RefCount, GetShortName (node.TypeName));
+					}
+					case 2: {
+						string pname = GetParentType (iter);
+						if (pname != null)
+							return string.Format ("There are <b>{0:n0}</b> distinct references from objects of type <b>{1}</b> to objects of type <b>{2}</b>", node.RefsToParent, GetShortName (node.TypeName), pname);
+						else
+							return "";
+					}
+					case 3: {
+						string rname = GetRootType (iter);
+						if (rname != null)
+							return string.Format ("There are <b>{0:n0}</b> indirect references from objects of type <b>{1}</b> to objects of type <b>{2}</b>", node.RefsToRoot, GetShortName (node.TypeName), rname);
+						else
+							return "";
+					}
+					case 4: {
+						string rname = GetRootType (iter);
+						if (rname != null)
+							return string.Format ("There are <b>{0:n0}</b> bytes of <b>{1}</b> objects indirectly referenced by <b>{2}</b> objects", node.RootMemory, rname, GetShortName (node.TypeName));
+						else
+							return "";
+					}
+					case 5: {
+						string pname = GetParentType (iter);
+						if (pname != null) {
+							if (InverseReferences)
+								return string.Format ("There are <b>{0:n0}</b> bytes of <b>{1}</b> objects which have references to <b>{2}</b> objects", node.TotalMemory, GetShortName (node.TypeName), pname);
+							else
+								return string.Format ("There are <b>{0:n0}</b> bytes of <b>{1}</b> objects referenced by <b>{2}</b> objects", node.TotalMemory, GetShortName (node.TypeName), pname);
+						} else
+							return string.Format ("There are <b>{0:n0}</b> bytes of <b>{1}</b> objects", node.TotalMemory, GetShortName (node.TypeName));
+					}
+					case 6:
+						string pname = GetParentType (iter);
+						if (pname != null) {
+							if (InverseReferences)
+								return string.Format ("Objects of type <b>{0}</b> which have references to <b>{2}</b> objects have an average size of <b>{1:n0}</b> bytes", GetShortName (node.TypeName), node.AverageSize, pname);
+							else
+								return string.Format ("Objects of type <b>{0}</b> referenced by <b>{2}</b> objects have an average size of <b>{1:n0}</b> bytes", GetShortName (node.TypeName), node.AverageSize, pname);
+						} else
+							return string.Format ("Objects of type <b>{0}</b> have an average size of <b>{1:n0}</b> bytes", GetShortName (node.TypeName), node.AverageSize);
+				}
+			} else {
+				FieldReference fr = (FieldReference) ob;
+				return fr.FiledName;
+			}
+			
+			return "";
+		}
+		
+		string GetShortName (string typeName)
+		{
+			int i = typeName.LastIndexOf ('.');
+			if (i != -1)
+				return typeName.Substring (i+1);
+			else
+				return typeName;
+		}
+		
+		string GetParentType (Gtk.TreeIter it)
+		{
+			if (store.IterParent (out it, it))
+				return GetShortName ((string) store.GetValue (it, TypeCol));
+			else
+				return null;
+		}
+		
+		string GetRootType (Gtk.TreeIter it)
+		{
+			Gtk.TreeIter rit;
+			while (store.IterParent (out rit, it)) {
+				it = rit;
+			}
+			return GetShortName ((string) store.GetValue (it, TypeCol));
+		}
+		
+		protected override bool OnScrollEvent (Gdk.EventScroll evnt)
+		{
+			HideTipWindow ();
+			return base.OnScrollEvent (evnt);
+		}
+
+		protected override bool OnLeaveNotifyEvent (Gdk.EventCrossing evnt)		
+		{
+			HideTipWindow ();
+			return base.OnLeaveNotifyEvent (evnt);
+		}
+		protected override bool OnButtonPressEvent (Gdk.EventButton e)
+		{
+			HideTipWindow ();
+			return base.OnButtonPressEvent (e);
+		}
+		
+		protected override bool OnKeyPressEvent (Gdk.EventKey evnt)
+		{
+			HideTipWindow ();
+			return base.OnKeyPressEvent (evnt);
+		}
+		
+		void HideTipWindow ()
+		{
+			lastTipTxt = null;
+			if (showTipScheduled) {
+				GLib.Source.Remove (tipTimeoutId);
+				showTipScheduled = false;
+			}
+			if (tipWindow != null) {
+				tipWindow.Destroy ();
+				tipWindow = null;
+			}
+		}
+
+		[GLib.ConnectBefore]
+		protected void OnTreeviewLeaveNotifyEvent(object o, Gtk.LeaveNotifyEventArgs args)
+		{
+			HideTipWindow ();
+		}
+		
+		public event EventHandler TypeActivated;
+	}
+	
+	class TipWindow: Gtk.Window
+	{
+		public TipWindow (string txt) : base (Gtk.WindowType.Popup)
+		{
+			Label lab = new Label ();
+			lab.Markup = txt;
+			lab.Xalign = 0.5f;
+			lab.Xpad = 3;
+			lab.Ypad = 3;
+			lab.Wrap = true;
+			Add (lab);
+		}
+		
+		protected override bool OnExposeEvent (Gdk.EventExpose ev)
+		{
+			base.OnExposeEvent (ev);
+			Gtk.Requisition req = SizeRequest ();
+			Gtk.Style.PaintFlatBox (this.Style, this.GdkWindow, Gtk.StateType.Normal, Gtk.ShadowType.Out, Gdk.Rectangle.Zero, this, "tooltip", 0, 0, req.Width, req.Height);
+			return true;
+		}
+	}
+}
Index: MonoDevelop.Profiler/Gui/Widgets/HeapShotSummary.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Widgets/HeapShotSummary.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Widgets/HeapShotSummary.cs	(revision 0)
@@ -0,0 +1,50 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+
+namespace MonoDevelop.Profiler
+{
+	public partial class HeapShotSummary : Gtk.Bin
+	{
+		public HeapShotSummary()
+		{
+			this.Build();
+		}
+		
+		public string FileName {
+			set { labelName.Text = value; }
+		}
+		
+		public long ObjectCount {
+			set { labelCount.Text = Services.GetHumanReadableSize (value); }
+		}
+		
+		public long TotalMemory {
+			set { labelMemory.Text = Services.GetHumanReadableSize (value); }
+		}
+	}
+}
Index: MonoDevelop.Profiler/Gui/Pads/ProfilerEntryCollectionNodeBuilder.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Pads/ProfilerEntryCollectionNodeBuilder.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Pads/ProfilerEntryCollectionNodeBuilder.cs	(revision 0)
@@ -0,0 +1,72 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections.Generic;
+
+using MonoDevelop.Core;
+using MonoDevelop.Core.Gui;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Ide.Gui.Pads;
+
+namespace MonoDevelop.Profiler.Gui.Pads
+{
+	public class ProfilerEntryCollectionNodeBuilder : TypeNodeBuilder
+	{
+		public ProfilerEntryCollectionNodeBuilder ()
+		{
+			//TODO: listen for snapshot create events
+		}
+			
+		public override Type NodeDataType {
+			get { return typeof(ProfilerEntryCollection); }
+		}
+		
+		public override string GetNodeName (ITreeNavigator thisNode, object dataObject)
+		{
+			return GettextCatalog.GetString ("Profilers");
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			label = GettextCatalog.GetString ("Profilers");
+			icon = Context.GetIcon (Stock.RunProgramIcon);
+		}
+
+		public override void BuildChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			ProfilerEntryCollection pec = dataObject as ProfilerEntryCollection;
+			foreach (ProfilerEntry pe in pec.ProfilerEntries)
+				builder.AddChild (pe);
+		}
+		
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return ((ProfilerEntryCollection) dataObject).Count > 0;
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Gui/Pads/ProfilerSnapshotNodeBuilder.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Pads/ProfilerSnapshotNodeBuilder.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Pads/ProfilerSnapshotNodeBuilder.cs	(revision 0)
@@ -0,0 +1,88 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections.Generic;
+
+using MonoDevelop.Core;
+using MonoDevelop.Core.Gui;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Ide.Gui.Pads;
+using MonoDevelop.Profiler.Gui.Views;
+
+namespace MonoDevelop.Profiler.Gui.Pads
+{
+	public class ProfilerSnapshotNodeBuilder : TypeNodeBuilder
+	{
+		public override Type NodeDataType {
+			get { return typeof (IProfilerSnapshot); }
+		}
+		
+		public override Type CommandHandlerType {
+			get { return typeof (ProfilerSnapshotCommandHandler); }
+		}
+		
+		public override string GetNodeName (ITreeNavigator thisNode, object dataObject)
+		{
+			return ((IProfilerSnapshot)dataObject).FileName;
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			IProfilerSnapshot snapshot = dataObject as IProfilerSnapshot;
+			label = snapshot.Name;
+			icon = Context.GetIcon (Gtk.Stock.File); 
+		}
+
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return false;
+		}
+	}
+	
+	public class ProfilerSnapshotCommandHandler : NodeCommandHandler
+	{
+		public override void RenameItem (string newName)
+		{
+			//TODO: 
+		}
+		
+		public override void ActivateItem ()
+		{
+			IProfilerSnapshot snapshot = CurrentNode.DataItem as IProfilerSnapshot;
+			
+			ISnapshotView view = Services.ProfilerService.CreateSnapshotView (snapshot.Profiler);
+			view.Initialize (snapshot);
+			IdeApp.Workbench.OpenDocument (view, true);
+		}
+		
+		public override DragOperation CanDragNode ()
+		{
+			return DragOperation.None;
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Gui/Pads/ProfilerEntryCollection.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Pads/ProfilerEntryCollection.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Pads/ProfilerEntryCollection.cs	(revision 0)
@@ -0,0 +1,68 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections.Generic;
+
+using MonoDevelop.Core;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Ide.Gui.Pads;
+
+namespace MonoDevelop.Profiler.Gui.Pads
+{
+	public class ProfilerEntryCollection
+	{
+		private List<ProfilerEntry> entries;
+		
+		public ProfilerEntryCollection ()
+		{
+			this.entries = new List<ProfilerEntry> ();
+		}
+		
+		public void Add (IProfiler profiler)
+		{
+			ProfilerEntry pe = new ProfilerEntry (profiler);
+			entries.Add (pe);
+		}
+		
+		public void AddSnapshot (IProfiler profiler, IProfilerSnapshot snapshot)
+		{
+			foreach (ProfilerEntry pe in entries) {
+				if (pe.Profiler == profiler)
+					pe.Snapshots.Add (snapshot);
+			}
+		}
+		
+		public IEnumerable<ProfilerEntry> ProfilerEntries {
+			get { return entries; }
+		}
+		
+		public int Count {
+			get { return entries.Count; }
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Gui/Pads/ProfilerEntryNodeBuilder.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Pads/ProfilerEntryNodeBuilder.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Pads/ProfilerEntryNodeBuilder.cs	(revision 0)
@@ -0,0 +1,73 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections.Generic;
+
+using MonoDevelop.Core;
+using MonoDevelop.Core.Gui;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Ide.Gui.Pads;
+
+namespace MonoDevelop.Profiler.Gui.Pads
+{
+	public class ProfilerEntryNodeBuilder : TypeNodeBuilder
+	{
+		public ProfilerEntryNodeBuilder ()
+		{
+			//TODO: listen for snapshot create events
+		}
+			
+		public override Type NodeDataType {
+			get { return typeof(ProfilerEntry); }
+		}
+		
+		public override string GetNodeName (ITreeNavigator thisNode, object dataObject)
+		{
+			return Services.ProfilerService.GetLabel (((ProfilerEntry)dataObject).Profiler);
+		}
+		
+		public override void BuildNode (ITreeBuilder treeBuilder, object dataObject, ref string label, ref Gdk.Pixbuf icon, ref Gdk.Pixbuf closedIcon)
+		{
+			ProfilerEntry entry = dataObject as ProfilerEntry;
+			label = Services.ProfilerService.GetLabel (entry.Profiler);
+			icon = Context.GetIcon (Stock.RunProgramIcon); 
+		}
+
+		public override void BuildChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			ProfilerEntry entry = dataObject as ProfilerEntry;
+			foreach (IProfilerSnapshot snapshot in entry.Snapshots)
+				builder.AddChild (snapshot);
+		}
+		
+		public override bool HasChildNodes (ITreeBuilder builder, object dataObject)
+		{
+			return ((ProfilerEntry) dataObject).Snapshots.Count > 0;
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Gui/Pads/ProfilerEntry.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Pads/ProfilerEntry.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Pads/ProfilerEntry.cs	(revision 0)
@@ -0,0 +1,56 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections.Generic;
+
+using MonoDevelop.Core;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Ide.Gui.Pads;
+
+namespace MonoDevelop.Profiler.Gui.Pads
+{
+	public class ProfilerEntry
+	{
+		private IProfiler profiler;
+		private List<IProfilerSnapshot> snapshots;
+		
+		public ProfilerEntry (IProfiler profiler)
+		{
+			this.profiler = profiler;
+			this.snapshots = new List<IProfilerSnapshot> ();
+		}
+		
+		public IProfiler Profiler {
+			get { return profiler; }
+		}
+		
+		public ICollection<IProfilerSnapshot> Snapshots {
+			get { return snapshots; }
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Gui/Pads/ProfilerPad.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Pads/ProfilerPad.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Pads/ProfilerPad.cs	(revision 0)
@@ -0,0 +1,112 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using Gtk;
+using System;
+using System.Resources;
+
+using MonoDevelop.Core;
+using Stock = MonoDevelop.Core.Gui.Stock;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Ide;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Ide.Gui.Pads;
+using MonoDevelop.Projects;
+
+namespace MonoDevelop.Profiler.Gui.Pads
+{
+	public class ProfilerPad : TreeViewPad
+	{
+		private VBox vbox;
+		private ToolButton createSnapshotButton;
+		
+		private ProfilerEntryCollection collection;
+		
+		public ProfilerPad ()
+		{
+			vbox = new VBox ();
+			
+			Toolbar toolbar = new Toolbar ();
+			toolbar.ToolbarStyle = ToolbarStyle.BothHoriz;
+			
+			createSnapshotButton = new ToolButton (new Gtk.Image (Stock.RunProgramIcon, IconSize.SmallToolbar), GettextCatalog.GetString ("Create snapshot"));
+			createSnapshotButton.Clicked += new EventHandler (CreateSnapshotClick);
+			createSnapshotButton.Expand = true;
+			createSnapshotButton.IsImportant = true;
+			toolbar.Insert (createSnapshotButton, 0);
+
+			vbox.PackStart (toolbar, false, true, 0);
+			
+			Services.ProfilerService.StartedEvent += new EventHandler (ProfilerStarted);
+			Services.ProfilerService.StoppedEvent += new EventHandler (ProfilerStopped);
+			Services.ProfilerService.SnapshotCreated += new ProfilerSnapshotEventHandler (SnapshotCreatedCallback);
+			createSnapshotButton.Sensitive = Services.ProfilerService.ActiveProfiler != null;
+		}
+		
+		public override void Initialize (NodeBuilder[] builders, TreePadOption[] options)
+		{
+			base.Initialize (builders, options);
+			vbox.PackStart (base.Control, true, true, 0);
+			vbox.ShowAll ();
+			
+			collection = new ProfilerEntryCollection ();
+			foreach (IProfiler prof in Services.ProfilerService.Profilers)
+				collection.Add (prof);
+			LoadTree (collection);
+		}
+		
+		public override Widget Control {
+			get { return vbox; }
+		}
+
+		private void CreateSnapshotClick (object sender, EventArgs args)
+		{
+			Services.ProfilerService.ActiveProfiler.CreateSnapshot ();
+		}
+
+		private void SnapshotCreatedCallback (object sender, ProfilerSnapshotEventArgs args)
+		{
+			collection.AddSnapshot (args.Profiler, args.Snapshot);
+			Services.DispatchService.GuiDispatch (delegate () {
+				LoadTree (collection); //FIXME: do not completely redraw
+			});
+		}
+		
+		private void ProfilerStarted (object sender, EventArgs args)
+		{
+			Services.DispatchService.GuiDispatch (delegate () {
+				createSnapshotButton.Sensitive = true;
+			});
+		}
+		
+		private void ProfilerStopped (object sender, EventArgs args)
+		{
+			Services.DispatchService.GuiDispatch (delegate () {
+				createSnapshotButton.Sensitive = false;
+			});
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Gui/Views/ISnapshotView.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Views/ISnapshotView.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Views/ISnapshotView.cs	(revision 0)
@@ -0,0 +1,42 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections.Generic;
+
+using MonoDevelop.Core;
+using MonoDevelop.Core.Gui;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Ide.Gui.Pads;
+
+namespace MonoDevelop.Profiler.Gui.Views
+{
+	public interface ISnapshotView : IViewContent
+	{
+		void Initialize (IProfilerSnapshot snapshot);
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Gui/Views/HeapShotSnapshotView.cs
===================================================================
--- MonoDevelop.Profiler/Gui/Views/HeapShotSnapshotView.cs	(revision 0)
+++ MonoDevelop.Profiler/Gui/Views/HeapShotSnapshotView.cs	(revision 0)
@@ -0,0 +1,135 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using Gtk;
+
+using System;
+using System.Collections.Generic;
+
+using MonoDevelop.Core;
+using Stock = MonoDevelop.Core.Gui.Stock;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Components;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Ide.Gui.Pads;
+using MonoDevelop.Profiler.Profilers;
+using MonoDevelop.Profiler.Profilers.HeapShot;
+
+namespace MonoDevelop.Profiler.Gui.Views
+{
+	public class HeapShotSnapshotView : AbstractViewContent, ISnapshotView
+	{
+		private VBox vbox;
+		private Notebook notebook;
+		
+		private HeapShotObjectMapViewer allObjectsTree;
+		private ObjectMapReader map;
+
+		public HeapShotSnapshotView ()
+		{
+			vbox = new VBox ();
+			notebook = new Notebook ();
+			vbox.PackStart (notebook, true, true, 0);
+		}
+		
+		public override bool IsDirty {
+			get { return false; }
+			set {  }
+		}
+		
+		public override string StockIconId {
+			get { return Gtk.Stock.File; }
+		}
+
+		public override Widget Control {
+			get { return vbox; }
+		}
+
+		public override void Load (string fileName)
+		{
+			//ignore
+		}
+
+		public void Initialize (IProfilerSnapshot snapshot)
+		{
+			ContentName = snapshot.Name + " (heap-shot)";
+			map = new ObjectMapReader (snapshot.FileName);
+			
+			HeapShotSummary summary = new HeapShotSummary ();
+			notebook.AppendPage (summary, new Label (GettextCatalog.GetString ("Summary")));
+			
+			allObjectsTree = new HeapShotObjectMapViewer ();
+			allObjectsTree.TypeActivated += OnAllObjectsTreeTypeActivated;
+			notebook.AppendPage (allObjectsTree, new Label (GettextCatalog.GetString ("All objects")));
+			
+			summary.FileName = snapshot.FileName;
+			summary.ObjectCount = map.NumObjects;
+			summary.TotalMemory = map.TotalMemory;
+			
+			allObjectsTree.FillAllTypes (map);
+			
+			vbox.ShowAll ();
+		}
+		
+		public event ProgressEventHandler ProgressEvent {
+			add { allObjectsTree.ProgressEvent += value; }
+			remove { allObjectsTree.ProgressEvent -= value; }
+		}
+
+		protected virtual void OnAllObjectsTreeTypeActivated(object sender, System.EventArgs e)
+		{
+			ShowTypeTree (allObjectsTree.SelectedType, allObjectsTree.InverseReferences);
+		}
+		
+		void ShowTypeTree (string typeName, bool inverse)
+		{
+			foreach (object child in notebook.Children) {
+				HeapShotObjectMapViewer tree = child as HeapShotObjectMapViewer;
+				if (tree != null && tree.RootTypeName == typeName) {
+					tree.InverseReferences = inverse;
+					notebook.Page = notebook.PageNum (tree);
+					return;
+				}
+			}
+			
+			HeapShotObjectMapViewer viewer = new HeapShotObjectMapViewer ();
+			viewer.FillType (map, typeName);
+			viewer.Show ();
+			viewer.TypeActivated += delegate {
+				ShowTypeTree (viewer.SelectedType, viewer.InverseReferences);
+			};
+			
+			TabLabel label = new TabLabel (new Label (typeName), new Gtk.Image (Stock.Class, Gtk.IconSize.Menu));
+			label.Button.Clicked += delegate {
+				notebook.Remove (viewer);
+				viewer.Destroy ();
+			};
+			label.ShowAll ();
+			int i = notebook.AppendPage (viewer, label);
+			notebook.Page = i;
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Codons/ProfilerCodon.cs
===================================================================
--- MonoDevelop.Profiler/Codons/ProfilerCodon.cs	(revision 0)
+++ MonoDevelop.Profiler/Codons/ProfilerCodon.cs	(revision 0)
@@ -0,0 +1,91 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.ComponentModel;
+
+using MonoDevelop.Core;
+using MonoDevelop.Core.Gui;
+using MonoDevelop.Core.AddIns;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Profiler.Gui.Views;
+
+namespace MonoDevelop.Profiler.Codons
+{
+	[CodonNameAttribute ("Profiler")]
+	[Description ("Defines a new profiler.")]
+	internal class ProfilerCodon : AbstractCodon
+	{
+		private IProfiler profiler;
+
+		[Description ("The icon used to visualize all profiler data.")]
+		[XmlMemberAttribute("icon")]
+		string icon = null;
+		
+		[Description ("Display name of the pad.")]
+		[XmlMemberAttribute("label")]
+		string label = null;
+		
+		[Description ("The view used to display the profiler snapshot.")]
+		[XmlMemberAttribute("view")]
+		string viewCls = null;
+		
+		public IProfiler Profiler {
+			get { return profiler; }
+		}
+		
+		public string Label {
+			get { return GettextCatalog.GetString (label); }
+		}
+		
+		public string Icon {
+			get { return icon; }
+		}
+
+		public void Initialize ()
+		{
+			profiler = (IProfiler) AddIn.CreateObject (Class);
+			if (profiler == null)
+				throw new ApplicationException ("Could not create profiler of type: " + Class);
+		}
+		
+		public ISnapshotView CreateSnapshotView ()
+		{
+			ISnapshotView view = (ISnapshotView) AddIn.CreateObject (viewCls);
+			if (view == null) throw new ApplicationException ("Could not create view of type: " + viewCls);
+			return view;
+		}
+		
+		public override object BuildItem (object owner, ArrayList subItems, ConditionCollection conditions)
+		{
+			Initialize ();
+			return this;
+		}
+
+	}
+}
Index: MonoDevelop.Profiler/Profilers/MonoProfilerSnapshot.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/MonoProfilerSnapshot.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/MonoProfilerSnapshot.cs	(revision 0)
@@ -0,0 +1,41 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using MonoDevelop.Core;
+using MonoDevelop.Core.Execution;
+
+namespace MonoDevelop.Profiler.Profilers
+{
+	public class MonoProfilerSnapshot : AbstractProfilerSnapshot
+	{
+		public MonoProfilerSnapshot (IProfiler profiler, string fileName)
+			: base (profiler, fileName)
+		{
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Profilers/HeapShotProfiler.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/HeapShotProfiler.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/HeapShotProfiler.cs	(revision 0)
@@ -0,0 +1,45 @@
+//
+// Authors:
+//   Lluis Sanchez Gual
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using MonoDevelop.Core;
+using MonoDevelop.Core.Execution;
+
+namespace MonoDevelop.Profiler.Profilers
+{
+	public class HeapShotProfiler : AbstractMonoProfiler
+	{
+		public override string ProfilerName {
+			get { return "heap-shot"; }
+		}
+		
+		protected override string DefaultObjectMapFile {
+			get { return "/tmp/md-heap-dump_0.omap"; }
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Profilers/AbstractMonoProfiler.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/AbstractMonoProfiler.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/AbstractMonoProfiler.cs	(revision 0)
@@ -0,0 +1,143 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Threading;
+using MonoDevelop.Core;
+using MonoDevelop.Core.Execution;
+
+namespace MonoDevelop.Profiler.Profilers
+{
+	public abstract class AbstractMonoProfiler : IProfiler
+	{
+		public event EventHandler StartedEvent;
+		public event EventHandler StoppedEvent;
+		
+		public event ProfilerSnapshotEventHandler SnapshotCreated;
+		public event ProfilerProcessEventHandler ProcessIdChanged;
+		
+		private int pid;
+		private bool isRunning;
+		
+		public abstract string ProfilerName { get; }
+		
+		public bool IsRunning {
+			get { return isRunning; }
+		}
+
+		public int ProcessId {
+			get { return pid; }
+			set {
+				if (pid != value) {
+					pid = value;
+					OnProcessIdChanged (new ProfilerProcessEventArgs (this, value));
+				}
+			}
+		}
+
+		public virtual void Start ()
+		{
+			isRunning = true;
+			OnStartedEvent (EventArgs.Empty);
+		}
+		
+		public virtual void Stop ()
+		{
+			isRunning = false;
+			OnStoppedEvent (EventArgs.Empty);
+		}
+
+		public virtual void CreateSnapshot ()
+		{
+			string dumpFile = DefaultObjectMapFile; //FIXME: process output to get the real filename ?
+			if (File.Exists (dumpFile))
+				File.Delete (dumpFile);
+			System.Diagnostics.Process.Start ("kill", "-PROF " + ProcessId);
+			
+			ThreadPool.QueueUserWorkItem (new WaitCallback (AsyncCreateSnapshot), dumpFile);
+		}
+		
+		protected abstract string DefaultObjectMapFile { get; }
+		
+		private void AsyncCreateSnapshot (object state)
+		{
+			string dumpFile = state as string;
+			string destFile = Services.ProfilerService.GetProfileSnapshotLocation ();
+			int tries = 40;
+			bool success = false;
+			
+			while (!success) {
+				if (--tries == 0)
+					return; //TODO: SnapshotError event?
+
+				System.Threading.Thread.Sleep (500);
+				if (!File.Exists (dumpFile))
+					continue;
+
+				try {
+					File.Copy (dumpFile, destFile, true);
+					File.Delete (dumpFile);
+					success = true;
+				} catch (Exception ex) {
+					Runtime.LoggingService.Error ("AbstractMonoProfiler", "AsyncCreateSnapshot Error", ex);
+				}
+			}
+
+			IProfilerSnapshot snapshot = new MonoProfilerSnapshot (this, destFile);
+			OnSnapshotCreated (new ProfilerSnapshotEventArgs (this, snapshot));
+		}
+		
+		public virtual IExecutionHandlerFactory GetExecutionHandlerFactory ()
+		{
+			return new MonoProfilerExecutionHandlerFactory (this);
+		}
+		
+		protected virtual void OnSnapshotCreated (ProfilerSnapshotEventArgs args)
+		{
+			if (SnapshotCreated != null)
+				SnapshotCreated (this, args);
+		}
+		
+		protected virtual void OnProcessIdChanged (ProfilerProcessEventArgs args)
+		{
+			if (ProcessIdChanged != null)
+				ProcessIdChanged (this, args);
+		}
+		
+		protected virtual void OnStartedEvent (EventArgs args)
+		{
+			if (StartedEvent != null)
+				StartedEvent (this, args);
+		}
+		
+		protected virtual void OnStoppedEvent (EventArgs args)
+		{
+			if (StoppedEvent != null)
+				StoppedEvent (this, args);
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Profilers/AbstractProfilerSnapshot.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/AbstractProfilerSnapshot.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/AbstractProfilerSnapshot.cs	(revision 0)
@@ -0,0 +1,59 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using MonoDevelop.Core;
+using MonoDevelop.Core.Execution;
+
+namespace MonoDevelop.Profiler.Profilers
+{
+	public abstract class AbstractProfilerSnapshot : IProfilerSnapshot
+	{
+		private IProfiler profiler;
+		private string fileName;
+
+		protected AbstractProfilerSnapshot (IProfiler profiler, string fileName)
+		{
+			this.profiler = profiler;
+			this.fileName = fileName;
+		}
+		
+		public IProfiler Profiler {
+			get { return profiler; }
+		}
+
+		public string FileName {
+			get { return fileName; }
+		}
+		
+		public string Name {
+			get {
+				return Path.GetFileNameWithoutExtension (fileName);
+			}
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Profilers/HeapShot/TypeInfo.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/HeapShot/TypeInfo.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/HeapShot/TypeInfo.cs	(revision 0)
@@ -0,0 +1,43 @@
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Text.RegularExpressions;
+
+namespace MonoDevelop.Profiler.Profilers.HeapShot
+{
+	public struct TypeInfo
+	{
+		public uint Code;
+		public string Name;
+		public int FieldsIndex;
+		public int FieldsCount;
+		public int ObjectCount;
+		public uint TotalSize;
+	}
+}
Index: MonoDevelop.Profiler/Profilers/HeapShot/FieldInfo.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/HeapShot/FieldInfo.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/HeapShot/FieldInfo.cs	(revision 0)
@@ -0,0 +1,39 @@
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Text.RegularExpressions;
+
+namespace MonoDevelop.Profiler.Profilers.HeapShot
+{		
+	public struct FieldInfo
+	{
+		public ulong Code;
+		public string Name;
+	}
+}
Index: MonoDevelop.Profiler/Profilers/HeapShot/ObjectInfo.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/HeapShot/ObjectInfo.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/HeapShot/ObjectInfo.cs	(revision 0)
@@ -0,0 +1,44 @@
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Text.RegularExpressions;
+
+namespace MonoDevelop.Profiler.Profilers.HeapShot
+{	
+	public struct ObjectInfo
+	{
+		public uint Code;
+		public int Type;
+		public uint Size;
+		public int RefsIndex;
+		public int RefsCount;
+		public int InverseRefsIndex;
+		public int InverseRefsCount;
+	}
+}
Index: MonoDevelop.Profiler/Profilers/HeapShot/ReferenceNode.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/HeapShot/ReferenceNode.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/HeapShot/ReferenceNode.cs	(revision 0)
@@ -0,0 +1,245 @@
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Text.RegularExpressions;
+
+namespace MonoDevelop.Profiler.Profilers.HeapShot
+{	
+	public class ReferenceNode
+	{
+		bool inverse;
+		ObjectMapReader map;
+		
+		public string TypeName;
+		public int RefCount;
+		public int RefsToParent;
+		public int RefsToRoot;
+		public uint RootMemory;
+		public uint TotalMemory;
+		int type;
+		bool globalRefs;
+		
+		public ArrayList references;
+		public ArrayList fieldReferences;
+		public Dictionary<int,RootRefInfo> refObjects = new Dictionary<int,RootRefInfo> ();
+		public Dictionary<int,int> parentObjects = new Dictionary<int,int> ();
+		
+		public ReferenceNode (ObjectMapReader map, int type, bool inverse)
+		{
+			this.map = map;
+			this.type = type;
+			TypeName = map.GetTypeName (type);
+			this.inverse = inverse;
+		}
+		
+		public uint AverageSize {
+			get { return RefCount != 0 ? (uint) (TotalMemory / RefCount) : 0; }
+		}
+		
+		public ICollection FieldReferences {
+			get { return fieldReferences != null ? fieldReferences : (ICollection) Type.EmptyTypes; }
+		}
+		
+		public void AddGlobalReferences ()
+		{
+			RefCount = map.GetObjectCountForType (type);
+			RefsToParent = 0;
+			TotalMemory = map.GetObjectSizeForType (type);
+			globalRefs = true;
+		}
+		
+		public void AddReference (int obj)
+		{
+			AddReference (-1, obj, 1, map.GetObjectSize (obj), null);
+		}
+		
+		void AddReference (int parentObject, int obj, int refsToRoot, uint rootMem, string fieldName)
+		{
+			if (parentObject != -1 && !parentObjects.ContainsKey (parentObject)) {
+				parentObjects [parentObject] = parentObject;
+				RefsToParent++;
+				RefsToRoot += refsToRoot;
+				RootMemory += rootMem;
+			}
+
+			if (fieldName != null) {
+				// Update field reference count
+				bool ffound = false;
+				if (fieldReferences != null) {
+					foreach (FieldReference f in fieldReferences) {
+						if (f.FiledName == fieldName) {
+							f.RefCount++;
+							ffound = true;
+							break;
+						}
+					}
+				}
+				if (!ffound) {
+					FieldReference f = new FieldReference ();
+					f.FiledName = fieldName;
+					f.RefCount = 1;
+					if (fieldReferences == null)
+						fieldReferences = new ArrayList ();
+					fieldReferences.Add (f);
+				}
+			}
+			
+			if (refObjects.ContainsKey (obj)) {
+				RootRefInfo ri = refObjects [obj];
+				ri.References += refsToRoot;
+				ri.Memory += rootMem;
+				refObjects [obj] = ri;
+				return;
+			}
+
+			RefCount++;
+			
+			RootRefInfo rr = new RootRefInfo ();
+			rr.References = refsToRoot;
+			rr.Memory = rootMem;
+			refObjects.Add (obj, rr);
+			TotalMemory += map.GetObjectSize (obj);
+		}
+		
+		public bool HasReferences {
+			get {
+				return true;
+			}
+		}
+		
+		public ArrayList References {
+			get {
+				if (references != null)
+					return references;
+
+				if (globalRefs) {
+					RefsToParent = 0;
+					RefCount = 0;
+					TotalMemory = 0;
+					foreach (int obj in map.GetObjectsByType (type))
+						AddReference (obj);
+					globalRefs = false;
+				}
+				
+				references = new ArrayList ();
+				foreach (KeyValuePair<int,RootRefInfo> entry in refObjects) {
+					int obj = entry.Key;
+					if (inverse) {
+						foreach (int oref in map.GetReferencers (obj)) {
+							ReferenceNode cnode = GetReferenceNode (oref);
+							string fname = map.GetReferencerField (oref, obj);
+							cnode.AddReference (obj, oref, entry.Value.References, entry.Value.Memory, fname);
+						}
+					} else {
+						foreach (int oref in map.GetReferences (obj)) {
+							ReferenceNode cnode = GetReferenceNode (oref);
+							string fname = map.GetReferencerField (obj, oref);
+							cnode.AddReference (obj, oref, 0, 0, fname);
+						}
+					}
+				}
+				foreach (ReferenceNode r in references)
+					r.Flush ();
+
+				refObjects = null;
+				return references;
+			}
+		}
+		
+		public void Flush ()
+		{
+			parentObjects = null;
+		}
+		
+		public ReferenceNode GetReferenceNode (int obj)
+		{
+			string name = map.GetObjectTypeName (obj);
+			foreach (ReferenceNode cnode in references) {
+				if (cnode.TypeName == name)
+					return cnode;
+			}
+			ReferenceNode nod = new ReferenceNode (map, map.GetObjectType (obj), inverse);
+			references.Add (nod);
+			return nod;
+		}
+		
+		public void Print (int maxLevels)
+		{
+			Print (0, maxLevels);
+		}
+		
+		void Print (int level, int maxLevels)
+		{
+			Console.Write (new string (' ', level*3));
+			Console.WriteLine (RefCount + " " + TypeName);
+			if (fieldReferences != null && fieldReferences.Count != 0) {
+				Console.Write (new string (' ', level*3) + new string (' ', RefCount.ToString().Length) + " ");
+				Console.Write ("(");
+				for (int n=0; n<fieldReferences.Count; n++) {
+					if (n > 0) Console.Write (", ");
+					FieldReference f = (FieldReference) fieldReferences [n];
+					Console.Write (f.FiledName + ":" + f.RefCount);
+				}
+				Console.WriteLine (")");
+			}
+			if (level < maxLevels) {
+				foreach (ReferenceNode cnode in References)
+					cnode.Print (level + 1, maxLevels);
+			}
+		}
+	}
+	
+	public class FieldReference
+	{
+		public int RefCount;
+		public string FiledName;
+	}
+	
+	public struct RootRefInfo
+	{
+		public int References;
+		public uint Memory;
+	}
+	
+	class ReferenceSorter: IComparer
+	{
+		public int Compare (object x, object y)
+		{
+			ReferenceNode t1 = (ReferenceNode) x;
+			ReferenceNode t2 = (ReferenceNode) y;
+			if (t1.RefCount == t2.RefCount)
+				return 0;
+			else if (t1.RefCount > t2.RefCount)
+				return -1;
+			else
+				return 1;
+		}
+	}
+}
Index: MonoDevelop.Profiler/Profilers/HeapShot/ObjectReference.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/HeapShot/ObjectReference.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/HeapShot/ObjectReference.cs	(revision 0)
@@ -0,0 +1,39 @@
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.IO;
+using System.Text.RegularExpressions;
+
+namespace MonoDevelop.Profiler.Profilers.HeapShot
+{	
+	public struct ObjectReference {
+		internal uint FieldCode;
+		internal uint ObjectCode;
+		public ObjectInfo Object;
+	}
+}
Index: MonoDevelop.Profiler/Profilers/HeapShot/ObjectMapFileReader.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/HeapShot/ObjectMapFileReader.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/HeapShot/ObjectMapFileReader.cs	(revision 0)
@@ -0,0 +1,605 @@
+//
+// Author:
+//   Lluis Sanchez Gual
+//
+// Copyright (C) 2005 Novell, Inc (http://www.novell.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Text.RegularExpressions;
+
+namespace MonoDevelop.Profiler.Profilers.HeapShot
+{	
+	public class ObjectMapReader 
+	{
+		const uint magic_number = 0x4eabfdd1;
+		const int expected_log_version = 6;
+		const int expected_summary_version = 2;
+		const string log_file_label = "heap-shot logfile";
+		
+		bool terminated_normally = true;
+		string name;
+		DateTime timestamp;
+		uint numTypes;
+		uint numObjects;
+		uint numReferences;
+		uint numFields;
+		uint totalMemory;
+		uint objectCount;
+		
+		int curObject;
+		int curType;
+		int curField;
+		int curRef;
+		
+		ObjectInfo[] objects;
+		TypeInfo[] types;
+		string[] fieldNames;
+		int[] objectIndices;
+		int[] typeIndices;
+		int[] references;
+		int[] inverseRefs;
+		int[] fieldReferences;
+		bool[] filteredObjects;
+		
+		uint[] referenceCodes;
+		uint[] objectTypeCodes;
+		uint[] fieldCodes;
+		uint[] fieldReferenceCodes;
+		uint[] objectCodes;
+		
+		internal ObjectMapReader ()
+		{
+		}
+		
+		public ObjectMapReader (string filename)
+		{
+			this.name = filename;
+			
+			Stream stream;
+			stream = new FileStream (filename, FileMode.Open, FileAccess.Read);
+
+			BinaryReader reader;
+			reader = new BinaryReader (stream);
+			
+			ReadPreamble (reader);
+			ReadLogFile (reader);
+			
+			reader.Close ();
+			
+			timestamp = File.GetLastWriteTime (filename);
+		}
+		
+		public string Name {
+			get { return name; }
+		}
+		
+		public DateTime Timestamp {
+			get { return timestamp; }
+		}
+		
+		public uint TotalMemory {
+			get { return totalMemory; }
+		}
+		
+		public uint NumObjects {
+			get { return objectCount; }
+		}
+		
+		public static ObjectMapReader CreateProcessSnapshot (int pid)
+		{
+			string dumpFile = "/tmp/heap-shot-dump";
+			if (File.Exists (dumpFile))
+				File.Delete (dumpFile);
+			System.Diagnostics.Process.Start ("kill", "-PROF " + pid);
+			
+			string fileName = null;
+			int tries = 40;
+			
+			while (fileName == null) {
+				if (--tries == 0)
+					return null;
+
+				System.Threading.Thread.Sleep (500);
+				if (!File.Exists (dumpFile))
+					continue;
+					
+				StreamReader freader = null;
+				try {
+					freader = new StreamReader (dumpFile);
+					fileName = freader.ReadToEnd ();
+					freader.Close ();
+				} catch {
+					if (freader != null)
+						freader.Close ();
+				}
+			}
+			return new ObjectMapReader (fileName);
+		}
+
+		///////////////////////////////////////////////////////////////////
+
+		private void Spew (string format, params object [] args)
+		{
+			string message;
+			message = String.Format (format, args);
+			Console.WriteLine (message);
+		}
+
+		///////////////////////////////////////////////////////////////////
+
+		private void ReadPreamble (BinaryReader reader)
+		{
+			uint this_magic;
+			this_magic = reader.ReadUInt32 ();
+			if (this_magic != magic_number) {
+				string msg;
+				msg = String.Format ("Bad magic number: expected {0}, found {1}",
+						     magic_number, this_magic);
+				throw new Exception (msg);
+			}
+
+			int this_version;
+			this_version = reader.ReadInt32 ();
+
+			string this_label;
+			int expected_version;
+
+			this_label = reader.ReadString ();
+			if (this_label == log_file_label) {
+				expected_version = expected_log_version;
+			} else
+				throw new Exception ("Unknown file label in heap-shot outfile");
+
+			if (this_version != expected_version) {
+				string msg;
+				msg = String.Format ("Version error in {0}: expected {1}, found {2}",
+						     this_label, expected_version, this_version);
+				throw new Exception (msg);
+			}
+			numTypes = reader.ReadUInt32 ();
+			numObjects = reader.ReadUInt32 ();
+			numReferences = reader.ReadUInt32 ();
+			numFields = reader.ReadUInt32 ();
+			objectCount = numObjects;
+		}
+
+		//
+		// Code to read the log files generated at runtime
+		//
+
+		// These need to agree w/ the definitions in outfile-writer.c
+		const byte TAG_TYPE      = 0x01;
+		const byte TAG_OBJECT    = 0x02;
+		const byte TAG_EOS       = 0xff;
+
+		private void ReadLogFile (BinaryReader reader)
+		{
+			int chunk_count = 0;
+			
+			objects = new ObjectInfo [numObjects];
+			types = new TypeInfo [numTypes];
+			objectTypeCodes = new uint [numObjects];
+			referenceCodes = new uint [numReferences];
+			fieldReferenceCodes = new uint [numReferences];
+			fieldCodes = new uint [numFields];
+			fieldNames = new string [numFields];
+
+			try {
+				while (ReadLogFileChunk (reader))
+					++chunk_count;
+
+			} catch (System.IO.EndOfStreamException) {
+				// This means that the outfile was truncated.
+				// In that case, just do nothing --- except if the file
+				// claimed that things terminated normally.
+				if (terminated_normally)
+					throw new Exception ("The heap log did not contain TAG_EOS, "
+							     + "but the outfile was marked as having been terminated normally, so "
+							     + "something must be terribly wrong.");
+			}
+			BuildMap ();
+			Spew ("Processed {0} chunks", chunk_count);
+			
+			objectTypeCodes = null;
+			referenceCodes = null;
+			fieldReferenceCodes = null;
+			fieldCodes = null;
+		}
+
+		private bool ReadLogFileChunk (BinaryReader reader)
+		{
+			byte tag = reader.ReadByte ();
+
+			switch (tag) {
+			case TAG_TYPE:
+				ReadLogFileChunk_Type (reader);
+				break;
+					
+			case TAG_OBJECT:
+				ReadLogFileChunk_Object (reader);
+				break;
+				
+			case TAG_EOS:
+				//Spew ("Found EOS");
+				return false;
+
+			default:
+				throw new Exception ("Unknown tag! " + tag);
+			}
+
+			return true;
+		}
+		
+		private void ReadLogFileChunk_Type (BinaryReader reader)
+		{
+			uint code = reader.ReadUInt32 ();
+			string name = reader.ReadString ();
+			
+			types [curType].Code = code;
+			types [curType].Name = name;
+			types [curType].FieldsIndex = curField;
+			
+			int nf = 0;
+			uint fcode;
+			while ((fcode = reader.ReadUInt32 ()) != 0) {
+				fieldCodes [curField] = fcode;
+				fieldNames [curField] = reader.ReadString ();
+				curField++;
+				nf++;
+			}
+			types [curType].FieldsCount = nf;
+			curType++;
+		}
+		
+		private void ReadLogFileChunk_Object (BinaryReader reader)
+		{
+			objects [curObject].Code = reader.ReadUInt32 ();
+			objectTypeCodes [curObject] = reader.ReadUInt32 ();
+			objects [curObject].Size = reader.ReadUInt32 ();
+			objects [curObject].RefsIndex = curRef;
+			totalMemory += objects [curObject].Size;
+			
+			// Read referenceCodes
+			
+			int nr = 0;
+			uint oref;
+			while ((oref = reader.ReadUInt32 ()) != 0) {
+				referenceCodes [curRef] = oref;
+				fieldReferenceCodes [curRef] = reader.ReadUInt32 ();
+				nr++;
+				curRef++;
+			}
+			objects [curObject].RefsCount = nr;
+			curObject++;
+		}
+		
+		void BuildMap ()
+		{
+			// Build an array of object indices and sort it
+			
+			RefComparer objectComparer = new RefComparer ();
+			objectComparer.objects = objects;
+			
+			objectIndices = new int [numObjects];
+			for (int n=0; n < numObjects; n++)
+				objectIndices [n] = n;
+			Array.Sort<int> (objectIndices, objectComparer);
+			// Sorted array of codes needed for the binary search
+			objectCodes = new uint [numObjects];	
+			for (int n=0; n < numObjects; n++)
+				objectCodes [n] = objects [objectIndices[n]].Code;
+			
+			// Build an array of type indices and sort it
+			
+			TypeComparer typeComparer = new TypeComparer ();
+			typeComparer.types = types;
+			
+			typeIndices = new int [numTypes];
+			for (int n=0; n < numTypes; n++)
+				typeIndices [n] = n;
+			Array.Sort<int> (typeIndices, typeComparer);
+			// Sorted array of codes needed for the binary search
+			uint[] typeCodes = new uint [numTypes];	
+			for (int n=0; n < numTypes; n++) {
+				typeCodes [n] = types [typeIndices[n]].Code;
+			}
+			
+			// Assign the type index to each object
+			
+			for (int n=0; n<numObjects; n++) {
+				int i = Array.BinarySearch<uint> (typeCodes, objectTypeCodes [n]);
+				if (i >= 0) {
+					objects [n].Type = typeIndices [i];
+					types [objects [n].Type].ObjectCount++;
+					types [objects [n].Type].TotalSize += objects [n].Size;
+				}
+			}
+			
+			// Build the array of referenceCodes, but using indexes
+			references = new int [numReferences];
+			
+			for (int n=0; n<numReferences; n++) {
+				int i = Array.BinarySearch (objectCodes, referenceCodes[n]);
+				if (i >= 0) {
+					references[n] = objectIndices [i];
+					objects [objectIndices [i]].InverseRefsCount++;
+				} else
+					references[n] = -1;
+			}
+			
+			// Calculate the array index of inverse referenceCodes for each object
+			
+			int[] invPositions = new int [numObjects];	// Temporary array to hold reference positions
+			int rp = 0;
+			for (int n=0; n<numObjects; n++) {
+				objects [n].InverseRefsIndex = rp;
+				invPositions [n] = rp;
+				rp += objects [n].InverseRefsCount;
+			}
+			
+			// Build the array of inverse referenceCodes
+			// Also calculate the index of each field name
+			
+			inverseRefs = new int [numReferences];
+			fieldReferences = new int [numReferences];
+			
+			for (int ob=0; ob < numObjects; ob++) {
+				int fi = types [objects [ob].Type].FieldsIndex;
+				int nf = fi + types [objects [ob].Type].FieldsCount;
+				int sr = objects [ob].RefsIndex;
+				int er = sr + objects [ob].RefsCount;
+				for (; sr<er; sr++) {
+					int i = references [sr];
+					if (i != -1) {
+						inverseRefs [invPositions [i]] = ob;
+						invPositions [i]++;
+					}
+					// If the reference is bound to a field, locate the field
+					uint fr = fieldReferenceCodes [sr];
+					if (fr != 0) {
+						for (int k=fi; k<nf; k++) {
+							if (fieldCodes [k] == fr) {
+								fieldReferences [sr] = k;
+								break;
+							}
+						}
+					}
+				}
+			}
+		}
+		
+		class RefComparer: IComparer <int> {
+			public ObjectInfo[] objects;
+			
+			public int Compare (int x, int y) {
+				return objects [x].Code.CompareTo (objects [y].Code);
+			}
+		}
+		
+		class TypeComparer: IComparer <int> {
+			public TypeInfo[] types;
+			
+			public int Compare (int x, int y) {
+				return types [x].Code.CompareTo (types [y].Code);
+			}
+		}
+		
+		public ReferenceNode GetReferenceTree (string typeName, bool inverse)
+		{
+			int type = GetTypeFromName (typeName);
+			if (type != -1)
+				return GetReferenceTree (type, inverse);
+			else
+				return new ReferenceNode (this, type, inverse);
+		}
+		
+		public ReferenceNode GetReferenceTree (int type, bool inverse)
+		{
+			ReferenceNode nod = new ReferenceNode (this, type, inverse);
+			nod.AddGlobalReferences ();
+			nod.Flush ();
+			return nod;
+		}
+		
+		public List<List<int>> GetRoots (int type)
+		{
+			List<int> path = new List<int> ();
+			Dictionary<int,List<int>> roots = new Dictionary<int,List<int>> ();
+			Dictionary<int,int> visited = new Dictionary<int,int> ();
+			
+			foreach (int obj in GetObjectsByType (type)) {
+				FindRoot (visited, path, roots, obj);
+				visited.Clear ();
+			}
+			
+			List<List<int>> res = new List<List<int>> ();
+			res.AddRange (roots.Values);
+			return res;
+		}
+		
+		void FindRoot (Dictionary<int,int> visited, List<int> path, Dictionary<int,List<int>> roots, int obj)
+		{
+			if (visited.ContainsKey (obj))
+				return;
+			visited [obj] = obj;
+			path.Add (obj);
+			
+			bool hasrefs = false;
+			foreach (int oref in GetReferencers (obj)) {
+				hasrefs = true;
+				FindRoot (visited, path, roots, oref);
+			}
+			
+			if (!hasrefs) {
+				// A root
+				if (!roots.ContainsKey (obj)) {
+					roots [obj] = new List<int> (path);
+				} else {
+					List<int> ep = roots [obj];
+					if (ep.Count > path.Count)
+						roots [obj] = new List<int> (path);
+				}
+			}
+			path.RemoveAt (path.Count - 1);
+		}		
+		
+		public int GetTypeCount ()
+		{
+			return (int) numTypes;
+		}
+		
+		public int GetTypeFromName (string name)
+		{
+			for (int n=0; n<numTypes; n++) {
+				if (name == types [n].Name)
+					return n;
+			}
+			return -1;
+		}
+		
+		public IEnumerable<int> GetObjectsByType (int type)
+		{
+			for (int n=0; n<numObjects; n++) {
+				if (objects [n].Type == type && (filteredObjects == null || !filteredObjects[n])) {
+					yield return n;
+				}
+			}
+		}
+		
+		public static ObjectMapReader GetDiff (ObjectMapReader oldMap, ObjectMapReader newMap)
+		{
+			ObjectMapReader dif = new ObjectMapReader ();
+			dif.fieldNames = newMap.fieldNames;
+			dif.fieldReferences = newMap.fieldReferences;
+			dif.inverseRefs = newMap.inverseRefs;
+			dif.numFields = newMap.numFields;
+			dif.numObjects = newMap.numObjects;
+			dif.numReferences = newMap.numReferences;
+			dif.numTypes = newMap.numTypes;
+			dif.objectCount = newMap.objectCount;
+			dif.objectIndices = newMap.objectIndices;
+			dif.objects = newMap.objects;
+			dif.objectCodes = newMap.objectCodes;
+			dif.references = newMap.references;
+			dif.totalMemory = newMap.totalMemory;
+			dif.typeIndices = newMap.typeIndices;
+			dif.types = newMap.types;
+			dif.RemoveData (oldMap);
+			return dif;
+		}
+		
+		public void RemoveData (ObjectMapReader otherReader)
+		{
+			types = (TypeInfo[]) types.Clone ();
+			filteredObjects = new bool [numObjects];
+			for (int n=0; n<otherReader.numObjects; n++) {
+				int i = Array.BinarySearch (objectCodes, otherReader.objects[n].Code);
+				if (i >= 0) {
+					i = objectIndices [i];
+					filteredObjects [i] = true;
+					int t = objects[i].Type;
+					types [t].ObjectCount--;
+					types [t].TotalSize -= objects[i].Size;
+					this.objectCount--;
+					this.totalMemory -= objects[i].Size;
+				}
+			}
+		}
+		
+		public IEnumerable<int> GetReferencers (int obj)
+		{
+			int n = objects [obj].InverseRefsIndex;
+			int end = n + objects [obj].InverseRefsCount;
+			for (; n<end; n++) {
+				int ro = inverseRefs [n];
+				if (filteredObjects == null || !filteredObjects [ro])
+					yield return ro;
+			}
+		}
+		
+		public IEnumerable<int> GetReferences (int obj)
+		{
+			int n = objects [obj].RefsIndex;
+			int end = n + objects [obj].RefsCount;
+			for (; n<end; n++) {
+				int ro = references [n];
+				if (filteredObjects == null || !filteredObjects [ro])
+					yield return ro;
+			}
+		}
+		
+		public string GetReferencerField (int obj, int refObj)
+		{
+			int n = objects [obj].RefsIndex;
+			int end = n + objects [obj].RefsCount;
+			for (; n<end; n++) {
+				if (references [n] == refObj) {
+					if (fieldReferences [n] != 0)
+						return fieldNames [fieldReferences [n]];
+					else
+						return null;
+				}
+			}
+			return null;
+		}
+		
+		public string GetObjectTypeName (int obj)
+		{
+			return types [objects [obj].Type].Name;
+		}
+		
+		public int GetObjectType (int obj)
+		{
+			return objects [obj].Type;
+		}
+		
+		public uint GetObjectSize (int obj)
+		{
+			return objects [obj].Size;
+		}
+		
+		public IEnumerable<int> GetTypes ()
+		{
+			for (int n=0; n<numTypes; n++)
+				yield return n;
+		}
+		
+		public string GetTypeName (int type)
+		{
+			return types [type].Name;
+		}
+		
+		public int GetObjectCountForType (int type)
+		{
+			return types [type].ObjectCount;
+		}
+		
+		public uint GetObjectSizeForType (int type)
+		{
+			return types [type].TotalSize;
+		}
+	}
+}
Index: MonoDevelop.Profiler/Profilers/HeapBuddyProfiler.cs
===================================================================
--- MonoDevelop.Profiler/Profilers/HeapBuddyProfiler.cs	(revision 0)
+++ MonoDevelop.Profiler/Profilers/HeapBuddyProfiler.cs	(revision 0)
@@ -0,0 +1,43 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using MonoDevelop.Core;
+using MonoDevelop.Core.Execution;
+
+namespace MonoDevelop.Profiler.Profilers
+{
+	public class HeapBuddyProfiler : AbstractMonoProfiler
+	{
+		public override string ProfilerName {
+			get { return "heap-buddy"; }
+		}
+
+		protected override string DefaultObjectMapFile {
+			get { return "/tmp/md-heap-dump"; }
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/gtk-gui/generated.cs
===================================================================
--- MonoDevelop.Profiler/gtk-gui/generated.cs	(revision 0)
+++ MonoDevelop.Profiler/gtk-gui/generated.cs	(revision 0)
@@ -0,0 +1,82 @@
+// ------------------------------------------------------------------------------
+//  <autogenerated>
+//      This code was generated by a tool.
+//      Mono Runtime Version: 2.0.50727.42
+// 
+//      Changes to this file may cause incorrect behavior and will be lost if 
+//      the code is regenerated.
+//  </autogenerated>
+// ------------------------------------------------------------------------------
+
+namespace Stetic {
+    
+    
+    internal class Gui {
+        
+        private static bool initialized;
+        
+        internal static void Initialize() {
+            if ((Stetic.Gui.initialized == false)) {
+                Stetic.Gui.initialized = true;
+            }
+        }
+    }
+    
+    internal class BinContainer {
+        
+        private Gtk.Widget child;
+        
+        private Gtk.UIManager uimanager;
+        
+        public static BinContainer Attach(Gtk.Bin bin) {
+            BinContainer bc = new BinContainer();
+            bin.SizeRequested += new Gtk.SizeRequestedHandler(bc.OnSizeRequested);
+            bin.SizeAllocated += new Gtk.SizeAllocatedHandler(bc.OnSizeAllocated);
+            bin.Added += new Gtk.AddedHandler(bc.OnAdded);
+            return bc;
+        }
+        
+        private void OnSizeRequested(object sender, Gtk.SizeRequestedArgs args) {
+            if ((this.child != null)) {
+                args.Requisition = this.child.SizeRequest();
+            }
+        }
+        
+        private void OnSizeAllocated(object sender, Gtk.SizeAllocatedArgs args) {
+            if ((this.child != null)) {
+                this.child.Allocation = args.Allocation;
+            }
+        }
+        
+        private void OnAdded(object sender, Gtk.AddedArgs args) {
+            this.child = args.Widget;
+        }
+        
+        public void SetUiManager(Gtk.UIManager uim) {
+            this.uimanager = uim;
+            this.child.Realized += new System.EventHandler(this.OnRealized);
+        }
+        
+        private void OnRealized(object sender, System.EventArgs args) {
+            if ((this.uimanager != null)) {
+                Gtk.Widget w;
+                w = this.child.Toplevel;
+                if (((w != null) && typeof(Gtk.Window).IsInstanceOfType(w))) {
+                    ((Gtk.Window)(w)).AddAccelGroup(this.uimanager.AccelGroup);
+                    this.uimanager = null;
+                }
+            }
+        }
+    }
+    
+    internal class ActionGroups {
+        
+        public static Gtk.ActionGroup GetActionGroup(System.Type type) {
+            return Stetic.ActionGroups.GetActionGroup(type.FullName);
+        }
+        
+        public static Gtk.ActionGroup GetActionGroup(string name) {
+            return null;
+        }
+    }
+}
Index: MonoDevelop.Profiler/gtk-gui/MonoDevelop.Profiler.HeapShotSummary.cs
===================================================================
--- MonoDevelop.Profiler/gtk-gui/MonoDevelop.Profiler.HeapShotSummary.cs	(revision 0)
+++ MonoDevelop.Profiler/gtk-gui/MonoDevelop.Profiler.HeapShotSummary.cs	(revision 0)
@@ -0,0 +1,117 @@
+// ------------------------------------------------------------------------------
+//  <autogenerated>
+//      This code was generated by a tool.
+//      Mono Runtime Version: 2.0.50727.42
+// 
+//      Changes to this file may cause incorrect behavior and will be lost if 
+//      the code is regenerated.
+//  </autogenerated>
+// ------------------------------------------------------------------------------
+
+namespace MonoDevelop.Profiler {
+    
+    
+    public partial class HeapShotSummary {
+        
+        private Gtk.Table table1;
+        
+        private Gtk.Label label1;
+        
+        private Gtk.Label label4;
+        
+        private Gtk.Label label6;
+        
+        private Gtk.Label labelCount;
+        
+        private Gtk.Label labelMemory;
+        
+        private Gtk.Label labelName;
+        
+        protected virtual void Build() {
+            Stetic.Gui.Initialize();
+            // Widget MonoDevelop.Profiler.HeapShotSummary
+            Stetic.BinContainer.Attach(this);
+            this.Events = ((Gdk.EventMask)(256));
+            this.Name = "MonoDevelop.Profiler.HeapShotSummary";
+            // Container child MonoDevelop.Profiler.HeapShotSummary.Gtk.Container+ContainerChild
+            this.table1 = new Gtk.Table(((uint)(3)), ((uint)(2)), false);
+            this.table1.Name = "table1";
+            this.table1.RowSpacing = ((uint)(6));
+            this.table1.ColumnSpacing = ((uint)(6));
+            this.table1.BorderWidth = ((uint)(6));
+            // Container child table1.Gtk.Table+TableChild
+            this.label1 = new Gtk.Label();
+            this.label1.Name = "label1";
+            this.label1.Xalign = 0F;
+            this.label1.LabelProp = Mono.Unix.Catalog.GetString("Name:");
+            this.table1.Add(this.label1);
+            Gtk.Table.TableChild w1 = ((Gtk.Table.TableChild)(this.table1[this.label1]));
+            w1.XOptions = ((Gtk.AttachOptions)(4));
+            w1.YOptions = ((Gtk.AttachOptions)(4));
+            // Container child table1.Gtk.Table+TableChild
+            this.label4 = new Gtk.Label();
+            this.label4.Name = "label4";
+            this.label4.Xalign = 0F;
+            this.label4.LabelProp = Mono.Unix.Catalog.GetString("Object count:");
+            this.table1.Add(this.label4);
+            Gtk.Table.TableChild w2 = ((Gtk.Table.TableChild)(this.table1[this.label4]));
+            w2.TopAttach = ((uint)(1));
+            w2.BottomAttach = ((uint)(2));
+            w2.XOptions = ((Gtk.AttachOptions)(4));
+            w2.YOptions = ((Gtk.AttachOptions)(4));
+            // Container child table1.Gtk.Table+TableChild
+            this.label6 = new Gtk.Label();
+            this.label6.Name = "label6";
+            this.label6.Xalign = 0F;
+            this.label6.LabelProp = Mono.Unix.Catalog.GetString("Total memory:");
+            this.table1.Add(this.label6);
+            Gtk.Table.TableChild w3 = ((Gtk.Table.TableChild)(this.table1[this.label6]));
+            w3.TopAttach = ((uint)(2));
+            w3.BottomAttach = ((uint)(3));
+            w3.XOptions = ((Gtk.AttachOptions)(4));
+            w3.YOptions = ((Gtk.AttachOptions)(4));
+            // Container child table1.Gtk.Table+TableChild
+            this.labelCount = new Gtk.Label();
+            this.labelCount.Name = "labelCount";
+            this.labelCount.Xalign = 0F;
+            this.labelCount.LabelProp = "";
+            this.table1.Add(this.labelCount);
+            Gtk.Table.TableChild w4 = ((Gtk.Table.TableChild)(this.table1[this.labelCount]));
+            w4.TopAttach = ((uint)(1));
+            w4.BottomAttach = ((uint)(2));
+            w4.LeftAttach = ((uint)(1));
+            w4.RightAttach = ((uint)(2));
+            w4.XOptions = ((Gtk.AttachOptions)(4));
+            w4.YOptions = ((Gtk.AttachOptions)(4));
+            // Container child table1.Gtk.Table+TableChild
+            this.labelMemory = new Gtk.Label();
+            this.labelMemory.Name = "labelMemory";
+            this.labelMemory.Xalign = 0F;
+            this.labelMemory.LabelProp = "";
+            this.table1.Add(this.labelMemory);
+            Gtk.Table.TableChild w5 = ((Gtk.Table.TableChild)(this.table1[this.labelMemory]));
+            w5.TopAttach = ((uint)(2));
+            w5.BottomAttach = ((uint)(3));
+            w5.LeftAttach = ((uint)(1));
+            w5.RightAttach = ((uint)(2));
+            w5.XOptions = ((Gtk.AttachOptions)(4));
+            w5.YOptions = ((Gtk.AttachOptions)(4));
+            // Container child table1.Gtk.Table+TableChild
+            this.labelName = new Gtk.Label();
+            this.labelName.Name = "labelName";
+            this.labelName.Xalign = 0F;
+            this.labelName.LabelProp = "";
+            this.table1.Add(this.labelName);
+            Gtk.Table.TableChild w6 = ((Gtk.Table.TableChild)(this.table1[this.labelName]));
+            w6.LeftAttach = ((uint)(1));
+            w6.RightAttach = ((uint)(2));
+            w6.XOptions = ((Gtk.AttachOptions)(4));
+            w6.YOptions = ((Gtk.AttachOptions)(4));
+            this.Add(this.table1);
+            if ((this.Child != null)) {
+                this.Child.ShowAll();
+            }
+            this.Show();
+        }
+    }
+}
Index: MonoDevelop.Profiler/gtk-gui/objects.xml
===================================================================
--- MonoDevelop.Profiler/gtk-gui/objects.xml	(revision 0)
+++ MonoDevelop.Profiler/gtk-gui/objects.xml	(revision 0)
@@ -0,0 +1,19 @@
+<objects>
+  <object type="MonoDevelop.Profiler.HeapShotSummary" palette-category="widget" allow-children="false" base-type="Gtk.Bin">
+    <itemgroups />
+    <signals />
+  </object>
+  <object type="MonoDevelop.Profiler.HeapShotObjectMapViewer" palette-category="widget" allow-children="false" base-type="Gtk.Bin">
+    <itemgroups>
+      <itemgroup label="HeapShotObjectMapViewer Properties">
+        <property name="InverseReferences" />
+      </itemgroup>
+    </itemgroups>
+    <signals>
+      <itemgroup label="HeapShotObjectMapViewer Signals">
+        <signal name="ProgressEvent" />
+        <signal name="TypeActivated" />
+      </itemgroup>
+    </signals>
+  </object>
+</objects>
\ No newline at end of file
Index: MonoDevelop.Profiler/gtk-gui/MonoDevelop.Profiler.HeapShotObjectMapViewer.cs
===================================================================
--- MonoDevelop.Profiler/gtk-gui/MonoDevelop.Profiler.HeapShotObjectMapViewer.cs	(revision 0)
+++ MonoDevelop.Profiler/gtk-gui/MonoDevelop.Profiler.HeapShotObjectMapViewer.cs	(revision 0)
@@ -0,0 +1,117 @@
+// ------------------------------------------------------------------------------
+//  <autogenerated>
+//      This code was generated by a tool.
+//      Mono Runtime Version: 2.0.50727.42
+// 
+//      Changes to this file may cause incorrect behavior and will be lost if 
+//      the code is regenerated.
+//  </autogenerated>
+// ------------------------------------------------------------------------------
+
+namespace MonoDevelop.Profiler {
+    
+    
+    public partial class HeapShotObjectMapViewer {
+        
+        private Gtk.VBox vbox1;
+        
+        private Gtk.ScrolledWindow scrolledwindow1;
+        
+        private Gtk.TreeView treeview;
+        
+        private Gtk.HBox hbox1;
+        
+        private Gtk.HBox boxFilter;
+        
+        private Gtk.Entry entryFilter;
+        
+        private Gtk.Button buttonFilter;
+        
+        private Gtk.CheckButton checkInverse;
+        
+        protected virtual void Build() {
+            Stetic.Gui.Initialize();
+            // Widget MonoDevelop.Profiler.HeapShotObjectMapViewer
+            Stetic.BinContainer.Attach(this);
+            this.Events = ((Gdk.EventMask)(256));
+            this.Name = "MonoDevelop.Profiler.HeapShotObjectMapViewer";
+            // Container child MonoDevelop.Profiler.HeapShotObjectMapViewer.Gtk.Container+ContainerChild
+            this.vbox1 = new Gtk.VBox();
+            this.vbox1.Name = "vbox1";
+            this.vbox1.Spacing = 6;
+            this.vbox1.BorderWidth = ((uint)(6));
+            // Container child vbox1.Gtk.Box+BoxChild
+            this.scrolledwindow1 = new Gtk.ScrolledWindow();
+            this.scrolledwindow1.CanFocus = true;
+            this.scrolledwindow1.Name = "scrolledwindow1";
+            this.scrolledwindow1.VscrollbarPolicy = ((Gtk.PolicyType)(1));
+            this.scrolledwindow1.HscrollbarPolicy = ((Gtk.PolicyType)(1));
+            this.scrolledwindow1.ShadowType = ((Gtk.ShadowType)(1));
+            // Container child scrolledwindow1.Gtk.Container+ContainerChild
+            this.treeview = new Gtk.TreeView();
+            this.treeview.CanFocus = true;
+            this.treeview.Events = ((Gdk.EventMask)(8196));
+            this.treeview.Name = "treeview";
+            this.scrolledwindow1.Add(this.treeview);
+            this.vbox1.Add(this.scrolledwindow1);
+            Gtk.Box.BoxChild w2 = ((Gtk.Box.BoxChild)(this.vbox1[this.scrolledwindow1]));
+            w2.Position = 0;
+            // Container child vbox1.Gtk.Box+BoxChild
+            this.hbox1 = new Gtk.HBox();
+            this.hbox1.Name = "hbox1";
+            this.hbox1.Spacing = 6;
+            // Container child hbox1.Gtk.Box+BoxChild
+            this.boxFilter = new Gtk.HBox();
+            this.boxFilter.Name = "boxFilter";
+            this.boxFilter.Spacing = 3;
+            // Container child boxFilter.Gtk.Box+BoxChild
+            this.entryFilter = new Gtk.Entry();
+            this.entryFilter.CanFocus = true;
+            this.entryFilter.Name = "entryFilter";
+            this.entryFilter.IsEditable = true;
+            this.entryFilter.InvisibleChar = '●';
+            this.boxFilter.Add(this.entryFilter);
+            Gtk.Box.BoxChild w3 = ((Gtk.Box.BoxChild)(this.boxFilter[this.entryFilter]));
+            w3.Position = 0;
+            // Container child boxFilter.Gtk.Box+BoxChild
+            this.buttonFilter = new Gtk.Button();
+            this.buttonFilter.CanFocus = true;
+            this.buttonFilter.Name = "buttonFilter";
+            this.buttonFilter.Label = "Filter";
+            this.boxFilter.Add(this.buttonFilter);
+            Gtk.Box.BoxChild w4 = ((Gtk.Box.BoxChild)(this.boxFilter[this.buttonFilter]));
+            w4.Position = 1;
+            w4.Expand = false;
+            w4.Fill = false;
+            this.hbox1.Add(this.boxFilter);
+            Gtk.Box.BoxChild w5 = ((Gtk.Box.BoxChild)(this.hbox1[this.boxFilter]));
+            w5.Position = 0;
+            // Container child hbox1.Gtk.Box+BoxChild
+            this.checkInverse = new Gtk.CheckButton();
+            this.checkInverse.CanFocus = true;
+            this.checkInverse.Name = "checkInverse";
+            this.checkInverse.Label = "Inverse references";
+            this.checkInverse.DrawIndicator = true;
+            this.hbox1.Add(this.checkInverse);
+            Gtk.Box.BoxChild w6 = ((Gtk.Box.BoxChild)(this.hbox1[this.checkInverse]));
+            w6.Position = 1;
+            w6.Expand = false;
+            w6.Fill = false;
+            this.vbox1.Add(this.hbox1);
+            Gtk.Box.BoxChild w7 = ((Gtk.Box.BoxChild)(this.vbox1[this.hbox1]));
+            w7.Position = 1;
+            w7.Expand = false;
+            w7.Fill = false;
+            this.Add(this.vbox1);
+            if ((this.Child != null)) {
+                this.Child.ShowAll();
+            }
+            this.Show();
+            this.treeview.MotionNotifyEvent += new Gtk.MotionNotifyEventHandler(this.OnTreeviewMotionNotifyEvent);
+            this.treeview.LeaveNotifyEvent += new Gtk.LeaveNotifyEventHandler(this.OnTreeviewLeaveNotifyEvent);
+            this.entryFilter.Activated += new System.EventHandler(this.OnEntryFilterActivated);
+            this.buttonFilter.Clicked += new System.EventHandler(this.OnButtonFilterClicked);
+            this.checkInverse.Clicked += new System.EventHandler(this.OnCheckInverseClicked);
+        }
+    }
+}
Index: MonoDevelop.Profiler/gtk-gui/gui.stetic
===================================================================
--- MonoDevelop.Profiler/gtk-gui/gui.stetic	(revision 0)
+++ MonoDevelop.Profiler/gtk-gui/gui.stetic	(revision 0)
@@ -0,0 +1,244 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<stetic-interface>
+  <import>
+    <widget-library name="../../../build/AddIns/MonoDevelop.Projects.Gui.dll" />
+    <widget-library name="../../../build/AddIns/MonoDevelop.Components.dll" />
+    <widget-library name="../bin/Debug/MonoDevelop.Profiler.exe" />
+  </import>
+  <widget class="Gtk.Bin" id="MonoDevelop.Profiler.HeapShotObjectMapViewer" design-size="480 300">
+    <property name="MemberName" />
+    <property name="Events">ButtonPressMask</property>
+    <child>
+      <widget class="Gtk.VBox" id="vbox1">
+        <property name="MemberName" />
+        <property name="Spacing">6</property>
+        <property name="BorderWidth">6</property>
+        <child>
+          <widget class="Gtk.ScrolledWindow" id="scrolledwindow1">
+            <property name="MemberName" />
+            <property name="CanFocus">True</property>
+            <property name="VscrollbarPolicy">Automatic</property>
+            <property name="HscrollbarPolicy">Automatic</property>
+            <property name="ShadowType">In</property>
+            <child>
+              <widget class="Gtk.TreeView" id="treeview">
+                <property name="MemberName">treeview</property>
+                <property name="CanFocus">True</property>
+                <property name="Events">PointerMotionMask, LeaveNotifyMask</property>
+                <signal name="MotionNotifyEvent" handler="OnTreeviewMotionNotifyEvent" />
+                <signal name="LeaveNotifyEvent" handler="OnTreeviewLeaveNotifyEvent" />
+              </widget>
+            </child>
+          </widget>
+          <packing>
+            <property name="Position">0</property>
+            <property name="AutoSize">True</property>
+          </packing>
+        </child>
+        <child>
+          <widget class="Gtk.HBox" id="hbox1">
+            <property name="MemberName" />
+            <property name="Spacing">6</property>
+            <child>
+              <widget class="Gtk.HBox" id="boxFilter">
+                <property name="MemberName">boxFilter</property>
+                <property name="Spacing">3</property>
+                <child>
+                  <widget class="Gtk.Entry" id="entryFilter">
+                    <property name="MemberName">entryFilter</property>
+                    <property name="CanFocus">True</property>
+                    <property name="IsEditable">True</property>
+                    <property name="InvisibleChar">●</property>
+                    <signal name="Activated" handler="OnEntryFilterActivated" />
+                  </widget>
+                  <packing>
+                    <property name="Position">0</property>
+                    <property name="AutoSize">True</property>
+                  </packing>
+                </child>
+                <child>
+                  <widget class="Gtk.Button" id="buttonFilter">
+                    <property name="MemberName" />
+                    <property name="CanFocus">True</property>
+                    <property name="Type">TextOnly</property>
+                    <property name="Label">Filter</property>
+                    <property name="IsDialogButton">False</property>
+                    <signal name="Clicked" handler="OnButtonFilterClicked" />
+                  </widget>
+                  <packing>
+                    <property name="Position">1</property>
+                    <property name="AutoSize">True</property>
+                    <property name="Expand">False</property>
+                    <property name="Fill">False</property>
+                  </packing>
+                </child>
+              </widget>
+              <packing>
+                <property name="Position">0</property>
+                <property name="AutoSize">True</property>
+              </packing>
+            </child>
+            <child>
+              <widget class="Gtk.CheckButton" id="checkInverse">
+                <property name="MemberName">checkInverse</property>
+                <property name="CanFocus">True</property>
+                <property name="Label">Inverse references</property>
+                <property name="DrawIndicator">True</property>
+                <property name="HasLabel">True</property>
+                <signal name="Clicked" handler="OnCheckInverseClicked" />
+              </widget>
+              <packing>
+                <property name="Position">1</property>
+                <property name="AutoSize">False</property>
+                <property name="Expand">False</property>
+                <property name="Fill">False</property>
+              </packing>
+            </child>
+          </widget>
+          <packing>
+            <property name="Position">1</property>
+            <property name="AutoSize">True</property>
+            <property name="Expand">False</property>
+            <property name="Fill">False</property>
+          </packing>
+        </child>
+      </widget>
+    </child>
+  </widget>
+  <widget class="Gtk.Bin" id="MonoDevelop.Profiler.HeapShotSummary" design-size="300 300">
+    <property name="MemberName" />
+    <property name="Events">ButtonPressMask</property>
+    <child>
+      <widget class="Gtk.Table" id="table1">
+        <property name="MemberName" />
+        <property name="NRows">3</property>
+        <property name="NColumns">2</property>
+        <property name="RowSpacing">6</property>
+        <property name="ColumnSpacing">6</property>
+        <property name="BorderWidth">6</property>
+        <child>
+          <widget class="Gtk.Label" id="label1">
+            <property name="MemberName" />
+            <property name="Xalign">0</property>
+            <property name="LabelProp" translatable="yes">Name:</property>
+          </widget>
+          <packing>
+            <property name="AutoSize">True</property>
+            <property name="XOptions">Fill</property>
+            <property name="YOptions">Fill</property>
+            <property name="XExpand">False</property>
+            <property name="XFill">True</property>
+            <property name="XShrink">False</property>
+            <property name="YExpand">False</property>
+            <property name="YFill">True</property>
+            <property name="YShrink">False</property>
+          </packing>
+        </child>
+        <child>
+          <widget class="Gtk.Label" id="label4">
+            <property name="MemberName" />
+            <property name="Xalign">0</property>
+            <property name="LabelProp" translatable="yes">Object count:</property>
+          </widget>
+          <packing>
+            <property name="TopAttach">1</property>
+            <property name="BottomAttach">2</property>
+            <property name="AutoSize">True</property>
+            <property name="XOptions">Fill</property>
+            <property name="YOptions">Fill</property>
+            <property name="XExpand">False</property>
+            <property name="XFill">True</property>
+            <property name="XShrink">False</property>
+            <property name="YExpand">False</property>
+            <property name="YFill">True</property>
+            <property name="YShrink">False</property>
+          </packing>
+        </child>
+        <child>
+          <widget class="Gtk.Label" id="label6">
+            <property name="MemberName" />
+            <property name="Xalign">0</property>
+            <property name="LabelProp" translatable="yes">Total memory:</property>
+          </widget>
+          <packing>
+            <property name="TopAttach">2</property>
+            <property name="BottomAttach">3</property>
+            <property name="AutoSize">True</property>
+            <property name="XOptions">Fill</property>
+            <property name="YOptions">Fill</property>
+            <property name="XExpand">False</property>
+            <property name="XFill">True</property>
+            <property name="XShrink">False</property>
+            <property name="YExpand">False</property>
+            <property name="YFill">True</property>
+            <property name="YShrink">False</property>
+          </packing>
+        </child>
+        <child>
+          <widget class="Gtk.Label" id="labelCount">
+            <property name="MemberName" />
+            <property name="Xalign">0</property>
+            <property name="LabelProp" translatable="yes" />
+          </widget>
+          <packing>
+            <property name="TopAttach">1</property>
+            <property name="BottomAttach">2</property>
+            <property name="LeftAttach">1</property>
+            <property name="RightAttach">2</property>
+            <property name="AutoSize">True</property>
+            <property name="XOptions">Fill</property>
+            <property name="YOptions">Fill</property>
+            <property name="XExpand">False</property>
+            <property name="XFill">True</property>
+            <property name="XShrink">False</property>
+            <property name="YExpand">False</property>
+            <property name="YFill">True</property>
+            <property name="YShrink">False</property>
+          </packing>
+        </child>
+        <child>
+          <widget class="Gtk.Label" id="labelMemory">
+            <property name="MemberName" />
+            <property name="Xalign">0</property>
+            <property name="LabelProp" translatable="yes" />
+          </widget>
+          <packing>
+            <property name="TopAttach">2</property>
+            <property name="BottomAttach">3</property>
+            <property name="LeftAttach">1</property>
+            <property name="RightAttach">2</property>
+            <property name="AutoSize">True</property>
+            <property name="XOptions">Fill</property>
+            <property name="YOptions">Fill</property>
+            <property name="XExpand">False</property>
+            <property name="XFill">True</property>
+            <property name="XShrink">False</property>
+            <property name="YExpand">False</property>
+            <property name="YFill">True</property>
+            <property name="YShrink">False</property>
+          </packing>
+        </child>
+        <child>
+          <widget class="Gtk.Label" id="labelName">
+            <property name="MemberName" />
+            <property name="Xalign">0</property>
+            <property name="LabelProp" translatable="yes" />
+          </widget>
+          <packing>
+            <property name="LeftAttach">1</property>
+            <property name="RightAttach">2</property>
+            <property name="AutoSize">True</property>
+            <property name="XOptions">Fill</property>
+            <property name="YOptions">Fill</property>
+            <property name="XExpand">False</property>
+            <property name="XFill">True</property>
+            <property name="XShrink">False</property>
+            <property name="YExpand">False</property>
+            <property name="YFill">True</property>
+            <property name="YShrink">False</property>
+          </packing>
+        </child>
+      </widget>
+    </child>
+  </widget>
+</stetic-interface>
\ No newline at end of file
Index: MonoDevelop.Profiler/ChangeLog
===================================================================
--- MonoDevelop.Profiler/ChangeLog	(revision 0)
+++ MonoDevelop.Profiler/ChangeLog	(revision 0)
@@ -0,0 +1,3 @@
+2007-04-20  Ben Motmans  <ben.motmans@gmail.com>
+
+	* Initial commit
\ No newline at end of file
Index: MonoDevelop.Profiler/MonoDevelop.Profiler.mdp
===================================================================
--- MonoDevelop.Profiler/MonoDevelop.Profiler.mdp	(revision 0)
+++ MonoDevelop.Profiler/MonoDevelop.Profiler.mdp	(revision 0)
@@ -0,0 +1,80 @@
+<Project name="MonoDevelop.Profiler" fileversion="2.0" language="C#" clr-version="Net_2_0" ctype="DotNetProject">
+  <Configurations active="Debug">
+    <Configuration name="Debug" ctype="DotNetProjectConfiguration">
+      <Output directory="./bin/Debug" assembly="MonoDevelop.Profiler" />
+      <Build debugmode="True" target="Exe" />
+      <Execution runwithwarnings="True" consolepause="True" runtime="MsNet" clr-version="Net_2_0" />
+      <CodeGeneration compiler="Mcs" warninglevel="4" optimize="True" unsafecodeallowed="False" generateoverflowchecks="True" generatexmldocumentation="False" ctype="CSharpCompilerParameters" />
+    </Configuration>
+    <Configuration name="Release" ctype="DotNetProjectConfiguration">
+      <Output directory="./bin/Release" assembly="MonoDevelop.Profiler" />
+      <Build debugmode="False" target="Exe" />
+      <Execution runwithwarnings="True" consolepause="True" runtime="MsNet" clr-version="Net_2_0" />
+      <CodeGeneration compiler="Mcs" warninglevel="4" optimize="True" unsafecodeallowed="False" generateoverflowchecks="True" generatexmldocumentation="False" ctype="CSharpCompilerParameters" />
+    </Configuration>
+  </Configurations>
+  <Contents>
+    <File name="./AssemblyInfo.cs" subtype="Code" buildaction="Compile" />
+    <File name="./MonoDevelopProfiler.addin.xml" subtype="Code" buildaction="Nothing" />
+    <File name="./Makefile.am" subtype="Code" buildaction="Nothing" />
+    <File name="./ChangeLog" subtype="Code" buildaction="Nothing" />
+    <File name="./Commands" subtype="Directory" buildaction="Compile" />
+    <File name="./Commands/ProjectCommands.cs" subtype="Code" buildaction="Compile" />
+    <File name="./MonoProfilerExecutionHandlerFactory.cs" subtype="Code" buildaction="Compile" />
+    <File name="./ProfilerService.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui" subtype="Directory" buildaction="Compile" />
+    <File name="./Profilers" subtype="Directory" buildaction="Compile" />
+    <File name="./Profilers/HeapBuddyProfiler.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/HeapShotProfiler.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Widgets" subtype="Directory" buildaction="Compile" />
+    <File name="./Gui/Pads" subtype="Directory" buildaction="Compile" />
+    <File name="./Gui/Pads/ProfilerPad.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Pads/ProfilerEntry.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Pads/ProfilerEntryNodeBuilder.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Pads/ProfilerSnapshotNodeBuilder.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Services.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Pads/ProfilerEntryCollection.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Pads/ProfilerEntryCollectionNodeBuilder.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/AbstractMonoProfiler.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/AbstractProfilerSnapshot.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/MonoProfilerSnapshot.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Views" subtype="Directory" buildaction="Compile" />
+    <File name="./Gui/Views/HeapShotSnapshotView.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Codons" subtype="Directory" buildaction="Compile" />
+    <File name="./Codons/ProfilerCodon.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Views/ISnapshotView.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/HeapShot" subtype="Directory" buildaction="Compile" />
+    <File name="./Profilers/HeapShot/FieldInfo.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/HeapShot/ObjectInfo.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/HeapShot/TypeInfo.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/HeapShot/ObjectReference.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/HeapShot/ReferenceNode.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Profilers/HeapShot/ObjectMapFileReader.cs" subtype="Code" buildaction="Compile" />
+    <File name="./gtk-gui/generated.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Widgets/HeapShotSummary.cs" subtype="Code" buildaction="Compile" />
+    <File name="./Gui/Widgets/HeapShotObjectMapViewer.cs" subtype="Code" buildaction="Compile" />
+    <File name="./gtk-gui/gui.stetic" subtype="Code" buildaction="EmbedAsResource" />
+    <File name="./gtk-gui/objects.xml" subtype="Code" buildaction="EmbedAsResource" />
+    <File name="./gtk-gui/MonoDevelop.Profiler.HeapShotObjectMapViewer.cs" subtype="Code" buildaction="Compile" />
+    <File name="./gtk-gui/MonoDevelop.Profiler.HeapShotSummary.cs" subtype="Code" buildaction="Compile" />
+  </Contents>
+  <References>
+    <ProjectReference type="Project" localcopy="True" refto="MonoDevelop.Projects" />
+    <ProjectReference type="Project" localcopy="True" refto="MonoDevelop.Projects.Gui" />
+    <ProjectReference type="Project" localcopy="True" refto="MonoDevelop.Ide" />
+    <ProjectReference type="Project" localcopy="True" refto="MonoDevelop.Core" />
+    <ProjectReference type="Project" localcopy="True" refto="MonoDevelop.Core.Gui" />
+    <ProjectReference type="Project" localcopy="True" refto="MonoDevelop.Components" />
+    <ProjectReference type="Gac" localcopy="True" refto="System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
+    <ProjectReference type="Gac" localcopy="True" refto="System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
+    <ProjectReference type="Gac" localcopy="True" refto="gtk-sharp, Version=2.10.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
+    <ProjectReference type="Gac" localcopy="True" refto="gdk-sharp, Version=2.10.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
+    <ProjectReference type="Gac" localcopy="True" refto="Mono.Posix, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756" />
+  </References>
+  <GtkDesignInfo partialTypes="True">
+    <ExportedWidgets>
+      <Widget>MonoDevelop.Profiler.HeapShotSummary</Widget>
+      <Widget>MonoDevelop.Profiler.HeapShotObjectMapViewer</Widget>
+    </ExportedWidgets>
+  </GtkDesignInfo>
+</Project>
\ No newline at end of file
Index: MonoDevelop.Profiler/MonoDevelopProfiler.addin.xml
===================================================================
--- MonoDevelop.Profiler/MonoDevelopProfiler.addin.xml	(revision 0)
+++ MonoDevelop.Profiler/MonoDevelopProfiler.addin.xml	(revision 0)
@@ -0,0 +1,67 @@
+<AddIn id	 = "MonoDevelop.Profiler"
+       name	 = "Mono profiler support"
+       author	 = "Ben Motmans"
+       copyright = "MIT"
+       url       = "http://monodevelop.com"
+       description = "Integrates mono profilers into the MonoDevelop IDE."
+	   category    = "IDE extensions"
+       version   = "0.1.0.0">
+       
+       <Runtime>
+		<Import assembly="MonoDevelop.Profiler.dll"/>
+	</Runtime>
+
+	<Dependencies>
+		<AddIn id="MonoDevelop.Core" version="0.13.0"/>
+		<AddIn id="MonoDevelop.Core.Gui" version="0.13.0"/>
+		<AddIn id="MonoDevelop.Projects" version="0.13.0"/>
+		<AddIn id="MonoDevelop.Projects.Gui" version="0.13.0"/>
+		<AddIn id="MonoDevelop.Ide" version="0.13.0"/>
+	</Dependencies>
+	
+	<Extension path="/Workspace/Services">
+		<Class id = "ProfilerService"
+		    class = "MonoDevelop.Profiler.ProfilerService"/>
+	</Extension>
+	
+	<Extension path = "/SharpDevelop/Commands" extension-nodes="Command" description="User interface commands.">
+		<Command id = "MonoDevelop.Profiler.Commands.ProjectCommands.ProfilerList"
+			defaultHandler = "MonoDevelop.Profiler.Commands.ProfilerListHandler"
+			type="array"
+			_label = "Profiler List" />
+	</Extension>
+	
+	<Extension path = "/SharpDevelop/Workbench/MainMenu/Run"  extension-nodes="CommandItem" description="Main menu items">
+		<ItemSet id = "RunProfiled" _label = "Run Profiled" insertafter="MonoDevelop.Ide.Commands.ProjectCommands.Run">
+			<CommandItem id = "MonoDevelop.Profiler.Commands.ProjectCommands.ProfilerList" />
+		</ItemSet>
+	</Extension>
+	
+	<Extension path = "/SharpDevelop/Workbench/Pads">
+		<SolutionPad id = "MonoDevelop.Profiler.Gui.Pads.ProfilerPad" class = "MonoDevelop.Profiler.Gui.Pads.ProfilerPad" defaultPlacement = "Left" _label = "Profiler" icon = "md-execute">
+			<NodeBuilder class = "MonoDevelop.Profiler.Gui.Pads.ProfilerEntryNodeBuilder"/>
+			<NodeBuilder class = "MonoDevelop.Profiler.Gui.Pads.ProfilerEntryCollectionNodeBuilder"/>
+			<NodeBuilder class = "MonoDevelop.Profiler.Gui.Pads.ProfilerSnapshotNodeBuilder"/>
+		</SolutionPad>
+	</Extension>
+
+	<Extension path = "/SharpDevelop/Workbench/Contexts/Profile">
+		<ContextPad id = "MonoDevelop.Profiler.Gui.Pads.ProfilerPad"/>
+	</Extension>
+	<Extension path = "/SharpDevelop/Workbench/Contexts/Edit">
+		<ContextPad id = "MonoDevelop.Profiler.Gui.Pads.ProfilerPad"/>
+	</Extension>
+	
+	<Extension path = "/AddIns/MonoDevelop.Profiler/Profilers" extension-nodes="Profiler" description="Profilers">
+		<!--heap-buddy disabled for now-->
+		<!--<Profiler id = "MonoDevelop.Profiler.Profilers.HeapBuddyProfiler"
+			class = "MonoDevelop.Profiler.Profilers.HeapBuddyProfiler"
+			view = "MonoDevelop.Profiler.Gui.Views.HeapBuddySnapshotView"
+			label = "Track memory allocations (heap-buddy)" icon = "md-execute" />-->
+		<Profiler id = "MonoDevelop.Profiler.Profilers.HeapShotProfiler"
+			class = "MonoDevelop.Profiler.Profilers.HeapShotProfiler"
+			view = "MonoDevelop.Profiler.Gui.Views.HeapShotSnapshotView"
+			label = "Explore live heap objects (heap-shot)" icon = "md-execute" />
+	</Extension>
+
+</AddIn>
Index: MonoDevelop.Profiler/ProfilerService.cs
===================================================================
--- MonoDevelop.Profiler/ProfilerService.cs	(revision 0)
+++ MonoDevelop.Profiler/ProfilerService.cs	(revision 0)
@@ -0,0 +1,203 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.IO;
+using System.Collections.Generic;
+
+using MonoDevelop.Core;
+using MonoDevelop.Core.AddIns;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Core.Gui;
+using MonoDevelop.Profiler.Codons;
+using MonoDevelop.Profiler.Gui.Views;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+
+namespace MonoDevelop.Profiler
+{
+	public class ProfilerService : AbstractService, IProfilerService
+	{
+		public event EventHandler StartedEvent;
+		public event EventHandler StoppedEvent;
+		
+		public event ProfilerSnapshotEventHandler SnapshotCreated;
+		public event ProfilerEventHandler ActiveProfilerChanged;
+
+		private IProfiler profiler;
+		
+		private List<ProfilerCodon> codons;
+		
+		private ProfilerSnapshotEventHandler snapCallback;
+		private EventHandler startCallback;
+		private EventHandler stopCallback;
+		
+		public ProfilerService ()
+		{
+			codons = new List<ProfilerCodon> ();
+			snapCallback = new ProfilerSnapshotEventHandler (ProfilerSnapshotEventCallback);
+			startCallback = new EventHandler (StartedEventCallback);
+			stopCallback = new EventHandler (StoppedEventCallback);
+			
+			foreach (ProfilerCodon codon in Runtime.AddInService.GetTreeCodons ("/AddIns/MonoDevelop.Profiler/Profilers")) {
+				codons.Add (codon);
+				codon.Initialize ();
+			}
+		}
+		
+		public bool IsRunning {
+			get { return profiler != null && profiler.IsRunning; }
+		}
+		
+		public IProfiler ActiveProfiler {
+			get { return profiler; }
+			set {
+				if (profiler != null) {
+					profiler.SnapshotCreated -= snapCallback;
+					profiler.StartedEvent -= startCallback;
+					profiler.StoppedEvent -= stopCallback;
+				}
+				
+				profiler = value;
+				if (profiler != null) {
+					profiler.SnapshotCreated += snapCallback;
+					profiler.StartedEvent += startCallback;
+					profiler.StoppedEvent += stopCallback;
+				}
+				
+				if (ActiveProfilerChanged != null)
+					ActiveProfilerChanged (this, new ProfilerEventArgs (value));
+			}
+		}
+
+		public override void UnloadService ()
+		{
+			Stop ();
+			base.UnloadService ();
+		}
+
+		public void Start ()
+		{
+			if (IsRunning)
+				return;
+			
+			ActiveProfiler.Start ();
+		}
+
+		public void Stop ()
+		{
+			if (!IsRunning)
+				return;
+			
+			if (ActiveProfiler != null)
+				ActiveProfiler.Stop ();
+			ActiveProfiler = null;
+		}
+
+		public IEnumerable<IProfiler> Profilers {
+			get {
+				foreach (ProfilerCodon codon in codons)
+					yield return codon.Profiler;
+			}
+		}
+		
+		public IEnumerable<ProfilerCodon> ProfilerCodons {
+			get { return codons; }
+		}
+		
+		internal string GetLabel (IProfiler profiler)
+		{
+			foreach (ProfilerCodon codon in codons)
+				if (codon.Profiler == profiler)
+					return codon.Label;
+			return GettextCatalog.GetString ("unknown");
+		}
+		
+		internal ISnapshotView CreateSnapshotView (IProfiler profiler)
+		{
+			foreach (ProfilerCodon codon in codons)
+				if (codon.Profiler == profiler)
+					return codon.CreateSnapshotView ();
+			return null;
+		}
+
+		public string GetProfileSnapshotLocation ()
+		{
+			if (IdeApp.ProjectOperations.CurrentOpenCombine != null) {
+				//create file $outputdir/md-profiler-snapshots/$combine-name_yyyy-MM-dd_HH-mm-ss
+				Combine comb = IdeApp.ProjectOperations.CurrentOpenCombine.RootCombine;
+				string dir = Path.Combine (comb.BaseDirectory, "md-profiler-snapshots");
+				
+				if (!Directory.Exists (dir))
+					Directory.CreateDirectory (dir);
+
+				string baseName = Path.Combine (
+					dir,				                                    
+					String.Concat (comb.Name, DateTime.Now.ToString ("_yyyy-MM-dd_HH-mm-ss"))
+				);
+				string fileName = baseName;
+				
+				int counter = 0;
+				while (File.Exists (fileName))
+					fileName = String.Concat (baseName, "_", counter);
+				
+				return fileName;
+			} else {
+				return Path.GetTempFileName ();
+			}
+		}
+		
+		protected virtual void OnStartedEvent (EventArgs args)
+		{
+			if (StartedEvent != null)
+				StartedEvent (this, args);
+		}
+		
+		protected virtual void OnStoppedEvent (EventArgs args)
+		{
+			if (StoppedEvent != null)
+				StoppedEvent (this, args);
+		}
+		
+		private void ProfilerSnapshotEventCallback (object sender, ProfilerSnapshotEventArgs args)
+		{
+			if (SnapshotCreated != null)
+				SnapshotCreated (this, args);
+		}
+		
+		private void StartedEventCallback (object sender, EventArgs args)
+		{
+			if (StartedEvent != null)
+				StartedEvent (this, args);
+		}
+		
+		private void StoppedEventCallback (object sender, EventArgs args)
+		{
+			if (StoppedEvent != null)
+				StoppedEvent (this, args);
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.Profiler/Services.cs
===================================================================
--- MonoDevelop.Profiler/Services.cs	(revision 0)
+++ MonoDevelop.Profiler/Services.cs	(revision 0)
@@ -0,0 +1,70 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+// Copyright (C) 2005 Novell, Inc.
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using MonoDevelop.Core;
+using MonoDevelop.Core.Gui;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Projects;
+
+namespace MonoDevelop.Profiler
+{
+	internal class Services
+	{
+		static DispatchService dispatchService;
+		static ProfilerService profilerService;
+		
+		public static DispatchService DispatchService {
+			get {
+				if (dispatchService == null)
+					dispatchService = (DispatchService) ServiceManager.GetService (typeof(DispatchService));
+				return dispatchService;
+			}
+		}
+
+		public static ProfilerService ProfilerService {
+			get {
+				if (profilerService == null)
+					profilerService = (ProfilerService) ServiceManager.GetService (typeof(ProfilerService));
+				return profilerService;
+			}
+		}
+		
+		public static string GetHumanReadableSize (long bytes)
+		{
+			if (bytes < 1024)
+				return String.Format ("{0} B", bytes);
+			else if (bytes < 10240)
+				return String.Format ("{0:0.0} kB", bytes / 1024.0);
+			else if (bytes < 1048576)
+				return String.Format ("{0} kB", bytes / 1024);
+			else
+				return String.Format ("{0:0.0} MB", bytes / (1048576.0));
+		}
+	}
+}
+
Index: MonoDevelop.Profiler/Makefile.am
===================================================================
--- MonoDevelop.Profiler/Makefile.am	(revision 0)
+++ MonoDevelop.Profiler/Makefile.am	(revision 0)
@@ -0,0 +1,75 @@
+
+ADDIN_BUILD = $(top_builddir)/build/AddIns/MonoDevelop.Profiler
+ASSEMBLY = $(ADDIN_BUILD)/MonoDevelop.Profiler.dll
+REFS =  \
+	$(GLADE_SHARP_LIBS) \
+	$(GTK_SHARP_LIBS) \
+	-r:$(top_builddir)/build/AddIns/MonoDevelop.Components.dll \
+	-r:$(top_builddir)/build/AddIns/MonoDevelop.Core.Gui.dll \
+	-r:$(top_builddir)/build/AddIns/MonoDevelop.Ide.dll \
+	-r:$(top_builddir)/build/AddIns/MonoDevelop.Projects.dll \
+	-r:$(top_builddir)/build/AddIns/MonoDevelop.Projects.Gui.dll \
+	-r:$(top_builddir)/build/bin/MonoDevelop.Core.dll \
+	-r:System \
+	-r:System.Xml \
+	-r:Mono.Posix
+
+FILES =  \
+	AssemblyInfo.cs \
+	Codons/ProfilerCodon.cs \
+	Commands/ProjectCommands.cs \
+	Gui/Pads/ProfilerEntry.cs \
+	Gui/Pads/ProfilerEntryCollection.cs \
+	Gui/Pads/ProfilerEntryNodeBuilder.cs \
+	Gui/Pads/ProfilerEntryCollectionNodeBuilder.cs \
+	Gui/Pads/ProfilerPad.cs \
+	Gui/Pads/ProfilerSnapshotNodeBuilder.cs \
+	Gui/Views/ISnapshotView.cs \
+	Gui/Views/HeapShotSnapshotView.cs \
+	Gui/Widgets/HeapShotSummary.cs \
+	Gui/Widgets/HeapShotObjectMapViewer.cs \
+	Profilers/AbstractMonoProfiler.cs \
+	Profilers/AbstractProfilerSnapshot.cs \
+	Profilers/HeapBuddyProfiler.cs \
+	Profilers/HeapShotProfiler.cs \
+	Profilers/MonoProfilerSnapshot.cs \
+	Profilers/HeapShot/FieldInfo.cs \
+	Profilers/HeapShot/ObjectInfo.cs \
+	Profilers/HeapShot/ObjectMapFileReader.cs \
+	Profilers/HeapShot/ObjectReference.cs \
+	Profilers/HeapShot/ReferenceNode.cs \
+	Profilers/HeapShot/TypeInfo.cs \
+	MonoProfilerExecutionHandlerFactory.cs \
+	ProfilerService.cs \
+	Services.cs \
+	gtk-gui/generated.cs \
+	gtk-gui/MonoDevelop.Profiler.HeapShotSummary.cs \
+	gtk-gui/MonoDevelop.Profiler.HeapShotObjectMapViewer.cs
+	
+RES =  \
+	gtk-gui/gui.stetic
+
+ADDIN = MonoDevelopProfiler.addin.xml
+
+all: $(ASSEMBLY) $(ADDIN_BUILD)/$(ADDIN)
+
+$(ADDIN_BUILD)/$(ADDIN): $(srcdir)/$(ADDIN)
+	mkdir -p $(ADDIN_BUILD)
+	cp $(srcdir)/$(ADDIN) $(ADDIN_BUILD)/.
+
+$(ADDIN_BUILD)/%: $(srcdir)/lib/%
+	mkdir -p $(ADDIN_BUILD)
+	cp $< $@
+
+$(ASSEMBLY): $(FILES) $(build_resources)
+	mkdir -p $(ADDIN_BUILD)
+	$(CSC) $(CSC_FLAGS) $(REFS) $(build_resources:%=/resource:%) $(build_sources) -out:$@ -target:library
+
+
+assemblydir = $(MD_ADDIN_DIR)/MonoDevelop.Profiler
+assembly_DATA = $(ASSEMBLY) $(ADDIN)
+
+CLEANFILES = $(ASSEMBLY) $(ASSEMBLY).mdb
+EXTRA_DIST = $(FILES) $(ADDIN) $(RES)
+
+include $(top_srcdir)/Makefile.include
Index: MonoDevelop.Profiler/MonoProfilerExecutionHandlerFactory.cs
===================================================================
--- MonoDevelop.Profiler/MonoProfilerExecutionHandlerFactory.cs	(revision 0)
+++ MonoDevelop.Profiler/MonoProfilerExecutionHandlerFactory.cs	(revision 0)
@@ -0,0 +1,78 @@
+//
+// Authors:
+//   Ben Motmans  <ben.motmans@gmail.com>
+//
+// Copyright (C) 2007 Ben Motmans
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+
+using System;
+using System.Threading;
+using MonoDevelop.Core;
+using MonoDevelop.Core.Execution;
+using MonoDevelop.Profiler.Profilers;
+
+namespace MonoDevelop.Profiler
+{
+	internal class MonoProfilerExecutionHandlerFactory : IExecutionHandlerFactory
+	{
+		AbstractMonoProfiler profiler;
+		
+		public MonoProfilerExecutionHandlerFactory (AbstractMonoProfiler profiler)
+		{
+			this.profiler = profiler;
+		}
+		
+		public IExecutionHandler CreateExecutionHandler (string platformId)
+		{
+			if (profiler != null && platformId == "Mono")
+				return new MonoProfilerExecutionHandler (profiler);
+			return null;
+		}
+	}
+	
+	class MonoProfilerExecutionHandler : NativePlatformExecutionHandler
+	{
+		AbstractMonoProfiler profiler;
+		
+		public MonoProfilerExecutionHandler (AbstractMonoProfiler profiler)
+		{
+			this.profiler = profiler;
+		}
+		
+		public override IProcessAsyncOperation Execute (string command, string arguments, string workingDirectory, IConsole console)
+		{
+			string args = string.Format ("--profile={1}:/tmp/md-heap-dump --debug \"{0}\" {2}", command, profiler.ProfilerName, arguments);
+			IProcessAsyncOperation pao = base.Execute ("mono", args, workingDirectory, console);
+			Services.ProfilerService.ActiveProfiler = profiler;
+			profiler.ProcessId = pao.ProcessId;
+			profiler.Start ();
+			pao.Completed += new OperationHandler (CompletedCallback);
+			
+			return pao;
+		}
+		
+		private void CompletedCallback (IAsyncOperation op)
+		{
+			Services.ProfilerService.Stop ();
+		}
+	}
+}
\ No newline at end of file
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 76004)
+++ Makefile.am	(working copy)
@@ -1,2 +1,2 @@
 
-SUBDIRS = MonoDevelop.DesignerSupport Deployment MonoDevelop.SourceEditor MonoDevelop.Autotools CSharpBinding DebuggerAddIn ILAsmBinding MonoQuery JavaBinding BooBinding NemerleBinding NUnit MonoDeveloperExtensions VersionControl VBNetBinding prj2make-sharp-lib WelcomePage ChangeLogAddIn MonoDevelop.GtkCore AspNetAddIn AspNetEdit MonoDevelop.WebReferences
+SUBDIRS = MonoDevelop.DesignerSupport Deployment MonoDevelop.SourceEditor MonoDevelop.Autotools CSharpBinding DebuggerAddIn ILAsmBinding MonoQuery JavaBinding BooBinding NemerleBinding NUnit MonoDeveloperExtensions VersionControl VBNetBinding prj2make-sharp-lib WelcomePage ChangeLogAddIn MonoDevelop.GtkCore AspNetAddIn AspNetEdit MonoDevelop.WebReferences MonoDevelop.Profiler