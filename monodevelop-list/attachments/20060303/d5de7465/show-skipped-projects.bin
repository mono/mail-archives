Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects/Combine.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects/Combine.cs	(revision 57534)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects/Combine.cs	(working copy)
@@ -557,14 +557,21 @@
 				monitor.ReportError (GettextCatalog.GetString ("The solution does not have an active configuration."), null);
 				return new DefaultCompilerResult (new CompilerResults (null), "", 0, 1);
 			}
-			CombineEntryCollection allProjects = GetAllBuildableEntries (ActiveConfiguration.Name);
+						
+			CombineEntryCollection allProjects = new CombineEntryCollection();
+			GetAllEntries(allProjects);												
+			
+			CombineEntryCollection allBuildableProjects = GetAllBuildableEntries (ActiveConfiguration.Name);
 			monitor.BeginTask (string.Format (GettextCatalog.GetString ("Building Solution {0}"), Name), allProjects.Count);
 			try {
 				CompilerResults cres = new CompilerResults (null);
 				
-				try {
+				try 
+				{
 					allProjects = TopologicalSort (allProjects);
-				} catch (CyclicBuildOrderException) {
+				}
+				catch (CyclicBuildOrderException) 
+				{
 					monitor.ReportError (GettextCatalog.GetString ("Cyclic dependencies can not be built with this version.\nBut we are working on it."), null);
 					return new DefaultCompilerResult (cres, "", 1, 1);
 				}
@@ -572,15 +579,28 @@
 				int builds = 0;
 				int failedBuilds = 0;
 				
-				foreach (Project entry in allProjects) {
+				foreach (Project entry in allProjects) 
+				{
+			
 					if (monitor.IsCancelRequested)
 						break;
 
+					if (!allBuildableProjects.Contains(entry))
+					{
+						monitor.BeginTask(GettextCatalog.GetString("Skipping Project: {0} Configuration: {1}", entry.Name, ActiveConfiguration.Name), 1);
+						monitor.Step (1);
+						monitor.EndTask();
+						monitor.Step (1);						
+						continue;
+					}
+
 					ICompilerResult res = entry.Build (monitor, false);
 					builds++;
 					cres.Errors.AddRange (res.CompilerResults.Errors);
 					monitor.Step (1);
-					if (res.ErrorCount > 0) {
+					
+					if (res.ErrorCount > 0)
+					{
 						failedBuilds++;
 						break;
 					}
@@ -591,6 +611,17 @@
 			}
 		}
 
+		private void GetAllEntries(CombineEntryCollection list)
+		{
+			foreach (CombineEntry entry in this.Entries) 
+			{				
+				if (entry is Combine)
+					((Combine)entry).GetAllEntries (list);
+				else if (entry is Project)
+					list.Add (entry);				
+			}			 
+		}
+
 		public void RemoveFileFromProjects (string fileName)
 		{
 			if (Directory.Exists (fileName)) {
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects/Project.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects/Project.cs	(revision 57533)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects/Project.cs	(working copy)
@@ -300,13 +300,18 @@
 			}
 			
 			if (!NeedsBuilding)
-				return new DefaultCompilerResult (new CompilerResults (null), "");
+			{
+				monitor.BeginTask(GettextCatalog.GetString("Skipping Project: {0} Configuration: {1}", Name, ActiveConfiguration.Name), 1);
+				monitor.Step(1);
+				monitor.EndTask();
+				return new DefaultCompilerResult(new CompilerResults (null), "");
+			}
 			
 			try {
 			
 				IBuildStep[] steps = BuildPipeline;
 				
-				monitor.BeginTask (String.Format (GettextCatalog.GetString ("Building Project: {0} Configuration: {1}"), Name, ActiveConfiguration.Name), steps.Length);
+				monitor.BeginTask(GettextCatalog.GetString("Building Project: {0} Configuration: {1}", Name, ActiveConfiguration.Name), steps.Length);
 				
 				Runtime.StringParserService.Properties["Project"] = Name;
 				
