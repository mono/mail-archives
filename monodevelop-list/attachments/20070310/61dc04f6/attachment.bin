Index: MSBuildData.cs
===================================================================
--- MSBuildData.cs	(wersja 73957)
+++ MSBuildData.cs	(kopia robocza)
@@ -30,33 +30,38 @@
 
 using System.Xml;
 using System.Collections.Generic;
+using MBBE = Microsoft.Build.BuildEngine;
+using Microsoft.Build.BuildEngine;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
 
 namespace MonoDevelop.Prj2Make
 {
 	class MSBuildData
 	{
-		XmlDocument doc;
-		XmlElement globalConfigElement;
+		MBBE.Project mbbeProject;
+
+		BuildPropertyGroup globalConfigGroup;
 		string guid;
 		List<string> extra;
 
-		Dictionary<DotNetProjectConfiguration, XmlElement> configElements;
+		Dictionary<DotNetProjectConfiguration, BuildPropertyGroup> configGroups;
 
-		Dictionary<ProjectFile, XmlElement> projectFileElements;
-		Dictionary<ProjectReference, XmlElement> projectReferenceElements;
+		Dictionary<ProjectFile, BuildItem> projectFileItems;
+		Dictionary<ProjectReference, BuildItem> projectReferenceItems;
 
 		public MSBuildData ()
 		{
 		}
 
-		public XmlDocument Document {
-			get { return doc; }
-			set { doc = value; }
+		public MBBE.Project Project {
+			get { return mbbeProject; }
+			set { mbbeProject = value; }
 		}
 
-		public XmlElement GlobalConfigElement {
-			get { return globalConfigElement; }
-			set { globalConfigElement = value; }
+		public BuildPropertyGroup GlobalConfigGroup {
+			get { return globalConfigGroup; }
+			set { globalConfigGroup = value; }
 		}
 
 		/* Guid w/o enclosing {} */
@@ -65,27 +70,27 @@
 			set { guid = value; }
 		}
 
-		public Dictionary<DotNetProjectConfiguration, XmlElement> ConfigElements {
+		public Dictionary<DotNetProjectConfiguration, BuildPropertyGroup> ConfigGroups {
 			get {
-				if (configElements == null)
-					configElements = new Dictionary<DotNetProjectConfiguration, XmlElement> ();
-				return configElements;
+				if (configGroups == null)
+					configGroups = new Dictionary<DotNetProjectConfiguration, BuildPropertyGroup> ();
+				return configGroups;
 			}
 		}
 		
-		public Dictionary<ProjectFile, XmlElement> ProjectFileElements {
+		public Dictionary<ProjectFile, BuildItem> ProjectFileItems {
 			get {
-				if (projectFileElements == null)
-					projectFileElements = new Dictionary<ProjectFile, XmlElement> ();
-				return projectFileElements;
+				if (projectFileItems == null)
+					projectFileItems = new Dictionary<ProjectFile, BuildItem> ();
+				return projectFileItems;
 			}
 		}
 
-		public Dictionary<ProjectReference, XmlElement> ProjectReferenceElements {
+		public Dictionary<ProjectReference, BuildItem> ProjectReferenceItems {
 			get {
-				if (projectReferenceElements == null)
-					projectReferenceElements = new Dictionary<ProjectReference, XmlElement> ();
-				return projectReferenceElements;
+				if (projectReferenceItems == null)
+					projectReferenceItems = new Dictionary<ProjectReference, BuildItem> ();
+				return projectReferenceItems;
 			}
 		}
 
Index: MSBuildSolution.cs
===================================================================
--- MSBuildSolution.cs	(wersja 73957)
+++ MSBuildSolution.cs	(kopia robocza)
@@ -36,6 +36,8 @@
 using System.IO;
 using System.Xml;
 
+using MBBE = Microsoft.Build.BuildEngine;
+
 namespace MonoDevelop.Prj2Make
 {
 	class MSBuildSolution : Combine
@@ -215,15 +217,12 @@
 
 					//FIXME: Move this to MSBuildFileFormat ?
 					MSBuildData data = (MSBuildData) proj.ExtendedProperties [typeof (MSBuildFileFormat)];
-					XmlElement elem = data.ProjectReferenceElements [pref];
-					elem.SetAttribute ("Include", 
-						Runtime.FileService.AbsoluteToRelativePath (
-							proj.BaseDirectory, p.FileName));
+					MBBE.BuildItem item = data.ProjectReferenceItems [pref];
+					item.Include = Runtime.FileService.AbsoluteToRelativePath (proj.BaseDirectory, p.FileName);
 
 					//Set guid of the ProjectReference
 					MSBuildData prefData = (MSBuildData) p.ExtendedProperties [typeof (MSBuildFileFormat)];
-					MSBuildFileFormat.EnsureChildValue (elem, "Project", MSBuildFileFormat.ns,
-						String.Concat ("{", prefData.Guid, "}"));
+					item.SetMetadata ("Project", String.Concat ("{", prefData.Guid, "}"));
 
 				}
 				if (saveProjects)
Index: Makefile.am
===================================================================
--- Makefile.am	(wersja 73957)
+++ Makefile.am	(kopia robocza)
@@ -12,20 +12,23 @@
 	-r:$(top_builddir)/build/AddIns/MonoDevelop.Ide.dll \
 	-r:$(top_builddir)/build/AddIns/MonoDevelop.Projects.dll \
 	-r:$(top_builddir)/build/bin/MonoDevelop.Core.dll \
+	-r:Microsoft.Build.Engine \
+	-r:Microsoft.Build.Framework \
+	-r:Microsoft.Build.Utilities \
 	-r:System \
 	-r:System.Xml
 
 FILES =  \
+	CSharpResourceIdBuilder.cs \
 	csproj_ver2003.cs \
 	CsprojInfo.cs \
-	CSharpResourceIdBuilder.cs \
 	IResourceIdBuilder.cs \
 	MdPrjHelper.cs \
-	MsPrjHelper.cs \
 	MSBuildData.cs \
 	MSBuildFileFormat.cs \
 	MSBuildProject.cs \
 	MSBuildSolution.cs \
+	MsPrjHelper.cs \
 	pkgconfiginvoker.cs \
 	PrjHelper.cs \
 	PrjxInfo.cs \
Index: MSBuildFileFormat.cs
===================================================================
--- MSBuildFileFormat.cs	(wersja 73957)
+++ MSBuildFileFormat.cs	(kopia robocza)
@@ -27,6 +27,7 @@
 //
 
 using MonoDevelop.Core;
+using MDP = MonoDevelop.Projects;
 using MonoDevelop.Projects;
 using VBBinding;
 using CSharpBinding;
@@ -42,15 +43,18 @@
 using System.Xml;
 using System.Xml.XPath;
 
+using Microsoft.Build.BuildEngine;
+using MBBE = Microsoft.Build.BuildEngine;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
 namespace MonoDevelop.Prj2Make
 {
 	public class MSBuildFileFormat : IFileFormat
 	{
 		string language;
-		internal const string ns = "http://schemas.microsoft.com/developer/msbuild/2003";
+		static string ns = "http://schemas.microsoft.com/developer/msbuild/2003";
 
-		static XmlNamespaceManager manager;
-
 		public MSBuildFileFormat ()
 		{
 		}
@@ -89,7 +93,7 @@
 					String.Compare (xr.NamespaceURI, ns) == 0)
 					return true;
 
-			} catch (FileNotFoundException fex) {
+			} catch (FileNotFoundException) {
 				Console.WriteLine (GettextCatalog.GetString ("File not found {0} : ", file));
 				return false;
 			} catch (XmlException xe) {
@@ -97,7 +101,7 @@
 				return false;
 			} finally {
 				if (xr != null)
-					((IDisposable)xr).Dispose ();
+					((IDisposable) xr).Dispose ();
 			}
 
 			return false;
@@ -108,17 +112,6 @@
 			return obj is DotNetProject;
 		}
 
-		static XmlNamespaceManager NamespaceManager {
-			get {
-				if (manager == null) {
-					manager = new XmlNamespaceManager (new NameTable ());
-					manager.AddNamespace ("tns", ns);
-				}
-
-				return manager;
-			}
-		}
-
 		public void WriteFile (string file, object node, IProgressMonitor monitor)
 		{
 			if (node == null)
@@ -160,219 +153,163 @@
 		{
 			string platform = "AnyCPU";
 			bool newdoc = false;
-			XmlDocument doc = null;
+			MBBE.Project mbbeProject = null;
+			Engine engine = Engine.GlobalEngine;
 
 			MSBuildData data = (MSBuildData) project.ExtendedProperties [typeof (MSBuildFileFormat)];
 			if (data == null) {
-				//Create a new XmlDocument
-				doc = new XmlDocument ();
+				mbbeProject = engine.CreateNewProject ();
+				mbbeProject.FullFileName = file;
 				data = new MSBuildData ();
-				data.Document = doc;
+				data.Project = mbbeProject;
 				project.ExtendedProperties [typeof (MSBuildFileFormat)] = data;
 				newdoc = true;
 
-				XmlElement e = doc.CreateElement ("Project", ns);
-				doc.AppendChild (e);
-				e.SetAttribute ("DefaultTargets", "Build");
+				mbbeProject.DefaultTargets = "Build";
 			} else {
-				doc = data.Document;
+				mbbeProject = data.Project;
 			}
 
 			//Write out the Configurations
 			//FIXME: Not touching global config right now,
 			//instead just writing out everything in the individual configs
-			XmlElement globalConfigElement = data.GlobalConfigElement;
-			if (globalConfigElement == null) {
-				globalConfigElement = doc.CreateElement ("PropertyGroup", ns);
-				doc.DocumentElement.AppendChild (globalConfigElement);
 
-				data.GlobalConfigElement = globalConfigElement;
+			BuildPropertyGroup globalConfigGroup = data.GlobalConfigGroup;
+			// FIXME: Project.AddNewPropertyGroup doesn't put it where we want
+			if (globalConfigGroup == null) {
+				globalConfigGroup  = mbbeProject.AddNewPropertyGroup (false);
+				data.GlobalConfigGroup = globalConfigGroup;
 				data.Guid = Guid.NewGuid ().ToString ().ToUpper ();
 
 				//FIXME: EnsureChildValue for AssemblyName <-> OutputAssembly
-				//	Get this from where? different configs could have different ones.. 
+				//	Get this from where? different configs could have different ones..
 			}
+			EnsurePropertyValue (globalConfigGroup, null, "ProjectGuid", String.Concat ("{", data.Guid, "}"));
 
-			EnsureChildValue (globalConfigElement, "ProjectGuid", ns, 
-				String.Concat ("{", data.Guid, "}"));
-
 			//Default Config and platform
 			//Note: Ignoring this, not relevant for MD, but might be useful for prj2make
-			//For new projects, adding these elements in SaveProject
+			//For new projects, adding these elements in SaveProjecti
 			//
 			//string [] defaultActivePlatform = GetConfigPlatform (project.ActiveConfiguration.Name);
 			//SetForNullCondition (doc, globalConfigElement, "Configuration", defaultActivePlatform [0]);
 			//SetForNullCondition (doc, globalConfigElement, "Platform", defaultActivePlatform [1]);
 
 			foreach (DotNetProjectConfiguration config in project.Configurations) {
-				XmlElement configElement = null;
+				BuildPropertyGroup configGroup = null;
+				Dictionary <string, BuildProperty> bag = new Dictionary <string, BuildProperty> ();
 
-				if (data.ConfigElements.ContainsKey (config)) {
-					configElement = data.ConfigElements [config];
+				if (data.ConfigGroups.ContainsKey (config)) {
+					configGroup = data.ConfigGroups [config];
+					foreach (BuildProperty bp in configGroup)
+						bag [bp.Name] = bp;
 				} else {
-					//Create node for new configuration
-					configElement = doc.CreateElement ("PropertyGroup", ns);
-					doc.DocumentElement.AppendChild (configElement);
+					configGroup = mbbeProject.AddNewPropertyGroup (false);
 
 					string [] t = GetConfigPlatform (config.Name);
-					configElement.SetAttribute ("Condition", 
-						String.Format (" '$(Configuration)|$(Platform)' == '{0}|{1}' ", t [0], t [1]));
-					data.ConfigElements [config] = configElement;
+					configGroup.Condition = String.Format (" '$(Configuration)|$(Platform)' == '{0}|{1}' ", t [0], t [1]);
+					data.ConfigGroups [config] = configGroup;
 				}
 
-				EnsureChildValue (configElement, "OutputType", ns, config.CompileTarget);
-				EnsureChildValue (configElement, "AssemblyName", ns, config.OutputAssembly);
-				EnsureChildValue (configElement, "OutputPath", ns, 
-					Runtime.FileService.AbsoluteToRelativePath (project.BaseDirectory, config.OutputDirectory));
-				EnsureChildValue (configElement, "DebugSymbols", ns, config.DebugMode);
+				EnsurePropertyValue (configGroup, bag, "OutputType", config.CompileTarget);
+				EnsurePropertyValue (configGroup, bag, "AssemblyName", config.OutputAssembly);
+				EnsurePropertyValue (configGroup, bag, "OutputPath", Runtime.FileService.AbsoluteToRelativePath (
+					project.BaseDirectory, config.OutputDirectory));
+				EnsurePropertyValue (configGroup, bag, "DebugSymbols", config.DebugMode);
 
 				if (project.LanguageName == "VBNet") {
-					VBCompilerParameters vbparams = 
-						(VBCompilerParameters) config.CompilationParameters;
+					VBCompilerParameters vbparams = (VBCompilerParameters) config.CompilationParameters;
 
-					EnsureChildValue (configElement, "RootNamespace", ns, vbparams.RootNamespace);
-					EnsureChildValue (configElement, "AllowUnsafeBlocks", ns, vbparams.UnsafeCode);
-					EnsureChildValue (configElement, "Optimize", ns, vbparams.Optimize);
-					EnsureChildValue (configElement, "CheckForOverflowUnderflow", ns, vbparams.GenerateOverflowChecks);
-					EnsureChildValue (configElement, "DefineConstants", ns, vbparams.DefineSymbols);
-					EnsureChildValue (configElement, "WarningLevel", ns, vbparams.WarningLevel);
-					EnsureChildValue (configElement, "OptionExplicit", ns, vbparams.OptionExplicit);
-					EnsureChildValue (configElement, "OptionStrict", ns, vbparams.OptionStrict);
-					if (vbparams.Win32Icon != null && vbparams.Win32Icon.Length > 0)
-						EnsureChildValue (configElement, "ApplicationIcon", ns,
+					EnsurePropertyValue (configGroup, bag, "RootNamespace", vbparams.RootNamespace);
+					EnsurePropertyValue (configGroup, bag, "AllowUnsafeBlocks", vbparams.UnsafeCode);
+					EnsurePropertyValue (configGroup, bag, "Optimize", vbparams.Optimize);
+					EnsurePropertyValue (configGroup, bag, "CheckForOverflowUnderflow", vbparams.GenerateOverflowChecks);
+					EnsurePropertyValue (configGroup, bag, "DefineConstants", vbparams.DefineSymbols);
+					EnsurePropertyValue (configGroup, bag, "WarningLevel", vbparams.WarningLevel);
+					EnsurePropertyValue (configGroup, bag, "OptionExplicit", vbparams.OptionExplicit);
+					EnsurePropertyValue (configGroup, bag, "OptionStrict", vbparams.OptionStrict);
+
+					if (!String.IsNullOrEmpty (vbparams.Win32Icon))
+						EnsurePropertyValue (configGroup, bag, "ApplicationIcon", 
 							Runtime.FileService.AbsoluteToRelativePath (
 								project.BaseDirectory, vbparams.Win32Icon));
 
-					if (vbparams.Win32Resource != null && vbparams.Win32Resource.Length > 0)
-						EnsureChildValue (configElement, "Win32Resource", ns,
+					if (!String.IsNullOrEmpty (vbparams.Win32Resource))
+						EnsurePropertyValue (configGroup, bag, "Win32Resource", 
 							Runtime.FileService.AbsoluteToRelativePath (
 								project.BaseDirectory, vbparams.Win32Resource));
+				} else if (project.LanguageName == "C#") {
+					CSharpCompilerParameters csparams = (CSharpCompilerParameters) config.CompilationParameters;
 
-					//FIXME: VB.net Imports
-				}
+					EnsurePropertyValue (configGroup, bag, "AllowUnsafeBlocks", csparams.UnsafeCode);
+					EnsurePropertyValue (configGroup, bag, "Optimize", csparams.Optimize);
+					EnsurePropertyValue (configGroup, bag, "CheckForOverflowUnderflow", csparams.GenerateOverflowChecks);
+					EnsurePropertyValue (configGroup, bag, "DefineConstants", csparams.DefineSymbols);
+					EnsurePropertyValue (configGroup, bag, "WarningLevel", csparams.WarningLevel);
 
-				if (project.LanguageName == "C#") {
-					CSharpCompilerParameters csparams =
-						(CSharpCompilerParameters) config.CompilationParameters;
-
-					EnsureChildValue (configElement, "AllowUnsafeBlocks", ns, csparams.UnsafeCode);
-					EnsureChildValue (configElement, "Optimize", ns, csparams.Optimize);
-					EnsureChildValue (configElement, "CheckForOverflowUnderflow", ns, csparams.GenerateOverflowChecks);
-					EnsureChildValue (configElement, "DefineConstants", ns, csparams.DefineSymbols);
-					EnsureChildValue (configElement, "WarningLevel", ns, csparams.WarningLevel);
-					if (csparams.Win32Icon != null && csparams.Win32Icon.Length > 0)
-						EnsureChildValue (configElement, "ApplicationIcon", ns,
+					if (!String.IsNullOrEmpty (csparams.Win32Icon))
+						EnsurePropertyValue (configGroup, bag, "ApplicationIcon",
 							Runtime.FileService.AbsoluteToRelativePath (
-								project.BaseDirectory, csparams.Win32Icon));
+								project.BaseDirectory, csparams.Win32Resource));
 
-					if (csparams.Win32Resource != null && csparams.Win32Resource.Length > 0)
-						EnsureChildValue (configElement, "Win32Resource", ns,
+					if (!String.IsNullOrEmpty (csparams.Win32Resource))
+						EnsurePropertyValue (configGroup, bag, "Win32Resource",
 							Runtime.FileService.AbsoluteToRelativePath (
 								project.BaseDirectory, csparams.Win32Resource));
 				}
-			}
 
-			//FIXME: Set ActiveConfiguration
-
-			CleanUpEmptyItemGroups (doc);
-			
-			if (newdoc) {
-				//MUST go at the end.. 
-				XmlElement el = doc.CreateElement ("Import", ns);
-				doc.DocumentElement.InsertAfter (el, doc.DocumentElement.LastChild);
-				el.SetAttribute ("Project", @"$(MSBuildBinPath)\Microsoft.CSharp.Targets");
+				
 			}
+			// FIXME: wrong: it should add import depending on language
+			if (newdoc)
+				mbbeProject.AddNewImport (@"$(MSBuildBinPath)\Microsoft.CSharp.targets", null);
 
-			doc.Save (file);
-
-			return;
+			mbbeProject.Save (file);
 		}
 
-		/* Finds an element named @elementName, with a attribute Condition, which has "$(@elementName) = ''"
-		 * and sets @value for that. Creates the element if its not found. */
-		void SetForNullCondition (XmlDocument doc, XmlElement configElement, string elementName, string value)
+		void SetForNullCondition (MBBE.Project mbbeProject, BuildPropertyGroup configGroup, string name, string value)
 		{
-			XmlNodeList list = doc.SelectNodes (String.Format (
-					"/tns:Project/tns:PropertyGroup/tns:{0}[@Condition]", elementName),
-					NamespaceManager);
-			foreach (XmlNode node in list) {
-				if (CheckNullCondition (node as XmlElement, elementName)) {
-					node.InnerText = value;
-					return;
+			foreach (BuildPropertyGroup bpg in mbbeProject.PropertyGroups) {
+				foreach (BuildProperty bp in bpg) {
+					if (CheckNullCondition (bp.Condition, name)) {
+						bp.Value = value;
+						return;
+					}
 				}
 			}
 
-			//Add new xml element for active config
-			XmlElement elem = doc.CreateElement (elementName, ns);
-			configElement.AppendChild (elem);
-			elem.InnerText = value;
-
-			elem.SetAttribute ("Condition", " '$(" + elementName + ")' == '' ");
+			BuildProperty bp2 = configGroup.AddNewProperty (name, value);
+			bp2.Condition = String.Format (" $({0}) == '' ", name);
 		}
-
-		bool CheckNullCondition (XmlElement elem, string varName)
+		
+		// used in SlnFileFormat
+		internal void SaveProject (DotNetProject project, IProgressMonitor monitor)
 		{
-			if (elem == null)
-				return false;
-
-			//FIXME: This will get instantiated repeatedly, save this
-			StringDictionary dic = ParseCondition (elem.Attributes ["Condition"].Value);
-
-			string varUpper = varName.ToUpper ();
-			if (dic.Keys.Count == 1 && 
-				dic.ContainsKey (varUpper) && String.IsNullOrEmpty (dic [varUpper])) {
-				// Eg. '$(Configuration)' == ''
-				return true;
-			}
-
-			return false;
-		}
-
-		void CleanUpEmptyItemGroups (XmlDocument doc)
-		{
-			XmlNodeList list = doc.SelectNodes ("/tns:Project/tns:ItemGroup[count(child)=0]", NamespaceManager);
-			List<XmlNode> del = new List<XmlNode> ();
-			foreach (XmlNode n in list) {
-				if (!n.HasChildNodes)
-					del.Add (n);
-			}
-
-			foreach (XmlNode n in del)
-				n.ParentNode.RemoveChild (n);
-		}
-
-		public void SaveProject (DotNetProject project, IProgressMonitor monitor)
-		{
 			WriteFile (project.FileName, project, monitor);
 
 			MSBuildData d = (MSBuildData) project.ExtendedProperties [typeof (MSBuildFileFormat)];
 			if (d == null)
-				throw new Exception (String.Format ("INTERNAL ERROR: 'data' object not found for {0}", project.Name));
+				throw new InvalidOperationException (String.Format ("Internal error: 'data' object not found for {0}", project.Name));
 
-			foreach (ProjectFile pfile in project.ProjectFiles)
-				d.ProjectFileElements [pfile] = FileToXmlElement (d, project, pfile);
+			foreach (ProjectFile pf in project.ProjectFiles)
+				d.ProjectFileItems [pf] = FileToBuildItem (d, project, pf);
 
-			foreach (ProjectReference pref in project.ProjectReferences)
-				d.ProjectReferenceElements [pref] = ReferenceToXmlElement (d, project, pref);
+			foreach (ProjectReference pr in project.ProjectReferences)
+				d.ProjectReferenceItems [pr] = ReferenceToBuildItem (d, project, pr);
 
-			XmlElement elem = d.Document.CreateElement ("Configuration", ns);
-			d.GlobalConfigElement.AppendChild (elem);
-			elem.InnerText = "Debug";
-			elem.SetAttribute ("Condition", " '$(Configuration)' == '' ");
+			BuildProperty bp = d.GlobalConfigGroup.AddNewProperty ("Configuration", "Debug");
+			bp.Condition = " '$(Configuration)' == '' ";
 
-			elem = d.Document.CreateElement ("Platform", ns);
-			d.GlobalConfigElement.AppendChild (elem);
-			elem.InnerText = "AnyCPU";
-			elem.SetAttribute ("Condition", " '$(Platform)' == '' ");
+			bp = d.GlobalConfigGroup.AddNewProperty ("Platform", "AnyCPU");
+			bp.Condition = " '$(Platform)' == '' ";
 
 			SetupHandlers (project);
-			d.Document.Save (project.FileName);
+			d.Project.Save (project.FileName);
 		}
 
 		//Reader
 		public object ReadFile (string fileName, IProgressMonitor monitor)
 		{
-			Project project = null;
+			MDP.Project project = null;
 			if (monitor == null || fileName == null)
 				//FIXME: Use NullProgressMonitor for monitor?
 				return null;
@@ -393,38 +330,47 @@
 		//FIXME: Use monitor to report warnings/errors
 		DotNetProject LoadProject (string fname, IProgressMonitor monitor)
 		{
-			XmlDocument doc = new XmlDocument ();
-			doc.Load (fname);
+			Engine engine;
+			MBBE.Project mbbeProject;
+			string basePath, lang;
+			MSBuildData data;
 
-			XPathNavigator nav = doc.CreateNavigator ();
-			nav.MoveToFirstChild ();
+			engine = Engine.GlobalEngine;
 
-			while (! (nav.UnderlyingObject is XmlElement))
-				nav.MoveToNext ();
+			if (engine.BinPath == null)
+				engine.BinPath = ToolLocationHelper.GetPathToDotNetFramework (TargetDotNetFrameworkVersion.Version20);
 
-			if (nav.NamespaceURI != ns)
-				throw new UnknownProjectVersionException (fname, nav.NamespaceURI);
-
-			//Resolve ../'s 
+			//Resolve ../'s
 			fname = Path.GetFullPath (fname);
-			string lang = GetLanguage (fname);
-			string basePath = Path.GetDirectoryName (fname);
+			lang = GetLanguage (fname);
+			basePath = Path.GetDirectoryName (fname);
 
+			// FIXME: it won't throw UnknownProjectVersionException just InvalidProjectFileException (for everything)
+			
+			mbbeProject = engine.CreateNewProject ();
+			mbbeProject.Load (fname);
+
 			//Create the project
 			MSBuildProject project = new MSBuildProject (lang);
 			project.FileName = fname;
 			project.Version = "0.1"; //FIXME:
-			//Default project name
-			project.Name = Path.GetFileNameWithoutExtension (fname);
+			project.Name = mbbeProject.EvaluatedProperties ["AssemblyName"].FinalValue;
 			project.FileFormat = new MSBuildFileFormat (lang);
 			project.ClrVersion = ClrVersion.Net_2_0;
 
-			MSBuildData data = new MSBuildData ();
-			data.Document = doc;
+			data = new MSBuildData ();
+			data.Project = mbbeProject;
 			project.ExtendedProperties [typeof (MSBuildFileFormat)] = data;
+			
+			BuildPropertyGroup globalConfigGroup = null;
+			foreach (BuildPropertyGroup bpg in mbbeProject.PropertyGroups) {
+				if (bpg.Condition == String.Empty) {
+					globalConfigGroup = bpg;
+					break;
+				}
+			}
 
-			//Read the global config
-			XPathNodeIterator iter = nav.Select ("/tns:Project/tns:PropertyGroup[not(@Condition)]", NamespaceManager);
+			data.GlobalConfigGroup = globalConfigGroup;
 
 			DotNetProjectConfiguration globalConfig = (DotNetProjectConfiguration) project.CreateConfiguration ("Temp");
 			globalConfig.ClrVersion = ClrVersion.Net_2_0;
@@ -434,45 +380,44 @@
 			string default_platform = "AnyCPU";
 			string guid = null;
 			string rootNamespace = String.Empty;
-			while (iter.MoveNext ()) {
-				if (guid == null && 
-					ReadAsString (iter.Current, "ProjectGuid", ref str_tmp, false))
-					guid = str_tmp;
+			BuildProperty bp;
 
-				ReadConfig (iter.Current, globalConfig, project.LanguageName, basePath, ref default_config, ref default_platform);
-				//FIXME: Handle case when >1 global PropertyGroups exist,
-				data.GlobalConfigElement = (XmlElement) iter.Current.UnderlyingObject;
+			bp = mbbeProject.EvaluatedProperties ["ProjectGuid"];
+			if (guid == null && bp != null)
+				guid = bp.FinalValue;
+			else
+				data.Guid = guid.Trim (new char [] {'{', '}'});
 
-				//FIXME: RootNamespace can be specified per-config, but we are 
-				//taking the first occurrence
-				if (rootNamespace == String.Empty &&
-					ReadAsString (iter.Current, "RootNamespace", ref str_tmp, false)) {
-					rootNamespace = str_tmp;
-				}
-			}
-			project.DefaultNamespace = rootNamespace;
+			ReadConfig (mbbeProject, null, globalConfig, project.LanguageName, basePath, ref default_config, ref default_platform);
 
-			if (guid != null)
-				data.Guid = guid.Trim (new char [] {'{', '}'});
+			bp = mbbeProject.EvaluatedProperties ["RootNamespace"];
+			if (rootNamespace == String.Empty && bp != null)
+				ReadAsString (bp, ref rootNamespace, false);
 
-			//ReadItemGroups : References, Source files etc
-			ReadItemGroups (data, project, globalConfig, basePath, monitor);
+			project.DefaultNamespace = rootNamespace;
 
-			//Load configurations
-			iter = nav.Select ("/tns:Project/tns:PropertyGroup[@Condition]", NamespaceManager);
-			while (iter.MoveNext ()) {
-				string tmp = String.Empty;
-				string tmp2 = String.Empty;
-				StringDictionary dic = ParseCondition (
-						iter.Current.GetAttribute ("Condition", NamespaceManager.DefaultNamespace));
+			ReadItemGroups (mbbeProject, project, globalConfig, basePath, monitor);
+			ReadPropertyGroups (mbbeProject, project, globalConfig, basePath);
+			
+			SetupHandlers (project);
+			return project;
+		}
 
+		void ReadPropertyGroups (MBBE.Project mbbeProject, MSBuildProject project, DotNetProjectConfiguration globalConfig, string basePath)
+		{
+			foreach (BuildPropertyGroup bpg in mbbeProject.PropertyGroups) {
+				if (bpg.Condition == String.Empty)
+					continue;
+
+				string tmp = null;
+				string tmp2 = null;
+				Dictionary <string, string> dic = ParseCondition (bpg.Condition);
 				string configname = GetConfigName (dic);
+				// FIXME: probably not needed
 				if (configname == null)
 					continue;
 
-				DotNetProjectConfiguration config = 
-					(DotNetProjectConfiguration) project.GetConfiguration (configname);
-
+				DotNetProjectConfiguration config  = (DotNetProjectConfiguration) project.GetConfiguration (configname);
 				if (config == null) {
 					config = (DotNetProjectConfiguration) globalConfig.Clone ();
 					config.Name = configname;
@@ -480,19 +425,10 @@
 					project.Configurations.Add (config);
 				}
 
-				ReadConfig (iter.Current, config, project.LanguageName, basePath, ref tmp, ref tmp2);
+				ReadConfig (mbbeProject, bpg, config, project.LanguageName, basePath, ref tmp, ref tmp2);
 
-				data.ConfigElements [config] = (XmlElement) iter.Current.UnderlyingObject;
+				((MSBuildData) project.ExtendedProperties [typeof (MSBuildFileFormat)]).ConfigGroups [config] = bpg;
 			}
-
-			/* Note: Ignoring this, not required for MD, but might be useful in prj2make
-			string confname = default_config + "|" + default_platform;
-			if (project.Configurations [confname] != null)
-				project.ActiveConfiguration = project.Configurations [confname]; */
-
-			SetupHandlers (project);
-
-			return project;
 		}
 
 		static void SetupHandlers (DotNetProject project)
@@ -534,12 +470,13 @@
 		{
 			DotNetProject project = (DotNetProject) sender;
 			MSBuildData d = (MSBuildData) project.ExtendedProperties [typeof (MSBuildFileFormat)];
-			if (d == null || !d.ConfigElements.ContainsKey ((DotNetProjectConfiguration) e.Configuration))
+			if (d == null || !d.ConfigGroups.ContainsKey ((DotNetProjectConfiguration) e.Configuration))
 				return;
 
-			XmlElement elem = d.ConfigElements [(DotNetProjectConfiguration)e.Configuration];
-			elem.ParentNode.RemoveChild (elem);
-			d.ConfigElements.Remove ((DotNetProjectConfiguration)e.Configuration);
+			MBBE.Project mbbeProject = d.Project;
+			BuildPropertyGroup bpg = d.ConfigGroups [(DotNetProjectConfiguration) e.Configuration];
+			mbbeProject.RemovePropertyGroup (bpg);
+			d.ConfigGroups.Remove ((DotNetProjectConfiguration) e.Configuration);
 		}
 
 		//References
@@ -547,12 +484,13 @@
 		static void HandleReferenceRemoved (object sender, ProjectReferenceEventArgs e)
 		{
 			MSBuildData d = (MSBuildData) e.Project.ExtendedProperties [typeof (MSBuildFileFormat)];
-			if (d == null || !d.ProjectReferenceElements.ContainsKey (e.ProjectReference))
+			if (d == null || !d.ProjectReferenceItems.ContainsKey (e.ProjectReference))
 				return;
 
-			XmlElement elem = d.ProjectReferenceElements [e.ProjectReference];
-			elem.ParentNode.RemoveChild (elem);
-			d.ProjectReferenceElements.Remove (e.ProjectReference);
+			MBBE.Project mbbeProject = d.Project;
+			BuildItem reference = d.ProjectReferenceItems [e.ProjectReference];
+			mbbeProject.RemoveItem (reference);
+			d.ProjectReferenceItems.Remove (e.ProjectReference);
 		}
 
 		static void HandleReferenceAdded (object sender, ProjectReferenceEventArgs e)
@@ -562,8 +500,8 @@
 				if (d == null)
 					return;
 
-				d.ProjectReferenceElements [e.ProjectReference] = 
-					ReferenceToXmlElement (d, e.Project, e.ProjectReference);
+				d.ProjectReferenceItems [e.ProjectReference] = ReferenceToBuildItem (d, e.Project, e.ProjectReference);
+					
 			} catch (Exception ex) {
 				Runtime.LoggingService.ErrorFormat ("{0}", ex.Message);
 				Console.WriteLine ("{0}", ex.ToString ());
@@ -571,78 +509,61 @@
 			}
 		}
 
-		internal static XmlElement ReferenceToXmlElement (MSBuildData d, Project project, ProjectReference projectRef)
+		internal static BuildItem ReferenceToBuildItem (MSBuildData d, MDP.Project project, ProjectReference pr)
 		{
-			ReferenceType refType = projectRef.ReferenceType;
+			MBBE.Project mbbeProject = d.Project;
+			BuildItem item;
+			string name;
 
-			string elemName;
-			if (refType == ReferenceType.Project)
-				elemName = "ProjectReference";
+			if (pr.ReferenceType == ReferenceType.Project)
+				name = "ProjectReference";
 			else
-				elemName = "Reference";
+				name = "Reference";
 
-			XmlDocument doc = d.Document;
-			XmlElement elem = doc.CreateElement (elemName, ns);
+			item = mbbeProject.AddNewItem (name, pr.Reference);
 
-			//Add the element to the document
-			XmlNode node = doc.SelectSingleNode (String.Format ("/tns:Project/tns:ItemGroup/tns:{0}", elemName), NamespaceManager);
-			if (node == null) {
-				node = doc.CreateElement ("ItemGroup", ns);
-				doc.DocumentElement.AppendChild (node);
-				node.AppendChild (elem);
-			} else {
-				node.ParentNode.AppendChild (elem);
-			}
-
-			string reference = projectRef.Reference;
-			switch (refType) {
+			switch (pr.ReferenceType) {
 			case ReferenceType.Gac:
 				break;
 			case ReferenceType.Assembly:
-				reference = AssemblyName.GetAssemblyName (reference).ToString ();
-
-				AppendChild (elem, "HintPath", ns, 
-					Runtime.FileService.AbsoluteToRelativePath (project.BaseDirectory, projectRef.Reference));
-				AppendChild (elem, "SpecificVersion", ns, "False");
+				//FIXME: netmodule? no assembly manifest?
+				item.Include = AssemblyName.GetAssemblyName (pr.Reference).ToString ();
+				item.SetMetadata ("HintPath", Runtime.FileService.AbsoluteToRelativePath (project.BaseDirectory, pr.Reference));
+				item.SetMetadata ("SpecificVersion", "false");
 				break;
 			case ReferenceType.Project:
 				Combine c = project.RootCombine;
 				if (c != null) {
-					Project p = c.FindProject (projectRef.Reference);
+					MDP.Project p = c.FindProject (pr.Reference);
 					//FIXME: if (p == null) : This should not happen!
-					reference = Runtime.FileService.AbsoluteToRelativePath (
-						project.BaseDirectory, p.FileName);
+					item.Include = Runtime.FileService.AbsoluteToRelativePath (project.BaseDirectory, p.FileName);
 
 					if (p.ExtendedProperties.Contains (typeof (MSBuildFileFormat))) {
 						MSBuildData data = (MSBuildData) p.ExtendedProperties [typeof (MSBuildFileFormat)];
 						if (data.Guid != null & data.Guid.Length != 0)
-							EnsureChildValue (elem, "Project", ns, String.Concat ("{", data.Guid, "}"));
+							item.SetMetadata ("Project", String.Concat ("{", data.Guid, "}"));
 					}
 
-					AppendChild (elem, "Name", ns, p.Name);
+					item.SetMetadata ("Name", p.Name);
 				}
 				break;
 			case ReferenceType.Custom:
 				break;
 			}
-
-			//Add the Include attribute
-			elem.SetAttribute ("Include", reference);
-
-			return elem;
+			return item;
 		}
 
 		//ProjectFile-s
-
 		static void HandleFileRemoved (object sender, ProjectFileEventArgs e)
 		{
 			MSBuildData d = (MSBuildData) e.Project.ExtendedProperties [typeof (MSBuildFileFormat)];
-			if (d == null || !d.ProjectFileElements.ContainsKey (e.ProjectFile))
+			if (d == null || !d.ProjectFileItems.ContainsKey (e.ProjectFile))
 				return;
 
-			XmlElement elem = d.ProjectFileElements [e.ProjectFile];
-			elem.ParentNode.RemoveChild (elem);
-			d.ProjectFileElements.Remove (e.ProjectFile);
+			MBBE.Project mbbeProject = d.Project;
+			BuildItem file = d.ProjectFileItems [e.ProjectFile];
+			mbbeProject.RemoveItem (file);
+			d.ProjectFileItems.Remove (e.ProjectFile);
 		}
 
 		static void HandleFileAdded (object sender, ProjectFileEventArgs e)
@@ -651,77 +572,56 @@
 			if (d == null)
 				return;
 
-			d.ProjectFileElements [e.ProjectFile] = FileToXmlElement (d, e.Project, e.ProjectFile);
+			d.ProjectFileItems [e.ProjectFile] = FileToBuildItem (d, e.Project, e.ProjectFile);
 		}
 
-		static XmlElement FileToXmlElement (MSBuildData d, Project project, ProjectFile projectFile)
+		static BuildItem FileToBuildItem (MSBuildData d, MDP.Project project, ProjectFile projectFile)
 		{
 			string name = BuildActionToString (projectFile.BuildAction);
+			MBBE.Project mbbeProject = d.Project;
+
 			if (name == null) {
 				Runtime.LoggingService.WarnFormat ("BuildAction.{0} not supported!", projectFile.BuildAction);
 				Console.WriteLine ("BuildAction.{0} not supported!", projectFile.BuildAction);
-				return null;
+				return null;	
 			}
 
-			//FIXME: Subtype
+			BuildItem item = mbbeProject.AddNewItem (name, projectFile.RelativePath);
 
-			XmlDocument doc = d.Document;
-			XmlElement elem = doc.CreateElement (name, ns);
-			elem.SetAttribute ("Include", projectFile.RelativePath);
-
-			XmlNode n = doc.SelectSingleNode (String.Format (
-					"/tns:Project/tns:ItemGroup/tns:{0}", name), NamespaceManager);
-
-			if (n == null) {
-				n = doc.CreateElement ("ItemGroup", ns);
-				doc.DocumentElement.AppendChild (n);
-				n.AppendChild (elem);
-			} else {
-				n.ParentNode.AppendChild (elem);
-			}
-
 			if (projectFile.BuildAction == BuildAction.EmbedAsResource) {
 				MSBuildProject msproj = project as MSBuildProject;
-				if (msproj == null || 
-					MSBuildProject.GetDefaultResourceIdInternal (projectFile) != projectFile.ResourceId)
-					//Emit LogicalName if we are writing elements for a Non-MSBuidProject,
-					//(eg. when converting a gtk-sharp project, it might depend on non-vs
-					// style resource naming)
-					//Or when the resourceId is different from the default one
-					EnsureChildValue (elem, "LogicalName", ns, projectFile.ResourceId);
-				
-				//DependentUpon is relative to the basedir of the 'pf' (resource file)
+				if (msproj == null || MSBuildProject.GetDefaultResourceIdInternal (projectFile) != projectFile.ResourceId)
+					item.SetMetadata ("LogicalName", projectFile.ResourceId);
+
 				if (!String.IsNullOrEmpty (projectFile.DependsOn))
-					EnsureChildValue (elem, "DependentUpon", ns,
-						Runtime.FileService.AbsoluteToRelativePath (
-							Path.GetDirectoryName (projectFile.Name), projectFile.DependsOn));
+					item.SetMetadata ("DependendUpon", Runtime.FileService.AbsoluteToRelativePath (
+						Path.GetDirectoryName (projectFile.Name), projectFile.DependsOn));
 			}
-			
-			return elem;
+
+			return item;
 		}
 
 		static void HandleFileRenamed (object sender, ProjectFileRenamedEventArgs e)
 		{
 			MSBuildData d = (MSBuildData) e.Project.ExtendedProperties [typeof (MSBuildFileFormat)];
-			if (d == null || !d.ProjectFileElements.ContainsKey (e.ProjectFile))
+			if (d == null || !d.ProjectFileItems.ContainsKey (e.ProjectFile))
 				return;
 
 			//FIXME: Check whether this file is a ApplicationIcon and accordingly update that?
-			XmlElement elem = d.ProjectFileElements [e.ProjectFile];
-			elem.SetAttribute ("Include", e.ProjectFile.RelativePath);
+			BuildItem file = d.ProjectFileItems [e.ProjectFile];
+			file.Include = e.ProjectFile.RelativePath;
 		}
 
 		static void HandleFilePropertyChanged (object sender, ProjectFileEventArgs e)
 		{
 			//Subtype, BuildAction, DependsOn, Data
-
+			
 			MSBuildData d = (MSBuildData) e.Project.ExtendedProperties [typeof (MSBuildFileFormat)];
-			if (d == null || !d.ProjectFileElements.ContainsKey (e.ProjectFile))
+			if (d == null || !d.ProjectFileItems.ContainsKey (e.ProjectFile))
 				return;
 
-			XmlElement elem = d.ProjectFileElements [e.ProjectFile];
-
-			//BuildAction
+			BuildItem item = d.ProjectFileItems [e.ProjectFile];
+			
 			string buildAction = BuildActionToString (e.ProjectFile.BuildAction);
 			if (buildAction == null) {
 				Runtime.LoggingService.WarnFormat ("BuildAction.{0} not supported!", e.ProjectFile.BuildAction);
@@ -729,259 +629,154 @@
 				return;
 			}
 
-			if (elem.LocalName != buildAction) {
-				XmlElement newElem = d.Document.CreateElement (buildAction, ns);
-				XmlNode parent = elem.ParentNode;
+			if (item.Name != buildAction)
+				item.Name = buildAction;
 
-				List<XmlNode> list = new List<XmlNode> ();
-				foreach (XmlNode n in elem.ChildNodes)
-					list.Add (n);
-				foreach (XmlNode n in list)
-					newElem.AppendChild (elem.RemoveChild (n));
-
-				list.Clear ();
-				foreach (XmlAttribute a in elem.Attributes)
-					list.Add (a);
-
-				foreach (XmlAttribute a in list)
-					newElem.Attributes.Append (elem.Attributes.Remove (a));
-
-				parent.RemoveChild (elem);
-				parent.AppendChild (newElem);
-
-				d.ProjectFileElements [e.ProjectFile] = newElem;
-			}
-
-			//DependentUpon is relative to the basedir of the 'pf' (resource file)
-			EnsureChildValue (d.ProjectFileElements [e.ProjectFile], "DependentUpon", ns,
-					Runtime.FileService.AbsoluteToRelativePath (
-						Path.GetDirectoryName (e.ProjectFile.Name), e.ProjectFile.DependsOn));
 			//FIXME: Subtype, Data
 		}
 
-		static string BuildActionToString (BuildAction ba)
-		{
-			switch (ba) {
-			case BuildAction.Nothing:
-				return "None";								
-			case BuildAction.Compile:
-				return "Compile";
-			case BuildAction.EmbedAsResource:
-				return "EmbeddedResource";
-			case BuildAction.FileCopy:
-				return "Content";
-			case BuildAction.Exclude:
-				//FIXME:
-				break;
-			}
-
-			return null;
-		}
-
 		//Reading
 
-		void ReadItemGroups (MSBuildData data, DotNetProject project, 
+		void ReadItemGroups (MBBE.Project mbbeProject, DotNetProject project, 
 				DotNetProjectConfiguration globalConfig, string basePath, IProgressMonitor monitor)
 		{
-			//FIXME: This can also be Config/Platform specific
-			XmlNodeList itemList = data.Document.SelectNodes ("/tns:Project/tns:ItemGroup", NamespaceManager);
-
-			StringBuilder importsBuilder = null;
-			if (project.LanguageName == "VBNet")
-				importsBuilder = new StringBuilder ();
-
 			ProjectFile pf;
 			ProjectReference pr;
-			foreach (XmlNode itemGroup in itemList) {
-				foreach (XmlNode node in itemGroup.ChildNodes) {
-					if (node.NodeType != XmlNodeType.Element)
-						continue;
+			MSBuildData data = (MSBuildData) project.ExtendedProperties [typeof (MSBuildFileFormat)];
+			string path = null;
+			
+			foreach (BuildItem bi in mbbeProject.GetEvaluatedItemsByNameIgnoringCondition ("Compile")) {
+				if (bi.IsImported)
+					continue;
 
-					if (node.Attributes ["Include"] == null) {
-						Console.WriteLine ("Warning: Expected 'Include' attribute not found for ItemGroup '{0}'",
-							node.LocalName);
+				path = GetValidPath (monitor, basePath, bi.FinalItemSpec);
+				if (path == null)
+					continue;
+				
+				pf = project.AddFile (path, BuildAction.Compile);
+				data.ProjectFileItems [pf] = bi;
+			}
+			
+			foreach (BuildItem bi in mbbeProject.GetEvaluatedItemsByNameIgnoringCondition ("Reference")) {
+				string hintPath = String.Empty;
+				string fullName = Runtime.SystemAssemblyService.GetAssemblyFullName (bi.FinalItemSpec);
+
+				if (bi.HasMetadata ("HintPath")) {
+					path = MapAndResolvePath (basePath, hintPath);
+					if (path != null) {
+						pr = project.AddReference (path);
+						data.ProjectReferenceItems [pr] = bi;
 						continue;
 					}
 
-					string path = null;
-					string include = node.Attributes ["Include"].Value;
-					pf = null;
-					pr = null;
-					if (include.Length == 0)
-						//FIXME: Ignore, error??
-						continue;
+				}
+				if (fullName != null && Runtime.SystemAssemblyService.FindInstalledAssembly (fullName) != null) {
+					pr = new ProjectReference (ReferenceType.Gac, fullName ?? bi.FinalItemSpec);
+					project.ProjectReferences.Add (pr);
+					data.ProjectReferenceItems [pr] = bi;
+				}
+			}
 
-					string str_tmp = String.Empty;
-					switch (node.LocalName) {
-					case "Reference":
-						string hintPath = String.Empty;
-						string fullname = Runtime.SystemAssemblyService.GetAssemblyFullName (include);
-						if ((fullname != null && 
-							Runtime.SystemAssemblyService.FindInstalledAssembly (fullname) != null) ||
-							!ReadAsString (node, "HintPath", ref hintPath, false)) {
+			foreach (BuildItem bi in mbbeProject.GetEvaluatedItemsByNameIgnoringCondition ("ProjectReference")) {
+				string projGuid = null;
+				string projName = null;
 
-							//If the assembly is from a package file
-							//Or has _no_ HintPath, then add it as a Gac entry
-							pr = new ProjectReference (ReferenceType.Gac, fullname ?? include);
-							project.ProjectReferences.Add (pr);
-						} else {
-							//Not in the Gac, has HintPath
-							path = MapAndResolvePath (basePath, hintPath);
-							if (path == null) {
-								Console.WriteLine (GettextCatalog.GetString (
-									"HintPath ({0}) for Reference '{1}' is invalid. Ignoring.",
-									hintPath, include));
-								monitor.ReportWarning (GettextCatalog.GetString (
-									"HintPath ({0}) for Reference '{1}' is invalid. Ignoring.",
-									hintPath, include));
+				if (bi.HasMetadata ("Project"))
+					projGuid = bi.GetMetadata ("Project");
+				if (bi.HasMetadata ("Name"))
+					projName = bi.GetMetadata ("Name");
 
-								continue;
-							}
-	
-							pr = project.AddReference (path);
-						}
-						data.ProjectReferenceElements [pr] = (XmlElement) node;
+				if (String.IsNullOrEmpty (projName)) {
+					//FIXME: Add support to load the project file from here
+					Console.WriteLine ("Expected element <Name> for ProjectReference '{0}'", bi.FinalItemSpec);
+					continue;
+				}
 
-						break;
-					case "ProjectReference":
-						//Not using @Include currently, instead using the Name
-						string projGuid = null;
-						string projName = null;
+				pr = new ProjectReference (ReferenceType.Project, projName);
+				project.ProjectReferences.Add (pr);
 
-						if (node ["Project"] != null)
-							projGuid = node ["Project"].InnerText;
-						if (node ["Name"] != null)
-							projName = node ["Name"].InnerText;
+				data.ProjectReferenceItems [pr] = bi;
+			}
 
-						if (String.IsNullOrEmpty (projName)) {
-							//FIXME: Add support to load the project file from here
-							Console.WriteLine ("Expected element <Name> for ProjectReference '{0}'", include);
-							continue;
-						}
+			foreach (BuildItem bi in mbbeProject.GetEvaluatedItemsByNameIgnoringCondition ("None")) {
+				path = GetValidPath (monitor, basePath, bi.FinalItemSpec);
+				if (path == null)
+					continue;
+				pf = project.AddFile (path, BuildAction.Nothing);
+				data.ProjectFileItems [pf] = bi;
+			}
 
-						pr = new ProjectReference (ReferenceType.Project, projName);
-						project.ProjectReferences.Add (pr);
-						data.ProjectReferenceElements [pr] = (XmlElement) node;
+			foreach (BuildItem bi in mbbeProject.GetEvaluatedItemsByNameIgnoringCondition ("Content")) {
+				path = GetValidPath (monitor, basePath, bi.FinalItemSpec);
+				if (path == null)
+					continue;
+				pf = project.AddFile (path, BuildAction.FileCopy);
+				data.ProjectFileItems [pf] = bi;
+			}
 
-						break;
-					case "Compile":
-						path = GetValidPath (monitor, basePath, include);
-						if (path == null)
-							continue;
-						pf = project.AddFile (path, BuildAction.Compile);
-						data.ProjectFileElements [pf] = (XmlElement) node;
-						break;
-					case "None":
-						path = GetValidPath (monitor, basePath, include);
-						if (path == null)
-							continue;
-						pf = project.AddFile (path, BuildAction.Nothing);
-						data.ProjectFileElements [pf] = (XmlElement) node;
-						break;
-					case "Content":
-						path = GetValidPath (monitor, basePath, include);
-						if (path == null)
-							continue;
-						pf = project.AddFile (path, BuildAction.FileCopy);
-						data.ProjectFileElements [pf] = (XmlElement) node;
-						break;
-					case "EmbeddedResource":
-						path = GetValidPath (monitor, basePath, include);
-						if (path == null)
-							continue;
+			foreach (BuildItem bi in mbbeProject.GetEvaluatedItemsByNameIgnoringCondition ("EmbeddedResource")) {
+				path = GetValidPath (monitor, basePath, bi.FinalItemSpec);
+				if (path == null)
+					continue;
 
-						if (!path.StartsWith (project.BaseDirectory)) {
-							monitor.ReportWarning (GettextCatalog.GetString (
-								"The specified path '{0}' for the EmbeddedResource is outside the project directory. Ignoring.", include));
-							Console.WriteLine ("The specified path '{0}' for the EmbeddedResource is outside the project directory. Ignoring.", include);
-							continue;
-						}
-
-						pf = project.AddFile (path, BuildAction.EmbedAsResource);
-						if (ReadAsString (node, "LogicalName", ref str_tmp, false))
-							pf.ResourceId = str_tmp;
-						data.ProjectFileElements [pf] = (XmlElement) node;
-						break;
-					case "Import":
-						//FIXME: Keep nodes for each import? List of imports?
-						//This will probably have to be written back in WriteFile
-						importsBuilder.AppendFormat ("{0},", include);
-						break;
-					default:
-						Console.WriteLine ("Unrecognised ItemGroup element '{0}', Include = '{1}'. Ignoring.", node.LocalName, include);
-						break;
-					}
-
-					if (pf != null) {
-						if (ReadAsString (node, "DependentUpon", ref str_tmp, false))
-							//DependentUpon is relative to the basedir of the 'pf' (resource file)
-							pf.DependsOn = MapAndResolvePath (Path.GetDirectoryName (pf.Name), str_tmp);
-
-						if (String.Compare (node.LocalName, "Content", true) != 0 && 
-							ReadAsString (node, "CopyToOutputDirectory", ref str_tmp, false))
-							Console.WriteLine ("Warning: CopyToOutputDirectory not supported for BuildAction '{0}', Include = '{1}'", node.LocalName, include);
-					}
+				if (!path.StartsWith (project.BaseDirectory)) {
+					monitor.ReportWarning (GettextCatalog.GetString (
+						"The specified path '{0}' for the EmbeddedResource is outside the project directory. Ignoring.", bi.FinalItemSpec));
+						Console.WriteLine ("The specified path '{0}' for the EmbeddedResource is outside the project directory. Ignoring.", bi.FinalItemSpec);
+					continue;
 				}
-			}
 
-			if (project.LanguageName == "VBNet") {
-				if (importsBuilder.Length > 0) {
-					importsBuilder.Length --;
-					VBCompilerParameters vbparams = (VBCompilerParameters) globalConfig.CompilationParameters;
-					vbparams.Imports = importsBuilder.ToString ();
-				}
+				pf = project.AddFile (path, BuildAction.EmbedAsResource);
+				if (bi.HasMetadata ("LogicalName"))
+					pf.ResourceId = bi.GetMetadata ("LogicalName");
+				data.ProjectFileItems [pf] = bi;
 			}
 		}
 
-		string GetValidPath (IProgressMonitor monitor, string basePath, string relPath)
+		void ReadConfig (MBBE.Project project, BuildPropertyGroup bpg, DotNetProjectConfiguration config,
+				 string lang, string basePath, ref string default_config, ref string default_platform)
 		{
-			string path = MapAndResolvePath (basePath, relPath);
-			if (path != null)
-				return path;
+			Dictionary <string, BuildProperty> properties = new Dictionary <string, BuildProperty> ();
+			if (bpg != null)
+				foreach (BuildProperty b in bpg)
+					properties.Add (b.Name, b);
+			else
+				foreach (BuildProperty b in project.EvaluatedProperties)
+					properties.Add (b.Name, b);
 
-			Console.WriteLine (GettextCatalog.GetString ("File name '{0}' is invalid. Ignoring.", relPath));
-			monitor.ReportWarning (GettextCatalog.GetString ("File name '{0}' is invalid. Ignoring.", relPath));
-			return null;
-		}
+			BuildProperty bp;
 
-		//FIXME: Too many params ?
-		void ReadConfig (XPathNavigator nav, DotNetProjectConfiguration config,
-				string lang, string basePath, ref string default_config, ref string default_platform)
-		{
-			if (nav.MoveToChild ("OutputType", ns)) {
+			bp = properties ["OutputType"];
+			if (bp != null) {
 				try {
-					config.CompileTarget = (CompileTarget) Enum.Parse (typeof (CompileTarget), nav.Value, true);
+					config.CompileTarget = (CompileTarget) Enum.Parse (typeof (CompileTarget), bp.FinalValue, true);
 				} catch (ArgumentException) {
 					//Ignore
 				}
-				nav.MoveToParent ();
 			}
 
-			if (nav.MoveToChild ("Configuration", ns)) {
-				if (CheckNullCondition (nav.UnderlyingObject as XmlElement, "Configuration"))
-					default_config = nav.Value;
+			bp = properties ["Configuration"];
+			if (bp != null)
+				if (CheckNullCondition (bp.Condition, "Configuration"))
+					default_config = bp.FinalValue;
 
-				nav.MoveToParent ();
-			}
-			
-			if (nav.MoveToChild ("Platform", ns)) {
-				if (CheckNullCondition (nav.UnderlyingObject as XmlElement, "Platform"))
-					default_platform = nav.Value;
+			bp = properties ["Platform"];
+			if (bp != null)
+				if (CheckNullCondition (bp.Condition, "Platform"))
+					default_platform = bp.FinalValue;
 
-				nav.MoveToParent ();
-			}
 
 			string str_tmp = String.Empty;
 			int int_tmp = 0;
 			bool bool_tmp = false;
 
-			if (ReadAsString (nav, "AssemblyName", ref str_tmp, false))
+			if (ReadAsString (properties ["AssemblyName"], ref str_tmp, false))
 				config.OutputAssembly = str_tmp;
 
-			if (ReadAsString (nav, "OutputPath", ref str_tmp, false))
+			if (ReadAsString (properties ["OutputPath"], ref str_tmp, false))
 				config.OutputDirectory = MapAndResolvePath (basePath, str_tmp);
 
-			if (ReadAsBool (nav, "DebugSymbols", ref bool_tmp))
+			if (ReadAsBool (properties ["DebugSymbols"], ref bool_tmp))
 				//FIXME: <DebugType>?
 				config.DebugMode = bool_tmp;
 
@@ -989,34 +784,34 @@
 				VBCompilerParameters vbparams = 
 					(VBCompilerParameters) config.CompilationParameters;
 
-				if (ReadAsString (nav, "RootNamespace", ref str_tmp, false))
+				if (ReadAsString (properties ["RootNamespace"], ref str_tmp, false))
 					vbparams.RootNamespace = str_tmp;
 
-				if (ReadAsBool (nav, "AllowUnsafeBlocks", ref bool_tmp))
+				if (ReadAsBool (properties ["AllowUnsafeBlocks"], ref bool_tmp))
 					vbparams.UnsafeCode = bool_tmp;
 
-				if (ReadAsBool (nav, "Optimize", ref bool_tmp))
+				if (ReadAsBool (properties ["Optimize"], ref bool_tmp))
 					vbparams.Optimize = bool_tmp;
 
-				if (ReadAsBool (nav, "CheckForOverflowUnderflow", ref bool_tmp))
+				if (ReadAsBool (properties ["CheckForOverflowUnderflow"], ref bool_tmp))
 					vbparams.GenerateOverflowChecks = bool_tmp;
 
-				if (ReadAsString (nav, "DefineConstants", ref str_tmp, true))
+				if (ReadAsString (properties ["DefineConstants"], ref str_tmp, true))
 					vbparams.DefineSymbols = str_tmp;
 
-				if (ReadAsInt (nav, "WarningLevel", ref int_tmp))
+				if (ReadAsInt (properties ["WarningLevel"], ref int_tmp))
 					vbparams.WarningLevel = int_tmp;
 
-				if (ReadOffOnAsBool (nav, "OptionExplicit", ref bool_tmp))
+				if (ReadOffOnAsBool (properties ["OptionExplicit"], ref bool_tmp))
 					vbparams.OptionExplicit = bool_tmp;
 
-				if (ReadOffOnAsBool (nav, "OptionStrict", ref bool_tmp))
+				if (ReadOffOnAsBool (properties ["OptionStrict"], ref bool_tmp))
 					vbparams.OptionStrict = bool_tmp;
 
-				if (ReadAsString (nav, "ApplicationIcon", ref str_tmp, false))
+				if (ReadAsString (properties ["ApplicationIcon"], ref str_tmp, false))
 					vbparams.Win32Icon = MapAndResolvePath (basePath, str_tmp);
 
-				if (ReadAsString (nav, "Win32Resource", ref str_tmp, false))
+				if (ReadAsString (properties ["Win32Resource"], ref str_tmp, false))
 					vbparams.Win32Resource = MapAndResolvePath (basePath, str_tmp);
 				//FIXME: OptionCompare, add support to VBnet binding, params etc
 			}
@@ -1025,32 +820,33 @@
 				CSharpCompilerParameters csparams =
 					(CSharpCompilerParameters) config.CompilationParameters;
 
-				if (ReadAsBool (nav, "AllowUnsafeBlocks", ref bool_tmp))
+				if (ReadAsBool (properties ["AllowUnsafeBlocks"], ref bool_tmp))
 					csparams.UnsafeCode = bool_tmp;
 
-				if (ReadAsBool (nav, "Optimize", ref bool_tmp))
+				if (ReadAsBool (properties ["Optimize"], ref bool_tmp))
 					csparams.Optimize = bool_tmp;
 
-				if (ReadAsBool (nav, "CheckForOverflowUnderflow", ref bool_tmp))
+				if (ReadAsBool (properties ["CheckForOverflowUnderflow"], ref bool_tmp))
 					csparams.GenerateOverflowChecks = bool_tmp;
 
-				if (ReadAsString (nav, "DefineConstants", ref str_tmp, true))
+				if (ReadAsString (properties ["DefineConstants"], ref str_tmp, true))
 					csparams.DefineSymbols = str_tmp;
 
-				if (ReadAsInt (nav, "WarningLevel", ref int_tmp))
+				if (ReadAsInt (properties ["WarningLevel"], ref int_tmp))
 					csparams.WarningLevel = int_tmp;
 
-				if (ReadAsString (nav, "ApplicationIcon", ref str_tmp, false))
+				if (ReadAsString (properties ["ApplicationIcon"], ref str_tmp, false))
 					csparams.Win32Icon = MapAndResolvePath (basePath, str_tmp);
 				
-				if (ReadAsString (nav, "Win32Resource", ref str_tmp, false))
+				if (ReadAsString (properties ["Win32Resource"], ref str_tmp, false))
 					csparams.Win32Resource = MapAndResolvePath (basePath, str_tmp);
 			}
+
 		}
 
-		StringDictionary ParseCondition (string condition)
+		Dictionary <string, string> ParseCondition (string condition)
 		{
-			StringDictionary dic = new StringDictionary ();
+			Dictionary <string, string> dic = new Dictionary <string, string> (StringComparer.InvariantCultureIgnoreCase);
 
 			if (condition == null || condition.Length == 0)
 				return dic;
@@ -1071,9 +867,9 @@
 					//FIXME: Yuck!
 					string key = left_parts [i].Substring (2, left_parts [i].Length - 3);
 					if (i < right_parts.Length)
-						dic [key.ToUpper ()] = right_parts [i].Trim ();
+						dic [key] = right_parts [i].Trim ();
 					else
-						dic [key.ToUpper ()] = String.Empty;
+						dic [key] = String.Empty;
 				}
 
 			}
@@ -1082,152 +878,113 @@
 		}
 
 		//Utility methods
-
-		static XmlNode MoveToChild (XmlNode node, string localName)
+		
+		static void EnsurePropertyValue (BuildPropertyGroup group, Dictionary <string, BuildProperty> bag, string name, object value)
 		{
-			if (!node.HasChildNodes)
-				return null;
+			BuildProperty bp = null;
 
-			foreach (XmlNode n in node.ChildNodes)
-				if (n.LocalName == localName)
-					return n;
-
-			return null;
-		}
-
-		internal static void EnsureChildValue (XmlNode node, string localName, string ns, object val)
-		{
-			XmlNode n = MoveToChild (node, localName);
-			if (n == null) {
-				//Child not found, create it
-				XmlElement e = node.OwnerDocument.CreateElement (localName, ns);
-				e.InnerText = val.ToString ();
-
-				node.AppendChild (e);
+			// O (N)
+			if (bag == null) {
+				foreach (BuildProperty bprop in group)
+					if (bprop.Name == name)
+						bp = bprop;
+				if (bp == null) {
+					bp = group.AddNewProperty (name, value.ToString ());
+					bag [name] = bp;
+				} else
+					bp.Value = value.ToString ();
 			} else {
-				n.InnerText = val.ToString ();
+				if (bag.ContainsKey (name)) {
+					bag [name].Value = value.ToString ();
+				} else {
+					bp = group.AddNewProperty (name, value.ToString ());
+					bag [name] = bp;
+				}
 			}
 		}
-
-		bool ReadAsString (XmlNode node, string localName, ref string val, bool allowEmpty)
+		
+		static string GetValidPath (IProgressMonitor monitor, string basePath, string relPath)
 		{
-			//Assumption: Number of child nodes is small enough
-			//that xpath query would be more expensive than
-			//linear traversal
-			if (node == null || !node.HasChildNodes)
-				return false;
+			string path = MapAndResolvePath (basePath, relPath);
+			if (path != null)
+				return path;
 
-			foreach (XmlNode n in node.ChildNodes) {
-				//Case sensitive compare
-				if (n.LocalName != localName)
-					continue;
-
-				//FIXME: Use XmlChar.WhitespaceChars ?
-				string s= n.InnerText.Trim ();
-				if (s.Length == 0 && !allowEmpty)
-					return false;
-
-				val = s;
-				return true;
-			}
-
-			return false;
+			Console.WriteLine (GettextCatalog.GetString ("File name '{0}' is invalid. Ignoring", relPath));
+			monitor.ReportWarning (GettextCatalog.GetString ("File name '{0}' is invalid. Ignoring", relPath));
+			return null;
 		}
 
-		bool ReadAsString (XPathNavigator nav, string localName, ref string val, bool allowEmpty)
+		bool ReadAsString (BuildProperty bp, ref string output, bool allowEmpty)
 		{
-			if (!nav.MoveToChild (localName, ns))
+			if (bp == null)
 				return false;
 
-			//FIXME: Use XmlChar.WhitespaceChars ?
-			string s = nav.Value.Trim ();
-			nav.MoveToParent ();
-
-			if (s.Length == 0 && !allowEmpty)
+			output = bp.FinalValue;
+			if (output.Length == 0 && !allowEmpty)
 				return false;
 
-			val = s;
 			return true;
 		}
 
-		bool ReadAsBool (XPathNavigator nav, string localName, ref bool val)
+		bool ReadAsBool (BuildProperty bp, ref bool output)
 		{
-			string str = String.Empty;
-			if (!ReadAsString (nav, localName, ref str, false))
+			if (bp == null)
 				return false;
 
-			switch (str.ToUpper ()) {
-			case "TRUE":
-				val = true;
-				break;
-			case "FALSE":
-				val = false;
-				break;
+			switch (bp.FinalValue.ToLower ()) {
+			case "true":
+				output = true;
+				return true;
+			case "false":
+				output = false;
+				return true;
 			default:
 				return false;
 			}
-
-			return true;
 		}
 
-		bool ReadOffOnAsBool (XPathNavigator nav, string localName, ref bool val)
+		bool ReadOffOnAsBool (BuildProperty bp, ref bool output)
 		{
-			string str = String.Empty;
-			if (!ReadAsString (nav, localName, ref str, false))
+			if (bp == null)
 				return false;
 
-			switch (str.ToUpper ()) {
-			case "ON":
-				val = true;
-				break;
-			case "OFF":
-				val = false;
-				break;
+			switch (bp.FinalValue.ToLower ()) {
+			case "on":
+				output = true;
+				return true;
+			case "off":
+				output = false;
+				return true;
 			default:
 				return false;
 			}
-
-			return true;
 		}
 
-		bool ReadAsInt (XPathNavigator nav, string localName, ref int val)
+		bool ReadAsInt (BuildProperty bp, ref int output)
 		{
-			if (!nav.MoveToChild (localName, ns))
+			if (bp == null)
 				return false;
 
 			try {
-				val = nav.ValueAsInt;
+				output = Int32.Parse (bp.FinalValue);
+				return true;
 			} catch {
 				return false;
-			} finally {
-				nav.MoveToParent ();
 			}
-
-			return true;
 		}
 
-		//Creates a <localName>Value</localName>
-		internal static XmlElement AppendChild (XmlElement e, string localName, string ns, string value)
+		static string GetConfigName (Dictionary <string, string> dic)
 		{
-			XmlElement elem = e.OwnerDocument.CreateElement (localName, ns);
-			elem.InnerText = value;
-			e.AppendChild (elem);
-
-			return elem;
-		}
-
-		static string GetConfigName (StringDictionary dic)
-		{
-			if (!dic.ContainsKey ("CONFIGURATION") || 
-				String.IsNullOrEmpty (dic ["CONFIGURATION"]))
+			if (!dic.ContainsKey ("Configuration") || 
+				String.IsNullOrEmpty (dic ["Configuration"]))
 				return null;
 
-			string configname = dic ["CONFIGURATION"];
-			if (dic.ContainsKey ("PLATFORM") && !String.IsNullOrEmpty (dic ["PLATFORM"])) {
-				if (String.Compare (dic ["PLATFORM"], "AnyCPU", true) == 0)
+			string configname = dic ["Configuration"];
+			if (dic.ContainsKey ("Platform") && !String.IsNullOrEmpty (dic ["Platform"])) {
+				if (String.Compare (dic ["Platform"], "AnyCPU", true) == 0)
 					configname = configname + "|Any CPU";
 				else
-					configname = configname + "|" + dic ["PLATFORM"];
+					configname = configname + "|" + dic ["Platform"];
 			}
 
 			return configname;
@@ -1249,7 +1006,7 @@
 			return ret;
 		}
 
-		internal static string MapAndResolvePath (string basePath, string relPath)
+		static string MapAndResolvePath (string basePath, string relPath)
 		{
 			string ret = SlnMaker.MapPath (basePath, relPath);
 			if (ret == null)
@@ -1257,17 +1014,49 @@
 			return Path.GetFullPath (ret);
 		}
 
-		string GetLanguage (string fileName)
+		static string GetLanguage (string filename)
 		{
-			string extn = Path.GetExtension (fileName);
+			string extn = Path.GetExtension (filename);
 			if (String.Compare (extn, ".csproj", true) == 0)
 				return "C#";
 			if (String.Compare (extn, ".vbproj", true) == 0)
 				return "VBNet";
+			return null;
+		}
 
+		static string BuildActionToString (BuildAction ba)
+		{
+			switch (ba) {
+			case BuildAction.Nothing:
+				return "None";								
+			case BuildAction.Compile:
+				return "Compile";
+			case BuildAction.EmbedAsResource:
+				return "EmbeddedResource";
+			case BuildAction.FileCopy:
+				return "Content";
+			case BuildAction.Exclude:
+				//FIXME:
+				break;
+			}
+
 			return null;
 		}
 
+		bool CheckNullCondition (string condition, string var)
+		{
+			Dictionary <string, string> dic = ParseCondition (condition);
+
+			// FIXME: change it
+			if (dic.Keys.Count == 1 && 
+				dic.ContainsKey (var) && String.IsNullOrEmpty (dic [var])) {
+				// Eg. '$(Configuration)' == ''
+				return true;
+			}
+
+			return false;
+		}
+
 		static Regex conditionRegex = null;
 		static Regex ConditionRegex {
 			get {
