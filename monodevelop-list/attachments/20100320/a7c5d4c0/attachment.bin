Index: MonoDevelop.CodeMetrics.csproj
===================================================================
--- MonoDevelop.CodeMetrics.csproj	(revision 153925)
+++ MonoDevelop.CodeMetrics.csproj	(working copy)
@@ -61,6 +61,9 @@
     <Reference Include="atk-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f">
       <SpecificVersion>False</SpecificVersion>
     </Reference>
+    <Reference Include="NRefactory, Version=2.1.1.0, Culture=neutral">
+      <Package>monodevelop</Package>
+    </Reference>
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\..\core\MonoDevelop.Ide\MonoDevelop.Ide.csproj">
@@ -103,6 +106,26 @@
     <Compile Include="MonoDevelop.CodeMetrics\Commands.cs" />
     <Compile Include="gtk-gui\generated.cs" />
     <Compile Include="gtk-gui\MonoDevelop.CodeMetrics.CodeMetricsWidget.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\ProjectProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\ASTVisitor.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\LOCEvaluate.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\ClassProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\CodeMetricsServices.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\ComplexityMetrics.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\NamespaceProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\Coupling.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\MethodProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\MetricsContext.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\InterfaceProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\DelegateProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\StructProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\Cohesion.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\EnumProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\InheritanceTree.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\FieldProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\ObjectOrientedMetrics.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\IProperties.cs" />
+    <Compile Include="MonoDevelop.CodeMetrics\AssociationBetweenClasses.cs" />
   </ItemGroup>
   <ItemGroup>
     <None Include="ChangeLog" />
Index: MonoDevelop.CodeMetrics/MetricsContext.cs
===================================================================
--- MonoDevelop.CodeMetrics/MetricsContext.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/MetricsContext.cs	(revision 0)
@@ -0,0 +1,90 @@
+// 
+// ClassPropertiesCollection.cs
+//  
+// Author:
+//       Michael Hutchinson <mhutchinson@novell.com>
+// 		 Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2010 Novell, Inc. (http://www.novell.com), Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Linq;
+using System.Collections.Generic;
+using System.Text;
+using MonoDevelop.Projects.Dom;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class MetricsContext 
+	{
+		/// <summary>
+		/// 
+		/// </summary>
+		/// <param name="cls">
+		/// A <see cref="IType"/>
+		/// </param>
+		/// <returns>
+		/// A <see cref="ClassProperties"/>
+		/// </returns>
+		internal ClassProperties GetInstanceOf (IType cls)
+		{
+			try {
+				if(cls.BodyRegion.Start==cls.BodyRegion.End)
+						return null;
+				foreach (var projprop in CodeMetricsWidget.widget.Projects)
+				{
+					foreach (var clsprop in projprop.Classes) {
+						var ret = RecursiveFindInstance (cls, clsprop.Value);
+						if(ret!=null)
+							return ret;
+					}
+					foreach (var prop in projprop.Namespaces) {
+						foreach (var clsprop in prop.Value.Classes) {
+							var ret = RecursiveFindInstance (cls, clsprop.Value);
+							if (ret != null)
+				    			return ret;
+						}
+					}
+				}
+			} catch (NullReferenceException nre) { return null; }
+			return null;
+		}
+		
+		private static ClassProperties RecursiveFindInstance (IType cls, ClassProperties prop)
+		{
+			foreach (var innercls in prop.InnerClasses) {
+				var ret = RecursiveFindInstance (cls, innercls.Value);
+				if (ret != null)
+					return ret;
+			}
+			
+			if (prop.Class.FullName == cls.FullName)
+				return prop;
+			return null;
+		}
+		
+		private int GetRootCount ()
+		{
+			//return instances.Where (c => c.IsRoot).Count ();
+			return 0;
+		}
+	}
+}
Index: MonoDevelop.CodeMetrics/InterfaceProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/InterfaceProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/InterfaceProperties.cs	(revision 0)
@@ -0,0 +1,107 @@
+// 
+// InterfaceProperties.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2009 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Text;
+
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class InterfaceProperties : IProperties
+	{
+		IType interfce;
+		
+		//TODO Implement method properties for Interfaces
+		Dictionary<string, MethodProperties> Methods;
+		Dictionary<string, FieldProperties> Fields;
+		
+		public IType Interface {
+			get {
+				return interfce;
+			}
+		}
+		
+		public string FullName {
+			get; internal set;
+		}
+		
+		public int CyclometricComplexity {
+			get {
+				return 0;
+			}
+		}
+		
+		public int ClassCoupling {
+			get; internal set;
+		}
+		
+		public int StartLine {
+			get; private set;
+		}
+		
+		public int EndLine {
+			get; private set;
+		}
+		
+		public ulong LOCReal {
+			get; internal set;
+		}
+		
+		public ulong LOCComments {
+			get;internal set;
+		}
+		
+		public string FilePath { 
+			get; set;
+		}
+		
+		public InterfaceProperties (IType i)
+		{
+			interfce = i;
+			FullName = Interface.FullName;
+			StartLine = Interface.BodyRegion.Start.Line;
+			EndLine = Interface.BodyRegion.End.Line;
+			FilePath="";
+		}
+	
+	}
+}
Index: MonoDevelop.CodeMetrics/Coupling.cs
===================================================================
--- MonoDevelop.CodeMetrics/Coupling.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/Coupling.cs	(revision 0)
@@ -0,0 +1,159 @@
+// 
+// Coupling.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2010 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.IO;
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory;
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public partial class ComplexityMetrics
+	{
+		class Coupling
+		{
+			/*
+			 * #  Coupling Between Objects (CBO): CBO is defined as the number of non-inherited classes associated with the target class. It is counted as the number of types that are used in attributes, parameters, return types, throws clauses, etc. Primitive types and system types (e.g. java.lang.*) are not counted.
+				# Data Abstraction Coupling (DAC): DAC is defined as the total number of referred types in attribute declarations. Primitive types, system types, and types inherited from the super classes are not counted.
+				# Method Invocation Coupling (MIC): MIC is defined as the relative number of classes that receive messages from a particular class. 
+			 */
+			
+			/// <summary>
+			///  Very experimental, lots of things to be done here (handling function calls in parameters, fetching correct method references from incomplete names). Refer to ORG files
+			/// </summary>
+			/// <param name="expression">
+			/// A <see cref="InvocationExpression"/>
+			/// </param>
+			/// <param name="meth">
+			/// A <see cref="MethodProperties"/>
+			/// </param>
+			private readonly static object coupleLock = new object();
+			
+			public static string EvaluateMethodCoupling(InvocationExpression expression, MethodProperties meth)
+			{
+				Console.WriteLine(expression.ToString());
+				
+				meth.EfferentCoupling++;
+				
+				StringBuilder calleeName = new StringBuilder();
+				List<string> paramList = new List<string>();
+				MethodProperties methCallee = null;
+				lock(coupleLock)
+				{
+					if(expression.TargetObject is MemberReferenceExpression) {
+					
+			   			calleeName.Append(ExtractCalleeFullName((MemberReferenceExpression)(expression.TargetObject), meth));
+						paramList = ExtractParamList(expression, meth);
+					
+						try {
+							methCallee = ComplexityMetrics.ProjProp.GetMethodReference(calleeName.ToString(), paramList);
+							methCallee.AfferentCoupling++;
+						} catch (Exception e) {
+							Console.WriteLine(e.ToString());
+						}
+					
+					} else if (expression.TargetObject is IdentifierExpression) {
+					
+						calleeName.Append(((IdentifierExpression)expression.TargetObject).Identifier);
+						paramList = ExtractParamList(expression, meth);
+					
+						try {
+							Console.WriteLine(calleeName.ToString());
+							methCallee = ComplexityMetrics.ProjProp.GetMethodReference(calleeName.ToString(), paramList);
+							methCallee.AfferentCoupling++;
+						} catch (Exception e) {
+							Console.WriteLine(e.ToString());
+						}
+					} 
+				}
+				return methCallee.Method.ReturnType.FullName;
+			}
+			
+			private static List<string> ExtractParamList(InvocationExpression expression, MethodProperties meth)
+			{
+				List<string> retVal = new List<string>();
+				foreach(Expression param in expression.Arguments)
+				{
+					if(param is PrimitiveExpression) {
+						retVal.Add(((PrimitiveExpression)param).Value.GetType().Name);
+						continue;
+					} else if(param is BinaryOperatorExpression) {
+						if(((BinaryOperatorExpression)param).Op == BinaryOperatorType.LogicalAnd || ((BinaryOperatorExpression)param).Op == BinaryOperatorType.LogicalOr)
+							retVal.Add("System.Boolean");
+						continue;
+					} else if (param is InvocationExpression) {
+						// TODO Deal with method calls within method calls
+						// Lots of cases
+						retVal.Add(EvaluateMethodCoupling((InvocationExpression)param, meth));
+					}
+					
+				}
+				return retVal;
+			}
+			
+			private static string ExtractCalleeFullName(MemberReferenceExpression expression, MethodProperties meth)
+			{
+				if(expression.TargetObject is MemberReferenceExpression)
+				{
+					return ExtractCalleeFullName((MemberReferenceExpression)(expression.TargetObject), meth)+"."+expression.MemberName; 
+				}
+				if(expression.TargetObject is IdentifierExpression)
+				{
+					return ((IdentifierExpression)(expression.TargetObject)).Identifier+"."+expression.MemberName;
+				}
+				return "";
+			}
+			
+			/// <summary>
+			/// Afferent coupling at field level
+			/// </summary>
+			/// <param name="expression">
+			/// A <see cref="IdentifierExpression"/>
+			/// </param>
+			/// <param name="meth">
+			/// A <see cref="MethodProperties"/>
+			/// </param>
+			public static void EvaluateFieldCoupling(IdentifierExpression expression, MethodProperties meth)
+			{
+				//TODO
+			}
+		}
+	}
+}
Index: MonoDevelop.CodeMetrics/EnumProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/EnumProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/EnumProperties.cs	(revision 0)
@@ -0,0 +1,102 @@
+// 
+// EnumProperties.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2010 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Text;
+
+
+using Gtk;
+
+using MonoDevelop.Core;
+
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class EnumProperties : IProperties
+	{
+		IType enm;
+		
+		public IType Enum {
+			get {
+				return enm;
+			}
+		}
+		
+		public string FullName {
+			get; internal set;
+		}
+		
+		public int CyclometricComplexity {
+			get {
+				return 0;
+			}
+		}
+		
+		public int ClassCoupling {
+			get; internal set;
+		}
+		
+		public int StartLine {
+			get; private set;
+		}
+		
+		public int EndLine {
+			get; private set;
+		}
+		
+		public ulong LOCReal {
+			get; internal set;
+		}
+		
+		public ulong LOCComments {
+			get;internal set;
+		}
+		
+		public string FilePath {
+			get; set;
+		}
+		
+		public EnumProperties (IType i)
+		{
+			enm = i;
+			FullName = Enum.FullName;
+			StartLine = Enum.BodyRegion.Start.Line;
+			EndLine = Enum.BodyRegion.End.Line;
+			FilePath="";
+		}
+	}
+}
+
Index: MonoDevelop.CodeMetrics/ClassProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/ClassProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/ClassProperties.cs	(revision 0)
@@ -0,0 +1,421 @@
+// 
+// CodeMetricsServices.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2009 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Text;
+
+using Gtk;
+
+using MonoDevelop.Core;
+using MonoDevelop.Ide.Gui;
+//using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+//using MonoDevelop.Projects.Dom.Parser;
+//using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory;
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+//add reference to configure.in file
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class ClassProperties : IProperties
+	{
+		private IType cls;
+		
+		public Dictionary<string, ClassProperties> InnerClasses {
+			get; private set;
+		}
+		
+		public Dictionary<string, EnumProperties> InnerEnums {
+			get; private set;
+		}
+		
+		public Dictionary<string, StructProperties> InnerStructs {
+			get; private set;
+		}
+		
+		public Dictionary<string, DelegateProperties> InnerDelegates {
+			get; private set;
+		}
+		
+		public Dictionary<string, InterfaceProperties> InnerInterfaces {
+			get; private set;
+		}
+		
+		public Dictionary<string, MethodProperties> Methods {
+			get; private set;
+		}
+		
+		public Dictionary<string, FieldProperties> Fields {
+			get; private set;
+		}
+		
+		internal IType Class {
+			get { return cls; }
+		}
+		
+		public ClassProperties ParentClass {
+			get; internal set;
+		}
+		
+		public NamespaceProperties ParentNamespace {
+			get; internal set;
+		}
+		
+		public int StartLine {
+			get; private set;
+		}
+		
+		public int EndLine {
+			get; private set;
+		}
+		
+		public string FilePath {
+			get; set;
+		}
+		
+		public int PublicMethodCount {
+			get; private set;
+		}
+		
+		public int PrivateMethodCount {
+			get; private set;
+		}
+		
+		public int OverloadedMethodCount {
+			get; private set;
+		}
+		
+		public int VirtualMethodCount {
+			get; private set;
+		}
+		
+		private void AddMethod ()
+		{
+			foreach (IMethod method in Class.Methods) {
+				if(method.Name==".ctor")
+					continue;
+				try {
+					string key = method.FullName + " " + SerializeParameters(method);
+					if(Methods.ContainsKey(key))
+						continue;
+			 		Methods.Add(key, new MethodProperties(method));
+					Methods[key].ParentClass = this;
+				} catch (Exception ex) {
+					Console.WriteLine("Error : " + ex);
+					//TODO some error handling
+				}	
+			}
+		}
+		
+		private void AddField ()
+		{
+			if(Fields==null)
+				Fields = new Dictionary<string, FieldProperties>();
+			foreach (IField field in Class.Fields) {
+				try {
+					Fields.Add(field.Name, new FieldProperties(field));
+				} catch (Exception ex) {
+					Console.WriteLine("Error : " + ex);
+				}
+			}
+		}
+		
+		
+#region Inner Types Count
+		
+		public int InnerTypeCount {
+			get {
+				return Class.InnerTypeCount;
+			}
+		}
+		
+		public int InnerClassCount {
+			get {
+				return InnerClasses.Count;
+			}
+		}
+		
+		public int InterfaceCount {
+			get {
+				return InnerInterfaces.Count;
+			}
+		}
+		
+		public int StructCount {
+			get {
+				return InnerStructs.Count;
+			}
+		}
+		
+		public int EnumCount {
+			get {
+				return InnerEnums.Count;
+			}
+		}
+		
+		public int DelegateCount {
+			get {
+				return InnerDelegates.Count;
+			}
+		}
+		
+		private void EvaluateInnerTypeCount()
+		{
+			foreach (IType type in Class.InnerTypes) {
+				switch (type.ClassType) {
+				case MonoDevelop.Projects.Dom.ClassType.Class:
+					AddInnerClass(type); 
+					break;
+				case MonoDevelop.Projects.Dom.ClassType.Enum:
+					AddInnerEnum(type);
+					break;
+				case MonoDevelop.Projects.Dom.ClassType.Interface:
+					AddInnerInterface(type);
+					break;
+				case MonoDevelop.Projects.Dom.ClassType.Struct:
+					AddInnerStruct(type);
+					break;
+				case MonoDevelop.Projects.Dom.ClassType.Delegate:
+					AddInnerDelegate(type);
+					break;
+				}
+			}
+		}
+		
+	
+		private void AddInnerClass(IType type)
+		{
+			if(!InnerClasses.ContainsKey(type.FullName))
+				InnerClasses.Add(type.FullName, new ClassProperties(type));
+		}
+	
+		
+		private void AddInnerEnum(IType type)
+		{
+			if(!InnerEnums.ContainsKey(type.FullName))
+				InnerEnums.Add(type.FullName, new EnumProperties(type));
+		}
+		
+		private void AddInnerInterface(IType type)
+		{
+			if(!InnerInterfaces.ContainsKey(type.FullName))
+				InnerInterfaces.Add(type.FullName, new InterfaceProperties(type));
+		}
+		
+		private void AddInnerStruct(IType type)
+		{
+			if(!InnerStructs.ContainsKey(type.FullName))
+				InnerStructs.Add(type.FullName, new StructProperties(type));
+		}
+		
+		private void AddInnerDelegate(IType type)
+		{
+			if(!InnerDelegates.ContainsKey(type.FullName))
+				InnerDelegates.Add(type.FullName, new DelegateProperties(type));
+		}
+		
+#endregion
+		
+		public string FullName {
+			get {return Class.FullName; }
+		}
+		
+		public int MethodCount {
+			get; private set;
+		}
+		
+		public int EventCount {
+			get; private set; 
+		}
+		
+		public int FieldCount {
+			get; private set;
+		}
+		
+		public int ConstructorCount {
+			get {
+				return Class.ConstructorCount;
+			}
+		}
+		
+		public bool IsDocumented {
+			get {
+				if (Class.Documentation != "")
+					return true;
+				else
+					return false;
+			}
+		}
+		
+		public int GetInterfacesImplemented { 
+			get; private set;
+		}
+		
+		public ClassProperties (IType c)
+		{
+			cls = c;
+			
+			InnerClasses = new Dictionary<string, ClassProperties> ();
+			InnerEnums = new Dictionary<string, EnumProperties> ();
+			InnerInterfaces = new Dictionary<string, InterfaceProperties>();
+			InnerStructs = new Dictionary<string, StructProperties> ();
+			InnerDelegates = new Dictionary<string, DelegateProperties> ();
+			Methods = new Dictionary<string, MethodProperties> ();
+			Fields = new Dictionary<string, FieldProperties> ();
+			
+			EvaluateInnerTypeCount();
+			
+			AddMethod ();
+			AddField ();
+			
+			this.FieldCount = this.Fields.Count;
+			this.EventCount = this.Class.EventCount;
+			this.MethodCount = this.Methods.Count;
+			this.StartLine = this.Class.BodyRegion.Start.Line;
+			this.EndLine = this.Class.BodyRegion.End.Line;
+		}
+		
+		public int DepthOfInheritance {
+			get; internal set;
+		}
+		
+		public int FanOut {
+			get; internal set;
+		}
+		
+		public int InheritedFieldCount {
+			get; internal set;
+		}
+		 
+		public int InheritedMethodCount {
+			get; internal set;
+		}
+		
+		public int TotalMethodCount {
+			get { return  + InheritedMethodCount; }
+		}
+		
+		public int TotalFieldCount {
+			get { return this.FieldCount + InheritedFieldCount; }
+		}
+		
+		public bool IsRoot {
+			get {
+				return DepthOfInheritance <=1 && FanOut > 0;
+			}
+		}
+		
+		public bool IsInnerClass {
+			get; internal set;
+		}
+		
+		public int DataAbstractionCoupling {
+			get; internal set;
+		}
+		
+		public int CyclometricComplexity {
+			get; internal set;
+		}
+		
+		public int AfferentCoupling {
+			get; internal set;
+		}
+		
+		public int EfferentCoupling {
+			get; internal set;
+		}
+		
+		public ulong LOCReal {
+			get; internal set;
+		}
+		
+		public ulong LOCComments {
+			get; internal set;
+		}
+		
+		public int ClassCoupling {
+			get; internal set;
+		}
+		
+		public double LCOM {
+			get; internal set;
+		}
+		
+		public double LCOM_HS {
+			get; internal set;
+		}
+		
+		internal void ProcessInnerClasses()
+		{
+			foreach(var innercls in this.InnerClasses)
+			{
+				RecursiveProcessClasses (innercls.Value);
+				this.CyclometricComplexity += innercls.Value.CyclometricComplexity;
+				this.ClassCoupling += innercls.Value.ClassCoupling;
+				this.LOCReal += innercls.Value.LOCReal;
+				this.LOCComments += innercls.Value.LOCComments;
+				this.FieldCount += innercls.Value.FieldCount;
+				this.MethodCount += innercls.Value.MethodCount;
+				/*
+				 * Finish adding more metrics
+				 */
+			}
+		}
+		
+		private void RecursiveProcessClasses(ClassProperties cls)
+		{
+			foreach(var innercls in cls.InnerClasses)
+			{
+				RecursiveProcessClasses(innercls.Value);
+				cls.CyclometricComplexity += innercls.Value.CyclometricComplexity;
+				cls.ClassCoupling += innercls.Value.ClassCoupling;
+				cls.LOCReal += innercls.Value.LOCReal;
+				cls.LOCComments += innercls.Value.LOCComments;
+				cls.FieldCount += innercls.Value.FieldCount;
+				cls.MethodCount += innercls.Value.MethodCount;
+			}
+		}
+		
+		private static string SerializeParameters(IMethod method)
+		{
+			StringBuilder paramString = new StringBuilder();
+			foreach(IParameter param in method.Parameters)
+				paramString.Append(param.ReturnType.Name + " ");
+			return paramString.ToString();
+		}
+	}
+	
+}
+
+			
Index: MonoDevelop.CodeMetrics/ProjectProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/ProjectProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/ProjectProperties.cs	(revision 0)
@@ -0,0 +1,594 @@
+// 
+// AssemblyProperties.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmai.com>
+// 
+// Copyright (c) 2010 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class ProjectProperties : IProperties
+	{
+		Project project;
+		
+		public Project Project {
+			get {
+				return project;
+			}
+		}
+		
+		public Dictionary<string, NamespaceProperties> Namespaces {
+			get; internal set;
+		}
+		
+		public Dictionary<string, ClassProperties> Classes {
+			get; internal set;
+		}
+		
+		public Dictionary<string, StructProperties> Structs {
+			get; internal set;
+		}
+		
+		public Dictionary<string, EnumProperties> Enums {
+			get; internal set;
+		}
+		
+		public Dictionary<string, DelegateProperties> Delegates {
+			get; internal set;
+		}
+		
+		public Dictionary<string, InterfaceProperties> Interfaces {
+			get; internal set;
+		}
+		
+		public string FullName {
+			get; internal set;
+		}
+		
+		public int CyclometricComplexity {
+			get; internal set;
+		}
+		
+		public int ClassCoupling {
+			get; internal set;
+		}
+		
+		public int StartLine {
+			get; private set;
+		}
+		
+		public int EndLine {
+			get; private set;
+		}
+		
+		public ulong LOCReal {
+			get; internal set;
+		}
+		
+		public ulong LOCComments {
+			get;internal set;
+		}
+		
+		public string FilePath {
+			get; set;
+		}
+		
+		public ProjectProperties(Project p)
+		{
+			Namespaces = new Dictionary<string, NamespaceProperties>();
+			Classes = new Dictionary<string, ClassProperties>();
+			Structs = new Dictionary<string, StructProperties>();
+			Enums = new Dictionary<string, EnumProperties>();
+			Delegates = new Dictionary<string, DelegateProperties>();
+			Interfaces = new Dictionary<string, InterfaceProperties>();
+			project = p;
+		}
+		
+		internal void AddInstance (IType cls)
+		{
+			// Do not include classes inherited from assemblies
+			if (cls.BodyRegion.Start == cls.BodyRegion.End)
+				return;
+			StringBuilder key = new StringBuilder();
+			key.Append(cls.FullName);
+			
+			switch (cls.ClassType)
+			{
+			case ClassType.Class:
+				AddClass(cls, key);
+				break;
+			case ClassType.Delegate:
+				AddDelegate(cls, key);
+				break;
+			case ClassType.Enum:
+				AddEnum(cls, key);
+				break;
+			case ClassType.Interface:
+				AddInterface(cls, key);
+				break;
+			case ClassType.Struct:
+				AddStruct(cls, key);
+				break;
+			case ClassType.Unknown:
+				break;
+			}
+			
+		}
+		
+		private void AddClass (IType cls, StringBuilder key)
+		{
+			if(cls.Namespace=="") {
+				lock(Classes)
+				{
+					foreach(var typeArg in cls.TypeParameters) {
+						foreach(var constraint in typeArg.Constraints) {
+							key.Append(constraint.Name);
+						}
+					}
+					if(Classes.ContainsKey(key.ToString()))
+						return;
+					Classes.Add(key.ToString(), new ClassProperties(cls));
+				}
+			} else {
+				AddNamespace(key, cls);
+			}
+		}
+		
+		private void AddStruct (IType strct, StringBuilder key)
+		{
+			if(strct.Namespace=="") {
+				lock(Structs)
+				{
+					foreach(var typeArg in strct.TypeParameters) {
+						foreach(var constraint in typeArg.Constraints) {
+							key.Append(constraint.Name);
+						}
+					}
+					if(Structs.ContainsKey(key.ToString()))
+						return;
+					Structs.Add(key.ToString(), new StructProperties(strct));
+				}
+			} else {
+				AddNamespace(key, strct);
+			}
+		}
+		
+		private void AddInterface (IType interfce, StringBuilder key)
+		{
+			if(interfce.Namespace=="") {
+				lock(Interfaces)
+				{
+					foreach(var typeArg in interfce.TypeParameters) {
+						foreach(var constraint in typeArg.Constraints) {
+							key.Append(constraint.Name);
+						}
+					}
+					if(Interfaces.ContainsKey(key.ToString()))
+						return;
+					Interfaces.Add(key.ToString(), new InterfaceProperties(interfce));
+				}
+			} else {
+				AddNamespace(key, interfce);
+			}
+		}
+		
+		private void AddEnum (IType enm, StringBuilder key)
+		{
+			if(enm.Namespace=="") {
+				lock(Enums)
+				{
+					foreach(var typeArg in enm.TypeParameters) {
+						foreach(var constraint in typeArg.Constraints) {
+							key.Append(constraint.Name);
+						}
+					}
+					if(Enums.ContainsKey(key.ToString()))
+						return;
+					Enums.Add(key.ToString(), new EnumProperties(enm));
+				}
+			} else {
+				AddNamespace(key,enm);
+			}
+		}
+		
+		private void AddDelegate (IType dlgte, StringBuilder key)
+		{
+			if(dlgte.Namespace=="") {
+				lock(Delegates)
+				{
+					foreach(var typeArg in dlgte.TypeParameters) {
+						foreach(var constraint in typeArg.Constraints) {
+							key.Append(constraint.Name);
+						}
+					}
+					if(Delegates.ContainsKey(key.ToString()))
+						return;
+					Delegates.Add(key.ToString(), new DelegateProperties(dlgte));
+				}
+			} else {
+				AddNamespace(key, dlgte);
+			}
+		}
+		
+		private void AddNamespace (StringBuilder key, IType cls)
+		{
+			lock(Namespaces)
+			{
+				if (InstanceExists (key.ToString()))
+					return;
+			
+				if(!Namespaces.ContainsKey(cls.Namespace))
+					Namespaces.Add(cls.Namespace, new NamespaceProperties(cls.Namespace));
+			
+				Namespaces[cls.Namespace].AddInstance(cls);
+			}
+		}
+		
+		/// <summary>
+		/// This method is used to return a reference to the namespace with the specified name
+		/// </summary>
+		/// <param name="FullName">
+		/// A <see cref="System.String"/>
+		/// </param>
+		/// <returns>
+		/// A <see cref="NamespaceProperties"/>
+		/// </returns>
+		internal NamespaceProperties GetNamespaceReference (string FullName)
+		{
+			if(Namespaces.ContainsKey(FullName))
+				return Namespaces[FullName];
+			return null;
+		}
+		
+		/// <summary>
+		/// This method is used to get the reference to the Method whose properties we need to update. Need a faster way to do things instead of brute force lookup.
+		/// </summary>
+		/// <param name="FullName">
+		/// A <see cref="System.String"/>
+		/// </param>
+		/// <param name="Parameters">
+		/// A <see cref="List<System.String>"/>
+		/// </param>
+		/// <returns>
+		/// A <see cref="MethodProperties"/>
+		/// </returns>
+		internal MethodProperties GetMethodReference (string FullName, List<string> Parameters)
+		{
+			StringBuilder MethodKey = new StringBuilder();
+			MethodKey.Append(FullName+" ");
+			foreach(string paramName in Parameters)
+				MethodKey.Append(paramName+" ");
+			foreach(var cls in Classes)
+			{
+				if(cls.Value.Methods.ContainsKey(MethodKey.ToString()))
+					return cls.Value.Methods[MethodKey.ToString()];
+				var ret = RecursiveFindRefMeth(cls.Value, MethodKey.ToString());
+				if(ret!=null)
+					return ret;
+			}
+			foreach(var namesp in Namespaces)
+			{
+				foreach(var cls in namesp.Value.Classes)
+				{
+					if(cls.Value.Methods.ContainsKey(MethodKey.ToString()))
+						return cls.Value.Methods[MethodKey.ToString()];
+					var ret = RecursiveFindRefMeth (cls.Value, MethodKey.ToString());
+					if(ret!=null)
+						return ret;
+				}
+			}
+			return null;
+		}
+
+		private MethodProperties RecursiveFindRefMeth (ClassProperties cls, string key)
+		{
+			foreach(var innercls in cls.InnerClasses)
+			{
+				if(innercls.Value.Methods.ContainsKey(key))
+					return innercls.Value.Methods[key];
+				var ret = RecursiveFindRefMeth(innercls.Value, key);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		/// <summary>
+		/// This method is used to get a class reference from the name. Brute force lookup for now, need a better way.
+		/// </summary>
+		/// <param name="cls">
+		/// A <see cref="ClassProperties"/>
+		/// </param>
+		/// <param name="key">
+		/// A <see cref="System.String"/>
+		/// </param>
+		/// <returns>
+		/// A <see cref="MethodProperties"/>
+		/// </returns>
+		internal ClassProperties GetClassReference (string FullName)
+		{
+			if(Classes.ContainsKey(FullName))
+				return Classes[FullName];
+			foreach(var cls in Classes)
+			{
+				var ret = RecursiveFindRefCls(cls.Value, FullName);
+				if(ret!=null)
+					return ret;
+			}
+			foreach(var namesp in Namespaces)
+			{
+				if(namesp.Value.Classes.ContainsKey(FullName))
+					return namesp.Value.Classes[FullName];
+				foreach(var cls in namesp.Value.Classes)
+				{
+					var ret = RecursiveFindRefCls (cls.Value, FullName);
+					if(ret!=null)
+						return ret;
+				}
+			}
+			return null;
+		}
+		
+		private ClassProperties RecursiveFindRefCls (ClassProperties cls, string key)
+		{
+			if(cls.InnerClasses.ContainsKey(key))
+				return cls.InnerClasses[key];
+			foreach (var innercls in cls.InnerClasses)
+			{
+				var ret = RecursiveFindRefCls (innercls.Value, key);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		/// <summary>
+		/// 
+		/// </summary>
+		/// <param name="key">
+		/// A <see cref="System.String"/>
+		/// </param>
+		/// <param name="namesp">
+		/// A <see cref="NamespaceProperties"/>
+		/// </param>
+		/// <returns>
+		/// A <see cref="EnumProperties"/>
+		/// </returns>
+		internal EnumProperties GetEnumReference (string FullName, NamespaceProperties namesp)
+		{
+			if(namesp == null) {
+				if(this.Enums.ContainsKey(FullName)) {
+					return this.Enums[FullName];
+				} else {
+					return null;
+				}
+			}
+			if(namesp.Enums.ContainsKey(FullName))
+				return namesp.Enums[FullName];
+			foreach(var cls in namesp.Classes)
+			{
+				if(cls.Value.InnerEnums.ContainsKey(FullName))
+					return cls.Value.InnerEnums[FullName];
+				var ret = RecursiveGetEnumReference(cls.Value, FullName);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		private EnumProperties RecursiveGetEnumReference (ClassProperties cls, string key)
+		{
+			foreach (var innercls in cls.InnerClasses)
+			{
+				if(innercls.Value.InnerEnums.ContainsKey(key))
+					return innercls.Value.InnerEnums[key];
+				var ret = RecursiveGetEnumReference (innercls.Value, key);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		/// <summary>
+		/// 
+		/// </summary>
+		/// <param name="FullName">
+		/// A <see cref="System.String"/>
+		/// </param>
+		/// <param name="namesp">
+		/// A <see cref="NamespaceProperties"/>
+		/// </param>
+		/// <returns>
+		/// A <see cref="InterfaceProperties"/>
+		/// </returns>
+		internal InterfaceProperties GetInterfaceReference (string FullName, NamespaceProperties namesp)
+		{
+			if(namesp == null)
+				if(this.Interfaces.ContainsKey(FullName))
+					return this.Interfaces[FullName];
+			if(namesp.Interfaces.ContainsKey(FullName))
+				return namesp.Interfaces[FullName];
+			foreach(var cls in namesp.Classes)
+			{
+				if(cls.Value.InnerInterfaces.ContainsKey(FullName))
+					return cls.Value.InnerInterfaces[FullName];
+				var ret = RecursiveGetInterfaceReference(cls.Value, FullName);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		private InterfaceProperties RecursiveGetInterfaceReference (ClassProperties cls, string key)
+		{
+			if(cls.InnerInterfaces.ContainsKey(key))
+				return cls.InnerInterfaces[key];
+			foreach (var innercls in cls.InnerClasses)
+			{
+				var ret = RecursiveGetInterfaceReference (innercls.Value, key);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		/// <summary>
+		/// 
+		/// </summary>
+		/// <param name="FullName">
+		/// A <see cref="System.String"/>
+		/// </param>
+		/// <param name="namesp">
+		/// A <see cref="NamespaceProperties"/>
+		/// </param>
+		/// <returns>
+		/// A <see cref="DelegateProperties"/>
+		/// </returns>
+		internal DelegateProperties GetDelegateReference (string FullName, NamespaceProperties namesp)
+		{
+			if(namesp == null)
+				if(this.Delegates.ContainsKey(FullName))
+					return this.Delegates[FullName];
+			if(namesp.Delegates.ContainsKey(FullName))
+				return namesp.Delegates[FullName];
+			foreach(var cls in namesp.Classes)
+			{
+				if(cls.Value.InnerDelegates.ContainsKey(FullName))
+					return cls.Value.InnerDelegates[FullName];
+				var ret = RecursiveGetDelegateReference(cls.Value, FullName);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		private DelegateProperties RecursiveGetDelegateReference (ClassProperties cls, string key)
+		{
+			if(cls.InnerDelegates.ContainsKey(key))
+				return cls.InnerDelegates[key];
+			foreach (var innercls in cls.InnerClasses)
+			{
+				var ret = RecursiveGetDelegateReference (innercls.Value, key);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		/// <summary>
+		/// 
+		/// </summary>
+		/// <param name="FullName">
+		/// A <see cref="System.String"/>
+		/// </param>
+		/// <param name="namesp">
+		/// A <see cref="NamespaceProperties"/>
+		/// </param>
+		/// <returns>
+		/// A <see cref="StructProperties"/>
+		/// </returns>
+		internal StructProperties GetStructReference (string FullName, NamespaceProperties namesp)
+		{
+			if(namesp == null)
+				if(this.Structs.ContainsKey(FullName))
+					return this.Structs[FullName];
+			if(namesp.Structs.ContainsKey(FullName))
+				return namesp.Structs[FullName];
+			foreach(var cls in namesp.Classes)
+			{
+				if(cls.Value.InnerStructs.ContainsKey(FullName))
+					return cls.Value.InnerStructs[FullName];
+				var ret = RecursiveGetStructReference(cls.Value, FullName);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		private StructProperties RecursiveGetStructReference (ClassProperties cls, string key)
+		{
+			if(cls.InnerClasses.ContainsKey(key))
+				return cls.InnerStructs[key];
+			foreach (var innercls in cls.InnerClasses)
+			{
+				var ret = RecursiveGetStructReference (innercls.Value, key);
+				if(ret!=null)
+					return ret;
+			}
+			return null;
+		}
+		
+		/// <summary>
+		/// 
+		/// </summary>
+		/// <param name="clsName">
+		/// A <see cref="System.String"/>
+		/// </param>
+		/// <returns>
+		/// A <see cref="System.Boolean"/>
+		/// </returns>
+		internal bool InstanceExists (string clsName)
+		{
+			if(Classes.ContainsKey(clsName))
+				return true;
+			foreach(var cls in this.Classes) {
+				if(RecursiveInstanceExists(cls.Value, clsName))
+					return true;
+			}
+			foreach(var namesp in this.Namespaces) {
+				if(namesp.Value.Classes.ContainsKey(clsName))
+					return true;
+				foreach(var cls in namesp.Value.Classes) {
+					if(RecursiveInstanceExists(cls.Value, clsName))
+						return true;
+				}
+			}
+			return false;
+		}
+		
+		private bool RecursiveInstanceExists(ClassProperties cls, string clsName)
+		{
+			if(cls.InnerClasses.ContainsKey(clsName))
+				return true;
+			foreach(var innercls in cls.InnerClasses) {
+				if(RecursiveInstanceExists(innercls.Value, clsName))
+					return true;
+			}
+			return false;
+		}
+	}
+}
+
Index: MonoDevelop.CodeMetrics/ComplexityMetrics.cs
===================================================================
--- MonoDevelop.CodeMetrics/ComplexityMetrics.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/ComplexityMetrics.cs	(revision 0)
@@ -0,0 +1,185 @@
+// 
+// CoverageAndComplexity.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+//		 Michael J. Hutchinson <m.j.hutchinson@gmail.com>
+// 
+// Copyright (c) 2009 Nikhil Sarda, Michael J. Hutchinson
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Linq;
+using System.Collections.Generic;
+using System.Text;
+using System.IO;
+using System.Threading;
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory;
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public partial class ComplexityMetrics
+	{
+		internal static MetricsContext mctx
+		{ get; private set; }
+
+		internal static ProjectFile File 
+		{ get; private set; }
+		
+		internal static List<LineSegment> FileText
+		{ get; private set; }
+		
+		internal static Mono.TextEditor.Document FileDoc
+		{ get; private set; }
+		
+		internal static ProjectProperties ProjProp
+		{ get; private set; }
+		
+		private static Stack<string> PrefixName; 
+		
+		public static void EvaluateComplexityMetrics (MetricsContext ctx, ProjectProperties project)
+		{
+			mctx = ctx;
+			PrefixName = new Stack<string>(0);
+			lock(mctx)
+			{
+				foreach (var file in project.Project.Files) {
+					/*if(file.BuildAction != BuildAction.Compile)
+						continue;*/
+					// Files not set to compile are sometimes not accessible
+					if(file.Name.Contains("svn-base"))
+						continue;
+					string text="";
+					try {
+						text = System.IO.File.ReadAllText(file.FilePath);
+					} catch (System.UnauthorizedAccessException uae) {
+						continue;
+					} catch (System.IO.FileNotFoundException fnf) {
+						// This exception arises in Nrefactory...WTF? 0_0
+						continue;
+					}
+					ProjProp = project;
+					File = file;
+					Mono.TextEditor.Document doc = new Mono.TextEditor.Document ();
+					doc.Text = text;
+					FileDoc = doc;
+					FileText = new List<LineSegment>();
+					foreach(LineSegment segment in doc.Lines)
+						FileText.Add(segment);
+					
+					using (ICSharpCode.NRefactory.IParser parser = ParserFactory.CreateParser(SupportedLanguage.CSharp, new StringReader(text))) {
+						parser.Parse();
+						if (parser.Errors.Count > 0) {
+							//Error handling TODO
+						} else {
+							foreach (var it in parser.CompilationUnit.Children) {
+								ProcessNode (ctx, it);
+							}
+						}
+					}
+				}
+			}
+		}
+		
+		
+		
+		private static void ProcessNode (MetricsContext ctx, ICSharpCode.NRefactory.Ast.INode node)
+		{
+			if(node is UsingStatement) {
+				//TODO do something (something to do with afferent and efferent coupling of namespaces)
+			} else if (node is NamespaceDeclaration) {
+				try {
+				PrefixName.Push(((NamespaceDeclaration)node).Name);
+				LOCEvaluate.EvaluateNamespaceLOC(ctx, (NamespaceDeclaration)node);
+				PrefixName.Pop(); 
+				} catch (Exception e) {
+				}
+			} else if (node is TypeDeclaration) {
+				LOCEvaluate.EvaluateTypeLOC(ctx, null, (TypeDeclaration)node, node.StartLocation.Line);
+			}
+		} 
+				
+		private static void ProcessMethod (MetricsContext ctx, ICSharpCode.NRefactory.Ast.INode method, IProperties parentClass)
+		{
+			if(method==null)
+				return;
+						
+			StringBuilder methodName = new StringBuilder("");
+			string[] PrefixArray = PrefixName.ToArray();
+			for(int i=0;i<PrefixArray.Length;i++)
+				methodName.Append(PrefixArray[PrefixArray.Length-i-1]+".");
+			List<string> methodParameterList = new List<string>(0);
+			if(method is MethodDeclaration) {
+				methodName.Append(((MethodDeclaration)method).Name);
+				foreach(ParameterDeclarationExpression pde in ((MethodDeclaration)method).Parameters) {
+					string type = pde.TypeReference.Type;
+					if(type.Contains("."))
+						type = type.Substring(type.LastIndexOf(".")+1);
+					methodParameterList.Add (type);
+				}
+			} else if(method is ConstructorDeclaration) {
+				methodName.Append(((ConstructorDeclaration)method).Name);
+				foreach(ParameterDeclarationExpression pde in ((ConstructorDeclaration)method).Parameters) {
+					string type = pde.TypeReference.Type;
+					if(type.Contains("."))
+						type = type.Substring(type.LastIndexOf(".")+1);
+					methodParameterList.Add (type);
+				}
+			}
+			
+			StringBuilder MethodKey = new StringBuilder();
+			MethodKey.Append(methodName.ToString()+" ");
+			foreach(string paramName in methodParameterList)
+				MethodKey.Append(paramName+" ");
+			try{
+				if(parentClass is ClassProperties) {
+					if(!(parentClass as ClassProperties).Methods.ContainsKey(MethodKey.ToString())) {
+						if(method is MethodDeclaration)
+							(parentClass as ClassProperties).Methods.Add(MethodKey.ToString(), new MethodProperties((MethodDeclaration)method, parentClass as ClassProperties));
+						else if (method is ConstructorDeclaration)
+							(parentClass as ClassProperties).Methods.Add(MethodKey.ToString(), new MethodProperties((ConstructorDeclaration)method, parentClass as ClassProperties));
+					}
+					var currentMethodReference = (parentClass as ClassProperties).Methods[MethodKey.ToString()];
+					//Calculate all metrics here
+					ASTVisitor.EvaluateComplexityMetrics (method, currentMethodReference);
+					LOCEvaluate.EvaluateMethodLOC(currentMethodReference, FileText, FileDoc);
+					currentMethodReference.FilePath = File.FilePath;
+				}
+			} catch (NullReferenceException ex){
+				LoggingService.LogError ("Error in '" + methodName.ToString() + "'", ex);
+				Console.WriteLine(MethodKey.ToString()+" hoo");
+			}
+		}
+	}
+}
Index: MonoDevelop.CodeMetrics/ObjectOrientedMetrics.cs
===================================================================
--- MonoDevelop.CodeMetrics/ObjectOrientedMetrics.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/ObjectOrientedMetrics.cs	(revision 0)
@@ -0,0 +1,57 @@
+// 
+// ObjectOrientedMetrics.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2009 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public partial class ObjectOrientedMetrics 
+	{
+		public static void EvaluateOOMetrics (MetricsContext ctx, ProjectProperties projprop)
+		{
+			foreach(var cls in projprop.Classes)
+				ObjectOrientedMetrics.ClassEvaluateInheritanceTree(ctx, cls.Value);
+			foreach (var namesp in projprop.Namespaces){
+				foreach (var cls in namesp.Value.Classes){
+					ObjectOrientedMetrics.ClassEvaluateInheritanceTree(ctx, cls.Value);
+				}
+			}
+		}
+	}
+}
\ No newline at end of file
Index: MonoDevelop.CodeMetrics/DelegateProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/DelegateProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/DelegateProperties.cs	(revision 0)
@@ -0,0 +1,102 @@
+// 
+// DelegateProperties.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2010 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Text;
+
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class DelegateProperties : IProperties
+	{
+		IType dlgte;
+		
+		public IType Delegate {
+			get {
+				return dlgte;
+			}
+		}
+		
+		public string FullName {
+			get; internal set;
+		}
+		
+		public int CyclometricComplexity {
+			get {
+				return 0;
+			}
+		}
+		
+		public int ClassCoupling {
+			get; internal set;
+		}
+		
+		public int StartLine {
+			get; private set;
+		}
+		
+		public int EndLine {
+			get; private set;
+		}
+		
+		public ulong LOCReal {
+			get; internal set;
+		}
+		
+		public ulong LOCComments {
+			get;internal set;
+		}
+		
+		public string FilePath {
+			get; set;
+		}
+		
+		public DelegateProperties (IType i)
+		{
+			dlgte = i;
+			FullName = Delegate.FullName;
+			StartLine = Delegate.BodyRegion.Start.Line;
+			EndLine = Delegate.BodyRegion.End.Line;
+			FilePath="";
+		}
+	}
+}
+
Index: MonoDevelop.CodeMetrics/CodeMetricsView.cs
===================================================================
--- MonoDevelop.CodeMetrics/CodeMetricsView.cs	(revision 153925)
+++ MonoDevelop.CodeMetrics/CodeMetricsView.cs	(working copy)
@@ -3,8 +3,9 @@
 //
 // Author:
 //   Mike Krüger <mkrueger@novell.com>
+//	 Nikhil Sarda <diff.operator@gmail.com>
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008 Novell, Inc (http://www.novell.com), Nikhil Sarda
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -32,7 +33,10 @@
 using MonoDevelop.Core;
  
 using MonoDevelop.Ide.Gui;
-using MonoDevelop.Projects;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
 
 namespace MonoDevelop.CodeMetrics
 {
Index: MonoDevelop.CodeMetrics/MethodProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/MethodProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/MethodProperties.cs	(revision 0)
@@ -0,0 +1,200 @@
+// 
+// MethodData.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2009 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Text;
+
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+//add reference to configure.in file
+
+namespace MonoDevelop.CodeMetrics
+{
+	public sealed class MethodProperties : IProperties
+	{
+		private readonly IMethod mthd;
+		private readonly ICSharpCode.NRefactory.Ast.INode mthdAst;
+		
+		public List<string> ParameterList;
+		
+		public IMethod Method {
+			get; private set; 
+		}
+		
+		public ICSharpCode.NRefactory.Ast.INode MethodAST {
+			get; private set;
+		}
+		
+		public string FullName {
+			get; private set;
+		}
+		
+		public int ParameterCount {
+			get { 
+				return ParameterList.Count;
+			}
+		}
+		
+		public bool IsDocumented 
+		{
+			get; private set;
+		}
+		
+		public ClassProperties ParentClass {
+			get; internal set;
+		}
+		
+		public int StartLine {
+			get; private set;
+		}
+		
+		public int EndLine {
+			get; private set;
+		}
+		
+		public int NumberOfVariables {
+			get; internal set;
+		}
+		
+		public int CyclometricComplexity {
+			get; internal set;
+		}
+		
+		public ulong LOCReal {
+			get; internal set;
+		}
+		
+		public ulong LOCComments {
+			get; internal set;
+		}
+		
+		public int AfferentCoupling {
+			get; internal set;
+		}
+		
+		public int EfferentCoupling {
+			get; internal set;
+		}
+		
+		public int ClassCoupling {
+			get; internal set;
+		}
+		
+		public int LCOM {
+			get; internal set;
+		}
+		
+		public int LCOMHS {
+			get; internal set;
+		}
+		
+		public string FilePath {
+			get; set;
+		}
+		
+		public MethodProperties (IMethod m)
+		{ 
+			mthd = m;
+			mthdAst = null;
+			ParameterList = new List<string> (0);
+			foreach(var param in m.Parameters) {
+				ParameterList.Add(param.ReturnType.FullName);
+			}
+			
+			AfferentCoupling=0;
+			EfferentCoupling=0;
+			FilePath="";
+			this.FullName = mthd.FullName;
+			this.StartLine = mthd.BodyRegion.Start.Line;
+			this.EndLine = mthd.BodyRegion.End.Line;
+		}
+		
+		public MethodProperties (ICSharpCode.NRefactory.Ast.INode m, ClassProperties prop)
+		{
+			mthd=null;
+			ParameterList = new List<string> (0);
+			if(m is MethodDeclaration) {
+				mthdAst = (MethodDeclaration)m;
+				VisitMethodMember((MethodDeclaration)m, prop);
+				this.FullName = prop.FullName + "." + ((MethodDeclaration)m).Name.Substring(((MethodDeclaration)m).Name.LastIndexOf(".")+1);
+			} else if(m is ConstructorDeclaration) {
+				mthdAst = (ConstructorDeclaration)m;
+				VisitConstructorMember((ConstructorDeclaration)m, prop);
+				this.FullName = prop.FullName + "." + ((ConstructorDeclaration)m).Name.Substring(((ConstructorDeclaration)m).Name.LastIndexOf(".")+1);
+			}
+			
+			AfferentCoupling=0;
+			EfferentCoupling=0;
+			FilePath="";
+			this.ParentClass = prop;
+			this.StartLine = mthdAst.StartLocation.Line;
+			this.EndLine = mthdAst.EndLocation.Line;
+
+		}
+		
+		public void VisitMethodMember(MethodDeclaration node, ClassProperties prop)
+		{
+			foreach(var param in node.Parameters) {
+				ParameterList.Add(param.TypeReference.Type);
+			}
+			this.StartLine = node.Body.StartLocation.Line;
+			this.EndLine = node.Body.EndLocation.Line;
+		}
+		
+		public void VisitConstructorMember(ConstructorDeclaration node, ClassProperties prop)
+		{
+			foreach(var param in node.Parameters) {
+				ParameterList.Add(param.TypeReference.Type);
+			}
+			this.StartLine = node.Body.StartLocation.Line;
+			this.EndLine = node.Body.EndLocation.Line;
+		}
+		
+		public bool IsParameters (List<string> parameters)
+		{
+			if (parameters.Count != ParameterList.Count)
+				return false;
+			for (int i = 0; i < parameters.Count; i++)
+				if (ParameterList[i] != parameters[i])
+					return false;
+			return true;
+		}
+	}
+}
Index: MonoDevelop.CodeMetrics/FieldProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/FieldProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/FieldProperties.cs	(revision 0)
@@ -0,0 +1,73 @@
+// 
+// InstanceProperties.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2010 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Text;
+
+using Gtk;
+
+using MonoDevelop.Core;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory;
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class FieldProperties
+	{
+		public IField Field {
+			get; private set;
+		}
+		
+		public int InternalAccessCount {
+			get; internal set;
+		}
+		
+		public int ExternalAccessCount {
+			get; internal set;
+		}
+		
+		public int AfferentCoupling {
+			get; internal set;
+		}
+		
+		public FieldProperties(IField field)
+		{
+			Field = field;	
+		}
+
+	}
+}
+
Index: MonoDevelop.CodeMetrics/Commands.cs
===================================================================
--- MonoDevelop.CodeMetrics/Commands.cs	(revision 153925)
+++ MonoDevelop.CodeMetrics/Commands.cs	(working copy)
@@ -3,8 +3,9 @@
 //
 // Author:
 //   Mike Krüger <mkrueger@novell.com>
+//	 Nikhil Sarda <diff.operator@gmail.com>
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008 Novell, Inc (http://www.novell.com), Nikhil Sarda 
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -29,6 +30,7 @@
 using MonoDevelop.Components.Commands;
 using MonoDevelop.Projects;
 using MonoDevelop.Ide;
+using MonoDevelop.Ide.Gui;
 
 namespace MonoDevelop.CodeMetrics
 {
Index: MonoDevelop.CodeMetrics/StructProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/StructProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/StructProperties.cs	(revision 0)
@@ -0,0 +1,101 @@
+// 
+// StructProperties.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2010 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Text;
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class StructProperties : IProperties
+	{		
+		IType strct;
+		
+		public IType Struct {
+			get {
+				return strct;
+			}
+		}
+		
+		public string FullName {
+			get; internal set;
+		}
+		
+		public int CyclometricComplexity {
+			get {
+				return 0;
+			}
+		}
+		
+		public int ClassCoupling {
+			get; internal set;
+		}
+		
+		public int StartLine {
+			get; private set;
+		}
+		
+		public int EndLine {
+			get; private set;
+		}
+		
+		public ulong LOCReal {
+			get; internal set;
+		}
+		
+		public ulong LOCComments {
+			get;internal set;
+		}
+		
+		public string FilePath {
+			get; set;
+		}
+		
+		public StructProperties (IType i)
+		{
+			strct = i;
+			FullName = Struct.FullName;
+			StartLine = Struct.BodyRegion.Start.Line;
+			EndLine = Struct.BodyRegion.End.Line;
+			FilePath="";
+		}
+	}
+}
+
Index: MonoDevelop.CodeMetrics/CodeMetricsNodeExtension.cs
===================================================================
--- MonoDevelop.CodeMetrics/CodeMetricsNodeExtension.cs	(revision 153925)
+++ MonoDevelop.CodeMetrics/CodeMetricsNodeExtension.cs	(working copy)
@@ -2,9 +2,10 @@
 // CodeMetricsNodeExtension.cs
 //
 // Author:
-//   Mike Krüger <mkrueger@novell.com>
+//   Mike KrÃ¼ger <mkrueger@novell.com>
+//	 Nikhil Sarda <diff.operator@gmail.com>
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008 Novell, Inc (http://www.novell.com), Nikhil Sarda
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -28,8 +29,14 @@
 
 using System;
 using System.IO;
+
+using MonoDevelop.Core;
 using MonoDevelop.Components.Commands;
-using MonoDevelop.Ide;
+using MonoDevelop.Ide.Commands;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Ide.Gui.Pads;
+using MonoDevelop.Ide.Gui.Pads.ProjectPad;
+using MonoDevelop.Projects;
 using MonoDevelop.Ide.Gui.Components;
 using MonoDevelop.Ide.Gui.Pads.ProjectPad;
 using MonoDevelop.Projects;
@@ -38,17 +45,17 @@
 {
 	public class CodeMetricsNodeExtension: NodeBuilderExtension
 	{
-		public override Type CommandHandlerType {
-			get { return typeof(CodeMetricsCommandHandler); }
+		public override Type CommandHandlerType {
+			get { return typeof(CodeMetricsCommandHandler); }
 		}
-		
+		
 		public override bool CanBuildNode (Type dataType)
-		{
-			return typeof(ProjectFile).IsAssignableFrom (dataType)
-				|| typeof(ProjectFolder).IsAssignableFrom (dataType)
-				|| typeof(Project).IsAssignableFrom (dataType)
+		{
+			return typeof(ProjectFile).IsAssignableFrom (dataType)
+				|| typeof(ProjectFolder).IsAssignableFrom (dataType)
+				|| typeof(Project).IsAssignableFrom (dataType)
 				|| typeof(SolutionFolder).IsAssignableFrom (dataType)
-				|| typeof(Solution).IsAssignableFrom (dataType);
+				|| typeof(Solution).IsAssignableFrom (dataType);
 		}
 		
 		public CodeMetricsNodeExtension()
@@ -57,8 +64,8 @@
 	}
 	
 	class CodeMetricsCommandHandler: NodeCommandHandler 
-	{
-		[CommandHandler (Commands.ShowMetrics)]
+	{
+		[CommandHandler (Commands.ShowMetrics)]
 		protected void OnShowMetrics () 
 		{
 			CodeMetricsView view = new CodeMetricsView ();
@@ -68,11 +75,7 @@
 				view.Add (file);
 			
 			ProjectFolder folder = CurrentNode.DataItem as ProjectFolder;
-			if (folder != null) {
-				foreach (string fileName in System.IO.Directory.GetFiles (folder.Path, "*", SearchOption.AllDirectories)) {
-					view.Add (fileName);
-				}
-			}
+			
 			SolutionFolder combine = CurrentNode.DataItem as SolutionFolder;
 			if (combine != null) 
 				view.Add (combine);
@@ -84,9 +87,9 @@
 			Project project = CurrentNode.DataItem as Project;
 			if (project != null) 
 				view.Add (project);
-			IdeApp.Workbench.OpenDocument (view, true);
+			MonoDevelop.Ide.IdeApp.Workbench.OpenDocument (view, true);
 			view.Run ();
 		}
-	}
+	}
 
 }
Index: MonoDevelop.CodeMetrics/LOCEvaluate.cs
===================================================================
--- MonoDevelop.CodeMetrics/LOCEvaluate.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/LOCEvaluate.cs	(revision 0)
@@ -0,0 +1,278 @@
+// 
+// CyclomaticComplexity.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2009 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.IO;
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory;
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public partial class ComplexityMetrics
+	{
+		public class LOCEvaluate
+		{
+			internal static void EvaluateNamespaceLOC (MetricsContext ctx, NamespaceDeclaration node)
+			{
+				if(node == null)
+					return;
+				//MessageService.ShowMessage(node.ToString());
+				try {
+					NamespaceProperties namespaceRef = ComplexityMetrics.ProjProp.GetNamespaceReference(node.Name);
+					if(namespaceRef==null)
+						return;
+					Dictionary<int, ICSharpCode.NRefactory.Ast.INode> typeLocations = new Dictionary<int, ICSharpCode.NRefactory.Ast.INode>();
+					foreach(var childnode in node.Children){
+						if(childnode is TypeDeclaration)
+							typeLocations.Add(childnode.StartLocation.Line, childnode);
+					}
+					
+					if(namespaceRef.FilePath==null||namespaceRef.FilePath=="")
+						namespaceRef.FilePath = ComplexityMetrics.File.FilePath;
+					
+					#region CommonLogic
+					int startIndex = node.StartLocation.Line;
+					int endIndex = node.EndLocation.Line;
+					
+					ulong totalLines = 0, totalRealLines = 0, totalCommentedLines = 0;
+					int realLines = 0;
+					bool isSingleLineComment = false;
+					bool isMultipleLineComment = false;
+					
+					for(int i=startIndex;i<endIndex;i++)
+					{
+						string lineText = ComplexityMetrics.FileDoc.GetTextAt(ComplexityMetrics.FileText[i]).Trim();
+						if(isMultipleLineComment){
+							totalCommentedLines++;
+							if(lineText.EndsWith("*/"))
+								isMultipleLineComment = false;
+							continue;
+						}
+						if(lineText.StartsWith ("/*")){
+							isMultipleLineComment = true;
+							totalCommentedLines++;
+							continue;
+						}
+						isSingleLineComment = lineText.StartsWith ("//");
+						if(isSingleLineComment)
+							totalCommentedLines++;
+						if (lineText.Length > 0 && !isSingleLineComment)
+						{
+							realLines++;
+							if((typeLocations.ContainsKey(i)) && (typeLocations[i] is TypeDeclaration))
+								i = EvaluateTypeLOC(ctx, namespaceRef, (TypeDeclaration)typeLocations[i], i);
+							if((typeLocations.ContainsKey(i+1)) &&(typeLocations[i+1] is TypeDeclaration))
+								i = EvaluateTypeLOC(ctx, namespaceRef, (TypeDeclaration)typeLocations[i+1], i);
+						}
+					}
+				
+					totalLines     += (ulong)(startIndex-endIndex+1);
+					totalRealLines += (ulong)realLines;
+					namespaceRef.LOCReal += totalRealLines;
+					namespaceRef.LOCComments += totalCommentedLines;
+					#endregion CommonLogic
+				} catch (Exception e) {
+					Console.WriteLine(e.ToString());
+				}
+			}
+			
+			internal static int EvaluateTypeLOC (MetricsContext ctx, NamespaceProperties namespaceRef, TypeDeclaration node, int startIndex)
+			{
+				if(node==null)
+					return -1;
+				StringBuilder typeName = new StringBuilder("");;
+				try {
+					string[] prefixArray = ComplexityMetrics.PrefixName.ToArray();
+					for(int i=0;i<prefixArray.Length;i++)
+						typeName.Append(prefixArray[prefixArray.Length-i-1]+".");
+					typeName.Append(node.Name);
+					foreach(var templateDef in node.Templates) {
+						foreach(var bases in templateDef.Bases) {
+							if(bases.Type.Contains("constraint:"))
+								continue;
+							typeName.Append(" " + bases.Type.Substring(bases.Type.LastIndexOf(".")+1));
+						}
+					}
+					
+					IProperties typeRef = null;
+					switch(node.Type)
+					{
+					case ICSharpCode.NRefactory.Ast.ClassType.Class:
+						typeRef = ComplexityMetrics.ProjProp.GetClassReference(typeName.ToString());
+						break;
+					case ICSharpCode.NRefactory.Ast.ClassType.Enum:
+						typeRef = ComplexityMetrics.ProjProp.GetEnumReference(typeName.ToString(), namespaceRef);
+						break;
+					case ICSharpCode.NRefactory.Ast.ClassType.Struct:
+						typeRef = ComplexityMetrics.ProjProp.GetStructReference(typeName.ToString(), namespaceRef);
+						break;
+					case ICSharpCode.NRefactory.Ast.ClassType.Interface:
+						typeRef = ComplexityMetrics.ProjProp.GetInterfaceReference(typeName.ToString(), namespaceRef);
+						break;
+					default:
+						return node.EndLocation.Line;
+					}
+					
+					if(typeRef==null)
+						return node.EndLocation.Line;
+					
+					Dictionary<int, ICSharpCode.NRefactory.Ast.INode> childLocations = new Dictionary<int, ICSharpCode.NRefactory.Ast.INode>(0);
+					foreach(ICSharpCode.NRefactory.Ast.INode childNode in node.Children) {
+						if((childNode is TypeDeclaration) || (childNode is ConstructorDeclaration) || (childNode is MethodDeclaration))
+							childLocations.Add(childNode.StartLocation.Line, childNode);
+					}
+					
+					if(typeRef.FilePath==null||typeRef.FilePath=="")
+						typeRef.FilePath=ComplexityMetrics.File.FilePath;
+					
+					startIndex = node.StartLocation.Line;
+					int endIndex = node.EndLocation.Line;
+					ulong totalLines = 0, totalRealLines = 0, totalCommentedLines = 0;
+					int realLines = 0;
+					bool isSingleLineComment = false;
+					bool isMultipleLineComment = false;
+					
+					for(int i=startIndex;i< endIndex;i++)
+					{
+						string lineText = ComplexityMetrics.FileDoc.GetTextAt(ComplexityMetrics.FileText[i]).Trim();
+						
+						if(isMultipleLineComment){
+							totalCommentedLines++;
+							if(lineText.EndsWith("*/"))
+								isMultipleLineComment = false;
+							continue;
+						}
+						if(lineText.StartsWith ("/*")){
+							isMultipleLineComment = true;
+							totalCommentedLines++;
+							continue;
+						}
+						isSingleLineComment = lineText.StartsWith ("//");
+						if(isSingleLineComment)
+							totalCommentedLines++;
+						if (lineText.Length > 0 && !isSingleLineComment)
+						{
+							realLines++;
+							if(childLocations.ContainsKey(i)) {
+								ComplexityMetrics.PrefixName.Push(node.Name);
+								if((childLocations[i] is MethodDeclaration) || (childLocations[i] is ConstructorDeclaration)) {
+									ComplexityMetrics.ProcessMethod(ctx, childLocations[i], typeRef);
+									i = childLocations[i].EndLocation.Line;
+								} else if(childLocations[i] is TypeDeclaration) {
+									i = EvaluateTypeLOC(ctx, namespaceRef, (TypeDeclaration)childLocations[i], i);
+								} 
+								ComplexityMetrics.PrefixName.Pop();
+							}
+						}
+					}
+				
+					totalLines     += (ulong)(endIndex-startIndex+2);
+					totalRealLines += (ulong)realLines;
+					if(typeRef is ClassProperties) {
+						((ClassProperties)typeRef).LOCReal += totalRealLines;
+						((ClassProperties)typeRef).LOCComments += totalCommentedLines;
+					} else if (typeRef is InterfaceProperties) {
+						((InterfaceProperties)typeRef).LOCReal += totalRealLines;
+						((InterfaceProperties)typeRef).LOCComments += totalCommentedLines;
+					} else if (typeRef is EnumProperties) {
+						((EnumProperties)typeRef).LOCReal += totalRealLines;
+						((EnumProperties)typeRef).LOCComments += totalCommentedLines;
+					} else if (typeRef is StructProperties) {
+						((StructProperties)typeRef).LOCReal += totalRealLines;
+						((StructProperties)typeRef).LOCComments += totalCommentedLines;
+					} else if (typeRef is DelegateProperties) {
+						((DelegateProperties)typeRef).LOCReal += totalRealLines;
+						((DelegateProperties)typeRef).LOCComments += totalCommentedLines;
+					} 
+				
+					
+				} catch (Exception e) {
+					Console.WriteLine("Error in class " + typeName.ToString());
+					Console.WriteLine(e.ToString());
+				}
+				return node.EndLocation.Line;
+			}
+		
+			internal static void EvaluateMethodLOC(MethodProperties prop, List<LineSegment> text, Mono.TextEditor.Document doc)
+			{
+				ulong totalLines = 0, totalRealLines = 0, totalCommentedLines = 0;
+				int realLines = 0;
+				bool isSingleLineComment = false;
+				bool isMultipleLineComment = false;
+				
+				int startIndex=prop.StartLine;
+				int endIndex=prop.EndLine;
+				
+				for(int i=startIndex;i< endIndex;i++)
+				{
+					string lineText = "";
+					try{
+					lineText = doc.GetTextAt(text[i]).Trim();
+					} catch (Exception e) {
+						continue;
+					}
+					if(isMultipleLineComment){
+						totalCommentedLines++;
+						if(lineText.EndsWith("*/"))
+							isMultipleLineComment = false;
+						continue;
+					}
+					if(lineText.StartsWith ("/*")){
+						isMultipleLineComment = true;
+						totalCommentedLines++;
+						continue;
+					}
+					isSingleLineComment = lineText.StartsWith ("//");
+					if(isSingleLineComment)
+						totalCommentedLines++;
+					if (lineText.Length > 0 && !isSingleLineComment)
+						realLines++;	
+				}
+			
+				totalLines     += (ulong)(endIndex-startIndex+1);
+				totalRealLines += (ulong)realLines;
+				((MethodProperties)prop).LOCComments = totalCommentedLines;
+				((MethodProperties)prop).LOCReal = totalRealLines + 1;
+			}		
+		}
+	}
+}
+
Index: MonoDevelop.CodeMetrics/AssociationBetweenClasses.cs
===================================================================
--- MonoDevelop.CodeMetrics/AssociationBetweenClasses.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/AssociationBetweenClasses.cs	(revision 0)
@@ -0,0 +1,36 @@
+// 
+// AssociationBetweenClasses.cs
+//  
+// Author:
+//       nikhil <${AuthorEmail}>
+// 
+// Copyright (c) 2010 nikhil
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+using System;
+namespace MonoDevelop.CodeMetrics
+{
+	public class AssociationBetweenClasses
+	{
+		public AssociationBetweenClasses ()
+		{
+		}
+	}
+}
+
Index: MonoDevelop.CodeMetrics/CodeMetricsServices.cs
===================================================================
--- MonoDevelop.CodeMetrics/CodeMetricsServices.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/CodeMetricsServices.cs	(revision 0)
@@ -0,0 +1,194 @@
+// 
+// CodeMetricsServices.cs
+//  
+// Author:
+//       nikhil <${AuthorEmail}>
+// 
+// Copyright (c) 2009 nikhil
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class CodeMetricsService
+	{
+		public static void AddTypes (ProjectProperties projectprop, MetricsContext ctx)
+		{
+			ProjectDom dom = ProjectDomService.GetProjectDom (projectprop.Project);
+			foreach (IType ob in dom.Types) {
+				projectprop.AddInstance(ob);
+			}
+		}
+		
+		internal static void ProcessInnerTypes(ProjectProperties projprop)
+		{
+			foreach (var namesp in projprop.Namespaces) {
+				namesp.Value.ProcessClasses();
+				projprop.CyclometricComplexity += namesp.Value.CyclometricComplexity;
+				projprop.LOCReal += namesp.Value.LOCReal;
+				projprop.LOCComments += namesp.Value.LOCComments;
+			}
+			foreach (var cls in projprop.Classes) {
+				cls.Value.ProcessInnerClasses();
+				projprop.CyclometricComplexity += cls.Value.CyclometricComplexity;
+				projprop.LOCReal += cls.Value.LOCReal;
+				projprop.LOCComments += cls.Value.LOCComments;
+			}	
+		}
+		
+		public static string GenerateAssemblyMetricText()
+		{
+			// TODO General stuff about the assembly
+			return "";
+		}
+		
+		public static string GenerateTypeMetricText(IProperties item)
+		{
+			if(item is NamespaceProperties){
+				
+				return GenerateNamespaceMetricText((NamespaceProperties)item).ToString();
+				
+			} else if (item is MethodProperties) {
+				
+				return GenerateMethodMetricText((MethodProperties)item).ToString();
+				
+			} else if (item is ClassProperties) {
+				
+				return GenerateClassMetricText((ClassProperties)item).ToString();
+				
+			} else if (item is InterfaceProperties) {
+				
+				return GenerateInterfaceMetricText((InterfaceProperties)item).ToString();
+				
+			} else if (item is EnumProperties) {
+				
+				return GenerateEnumMetricText((EnumProperties)item).ToString();
+				
+			} else if (item is DelegateProperties) {
+				
+				return GenerateDelegateMetricText((DelegateProperties)item).ToString();
+				
+			} else if (item is StructProperties) {
+				
+				return GenerateStructMetricText((StructProperties)item).ToString();
+			
+			}
+			
+			return "NULL";
+		}
+		
+		private static StringBuilder GenerateNamespaceMetricText(NamespaceProperties item)
+		{
+			StringBuilder results = new StringBuilder();
+			results.Append(GettextCatalog.GetString("\nName : ") + item.FullName);
+			results.Append(GettextCatalog.GetString("\nTotal number of classes : ") + item.Classes.Count);
+			results.Append(GettextCatalog.GetString("\nTotal number of methods : ") + item.MethodCount);
+			results.Append(GettextCatalog.GetString("\nTotal number of fields : ") + item.FieldCount);
+			results.Append(GettextCatalog.GetString("\nClass Coupling : ") + item.ClassCoupling);
+			return results;
+		}
+		
+		private static StringBuilder GenerateClassMetricText(ClassProperties item)
+		{
+			StringBuilder results = new StringBuilder();
+			results.Append(GettextCatalog.GetString("\nName : ") + item.FullName);
+			results.Append(GettextCatalog.GetString("\nDepth of inheritance : ") + item.DepthOfInheritance);
+			results.Append(GettextCatalog.GetString("\nNumber of children : ") + item.FanOut);
+			results.Append(GettextCatalog.GetString("\nAfferent Coupling : ") + item.AfferentCoupling);
+			results.Append(GettextCatalog.GetString("\nEfferent Coupling : ") + item.EfferentCoupling);
+			results.Append(GettextCatalog.GetString("\nData abstraction coupling : ") + item.DataAbstractionCoupling);
+			results.Append(GettextCatalog.GetString("\nConstructors : ") + item.ConstructorCount);
+			results.Append(GettextCatalog.GetString("\nDelegates : ") + item.DelegateCount);
+			results.Append(GettextCatalog.GetString("\nEvents : ") + item.EventCount);
+			results.Append(GettextCatalog.GetString("\nFields : ") + item.FieldCount);
+			results.Append(GettextCatalog.GetString("\nInner classes : ") + item.InnerClassCount);
+			results.Append(GettextCatalog.GetString("\nStructs : ") + item.StructCount);
+			results.Append(GettextCatalog.GetString("\nMethods : ") + item.MethodCount);
+			results.Append(GettextCatalog.GetString("\nProperties : ") + item.Class.PropertyCount);
+			results.Append(GettextCatalog.GetString("\nLack of cohesion of methods : ") + item.LCOM);
+			results.Append(GettextCatalog.GetString("\nLack of cohesion of methods (Henderson-Sellers) : ") + item.LCOM_HS);
+			return results;
+		}
+		
+		private static StringBuilder GenerateMethodMetricText(MethodProperties item)
+		{
+			StringBuilder results = new StringBuilder();
+			results.Append(GettextCatalog.GetString("\nName : " + item.FullName));
+			results.Append(GettextCatalog.GetString("\nTotal number of local variables : " + item.NumberOfVariables));
+			results.Append(GettextCatalog.GetString("\nTotal number of parameters : " + item.ParameterCount));
+			results.Append(GettextCatalog.GetString("\nAfferent Coupling : " + item.AfferentCoupling));
+			results.Append(GettextCatalog.GetString("\nEfferent Coupling : " + item.EfferentCoupling));
+			
+			return results;
+		}
+		
+		private static StringBuilder GenerateStructMetricText (StructProperties item)
+		{
+			StringBuilder results = new StringBuilder();
+			results.Append(GettextCatalog.GetString("\nName : " + item.FullName));
+			results.Append(GettextCatalog.GetString("\nTotal number of fields : " + item.Struct.FieldCount));
+			results.Append(GettextCatalog.GetString("\nTotal number of properties : " + item.Struct.PropertyCount));
+			return results;
+		}
+		
+		private static StringBuilder GenerateInterfaceMetricText (InterfaceProperties item)
+		{
+			StringBuilder results = new StringBuilder();
+			results.Append(GettextCatalog.GetString("\nName : " + item.FullName));
+			results.Append(GettextCatalog.GetString("\nTotal number of properties : " + item.Interface.PropertyCount));
+			results.Append(GettextCatalog.GetString("\nTotal number of methods : " + item.Interface.MethodCount));
+			return results;
+		}
+		
+		private static StringBuilder GenerateDelegateMetricText (DelegateProperties item)
+		{
+			StringBuilder results = new StringBuilder();
+			results.Append(GettextCatalog.GetString("\nName : " + item.FullName));
+			results.Append(GettextCatalog.GetString("\nReturn Type : " + item.Delegate.ReturnType));
+			results.Append(GettextCatalog.GetString("\nTotal number of parameters : " + item.Delegate.Parameters.Count));
+			return results;
+		}
+		
+		private static StringBuilder GenerateEnumMetricText (EnumProperties item)
+		{
+			StringBuilder results = new StringBuilder();
+			results.Append(GettextCatalog.GetString("\nName : " + item.FullName));
+			results.Append(GettextCatalog.GetString("\nTotal number of inner types : " + item.Enum.InnerTypeCount));
+			return results;
+		}
+	}
+}
Index: MonoDevelop.CodeMetrics/CodeMetricsWidget.cs
===================================================================
--- MonoDevelop.CodeMetrics/CodeMetricsWidget.cs	(revision 153925)
+++ MonoDevelop.CodeMetrics/CodeMetricsWidget.cs	(working copy)
@@ -3,8 +3,9 @@
 //
 // Author:
 //   Mike Krüger <mkrueger@novell.com>
+//	 Nikhil Sarda <diff.operator@gmail.com>
 //
-// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
+// Copyright (C) 2008 Novell, Inc (http://www.novell.com), Nikhil Sarda
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -28,251 +29,325 @@
 
 using System;
 using System.Collections.Generic;
+using System.IO;
+
 using Gtk;
-using Mono.TextEditor;
+using Gdk;
+
 using MonoDevelop.Core;
 using MonoDevelop.Ide;
+using MonoDevelop.Ide.Gui;
 using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
 
 namespace MonoDevelop.CodeMetrics
 {
-	[System.ComponentModel.Category("MonoDevelop.CodeMetrics")]
-	[System.ComponentModel.ToolboxItem(true)]
+	// TODO Use thread synchronization to coordinate between TreeStore drawing and Metrics calculation 
 	public partial class CodeMetricsWidget : Gtk.Bin
 	{
+		public static CodeMetricsWidget widget;
+		
 		List<string> files = new List<string> ();
-		TreeStore store = new TreeStore (typeof (string), // file name
-		                                 typeof (string), // line count (real lines)
-		     //                            typeof (string),  // license
-		                                 typeof (int) // line count number
+		List<ProjectProperties> projects = new List<ProjectProperties>();
+		
+		public List<ProjectProperties> Projects {
+			get {
+				return projects;
+			}
+		}
+		
+		MetricsContext ctx = new MetricsContext ();
+		
+		//TODO Treestore will have LOC, real LOC, commented LOC and cyclometric complexity (later to add code coverage)
+		TreeStore metricStore = new TreeStore (typeof (Pixbuf), // Icon
+		                                 typeof (string), // type name
+		                                 typeof (string), // cyclometric complexity
+		                                 typeof (string), // class coupling
+		                                 typeof (string), 	  // real loc
+		                                 typeof (string),	  // comments loc
+		                                 typeof (IProperties)  // reference to objects
 		                                 );
-		TreeViewColumn col1, col2;
+		TreeViewColumn iconCol, 
+						typenameCol, 
+						cyclometricComplexityCol,
+						classCouplingCol,
+						realLocCol, 
+						commentsLocCol;
+		
+		CellRendererText crt;
+		IProperties rowSelectTypeName;
+		bool clicked = false;
+		
 		public CodeMetricsWidget()
 		{
 			this.Build();
 			treeviewMetrics.RulesHint = true;
-			treeviewMetrics.Model = store;
+			treeviewMetrics.Model = metricStore;
 			
-			CellRendererText crt = new CellRendererText ();
+			projects = new List<ProjectProperties>();
+			
+			crt = new CellRendererText ();
 			crt.Ellipsize = Pango.EllipsizeMode.Start;
-			col1 = new TreeViewColumn (GettextCatalog.GetString ("File"), crt, "text", 0);
-			col1.SortIndicator = true;
-			col1.SortColumnId = 0;
-			col1.Expand = true;
-			col1.Resizable = true;
-			treeviewMetrics.AppendColumn (col1);
 			
-			col2 = new TreeViewColumn (GettextCatalog.GetString ("Lines (real)"), new CellRendererText (), "text", 1);
-			col2.SortIndicator = true;
-			col2.SortColumnId = 3;
-			treeviewMetrics.AppendColumn (col2);
-			/*
-			col = new TreeViewColumn (GettextCatalog.GetString ("License"), new CellRendererText (), "text", 2);
-			col.SortIndicator = true;
-			col.SortColumnId = 2;
-			treeviewMetrics.AppendColumn (col);*/
+			iconCol = new TreeViewColumn (GettextCatalog.GetString ("Icon"), new Gtk.CellRendererPixbuf (), "pixbuf", 0);
+			iconCol.SortIndicator = true;
+			iconCol.SortColumnId = 1;
+			iconCol.Expand = false;
+			iconCol.Resizable = true;
+			treeviewMetrics.AppendColumn (iconCol);
+						
+			typenameCol = new TreeViewColumn (GettextCatalog.GetString ("Type name"), crt, "text", 1);
+			typenameCol.SortIndicator = true;
+			typenameCol.SortColumnId = 0;
+			typenameCol.Expand = true;
+			typenameCol.Resizable = true;
+			treeviewMetrics.AppendColumn (typenameCol);
+			
+			cyclometricComplexityCol = new TreeViewColumn (GettextCatalog.GetString ("Cyclometric Complexity"), new CellRendererText (), "text", 2);
+			cyclometricComplexityCol.SortIndicator = true;
+			cyclometricComplexityCol.SortColumnId = 0;
+			cyclometricComplexityCol.Reorderable = true;
+			cyclometricComplexityCol.Resizable = false;
+			treeviewMetrics.AppendColumn (cyclometricComplexityCol);
+			
+			classCouplingCol = new TreeViewColumn (GettextCatalog.GetString ("Class Coupling"), new CellRendererText (), "text", 3);
+			classCouplingCol.SortIndicator = true;
+			classCouplingCol.SortColumnId = 0;
+			classCouplingCol.Reorderable = true;
+			classCouplingCol.Resizable = false;
+			treeviewMetrics.AppendColumn (classCouplingCol);
+			
+			realLocCol = new TreeViewColumn (GettextCatalog.GetString ("Real Loc"), new CellRendererText (), "text", 4);
+			realLocCol.SortIndicator = true;
+			realLocCol.SortColumnId = 0;
+			realLocCol.Reorderable = true;
+			realLocCol.Resizable = false;
+			treeviewMetrics.AppendColumn (realLocCol);
+			
+			commentsLocCol = new TreeViewColumn (GettextCatalog.GetString ("Comments Loc"), new CellRendererText (), "text", 5);
+			commentsLocCol.SortIndicator = true;
+			commentsLocCol.SortColumnId = 0;
+			commentsLocCol.Reorderable = true;
+			commentsLocCol.Resizable = false;
+			treeviewMetrics.AppendColumn (commentsLocCol);
+			
+			// TODO: When user clicks on the respective type then the corresponding filename containing that type should open
+			
 			this.treeviewMetrics.RowActivated += delegate {
 				Gtk.TreeIter selectedIter;
 				if (treeviewMetrics.Selection.GetSelected (out selectedIter)) {
-					string fileName = (string)store.GetValue (selectedIter, 0);
-					IdeApp.Workbench.OpenDocument (fileName);
+					rowSelectTypeName = (IProperties)metricStore.GetValue (selectedIter, 6);
+						MonoDevelop.Ide.IdeApp.Workbench.OpenDocument (rowSelectTypeName.FilePath);
+						MonoDevelop.Ide.IdeApp.Workbench.ActiveDocument.TextEditor.JumpTo(rowSelectTypeName.StartLine, 0);	
 				}
 			};
+			
+			this.treeviewMetrics.CursorChanged += delegate {
+				Gtk.TreeIter selectedIter;
+				if (treeviewMetrics.Selection.GetSelected (out selectedIter)) {
+					rowSelectTypeName = (IProperties)metricStore.GetValue (selectedIter, 6);
+					Gtk.Application.Invoke( delegate {
+						textviewReport.Buffer.Text = CodeMetricsService.GenerateTypeMetricText(rowSelectTypeName);	
+					});
+				}
+			};
 		}
 		
 		protected override void OnDestroyed ()
 		{
-			if (store != null) {
-				store.Dispose ();
-				store = null;
+			if (metricStore != null) {
+				metricStore.Dispose ();
+				metricStore = null;
 			}
 			base.OnDestroyed ();
 		}
 		
 		class MetricsWorkerThread : WorkerThread
 		{
-			//Dictionary<string, Mono.TextEditor.Document> headers = new Dictionary<string, Mono.TextEditor.Document> ();
-			//int longestHeader = -1;
-				
-			CodeMetricsWidget widget;
+			//Earlier wasnt using the static thing, maybe not required as well
+			CodeMetricsWidget widget=CodeMetricsWidget.widget;
 			
-			//int[,] num;
+			public static object lockCounter = new object();
+			
 			public MetricsWorkerThread (CodeMetricsWidget widget)
 			{
 				this.widget = widget;
-			/*	foreach (KeyValuePair<string, string> header in StandardHeaderService.HeaderTemplates) {
-					Mono.TextEditor.Document newDoc = new Mono.TextEditor.Document ();
-					newDoc.Text = header.Value;
-					headers[header.Key] = newDoc;
-					longestHeader = Math.Max (longestHeader, header.Value.Length);
-				}i*/
-			//	num = new int [longestHeader, longestHeader];
 			}
-			/* real lcs takes too long, but we can fake it.
-			int LongestCommonSubstring (string str1, string str2)
+			
+			protected override void InnerRun ()
 			{
-				if (String.IsNullOrEmpty (str1) || String.IsNullOrEmpty (str2))
-					return 0;
+				int counter=0;
+				int totalProjects = widget.projects.Count;
+				try {
+					foreach(ProjectProperties projectprop in widget.projects)
+						CodeMetricsService.AddTypes(projectprop, widget.ctx);
+					
+					foreach(ProjectProperties projectprop in widget.projects) {
+						ObjectOrientedMetrics.EvaluateOOMetrics(widget.ctx, projectprop);
+						ComplexityMetrics.EvaluateComplexityMetrics(widget.ctx, projectprop);
+						CodeMetricsService.ProcessInnerTypes(projectprop);
+					
+						Gtk.Application.Invoke ( delegate {
+							FillTree(projectprop);
+						});
+						if(base.IsStopping)
+							return;
+						lock(lockCounter)
+						{
+							counter++;
+							DispatchService.GuiSyncDispatch (delegate {
+								IdeApp.Workbench.StatusBar.SetProgressFraction (counter / (double)totalProjects);
+							});
+						}
+					}
+				} catch (Exception e) {
+					Console.WriteLine("Error : " + e.ToString());
+					base.Stop ();
+				}
 				
-				for (int i = 0; i < str1.Length; i++) {
-					num [i, 0] = 0;
+				
+				Gtk.Application.Invoke (delegate {
+					IdeApp.Workbench.StatusBar.ShowMessage("Finished calculating metrics\n");
+					IdeApp.Workbench.StatusBar.EndProgress ();
+					widget.textviewReport.Buffer.Text = GettextCatalog.GetString ("Finished calculating metrics\n");
+					widget.textviewReport.Buffer.Text += CodeMetricsService.GenerateAssemblyMetricText();
+				});
+				
+				base.Stop ();
+			}
+			
+			protected void FillTree (ProjectProperties projprop)
+			{
+				var rootIter = widget.metricStore.AppendValues ( ImageService.GetPixbuf("md-project", Gtk.IconSize.Menu),
+					                                           projprop.Project.Name, 
+				    	                                       projprop.CyclometricComplexity.ToString(),
+				        	                                   "",
+				            	                               projprop.LOCReal.ToString(),
+				                	                           projprop.LOCComments.ToString(),
+				                       	                       projprop);
+				
+					FillNamespaces(projprop.Namespaces, rootIter);
+					FillClasses(projprop.Classes, rootIter);
+					FillEnums(projprop.Enums, rootIter);
+					FillStructs(projprop.Structs, rootIter);
+					FillDelegates(projprop.Delegates, rootIter);
+					FillInterfaces(projprop.Interfaces, rootIter);
+			}
+			
+			private void FillNamespaces (Dictionary<string, NamespaceProperties> namespaces, TreeIter parentIter)
+			{
+				foreach (var namesp in namespaces) {
+					var subiter = widget.metricStore.AppendValues (parentIter,
+					                                           ImageService.GetPixbuf("md-name-space", Gtk.IconSize.Menu),
+					                                           namesp.Value.FullName, 
+					                                           namesp.Value.CyclometricComplexity.ToString(), 
+					                                           namesp.Value.ClassCoupling.ToString(),
+					                                           namesp.Value.LOCReal.ToString(),
+					                                           namesp.Value.LOCComments.ToString(),
+					                                           namesp.Value);
+					FillClasses(namesp.Value.Classes, subiter);
+					FillEnums(namesp.Value.Enums, subiter);
+					FillStructs(namesp.Value.Structs, subiter);
+					FillDelegates(namesp.Value.Delegates, subiter);
+					FillInterfaces(namesp.Value.Interfaces, subiter);
 				}
-				for (int j = 0; j < str2.Length; j++) {
-					num [0, j] = 0;
+			}
+			
+			private void FillEnums (Dictionary<string,EnumProperties> enms, TreeIter parentIter)
+			{
+				foreach (var cls in enms){
+					var iter = widget.metricStore.AppendValues (parentIter,
+					                                            ImageService.GetPixbuf("md-enum", Gtk.IconSize.Menu),
+					                                            cls.Value.FullName, 
+					                                            cls.Value.CyclometricComplexity.ToString(),
+					                                            cls.Value.ClassCoupling.ToString(),
+					                                            cls.Value.LOCReal.ToString(),
+					                                            cls.Value.LOCComments.ToString(),
+					                                            cls.Value);
 				}
-				
-				for (int i = 1; i < str1.Length; i++) {
-					for (int j = 1; j < str2.Length; j++) {
-						if (str1[i] == str2[j])
-							num [i, j] = num [i - 1, j - 1] + 1;
-						else 
-							num [i, j] = Math.Max (num [i, j - 1], num [i - 1, j]);
-					}
+			}
+			
+			private void FillStructs (Dictionary<string, StructProperties> strcts, TreeIter parentIter)
+			{
+				foreach (var cls in strcts){
+					var iter = widget.metricStore.AppendValues (parentIter,
+					                                            ImageService.GetPixbuf("md-struct", Gtk.IconSize.Menu),
+					                                            cls.Value.FullName, 
+					                                            cls.Value.CyclometricComplexity.ToString(),
+					                                            cls.Value.ClassCoupling.ToString(),
+					                                            cls.Value.LOCReal.ToString(),
+					                                            cls.Value.LOCComments.ToString(),
+					                                            cls.Value);
 				}
-				return num [str1.Length - 1, str2.Length - 1];
-			}*/
+			}
 			
-		/*	int FakeLongestCommonSubstring (Mono.TextEditor.Document doc, string header)
+			private void FillInterfaces (Dictionary<string, InterfaceProperties> interfces, TreeIter parentIter)
 			{
-				int lcs = 0;
-				int i = 0;
-				
-				int j = Math.Max (0, header.LastIndexOf ('}') + 1);
-				while (j < header.Length && i < doc.Length) {
-					if (doc.GetCharAt (i) == header[j]) {
-						i++;
-						j++;
-						lcs++;
-						continue;
-					} 
-					if (Char.IsWhiteSpace (header[j])) {
-						j++;
-						continue;
-					}
-					if (header[j] == '[') {
-						while (j < header.Length && header[j] != ']') {
-							j++;
-						}
-						j++;
-						continue;
-					}
-					if (Char.IsWhiteSpace (doc.GetCharAt (i))) {
-						i++;
-						continue;
-					}
-					i++;
+				foreach (var cls in interfces){
+					var iter = widget.metricStore.AppendValues (parentIter,
+					                                            ImageService.GetPixbuf("md-interface", Gtk.IconSize.Menu),
+					                                            cls.Value.FullName, 
+					                                            cls.Value.CyclometricComplexity.ToString(),
+					                                            cls.Value.ClassCoupling.ToString(),
+					                                            cls.Value.LOCReal.ToString(),
+					                                            cls.Value.LOCComments.ToString(),
+					                                            cls.Value);
+					// Add recursive field for members of interfaces
 				}
-				return lcs;
-			}*/
+			}
 			
-			//string last = null;
-			/*
-			string GetLicense (Mono.TextEditor.Document document)
+			private void FillDelegates (Dictionary<string, DelegateProperties> dlgtes, TreeIter parentIter)
 			{
-				string result = GettextCatalog.GetString ("Unknown");
-				//string possibleHeader = document.GetTextAt (0, Math.Min (this.longestHeader, document.Length));
-				
-				if (!String.IsNullOrEmpty (last)) {
-					foreach (KeyValuePair<string, string> header in StandardHeaderService.HeaderTemplates) {
-						if (header.Key == last) {
-							int match = FakeLongestCommonSubstring (document, header.Value);//;LongestCommonSubstring (header.Value, possibleHeader);
-							if (match > header.Value.Length / 2) 
-								return header.Key;
-							break;
-						}
-					}
+				foreach (var cls in dlgtes){
+					var iter = widget.metricStore.AppendValues (parentIter,
+					                                            ImageService.GetPixbuf("md-method", Gtk.IconSize.Menu),
+					                                            cls.Value.FullName, 
+					                                            cls.Value.CyclometricComplexity.ToString(),
+					                                            cls.Value.ClassCoupling.ToString(),
+					                                            cls.Value.LOCReal.ToString(),
+					                                            cls.Value.LOCComments.ToString(),
+					                                            cls.Value);
 				}
-				
-				foreach (KeyValuePair<string, string> header in StandardHeaderService.HeaderTemplates) {
-					if (header.Key == last)
-						continue;
-					int match = FakeLongestCommonSubstring (document, header.Value);
-//					int match = LongestCommonSubstring (header.Value, possibleHeader);
-					if (match > header.Value.Length / 2) {
-						last = header.Key;
-						return header.Key;
-					}
+			}
+			
+			private void FillClasses (Dictionary<string, ClassProperties> clss, TreeIter parentIter)
+			{
+				foreach (var cls in clss){
+					var childIter = widget.metricStore.AppendValues (parentIter,
+					                                            ImageService.GetPixbuf("md-class", Gtk.IconSize.Menu),
+					                                            cls.Value.FullName, 
+					                                            cls.Value.CyclometricComplexity.ToString(),
+					                                            cls.Value.ClassCoupling.ToString(),
+					                                            cls.Value.LOCReal.ToString(),
+					                                            cls.Value.LOCComments.ToString(),
+					                                            cls.Value);
+					FillMethods(cls.Value.Methods, childIter);
+					FillDelegates(cls.Value.InnerDelegates, childIter);
+					FillStructs(cls.Value.InnerStructs, childIter);
+					FillEnums(cls.Value.InnerEnums, childIter);
+					FillInterfaces(cls.Value.InnerInterfaces, childIter);
+					FillClasses(cls.Value.InnerClasses, childIter);
 				}
-				return result;
 			}
-			Dictionary<string, int> licenseStats = new Dictionary<string,int> (); */
-			protected override void InnerRun ()
+		
+			private void FillMethods (Dictionary<string, MethodProperties> mthd, TreeIter parentIter)
 			{
-				ulong totalLines = 0, totalRealLines = 0, totalCommentedLines = 0;
-				Mono.TextEditor.Document doc = new Mono.TextEditor.Document ();
-				for (int i = 0; i < widget.files.Count; i++) {
-					string file = widget.files [i];
-					if (base.IsStopping)
-						return;
-					try {
-						doc.Text = System.IO.File.ReadAllText (file);
-					} catch (Exception e) {
-						DispatchService.GuiSyncDispatch (delegate {
-						IdeApp.Workbench.StatusBar.SetProgressFraction (i / (double)widget.files.Count);
-							widget.store.AppendValues (file,
-							                           e.Message,
-							                           e.Message);
-						});
-						continue;
-					}
-					int realLines = 0;
-					foreach (LineSegment segment in doc.Lines) {
-						string text = doc.GetTextAt (segment).Trim ();
-						bool isComment = text.StartsWith ("//");
-						if (isComment)
-							totalCommentedLines++;
-						if (text.Length > 0 && !isComment)
-							realLines++;
-					}
-			//		string license = GetLicense (doc);
-			//		if (!licenseStats.ContainsKey (license))
-			//			licenseStats [license] = 0;
-					totalLines     += (ulong)doc.LineCount;
-					totalRealLines += (ulong)realLines;
-			//		licenseStats[license]++;
-					DispatchService.GuiSyncDispatch (delegate {
-						IdeApp.Workbench.StatusBar.SetProgressFraction (i / (double)widget.files.Count);
-						widget.store.AppendValues (file,
-						                           doc.LineCount + "(" + realLines + ")",
-						                         //  license,
-						                           doc.LineCount);
-					});
+				foreach (var cls in mthd){
+					var childIter = widget.metricStore.AppendValues (parentIter,
+					                                            ImageService.GetPixbuf("md-method", Gtk.IconSize.Menu),
+					                                            cls.Value.FullName, 
+					                                            cls.Value.CyclometricComplexity.ToString(),
+					                                            cls.Value.ClassCoupling.ToString(),
+					                                            cls.Value.LOCReal.ToString(),
+					                                            cls.Value.LOCComments.ToString(),
+					                                            cls.Value);
 				}
-				DispatchService.GuiSyncDispatch (delegate {
-					IdeApp.Workbench.StatusBar.EndProgress ();
-					widget.ShowResults (totalLines, totalRealLines, totalCommentedLines);//, licenseStats);
-				});
-				base.Stop ();
 			}
-				
 		}
 		
-		public void ShowResults (ulong lines, ulong realLines, ulong commentedLines)//, Dictionary<string, int> licenseStats)
-		{
-			textviewReport.Buffer.Text = GettextCatalog.GetString ("Results:"); 
-			textviewReport.Buffer.Text += Environment.NewLine; 
-			textviewReport.Buffer.Text += GettextCatalog.GetString ("lines: {0} (real:{1}), commented:{2} ({3:0.00}%), blank:{4} ({5:0.00}%)",
-			                                                       lines,
-			                                                       realLines,
-			                                                       commentedLines,
-			                                                       Percent (commentedLines, lines),
-			                                                       lines - realLines - commentedLines,
-			                                                       Percent (lines - realLines - commentedLines, lines));
-			textviewReport.Buffer.Text += Environment.NewLine; /*
-			textviewReport.Buffer.Text += Environment.NewLine; 
-			textviewReport.Buffer.Text += GettextCatalog.GetString ("Licenses:"); 
-			textviewReport.Buffer.Text += Environment.NewLine; 
-			foreach (KeyValuePair<string, int> license in licenseStats) {
-				textviewReport.Buffer.Text += "\t"; 
-				textviewReport.Buffer.Text += license.Key;
-				textviewReport.Buffer.Text += Environment.NewLine; 
-				textviewReport.Buffer.Text +=  String.Format ("\t\t{0} ({1:0.00}%)",
-				                                              license.Value,
-				                                              license.Value * 100.0 / this.files.Count); 
-				textviewReport.Buffer.Text += Environment.NewLine; 
-			}*/
-		}
-		
 		double Percent (ulong a, ulong b)
 		{
 			if (b == 0)
@@ -283,11 +358,12 @@
 		public void Run ()
 		{
 			MetricsWorkerThread thread = new MetricsWorkerThread (this);
-			IdeApp.Workbench.StatusBar.BeginProgress (GettextCatalog.GetString ("Scanning files..."));
-			textviewReport.Buffer.Text = GettextCatalog.GetString ("Scanning files...");
+			IdeApp.Workbench.StatusBar.BeginProgress (GettextCatalog.GetString ("Calculating Metrics..."));
+			textviewReport.Buffer.Text = GettextCatalog.GetString ("Calculating Metrics...");
 			thread.Start ();
 		}
 		
+		#region AddMethods
 		public void Add (string fileName)
 		{
 			files.Add (fileName);
@@ -301,26 +377,26 @@
 		
 		public void Add (Project project)
 		{
-//			System.Console.WriteLine("add project folder :" + project);
+			projects.Add(new ProjectProperties(project));
 			foreach (ProjectFile projectFile in project.Files) {
-				Add (projectFile);
+				Add (projectFile);	
 			}
 		}
 		
 		public void Add (SolutionFolder combine)
 		{
-//			System.Console.WriteLine("add solution folder :" + combine);
 			foreach (Project project in combine.GetAllProjects ()) {
 				Add (project);
 			}
+			
 		}
 		
 		public void Add (WorkspaceItem item)
 		{
-//			System.Console.WriteLine("add workspace item:" + item);
 			foreach (Project project in item.GetAllProjects ()) {
 				Add (project);
 			}
 		}
+		#endregion
 	}
 }
\ No newline at end of file
Index: MonoDevelop.CodeMetrics/IProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/IProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/IProperties.cs	(revision 0)
@@ -0,0 +1,42 @@
+// 
+// IProperties.cs
+//  
+// Author:
+//       nikhil <${AuthorEmail}>
+// 
+// Copyright (c) 2010 nikhil
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+using System;
+using MonoDevelop.Projects.Dom;
+namespace MonoDevelop.CodeMetrics
+{
+	public interface IProperties
+	{
+		string FullName {get;}
+		int CyclometricComplexity {get;}
+		int ClassCoupling {get;}
+		int StartLine {get;}
+		int EndLine {get;}
+		ulong LOCReal {get;}
+		ulong LOCComments {get;}
+		string FilePath {get;set;}
+	}
+}
+
Index: MonoDevelop.CodeMetrics/ASTVisitor.cs
===================================================================
--- MonoDevelop.CodeMetrics/ASTVisitor.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/ASTVisitor.cs	(revision 0)
@@ -0,0 +1,327 @@
+// 
+// CyclomaticComplexity.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+//	     Michael J. Hutchinson <diff.operator@gmail.com>
+// 
+// Copyright (c) 2009 Nikhil Sarda, Michael J. Hutchinson
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.IO;
+
+using Gtk;
+
+using MonoDevelop.Core;
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory;
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	//TODO Read up on visitor pattern and implement it on top of this routine (recommended by Levi (tak!))
+	public partial class ComplexityMetrics
+	{
+		interface IStatementVisitor
+		{
+			void VisitStatement (BlockStatement statement, MethodProperties meth);
+			void VisitStatement (IfElseStatement statement, MethodProperties meth);
+			void VisitStatement (ElseIfSection statement, MethodProperties meth);
+			void VisitStatement (ForeachStatement statement, MethodProperties meth);
+			void VisitStatement (ForNextStatement  statement, MethodProperties meth);
+			void VisitStatement (ForStatement statement, MethodProperties meth);
+			void VisitStatement (DoLoopStatement statement, MethodProperties meth);
+			void VisitStatement (SwitchStatement statement, MethodProperties meth);
+			void VisitStatement (LocalVariableDeclaration statement, MethodProperties meth);
+			void VisitStatement (ExpressionStatement statement, MethodProperties meth);
+		}
+		
+		interface IExpressionVisitor
+		{
+			void VisitExpression (BinaryOperatorExpression expression, MethodProperties meth);
+			void VisitExpression (MemberReferenceExpression expression, MethodProperties meth);
+			void VisitExpression (ParenthesizedExpression expression, MethodProperties meth);
+			void VisitExpression (ConditionalExpression expression, MethodProperties meth);
+			void VisitExpression (IdentifierExpression expression, MethodProperties meth);
+			void VisitExpression (AssignmentExpression expression, MethodProperties meth);
+			void VisitExpression (PrimitiveExpression expression, MethodProperties meth);
+			void VisitExpression (InvocationExpression expression, MethodProperties meth);
+		}
+		
+		private class ASTVisitor : IStatementVisitor, IExpressionVisitor
+		{
+			private static ClassProperties cls;
+			
+			internal static void EvaluateComplexityMetrics (ICSharpCode.NRefactory.Ast.INode method, MethodProperties props)
+			{
+				props.CyclometricComplexity = 1;
+				props.LOCReal=0;
+				props.NumberOfVariables=0;
+				
+				cls = props.ParentClass;
+				
+				ASTVisitor ctxAstVisitor = new ASTVisitor();
+				if(method is MethodDeclaration) {
+					foreach (var statement in ((MethodDeclaration)method).Body.Children) {
+						ctxAstVisitor.VisitStatement(statement, props);
+					}
+				} else if (method is ConstructorDeclaration) {
+					foreach (var statement in ((ConstructorDeclaration)method).Body.Children) {
+						ctxAstVisitor.VisitStatement(statement, props);
+					}
+				}
+				cls.CyclometricComplexity += props.CyclometricComplexity;
+			}
+		
+			private ASTVisitor(){}
+			
+			public void VisitExpression (BinaryOperatorExpression expression, MethodProperties meth)
+			{
+				if(((BinaryOperatorExpression)expression).Op==BinaryOperatorType.LogicalAnd||((BinaryOperatorExpression)expression).Op==BinaryOperatorType.LogicalOr) {
+					meth.CyclometricComplexity++;
+					VisitExpression(((BinaryOperatorExpression)expression).Left , meth);
+					VisitExpression(((BinaryOperatorExpression)expression).Right, meth);
+				}
+			}
+			
+			public void VisitExpression (MemberReferenceExpression expression, MethodProperties meth)
+			{
+				return;
+			}
+			
+			public void VisitExpression (ParenthesizedExpression expression, MethodProperties meth)
+			{
+				VisitExpression(((ParenthesizedExpression)expression).Expression, meth);
+			}
+			
+			public void VisitExpression (ConditionalExpression expression, MethodProperties meth)
+			{
+				VisitExpression(((ConditionalExpression)expression).Condition, meth);
+				VisitExpression(((ConditionalExpression)expression).TrueExpression, meth);
+			}
+			
+			public void VisitExpression (IdentifierExpression expression, MethodProperties meth)
+			{
+				if(cls.Fields.ContainsKey(expression.Identifier)){
+					cls.Fields[expression.Identifier].InternalAccessCount++;
+				} else {
+					foreach(var field in cls.Fields){
+					//TODO External access
+					}
+				
+				}
+			}
+			
+			public void VisitExpression (AssignmentExpression expression, MethodProperties meth)
+			{
+				VisitExpression(expression.Left, meth);
+				VisitExpression(expression.Right, meth);
+			}
+			
+			public void VisitExpression (PrimitiveExpression expression, MethodProperties meth)
+			{
+				return;
+			}
+			
+			public void VisitExpression (InvocationExpression expression, MethodProperties meth)
+			{
+				//Coupling.EvaluateMethodCoupling(expression, meth);
+			}
+			
+			public void VisitStatement (BlockStatement statement, MethodProperties meth)
+			{
+				meth.LOCReal++;
+				foreach(var innerStatement in ((BlockStatement)statement).Children)
+					VisitStatement((Statement)innerStatement, meth);				
+			}
+			
+			public void VisitStatement (IfElseStatement statement, MethodProperties meth)
+			{
+				meth.CyclometricComplexity++;
+				//Process the conditions
+				VisitExpression(((IfElseStatement)statement).Condition, meth);
+				//Handle the true statement
+				foreach(Statement innerStatement in  ((IfElseStatement)statement).TrueStatement)
+					VisitStatement(innerStatement, meth);
+				//Handle the false statement
+				foreach(Statement innerStatement in ((IfElseStatement)statement).FalseStatement) {
+					meth.CyclometricComplexity++;		
+					VisitStatement(innerStatement, meth);
+				}
+				//Handle the ElseIf statements
+				foreach(ElseIfSection elseIfSection in ((IfElseStatement)statement).ElseIfSections)
+					VisitStatement(elseIfSection, meth);
+			}
+			
+			public void VisitStatement (ElseIfSection statement, MethodProperties meth)
+			{
+				meth.CyclometricComplexity++;
+				
+				VisitExpression(statement.Condition, meth);
+				VisitStatement(statement.EmbeddedStatement, meth);
+			}
+			
+			public void VisitStatement (ForeachStatement statement, MethodProperties meth)
+			{
+				meth.CyclometricComplexity++;
+				VisitExpression(((ForeachStatement)(statement)).Expression, meth);
+				
+				VisitExpression(statement.NextExpression, meth);						
+				
+				foreach(var innerStatement in ((ForeachStatement)statement).EmbeddedStatement.Children)
+					VisitStatement((Statement)innerStatement, meth);
+			}
+			
+			public void VisitStatement (ForNextStatement statement, MethodProperties meth)
+			{
+				meth.CyclometricComplexity++;
+				VisitExpression(statement.LoopVariableExpression, meth);
+				
+				foreach(Expression innerExpression in statement.NextExpressions)
+					VisitExpression(innerExpression, meth);
+				
+				foreach(var innerStatement in statement.EmbeddedStatement.Children)
+					VisitStatement(innerStatement, meth);
+			}
+			
+			public void VisitStatement (ForStatement statement, MethodProperties meth)
+			{
+				meth.CyclometricComplexity++;
+				VisitExpression(statement.Condition, meth);
+				
+				foreach(var innerStatement in ((ForStatement)statement).EmbeddedStatement.Children)
+					VisitStatement(innerStatement, meth);
+			}
+			
+			public void VisitStatement (DoLoopStatement statement, MethodProperties meth)
+			{
+				meth.CyclometricComplexity++;
+				VisitExpression(statement.Condition, meth);
+				
+				foreach(var innerStatement in statement.EmbeddedStatement.Children)
+					VisitStatement(innerStatement, meth);
+			}
+			
+			public void VisitStatement (SwitchStatement statement, MethodProperties meth)
+			{
+				meth.CyclometricComplexity++;
+				VisitExpression(((SwitchStatement)statement).SwitchExpression, meth);
+				foreach(SwitchSection innerSection in ((SwitchStatement)statement).SwitchSections){
+					meth.CyclometricComplexity++;
+					foreach(var caseLabel in innerSection.SwitchLabels)
+						VisitExpression(caseLabel.ToExpression, meth);
+				}
+			}
+			
+			public void VisitStatement (LocalVariableDeclaration statement, MethodProperties meth) 
+			{
+				meth.NumberOfVariables+=statement.Variables.Count;
+				foreach(VariableDeclaration variable in statement.Variables)
+					VisitExpression(variable.Initializer, meth);
+			}
+			
+			public void VisitStatement (ExpressionStatement statement, MethodProperties meth)
+			{
+				//TODO Ability to evaluate access count of external fields
+				// Currently we assume that MemberReferenceExpression is not called and that we directly go on to IdentifierExpression
+				VisitExpression(statement.Expression, meth);
+			}
+			
+			private void VisitStatement(ICSharpCode.NRefactory.Ast.INode statement, MethodProperties meth)
+			{
+				try{
+					if(statement is BlockStatement){
+						VisitStatement((BlockStatement)statement, meth);
+					} else if (statement is IfElseStatement) {
+					
+						VisitStatement((IfElseStatement)statement, meth);
+					} else if (statement is ElseIfSection) {
+						
+						VisitStatement((ElseIfSection)statement, meth);			
+					} else if (statement is ForeachStatement) {
+						
+						VisitStatement((ForeachStatement)statement, meth);
+					} else if (statement is ForStatement) {
+						
+						VisitStatement((ForStatement)statement,meth);
+					} else if (statement is ForNextStatement) {
+						
+						VisitStatement((ForNextStatement)statement, meth);
+					} else if (statement is DoLoopStatement) {
+						
+						VisitStatement((DoLoopStatement)statement, meth);
+					} else if (statement is SwitchStatement) {
+												
+						VisitStatement((SwitchStatement)statement, meth); 
+					} else if (statement is LocalVariableDeclaration) {
+						
+						VisitStatement((LocalVariableDeclaration)statement, meth);
+					} else if (statement is ExpressionStatement) {
+						
+						VisitStatement((ExpressionStatement)statement, meth);
+					} 
+				}catch(Exception ex){
+				Console.WriteLine(ex.ToString());
+				}
+			//See other potential types to exploit
+			}	
+			
+			private void VisitExpression(Expression expression, MethodProperties meth)
+			{
+				if(expression is IdentifierExpression){
+					
+					VisitExpression((IdentifierExpression)expression, meth);
+				} else if (expression is AssignmentExpression) {
+					
+					VisitExpression((AssignmentExpression)expression, meth);
+				} else if (expression is PrimitiveExpression) {
+					
+					VisitExpression((PrimitiveExpression)expression, meth);
+				} else if (expression is BinaryOperatorExpression) {
+			
+					VisitExpression((BinaryOperatorExpression) expression, meth);
+				} else if (expression is MemberReferenceExpression) {
+					//TODO something
+				} else if (expression is ParenthesizedExpression) {
+					
+					VisitExpression((ParenthesizedExpression)expression, meth);
+				} else if (expression is ConditionalExpression) {
+					
+					VisitExpression((ConditionalExpression)expression, meth);
+				} else if (expression is InvocationExpression) {
+					
+					VisitExpression((InvocationExpression)expression, meth);
+				}
+			}
+				//There are many more types to exploit
+		}
+	}
+}
+
Index: MonoDevelop.CodeMetrics/Cohesion.cs
===================================================================
--- MonoDevelop.CodeMetrics/Cohesion.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/Cohesion.cs	(revision 0)
@@ -0,0 +1,73 @@
+// 
+// Cohesion.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2010 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.IO;
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+using ICSharpCode.NRefactory;
+using ICSharpCode.NRefactory.Ast;
+using ICSharpCode.NRefactory.AstBuilder;
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class Cohesion
+	{
+		public static void EvaluateCohesion(ClassProperties cls)
+		{
+			double totalaccess = 0;
+			foreach (var field in cls.Fields)
+				totalaccess += field.Value.InternalAccessCount;
+			
+			cls.LCOM = 1 - (double)(totalaccess/(cls.Class.MethodCount*cls.Class.FieldCount));
+			cls.LCOM_HS = (cls.Class.MethodCount - totalaccess/cls.Class.FieldCount)/(cls.Class.MethodCount-1);
+			
+		}
+		/*
+		 * Pairwise Field Irrelation
+			Let:
+
+		    M 	be the set of methods defined by the class
+    		F 	be the set of fields defined by the class
+    		Mf 	be the subset of M of methods that access field f, where f is a member of F
+
+			Then, the Total Field Irrelation is the mean Jaccard Distance between Mf1 and Mf2, where f1 ≠ f2.
+		*/
+	}
+}
+
Index: MonoDevelop.CodeMetrics/NamespaceProperties.cs
===================================================================
--- MonoDevelop.CodeMetrics/NamespaceProperties.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/NamespaceProperties.cs	(revision 0)
@@ -0,0 +1,271 @@
+// 
+// CodeMetricsServices.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2009 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Text;
+
+using Gtk;
+
+using MonoDevelop.Core;
+ 
+using MonoDevelop.Ide.Gui;
+using MonoDevelop.Projects;
+using MonoDevelop.Projects.Dom;
+using MonoDevelop.Projects.Dom.Parser;
+using MonoDevelop.Projects.Dom.Output;
+using Mono.TextEditor;
+
+//add reference to configure.in file
+
+namespace MonoDevelop.CodeMetrics
+{
+	public class NamespaceProperties : IProperties
+	{
+		public Dictionary<string, ClassProperties> Classes {
+			get; internal set;
+		}
+		
+		public Dictionary<string, EnumProperties> Enums {
+			get; internal set;
+		}
+		
+		public Dictionary<string, StructProperties> Structs {
+			get; internal set;
+		}
+		
+		public Dictionary<string, DelegateProperties> Delegates {
+			get; internal set;
+		}
+		
+		public Dictionary<string, InterfaceProperties> Interfaces {
+			get; internal set;
+		}
+		
+		public string FullName {
+			get; private set;
+		}
+		
+		public int CyclometricComplexity {
+			get; private set;
+		}
+		
+		public int ClassCoupling {
+			get; private set;
+		}
+		
+		public ulong LOCReal {
+			get; internal set;
+		}
+		
+		public ulong LOCComments {
+			get; internal set;
+		}
+		
+		public int NumberOfTypes {
+			get; private set;
+		}
+		
+		public int FieldCount {
+			get; private set;
+		}
+		
+		public int MethodCount {
+			get; private set;
+		}
+		
+		public int StartLine {
+			get; private set;
+		}
+		
+		public int EndLine {
+			get; private set;
+		}
+		
+		//TODO Need to implement these
+		public int EfferentCoupling {
+			get; private set;
+		}
+		
+		public int AfferentCoupling {
+			get; private set;
+		}
+		
+		public string FilePath {
+			get; set;
+		}
+		
+		public NamespaceProperties(string name)
+		{
+			Classes = new Dictionary<string, ClassProperties>();
+			Interfaces = new Dictionary<string, InterfaceProperties>();
+			Structs = new Dictionary<string, StructProperties>();
+			Delegates = new Dictionary<string, DelegateProperties>();
+			Enums = new Dictionary<string, EnumProperties>();
+			
+			FullName = name;
+			CyclometricComplexity = 0;
+			ClassCoupling = 0;
+			LOCReal = 0;
+			LOCComments = 0;
+			NumberOfTypes = 0;
+			MethodCount = 0;
+			FieldCount = 0;
+			EfferentCoupling = 0;
+			AfferentCoupling = 0;
+			FilePath="";
+		}
+		
+		internal void AddInstance (IType type)
+		{
+			// Do not include classes that have somehow already been included
+			StringBuilder key = new StringBuilder("");
+			key.Append(type.FullName);
+			
+			foreach(var typeArg in type.TypeParameters) {
+				foreach(var constraint in typeArg.Constraints) {
+					key.Append(" " + constraint.Name);
+				}
+			}
+	
+			switch(type.ClassType)
+			{
+			case ClassType.Class:
+				AddClass(type, key);
+				break;
+			case ClassType.Delegate:
+				AddDelegate(type, key);
+				break;
+			case ClassType.Enum:
+				AddEnum(type, key);
+				break;
+			case ClassType.Interface:
+				AddInterface(type, key);
+				break;
+			case ClassType.Struct:
+				AddStruct(type, key);
+				break;
+			case ClassType.Unknown:
+				break;
+			}
+		}
+		
+		private void AddClass (IType cls, StringBuilder key)
+		{
+			lock(Classes)
+			{
+				foreach(var typeArg in cls.TypeParameters) {
+					foreach(var constraint in typeArg.Constraints) {
+						key.Append(constraint.Name);
+					}
+				}
+				if(Classes.ContainsKey(key.ToString()))
+					return;
+				Classes.Add(key.ToString(), new ClassProperties(cls));
+			}	
+		}
+		
+		private void AddStruct (IType strct, StringBuilder key)
+		{
+			lock(Structs)
+			{
+				foreach(var typeArg in strct.TypeParameters) {
+					foreach(var constraint in typeArg.Constraints) {
+						key.Append(constraint.Name);
+					}
+				}
+				if(Structs.ContainsKey(key.ToString()))
+					return;
+				Structs.Add(key.ToString(), new StructProperties(strct));
+			}
+		}
+		
+		private void AddInterface (IType interfce, StringBuilder key)
+		{
+			lock(Interfaces)
+			{
+				foreach(var typeArg in interfce.TypeParameters) {
+					foreach(var constraint in typeArg.Constraints) {
+						key.Append(constraint.Name);
+					}
+				}
+				if(Interfaces.ContainsKey(key.ToString()))
+					return;
+				Interfaces.Add(key.ToString(), new InterfaceProperties(interfce));
+			}
+		}
+		
+		private void AddEnum (IType enm, StringBuilder key)
+		{
+			lock(Enums)
+			{
+				foreach(var typeArg in enm.TypeParameters) {
+					foreach(var constraint in typeArg.Constraints) {
+						key.Append(constraint.Name);
+					}
+				}
+				if(Enums.ContainsKey(key.ToString()))
+					return;
+				Enums.Add(key.ToString(), new EnumProperties(enm));
+			}
+		}
+		
+		private void AddDelegate (IType dlgte, StringBuilder key)
+		{
+			lock(Delegates)
+			{
+				foreach(var typeArg in dlgte.TypeParameters) {
+					foreach(var constraint in typeArg.Constraints) {
+						key.Append(constraint.Name);
+					}
+				}
+				if(Delegates.ContainsKey(key.ToString()))
+					return;
+				Delegates.Add(key.ToString(), new DelegateProperties(dlgte));
+			}
+		}
+		
+		internal void ProcessClasses()
+		{
+			foreach(var cls in this.Classes)
+			{
+				cls.Value.ProcessInnerClasses();
+				this.CyclometricComplexity += cls.Value.CyclometricComplexity;
+				this.ClassCoupling += cls.Value.ClassCoupling;
+				this.LOCReal += cls.Value.LOCReal;
+				this.LOCComments += cls.Value.LOCComments;
+				this.FieldCount += cls.Value.FieldCount;
+				this.MethodCount += cls.Value.MethodCount;
+				this.NumberOfTypes++;
+			}
+		}
+		
+	}
+}
+
+			
Index: MonoDevelop.CodeMetrics/InheritanceTree.cs
===================================================================
--- MonoDevelop.CodeMetrics/InheritanceTree.cs	(revision 0)
+++ MonoDevelop.CodeMetrics/InheritanceTree.cs	(revision 0)
@@ -0,0 +1,58 @@
+// 
+// InheritanceTree.cs
+//  
+// Author:
+//       Nikhil Sarda <diff.operator@gmail.com>
+// 
+// Copyright (c) 2009 Nikhil Sarda
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Threading;
+
+using MonoDevelop.Projects.Dom;
+
+namespace MonoDevelop.CodeMetrics
+{
+
+	public partial class ObjectOrientedMetrics
+	{
+		private static void ClassEvaluateInheritanceTree (MetricsContext ctx, ClassProperties cls)
+		{
+			foreach (IType ob in cls.Class.SourceProjectDom.GetInheritanceTree (cls.Class)) {
+				if (ob.ClassType == MonoDevelop.Projects.Dom.ClassType.Class && ob != cls.Class && ob.Name!="Object") {
+					cls.DepthOfInheritance++;
+					ClassProperties tmp = ctx.GetInstanceOf (ob);
+					// lock tmp here
+					if(tmp != null) {
+						tmp.FanOut++;
+						cls.InheritedFieldCount += tmp.FieldCount;
+						cls.InheritedMethodCount += tmp.MethodCount;
+						if (ob.IsAbstract)
+							cls.DataAbstractionCoupling++;
+					}
+				}
+			foreach (var innercls in cls.InnerClasses) {
+				ClassEvaluateInheritanceTree (ctx, innercls.Value);
+				}
+			}
+		}
+	}
+}
Index: gtk-gui/objects.xml
===================================================================
--- gtk-gui/objects.xml	(revision 153925)
+++ gtk-gui/objects.xml	(working copy)
@@ -1,6 +1,2 @@
 <objects attr-sync="on">
-  <object type="MonoDevelop.CodeMetrics.CodeMetricsWidget" palette-category="MonoDevelop.CodeMetrics" allow-children="false" base-type="Gtk.Bin">
-    <itemgroups />
-    <signals />
-  </object>
 </objects>
\ No newline at end of file
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 153925)
+++ Makefile.am	(working copy)
@@ -12,6 +12,7 @@
 	$(GLIB_SHARP_LIBS) \
 	$(GTK_SHARP_LIBS) \
 	$(MONO_ADDINS_LIBS) \
+	-pkg:monodevelop \
 	-r:Mono.Posix \
 	-r:System \
 	-r:System.Data \
@@ -23,10 +24,30 @@
 	AssemblyInfo.cs \
 	gtk-gui/generated.cs \
 	gtk-gui/MonoDevelop.CodeMetrics.CodeMetricsWidget.cs \
+	MonoDevelop.CodeMetrics/AssociationBetweenClasses.cs \
+	MonoDevelop.CodeMetrics/ASTVisitor.cs \
+	MonoDevelop.CodeMetrics/ClassProperties.cs \
 	MonoDevelop.CodeMetrics/CodeMetricsNodeExtension.cs \
+	MonoDevelop.CodeMetrics/CodeMetricsServices.cs \
 	MonoDevelop.CodeMetrics/CodeMetricsView.cs \
 	MonoDevelop.CodeMetrics/CodeMetricsWidget.cs \
-	MonoDevelop.CodeMetrics/Commands.cs
+	MonoDevelop.CodeMetrics/Cohesion.cs \
+	MonoDevelop.CodeMetrics/Commands.cs \
+	MonoDevelop.CodeMetrics/ComplexityMetrics.cs \
+	MonoDevelop.CodeMetrics/Coupling.cs \
+	MonoDevelop.CodeMetrics/DelegateProperties.cs \
+	MonoDevelop.CodeMetrics/EnumProperties.cs \
+	MonoDevelop.CodeMetrics/FieldProperties.cs \
+	MonoDevelop.CodeMetrics/InheritanceTree.cs \
+	MonoDevelop.CodeMetrics/InterfaceProperties.cs \
+	MonoDevelop.CodeMetrics/IProperties.cs \
+	MonoDevelop.CodeMetrics/LOCEvaluate.cs \
+	MonoDevelop.CodeMetrics/MethodProperties.cs \
+	MonoDevelop.CodeMetrics/MetricsContext.cs \
+	MonoDevelop.CodeMetrics/NamespaceProperties.cs \
+	MonoDevelop.CodeMetrics/ObjectOrientedMetrics.cs \
+	MonoDevelop.CodeMetrics/ProjectProperties.cs \
+	MonoDevelop.CodeMetrics/StructProperties.cs
 
 RES =  \
 	gtk-gui/gui.stetic \