Index: AUTHORS
===================================================================
--- AUTHORS	(revision 62361)
+++ AUTHORS	(working copy)
@@ -27,6 +27,7 @@
 Jacob Ils√∏ Christensen
 Scott Ellington
 Michael Hutchinson
+James Fitzsimons
 
 and Mike Krueger and the SharpDevelop team
 
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 62361)
+++ ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2006-07-08 James Fitzsimons <james.fitzsimons@gmail.com>
+	
+	* AUTHORS: Added my name.
+
 2006-07-03 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* monodevelop.in: Added yet another way of finding the
 	
Index: Extras/MonoDevelop.SourceEditor/MonoDevelop.SourceEditor.Gui/SourceEditorDisplayBinding.cs
===================================================================
--- Extras/MonoDevelop.SourceEditor/MonoDevelop.SourceEditor.Gui/SourceEditorDisplayBinding.cs	(revision 62361)
+++ Extras/MonoDevelop.SourceEditor/MonoDevelop.SourceEditor.Gui/SourceEditorDisplayBinding.cs	(working copy)
@@ -1,6 +1,9 @@
 using System;
+using System.Collections;
+using System.Collections.Specialized;
 using System.IO;
 using System.Runtime.InteropServices;
+using System.Text;
 
 using MonoDevelop.Core.Execution;
 using MonoDevelop.Core.Gui;
@@ -17,6 +20,7 @@
 using MonoDevelop.Ide.Codons;
 using MonoDevelop.SourceEditor.Document;
 using MonoDevelop.Projects.Text;
+using MonoDevelop.Projects.Parser;
 
 using Gtk;
 using GtkSourceView;
@@ -53,6 +57,8 @@
 				return true;
 			if (mimetype == "application/x-aspx")
 				return true;
+			if (mimetype == "application/x-ascx")
+				return true;
 
 			// If gedit can open the file, this editor also can do it
 			foreach (DesktopApplication app in DesktopApplication.GetApplications (mimetype))
@@ -87,10 +93,19 @@
 		IDocumentInformation
 	{
 		VBox mainBox;
-		HBox editorBar;
+		VBox editorBar;
 		HBox reloadBar;
+		HBox classBrowser;
+		Gtk.ComboBox classCombo;
+		Gtk.ComboBox membersCombo;
+		ListStore classStore;
+		ListStore memberStore;
+		HybridDictionary classes;
+		HybridDictionary members;
+		bool classBrowserVisible = true;
 		internal FileSystemWatcher fsw;
 		IProperties properties;
+		IParseInformation memberParseInfo;
 		
 		BreakpointEventHandler breakpointAddedHandler;
 		BreakpointEventHandler breakpointRemovedHandler;
@@ -157,11 +172,60 @@
 			}
 		}
 		
+		public bool ClassBrowserVisible {
+			get {
+				return classBrowserVisible;
+			}
+			set {
+				if (value && !classBrowserVisible)
+					editorBar.PackStart(classBrowser, true, true, 3);
+				if (!value && classBrowserVisible)
+					editorBar.Remove(classBrowser);
+				classBrowserVisible = value;
+			}
+		}
+		
 		public SourceEditorDisplayBindingWrapper ()
-		{
+		{			
 			mainBox = new VBox ();
-			editorBar = new HBox ();
-			mainBox.PackStart (editorBar, false, false, 0);
+			editorBar = new VBox ();
+			mainBox.PackStart (editorBar, false, true, 0);
+			
+			classBrowser = new HBox(true, 2);
+			classCombo = new Gtk.ComboBox(); 
+			membersCombo = new Gtk.ComboBox();	
+			
+			classes = new HybridDictionary();
+			members = new HybridDictionary();	
+			
+			// Setup the columns and column renders for the comboboxes
+			CellRendererPixbuf pixr = new CellRendererPixbuf();
+			classCombo.PackStart(pixr, false);
+			classCombo.AddAttribute(pixr, "pixbuf", 0);
+			CellRenderer colr = new CellRendererText();
+			classCombo.PackStart(colr, true);
+			classCombo.AddAttribute(colr, "text", 1);
+			
+			pixr = new CellRendererPixbuf();
+			membersCombo.PackStart(pixr, false);
+			membersCombo.AddAttribute(pixr, "pixbuf", 0);
+			colr = new CellRendererText();
+			membersCombo.PackStart(colr, true);
+			membersCombo.AddAttribute(colr, "text", 1);
+			
+			// Pack the controls into the editorbar just below the file name tabs.
+			classBrowser.PackStart(classCombo, true, true, 0);
+			classBrowser.PackStart(membersCombo, true, true, 0);
+			editorBar.PackStart(classBrowser, false, true, 1);
+			
+			// Set up the data stores for the comboboxes
+			classStore = new ListStore(typeof(Gdk.Pixbuf), typeof(string));
+			classCombo.Model = classStore;	
+			memberStore = new ListStore(typeof(Gdk.Pixbuf), typeof(string));
+			membersCombo.Model = memberStore;
+ 
+			IdeApp.ProjectOperations.ParserDatabase.ParseInformationChanged += new MonoDevelop.Projects.Parser.ParseInformationEventHandler(UpdateClassBrowser); 
+			
 			se = new SourceEditor (this);
 			se.Buffer.ModifiedChanged += new EventHandler (OnModifiedChanged);
 			se.Buffer.MarkSet += new MarkSetHandler (OnMarkSet);
@@ -303,8 +367,166 @@
 					
 				UpdateExecutionLocation ();
 			}
+			
+			IFileParserContext context = IdeApp.ProjectOperations.ParserDatabase.GetFileParserContext(fileName);
+			memberParseInfo = context.ParseFile(fileName);
+			BindClassCombo();
 		}
 		
+		private void UpdateClassBrowser(object sender, ParseInformationEventArgs args)
+		{
+			// This event handler can get called when files other than the current content are updated. eg.
+			// when loading a new document. If we didn't do this check the member combo for this tab would have
+			// methods for a different class in it!
+			if (ContentName == args.FileName) {
+				memberParseInfo = args.ParseInformation;
+				GLib.Timeout.Add (1000, new GLib.TimeoutHandler (BindClassCombo));
+			}
+		}
+		
+		private bool BindClassCombo()
+		{	
+			classCombo.Changed -= new EventHandler (ClassChanged);
+			// Clear down all our local stores.
+			classStore.Clear();				
+			classes.Clear();
+			
+			// check the IParseInformation member variable to see if we could get ParseInformation for the 
+			// current docuement. If not we can't display class and member info so hide the browser bar.
+			if (memberParseInfo == null) {
+				ClassBrowserVisible = false;
+				return false;
+			}
+			
+			if (!ClassBrowserVisible)
+				ClassBrowserVisible = true;
+				
+			ClassCollection cls = ((ICompilationUnit)memberParseInfo.BestCompilationUnit).Classes;
+			foreach (IClass c in cls) {
+				// Add the IClass object to our hashmap so we can look it up later.
+				classes.Add(c.Name, c);
+				
+				// Get the appropriate icon from the Icon service for the current IClass.
+				Gdk.Pixbuf pix = IdeApp.Services.Resources.GetIcon (IdeApp.Services.Icons.GetIcon (c));
+				classStore.AppendValues (pix, c.Name);
+			}
+			classCombo.Active = 0;
+			classCombo.Changed += new EventHandler (ClassChanged);
+			
+			if (cls.Count > 0)
+				BindMemberCombo(cls [0]);
+
+			// return false to stop the GLib.Timeout
+			return false;
+		}
+		
+		
+		private void BindMemberCombo(IClass c)
+		{
+			membersCombo.Changed -= new EventHandler (MemberChanged);
+			// Clear down all our local stores.
+			memberStore.Clear();
+			members.Clear();
+				
+			HybridDictionary methodMap = new HybridDictionary();
+			members.Add(c.Name, methodMap);
+			
+			Gdk.Pixbuf pix;
+			// Add items to the member drop down 
+			MethodCollection sortedMethods = c.Methods;
+			ArrayList.Adapter (sortedMethods).Sort (new CaseInsensitiveComparer ());
+			
+			foreach (IMethod method in sortedMethods) {
+				pix = IdeApp.Services.Resources.GetIcon(IdeApp.Services.Icons.GetIcon(method)); 
+				// For methods we append their parameter types too. This is a nice feature,
+				// and it is also necessay to avoid problems with overloaded methods having
+				// the same name
+				StringBuilder methodName = new StringBuilder();
+				methodName.Append(method.Name + "(");
+				for (int i = 0; i < method.Parameters.Count; i++) {
+					methodName.Append(method.Parameters [i].ReturnType.Name);
+					if (i < method.Parameters.Count - 1) methodName.Append (", ");
+				}
+				methodName.Append(")"); 
+				
+				memberStore.AppendValues(pix, methodName.ToString ());
+				methodMap.Add(methodName.ToString (), method); 
+			}
+			foreach (IProperty property in c.Properties) {
+				pix = IdeApp.Services.Resources.GetIcon (IdeApp.Services.Icons.GetIcon (property));
+				if (methodMap [property.Name] != null) {
+					// The unlikely case that two properties have the same name has occured.
+					// We use the fully qualified name for each subsequent property to avoid
+					// problems.
+					memberStore.AppendValues (pix, property.FullyQualifiedName);
+					methodMap.Add (property.FullyQualifiedName, property);
+				}
+				else {
+					memberStore.AppendValues (pix, property.Name);
+					methodMap.Add (property.Name, property);
+				}
+			}
+			foreach(IField member in c.Fields) {
+				pix = IdeApp.Services.Resources.GetIcon (IdeApp.Services.Icons.GetIcon (member));
+				memberStore.AppendValues (pix, member.Name);
+				methodMap.Add (member.Name, member);				
+			}
+			
+			membersCombo.Active = 0;
+			membersCombo.Changed += new EventHandler (MemberChanged);
+		}
+		
+		
+		private void MemberChanged(object sender, EventArgs e)
+		{
+			Gtk.TreeIter iter;
+			if (classCombo.GetActiveIter (out iter)) {
+				// Get the name of the current class from the class combobox
+				string className = classStore.GetValue (iter, 1).ToString ();
+			    if (membersCombo.GetActiveIter (out iter)) {	    
+				    	// Find the IMember object in our hashmap by name from the member combo
+				    	IMember member = ((HybridDictionary)members [className]) [memberStore.GetValue (iter, 1)] as IMember;
+					int line = member.Region.BeginLine;
+					
+					// Get a handle to the current document
+					if (IdeApp.Workbench.ActiveDocument == null) {
+						return;
+					}
+				
+					// If we can we navigate to the line location of the IMember.
+					IViewContent content = (IViewContent) IdeApp.Workbench.ActiveDocument.Content;
+					if (content is IPositionable) {
+						((IPositionable)content).JumpTo (Math.Max (1, line), 1);
+					}
+			    }
+		    }
+		}
+
+		
+		private void ClassChanged(object sender, EventArgs e)
+		{
+			Gtk.TreeIter iter;
+			if (classCombo.GetActiveIter(out iter)) 	{
+				string className = (string)classStore.GetValue(iter, 1);
+				IClass selectedClass = classes[className] as IClass;
+				int line = selectedClass.Region.BeginLine;
+				
+				// Get a handle to the current document
+				if (IdeApp.Workbench.ActiveDocument == null) {
+					Console.WriteLine("Active document is null while looking for class {0}", className);
+					return;
+				}
+				
+				// If we can we navigate to the line location of the IMember.
+				IViewContent content = (IViewContent)IdeApp.Workbench.ActiveDocument.Content;
+				if (content is IPositionable) {
+					((IPositionable)content).JumpTo (Math.Max (1, line), 1);
+				}
+				
+				BindMemberCombo(selectedClass);
+			}
+		}
+		
 		void OnBreakpointAdded (object sender, BreakpointEventArgs args)
 		{
 			if (args.Breakpoint.FileName == ContentName)
@@ -363,7 +585,7 @@
 				reloadBar.ShowAll ();
 			}
 			warnOverwrite = true;
-			editorBar.PackStart (reloadBar);
+			editorBar.PackStart (reloadBar, false, true, 1);
 			reloadBar.ShowAll ();
 			WorkbenchWindow.ShowNotification = true;
 		}
Index: Extras/MonoDevelop.SourceEditor/ChangeLog
===================================================================
--- Extras/MonoDevelop.SourceEditor/ChangeLog	(revision 62361)
+++ Extras/MonoDevelop.SourceEditor/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2006-07-08 James Fitzsimons <james.fitzsimons@gmail.com>
+
+	* MonoDevelop.SourceEditor.Gui/SourceEditorDisplayBinding.cs Added class and method browser combos. Added ascx to list in CanCreateContentForMimeType().
+
 2006-07-03 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* MonoDevelop.SourceEditor.addin.xml: Updated versions.
