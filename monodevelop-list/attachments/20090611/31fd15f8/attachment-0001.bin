// DataViewStore.cs
//
//  Copyright (C) 2008 Christian Hoff
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 

namespace Bestandsverwaltung.DataWidgets.DataTable
{
	public class DataViewStore : GLib.Object, Gtk.TreeModelImplementor, Gtk.TreeSortableImplementor
	{
		readonly System.Threading.Thread GtkThread;
		public event System.EventHandler Reset;
		
		public DataViewStore (System.Data.DataView DataView)
		{
			if (DataView == null)
				throw (new System.ArgumentNullException ("DataView"));
			
			_dataView = DataView;
			_dataView.ListChanged += this.DataView_ListChanged;
			
			// Create a random stamp for the iters
			System.Random RandomStampGen = new System.Random ();
			this.Stamp = RandomStampGen.Next (int.MinValue, int.MaxValue);
			
			_adapter = new Gtk.TreeModelAdapter (this);
			// Assume that this ctor is invoked from the Gtk+ thread
			GtkThread = System.Threading.Thread.CurrentThread;
			
			System.Console.WriteLine ("Properties of first element: ");
			foreach (System.ComponentModel.PropertyDescriptor descriptor in (_dataView [0] as System.ComponentModel.ICustomTypeDescriptor).GetProperties ()) {
				System.Console.WriteLine ("{0}: {1}", descriptor.Name, descriptor.GetValue (_dataView [0]).ToString ());
			}
			
		}
		
		// Properties
		
		public readonly int Stamp;
		
		private System.Data.DataView _dataView;
		public System.Data.DataView DataView
		{
			get {
				return _dataView;
			}
		}
		
		private Gtk.TreeModelAdapter _adapter;
		public Gtk.TreeModelAdapter Adapter
		{
			get {
				return _adapter;
			}
		}
		
		public Gtk.TreeModelFlags Flags
		{
			get {
				// Iters(DataRowViews) do not remain valid after the model was modified
				return Gtk.TreeModelFlags.ListOnly;
			}
		}
		
		public int NColumns
		{
			get {
				return _dataView.Table.Columns.Count;
			}
		}
		
		
		// Methods
		
#region Gtk.TreeIter handling
		private System.Collections.Generic.List<System.Runtime.InteropServices.GCHandle> _rowHandles = new System.Collections.Generic.List<System.Runtime.InteropServices.GCHandle> ();
		
		public override void Dispose ()
		{
			// Free all the GCHandles pointing to the iters since they won't be garbage collected
			 foreach (System.Runtime.InteropServices.GCHandle handle in _rowHandles)
				handle.Free ();
			
			_dataView.ListChanged -= DataView_ListChanged;
			
			base.Dispose ();
		}
		
		public Gtk.TreeIter IterFromRow (System.Data.DataRowView row)
		{
			Gtk.TreeIter result = Gtk.TreeIter.Zero;
			IterFromRow (row, ref result);
			
			return result;
		}
		
		private void IterFromRow (System.Data.DataRowView row, ref Gtk.TreeIter iter)
		{
			System.Runtime.InteropServices.GCHandle gch = System.Runtime.InteropServices.GCHandle.Alloc (row);
			
			iter.UserData = (System.IntPtr) gch;
			iter.Stamp = this.Stamp;
			
			_rowHandles.Add (gch);
		}
		
		public System.Data.DataRowView RowFromIter (Gtk.TreeIter iter)
		{
			if (iter.Stamp != this.Stamp)
				throw (new System.InvalidOperationException (System.String.Format ("iter belongs to a different model; it's stamp is not equal to the stamp of this model({0})", this.Stamp.ToString ())));
			
			if (iter.UserData == System.IntPtr.Zero)
				throw (new System.InvalidOperationException ("iter does not contain any row information"));
			
			System.Runtime.InteropServices.GCHandle gch = (System.Runtime.InteropServices.GCHandle) iter.UserData;
			return gch.Target as System.Data.DataRowView;
		}

		public void DeleteIters (Gtk.TreeIter[] iters)
		{
			System.Collections.Generic.List<int> IterIndices = new System.Collections.Generic.List<int> (iters.GetLength (0));
			for (int IterIndex = 0; IterIndex < iters.GetLength (0); IterIndex++)
				IterIndices.Add (IndexFromRow (RowFromIter (iters [IterIndex])));
			
			IterIndices.Sort ();
			// Delete from the end to the beginning to keep our indices valid
			for (int IterIndex = IterIndices.Count - 1; IterIndex >= 0; IterIndex--)
				_dataView.Delete (IterIndices [IterIndex]);
		}
#endregion
		
#region TreePath handling
		public Gtk.TreePath GetPath (Gtk.TreeIter iter)
		{
			return PathFromRow (RowFromIter (iter));
		}
		
		public Gtk.TreePath PathFromRow (System.Data.DataRowView row)
		{
			int index = IndexFromRow (row);
			if (index == -1)
				return null;
			
			Gtk.TreePath path = new Gtk.TreePath ();
			path.AppendIndex (index);
			
			return path;
		}

		public System.Data.DataRowView RowFromPath (Gtk.TreePath path)
		{
			if (path.Depth != 1) throw (new System.InvalidOperationException ("This is a list-only model; your path has a depth not equal to 1"));

			return RowFromIndex (path.Indices [0]);
		}
		
		public int IndexFromRow (System.Data.DataRowView row)
		{
			return (_dataView as System.Collections.IList).IndexOf (row);
		}

		public System.Data.DataRowView RowFromIndex (int RowIndex)
		{
			return _dataView [RowIndex];
		}
		
		public bool GetIter (out Gtk.TreeIter iter, Gtk.TreePath path)
		{
			iter = Gtk.TreeIter.Zero;
			
			if (path.Indices.Length != 1)
				return false;
			
			int index = path.Indices [0];
			if (index >= _dataView.Count)
				return false;
			
			IterFromRow (_dataView [index], ref iter);
			return true;
		}
#endregion
		
#region get/set model data
		/* NOTE: Do not use this method from managed code. The reconversion into a System.type will fail for any non-primitive data types
		*  Use GetColumnSystemType instead
		*/
		public GLib.GType GetColumnType (int column)
		{
			return (GLib.GType) GetColumnSystemType (column);
		}
		
		public System.Type GetColumnSystemType (int ColumnIndex)
		{
			System.Data.DataColumn column = _dataView.Table.Columns [ColumnIndex];
			if (column.DataType.IsValueType && column.AllowDBNull)
				return typeof (System.Nullable<>).MakeGenericType (column.DataType);
			else
				return column.DataType;
		}
		
		public void GetValue (Gtk.TreeIter iter, int column, ref GLib.Value val)
		{
			val.Init (GetColumnType (column));
			val.Val = GetValue (iter, column);
		}
		
		public object GetValue (Gtk.TreeIter iter, int column)
		{
			object DbColumnValue = RowFromIter (iter) [column];
			return (DbColumnValue == System.DBNull.Value) ? null : DbColumnValue;
		}
		
		public void SetValue (Gtk.TreeIter iter, int column, object val)
		{
			RowFromIter (iter) [column] = (val == null) ? System.DBNull.Value : val;
		}
#endregion
		
		public bool GetIterFirst (out Gtk.TreeIter iter)
		{
			if (_dataView.Count == 0) {
				iter = Gtk.TreeIter.Zero;
				return false;
			} else {
				iter = IterFromRow (_dataView [0]);
				return true;
			}
		}
		
		public bool IterNext (ref Gtk.TreeIter iter)
		{
			int NewIndex = IndexFromRow (RowFromIter (iter)) + 1;
			if (NewIndex >= _dataView.Count)
				return false;
			
			IterFromRow (_dataView [NewIndex], ref iter);
			return true;
		}
		
		public int IterNChildren (Gtk.TreeIter iter)
		{
			// List-only model
			if (iter.UserData == System.IntPtr.Zero)
				return _dataView.Count;
			else
				return 0;
		}
		
		public bool IterHasChild (Gtk.TreeIter iter)
		{
			return IterNChildren (iter) != 0;
		}
		
		public bool IterNthChild (out Gtk.TreeIter child, Gtk.TreeIter parent, int index)
		{
			if (parent.UserData == System.IntPtr.Zero) {
				child = IterFromRow (_dataView [index]);
				return true;
			} else {
				// List-only model
				child = Gtk.TreeIter.Zero;
				return false;
			}
		}
		
		// child: first child iter of parent
		public bool IterChildren (out Gtk.TreeIter child, Gtk.TreeIter parent)
		{
			if (parent.UserData == System.IntPtr.Zero)
				return GetIterFirst (out child);
			
			child = Gtk.TreeIter.Zero;
			return false;
		}
		
		public bool IterParent (out Gtk.TreeIter parent, Gtk.TreeIter child)
		{
			// List-only model
			parent = Gtk.TreeIter.Zero;
			return false;
		}
		
		public void RefNode (Gtk.TreeIter iter)
		{
		}
		
		public void UnrefNode (Gtk.TreeIter iter)
		{
		}
		
		// Event handling

		private void DataView_ListChanged (object sender, System.ComponentModel.ListChangedEventArgs args)
		{
			if (args.ListChangedType != System.ComponentModel.ListChangedType.Reset && args.NewIndex == -1 && args.OldIndex == -1)
				return;
			
			bool lockGtk = GtkThread != System.Threading.Thread.CurrentThread;
			if (lockGtk)
				Gdk.Threads.Enter ();
			System.Console.WriteLine ("Threadsafe, command: {0}, NewIndex: {1}, OldIndex: {2}", args.ListChangedType, args.NewIndex, args.OldIndex);
			switch (args.ListChangedType) {
			case System.ComponentModel.ListChangedType.ItemAdded:
				_adapter.EmitRowInserted (new Gtk.TreePath (new int [1] {args.NewIndex}), IterFromRow (_dataView [args.NewIndex]));
				break;
			case System.ComponentModel.ListChangedType.ItemDeleted:
				// System.Console.WriteLine ("Item deleted, old index: {0}, new index: {1}", e.OldIndex, e.NewIndex);
				_adapter.EmitRowDeleted (new Gtk.TreePath (new int [1] {args.NewIndex}));
				break;
			case System.ComponentModel.ListChangedType.ItemChanged:
				_adapter.EmitRowChanged (new Gtk.TreePath (new int [1] {args.NewIndex}), IterFromRow (_dataView [args.NewIndex]));
				break;
			case System.ComponentModel.ListChangedType.ItemMoved:
				// Index: New position
				// Value: Old position
				int[] NewRowOrder = new int [_dataView.Count];
				for (int ChildIndex = 0; ChildIndex < _dataView.Count; ChildIndex++) {
					if (ChildIndex == args.OldIndex)
						NewRowOrder [ChildIndex] = args.NewIndex;
					else if (ChildIndex == args.NewIndex)
						NewRowOrder [ChildIndex] = args.OldIndex;
					else
						NewRowOrder [ChildIndex] = ChildIndex;
				}
				_adapter.EmitRowsReordered (null, Gtk.TreeIter.Zero, NewRowOrder);
				break;
			case System.ComponentModel.ListChangedType.Reset:
				if (this.Reset != null)
					this.Reset (this, new System.EventArgs ());
				else
                	System.Console.WriteLine ("WARNING: Reset command on DataView cannot be handled!");
                break;
			}
			if (lockGtk)
				Gdk.Threads.Leave ();
		}
		
#region TreeSortable implementation
		bool Gtk.TreeSortableImplementor.HasDefaultSortFunc { get { return true; } }
		Gtk.TreeIterCompareFunc Gtk.TreeSortableImplementor.DefaultSortFunc { set { throw new System.NotSupportedException (); } }
		void Gtk.TreeSortableImplementor.SetSortFunc (int col_idx, Gtk.TreeIterCompareFunc func) {
			throw new System.NotSupportedException ();
		}
		
		public void SetSortColumnId (int sort_column_id, Gtk.SortType order) {
			_dataView.Sort = _dataView.Table.Columns [sort_column_id].ColumnName + " " + (order == Gtk.SortType.Ascending ? "ASC" : "DESC");
		}
		
		public bool GetSortColumnId (out int sort_column_id, out Gtk.SortType order) {
			if (_dataView.Sort == "") {
				sort_column_id = -1;
				order = Gtk.SortType.Ascending;
				return false;
			}
			int seperator = _dataView.Sort.LastIndexOf (' ');
			string sort_column = _dataView.Sort.Substring (0, seperator);
			string sort_order = _dataView.Sort.Substring (seperator + 1);
			
			sort_column_id = _dataView.Table.Columns.IndexOf (sort_column);
			switch (sort_order) {
			case "ASC":
				order = Gtk.SortType.Ascending;
				break;
			case "DESC":
				order = Gtk.SortType.Descending;
				break;
			default:
				throw new System.FormatException (string.Format ("Sort order of data view could not be parsed (Sort property of DataView = {0})", _dataView.Sort));
			}
			return true;
		}
#endregion
	}
}