Index: ChangeLog
===================================================================
--- ChangeLog	(revision 64667)
+++ ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2006-08-31 Levi Bard  <taktaktaktaktaktaktaktaktaktak@gmail.com>
+
+	* *: Fixes for win32 support.
+
 2006-08-23 Scott Ellington  <scott.ellington@gmail.com>
 
 	* monodevelop.xml: permit mds and mdp files to be opened from desktop
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects/ProjectService.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects/ProjectService.cs	(revision 64667)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects/ProjectService.cs	(working copy)
@@ -114,6 +114,9 @@
 		{
 			if (filename.StartsWith ("file://"))
 				filename = filename.Substring (7);
+
+			if (filename.StartsWith("/") && SystemPackage.IsWin32)
+				filename = filename.Substring (1);
 				
 			IFileFormat format = formatManager.GetFileFormat (filename);
 			return format != null;
Index: Core/src/MonoDevelop.Projects/ChangeLog
===================================================================
--- Core/src/MonoDevelop.Projects/ChangeLog	(revision 64667)
+++ Core/src/MonoDevelop.Projects/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2006-08-31 Levi Bard  <taktaktaktaktaktaktaktaktaktak@gmail.com>
+
+	* MonoDevelop.Projects/ProjectService.cs: Win32 URI workaround.
+
 2006-08-30 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* MonoDevelop.Projects.Text/TextFile.cs: Workaround a mono bug
Index: Core/src/MonoDevelop.Ide/ChangeLog
===================================================================
--- Core/src/MonoDevelop.Ide/ChangeLog	(revision 64667)
+++ Core/src/MonoDevelop.Ide/ChangeLog	(working copy)
@@ -1,3 +1,10 @@
+2006-08-31 Levi Bard  <taktaktaktaktaktaktaktaktaktak@gmail.com>
+
+	* MonoDevelop.Ide.Gui/ProjectOperations.cs: Win32 URI workaround.
+	* MonoDevelop.Ide.Gui/Workbench.cs: Win32 URI workaround.
+	* MonoDevelop.Ide.Gui/IdeStartup.cs: Autoinitialize VFS, TCP IPC fixes.
+	* MonoDevelop.Ide.Gui/DefaultWorkbench.cs: Win32 URI workaround.
+
 2006-08-30 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* MonoDevelop.Ide.Gui.Search/SearchReplaceManager.cs: Fix the build.
Index: Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/ProjectOperations.cs
===================================================================
--- Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/ProjectOperations.cs	(revision 64667)
+++ Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/ProjectOperations.cs	(working copy)
@@ -246,6 +246,8 @@
 
 			if (filename.StartsWith ("file://"))
 				filename = filename.Substring (7);
+			if (filename.StartsWith ("/") && SystemPackage.IsWin32)
+				filename = filename.Substring (1);
 
 			IProgressMonitor monitor = IdeApp.Workbench.ProgressMonitors.GetLoadProgressMonitor ();
 			
Index: Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/Workbench.cs
===================================================================
--- Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/Workbench.cs	(revision 64667)
+++ Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/Workbench.cs	(working copy)
@@ -447,6 +447,10 @@
 	
 				if (fileName.StartsWith ("file://")) {
 					fileName = fileName.Substring (7);
+
+					if (fileName.StartsWith("/") && SystemPackage.IsWin32)
+						fileName = fileName.Substring (1);
+
 					// FIXME: this is lame
 					fileName = fileName.Replace ("%3f", "?");
 					fileName = fileName.Replace ("%3F", "?");
Index: Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/IdeStartup.cs
===================================================================
--- Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/IdeStartup.cs	(revision 64667)
+++ Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/IdeStartup.cs	(working copy)
@@ -61,21 +61,26 @@
 		
 		public int Run (string[] args)
 		{
+			Gnome.Vfs.Vfs.Initialize ();
 			MonoDevelopOptions options = new MonoDevelopOptions ();
 			options.ProcessArgs (args);
 			string[] remainingArgs = options.RemainingArguments;
+			string socket_filename = null;
+			EndPoint ep = null;
 			
-			string socket_filename = "/tmp/md-" + Environment.GetEnvironmentVariable ("USER") + "-socket";
-			listen_socket = new Socket (AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
-			EndPoint ep = new UnixEndPoint (socket_filename);
-			
-			// Connect to existing monodevelop and pass filename(s) and exit
-			if (remainingArgs.Length > 0 && File.Exists (socket_filename)) {
-				try {
-					listen_socket.Connect (ep);
-					listen_socket.Send (Encoding.UTF8.GetBytes (String.Join ("\n", remainingArgs)));
-					return 0;
-				} catch {}
+			if(!options.ipc_tcp){
+				socket_filename = "/tmp/md-" + Environment.GetEnvironmentVariable ("USER") + "-socket";
+				listen_socket = new Socket (AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
+				ep = new UnixEndPoint (socket_filename);
+				
+				// Connect to existing monodevelop and pass filename(s) and exit
+				if (remainingArgs.Length > 0 && File.Exists (socket_filename)) {
+					try {
+						listen_socket.Connect (ep);
+						listen_socket.Send (Encoding.UTF8.GetBytes (String.Join ("\n", remainingArgs)));
+						return 0;
+					} catch {}
+				}
 			}
 			
 			string name    = Assembly.GetEntryAssembly ().GetName ().Name;
@@ -181,18 +186,22 @@
 			
 			// FIXME: we should probably track the last 'selected' one
 			// and do this more cleanly
-			try {
-				listen_socket.Bind (ep);
-				listen_socket.Listen (5);
-				listen_socket.BeginAccept (new AsyncCallback (ListenCallback), listen_socket);
-			} catch {
-				// Socket already in use
+			if (!options.ipc_tcp) {
+				try {
+					listen_socket.Bind (ep);
+					listen_socket.Listen (5);
+					listen_socket.BeginAccept (new AsyncCallback (ListenCallback), listen_socket);
+				} catch {
+					// Socket already in use
+				}
 			}
 
 			IdeApp.Run ();
 
 			// unloading services
-			File.Delete (socket_filename);
+			if (null != socket_filename)
+				File.Delete (socket_filename);
+
 			ServiceManager.UnloadAllServices ();
 			System.Environment.Exit (0);
 			return 0;
Index: Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/DefaultWorkbench.cs
===================================================================
--- Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/DefaultWorkbench.cs	(revision 64667)
+++ Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Gui/DefaultWorkbench.cs	(working copy)
@@ -153,6 +153,10 @@
 				string file = individualFile.Trim ();
 				if (file.StartsWith ("file://")) {
 					file = file.Substring (7);
+					
+					if (file.StartsWith("/") && SystemPackage.IsWin32)
+						file = file.Substring(1);
+
 					try {
 						if (Services.ProjectService.IsCombineEntryFile (file))
 							IdeApp.ProjectOperations.OpenCombine(file);
Index: Core/src/MonoDevelop.Core/MonoDevelop.Core.AddIns/AddInService.cs
===================================================================
--- Core/src/MonoDevelop.Core/MonoDevelop.Core.AddIns/AddInService.cs	(revision 64667)
+++ Core/src/MonoDevelop.Core/MonoDevelop.Core.AddIns/AddInService.cs	(working copy)
@@ -78,7 +78,15 @@
 		
 		string[] GetAddInDirectories (out bool ignoreDefaultPath)
 		{
-			ArrayList addInDirs = System.Configuration.ConfigurationSettings.GetConfig("AddInDirectories") as ArrayList;
+			ArrayList addInDirs = null;
+			
+			try {
+				addInDirs = System.Configuration.ConfigurationSettings.GetConfig ("AddInDirectories") as ArrayList;
+			} catch {
+				ignoreDefaultPath = false;
+				return null;
+			}
+
 			if (addInDirs != null) {
 				int i, count = addInDirs.Count;
 				if (count <= 1) {
Index: Core/src/MonoDevelop.Core/MonoDevelop.Core.Execution/MonoPlatformExecutionHandler.cs
===================================================================
--- Core/src/MonoDevelop.Core/MonoDevelop.Core.Execution/MonoPlatformExecutionHandler.cs	(revision 64667)
+++ Core/src/MonoDevelop.Core/MonoDevelop.Core.Execution/MonoPlatformExecutionHandler.cs	(working copy)
@@ -34,14 +34,8 @@
 	{
 		public override IProcessAsyncOperation Execute (string command, string arguments, string workingDirectory, IConsole console)
 		{
-			string args = string.Format (@"--debug {0} {1}", command.Replace (" ", "\\ "), arguments);
-			
-			if (console is ExternalConsole)
-				return base.Execute ("mono", args, workingDirectory, console);
-			else
-				// The use of 'sh' is a workaround. Looks like there is a bug
-				// in mono, Process can't start a "mono" process.
-				return base.Execute ("sh", string.Format ("-c \"mono {0}\"", args), workingDirectory, console);
+			string args = string.Format ("--debug \"{0}\" {1}", command, arguments);
+			return base.Execute ("mono", args, workingDirectory, console);
 		}
 	}
 }
Index: Core/src/MonoDevelop.Core/MonoDevelop.Core.Execution/ProcessService.cs
===================================================================
--- Core/src/MonoDevelop.Core/MonoDevelop.Core.Execution/ProcessService.cs	(revision 64667)
+++ Core/src/MonoDevelop.Core/MonoDevelop.Core.Execution/ProcessService.cs	(working copy)
@@ -23,6 +23,9 @@
 		
 		public override void InitializeService ()
 		{
+			if(SystemPackage.IsWin32){ 
+				remotingChannel = "tcp";
+			}
 		}
 		
 		public ProcessWrapper StartProcess (string command, string arguments, string workingDirectory, EventHandler exited) 
Index: Core/src/MonoDevelop.Core/ChangeLog
===================================================================
--- Core/src/MonoDevelop.Core/ChangeLog	(revision 64667)
+++ Core/src/MonoDevelop.Core/ChangeLog	(working copy)
@@ -1,3 +1,12 @@
+2006-08-31 Levi Bard  <taktaktaktaktaktaktaktaktaktak@gmail.com>
+
+	* MonoDevelop.Core.AddIns/AddInService.cs: Added robustness for addin dir detection failure.
+	* MonoDevelop.Core.Execution/MonoPlatformExecutionHandler.cs: Removed /bin/sh dependence.
+	* MonoDevelop.Core.Execution/ProcessService.cs: Default to TCP IPC on win32.
+	* MonoDevelop.Core/SystemPackage.cs: Added property to check for win32 systems.
+	* MonoDevelop.Core/SystemAssemblyService.cs: Pathing and environment variable compatibility fixes.
+	* MonoDevelop.Core.AddIns.Setup/SetupService.cs: Win32 URI workaround.
+
 2006-08-30 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* MonoDevelop.Core.AddIns.Setup/SetupService.cs: Added support
Index: Core/src/MonoDevelop.Core/MonoDevelop.Core/SystemPackage.cs
===================================================================
--- Core/src/MonoDevelop.Core/MonoDevelop.Core/SystemPackage.cs	(revision 64667)
+++ Core/src/MonoDevelop.Core/MonoDevelop.Core/SystemPackage.cs	(working copy)
@@ -27,6 +27,7 @@
 //
 
 using System;
+using System.IO;
 
 namespace MonoDevelop.Core
 {
@@ -70,5 +71,19 @@
 		public string[] Assemblies {	
 			get { return assemblies; }
 		}
+
+		public static bool IsWin32 {
+			get {
+				switch(Environment.OSVersion.Platform){
+					case PlatformID.Win32NT:
+					case PlatformID.Win32S:
+					case PlatformID.Win32Windows:
+					case PlatformID.WinCE:
+						return true;
+						break;
+				}
+				return false;
+			}
+		}
 	}
 }
Index: Core/src/MonoDevelop.Core/MonoDevelop.Core/SystemAssemblyService.cs
===================================================================
--- Core/src/MonoDevelop.Core/MonoDevelop.Core/SystemAssemblyService.cs	(revision 64667)
+++ Core/src/MonoDevelop.Core/MonoDevelop.Core/SystemAssemblyService.cs	(working copy)
@@ -235,8 +235,8 @@
 
 			//Pull up assemblies from the installed mono system.
 			string prefix = Path.GetDirectoryName (typeof (int).Assembly.Location);
-			
-			if (prefix.IndexOf ("mono/" + versionDir) == -1)
+
+			if (prefix.IndexOf ( Path.Combine("mono", versionDir)) == -1)
 				prefix = Path.Combine (prefix, "mono");
 			else
 				prefix = Path.GetDirectoryName (prefix);
@@ -246,21 +246,25 @@
 
 			string search_dirs = Environment.GetEnvironmentVariable ("PKG_CONFIG_PATH");
 			string libpath = Environment.GetEnvironmentVariable ("PKG_CONFIG_LIBPATH");
+			char splitc = SystemPackage.IsWin32 ? ';' : ':' ;
+
 			if (String.IsNullOrEmpty (libpath)) {
 				string path_dirs = Environment.GetEnvironmentVariable ("PATH");
-				foreach (string pathdir in path_dirs.Split (':')) {
+				foreach (string pathdir in path_dirs.Split (splitc)) {
 					if (pathdir == null)
 						continue;
 					if (File.Exists (pathdir + Path.DirectorySeparatorChar + "pkg-config")) {
-						libpath = pathdir + Path.DirectorySeparatorChar + "../lib/pkgconfig/";
+						libpath = Path.Combine(pathdir,"..");
+						libpath = Path.Combine(libpath,"lib");
+						libpath = Path.Combine(libpath,"pkg-config");
 						break;
 					}
 				}
 			}
-			search_dirs += ":" + libpath;
+			search_dirs += splitc + libpath;
 			if (search_dirs != null && search_dirs.Length > 0) {
 				ArrayList scanDirs = new ArrayList ();
-				foreach (string potentialDir in search_dirs.Split (':')) {
+				foreach (string potentialDir in search_dirs.Split (splitc)) {
 					if (!scanDirs.Contains (potentialDir))
 						scanDirs.Add (potentialDir);
 				}
@@ -269,11 +273,9 @@
 						continue;
 	
 					if (Directory.Exists (pcdir)) {
-						//try  {
 							foreach (string pcfile in Directory.GetFiles (pcdir, "*.pc")) {
 								ParsePCFile (pcfile);
 							}
-						//} catch { }
 					}
 				}
 			}
@@ -285,6 +287,10 @@
 			ArrayList list = new ArrayList ();
 			
 			string dir = Path.Combine (prefix, version);
+			if(!Directory.Exists(dir)) {
+				return;
+			}
+
 			foreach (string assembly in Directory.GetFiles (dir, "*.dll")) {
 				AddAssembly (assembly, package);
 				list.Add (assembly);
@@ -349,7 +355,7 @@
 				System.Reflection.AssemblyName an = System.Reflection.AssemblyName.GetAssemblyName (assemblyfile);
 				assemblyFullNameToPath[NormalizeAsmName (an.FullName)] = assemblyfile;
 				assemblyPathToPackage[assemblyfile] = package;
-			} catch { 
+			} catch {
 			}
 		}
 	
@@ -413,8 +419,8 @@
 			Process p = new Process ();
 			p.StartInfo = psi;
 			p.Start ();
+			string ret = p.StandardOutput.ReadToEnd ().Trim ();
 			p.WaitForExit ();
-			string ret = p.StandardOutput.ReadToEnd ().Trim ();
 			if (String.IsNullOrEmpty (ret))
 				return String.Empty;
 			return ret;
Index: Core/src/MonoDevelop.Core/MonoDevelop.Core.AddIns.Setup/SetupService.cs
===================================================================
--- Core/src/MonoDevelop.Core/MonoDevelop.Core.AddIns.Setup/SetupService.cs	(revision 64667)
+++ Core/src/MonoDevelop.Core/MonoDevelop.Core.AddIns.Setup/SetupService.cs	(working copy)
@@ -1173,6 +1173,8 @@
 			if (url.StartsWith ("file://")) {
 				string tmpfile = Path.GetTempFileName ();
 				string path = url.Substring (7);
+				if (path.StartsWith ("/") && SystemPackage.IsWin32)
+					path = path.Substring (1);
 				File.Delete (tmpfile);
 				File.Copy (path, tmpfile);
 				return tmpfile;
Index: Extras/MonoDevelop.Autotools/SimpleProjectMakefileHandler.cs
===================================================================
--- Extras/MonoDevelop.Autotools/SimpleProjectMakefileHandler.cs	(revision 64667)
+++ Extras/MonoDevelop.Autotools/SimpleProjectMakefileHandler.cs	(working copy)
@@ -133,19 +133,21 @@
 				StringBuilder res_files = new StringBuilder ();
 				StringBuilder extras = new StringBuilder ();
 				StringBuilder datafiles = new StringBuilder ();
+				string pfpath = null;
 				foreach (ProjectFile projectFile in project.ProjectFiles) 
 				{
+					pfpath = SystemPackage.IsWin32 ? projectFile.RelativePath.Replace("\\","/") : projectFile.RelativePath;
 					switch ( projectFile.BuildAction )
 					{
 						case BuildAction.Compile:
 							
 							if ( projectFile.Subtype != Subtype.Code ) continue;
-							files.AppendFormat ( "\\\n\t{0} ", projectFile.RelativePath );
+							files.AppendFormat ( "\\\n\t{0} ", pfpath );
 							break;
 
 						case BuildAction.Nothing:
 							
-							extras.AppendFormat ( "\\\n\t{0} ", projectFile.RelativePath );
+							extras.AppendFormat ( "\\\n\t{0} ", pfpath );
 							break;
 
 						case BuildAction.EmbedAsResource:
@@ -153,18 +155,19 @@
 							if ( !projectFile.FilePath.StartsWith ( ctx.BaseDirectory ) )
 							{
 								// file is not within directory hierarchy, copy it in
-								string rdir = Path.GetDirectoryName (project.FileName) + "/" + resourcedir;
+								string rdir = Path.Combine (Path.GetDirectoryName (project.FileName), resourcedir);
 								if ( !Directory.Exists ( rdir ) ) Directory.CreateDirectory ( rdir );
-								string newPath = rdir + "/" + Path.GetFileName ( projectFile.FilePath );
+								string newPath = Path.Combine (rdir, Path.GetFileName ( projectFile.FilePath ));
 								File.Copy ( projectFile.FilePath, newPath, true ) ;
-								res_files.AppendFormat ( "\\\n\t{0} ", project.GetRelativeChildPath ( newPath ) );
+								pfpath = SystemPackage.IsWin32 ? project.GetRelativeChildPath (newPath).Replace("\\","/") : project.GetRelativeChildPath (newPath);
+								res_files.AppendFormat ( "\\\n\t{0} ", pfpath );
 							}
-							else res_files.AppendFormat ( "\\\n\t{0} ", projectFile.RelativePath );
+							else res_files.AppendFormat ( "\\\n\t{0} ", pfpath );
 							break;
 							
 						case BuildAction.FileCopy:
 						
-							datafiles.AppendFormat ("\\\n\t{0} ", projectFile.RelativePath);
+							datafiles.AppendFormat ("\\\n\t{0} ", pfpath );
 							break;
 					}
 				}
@@ -181,7 +184,7 @@
 					if ( !ctx.IsSupportedConfiguration ( config.Name ) ) continue;
 					
 					conf_vars.AppendFormat ("if ENABLE_{0}\n", config.Name.ToUpper () );
-					string assembly = project.GetRelativeChildPath ( config.CompiledOutputName );
+					string assembly = SystemPackage.IsWin32 ? project.GetRelativeChildPath ( config.CompiledOutputName ).Replace("\\","/") : project.GetRelativeChildPath ( config.CompiledOutputName );
 
 					conf_vars.AppendFormat ("ASSEMBLY_COMPILER_COMMAND = {0}\n",
 							setup.GetCompilerCommand ( project, config.Name ) );
@@ -240,6 +243,7 @@
 
 					// for project references, we need a ref to the dll for the current configuration
 					StringWriter projectReferences = new StringWriter();
+					string pref = null;
 					foreach (ProjectReference reference in project.ProjectReferences) 
 					{
 						if (reference.ReferenceType == ReferenceType.Project) 
@@ -253,11 +257,13 @@
 							
 							projectReferences.WriteLine (" \\");
 							projectReferences.Write ("\t");
-							projectReferences.Write ( project.GetRelativeChildPath ( dnpc.CompiledOutputName ) );
+							pref = SystemPackage.IsWin32 ? project.GetRelativeChildPath ( dnpc.CompiledOutputName ).Replace("\\","/") : project.GetRelativeChildPath ( dnpc.CompiledOutputName );
+							projectReferences.Write ( pref );
 						} 
 					}
 					conf_vars.AppendFormat ( "PROJECT_REFERENCES = {0}\n", projectReferences.ToString() );
-					conf_vars.AppendFormat ( "BUILD_DIR = {0}\n", project.GetRelativeChildPath ( config.OutputDirectory ) );
+					pref = SystemPackage.IsWin32 ? project.GetRelativeChildPath ( config.OutputDirectory ).Replace("\\","/") : project.GetRelativeChildPath ( config.OutputDirectory );
+					conf_vars.AppendFormat ( "BUILD_DIR = {0}\n", pref);
 					conf_vars.Append ( "endif\n" );
 				}
 				templateEngine.Variables["CONFIG_VARS"] = conf_vars.ToString ();
Index: Extras/MonoDevelop.Autotools/SolutionDeployer.cs
===================================================================
--- Extras/MonoDevelop.Autotools/SolutionDeployer.cs	(revision 64667)
+++ Extras/MonoDevelop.Autotools/SolutionDeployer.cs	(working copy)
@@ -90,7 +90,7 @@
 				else pkgconfig = (bool) en_obj;
 				
 				Makefile makefile = handler.Deploy ( context, combine, monitor );
-				string path = solution_dir + "/Makefile";
+				string path = Path.Combine (solution_dir, "Makefile");
 				context.AddAutoconfFile ( path );
 
 				CreateAutoGenDotSH ( monitor );
@@ -210,13 +210,15 @@
 			{
 				string dll_name = Path.GetFileName  ( dll );
 
-				string libdir = solution_dir + "/lib/";
+				string libdir = Path.Combine (solution_dir, "lib");
 				if ( !Directory.Exists ( libdir ) ) Directory.CreateDirectory ( libdir );
 
-				string newPath = libdir + dll_name;
+				string newPath = Path.Combine (libdir, dll_name);
 				File.Copy ( dll, newPath , true );
 
 				newPath = Runtime.FileUtilityService.AbsoluteToRelativePath ( solution_dir, newPath );
+				if (SystemPackage.IsWin32) 
+					newPath = newPath.Replace ("\\","/");
 				sb.Append (' ');
 				sb.Append ( newPath );
 			}
@@ -235,7 +237,7 @@
 
 			templateEngine.Variables["NAME"] = solution_name;
 
-			string fileName = solution_dir + "/autogen.sh";
+			string fileName = Path.Combine (solution_dir, "autogen.sh");
 
 			StreamWriter writer = new StreamWriter( fileName );
 
@@ -248,7 +250,8 @@
 			writer.Close();
 
 			// make autogen.sh executable
-			Syscall.chmod ( fileName , FilePermissions.S_IXOTH | FilePermissions.S_IROTH | FilePermissions.S_IRWXU | FilePermissions.S_IRWXG );
+			if (!SystemPackage.IsWin32)
+				Syscall.chmod ( fileName , FilePermissions.S_IXOTH | FilePermissions.S_IROTH | FilePermissions.S_IRWXU | FilePermissions.S_IRWXG );
 		}
 
 		void CreateConfigureDotAC ( Combine combine, string defaultConf, IProgressMonitor monitor )
@@ -299,9 +302,14 @@
 
 			// build list of *.in files
 			StringBuilder configFiles = new StringBuilder();
+			string tmpmf = null;
 			foreach (string makefile in context.GetAutoConfFiles () ) 
 			{
-				configFiles.Append( Runtime.FileUtilityService.AbsoluteToRelativePath ( solution_dir, makefile ) );
+				tmpmf = Runtime.FileUtilityService.AbsoluteToRelativePath ( solution_dir, makefile );
+				if (SystemPackage.IsWin32)
+					tmpmf = tmpmf.Replace("\\","/");
+
+				configFiles.Append(tmpmf); 
 				configFiles.Append("\n");
 			}
 			templateEngine.Variables["CONFIG_FILES"] = configFiles.ToString();
@@ -321,7 +329,7 @@
 			templateEngine.Variables["SOLUTION_NAME"] = solution_name;
 			templateEngine.Variables["VERSION"] = solution_version;
 
-			string configureFileName = solution_dir + "/configure.ac";
+			string configureFileName = Path.Combine (solution_dir, "configure.ac");
 
 			StreamWriter writer = new StreamWriter(configureFileName);
 			Stream stream = context.GetTemplateStream ("configure.ac.template");
Index: Extras/MonoDevelop.Autotools/ChangeLog
===================================================================
--- Extras/MonoDevelop.Autotools/ChangeLog	(revision 64667)
+++ Extras/MonoDevelop.Autotools/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2006-08-31 Levi Bard  <taktaktaktaktaktaktaktaktaktak@gmail.com>
+
+	* SimpleProjectMakefileHandler.cs: Win32 pathing vs autotools fixes.
+	* SolutionDeployer.cs: Win32 pathing vs autotools fixes, syscall workaround.
+	* SolutionMakefileHandler.cs: Win32 pathing fixes.
+
 2006-08-19  Scott Ellington  <scott.ellington@gmail.com> 
 
 	* SimpleProjectMakefileHandler.cs: 
Index: Extras/MonoDevelop.Autotools/SolutionMakefileHandler.cs
===================================================================
--- Extras/MonoDevelop.Autotools/SolutionMakefileHandler.cs	(revision 64667)
+++ Extras/MonoDevelop.Autotools/SolutionMakefileHandler.cs	(working copy)
@@ -77,7 +77,7 @@
 						
 						// add the subdirectory to the list
 						string path = Path.GetDirectoryName (ce.RelativeFileName);
-						if (path.StartsWith ("./") )
+						if (path.StartsWith ("." + Path.DirectorySeparatorChar) )
 							path = path.Substring (2);
 						subdirs.Append (" ");
 						subdirs.Append ( AutotoolsContext.EscapeStringForAutomake (path) );
@@ -96,7 +96,7 @@
 					if ( handler.CanDeploy ( ce ) )
 					{
 						makefile = handler.Deploy ( ctx, ce, monitor );
-						string outpath = Path.GetDirectoryName(ce.FileName) + "/Makefile";
+						string outpath = Path.Combine(Path.GetDirectoryName(ce.FileName), "Makefile");
 						StreamWriter writer = new StreamWriter ( outpath + ".am" );
 						makefile.Write ( writer );
 						writer.Close ();
Index: Extras/WelcomePage/ChangeLog
===================================================================
--- Extras/WelcomePage/ChangeLog	(revision 64667)
+++ Extras/WelcomePage/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2006-08-31 Levi Bard  <taktaktaktaktaktaktaktaktaktak@gmail.com>
+
+	* WelcomePageView.cs: Win32 pathing fixes, and weird gecko#/win32 workaround.
+
 2006-08-10  Scott Ellington  <scott.ellington@gmail.com>
 
 	* WelcomePageView.cs: override StockIconId for home tab icon
Index: Extras/WelcomePage/WelcomePageView.cs
===================================================================
--- Extras/WelcomePage/WelcomePageView.cs	(revision 64667)
+++ Extras/WelcomePage/WelcomePageView.cs	(working copy)
@@ -81,8 +81,11 @@
 			htmlControl.OpenUri += new OpenUriHandler (CatchUri);
 			htmlControl.LinkMsg += new EventHandler (LinkMessage);
 			
-			datadir = Path.GetDirectoryName (typeof(ShowWelcomePageHandler).Assembly.Location) + "/";
+			datadir = "file://" + Path.GetDirectoryName (typeof(ShowWelcomePageHandler).Assembly.Location) + "/";
 
+			if (SystemPackage.IsWin32)
+				datadir = datadir.Replace("\\","/");
+
 			this.IsViewOnly = true;
 
 			LoadContent ();
@@ -137,6 +140,10 @@
 	
 			string URI = e.AURI;
 
+			// HACK: Necessary for win32; I have no idea why
+			if (SystemPackage.IsWin32)
+				Console.WriteLine ("WelcomePage: Handling URI: " + URI);
+
 			if (URI.StartsWith("project://"))
 			{
 				string projectUri = URI.Substring(10);			
Index: Extras/MonoQuery/ChangeLog
===================================================================
--- Extras/MonoQuery/ChangeLog	(revision 64667)
+++ Extras/MonoQuery/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2006-08-31 Levi Bard  <taktaktaktaktaktaktaktaktaktak@gmail.com>
+
+	* MonoQuery/MonoQueryService.cs: File existence check on unload.
+
 2006-08-08  Jacob Ilsø Christensen  <jacobilsoe@gmail.com>
 
 	* Mono.Data.Sql/Makefile.am:
Index: Extras/MonoQuery/MonoQuery/MonoQueryService.cs
===================================================================
--- Extras/MonoQuery/MonoQuery/MonoQueryService.cs	(revision 64667)
+++ Extras/MonoQuery/MonoQuery/MonoQueryService.cs	(working copy)
@@ -103,9 +103,11 @@
 		
 		public override void UnloadService ()
 		{
-			using (FileStream fs = new FileStream(serializedFile, FileMode.Create)) {
-				XmlSerializer serializer = new XmlSerializer (typeof (DbProviderCollection));
-				serializer.Serialize (fs, providers);
+			if(File.Exists(serializedFile)) {
+				using (FileStream fs = new FileStream(serializedFile, FileMode.Create)) {
+					XmlSerializer serializer = new XmlSerializer (typeof (DbProviderCollection));
+					serializer.Serialize (fs, providers);
+				}
 			}
 		}
 	}
Index: Extras/VBNetBinding/ChangeLog
===================================================================
--- Extras/VBNetBinding/ChangeLog	(revision 64667)
+++ Extras/VBNetBinding/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2006-08-31 Levi Bard  <taktaktaktaktaktaktaktaktaktak@gmail.com>
+
+	* VBBindingCompilerServices.cs: Fixed win32 pathing/compilation issues, removed /bin/sh dependence, removed \r.
+
 2006-07-11 Philip Turnbull <philip.turnbull@gmail.com>
 
 	* VBNetBinding/VBNetBinding.addin.xml:
Index: Extras/VBNetBinding/VBBindingCompilerServices.cs
===================================================================
--- Extras/VBNetBinding/VBBindingCompilerServices.cs	(revision 64667)
+++ Extras/VBNetBinding/VBBindingCompilerServices.cs	(working copy)
@@ -1,297 +1,205 @@
-// <file>
-//     <copyright see="prj:///doc/copyright.txt"/>
-//     <license see="prj:///doc/license.txt"/>
-//     <owner name="Markus Palme" email="MarkusPalme@gmx.de"/>
-//     <version value="$version"/>
-// </file>
-
-using System;
+// <file>
+//     <copyright see="prj:///doc/copyright.txt"/>
+//     <license see="prj:///doc/license.txt"/>
+//     <owner name="Markus Palme" email="MarkusPalme@gmx.de"/>
+//     <version value="$version"/>
+// </file>
+
+using System;
 using System.Text;
-using System.Text.RegularExpressions;
-using System.Collections;
-using System.IO;
-using System.Diagnostics;
+using System.Text.RegularExpressions;
+using System.Collections;
+using System.IO;
+using System.Diagnostics;
 using System.CodeDom.Compiler;
-
-using MonoDevelop.Core;
+using System.Threading;
+
+using MonoDevelop.Core;
 using MonoDevelop.Core.Gui;
-using MonoDevelop.Core.Gui.Components;
+using MonoDevelop.Core.Gui.Components;
 using MonoDevelop.Projects;
-
-namespace VBBinding {
-	
-	/// <summary>
-	/// This class controls the compilation of VB.net files and VB.net projects
-	/// </summary>
-	public class VBBindingCompilerServices
+
+namespace VBBinding {
+	
+	/// <summary>
+	/// This class controls the compilation of VB.net files and VB.net projects
+	/// </summary>
+	public class VBBindingCompilerServices
 	{	
 	
 		static Regex regexError = new Regex (@"^(\s*(?<file>.*)\((?<line>\d*)(,(?<column>\d*))?\)\s+)*(?<level>\w+)\s*(?<number>.*):\s(?<message>.*)",
 		RegexOptions.Compiled | RegexOptions.ExplicitCapture);
 
-	
-		FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService(typeof(FileUtilityService));
-		PropertyService propertyService       = (PropertyService)ServiceManager.GetService(typeof(PropertyService));
-		
-		public bool CanCompile(string fileName)
-		{
-			return Path.GetExtension(fileName) == ".vb";
-		}
-		
-		string GetCompilerName(string compilerVersion)
-		{
-			//string runtimeDirectory = Path.Combine(fileUtilityService.NETFrameworkInstallRoot, compilerVersion);
-			//if (compilerVersion.Length == 0 || compilerVersion == "Standard" || !Directory.Exists(runtimeDirectory)) {
-			//	runtimeDirectory = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory();
-			//}
-			//return String.Concat('"', Path.Combine(runtimeDirectory, "vbc.exe"), '"');
-			return "mbas";
-		}
-		
-		string GenerateOptions (DotNetProjectConfiguration configuration, VBCompilerParameters compilerparameters, string outputFileName)
-		{
-			StringBuilder sb = new StringBuilder();
-			
-			sb.Append("-out:");sb.Append(outputFileName);/*sb.Append('"');*/sb.Append(Environment.NewLine);
-			
-			sb.Append("-nologo");sb.Append(Environment.NewLine);
-			sb.Append("-utf8output");sb.Append(Environment.NewLine);
-			
-//			if (compilerparameters.DebugMode) {
-//				sb.Append("--debug+");sb.Append(Environment.NewLine);
-//				sb.Append("--debug:full");sb.Append(Environment.NewLine);
-//			}
-			
-			//if (compilerparameters.Optimize) {
-			//	sb.Append("-optimize");sb.Append(Environment.NewLine);
-			//}
-			
-			//if (compilerparameters.OptionStrict) {
-			//	sb.Append("-optionstrict");sb.Append(Environment.NewLine);
-			//}
-			
-			//if (compilerparameters.OptionExplicit) {
-			//	sb.Append("-optionexplicit");sb.Append(Environment.NewLine);
-			//}// else {
-			//	sb.Append("--optionexplicit-");sb.Append(Environment.NewLine);
-			//}
-			
-			if (compilerparameters.Win32Icon != null && compilerparameters.Win32Icon.Length > 0 && File.Exists(compilerparameters.Win32Icon)) {
-				sb.Append("-win32icon:");sb.Append('"');sb.Append(compilerparameters.Win32Icon);sb.Append('"');sb.Append(Environment.NewLine);
-			}
-			
-			if (compilerparameters.RootNamespace!= null && compilerparameters.RootNamespace.Length > 0) {
-				sb.Append("-rootnamespace:");sb.Append('"');sb.Append(compilerparameters.RootNamespace);sb.Append('"');sb.Append(Environment.NewLine);
-			}
-			
-			if (compilerparameters.DefineSymbols.Length > 0) {
-				sb.Append("-define:");sb.Append('"');sb.Append(compilerparameters.DefineSymbols);sb.Append('"');sb.Append(Environment.NewLine);
-			}
-			
-			if (compilerparameters.MainClass != null && compilerparameters.MainClass.Length > 0) {
-				sb.Append("-main:");sb.Append(compilerparameters.MainClass);sb.Append(Environment.NewLine);
-			}
-			
-			if(compilerparameters.Imports.Length > 0) {
-				sb.Append("-imports:");sb.Append(compilerparameters.Imports);sb.Append(Environment.NewLine);
-			}
-			
-			switch (configuration.CompileTarget) {
-				case CompileTarget.Exe:
-					sb.Append("-target:exe");
-					break;
-				case CompileTarget.WinExe:
-					sb.Append("-target:winexe");
-					break;
-				case CompileTarget.Library:
-					sb.Append("-target:library");
-					break;
-				case CompileTarget.Module:
-					sb.Append("-target:module");
-					break;
-				default:
-					throw new NotSupportedException("unknown compile target:" + configuration.CompileTarget);
-			}
+	
+		FileUtilityService fileUtilityService = (FileUtilityService)ServiceManager.GetService(typeof(FileUtilityService));
+		PropertyService propertyService       = (PropertyService)ServiceManager.GetService(typeof(PropertyService));
+		
+		public bool CanCompile(string fileName)
+		{
+			return Path.GetExtension(fileName) == ".vb";
+		}
+		
+		string GetCompilerName(string compilerVersion)
+		{
+			return "mbas";
+		}
+		
+		string GenerateOptions (DotNetProjectConfiguration configuration, VBCompilerParameters compilerparameters, string outputFileName)
+		{
+			StringBuilder sb = new StringBuilder();
+			
+			sb.Append("-out:");sb.Append("\"" + outputFileName + "\"");sb.Append(Environment.NewLine);
+			sb.Append("-nologo");sb.Append(Environment.NewLine);
+			sb.Append("-utf8output");sb.Append(Environment.NewLine);
+			
+//			if (compilerparameters.DebugMode) {
+//				sb.Append("--debug+");sb.Append(Environment.NewLine);
+//				sb.Append("--debug:full");sb.Append(Environment.NewLine);
+//			}
+			
+			//if (compilerparameters.Optimize) {
+			//	sb.Append("-optimize");sb.Append(Environment.NewLine);
+			//}
+			
+			//if (compilerparameters.OptionStrict) {
+			//	sb.Append("-optionstrict");sb.Append(Environment.NewLine);
+			//}
+			
+			//if (compilerparameters.OptionExplicit) {
+			//	sb.Append("-optionexplicit");sb.Append(Environment.NewLine);
+			//}// else {
+			//	sb.Append("--optionexplicit-");sb.Append(Environment.NewLine);
+			//}
+			
+			if (compilerparameters.Win32Icon != null && compilerparameters.Win32Icon.Length > 0 && File.Exists(compilerparameters.Win32Icon)) {
+				sb.Append("-win32icon:");sb.Append('"');sb.Append(compilerparameters.Win32Icon);sb.Append('"');sb.Append(Environment.NewLine);
+			}
+			
+			if (compilerparameters.RootNamespace!= null && compilerparameters.RootNamespace.Length > 0) {
+				sb.Append("-rootnamespace:");sb.Append('"');sb.Append(compilerparameters.RootNamespace);sb.Append('"');sb.Append(Environment.NewLine);
+			}
+			
+			if (compilerparameters.DefineSymbols.Length > 0) {
+				sb.Append("-define:");sb.Append('"');sb.Append(compilerparameters.DefineSymbols);sb.Append('"');sb.Append(Environment.NewLine);
+			}
+			
+			if (compilerparameters.MainClass != null && compilerparameters.MainClass.Length > 0) {
+				sb.Append("-main:");sb.Append(compilerparameters.MainClass);sb.Append(Environment.NewLine);
+			}
+			
+			if(compilerparameters.Imports.Length > 0) {
+				sb.Append("-imports:");sb.Append(compilerparameters.Imports);sb.Append(Environment.NewLine);
+			}
+			
+			switch (configuration.CompileTarget) {
+				case CompileTarget.Exe:
+					sb.Append("-target:exe");
+					break;
+				case CompileTarget.WinExe:
+					sb.Append("-target:winexe");
+					break;
+				case CompileTarget.Library:
+					sb.Append("-target:library");
+					break;
+				case CompileTarget.Module:
+					sb.Append("-target:module");
+					break;
+				default:
+					throw new NotSupportedException("unknown compile target:" + configuration.CompileTarget);
+			}
 			sb.Append(Environment.NewLine);
-			return sb.ToString();
-		}
-		
-		public ICompilerResult Compile (ProjectFileCollection projectFiles, ProjectReferenceCollection references, DotNetProjectConfiguration configuration, IProgressMonitor monitor)
+			return sb.ToString();
+		}
+		
+		public ICompilerResult Compile (ProjectFileCollection projectFiles, ProjectReferenceCollection references, DotNetProjectConfiguration configuration, IProgressMonitor monitor)
 		{
 			VBCompilerParameters compilerparameters = (VBCompilerParameters) configuration.CompilationParameters;
 			if (compilerparameters == null) compilerparameters = new VBCompilerParameters ();
-			
+			
 			string exe = configuration.CompiledOutputName;
-			string responseFileName = Path.GetTempFileName();
-			//string stdResponseFileName = String.Concat(propertyService.DataDirectory, Path.DirectorySeparatorChar, "vb.rsp");
+			string responseFileName = Path.GetTempFileName();
+			//string stdResponseFileName = String.Concat(propertyService.DataDirectory, Path.DirectorySeparatorChar, "vb.rsp");
 			StreamWriter writer = new StreamWriter(responseFileName);
 			
-			//Console.WriteLine(GenerateOptions(compilerparameters,exe));	
-			writer.WriteLine(GenerateOptions (configuration, compilerparameters, exe));
-			
-			foreach (ProjectReference lib in references) {
+			writer.WriteLine(GenerateOptions (configuration, compilerparameters, exe));
+			
+			foreach (ProjectReference lib in references) {
 				foreach (string fileName in lib.GetReferencedFileNames())
-					writer.WriteLine(String.Concat("-r:", fileName));
-			}
-			
-			// write source files and embedded resources
-			foreach (ProjectFile finfo in projectFiles) {
-				if (finfo.Subtype != Subtype.Directory) {
-					switch (finfo.BuildAction) {
+					writer.WriteLine(String.Concat("-r:", fileName));
+			}
+			
+			// write source files and embedded resources
+			foreach (ProjectFile finfo in projectFiles) {
+				if (finfo.Subtype != Subtype.Directory) {
+					switch (finfo.BuildAction) {
 						case BuildAction.Compile:
-							//Console.WriteLine(finfo.Name);
-							writer.WriteLine(finfo.Name);
-						break;
-						
+							writer.WriteLine("\"" + finfo.Name + "\"");
+						break;
+						
 						case BuildAction.EmbedAsResource:
-							//Console.WriteLine(String.Concat("-resource:", finfo.Name));
-							writer.WriteLine(String.Concat("-resource:", finfo.Name));
-						break;
-					}
-				}
-			}
-			
-			TempFileCollection tf = new TempFileCollection ();
-			writer.Close();
-			
-			string output = "";
-			string error  = "";
-			string compilerName = GetCompilerName(compilerparameters.VBCompilerVersion);
-			string outstr = String.Concat(compilerName, " @", responseFileName); //, " @", stdResponseFileName);
+							writer.WriteLine(String.Concat("-resource:", finfo.Name));
+						break;
+					}
+				}
+			}
 			
-			//Console.WriteLine("Attempting to run: "+outstr);
-			
-			//Executor.ExecWaitWithCapture(outstr, tf, ref output, ref error);
-			DoCompilation(outstr,tf,ref output,ref error);
+			TempFileCollection tf = new TempFileCollection ();
+			writer.Close();
 			
-			//Console.WriteLine("Output: "+output);
-			//Console.WriteLine("Error: "+error);
+			string output = "";
+			string error  = "";
+			string compilerName = GetCompilerName(compilerparameters.VBCompilerVersion);
+			string outstr = String.Concat(compilerName, " @", responseFileName);
 			
-			
+			DoCompilation(outstr,tf,ref output,ref error);
+			
 			ICompilerResult result = ParseOutput(tf, output);
 			ParseOutput(tf,error);
-			
-			File.Delete(responseFileName);
-			File.Delete(output);
-			File.Delete(error);
-			if (configuration.CompileTarget != CompileTarget.Library) {
-				WriteManifestFile(exe);
-			}
-			return result;
-		}
-		
-		// code duplication: see C# backend : CSharpBindingCompilerManager
-		void WriteManifestFile(string fileName)
-		{
-			string manifestFile = String.Concat(fileName, ".manifest");
-			if (File.Exists(manifestFile)) {
-				return;
-			}
-			StreamWriter sw = new StreamWriter(manifestFile);
-			sw.WriteLine("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>");
-			sw.WriteLine("");
-			sw.WriteLine("<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">");
-			sw.WriteLine("	<dependency>");
-			sw.WriteLine("		<dependentAssembly>");
-			sw.WriteLine("			<assemblyIdentity");
-			sw.WriteLine("				type=\"win32\"");
-			sw.WriteLine("				name=\"Microsoft.Windows.Common-Controls\"");
-			sw.WriteLine("				version=\"6.0.0.0\"");
-			sw.WriteLine("				processorArchitecture=\"X86\"");
-			sw.WriteLine("				publicKeyToken=\"6595b64144ccf1df\"");
-			sw.WriteLine("				language=\"*\"");
-			sw.WriteLine("			/>");
-			sw.WriteLine("		</dependentAssembly>");
-			sw.WriteLine("	</dependency>");
-			sw.WriteLine("</assembly>");
-			sw.Close();
-		}
-		
-/***** Legacy #D code, will remove if replacement code tests OK *****
-
-		CompilerResult ParseOutput(TempFileCollection tf, string file)
-		{
-			StringBuilder compilerOutput = new StringBuilder();
-			
-			StreamReader sr = File.OpenText(file);
-			
-			// skip fist whitespace line
-			sr.ReadLine();
-			
-			CompilerResults cr = new CompilerResults(tf);
-			
-			while (true) {
-				string next = sr.ReadLine();
-				compilerOutput.Append(next);compilerOutput.Append(Environment.NewLine);
-				if (next == null) {
-					break;
-				}
-				CompilerError error = new CompilerError();
-				
-				int index           = next.IndexOf(": ");
-				if (index < 0) {
-					continue;
-				}
-				
-				string description  = null;
-				string errorwarning = null;
-				string location     = null;
-				
-				string s1 = next.Substring(0, index);
-				string s2 = next.Substring(index + 2);
-				index  = s2.IndexOf(": ");
-				
-				if (index == -1) {
-					errorwarning = s1;
-					description = s2;
-				} else {
-					location = s1;
-					s1 = s2.Substring(0, index);
-					s2 = s2.Substring(index + 2);
-					errorwarning = s1;
-					description = s2;
-				}
-				
-				if (location != null) {
-					int idx1 = location.LastIndexOf('(');
-					int idx2 = location.LastIndexOf(')');
-					if (idx1 >= 0 &&  idx2 >= 0) {
-						string filename = location.Substring(0, idx1);
-						error.Line = Int32.Parse(location.Substring(idx1 + 1, idx2 - idx1 - 1));
-						error.FileName = Path.GetFullPath(filename.Trim()); // + "\\" + Path.GetFileName(filename);
-					}
-				}
-				
-				string[] what = errorwarning.Split(' ');
-				Console.WriteLine("Error is: "+what[0]);
-				error.IsWarning   = (what[0] == "warning" || what[0]=="MonoBASIC");
-				error.ErrorNumber = what[what.Length - 1];
-				
-				error.ErrorText = description;
-				
-				cr.Errors.Add(error);
-			}
-			sr.Close();
-			Console.WriteLine(compilerOutput.ToString());
-			return new DefaultCompilerResult(cr, compilerOutput.ToString());
+			
+			File.Delete(responseFileName);
+			File.Delete(output);
+			File.Delete(error);
+			if (configuration.CompileTarget != CompileTarget.Library) {
+				WriteManifestFile(exe);
+			}
+			return result;
 		}
-*/
 		
+		// code duplication: see C# backend : CSharpBindingCompilerManager
+		void WriteManifestFile(string fileName)
+		{
+			string manifestFile = String.Concat(fileName, ".manifest");
+			if (File.Exists(manifestFile)) {
+				return;
+			}
+			StreamWriter sw = new StreamWriter(manifestFile);
+			sw.WriteLine("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>");
+			sw.WriteLine("");
+			sw.WriteLine("<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">");
+			sw.WriteLine("	<dependency>");
+			sw.WriteLine("		<dependentAssembly>");
+			sw.WriteLine("			<assemblyIdentity");
+			sw.WriteLine("				type=\"win32\"");
+			sw.WriteLine("				name=\"Microsoft.Windows.Common-Controls\"");
+			sw.WriteLine("				version=\"6.0.0.0\"");
+			sw.WriteLine("				processorArchitecture=\"X86\"");
+			sw.WriteLine("				publicKeyToken=\"6595b64144ccf1df\"");
+			sw.WriteLine("				language=\"*\"");
+			sw.WriteLine("			/>");
+			sw.WriteLine("		</dependentAssembly>");
+			sw.WriteLine("	</dependency>");
+			sw.WriteLine("</assembly>");
+			sw.Close();
+		}
+		
 		ICompilerResult ParseOutput(TempFileCollection tf, string file)
 		{
 			StringBuilder compilerOutput = new StringBuilder();
 			
 			StreamReader sr = File.OpenText(file);
 			
-			// skip fist whitespace line
-			//sr.ReadLine();
-			
 			CompilerResults cr = new CompilerResults(tf);
 			
-			// we have 2 formats for the error output the csc gives :
-			//Regex normalError  = new Regex(@"(?<file>.*)\((?<line>\d+),(?<column>\d+)\):\s+(?<error>\w+)\s+(?<number>[\d\w]+):\s+(?<message>.*)", RegexOptions.Compiled);
-			//Regex generalError = new Regex(@"(?<error>.+)\s+(?<number>[\d\w]+):\s+(?<message>.*)", RegexOptions.Compiled);
-			
 			while (true) {
 				string curLine = sr.ReadLine();
 				compilerOutput.Append(curLine);
@@ -342,20 +250,54 @@
 			return error;
 		}
 		
+		// code duplication: see C# backend : CSharpBindingCompilerManager
 		private void DoCompilation(string outstr, TempFileCollection tf, ref string output, ref string error) {
 			output = Path.GetTempFileName();
 			error = Path.GetTempFileName();
 			
-			string arguments = outstr + " > " + output + " 2> " + error;
-			string command = arguments;
-			ProcessStartInfo si = new ProcessStartInfo("/bin/sh","-c \"" + command + "\"");
+			string[] tokens = outstr.Split(' ');
+
+			outstr = outstr.Substring(tokens[0].Length+1);
+
+			ProcessStartInfo si = new ProcessStartInfo(tokens[0], "\"" + outstr + "\"");
 			si.RedirectStandardOutput = true;
 			si.RedirectStandardError = true;
 			si.UseShellExecute = false;
 			Process p = new Process();
 			p.StartInfo = si;
 			p.Start();
+			new StreamRedirector(p.StandardOutput, output);
+			new StreamRedirector(p.StandardError, error);
 			p.WaitForExit ();
 		}
-	}
+	}
+
+	// code duplication: see C# backend : CSharpBindingCompilerManager
+	// Wrapper class for threading stdout/stderr redirects
+	// Since we can't rely on ">out 2>err"
+	internal class StreamRedirector {
+		protected string redirectfile;
+		protected StreamReader str;
+
+		// Kicks off a thread dumping input from strredir into fileredir
+		public StreamRedirector (StreamReader strredir, string fileredir) {
+			Thread t = new Thread (new ThreadStart (Run));
+			str = strredir;
+			redirectfile = fileredir;
+			t.Start();
+		}
+
+		public void Run () {
+			try {
+				string s = null;
+				StreamWriter sw = new StreamWriter (redirectfile);
+
+				s = str.ReadToEnd();
+				sw.Write(s);
+				sw.Close();
+			} catch {
+				//Should we do something here?
+			}
+		}
+	}
 }
Index: Extras/CSharpBinding/ChangeLog
===================================================================
--- Extras/CSharpBinding/ChangeLog	(revision 64667)
+++ Extras/CSharpBinding/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2006-08-31 Levi Bard  <taktaktaktaktaktaktaktaktaktak@gmail.com>
+
+	* CSharpBindingCompilerManager.cs: Fixed win32 pathing issues, removed old mcs-specific compiler options (that weren't being used since [g]mcs options have been aligned with csc options), removed /bin/sh dependence.
+	* Project/CSharpCompilerParameters.cs: Changed default compiler to mcs.
+
 2006-08-07 Philip Turnbull <philip.turnbull@gmail.com>
 
 	* CSharpBinding/CSharpBinding.addin.xml:
Index: Extras/CSharpBinding/CSharpBindingCompilerManager.cs
===================================================================
--- Extras/CSharpBinding/CSharpBindingCompilerManager.cs	(revision 64667)
+++ Extras/CSharpBinding/CSharpBindingCompilerManager.cs	(working copy)
@@ -12,6 +12,7 @@
 using System.Text;
 using System.Text.RegularExpressions;
 using System.CodeDom.Compiler;
+using System.Threading;
 
 using MonoDevelop.Core;
 using MonoDevelop.Projects;
@@ -38,159 +39,114 @@
 			string exe = configuration.CompiledOutputName;
 			string responseFileName = Path.GetTempFileName();
 			StreamWriter writer = new StreamWriter(responseFileName);
+
+			writer.WriteLine("\"/out:" + exe + '"');
 			
-			if (compilerparameters.CsharpCompiler == CsharpCompiler.Csc) {
-				writer.WriteLine("\"/out:" + exe + '"');
-				
-				ArrayList pkg_references = new ArrayList ();
-				
-				if (references != null) {
-					foreach (ProjectReference lib in references) {
-						foreach (string fileName in lib.GetReferencedFileNames ()) {
-							switch (lib.ReferenceType) {
-							case ReferenceType.Gac:
-								SystemPackage pkg = Runtime.SystemAssemblyService.GetPackageFromFullName (lib.Reference);
-								if (pkg == null) {
-									string msg = String.Format (GettextCatalog.GetString ("{0} could not be found or is invalid."), lib.Reference);
-									monitor.ReportWarning (msg);
-									continue;
-								}
-								if (pkg.IsCorePackage) {
-									writer.WriteLine ("\"/r:" + Path.GetFileName (fileName) + "\"");
-								} else if (!pkg_references.Contains (pkg.Name)) {
-									pkg_references.Add (pkg.Name);
-									writer.WriteLine ("\"-pkg:" + pkg.Name + "\"");
-								}
-								break;
-							default:
-								writer.WriteLine ("\"/r:" + fileName + "\"");
-								break;
+			ArrayList pkg_references = new ArrayList ();
+			
+			if (references != null) {
+				foreach (ProjectReference lib in references) {
+					foreach (string fileName in lib.GetReferencedFileNames ()) {
+						switch (lib.ReferenceType) {
+						case ReferenceType.Gac:
+							SystemPackage pkg = Runtime.SystemAssemblyService.GetPackageFromFullName (lib.Reference);
+							if (pkg == null) {
+								string msg = String.Format (GettextCatalog.GetString ("{0} could not be found or is invalid."), lib.Reference);
+								monitor.ReportWarning (msg);
+								continue;
 							}
+							if (pkg.IsCorePackage) {
+								writer.WriteLine ("\"/r:" + Path.GetFileName (fileName) + "\"");
+							} else if (!pkg_references.Contains (pkg.Name)) {
+								pkg_references.Add (pkg.Name);
+								writer.WriteLine ("\"-pkg:" + pkg.Name + "\"");
+							}
+							break;
+						default:
+							writer.WriteLine ("\"/r:" + fileName + "\"");
+							break;
 						}
 					}
 				}
+			}
+			
+			writer.WriteLine("/noconfig");
+			writer.WriteLine("/nologo");
+			writer.WriteLine("/codepage:utf8");
+//			writer.WriteLine("/utf8output");
+//			writer.WriteLine("/w:" + compilerparameters.WarningLevel);;
 				
-				writer.WriteLine("/noconfig");
-				writer.WriteLine("/nologo");
-				writer.WriteLine("/codepage:utf8");
-//				writer.WriteLine("/utf8output");
-//				writer.WriteLine("/w:" + compilerparameters.WarningLevel);;
-				
-				if (configuration.DebugMode) {
-					writer.WriteLine("/debug:+");
-					writer.WriteLine("/debug:full");
-					writer.WriteLine("/d:DEBUG");
-				}
-				
-				// mcs default is + but others might not be
-				if (compilerparameters.Optimize)
-					writer.WriteLine("/optimize+");
-				else
-					writer.WriteLine("/optimize-");
-				
-				if (compilerparameters.Win32Icon != null && compilerparameters.Win32Icon.Length > 0 && File.Exists (compilerparameters.Win32Icon)) {
-					writer.WriteLine("\"/win32icon:" + compilerparameters.Win32Icon + "\"");
-				}
-				
-				if (compilerparameters.UnsafeCode) {
-					writer.WriteLine("/unsafe");
-				}
-				
-				if (compilerparameters.DefineSymbols.Length > 0) {
-					writer.WriteLine("/define:" + '"' + compilerparameters.DefineSymbols + '"');
-				}
-				
-				if (compilerparameters.MainClass != null && compilerparameters.MainClass.Length > 0) {
-					writer.WriteLine("/main:" + compilerparameters.MainClass);
-				}
-				
-				switch (configuration.CompileTarget) {
-					case CompileTarget.Exe:
-						writer.WriteLine("/t:exe");
-						break;
-					case CompileTarget.WinExe:
-						writer.WriteLine("/t:winexe");
-						break;
-					case CompileTarget.Library:
-						writer.WriteLine("/t:library");
-						break;
-				}
-				
-				foreach (ProjectFile finfo in projectFiles) {
-					if (finfo.Subtype != Subtype.Directory) {
-						switch (finfo.BuildAction) {
-							case BuildAction.Compile:
-								if (CanCompile (finfo.Name))
-									writer.WriteLine('"' + finfo.Name + '"');
-								break;
-							case BuildAction.EmbedAsResource:
-								// FIXME: workaround 60990
-								writer.WriteLine(@"""/res:{0},{1}""", finfo.Name, Path.GetFileName (finfo.Name));
-								break;
-						}
-					}
-				}
-				if (compilerparameters.GenerateXmlDocumentation) {
-					writer.WriteLine("\"/doc:" + Path.ChangeExtension(exe, ".xml") + '"');
-				}
-			} 
-			else {
-				writer.WriteLine("-o " + exe);
-				
-				if (compilerparameters.UnsafeCode) {
-					writer.WriteLine("--unsafe");
-				}
-				
-				writer.WriteLine("--wlevel " + compilerparameters.WarningLevel);
-		
-				if (references != null) {		
-					foreach (ProjectReference lib in references) {
-						foreach (string fileName in lib.GetReferencedFileNames ())
-							writer.WriteLine("-r:" + fileName );
-					}
-				}
-				
-				switch (configuration.CompileTarget) {
-					case CompileTarget.Exe:
-						writer.WriteLine("--target exe");
-						break;
-					case CompileTarget.WinExe:
-						writer.WriteLine("--target winexe");
-						break;
-					case CompileTarget.Library:
-						writer.WriteLine("--target library");
-						break;
-				}
-				foreach (ProjectFile finfo in projectFiles) {
-					if (finfo.Subtype != Subtype.Directory) {
-						switch (finfo.BuildAction) {
-							case BuildAction.Compile:
+			if (configuration.DebugMode) {
+				writer.WriteLine("/debug:+");
+				writer.WriteLine("/debug:full");
+				writer.WriteLine("/d:DEBUG");
+			}
+			
+			// mcs default is + but others might not be
+			if (compilerparameters.Optimize)
+				writer.WriteLine("/optimize+");
+			else
+				writer.WriteLine("/optimize-");
+			
+			if (compilerparameters.Win32Icon != null && compilerparameters.Win32Icon.Length > 0 && File.Exists (compilerparameters.Win32Icon)) {
+				writer.WriteLine("\"/win32icon:" + compilerparameters.Win32Icon + "\"");
+			}
+			
+			if (compilerparameters.UnsafeCode) {
+				writer.WriteLine("/unsafe");
+			}
+			
+			if (compilerparameters.DefineSymbols.Length > 0) {
+				writer.WriteLine("/define:" + '"' + compilerparameters.DefineSymbols + '"');
+			}
+			
+			if (compilerparameters.MainClass != null && compilerparameters.MainClass.Length > 0) {
+				writer.WriteLine("/main:" + compilerparameters.MainClass);
+			}
+			
+			switch (configuration.CompileTarget) {
+				case CompileTarget.Exe:
+					writer.WriteLine("/t:exe");
+					break;
+				case CompileTarget.WinExe:
+					writer.WriteLine("/t:winexe");
+					break;
+				case CompileTarget.Library:
+					writer.WriteLine("/t:library");
+					break;
+			}
+			
+			foreach (ProjectFile finfo in projectFiles) {
+				if (finfo.Subtype != Subtype.Directory) {
+					switch (finfo.BuildAction) {
+						case BuildAction.Compile:
+							if (CanCompile (finfo.Name))
 								writer.WriteLine('"' + finfo.Name + '"');
-								break;
-							
-							case BuildAction.EmbedAsResource:
-								writer.WriteLine("--linkres " + finfo.Name);
-								break;
-						}
+							break;
+						case BuildAction.EmbedAsResource:
+							// FIXME: workaround 60990
+							writer.WriteLine(@"""/res:{0},{1}""", finfo.Name, Path.GetFileName (finfo.Name));
+							break;
 					}
-				}			
+				}
 			}
+			if (compilerparameters.GenerateXmlDocumentation) {
+				writer.WriteLine("\"/doc:" + Path.ChangeExtension(exe, ".xml") + '"');
+			}
+
 			writer.Close();
-			
+
 			string output = String.Empty;
 			string error  = String.Empty;
 			
 			string mcs = configuration.ClrVersion == ClrVersion.Net_1_1 ? "mcs" : "gmcs";
 			
-			string compilerName = compilerparameters.CsharpCompiler == CsharpCompiler.Csc ? GetCompilerName (configuration.ClrVersion) : System.Environment.GetEnvironmentVariable("ComSpec") + " /c " + mcs;
+			string compilerName = compilerparameters.CsharpCompiler == CsharpCompiler.Csc ? GetCompilerName (configuration.ClrVersion) : mcs;
 			string outstr = compilerName + " @" + responseFileName;
 			TempFileCollection tf = new TempFileCollection();
-			
-			//StreamReader t = File.OpenText(responseFileName);
-			
-			//Executor.ExecWaitWithCapture(outstr,  tf, ref output, ref error);
+
 			DoCompilation(outstr, tf, ref output, ref error);
-			
+
 			ICompilerResult result = ParseOutput(tf, output, error);
 			if (result.CompilerOutput.Trim () != "")
 				monitor.Log.WriteLine (result.CompilerOutput);
@@ -254,15 +210,19 @@
 			output = Path.GetTempFileName();
 			error = Path.GetTempFileName();
 			
-			string arguments = outstr + " > " + output + " 2> " + error;
-			string command = arguments;
-			ProcessStartInfo si = new ProcessStartInfo("/bin/sh","-c \"" + command + "\"");
+			string[] tokens = outstr.Split(' ');
+
+			outstr = outstr.Substring(tokens[0].Length+1);
+
+			ProcessStartInfo si = new ProcessStartInfo(tokens[0], "\"" + outstr + "\"");
 			si.RedirectStandardOutput = true;
 			si.RedirectStandardError = true;
 			si.UseShellExecute = false;
 			Process p = new Process();
 			p.StartInfo = si;
 			p.Start();
+			new StreamRedirector(p.StandardOutput, output);
+			new StreamRedirector(p.StandardError, error);
 			p.WaitForExit ();
 		}
 
@@ -300,4 +260,32 @@
 			return error;
 		}
 	}
+
+	// Wrapper class for threading stdout/stderr redirects
+	// Since we can't rely on ">out 2>err"
+	internal class StreamRedirector {
+		protected string redirectfile;
+		protected StreamReader str;
+
+		// Kicks off a thread dumping input from strredir into fileredir
+		public StreamRedirector (StreamReader strredir, string fileredir) {
+			Thread t = new Thread (new ThreadStart (Run));
+			str = strredir;
+			redirectfile = fileredir;
+			t.Start();
+		}
+
+		public void Run () {
+			try {
+				string s = null;
+				StreamWriter sw = new StreamWriter (redirectfile);
+
+				s = str.ReadToEnd();
+				sw.Write(s);
+				sw.Close();
+			} catch {
+				//Should we do something here?
+			}
+		}
+	}
 }
Index: Extras/CSharpBinding/Project/CSharpCompilerParameters.cs
===================================================================
--- Extras/CSharpBinding/Project/CSharpCompilerParameters.cs	(revision 64667)
+++ Extras/CSharpBinding/Project/CSharpCompilerParameters.cs	(working copy)
@@ -28,7 +28,7 @@
 		// Configuration parameters
 		
 		[ItemProperty ("compiler")]
-		CsharpCompiler csharpCompiler = CsharpCompiler.Csc;
+		CsharpCompiler csharpCompiler = CsharpCompiler.Mcs;
 		
 		[ItemProperty ("warninglevel")]
 		int  warninglevel       = 4;