diff -ruN stetic/libstetic/AssemblyWidgetLibrary.cs stetic.clean/libstetic/AssemblyWidgetLibrary.cs
--- stetic/libstetic/AssemblyWidgetLibrary.cs	2006-06-09 22:59:49.000000000 +0200
+++ stetic.clean/libstetic/AssemblyWidgetLibrary.cs	2006-06-30 22:59:37.000000000 +0200
@@ -7,7 +7,10 @@
 	public class AssemblyWidgetLibrary: WidgetLibrary
 	{
 		Assembly assembly;
-		
+		public Assembly Asm {
+			get { return (assembly); }
+		}
+				
 		public AssemblyWidgetLibrary (Assembly assembly)
 		{
 			this.assembly = assembly;
diff -ruN stetic/libstetic/ClassDescriptor.cs stetic.clean/libstetic/ClassDescriptor.cs
--- stetic/libstetic/ClassDescriptor.cs	2006-06-09 22:59:49.000000000 +0200
+++ stetic.clean/libstetic/ClassDescriptor.cs	2006-06-30 23:21:05.000000000 +0200
@@ -9,6 +9,20 @@
 	
 	public abstract class ClassDescriptor
 	{
+		public struct ToolboxItemDefinitions
+		{
+			public string Name;
+			public string Category;
+			public string Description;
+			
+			public ToolboxItemDefinitions (string aName, string aCategory, string aDescription)
+			{
+				Name = aName;
+				Category = aCategory;
+				Description = aDescription;
+			}
+		}
+		
 		protected string label, category, cname;
 		protected bool deprecated, hexpandable, vexpandable, allowChildren = true;
 		
@@ -19,6 +33,24 @@
 		protected ItemGroup contextMenu;
 		protected ItemGroup internalChildren;
 		
+		private bool isToolboxItem = false;
+		public bool IsToolboxItem {
+			get { return (isToolboxItem); }
+			set { isToolboxItem = value; }
+		}
+
+		private System.Type widgetType = (System.Type) null;
+		public System.Type WidgetType {
+			get {
+				if (isToolboxItem)
+					return (widgetType);
+				return ((System.Type) null);
+			}
+			set { widgetType = value; }
+		}
+		
+		public ToolboxItemDefinitions AssemblyDefinitions;
+
 		WidgetLibrary library;
 		PropertyDescriptor[] initializationProperties;
 		static PropertyDescriptor[] emptyPropArray = new PropertyDescriptor[0];
@@ -32,14 +64,27 @@
 			else if (cname == null)
 				cname = elem.GetAttribute ("type");
 
-			label = elem.GetAttribute ("label");
+			if (! (IsToolboxItem))
+				label = elem.GetAttribute ("label");
+			else {
+				label = AssemblyDefinitions.Description;
+				if (label == "")
+					label = elem.GetAttribute ("label");
+			}
+			
 			if (label == "")
 				label = WrappedTypeName;
 			
 			if (elem.HasAttribute ("allow-children"))
 				allowChildren = elem.GetAttribute ("allow-children") == "yes";
 				
-			category = elem.GetAttribute ("palette-category");
+			if (! (IsToolboxItem))
+				category = elem.GetAttribute ("palette-category");
+			else {
+				category = AssemblyDefinitions.Category;
+				if (category == "")
+					category = elem.GetAttribute ("palette-category");
+			}
 
 			if (elem.HasAttribute ("deprecated"))
 				deprecated = true;
diff -ruN stetic/libstetic/ItemDescriptor.cs stetic.clean/libstetic/ItemDescriptor.cs
--- stetic/libstetic/ItemDescriptor.cs	2006-06-09 22:59:49.000000000 +0200
+++ stetic.clean/libstetic/ItemDescriptor.cs	2006-06-30 22:59:37.000000000 +0200
@@ -122,6 +122,8 @@
 				} else {
 					object wrapper = ObjectWrapper.Lookup (obj);
 					object res = obj.GetType().InvokeMember (CheckName, BindingFlags.Public | BindingFlags.NonPublic, null, wrapper, null);
+					if (res == null)
+						return (false);
 					return (bool) res;
 				}
 			}
diff -ruN stetic/libstetic/Registry.cs stetic.clean/libstetic/Registry.cs
--- stetic/libstetic/Registry.cs	2006-03-15 16:40:40.000000000 +0100
+++ stetic.clean/libstetic/Registry.cs	2006-06-30 23:22:49.000000000 +0200
@@ -7,15 +7,55 @@
 namespace Stetic {
 	public static class Registry {
 
+		public delegate void PaletteGroupsChanged();
+
+		public class ControlGroup {
+		
+			private string groupname = "";
+			public string GroupName {
+				get { return (groupname); }
+				set { groupname = value; }
+			}
+			
+			private string displayName = "";
+			public string DisplayName {
+				get { return (displayName); }
+				set { displayName = value; }
+			}
+			
+			private int refcount = 1;
+			public int Ref {
+				get { return (refcount); }
+				set { refcount = value; }
+			}
+			
+			public ControlGroup (string aName, string aDisplayname)
+			{
+				GroupName = aName;
+				DisplayName = aDisplayname;
+			}
+		}
+		
 		static ArrayList libraries = new ArrayList ();
 		static ArrayList classes = new ArrayList ();
 		
+		private static ArrayList groups = new ArrayList ();
+		public static ArrayList Groups {
+			get { return (groups); }
+		}
+		
 		static XslTransform gladeImport, gladeExport;
 		static AssemblyWidgetLibrary coreLib;
 		
 		public static event EventHandler RegistryChanging;
 		public static event EventHandler RegistryChanged;
 
+		public static event PaletteGroupsChanged onGroupsChanged = null;
+		public static event PaletteGroupsChanged OnGroupsChanged {
+			add { onGroupsChanged += value; }
+			remove { onGroupsChanged -= value; }
+		}
+		
 		static Registry ()
 		{
 			coreLib = new AssemblyWidgetLibrary (Assembly.GetExecutingAssembly ());
@@ -26,6 +66,45 @@
 			get { return coreLib; }
 		}
 		
+		public static bool ControlGroupExists (string name)
+		{
+			foreach (ControlGroup cg in groups)
+				if (cg.GroupName == name)
+					return (true);
+			return (false);
+		}
+		
+		public static void AddControlGroup (string name, string displayname)
+		{
+			foreach (ControlGroup cg in groups)
+				if (cg.GroupName == name) {
+					cg.Ref++;
+					return;
+				}
+				
+			groups.Add (new ControlGroup (name, displayname));
+			if (onGroupsChanged != null)
+				onGroupsChanged();
+		}
+		
+		public static void RemoveControlGroup (string name)
+		{
+			ControlGroup res = (ControlGroup) null;
+			foreach (ControlGroup cg in groups)
+				if (cg.GroupName == name) {
+					res = cg;
+					break;
+				}
+			if (res != null) {
+				res.Ref--;
+				if (res.Ref <= 0) {
+					groups.Remove (res);
+					if (onGroupsChanged != null)
+						onGroupsChanged();
+				}
+			}
+		}
+		
 		public static void RegisterWidgetLibrary (WidgetLibrary library)
 		{
 			NotifyChanging ();
diff -ruN stetic/libstetic/TypedClassDescriptor.cs stetic.clean/libstetic/TypedClassDescriptor.cs
--- stetic/libstetic/TypedClassDescriptor.cs	2006-05-19 20:32:44.000000000 +0200
+++ stetic.clean/libstetic/TypedClassDescriptor.cs	2006-06-30 23:25:13.000000000 +0200
@@ -1,5 +1,6 @@
 using System;
 using System.Collections;
+using System.ComponentModel;
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Xml;
@@ -13,6 +14,7 @@
 
 		MethodInfo ctorMethodInfo;
 		MethodInfo ctorMethodInfoWithClass;
+		MethodInfo ctorDirectMethodInfoWithClass;
 		ConstructorInfo cinfo;
 		bool useGTypeCtor;
 		Gdk.Pixbuf icon;
@@ -21,9 +23,62 @@
 		
 		static Gdk.Pixbuf missingIcon;
 
+		public bool CheckIsToolboxItem (Assembly aAssembly, string aName)
+		{
+			if (aAssembly == null)
+				return (false);
+			
+			bool ctrl, cat, desc;
+			string name, category, description;
+			foreach (System.Type type in aAssembly.GetExportedTypes()) {
+				if (type.ToString() != aName)
+					continue;
+
+				WidgetType = type;
+				
+				if (type.IsAbstract || type.IsNotPublic) 
+					return (false);
+					
+				Attribute[] attrs = Attribute.GetCustomAttributes (type);
+				
+				ctrl = false; cat = false; desc = false;
+				name = ""; category = ""; description = "";
+				foreach (Attribute attr in attrs) {						
+					if (attr is ToolboxItemAttribute) {
+						if ((attr.Equals(ToolboxItemAttribute.Default) == true) && (type.IsAbstract == false))
+							ctrl = true;
+						name = type.Name;
+					}
+					if (attr is CategoryAttribute) {
+						cat = true;
+						category = (attr as CategoryAttribute).Category;
+					}
+					if (attr is DescriptionAttribute) {
+						desc = true;
+						description = (attr as DescriptionAttribute).Description;
+					}
+				}
+
+				if ((! cat) && ctrl)
+					category = "[Unsorted]";
+				if ((! desc) && ctrl)
+					description = name;
+				
+				if (ctrl) {
+					if (Registry.ControlGroupExists(category) == false)
+						Registry.AddControlGroup (category, category);
+					AssemblyDefinitions = new ToolboxItemDefinitions (name, category, description);
+				}
+				return (ctrl);
+			}
+			return (false);
+		}
+		
 		public TypedClassDescriptor (Assembly assembly, XmlElement elem)
 		{
 			wrapped = Registry.GetType (elem.GetAttribute ("type"), true);
+			IsToolboxItem = CheckIsToolboxItem(assembly, elem.GetAttribute ("type"));
+
 			if (elem.HasAttribute ("wrapper"))
 			    wrapper = Registry.GetType (elem.GetAttribute ("wrapper"), true);
 			else {
@@ -55,6 +110,11 @@
 			
 			BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly;
 						
+			// Search if type provides its own CreateWrappedInstance which will override default wrapper control
+			ctorDirectMethodInfoWithClass = null;
+			foreach (System.Reflection.MethodInfo mtd in wrapped.GetMethods())
+				if ((mtd.Name == "CreateWrappedInstance") && (mtd.IsStatic == true) && (mtd.GetParameters().Length == 1))
+					ctorDirectMethodInfoWithClass = mtd;
 
 			ctorMethodInfoWithClass = wrapper.GetMethod ("CreateInstance", flags, null, new Type[] { typeof(ClassDescriptor)}, null);
 			if (ctorMethodInfoWithClass == null) {
@@ -111,6 +171,10 @@
 		{
 			object inst;
 
+			if (ctorDirectMethodInfoWithClass != null) {
+				inst = ctorDirectMethodInfoWithClass.Invoke (null, new object[] { this });
+				if (inst != null) return inst;
+			}
 			if (ctorMethodInfoWithClass != null) {
 				inst = ctorMethodInfoWithClass.Invoke (null, new object[] { this });
 				if (inst != null) return inst;
diff -ruN stetic/libstetic/wrapper/objects.xml stetic.clean/libstetic/wrapper/objects.xml
--- stetic/libstetic/wrapper/objects.xml	2006-06-12 18:56:28.000000000 +0200
+++ stetic.clean/libstetic/wrapper/objects.xml	2006-06-30 22:59:37.000000000 +0200
@@ -1380,7 +1380,7 @@
 		<property name="Adjustment.PageSize" />
 		<property name="Adjustment.StepIncrement" />
 	    </itemgroup>
-	    <itemgroup label="Spin Button Properties" important="true">
+	    <itemgroup label="Spin Button Properties" name="SpinProperties" important="true">
 		<property name="ClimbRate" />
 		<property name="Digits" />
 		<property name="Numeric" />
diff -ruN stetic/libsteticui/Palette.cs stetic.clean/libsteticui/Palette.cs
--- stetic/libsteticui/Palette.cs	2006-06-08 14:37:25.000000000 +0200
+++ stetic.clean/libsteticui/Palette.cs	2006-06-30 23:19:10.000000000 +0200
@@ -19,21 +19,57 @@
 		public Palette () : base (false, 0)
 		{
 			groups = new Hashtable ();
-			Registry.RegistryChanged += OnRegistryChanged;
 			
-			ShowGroup ("window", "Windows");
-			ShowGroup ("widget", "Widgets");
-			ShowGroup ("container", "Containers");
+			Registry.AddControlGroup ("window", "Windows");
+			Registry.AddControlGroup  ("widget", "Widgets");
+			Registry.AddControlGroup  ("container", "Containers");
 //			ShowGroup ("toolbaritem", "Toolbar Items");
-			ShowGroup ("actions", "Actions");
+			Registry.AddControlGroup  ("actions", "Actions");
+
+			Registry.RegistryChanged += OnRegistryChanged;
+			Registry.OnGroupsChanged += OnGroupsChanged;
+			// Enforce the first time
+			OnGroupsChanged();
 		}
 		
 		public override void Dispose ()
 		{
+			Registry.OnGroupsChanged -= OnGroupsChanged;
 			Registry.RegistryChanged -= OnRegistryChanged;
 			base.Dispose ();
 		}
 		
+		internal bool GroupExists (string name)
+		{
+			foreach (string[] str in visibleGroups)
+				if (str[0] == name)
+					return (true);
+			return (false);
+		}
+		
+		internal bool RegistryGroupExists (string name)
+		{
+			foreach (Registry.ControlGroup grp in Registry.Groups)
+				if (grp.GroupName == name)
+					return (true);
+			return (false);
+		}
+		
+		public void OnGroupsChanged ()
+		{
+			// First show new groups
+			foreach (Registry.ControlGroup cg in Registry.Groups)
+				if (GroupExists(cg.GroupName) == false)
+					ShowGroup (cg.GroupName, cg.DisplayName);
+			// Then delete non-existant
+			if (visibleGroups.Count > 0)
+				for (int i=visibleGroups.Count-1; i>=0; i--) {
+					string[] grp = (string[]) visibleGroups[i];
+					if (RegistryGroupExists(grp[0]) == false)
+						HideGroup (grp[0]);
+				}
+		}
+		
 		public Palette (Project project): this ()
 		{
 			this.Project = project;
diff -ruN stetic/stetic/Stetic.cs stetic.clean/stetic/Stetic.cs
--- stetic/stetic/Stetic.cs	2006-06-08 14:37:25.000000000 +0200
+++ stetic.clean/stetic/Stetic.cs	2006-06-30 22:59:37.000000000 +0200
@@ -105,6 +105,9 @@
 			Glade.XML glade = new Glade.XML ("stetic.glade", null);
 			glade.Autoconnect (typeof (SteticMain));
 
+			foreach (string lib in libraries)
+				Registry.RegisterWidgetLibrary (new AssemblyWidgetLibrary (lib));
+			
 			if (ProjectView.Parent is Gtk.Viewport &&
 			    ProjectView.Parent.Parent is Gtk.ScrolledWindow) {
 				Gtk.Viewport viewport = (Gtk.Viewport)ProjectView.Parent;
