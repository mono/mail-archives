Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Utility/DiffUtility.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Utility/DiffUtility.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Utility/DiffUtility.cs	(working copy)
@@ -60,7 +60,10 @@
 		static public int Compare(IList a, IList b, IComparer comparer)
 		{
 			if (a == null || b == null) {
-				return 1;
+				if (a == b)
+					return 0;
+				else
+					return (a == null) ? -1 : 1;
 			}
 			int limit = (a.Count < b.Count) ? a.Count : b.Count;
 			for(int i=0; i < limit; i++) {
@@ -82,7 +85,10 @@
 		static public int Compare(SortedList a, SortedList b, IComparer comparer)
 		{
 			if (a == null || b == null) {
-				return 1;
+				if (a == b)
+					return 0;
+				else
+					return (a == null) ? -1 : 1;
 			}
 			int cmp;
 			int limit = (a.Count < b.Count) ? a.Count : b.Count;
Index: Core/src/MonoDevelop.Projects/ChangeLog
===================================================================
--- Core/src/MonoDevelop.Projects/ChangeLog	(revision 62252)
+++ Core/src/MonoDevelop.Projects/ChangeLog	(working copy)
@@ -1,3 +1,29 @@
+2006-07-05 Matej Urbas <matej.urbas@gmail.com>
+
+	* MonoDevelop.Projects.Utility/DiffUtility.cs: Changed the comparison
+	  methods to allow comparison between null and non-null arguments.
+	
+	* MonoDevelop.Projects.Parser/IClass.cs:
+	* MonoDevelop.Projects.Parser/IMethod.cs:
+	* MonoDevelop.Projects.Parser/IReturnType.cs:
+	* MonoDevelop.Projects.Parser/AbstractClass.cs:
+	* MonoDevelop.Projects.Parser/AbstractReturnType.cs:
+	* MonoDevelop.Projects.Parser/ClassProxy.cs:
+	* MonoDevelop.Projects.Parser/AbstractMethod.cs:
+	  Extended all above interfaces and classes to provide generics support.
+	
+	* MonoDevelop.Projects.Parser/GenericParameter.cs:
+	* MonoDevelop.Projects.Parser/GenericParameterList.cs:
+	* MonoDevelop.Projects.Parser/ReturnTypeList.cs:
+	  Added above files to the project.
+
+	* MonoDevelop.Projects.CodeGeneration/CodeRefactorer.cs: Updated to use 
+	  ReturnType as BaseTypes in IClass instances.
+	
+	* MonoDevelop.Projects.mdp: Added new file to the build process.
+	
+	* Makefile.am: Added new files to the build process.
+
 2006-07-03 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* MonoDevelop.Projects/ProjectReference.cs: Remove the DataItemAttribute,
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.mdp
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.mdp	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.mdp	(working copy)
@@ -13,6 +13,7 @@
       <CodeGeneration compiler="Csc" warninglevel="4" optimize="True" unsafecodeallowed="False" generateoverflowchecks="True" mainclass="" generatexmldocumentation="False" ctype="CSharpCompilerParameters" />
     </Configuration>
   </Configurations>
+  <DeployTargets />
   <DeploymentInformation strategy="File">
     <excludeFiles />
   </DeploymentInformation>
@@ -218,6 +219,9 @@
     <File name="./MonoDevelop.Projects/ExecutionContext.cs" subtype="Code" buildaction="Compile" />
     <File name="./MonoDevelop.Projects/BuildTool.cs" subtype="Code" buildaction="Compile" />
     <File name="./MonoDevelop.Projects/ProjectsServices.cs" subtype="Code" buildaction="Compile" />
+    <File name="./MonoDevelop.Projects.Parser/GenericParameter.cs" subtype="Code" buildaction="Compile" />
+    <File name="./MonoDevelop.Projects.Parser/ReturnTypeList.cs" subtype="Code" buildaction="Compile" />
+    <File name="./MonoDevelop.Projects.Parser/GenericParameterList.cs" subtype="Code" buildaction="Compile" />
     <File name="./MonoDevelop.Projects.Extensions/DataTypeCodon.cs" subtype="Code" buildaction="Compile" />
     <File name="./MonoDevelop.Projects.Deployment" subtype="Directory" buildaction="Compile" />
     <File name="./MonoDevelop.Projects.Deployment/DeployService.cs" subtype="Code" buildaction="Compile" />
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.CodeGeneration/CodeRefactorer.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.CodeGeneration/CodeRefactorer.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.CodeGeneration/CodeRefactorer.cs	(working copy)
@@ -158,12 +158,12 @@
 		
 		bool IsSubclass (IParserContext ctx, IClass baseClass, IClass subclass)
 		{
-			foreach (string clsName in subclass.BaseTypes)
-				if (clsName == baseClass.FullyQualifiedName)
+			foreach (IReturnType clsName in subclass.BaseTypes)
+				if (clsName.FullyQualifiedName == baseClass.FullyQualifiedName)
 					return true;
 
-			foreach (string clsName in subclass.BaseTypes) {
-				IClass cls = ctx.GetClass (clsName, true, true);
+			foreach (IReturnType clsName in subclass.BaseTypes) {
+				IClass cls = ctx.GetClass (clsName.FullyQualifiedName, true, true);
 				if (cls != null && IsSubclass (ctx, baseClass, cls))
 					return true;
 			}
Index: Core/src/MonoDevelop.Projects/Makefile.am
===================================================================
--- Core/src/MonoDevelop.Projects/Makefile.am	(revision 62252)
+++ Core/src/MonoDevelop.Projects/Makefile.am	(working copy)
@@ -219,6 +219,9 @@
 MonoDevelop.Projects/ExecutionContext.cs \
 MonoDevelop.Projects/BuildTool.cs \
 MonoDevelop.Projects/ProjectsServices.cs \
+MonoDevelop.Projects.Parser/GenericParameter.cs \
+MonoDevelop.Projects.Parser/ReturnTypeList.cs \
+MonoDevelop.Projects.Parser/GenericParameterList.cs \
 MonoDevelop.Projects/UnknownCombineEntry.cs \
 MonoDevelop.Projects.Documentation/IDocumentationService.cs
 
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/IClass.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/IClass.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/IClass.cs	(working copy)
@@ -9,6 +9,7 @@
 using System.Collections;
 using System.Collections.Specialized;
 using System.Reflection;
+using MonoDevelop.Projects.Parser;
 
 namespace MonoDevelop.Projects.Parser
 {
@@ -38,10 +39,23 @@
 			get;
 		}
 		
-		StringCollection BaseTypes {
+		/* Reasoning behind the 'null' isGeneric indication: since most classes
+		   are not generic, it is best not to create string collections to hold
+		   type parameters and use the 'null' value to indicate that a type is
+		   not generic */
+		/// <summary>
+		/// Contains a set of formal parameters to a generic type. 
+		/// <p>If this property returns null or an empty collection, the type is
+		/// not generic.</p>
+		/// </summary>
+		GenericParameterList GenericParameters {
 			get;
 		}
 		
+		ReturnTypeList BaseTypes {
+			get;
+		}
+		
 		ClassCollection InnerClasses {
 			get;
 		}
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/ReflectionClass.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/ReflectionClass.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/ReflectionClass.cs	(working copy)
@@ -88,13 +88,13 @@
 			
 			// set base classes
 			if (type.BaseType != null) { // it's null for System.Object ONLY !!!
-				baseTypes.Add(type.BaseType.FullName);
+				baseTypes.Add(new ReflectionReturnType(type.BaseType));
 			}
 			
 			if (classType != ClassType.Delegate) {
 				// add members
 				foreach (TypeReference iface in type.Interfaces) {
-					baseTypes.Add(iface.FullName);
+					baseTypes.Add(new ReflectionReturnType(iface));
 				}
 				
 				foreach (TypeDefinition nestedType in type.NestedTypes) {
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/PersistentClass.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/PersistentClass.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/PersistentClass.cs	(working copy)
@@ -35,8 +35,10 @@
 			cls.modifiers          = sclass.Modifiers;
 			cls.classType          = sclass.ClassType;
 
-			foreach (string t in sclass.BaseTypes)
-				cls.baseTypes.Add (typeResolver.Resolve (t));
+			foreach (IReturnType t in sclass.BaseTypes)
+			{
+				cls.baseTypes.Add (PersistentReturnType.Resolve(t, typeResolver));
+			}
 			
 			foreach (IClass c in sclass.InnerClasses) {
 				PersistentClass pc = PersistentClass.Resolve (c, typeResolver);
@@ -92,7 +94,7 @@
 
 			uint count = reader.ReadUInt32();
 			for (uint i = 0; i < count; ++i) {
-				cls.baseTypes.Add (PersistentHelper.ReadString (reader, nameTable));
+				cls.baseTypes.Add (PersistentReturnType.Read (reader, nameTable));
 			}
 			
 			count = reader.ReadUInt32();
@@ -150,10 +152,10 @@
 				
 			writer.Write((uint)cls.Modifiers);
 			writer.Write((short)cls.ClassType);
-
+				
 			writer.Write((uint)(cls.BaseTypes.Count));
-			foreach (string baseType in cls.BaseTypes)
-				PersistentHelper.WriteString (baseType, writer, nameTable);
+			foreach (IReturnType baseType in cls.BaseTypes)
+				PersistentReturnType.WriteTo(baseType, writer, nameTable);
 
 			writer.Write((uint)cls.InnerClasses.Count);
 			foreach (IClass innerClass in cls.InnerClasses) {
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/IMethod.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/IMethod.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/IMethod.cs	(working copy)
@@ -22,5 +22,14 @@
 		bool IsConstructor {
 			get;
 		}
+		
+		/// <summary>
+		/// Contains a list of formal parameters to a generic method. 
+		/// <p>If this property returns null or an empty collection, the method
+		/// is not generic.</p>
+		/// </summary>
+		GenericParameterList GenericParameters {
+			get;
+		}
 	}
 }
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/AbstractClass.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/AbstractClass.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/AbstractClass.cs	(working copy)
@@ -20,9 +20,10 @@
 		protected IRegion          region;
 		protected IRegion          bodyRegion;
 		protected object           declaredIn;
+		
+		protected GenericParameterList genericParamters;
+		protected ReturnTypeList     baseTypes    = new ReturnTypeList();
 
-		protected StringCollection baseTypes       = new StringCollection();
-
 		protected ClassCollection    innerClasses = new ClassCollection();
 		protected FieldCollection    fields       = new FieldCollection();
 		protected PropertyCollection properties   = new PropertyCollection();
@@ -57,8 +58,22 @@
 				return declaredIn;
 			}
 		}
+		
+		/// <summary>
+		/// Contains a list of formal parameters to a generic type. 
+		/// <p>If this property returns null or an empty collection, the type is
+		/// not generic.</p>
+		/// </summary>
+		public virtual GenericParameterList GenericParameters {
+			get {
+				return genericParamters;
+			}
+			set {
+				genericParamters = value;
+			}
+		}
 
-		public virtual StringCollection BaseTypes {
+		public virtual ReturnTypeList BaseTypes {
 			get {
 				return baseTypes;
 			}
@@ -154,7 +169,15 @@
 			if(cmp != 0)
 				return cmp;
 			
-			return DiffUtility.Compare(Events, value.Events);
+			cmp = DiffUtility.Compare(Events, value.Events);
+			if (cmp != 0)
+				return cmp;
+			
+			if (value.GenericParameters == GenericParameters)
+				return 0;	// They are the same classes or are both null - 
+							// which counts as 'being same'
+			else
+				return DiffUtility.Compare(GenericParameters, value.GenericParameters);
 		}
 		
 		public override bool Equals (object ob)
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/AbstractReturnType.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/AbstractReturnType.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/AbstractReturnType.cs	(working copy)
@@ -15,6 +15,7 @@
 		protected int    pointerNestingLevel;
 		protected int[]  arrayDimensions;
 		protected object declaredin = null;
+		protected ReturnTypeList genericArguments;
 		string fname;
 		
 		public virtual string FullyQualifiedName {
@@ -74,6 +75,19 @@
 				return arrayDimensions;
 			}
 		}
+		 		
+		/// <summary>
+		/// Contains values (types) of actual parameters (arguments) to a
+		/// generic type.
+		/// </summary>
+		public virtual ReturnTypeList GenericArguments {
+			get {
+				return genericArguments;
+			}
+			set {
+				genericArguments = value;
+			}
+		}
 
 		public virtual int CompareTo (object ob) 
 		{
@@ -95,7 +109,14 @@
 				return cmp;
 			}
 			
-			return DiffUtility.Compare(ArrayDimensions, value.ArrayDimensions);
+			cmp = DiffUtility.Compare(ArrayDimensions, value.ArrayDimensions);
+			if (cmp != 0)
+				return cmp;
+			
+			if (GenericArguments == value.GenericArguments)
+				return 0;
+			else
+				return DiffUtility.Compare(GenericArguments, value.GenericArguments);
 		}
 		
 		int IComparable.CompareTo(object value)
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/DefaultParserService.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/DefaultParserService.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/DefaultParserService.cs	(working copy)
@@ -1638,8 +1638,10 @@
 
 		void PutBaseClassesOnStack(IClass c)
 		{
-			foreach (string baseTypeName in c.BaseTypes)
-				baseTypeQueue.Enqueue(baseTypeName);
+			foreach (IReturnType baseType in c.BaseTypes)
+			{
+				baseTypeQueue.Enqueue(baseType.FullyQualifiedName);
+			}
 		}
 
 		public IClass Current {
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/IReturnType.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/IReturnType.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/IReturnType.cs	(working copy)
@@ -35,6 +35,13 @@
 		object DeclaredIn {
 			get;
 		}
-		
+		 		
+		/// <summary>
+		/// Contains values (types) of actual parameters (arguments) to a
+		/// generic type.
+		/// </summary>
+		ReturnTypeList GenericArguments {
+			get;
+		}
 	}
 }
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/ClassProxy.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/ClassProxy.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/ClassProxy.cs	(working copy)
@@ -94,12 +94,23 @@
 			}
 		}
 		
-		public StringCollection BaseTypes {
+		/// <summary>
+		/// Contains a list of formal parameters to a generic type. 
+		/// <p>If this property returns null or an empty collection, the type is
+		/// not generic.</p>
+		/// </summary>
+		public GenericParameterList GenericParameters {
 			get {
-				return new StringCollection();
+				return null;
 			}
 		}
 		
+		public ReturnTypeList  BaseTypes {
+			get {
+				return new ReturnTypeList();
+			}
+		}
+		
 		public ClassCollection InnerClasses {
 			get {
 				return new ClassCollection();
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/CodeCompletionDatabase.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/CodeCompletionDatabase.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/CodeCompletionDatabase.cs	(working copy)
@@ -47,7 +47,7 @@
 	{
 		static readonly int MAX_ACTIVE_COUNT = 100;
 		static readonly int MIN_ACTIVE_COUNT = 50;
-		static protected readonly int FORMAT_VERSION = 6;
+		static protected readonly int FORMAT_VERSION = 7;
 		
 		NamespaceEntry rootNamespace;
 		protected ArrayList references;
Index: Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/AbstractMethod.cs
===================================================================
--- Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/AbstractMethod.cs	(revision 62252)
+++ Core/src/MonoDevelop.Projects/MonoDevelop.Projects.Parser/AbstractMethod.cs	(working copy)
@@ -15,6 +15,7 @@
 	{
 		protected IRegion bodyRegion;
 		
+		protected GenericParameterList genericParameters;
 		protected ParameterCollection parameters = new ParameterCollection();
 
 		public virtual IRegion BodyRegion {
@@ -31,6 +32,20 @@
 				parameters = value;
 			}
 		}
+		
+		/// <summary>
+		/// Contains a list of formal parameters to a generic method. 
+		/// <p>If this property returns null or an empty collection, the method
+		/// is not generic.</p>
+		/// </summary>
+		public virtual GenericParameterList GenericParameters {
+			get {
+				return genericParameters;
+			}
+			set {
+				genericParameters = value;
+			}
+		}
 
 		public virtual bool IsConstructor {
 			get {
@@ -53,7 +68,14 @@
 			if (cmp != 0)
 				return cmp;
 			
-			return DiffUtility.Compare(Parameters, ((IMethod)value).Parameters);
+			cmp = DiffUtility.Compare(Parameters, ((IMethod)value).Parameters);
+			if (cmp != 0)
+				return cmp;
+				
+			if (GenericParameters == ((IMethod)value).GenericParameters)
+				return 0;
+			else
+				return DiffUtility.Compare(GenericParameters, ((IMethod)value).GenericParameters);
 		}
 		
 		public override bool Equals (object ob)
Index: Core/src/MonoDevelop.Ide/ChangeLog
===================================================================
--- Core/src/MonoDevelop.Ide/ChangeLog	(revision 62252)
+++ Core/src/MonoDevelop.Ide/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2006-07-05 Matej Urbas <matej.urbas@gmail.com>
+
+	* MonoDevelop.Ide.Commands/RefactoryCommands.cs: Updated to use ReturnType
+	  as BaseTypes in IClass instances.
+
 2006-07-04  Michael Hutchinson <m.j.hutchinson@gmail.com>
 
 	* Core/src/MonoDevelop.Ide/MonoDevelop.Ide.addin.xml:
Index: Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Commands/RefactoryCommands.cs
===================================================================
--- Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Commands/RefactoryCommands.cs	(revision 62252)
+++ Core/src/MonoDevelop.Ide/MonoDevelop.Ide.Commands/RefactoryCommands.cs	(working copy)
@@ -225,8 +225,8 @@
 			if (cls == null) return;
 			
 			if (cls.BaseTypes != null) {
-				foreach (string bc in cls.BaseTypes) {
-					IClass bcls = ctx.GetClass (bc, true, true);
+				foreach (IReturnType bc in cls.BaseTypes) {
+					IClass bcls = ctx.GetClass (bc.FullyQualifiedName, true, true);
 					if (bcls != null && bcls.ClassType != ClassType.Interface && bcls.Region != null) {
 						IdeApp.Workbench.OpenDocument (bcls.Region.FileName, bcls.Region.BeginLine, bcls.Region.BeginColumn, true);
 						return;
Index: Extras/NemerleBinding/ChangeLog
===================================================================
--- Extras/NemerleBinding/ChangeLog	(revision 62252)
+++ Extras/NemerleBinding/ChangeLog	(working copy)
@@ -1,3 +1,7 @@
+2006-07-05 Matej Urbas <matej.urbas@gmail.com>
+
+	* Parser/SharpDevelopTree/Class.cs: Updated to use ReturnType as BaseTypes.
+
 2006-07-03 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* NemerleLanguageBinding.cs:
Index: Extras/NemerleBinding/Parser/SharpDevelopTree/Class.cs
===================================================================
--- Extras/NemerleBinding/Parser/SharpDevelopTree/Class.cs	(revision 62252)
+++ Extras/NemerleBinding/Parser/SharpDevelopTree/Class.cs	(working copy)
@@ -217,7 +217,7 @@
             
             foreach (NCC.MType.Class mt in tinfo.GetDirectSuperTypes ())
             {
-                baseTypes.Add (Engine.GetNameFromType (mt));
+                baseTypes.Add (new ReturnType(mt));
             }
             
             LoadXml ();
Index: Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore/GtkCoreService.cs
===================================================================
--- Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore/GtkCoreService.cs	(revision 62252)
+++ Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore/GtkCoreService.cs	(working copy)
@@ -343,12 +343,12 @@
 		
 		static bool IsWidget (IClass cls, IParserContext pctx)
 		{
-			foreach (string bt in cls.BaseTypes)
-				if (bt == "Gtk.Widget")
+			foreach (IReturnType bt in cls.BaseTypes)
+				if (bt.FullyQualifiedName == "Gtk.Widget")
 					return true;
 
-			foreach (string bt in cls.BaseTypes) {
-				IClass bcls = pctx.GetClass (bt, true, true);
+			foreach (IReturnType bt in cls.BaseTypes) {
+				IClass bcls = pctx.GetClass (bt.FullyQualifiedName, true, true);
 				if (bcls != null)
 					return IsWidget (bcls, pctx);
 			}
Index: Extras/MonoDevelop.GtkCore/ChangeLog
===================================================================
--- Extras/MonoDevelop.GtkCore/ChangeLog	(revision 62252)
+++ Extras/MonoDevelop.GtkCore/ChangeLog	(working copy)
@@ -1,3 +1,12 @@
+2006-07-05 Matej Urbas <matej.urbas@gmail.com>
+
+	* MonoDevelop.GtkCore/GtkCoreService.cs:
+	* MonoDevelop.GtkCore.GuiBuilder/ActionGroupDisplayBinding.cs:
+	* MonoDevelop.GtkCore.GuiBuilder/CodeBinder:
+	* MonoDevelop.GtkCore.GuiBuilder/GuiBuilderWindow.cs:
+	* MonoDevelop.GtkCore.WidgetLibrary/BaseWidgetLibrary.cs: Updated to use
+	  ReturnType as BaseTypes in IClass instances.
+
 2006-07-03 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* lib/*: Updated from Stetic module.
Index: Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.WidgetLibrary/BaseWidgetLibrary.cs
===================================================================
--- Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.WidgetLibrary/BaseWidgetLibrary.cs	(revision 62252)
+++ Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.WidgetLibrary/BaseWidgetLibrary.cs	(working copy)
@@ -80,14 +80,14 @@
 		
 		Stetic.ClassDescriptor FindType (IParserContext ctx, IClass cls)
 		{
-			foreach (string baseType in cls.BaseTypes) {
-				IClass bc = ctx.GetClass (baseType);
+			foreach (IReturnType baseType in cls.BaseTypes) {
+				IClass bc = ctx.GetClass (baseType.FullyQualifiedName);
 				if (bc == null)
 					continue;
 				if (bc.ClassType == ClassType.Interface)
 					continue;
 
-				Stetic.ClassDescriptor klass = Stetic.Registry.LookupClassByName (baseType);
+				Stetic.ClassDescriptor klass = Stetic.Registry.LookupClassByName (baseType.FullyQualifiedName);
 				if (klass != null) return klass;
 				
 				klass = FindType (ctx, bc);
Index: Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/ActionGroupDisplayBinding.cs
===================================================================
--- Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/ActionGroupDisplayBinding.cs	(revision 62252)
+++ Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/ActionGroupDisplayBinding.cs	(working copy)
@@ -199,11 +199,11 @@
 		internal static bool IsValidClass (IParserContext ctx, IClass cls)
 		{
 			if (cls.BaseTypes != null) {
-				foreach (string bt in cls.BaseTypes) {
-					if (bt == "Gtk.ActionGroup")
+				foreach (IReturnType bt in cls.BaseTypes) {
+					if (bt.FullyQualifiedName == "Gtk.ActionGroup")
 						return true;
 					
-					IClass baseCls = ctx.GetClass (bt, true, true);
+					IClass baseCls = ctx.GetClass (bt.FullyQualifiedName, true, true);
 					if (baseCls != null && IsValidClass (ctx, baseCls))
 						return true;
 				}
Index: Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/GuiBuilderWindow.cs
===================================================================
--- Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/GuiBuilderWindow.cs	(revision 62252)
+++ Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/GuiBuilderWindow.cs	(working copy)
@@ -274,11 +274,11 @@
 		internal bool IsValidClass (IParserContext ctx, IClass cls)
 		{
 			if (cls.BaseTypes != null) {
-				foreach (string bt in cls.BaseTypes) {
-					if (bt == rootWidget.Wrapped.GetType().FullName)
+				foreach (IReturnType bt in cls.BaseTypes) {
+					if (bt.FullyQualifiedName == rootWidget.Wrapped.GetType().FullName)
 						return true;
 					
-					IClass baseCls = ctx.GetClass (bt, true, true);
+					IClass baseCls = ctx.GetClass (bt.FullyQualifiedName, true, true);
 					if (IsValidClass (ctx, baseCls))
 						return true;
 				}
Index: Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/CodeBinder.cs
===================================================================
--- Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/CodeBinder.cs	(revision 62252)
+++ Extras/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/CodeBinder.cs	(working copy)
@@ -302,11 +302,11 @@
 		{
 			if (cls.BaseTypes != null) {
 				string typeName = GetObjectTypeName (obj);
-				foreach (string bt in cls.BaseTypes) {
-					if (bt == typeName)
+				foreach (IReturnType bt in cls.BaseTypes) {
+					if (bt.FullyQualifiedName == typeName)
 						return true;
 					
-					IClass baseCls = ctx.GetClass (bt, true, true);
+					IClass baseCls = ctx.GetClass (bt.FullyQualifiedName, true, true);
 					if (baseCls != null && IsValidClass (ctx, baseCls, obj))
 						return true;
 				}
Index: Extras/VBNetBinding/ChangeLog
===================================================================
--- Extras/VBNetBinding/ChangeLog	(revision 62252)
+++ Extras/VBNetBinding/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2006-07-05 Matej Urbas <matej.urbas@gmail.com>
+
+	* Parser/VBNetVisitor.cs:
+	* Parser/Resolver.cs: Updated to use ReturnType as BaseTypes in IClass
+	  instances.
+
 2006-07-03 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* VBLanguageBinding.cs:
Index: Extras/VBNetBinding/Parser/VBNetVisitor.cs
===================================================================
--- Extras/VBNetBinding/Parser/VBNetVisitor.cs	(revision 62252)
+++ Extras/VBNetBinding/Parser/VBNetVisitor.cs	(working copy)
@@ -100,8 +100,8 @@
 				cu.Classes.Add(c);
 			}
 			if (typeDeclaration.BaseTypes != null) {
-				foreach (AST.TypeReference type in typeDeclaration.BaseTypes) {
-					c.BaseTypes.Add(type.Type);
+				foreach (AST.TypeReference type in typeDeclaration.BaseTypes) {
+					c.BaseTypes.Add(new ReturnType(type.Type));
 				}
 			}
 			currentClass.Push(c);
Index: Extras/VBNetBinding/Parser/Resolver.cs
===================================================================
--- Extras/VBNetBinding/Parser/Resolver.cs	(revision 62252)
+++ Extras/VBNetBinding/Parser/Resolver.cs	(working copy)
@@ -533,8 +533,8 @@
 			}
 //			Console.WriteLine("ClassType = " + curType.ClassType);
 			if (curType.ClassType == ClassType.Interface && !showStatic) {
-				foreach (string s in curType.BaseTypes) {
-					IClass baseClass = parserContext.GetClass (s, true, false);
+				foreach (IReturnType s in curType.BaseTypes) {
+					IClass baseClass = parserContext.GetClass (s.FullyQualifiedName, true, false);
 					if (baseClass != null && baseClass.ClassType == ClassType.Interface) {
 						ListMembers(members, baseClass);
 					}
@@ -567,8 +567,8 @@
 			}
 //			Console.WriteLine("ClassType = " + curType.ClassType);
 			if (curType.ClassType == ClassType.Interface && !showStatic) {
-				foreach (string s in curType.BaseTypes) {
-					IClass baseClass = parserContext.GetClass (s, true, false);
+				foreach (IReturnType s in curType.BaseTypes) {
+					IClass baseClass = parserContext.GetClass (s.FullyQualifiedName, true, false);
 					if (baseClass != null && baseClass.ClassType == ClassType.Interface) {
 						ListTypes(members, baseClass);
 					}
@@ -781,8 +781,8 @@
 					return m.ReturnType;
 				}
 			}
-			foreach (string baseType in curType.BaseTypes) {
-				IClass c = SearchType(baseType, curType);
+			foreach (IReturnType baseType in curType.BaseTypes) {
+				IClass c = SearchType(baseType.FullyQualifiedName, curType);
 				if (c != null) {
 					IReturnType erg = SearchMember(new ReturnType(c.FullyQualifiedName), memberName);
 					if (erg != null) {
@@ -1130,8 +1130,8 @@
 	
 		public IClass BaseClass(IClass curClass)
 		{
-			foreach (string s in curClass.BaseTypes) {
-				IClass baseClass = parserContext.GetClass (s, true, false);
+			foreach (IReturnType s in curClass.BaseTypes) {
+				IClass baseClass = parserContext.GetClass (s.FullyQualifiedName, true, false);
 				if (baseClass != null && baseClass.ClassType != ClassType.Interface) {
 					return baseClass;
 				}
@@ -1179,8 +1179,8 @@
 			if (possibleBaseClass.FullyQualifiedName == c.FullyQualifiedName) {
 				return true;
 			}
-			foreach (string baseClass in c.BaseTypes) {
-				IClass bc = parserContext.GetClass (baseClass, true, false);
+			foreach (IReturnType baseClass in c.BaseTypes) {
+				IClass bc = parserContext.GetClass (baseClass.FullyQualifiedName, true, false);
 				if (IsClassInInheritanceTree(possibleBaseClass, bc)) {
 					return true;
 				}
Index: Extras/BooBinding/ChangeLog
===================================================================
--- Extras/BooBinding/ChangeLog	(revision 62252)
+++ Extras/BooBinding/ChangeLog	(working copy)
@@ -1,3 +1,8 @@
+2006-07-05 Matej Urbas <matej.urbas@gmail.com>
+
+	* Parser/Visitor.boo: Updated to use ReturnType as BaseTypes in IClass
+	  instances.
+
 2006-07-03 Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* BooBinding.addin.xml: Updated versions.
Index: Extras/BooBinding/Parser/Visitor.boo
===================================================================
--- Extras/BooBinding/Parser/Visitor.boo	(revision 62252)
+++ Extras/BooBinding/Parser/Visitor.boo	(working copy)
@@ -124,7 +124,8 @@
 		region = GetRegion(node)
 		modifier = GetModifier(node)
 		c = Class(_cu, ClassType.Delegate, modifier, region)
-		c.BaseTypes.Add('System.Delegate')
+		// TODO: Check how a return type with type System.Delegate dan be created
+		c.BaseTypes.Add(ReturnType('System.Delegate'))
 		c.FullyQualifiedName = node.FullName
 		if _currentClass.Count > 0:
 			cast(Class, _currentClass.Peek()).InnerClasses.Add(c)
@@ -167,7 +168,8 @@
 				_cu.Classes.Add(c) unless c.Name.StartsWith ("___")
 			if node.BaseTypes != null:
 				for r as AST.SimpleTypeReference in node.BaseTypes:
-					c.BaseTypes.Add(r.Name)
+					// TODO: Check how a return type with type System.Delegate dan be created
+					c.BaseTypes.Add(ReturnType(r.Name))
 			_currentClass.Push(c)
 		except ex:
 			Error (ex.ToString ())
Index: Extras/CSharpBinding/ChangeLog
===================================================================
--- Extras/CSharpBinding/ChangeLog	(revision 62252)
+++ Extras/CSharpBinding/ChangeLog	(working copy)
@@ -1,3 +1,12 @@
+2006-07-05 Matej Urbas <matej.urbas@gmail.com>
+
+	* CSharpAmbience.cs: Fixed a regression that displayed all base types of a
+	  class to be of PersistentReturnType type.
+	* Parser/CodeGenerator.cs:
+	* Parser/CSharpVisitor.cs:
+	* Parser/Resolver.cs: Updated to use ReturnType as BaseTypes in IClass
+	  instances.
+
 2006-07-04  Michael Hutchinson <m.j.hutchinson@gmail.com>
 
 	* CSharpEnhancedCodeProvider.cs: Fix parsing of imports
Index: Extras/CSharpBinding/Parser/CSharpVisitor.cs
===================================================================
--- Extras/CSharpBinding/Parser/CSharpVisitor.cs	(revision 62252)
+++ Extras/CSharpBinding/Parser/CSharpVisitor.cs	(working copy)
@@ -165,7 +165,7 @@
 			}
 			if (typeDeclaration.BaseTypes != null) {
 				foreach (ICSharpCode.NRefactory.Parser.AST.TypeReference type in typeDeclaration.BaseTypes) {
-					c.BaseTypes.Add(type.Type);
+					c.BaseTypes.Add(new ReturnType(type.Type));
 				}
 			}
 			currentClass.Push(c);
Index: Extras/CSharpBinding/Parser/CodeGenerator.cs
===================================================================
--- Extras/CSharpBinding/Parser/CodeGenerator.cs	(revision 62252)
+++ Extras/CSharpBinding/Parser/CodeGenerator.cs	(working copy)
@@ -177,8 +177,8 @@
 				return true;
 				
 			if (type.BaseTypes != null) {
-				foreach (string bc in type.BaseTypes) {
-					IClass bcls = ctx.ParserContext.GetClass (bc, true, true);
+				foreach (IReturnType bc in type.BaseTypes) {
+					IClass bcls = ctx.ParserContext.GetClass (bc.FullyQualifiedName, true, true);
 					if (bcls != null && IsExpectedClass (bcls))
 						return true;
 				}
Index: Extras/CSharpBinding/Parser/Resolver.cs
===================================================================
--- Extras/CSharpBinding/Parser/Resolver.cs	(revision 62252)
+++ Extras/CSharpBinding/Parser/Resolver.cs	(working copy)
@@ -333,8 +333,8 @@
 			}
 //			Console.WriteLine("ClassType = " + curType.ClassType);
 			if (curType.ClassType == ClassType.Interface && !showStatic) {
-				foreach (string s in curType.BaseTypes) {
-					IClass baseClass = parserContext.GetClass (s, true, true);
+				foreach (IReturnType s in curType.BaseTypes) {
+					IClass baseClass = parserContext.GetClass (s.FullyQualifiedName, true, true);
 					if (baseClass != null && baseClass.ClassType == ClassType.Interface) {
 						ListMembers(members, baseClass);
 					}
@@ -352,8 +352,8 @@
 		
 		public IClass BaseClass(IClass curClass)
 		{
-			foreach (string s in curClass.BaseTypes) {
-				IClass baseClass = parserContext.GetClass (s, true, true);
+			foreach (IReturnType s in curClass.BaseTypes) {
+				IClass baseClass = parserContext.GetClass (s.FullyQualifiedName, true, true);
 				if (baseClass != null && baseClass.ClassType != ClassType.Interface) {
 					return baseClass;
 				}
@@ -567,8 +567,8 @@
 					}
 				}
 			}
-			foreach (string baseType in curType.BaseTypes) {
-				IClass c = parserContext.GetClass (baseType, true, true);
+			foreach (IReturnType baseType in curType.BaseTypes) {
+				IClass c = parserContext.GetClass (baseType.FullyQualifiedName, true, true);
 				if (c != null)
 					return SearchClassMember (new ReturnType(c.FullyQualifiedName), memberName, includeMethods, out curType, out member);
 			}
@@ -900,8 +900,8 @@
 			if (possibleBaseClass.FullyQualifiedName == c.FullyQualifiedName) {
 				return true;
 			}
-			foreach (string baseClass in c.BaseTypes) {
-				IClass bc = parserContext.GetClass (baseClass, true, true);
+			foreach (IReturnType baseClass in c.BaseTypes) {
+				IClass bc = parserContext.GetClass (baseClass.FullyQualifiedName, true, true);
 				if (IsClassInInheritanceTree(possibleBaseClass, bc)) {
 					return true;
 				}
Index: Extras/CSharpBinding/CSharpAmbience.cs
===================================================================
--- Extras/CSharpBinding/CSharpAmbience.cs	(revision 62252)
+++ Extras/CSharpBinding/CSharpAmbience.cs	(working copy)
@@ -178,7 +178,7 @@
 				if (c.BaseTypes.Count > 0) {
 					builder.Append(" : ");
 					for (int i = 0; i < c.BaseTypes.Count; ++i) {
-						builder.Append(c.BaseTypes[i]);
+						builder.Append(c.BaseTypes[i].FullyQualifiedName);
 						if (i + 1 < c.BaseTypes.Count) {
 							builder.Append(", ");
 						}
