Index: main/src/addins/MonoDevelop.Autotools/SimpleProjectMakefileHandler.cs
===================================================================
--- main/src/addins/MonoDevelop.Autotools/SimpleProjectMakefileHandler.cs	(revision 102818)
+++ main/src/addins/MonoDevelop.Autotools/SimpleProjectMakefileHandler.cs	(working copy)
@@ -364,10 +364,14 @@
 						if (configSection.DeployFileVars.ContainsKey (targetDeployVar)) {
 							//use the dfile from the config section
 							DeployFile dfile = configSection.DeployFileVars [targetDeployVar];
-							string fname = EscapeSpace (
-									FileService.AbsoluteToRelativePath (
-										Path.GetFullPath (project.BaseDirectory),
-										Path.GetFullPath (dfile.SourcePath)));
+							string fname;
+							if (!dfile.UseAbsoluteSourcePath)
+								fname = EscapeSpace (
+										FileService.AbsoluteToRelativePath (
+											Path.GetFullPath (project.BaseDirectory),
+											Path.GetFullPath (dfile.SourcePath)));
+							else
+								fname = EscapeSpace (dfile.SourcePath);
 
 							conf_vars.AppendFormat ("{0}_SOURCE={1}\n", targetDeployVar, fname);
 
@@ -506,10 +510,18 @@
 					dllRefWriter.WriteLine (" \\");
 					dllRefWriter.Write ("\t");
 
-					ctx.AddGlobalReferencedFile (EscapeSpace (FileService.AbsoluteToRelativePath (
-						Path.GetFullPath (ctx.BaseDirectory), assemblyPath)));
-					dllRefWriter.Write (EscapeSpace (FileService.AbsoluteToRelativePath (
-						project.BaseDirectory, assemblyPath)));
+					if (!reference.AbsolutePath)
+					{
+						ctx.AddGlobalReferencedFile (EscapeSpace (FileService.AbsoluteToRelativePath (
+							Path.GetFullPath (ctx.BaseDirectory), assemblyPath)));
+						dllRefWriter.Write (EscapeSpace (FileService.AbsoluteToRelativePath (
+							project.BaseDirectory, assemblyPath)));
+					}
+					else
+					{
+						ctx.AddGlobalReferencedFile (EscapeSpace (assemblyPath));
+						dllRefWriter.Write (EscapeSpace (assemblyPath));
+					}
 
 				} 
 				else if (reference.ReferenceType == ReferenceType.Project)
Index: main/src/addins/MonoDevelop.Autotools/SolutionDeployer.cs
===================================================================
--- main/src/addins/MonoDevelop.Autotools/SolutionDeployer.cs	(revision 102818)
+++ main/src/addins/MonoDevelop.Autotools/SolutionDeployer.cs	(working copy)
@@ -226,7 +226,8 @@
 				sb.Append ("expansions.m4");
 
 			foreach ( string file in context.GetGlobalReferencedFiles() )
-				sb.Append (' ').Append (file);
+				if (!Path.IsPathRooted (file))
+					sb.Append (' ').Append (file);
 			
 			string vals = sb.ToString ();
 
Index: main/src/addins/MonoDevelop.Autotools/MakefileData.cs
===================================================================
--- main/src/addins/MonoDevelop.Autotools/MakefileData.cs	(revision 102818)
+++ main/src/addins/MonoDevelop.Autotools/MakefileData.cs	(working copy)
@@ -709,12 +709,12 @@
 					List<ProjectReference> toRemove = new List<ProjectReference> ();
 					foreach (ProjectReference pref in OwnerProject.ProjectReferences) {
 						if (pref.ReferenceType == ReferenceType.Gac) {
-							string [] files = pref.GetReferencedFileNames ();
+							ProjectDeployFile [] files = pref.GetReferencedFiles ();
 							if (files == null)
 								continue;
 
 							// this should help normalize paths like /foo//bar/../
-							string fullpath = Path.GetFullPath (files [0]);
+							string fullpath = Path.GetFullPath (files [0].Path);
 							if (existingGacRefs.ContainsKey (fullpath))
 								toRemove.Add (pref);
 							else
@@ -1170,9 +1170,9 @@
 							pr.ReferenceType != ReferenceType.Project)
 							continue;
 						
-						string [] files = pr.GetReferencedFileNames ();
+						ProjectDeployFile [] files = pr.GetReferencedFiles ();
 						if (files.Length > 0)
-							asmProjectRefs [files [0]] = pr;
+							asmProjectRefs [files [0].Path] = pr;
 					}
 
 					List<string> toRemove = new List<string> ();
@@ -1493,7 +1493,7 @@
 			}
 
 			if (pkg == null)
-				return AsmRefToString (pr.GetReferencedFileNames () [0], refVar, false);
+				return AsmRefToString (pr.GetReferencedFiles () [0].Path, refVar, false);
 
 			// Reference is from a package
 
@@ -1555,12 +1555,12 @@
 
 		string ProjectRefToString (ProjectReference pr, MakefileVar refVar)
 		{
-			string [] tmp = pr.GetReferencedFileNames ();
+			ProjectDeployFile [] tmp = pr.GetReferencedFiles ();
 			if (tmp == null || tmp.Length == 0)
 				//Reference not found, ignoring
 				return null;
 
-			return AsmRefToString (tmp [0], refVar, true);
+			return AsmRefToString (tmp [0].Path, refVar, true);
 		}
 
 		static string EscapeString (string str)
Index: main/src/addins/Deployment/MonoDevelop.Deployment/MonoDevelop.Deployment/DefaultDeployServiceExtension.cs
===================================================================
--- main/src/addins/Deployment/MonoDevelop.Deployment/MonoDevelop.Deployment/DefaultDeployServiceExtension.cs	(revision 102818)
+++ main/src/addins/Deployment/MonoDevelop.Deployment/MonoDevelop.Deployment/DefaultDeployServiceExtension.cs	(working copy)
@@ -42,8 +42,8 @@
 
 			// Collect referenced assemblies
 			
-			foreach (string refFile in project.GetReferenceDeployFiles (false)) {
-				deployFiles.Add (new DeployFile (project, refFile, Path.GetFileName (refFile), TargetDirectory.ProgramFiles));
+			foreach (ProjectDeployFile refFile in project.GetReferencedFiles (false)) {
+				deployFiles.Add (new DeployFile (project, refFile.Path, refFile.UseAbsolutePath, Path.GetFileName (refFile.Path), TargetDirectory.ProgramFiles));
 			}
 			
 			return deployFiles;
Index: main/src/addins/Deployment/MonoDevelop.Deployment/MonoDevelop.Deployment/DeployFile.cs
===================================================================
--- main/src/addins/Deployment/MonoDevelop.Deployment/MonoDevelop.Deployment/DeployFile.cs	(revision 102818)
+++ main/src/addins/Deployment/MonoDevelop.Deployment/MonoDevelop.Deployment/DeployFile.cs	(working copy)
@@ -40,6 +40,7 @@
 	public class DeployFile
 	{
 		string sourcePath;
+		bool useAbsoluteSourcePath;
 		string relativeTargetPath;
 		string targetDirectoryID;
 		DeployContext deployContext;
@@ -53,6 +54,7 @@
 			DeployProperties props = DeployService.GetDeployProperties (pfile);
 			this.targetDirectoryID = props.TargetDirectory;
 			this.sourcePath = pfile.FilePath;
+			this.useAbsoluteSourcePath = false;
 			this.relativeTargetPath = props.RelativeDeployPath;
 			this.attributes = props.FileAttributes;
 			if (props.HasPathReferences)
@@ -61,14 +63,20 @@
 		}
 		
 		public DeployFile (CombineEntry sourceCombineEntry, string sourcePath, string relativeTargetPath)
-		 : this (sourceCombineEntry, sourcePath, relativeTargetPath, TargetDirectory.ProgramFiles)
+		 : this (sourceCombineEntry, sourcePath, false, relativeTargetPath, TargetDirectory.ProgramFiles)
 		{
 		}
-		
+
 		public DeployFile (CombineEntry sourceCombineEntry, string sourcePath, string relativeTargetPath, string targetDirectoryID)
+		 : this (sourceCombineEntry, sourcePath, false, relativeTargetPath, TargetDirectory.ProgramFiles)
 		{
+		}
+		
+		public DeployFile (CombineEntry sourceCombineEntry, string sourcePath, bool useAbsoluteSourcePath, string relativeTargetPath, string targetDirectoryID)
+		{
 			this.targetDirectoryID = targetDirectoryID;
 			this.sourcePath = sourcePath;
+			this.useAbsoluteSourcePath = useAbsoluteSourcePath;
 			this.relativeTargetPath = relativeTargetPath;
 			this.sourceCombineEntry = sourceCombineEntry;
 		}
@@ -87,7 +95,10 @@
 				if (displayName != null)
 					return displayName;
 				else {
-					return FileService.AbsoluteToRelativePath (sourceCombineEntry.BaseDirectory, SourcePath);
+					if (useAbsoluteSourcePath)
+						return SourcePath;
+					else
+						return FileService.AbsoluteToRelativePath (sourceCombineEntry.BaseDirectory, SourcePath);
 				}
 			}
 			set { displayName = value; }
@@ -97,6 +108,11 @@
 			get { return sourcePath; }
 			set { sourcePath = value; }
 		}
+
+		public bool UseAbsoluteSourcePath {
+			get { return useAbsoluteSourcePath; }
+			set { useAbsoluteSourcePath = value; }
+		}
 		
 		public string RelativeTargetPath {
 			get { return relativeTargetPath; }
Index: main/src/addins/MonoDevelop.DesignerSupport/MonoDevelop.DesignerSupport.Projects/ProjectReferenceDescriptor.cs
===================================================================
--- main/src/addins/MonoDevelop.DesignerSupport/MonoDevelop.DesignerSupport.Projects/ProjectReferenceDescriptor.cs	(revision 102818)
+++ main/src/addins/MonoDevelop.DesignerSupport/MonoDevelop.DesignerSupport.Projects/ProjectReferenceDescriptor.cs	(working copy)
@@ -109,9 +109,9 @@
 		[Description ("Path to the assembly.")]
 		public string Path {
 			get {
-				string[] files = pref.GetReferencedFileNames ();
+				ProjectDeployFile[] files = pref.GetReferencedFiles ();
 				if (files.Length > 0)
-					return files [0];
+					return files [0].Path;
 				else
 					return string.Empty;
 			}
@@ -124,5 +124,13 @@
 			get { return pref.LocalCopy; }
 			set { pref.LocalCopy = value; }
 		}
+
+		[Category ("Reference")]
+		[DisplayName ("Absolute Path")]
+		[Description ("Refer to the referenced assembly by an absolute path.")]
+		public bool AbsolutePath {
+			get { return pref.AbsolutePath; }
+			set { pref.AbsolutePath = value; }
+		}
 	}
 }
Index: main/src/addins/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/ToolboxProvider.cs
===================================================================
--- main/src/addins/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/ToolboxProvider.cs	(revision 102818)
+++ main/src/addins/MonoDevelop.GtkCore/MonoDevelop.GtkCore.GuiBuilder/ToolboxProvider.cs	(working copy)
@@ -34,8 +34,8 @@
 			string of = FileService.GetFullPath (view.Project.GetOutputFileName ());
 			refs [of] = of;
 			foreach (ProjectReference pr in view.Project.ProjectReferences)
-				foreach (string f in pr.GetReferencedFileNames ()) {
-					refs[FileService.GetFullPath (f)] = f;
+				foreach (ProjectDeployFile df in pr.GetReferencedFiles ()) {
+					refs[FileService.GetFullPath (df.Path)] = df.Path;
 				}
 			
 			List<BaseToolboxNode> list = new List<BaseToolboxNode> ();
Index: main/src/addins/AspNetAddIn/MonoDevelop.AspNet/AspNetAppProject.cs
===================================================================
--- main/src/addins/AspNetAddIn/MonoDevelop.AspNet/AspNetAppProject.cs	(revision 102818)
+++ main/src/addins/AspNetAddIn/MonoDevelop.AspNet/AspNetAppProject.cs	(working copy)
@@ -176,8 +176,8 @@
 					files.Add (new DeployFile (this, pf.FilePath, pf.RelativePath, WebTargetDirectory.SiteRoot));
 			
 			//add referenced libraries
-			foreach (string refFile in GetReferenceDeployFiles (false))
-				files.Add (new DeployFile (this, refFile, Path.GetFileName (refFile), WebTargetDirectory.AspNetBin));
+			foreach (ProjectDeployFile refFile in GetReferencedFiles (false))
+				files.Add (new DeployFile (this, refFile.Path, Path.GetFileName (refFile.Path), WebTargetDirectory.AspNetBin));
 			
 			//add the compiled output file
 			string outputFile = this.GetOutputFileName ();
Index: main/src/addins/VBNetBinding/VBBindingCompilerServices.cs
===================================================================
--- main/src/addins/VBNetBinding/VBBindingCompilerServices.cs	(revision 102818)
+++ main/src/addins/VBNetBinding/VBBindingCompilerServices.cs	(working copy)
@@ -17,28 +17,28 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-using System;
+
+using System;
 using System.Text;
-using System.Text.RegularExpressions;
-using System.Collections;
-using System.IO;
-using System.Diagnostics;
+using System.Text.RegularExpressions;
+using System.Collections;
+using System.IO;
+using System.Diagnostics;
 using System.CodeDom.Compiler;
 using System.Threading;
-
-using MonoDevelop.Core;
+
+using MonoDevelop.Core;
 using MonoDevelop.Core.Execution;
 using MonoDevelop.Core.Gui;
-using MonoDevelop.Core.Gui.Components;
+using MonoDevelop.Core.Gui.Components;
 using MonoDevelop.Projects;
-
-namespace VBBinding {
-	
-	/// <summary>
-	/// This class controls the compilation of VB.net files and VB.net projects
-	/// </summary>
-	public class VBBindingCompilerServices
+
+namespace VBBinding {
+	
+	/// <summary>
+	/// This class controls the compilation of VB.net files and VB.net projects
+	/// </summary>
+	public class VBBindingCompilerServices
 	{
 		//matches "/home/path/Default.aspx.vb (40,31) : Error VBNC30205: Expected end of statement."
 		//and "Error : VBNC99999: vbnc crashed nearby this location in the source code."
@@ -46,151 +46,151 @@
 		static Regex regexError = new Regex (@"^\s*((?<file>.*)\((?<line>\d*),(?<column>\d*)\) : )?(?<level>\w+) :? ?(?<number>[^:]*): (?<message>.*)$",
 		                                     RegexOptions.Compiled | RegexOptions.ExplicitCapture);
 		
-		public bool CanCompile(string fileName)
-		{
-			return Path.GetExtension(fileName) == ".vb";
-		}
-		
-		string GetCompilerName(string compilerVersion)
-		{
-			//string runtimeDirectory = Path.Combine(fileUtilityService.NETFrameworkInstallRoot, compilerVersion);
-			//if (compilerVersion.Length == 0 || compilerVersion == "Standard" || !Directory.Exists(runtimeDirectory)) {
-			//	runtimeDirectory = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory();
-			//}
+		public bool CanCompile(string fileName)
+		{
+			return Path.GetExtension(fileName) == ".vb";
+		}
+		
+		string GetCompilerName(string compilerVersion)
+		{
+			//string runtimeDirectory = Path.Combine(fileUtilityService.NETFrameworkInstallRoot, compilerVersion);
+			//if (compilerVersion.Length == 0 || compilerVersion == "Standard" || !Directory.Exists(runtimeDirectory)) {
+			//	runtimeDirectory = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory();
+			//}
 			//return String.Concat('"', Path.Combine(runtimeDirectory, "vbc.exe"), '"');
-			return "vbnc";
-		}
-		
-		string GenerateOptions (DotNetProjectConfiguration configuration, VBCompilerParameters compilerparameters, string outputFileName)
-		{
-			StringBuilder sb = new StringBuilder();
+			return "vbnc";
+		}
+		
+		string GenerateOptions (DotNetProjectConfiguration configuration, VBCompilerParameters compilerparameters, string outputFileName)
+		{
+			StringBuilder sb = new StringBuilder();
 			bool hasWin32Resource = false;
-			
-			sb.Append("-out:");sb.Append("\"" + outputFileName + "\"");/*sb.Append('"');*/sb.Append(Environment.NewLine);
-			
-			sb.Append("-nologo");sb.Append(Environment.NewLine);
-			sb.Append("-utf8output");sb.Append(Environment.NewLine);
-			
-//			if (compilerparameters.DebugMode) {
-//				sb.Append("--debug+");sb.Append(Environment.NewLine);
-//				sb.Append("--debug:full");sb.Append(Environment.NewLine);
-//			}
-			
-			//if (compilerparameters.Optimize) {
-			//	sb.Append("-optimize");sb.Append(Environment.NewLine);
-			//}
-			
-			//if (compilerparameters.OptionStrict) {
-			//	sb.Append("-optionstrict");sb.Append(Environment.NewLine);
-			//}
-			
-			//if (compilerparameters.OptionExplicit) {
-			//	sb.Append("-optionexplicit");sb.Append(Environment.NewLine);
-			//}// else {
-			//	sb.Append("--optionexplicit-");sb.Append(Environment.NewLine);
-			//}
-			
-			if (compilerparameters.Win32Resource != null && compilerparameters.Win32Resource.Length > 0 && File.Exists(compilerparameters.Win32Resource)) {
-				sb.Append("-win32resource:");sb.Append('"');sb.Append(compilerparameters.Win32Resource);sb.Append('"');sb.Append(Environment.NewLine);
+			
+			sb.Append("-out:");sb.Append("\"" + outputFileName + "\"");/*sb.Append('"');*/sb.Append(Environment.NewLine);
+			
+			sb.Append("-nologo");sb.Append(Environment.NewLine);
+			sb.Append("-utf8output");sb.Append(Environment.NewLine);
+			
+//			if (compilerparameters.DebugMode) {
+//				sb.Append("--debug+");sb.Append(Environment.NewLine);
+//				sb.Append("--debug:full");sb.Append(Environment.NewLine);
+//			}
+			
+			//if (compilerparameters.Optimize) {
+			//	sb.Append("-optimize");sb.Append(Environment.NewLine);
+			//}
+			
+			//if (compilerparameters.OptionStrict) {
+			//	sb.Append("-optionstrict");sb.Append(Environment.NewLine);
+			//}
+			
+			//if (compilerparameters.OptionExplicit) {
+			//	sb.Append("-optionexplicit");sb.Append(Environment.NewLine);
+			//}// else {
+			//	sb.Append("--optionexplicit-");sb.Append(Environment.NewLine);
+			//}
+			
+			if (compilerparameters.Win32Resource != null && compilerparameters.Win32Resource.Length > 0 && File.Exists(compilerparameters.Win32Resource)) {
+				sb.Append("-win32resource:");sb.Append('"');sb.Append(compilerparameters.Win32Resource);sb.Append('"');sb.Append(Environment.NewLine);
 				hasWin32Resource = true;
-			}
-			if (compilerparameters.Win32Icon != null && compilerparameters.Win32Icon.Length > 0 && File.Exists(compilerparameters.Win32Icon)) {
+			}
+			if (compilerparameters.Win32Icon != null && compilerparameters.Win32Icon.Length > 0 && File.Exists(compilerparameters.Win32Icon)) {
 				if (hasWin32Resource)
 					Console.WriteLine ("Warning: Both Win32 icon and Win32 resource cannot be specified. Ignoring the icon.");
 				else
-					sb.Append("-win32icon:");sb.Append('"');sb.Append(compilerparameters.Win32Icon);sb.Append('"');sb.Append(Environment.NewLine);
-			}
-			
-			if (compilerparameters.RootNamespace!= null && compilerparameters.RootNamespace.Length > 0) {
-				sb.Append("-rootnamespace:");sb.Append('"');sb.Append(compilerparameters.RootNamespace);sb.Append('"');sb.Append(Environment.NewLine);
-			}
-			
-			if (compilerparameters.DefineSymbols.Length > 0) {
-				sb.Append("-define:");sb.Append('"');sb.Append(compilerparameters.DefineSymbols);sb.Append('"');sb.Append(Environment.NewLine);
-			}
+					sb.Append("-win32icon:");sb.Append('"');sb.Append(compilerparameters.Win32Icon);sb.Append('"');sb.Append(Environment.NewLine);
+			}
+			
+			if (compilerparameters.RootNamespace!= null && compilerparameters.RootNamespace.Length > 0) {
+				sb.Append("-rootnamespace:");sb.Append('"');sb.Append(compilerparameters.RootNamespace);sb.Append('"');sb.Append(Environment.NewLine);
+			}
+			
+			if (compilerparameters.DefineSymbols.Length > 0) {
+				sb.Append("-define:");sb.Append('"');sb.Append(compilerparameters.DefineSymbols);sb.Append('"');sb.Append(Environment.NewLine);
+			}
 			if (configuration.SignAssembly) {
 				if (File.Exists (configuration.AssemblyKeyFile)) {
 					sb.Append("-keyfile:");sb.Append('"');sb.Append(configuration.AssemblyKeyFile);sb.Append('"');sb.Append(Environment.NewLine);
-				}
+				}
 			}
-			
-			if (compilerparameters.MainClass != null && compilerparameters.MainClass.Length > 0) {
-				sb.Append("-main:");sb.Append(compilerparameters.MainClass);sb.Append(Environment.NewLine);
-			}
 			
-			if (!String.IsNullOrEmpty (compilerparameters.AdditionalParameters)) {
-				sb.Append(compilerparameters.AdditionalParameters.Length);sb.Append(Environment.NewLine);
-			}
-			
-			if(compilerparameters.Imports.Length > 0) {
-				sb.Append("-imports:");sb.Append(compilerparameters.Imports);sb.Append(Environment.NewLine);
-			}
-			
-			switch (configuration.CompileTarget) {
-				case CompileTarget.Exe:
-					sb.Append("-target:exe");
-					break;
-				case CompileTarget.WinExe:
-					sb.Append("-target:winexe");
-					break;
-				case CompileTarget.Library:
-					sb.Append("-target:library");
-					break;
-				case CompileTarget.Module:
-					sb.Append("-target:module");
-					break;
-				default:
-					throw new NotSupportedException("unknown compile target:" + configuration.CompileTarget);
-			}
+			if (compilerparameters.MainClass != null && compilerparameters.MainClass.Length > 0) {
+				sb.Append("-main:");sb.Append(compilerparameters.MainClass);sb.Append(Environment.NewLine);
+			}
+			
+			if (!String.IsNullOrEmpty (compilerparameters.AdditionalParameters)) {
+				sb.Append(compilerparameters.AdditionalParameters.Length);sb.Append(Environment.NewLine);
+			}
+			
+			if(compilerparameters.Imports.Length > 0) {
+				sb.Append("-imports:");sb.Append(compilerparameters.Imports);sb.Append(Environment.NewLine);
+			}
+			
+			switch (configuration.CompileTarget) {
+				case CompileTarget.Exe:
+					sb.Append("-target:exe");
+					break;
+				case CompileTarget.WinExe:
+					sb.Append("-target:winexe");
+					break;
+				case CompileTarget.Library:
+					sb.Append("-target:library");
+					break;
+				case CompileTarget.Module:
+					sb.Append("-target:module");
+					break;
+				default:
+					throw new NotSupportedException("unknown compile target:" + configuration.CompileTarget);
+			}
 			sb.Append(Environment.NewLine);
-			return sb.ToString();
-		}
-		
-		public ICompilerResult Compile (ProjectFileCollection projectFiles, ProjectReferenceCollection references, DotNetProjectConfiguration configuration, IProgressMonitor monitor)
+			return sb.ToString();
+		}
+		
+		public ICompilerResult Compile (ProjectFileCollection projectFiles, ProjectReferenceCollection references, DotNetProjectConfiguration configuration, IProgressMonitor monitor)
 		{
 			VBCompilerParameters compilerparameters = (VBCompilerParameters) configuration.CompilationParameters;
 			if (compilerparameters == null) compilerparameters = new VBCompilerParameters ();
-			
+			
 			string exe = configuration.CompiledOutputName;
-			string responseFileName = Path.GetTempFileName();
+			string responseFileName = Path.GetTempFileName();
 			StreamWriter writer = new StreamWriter(responseFileName);
 			
-			writer.WriteLine(GenerateOptions (configuration, compilerparameters, exe));
-			
-			foreach (ProjectReference lib in references) {
-				foreach (string fileName in lib.GetReferencedFileNames())
-					writer.WriteLine(String.Concat("-r:", fileName));
-			}
-			
-			// write source files and embedded resources
-			foreach (ProjectFile finfo in projectFiles) {
-				if (finfo.Subtype != Subtype.Directory) {
-					switch (finfo.BuildAction) {
+			writer.WriteLine(GenerateOptions (configuration, compilerparameters, exe));
+			
+			foreach (ProjectReference lib in references) {
+				foreach (ProjectDeployFile df in lib.GetReferencedFiles())
+					writer.WriteLine(String.Concat("-r:", df.Path));
+			}
+			
+			// write source files and embedded resources
+			foreach (ProjectFile finfo in projectFiles) {
+				if (finfo.Subtype != Subtype.Directory) {
+					switch (finfo.BuildAction) {
 						case BuildAction.Compile:
-							writer.WriteLine("\"" + finfo.Name + "\"");
-						break;
-						
+							writer.WriteLine("\"" + finfo.Name + "\"");
+						break;
+						
 						case BuildAction.EmbedAsResource:
 							string fname = finfo.Name;
 							if (String.Compare (Path.GetExtension (fname), ".resx", true) == 0)
 								fname = Path.ChangeExtension (fname, ".resources");
 
 							writer.WriteLine(@"""-resource:{0},{1}""", fname, finfo.ResourceId);
-							break;
+							break;
 						default:
 							continue;
-					}
-				}
-			}
-			
-			TempFileCollection tf = new TempFileCollection ();
-			writer.Close();
-			
-			string output = "";
-			string compilerName = GetCompilerName(compilerparameters.VBCompilerVersion);
+					}
+				}
+			}
+			
+			TempFileCollection tf = new TempFileCollection ();
+			writer.Close();
+			
+			string output = "";
+			string compilerName = GetCompilerName(compilerparameters.VBCompilerVersion);
 			string outstr = String.Concat(compilerName, " @", responseFileName);
 			
-			
+			
 			string workingDir = ".";
 			if (projectFiles != null && projectFiles.Count > 0)
 				workingDir = projectFiles [0].Project.BaseDirectory;
@@ -211,41 +211,41 @@
 				// Show everything the compiler said.
 				result.AddError (output);
 			}
-			
-			FileService.DeleteFile (responseFileName);
-			if (configuration.CompileTarget != CompileTarget.Library) {
-				WriteManifestFile(exe);
-			}
-			return result;
-		}
-		
-		// code duplication: see C# backend : CSharpBindingCompilerManager
-		void WriteManifestFile(string fileName)
-		{
-			string manifestFile = String.Concat(fileName, ".manifest");
-			if (File.Exists(manifestFile)) {
-				return;
-			}
-			StreamWriter sw = new StreamWriter(manifestFile);
-			sw.WriteLine("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>");
-			sw.WriteLine("");
-			sw.WriteLine("<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">");
-			sw.WriteLine("	<dependency>");
-			sw.WriteLine("		<dependentAssembly>");
-			sw.WriteLine("			<assemblyIdentity");
-			sw.WriteLine("				type=\"win32\"");
-			sw.WriteLine("				name=\"Microsoft.Windows.Common-Controls\"");
-			sw.WriteLine("				version=\"6.0.0.0\"");
-			sw.WriteLine("				processorArchitecture=\"X86\"");
-			sw.WriteLine("				publicKeyToken=\"6595b64144ccf1df\"");
-			sw.WriteLine("				language=\"*\"");
-			sw.WriteLine("			/>");
-			sw.WriteLine("		</dependentAssembly>");
-			sw.WriteLine("	</dependency>");
-			sw.WriteLine("</assembly>");
-			sw.Close();
-		}
-		
+			
+			FileService.DeleteFile (responseFileName);
+			if (configuration.CompileTarget != CompileTarget.Library) {
+				WriteManifestFile(exe);
+			}
+			return result;
+		}
+		
+		// code duplication: see C# backend : CSharpBindingCompilerManager
+		void WriteManifestFile(string fileName)
+		{
+			string manifestFile = String.Concat(fileName, ".manifest");
+			if (File.Exists(manifestFile)) {
+				return;
+			}
+			StreamWriter sw = new StreamWriter(manifestFile);
+			sw.WriteLine("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>");
+			sw.WriteLine("");
+			sw.WriteLine("<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">");
+			sw.WriteLine("	<dependency>");
+			sw.WriteLine("		<dependentAssembly>");
+			sw.WriteLine("			<assemblyIdentity");
+			sw.WriteLine("				type=\"win32\"");
+			sw.WriteLine("				name=\"Microsoft.Windows.Common-Controls\"");
+			sw.WriteLine("				version=\"6.0.0.0\"");
+			sw.WriteLine("				processorArchitecture=\"X86\"");
+			sw.WriteLine("				publicKeyToken=\"6595b64144ccf1df\"");
+			sw.WriteLine("				language=\"*\"");
+			sw.WriteLine("			/>");
+			sw.WriteLine("		</dependentAssembly>");
+			sw.WriteLine("	</dependency>");
+			sw.WriteLine("</assembly>");
+			sw.Close();
+		}
+		
 		void ParseOutput(TempFileCollection tf, string output, CompilerResults cr)
 		{
 			using (StringReader sr = new StringReader (output)) {			
@@ -316,5 +316,5 @@
 					outwr.Dispose ();
 			}
 		}
-	}
+	}
 }
Index: main/src/addins/CSharpBinding/CSharpBindingCompilerManager.cs
===================================================================
--- main/src/addins/CSharpBinding/CSharpBindingCompilerManager.cs	(revision 102818)
+++ main/src/addins/CSharpBinding/CSharpBindingCompilerManager.cs	(working copy)
@@ -62,7 +62,7 @@
 			
 			if (references != null) {
 				foreach (ProjectReference lib in references) {
-					foreach (string fileName in lib.GetReferencedFileNames ()) {
+					foreach (ProjectDeployFile df in lib.GetReferencedFiles ()) {
 						switch (lib.ReferenceType) {
 						case ReferenceType.Gac:
 							SystemPackage pkg = Runtime.SystemAssemblyService.GetPackageFromFullName (lib.Reference);
@@ -72,9 +72,9 @@
 								continue;
 							}
 							if (pkg.IsCorePackage) {
-								writer.WriteLine ("\"/r:" + Path.GetFileName (fileName) + "\"");
+								writer.WriteLine ("\"/r:" + Path.GetFileName (df.Path) + "\"");
 							} else if (pkg.IsInternalPackage) {
-								writer.WriteLine ("\"/r:" + fileName + "\"");
+								writer.WriteLine ("\"/r:" + df.Path + "\"");
 							} else if (!pkg_references.Contains (pkg.Name)) {
 								pkg_references.Add (pkg.Name);
 								writer.WriteLine ("\"-pkg:" + pkg.Name + "\"");
@@ -83,7 +83,7 @@
 								gacRoots.Add (pkg.GacRoot);
 							break;
 						default:
-							writer.WriteLine ("\"/r:" + fileName + "\"");
+							writer.WriteLine ("\"/r:" + df.Path + "\"");
 							break;
 						}
 					}
Index: main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/ProjectReference.cs
===================================================================
--- main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/ProjectReference.cs	(revision 102818)
+++ main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/ProjectReference.cs	(working copy)
@@ -23,8 +23,9 @@
 using System.IO;
 using System.Diagnostics;
 using System.Xml;
+using System.Text;
+using System.ComponentModel;
 using MonoDevelop.Core;
-using System.ComponentModel;
 using MonoDevelop.Projects;
 using MonoDevelop.Projects.Serialization;
 
@@ -61,6 +62,8 @@
 		
 		[ItemProperty ("localcopy")]
 		bool localCopy = true;
+
+		bool absolutePath = false;
 		
 		public ProjectReference ()
 		{
@@ -98,6 +101,10 @@
 		[ReadOnly(true)]
 		public string Reference {
 			get {
+				// Convert to absolute representation.
+				if (referenceType == ReferenceType.Assembly && !Path.IsPathRooted (reference))
+					reference = FileService.RelativeToAbsolutePath (ownerProject.BaseDirectory, reference);
+
 				return reference;
 			}
 		}
@@ -121,26 +128,37 @@
 				localCopy = value;
 			}
 		}
+
+		[DefaultValue(false)]
+		public bool AbsolutePath {
+			get {
+				return absolutePath;
+			}
+			set {
+				absolutePath = value;
+			}
+		}
 		
 		/// <summary>
 		/// Returns the file name to an assembly, regardless of what 
 		/// type the assembly is.
 		/// </summary>
-		string GetReferencedFileName ()
+		public ProjectDeployFile GetDeployFile ()
 		{
 			switch (ReferenceType) {
 				case ReferenceType.Assembly:
-					return reference;
+					// Return known absolute version.
+					return new ProjectDeployFile (Reference, AbsolutePath);
 				
 				case ReferenceType.Gac:
 					string file = Runtime.SystemAssemblyService.GetAssemblyLocation (Reference);
-					return file == null ? reference : file;
+					return file == null ? new ProjectDeployFile (reference, true) : new ProjectDeployFile (file, true);
 				case ReferenceType.Project:
 					if (ownerProject != null) {
 						Combine c = ownerProject.RootCombine;
 						if (c != null) {
 							Project p = c.FindProject (reference);
-							if (p != null) return p.GetOutputFileName ();
+							if (p != null) return new ProjectDeployFile (p.GetOutputFileName (), false);
 						}
 					}
 					return null;
@@ -150,24 +168,32 @@
 			}
 		}
 		
-		public virtual string[] GetReferencedFileNames ()
+		public virtual ProjectDeployFile[] GetReferencedFiles()
 		{
-			string s = GetReferencedFileName ();
-			if (s != null)
-				return new string[] { s };
+			ProjectDeployFile df = GetDeployFile ();
+			if (df != null)
+				return new ProjectDeployFile[] { df };
 			else
-				return new string [0];
+				return new ProjectDeployFile[0];
 		}
 		
 		DataCollection ICustomDataItem.Serialize (ITypeSerializer handler)
 		{
 			DataCollection data = handler.Serialize (this);
-			string refto = reference;
-			if (referenceType == ReferenceType.Assembly) {
-				string basePath = Path.GetDirectoryName (handler.SerializationContext.BaseFile);
-				refto = FileService.AbsoluteToRelativePath (basePath, refto);
-			} else if (referenceType == ReferenceType.Gac && loadedReference != null)
-				refto = loadedReference;
+			string refto;
+			switch (referenceType)
+			{
+				case ReferenceType.Gac:
+					refto = loadedReference != null ? loadedReference : reference;
+					break;
+				case ReferenceType.Assembly:
+					// If we are storing a relative path, convert known absolute version.
+					refto = !absolutePath ? FileService.AbsoluteToRelativePath (ownerProject.BaseDirectory, Reference) : Reference;
+					break;
+				default:
+					refto = reference;
+					break;
+			}
 
 			data.Add (new DataValue ("refto", refto));
 			return data;
@@ -177,14 +203,14 @@
 		{
 			DataValue refto = data.Extract ("refto") as DataValue;
 			handler.Deserialize (this, data);
+
 			if (refto != null) {
 				reference = refto.Value;
 				UpdateGacReference ();
-				if (referenceType == ReferenceType.Assembly) {
-					string basePath = Path.GetDirectoryName (handler.SerializationContext.BaseFile);
-					reference = FileService.RelativeToAbsolutePath (basePath, reference);
-				}
 			}
+
+			// Our absolute setting is inferred from the stored path.
+			absolutePath = referenceType == ReferenceType.Assembly && Path.IsPathRooted (reference);
 		}
 		
 		void UpdateGacReference ()
Index: main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/ProjectDeployFile.cs
===================================================================
--- main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/ProjectDeployFile.cs	(revision 0)
+++ main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/ProjectDeployFile.cs	(revision 0)
@@ -0,0 +1,44 @@
+//  ProjectDeployFile.cs
+//
+//  This file was derived from a file from #Develop. 
+//
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; either version 2 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+using System;
+
+namespace MonoDevelop.Projects
+{
+	public class ProjectDeployFile
+	{
+		private string path;
+		private bool useAbsolutePath;
+
+		public ProjectDeployFile (string path, bool useAbsolutePath)
+		{
+			this.path = path;
+			this.useAbsolutePath = useAbsolutePath;
+		}
+
+		public string Path {
+			get { return path; }
+			set { path = value; }
+		}
+
+		public bool UseAbsolutePath {
+			get { return useAbsolutePath; }
+			set { useAbsolutePath = value; }
+		}
+	}
+}
Index: main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/DotNetProject.cs
===================================================================
--- main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/DotNetProject.cs	(revision 102818)
+++ main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/DotNetProject.cs	(working copy)
@@ -246,7 +246,7 @@
 					if (p != null && !(p is DotNetProject))
 						continue;
 
-					if (p == null || pr.GetReferencedFileNames ().Length == 0) {
+					if (p == null || pr.GetReferencedFiles ().Length == 0) {
 						if (refres == null)
 							refres = new DefaultCompilerResult ();
 						string msg = GettextCatalog.GetString ("Referenced project '{0}' not found in the solution.", pr.Reference);
@@ -313,11 +313,11 @@
 			foreach (ProjectReference pref in prj.ProjectReferences) {
 				if (pref.ReferenceType == ReferenceType.Gac)
 					continue;
-				foreach (string referenceFileName in pref.GetReferencedFileNames ()) {
-					string asmName = Path.GetFileName (referenceFileName);
+				foreach (ProjectDeployFile df in pref.GetReferencedFiles ()) {
+					string asmName = Path.GetFileName (df.Path);
 					asmName = Path.Combine (targetDir, asmName);
 					if (!File.Exists (asmName)) {
-						File.Copy (referenceFileName, asmName);
+						File.Copy (df.Path, asmName);
 						files.Add (asmName);
 					}
 				}
Index: main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/Project.cs
===================================================================
--- main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/Project.cs	(revision 102818)
+++ main/src/core/MonoDevelop.Projects/MonoDevelop.Projects/Project.cs	(working copy)
@@ -210,34 +210,34 @@
 		
 		void CopyReferencesToOutputPath (string destPath, bool force)
 		{
-			string[] deployFiles = GetReferenceDeployFiles (force);
+			ProjectDeployFile[] deployFiles = GetReferencedFiles (force);
 			
-			foreach (string sourcePath in deployFiles) {
-				string destinationFileName = Path.Combine (destPath, Path.GetFileName (sourcePath));
+			foreach (ProjectDeployFile sourceFile in deployFiles) {
+				string destinationFileName = Path.Combine (destPath, Path.GetFileName (sourceFile.Path));
 				try {
-					if (destinationFileName != sourcePath) {
+					if (destinationFileName != sourceFile.Path) {
 						// Make sure the target directory exists
 						if (!Directory.Exists (Path.GetDirectoryName (destinationFileName)))
 							Directory.CreateDirectory (Path.GetDirectoryName (destinationFileName));
 						// Copy the file
-						FileService.CopyFile (sourcePath, destinationFileName);
+						FileService.CopyFile (sourceFile.Path, destinationFileName);
 					}
 				} catch (Exception e) {
-					LoggingService.LogError ("Can't copy reference file from {0} to {1}: {2}", sourcePath, destinationFileName, e);
+					LoggingService.LogError ("Can't copy reference file from {0} to {1}: {2}", sourceFile.Path, destinationFileName, e);
 				}
 			}
 		}
 		
-		public string[] GetReferenceDeployFiles (bool force)
+		public ProjectDeployFile[] GetReferencedFiles (bool force)
 		{
 			ArrayList deployFiles = new ArrayList ();
 
 			foreach (ProjectReference projectReference in ProjectReferences) {
 				if ((projectReference.LocalCopy || force) && projectReference.ReferenceType != ReferenceType.Gac) {
-					foreach (string referenceFileName in projectReference.GetReferencedFileNames ()) {
-						deployFiles.Add (referenceFileName);
-						if (File.Exists (referenceFileName + ".config"))
-							deployFiles.Add (referenceFileName + ".config");
+					foreach (ProjectDeployFile df in projectReference.GetReferencedFiles ()) {
+						deployFiles.Add (df);
+						if (File.Exists (df.Path + ".config"))
+							deployFiles.Add (new ProjectDeployFile (df.Path + ".config", df.UseAbsolutePath));
 					}
 				}
 				if (projectReference.ReferenceType == ReferenceType.Project && projectReference.LocalCopy && RootCombine != null) {
@@ -245,23 +245,23 @@
 					if (p != null) {
 						AbstractProjectConfiguration config = p.ActiveConfiguration as AbstractProjectConfiguration;
 						if (config != null && config.DebugMode)
-							deployFiles.Add (p.GetOutputFileName () + ".mdb");
+							deployFiles.Add (new ProjectDeployFile (p.GetOutputFileName () + ".mdb", false));
 
-						deployFiles.AddRange (p.GetReferenceDeployFiles (force));
+						deployFiles.AddRange (p.GetReferencedFiles (force));
 					}
 				}
 			}
-			return (string[]) deployFiles.ToArray (typeof(string));
+			return (ProjectDeployFile[]) deployFiles.ToArray (typeof(ProjectDeployFile));
 		}
 		
 		void CleanReferencesInOutputPath (string destPath)
 		{
-			string[] deployFiles = GetReferenceDeployFiles (true);
+			ProjectDeployFile[] deployFiles = GetReferencedFiles (true);
 			
-			foreach (string sourcePath in deployFiles) {
-				string destinationFileName = Path.Combine (destPath, Path.GetFileName (sourcePath));
+			foreach (ProjectDeployFile sourceFile in deployFiles) {
+				string destinationFileName = Path.Combine (destPath, Path.GetFileName (sourceFile.Path));
 				try {
-					if (destinationFileName != sourcePath) {
+					if (destinationFileName != sourceFile.Path) {
 						if (File.Exists (destinationFileName))
 							FileService.DeleteFile (destinationFileName);
 					}
Index: main/src/core/MonoDevelop.Projects/Makefile.am
===================================================================
--- main/src/core/MonoDevelop.Projects/Makefile.am	(revision 102818)
+++ main/src/core/MonoDevelop.Projects/Makefile.am	(working copy)
@@ -202,6 +202,7 @@
 	MonoDevelop.Projects/MonoDevelopFileFormat.cs \
 	MonoDevelop.Projects/PrjxFileFormat.cs \
 	MonoDevelop.Projects/Project.cs \
+	MonoDevelop.Projects/ProjectDeployFile.cs \
 	MonoDevelop.Projects/ProjectConvertTool.cs \
 	MonoDevelop.Projects/ProjectCreateInformation.cs \
 	MonoDevelop.Projects/ProjectEventArgs.cs \
Index: main/src/core/MonoDevelop.Projects/MonoDevelop.Projects.Parser/ProjectCodeCompletionDatabase.cs
===================================================================
--- main/src/core/MonoDevelop.Projects/MonoDevelop.Projects.Parser/ProjectCodeCompletionDatabase.cs	(revision 102818)
+++ main/src/core/MonoDevelop.Projects/MonoDevelop.Projects.Parser/ProjectCodeCompletionDatabase.cs	(working copy)
@@ -228,8 +228,8 @@
 					return new string[] { "Assembly:" + refId };
 				default:
 					ArrayList list = new ArrayList ();
-					foreach (string s in pr.GetReferencedFileNames ())
-						list.Add ("Assembly:" + s);
+					foreach (ProjectDeployFile f in pr.GetReferencedFiles ())
+						list.Add ("Assembly:" + f.Path);
 					return (string[]) list.ToArray (typeof(string));
 			}
 		}
Index: main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.Commands/ProjectCommands.cs
===================================================================
--- main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.Commands/ProjectCommands.cs	(revision 102818)
+++ main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.Commands/ProjectCommands.cs	(working copy)
@@ -66,6 +66,7 @@
 		Clean,
 		CleanSolution,
 		LocalCopyReference,
+		AbsolutePathReference,
 		DeployTargetList,
 		ConfigureDeployTargets,
 		CustomCommandList,
Index: main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.Gui.Pads.ProjectPad/ProjectReferenceNodeBuilder.cs
===================================================================
--- main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.Gui.Pads.ProjectPad/ProjectReferenceNodeBuilder.cs	(revision 102818)
+++ main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.Gui.Pads.ProjectPad/ProjectReferenceNodeBuilder.cs	(working copy)
@@ -89,8 +89,8 @@
 			ProjectReference pref = CurrentNode.DataItem as ProjectReference;
 			if (pref == null)
 				return;
-			foreach (string fileName in pref.GetReferencedFileNames ()) {
-				IdeApp.Workbench.OpenDocument (fileName);
+			foreach (ProjectDeployFile df in pref.GetReferencedFiles ()) {
+				IdeApp.Workbench.OpenDocument (df.Path);
 			}
 		}
 				
@@ -123,6 +123,28 @@
 			}
 		}
 		
+		[CommandHandler (ProjectCommands.AbsolutePathReference)]
+		public void ChangeAbsolutePath ()
+		{
+			ProjectReference pref = (ProjectReference) CurrentNode.DataItem;
+			pref.AbsolutePath = !pref.AbsolutePath;
+			Project project = CurrentNode.GetParentDataItem (typeof(Project), false) as Project;
+			IdeApp.ProjectOperations.SaveProject (project);
+		}
+		
+		[CommandUpdateHandler (ProjectCommands.AbsolutePathReference)]
+		public void UpdateAbsolutePath (CommandInfo info)
+		{
+			ProjectReference pref = (ProjectReference) CurrentNode.DataItem;
+			if (pref.ReferenceType == ReferenceType.Assembly) {
+				info.Checked = pref.AbsolutePath;
+				info.Enabled = true;
+			} else {
+				info.Checked = false;
+				info.Enabled = false;
+			}
+		}
+		
 		public override DragOperation CanDragNode ()
 		{
 			return DragOperation.Copy;
Index: main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.addin.xml
===================================================================
--- main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.addin.xml	(revision 102818)
+++ main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.addin.xml	(working copy)
@@ -440,6 +440,10 @@
 				type="check"
 				_description = "Copy the assembly to the output directory when building the project"
 				_label = "_Local Copy" />
+		<Command id = "MonoDevelop.Ide.Commands.ProjectCommands.AbsolutePathReference"
+				type="check"
+				_description = "File refered to by an absolute path"
+				_label = "Absolute Path" />
 		<Command id = "MonoDevelop.Ide.Commands.ProjectCommands.Stop"
 				defaultHandler = "MonoDevelop.Ide.Commands.StopHandler"
 				icon = "gtk-stop"
Index: main/docs/api/MonoDevelop.Ide.Commands/ProjectCommands.xml
===================================================================
--- main/docs/api/MonoDevelop.Ide.Commands/ProjectCommands.xml	(revision 102818)
+++ main/docs/api/MonoDevelop.Ide.Commands/ProjectCommands.xml	(working copy)
@@ -152,6 +152,12 @@
       <ReturnValue><ReturnType>MonoDevelop.Ide.Commands.ProjectCommands</ReturnType></ReturnValue>
       <Docs><summary>To be added.</summary></Docs>
     </Member>
+    <Member MemberName="AbsolutePathReference">
+      <MemberSignature Language="C#" Value="AbsolutePathReference" />
+      <MemberType>Field</MemberType>
+      <ReturnValue><ReturnType>MonoDevelop.Ide.Commands.ProjectCommands</ReturnType></ReturnValue>
+      <Docs><summary>To be added.</summary></Docs>
+    </Member>
     <Member MemberName="AddCombine">
       <MemberSignature Language="C#" Value="AddCombine" />
       <MemberType>Field</MemberType>
