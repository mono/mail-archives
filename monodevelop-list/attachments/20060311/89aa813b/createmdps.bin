#!/usr/bin/perl -w
# Create mdp files from Makefile.am files

sub resolvevars($$) {
    my $vars = shift;
    my $string = shift;
    
    do {
        $change = undef;
        @Vars = ($string =~ /\$\(([^\)]+)\)/g);
        foreach my $var (@Vars) {
            my $replace = $vars->{$var};
            if(defined($replace)) {
                $string =~ s/\$\($var\)/$replace/g;
                $change = 1;
            }
        }
    } while($change);

    return $string;
}

my %OUR_GAC = (
    "atk-sharp" => "atk-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "glib-sharp" => "glib-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "gtk-sharp" => "gtk-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "gdk-sharp" => "gdk-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "pango-sharp" => "pango-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "gecko-sharp" => "glade-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99",
    "glade-sharp" => "glade-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "gnome-sharp" => "gnome-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "gnome-vfs-sharp" => "gnome-vfs-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "gconf-sharp" => "gconf-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "gtkhtml-sharp" => "gtkhtml-sharp, Version=2.8.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "gtksourceview-sharp" => "gtksourceview-sharp, Version=1.0.0.2, Culture=neutral, PublicKeyToken=35e10195dab3c99f",
    "gladeui-sharp" => "gladeui-sharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=ccf7d78a55e9f021",
    "nunit.core" => "nunit.core, Version=2.2.0.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77",
    "nunit.framework" => "nunit.framework, Version=2.2.0.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77",
    "Mono.GetOptions" => "Mono.GetOptions, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756",
    "monodoc" => "monodoc, Version=1.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756",
    "System.Runtime.Remoting" => "System.Runtime.Remoting, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
    "System" => "System, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
    "System.Xml" => "System.Xml, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
    "Mono.Posix" => "Mono.Posix, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756",
    "System.Drawing" => "System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
    "System.Web.Services" => "System.Web.Services, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
    "System.Data" => "System.Data, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
    "ICSharpCode.SharpZipLib" => "ICSharpCode.SharpZipLib, Version=0.84.0.0, Culture=neutral, PublicKeyToken=1b03e6acf1164f73",
    "gecko-sharp" => "gecko-sharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=ccf7d78a55e9f021",
    "Boo.Lang" => "Boo.Lang, Version=1.0.0.0, Culture=neutral, PublicKeyToken=32c39770e9a21a67",
    "Boo.Lang.Useful" => "Boo.Lang.Useful, Version=1.0.0.0, Culture=neutral, PublicKeyToken=32c39770e9a21a67",
    "Boo.Lang.CodeDom" => "Boo.Lang.CodeDom, Version=1.0.0.0, Culture=neutral, PublicKeyToken=32c39770e9a21a67",
    "Boo.Lang.Compiler" => "Boo.Lang.Compiler, Version=1.0.0.0, Culture=neutral, PublicKeyToken=32c39770e9a21a67",
    "Boo.Lang.Parser" => "Boo.Lang.Parser, Version=1.0.0.0, Culture=neutral, PublicKeyToken=32c39770e9a21a67",
    "Boo.Lang.Interpreter" => "Boo.Lang.Interpreter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=32c39770e9a21a67",
    "Npgsql" => "Npgsql, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7",
    "ByteFX.Data" => "ByteFX.Data, Version=0.7.6.1, Culture=neutral, PublicKeyToken=0738eb9f132ed756",
    "Mono.Data.SqliteClient" => "Mono.Data.SqliteClient, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756",
    "System.Data.OracleClient" => "System.Data.OracleClient, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
    "Mono.Data.SybaseClient" => "Mono.Data.SybaseClient, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756",
    "Mono.Debugger" => "Mono.Debugger, Version=1.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756",
);
my %CONTRIB_DLLS = (
    "log4net" => "contrib/log4net",
    "Mono.Cecil" => "contrib/Mono.Cecil.dll",
    "FirebirdSql.Data.Firebird" => "contrib/FirebirdSql.Data.Firebird.dll",
);

my $Projects = {};

# Phase1: collect all defined variables in the Makefile.am and resolve $()
# parts where possible
foreach my $file (@ARGV) {
    open IN, $file or die "Couldn't open '$file'";
    
    $ProjectName = "";
    my $constructedline = "";
    my $VARS = {
        BOO_LIBS => "-r:Boo.Lang -r:Boo.Lang.Useful -r:Boo.Lang.CodeDom -r:Boo.Lang.Compiler -r:Boo.Lang.Parser -r:Boo.Lang.Interpreter",
        GTK_SHARP_LIBS => "-r:pango-sharp -r:atk-sharp -r:gtk-sharp -r:gdk-sharp -r:glib-sharp",
        GNOME_SHARP_LIBS => "-r:gnome-sharp",
        GCONF_SHARP_LIBS => "-r:gconf-sharp",
        GNOME_VFS_SHARP_LIBS => "-r:gnome-vfs-sharp",
        GECKO_SHARP_LIBS => "-r:gecko-sharp",
        GLADE_SHARP_LIBS => "-r:glade-sharp",
        GLADEUI_SHARP_LIBS => "-r:gladeui-sharp",
        GTKHTML_SHARP_LIBS => "-r:gtkhtml-sharp",
        GTKSOURCEVIEW_SHARP_LIBS => "-r:gtksourceview-sharp",
        MONODOC_LIBS => "-r:monodoc",
        MONO_DEBUGGER_LIBS => "-r:Mono.Debugger",
    };
    while( <IN> ) {
        # concat lines ending in \
        if($_ =~ /(.*)\\$/) {
            $constructedline .= $1;
            next;
        }
        $constructedline .= $_;

        $constructedline =~ s/\\(.)/$1/g;
        if($constructedline =~ /\s*(\w+)\s*=(.*)/) {
            $VARS->{$1} = $2;
        }

        $constructedline = "";
    }

    foreach my $var (keys %{$VARS}) {
        $VARS->{$var} = resolvevars($VARS, $VARS->{$var});
    }

    if( $VARS->{"ASSEMBLY"} =~ m/([\w\.]+)\.(dll|exe)/ ) {
        $ProjectName = $1;
        $VARS->{"_FILE"} = $file;

        $Projects->{$ProjectName} = $VARS;
    }
    close IN;
}

# part2: output projectfiles
foreach my $VARS (values %{$Projects}) {
    $ProjectName = "";
   
    # extract project infos
    @ProjectFiles = split ' ', $VARS->{"FILES"};
    @ProjectGeneratedFiles = split ' ', $VARS->{"GENERATED_FILES"};
    @ProjectRefs = split /\s*(?:-|\/)(?:r|reference):/, $VARS->{"REFS"};
    @ProjectRes = split /\s*-resource:/, $VARS->{"RESOURCES"};
    @ProjectRes = split ' ', $VARS->{"RES"};
    $VARS->{"ASSEMBLY"} =~ /([\w\-\.]+)\.(dll|exe)/;
    $ProjectName = $1;
    $ProjectTarget = "Library" if $2 eq "dll";
    $ProjectTarget = "Exe" if $2 eq "exe";
    $VARS->{"ASSEMBLY"} =~ /\s*\$\(top_builddir\)(.*\/)/;
    $BuildDir = $1;
 
    

    next if $ProjectName eq "";

    print "ProjectName: $ProjectName\n";
    my $file = $VARS->{"_FILE"};
    $file =~ s/\/([^\/]+)$//;
    $basedir = $file;
    $from_basedir_to_top = $basedir;
    $from_basedir_to_top =~ s/([^\/]+)/../g;
    $BuildDir = "$from_basedir_to_top$BuildDir";
    print "BuildDir: $BuildDir\n";
    $Language = "C#";
    $Language = "Boo" if grep(/\.boo$/, @ProjectFiles);
    print "Language: $Language\n";

    # Construct mdp file
    open OUT, "> $basedir/$ProjectName.mdp" or die "Couldn't open '$basedir/$ProjectName.t.mdp'";
    print OUT <<EOF;
<Project name="$ProjectName" fileversion="2.0" language="$Language" ctype="DotNetProject">
EOF
    if ($Language eq "C#") {
        print OUT <<EOF;
  <Configurations active="Debug">
    <Configuration name="Debug" ctype="DotNetProjectConfiguration">
      <Output directory="$BuildDir" assembly="$ProjectName" />
      <Build debugmode="True" target="$ProjectTarget" />
      <Execution runwithwarnings="True" consolepause="True" runtime="MsNet" />
      <CodeGeneration compiler="Csc" warninglevel="4" optimize="False" unsafecodeallowed="False" generateoverflowchecks="True" mainclass="" generatexmldocumentation="False" ctype="CSharpCompilerParameters" />
    </Configuration>
    <Configuration name="Release" ctype="DotNetProjectConfiguration">
      <Output directory="$BuildDir" assembly="$ProjectName" />
      <Build debugmode="False" target="$ProjectTarget" />
      <Execution runwithwarnings="True" consolepause="True" runtime="MsNet" />
      <CodeGeneration compiler="Csc" warninglevel="4" optimize="True" unsafecodeallowed="False" generateoverflowchecks="True" mainclass="" generatexmldocumentation="False" ctype="CSharpCompilerParameters" />
    </Configuration>
  </Configurations>
EOF
    } elsif($Language eq "Boo") {
        print OUT <<EOF;
  <Configurations active="Debug">
    <Configuration name="Debug" ctype="DotNetProjectConfiguration">
      <Output directory="$BuildDir" assembly="$ProjectName" />
      <Build debugmode="True" target="$ProjectTarget" />
      <Execution runwithwarnings="True" consolepause="True" runtime="MsNet" />
      <CodeGeneration genwarnings="False" ducky="False" culture="" ctype="BooCompilerParameters" />
    </Configuration>
    <Configuration name="Release" ctype="DotNetProjectConfiguration">
      <Output directory="$BuildDir" assembly="$ProjectName" />
      <Build debugmode="False" target="$ProjectTarget" />
      <Execution runwithwarnings="True" consolepause="True" runtime="MsNet" />
      <CodeGeneration genwarnings="False" ducky="False" culture="" ctype="BooCompilerParameters" />
    </Configuration>
  </Configurations>
EOF
    }

    print OUT <<EOF;
  <DeploymentInformation strategy="File">
    <excludeFiles />
  </DeploymentInformation>
  <Contents>
EOF

    foreach my $res (@ProjectRes) {
        print OUT "    <File name=\"$res\" subtype=\"Code\" buildaction=\"EmbedAsResource\" />\n"
    }
    foreach my $pfile (@ProjectGeneratedFiles,@ProjectFiles) {
	print OUT "    <File name=\"$pfile\" subtype=\"Code\" buildaction=\"Compile\" />\n"
    }
    print OUT <<EOF;
  </Contents>
  <References>
EOF
    foreach my $ref (@ProjectRefs) {
        next if $ref =~ /^\s*$/;
        $ref =~ s/\.dll$//g;
        if($ref =~ m/\$\((?:top_builddir|top_srcdir)\).*\/([^\/]+)/) {
            if(defined($CONTRIB_DLLS{$1})) {
                print OUT "    <ProjectReference type=\"Assembly\" localcopy=\"True\" refto=\"$from_basedir_to_top/$CONTRIB_DLLS{$1}\" />\n";
            } else {
                print OUT "    <ProjectReference type=\"Project\" localcopy=\"True\" refto=\"$1\" />\n";
            }
        } elsif($ref =~ m/\$\(srcdir\)\/(.*)$/) {
            print OUT "    <ProjectReference type=\"Assembly\" localcopy=\"True\" refto=\"$1\" />\n";
        } else {
            # try to find out assembly
            if(defined($OUR_GAC{$ref})) {
                print OUT "    <ProjectReference type=\"Gac\" localcopy=\"True\" refto=\"$OUR_GAC{$ref}\" />\n";
            } else {
                print "Assembly '$ref' not known\n";
            }
        }
    }

    print OUT <<EOF;
  </References>
</Project>
EOF
    close OUT;
}

