Index: Services/SystemAssemblyService.cs
===================================================================
--- Services/SystemAssemblyService.cs	(revision 2737)
+++ Services/SystemAssemblyService.cs	(working copy)
@@ -1,225 +1,67 @@
 using System;
 using System.IO;
 using System.Collections;
-using System.Diagnostics;
-using System.Reflection;
-
 using MonoDevelop.Core.Services;
 
 namespace MonoDevelop.Services
 {
 	public class SystemAssemblyService : AbstractService
 	{
-		Hashtable assemblyPathToPackage = new Hashtable ();
-		Hashtable assemblyFullNameToPath = new Hashtable ();
-		bool initialized;
+		private readonly Hashtable resolvedAssemblies = new Hashtable ();
+		private string gacPath = String.Empty;
 
-		public ICollection AssemblyPaths
+		protected override void OnInitialize (EventArgs e)
 		{
-			get {
-				if (!initialized)
-					Initialize ();
-					
-				return assemblyPathToPackage.Keys;
-			}
+			gacPath = GetMonoGac ();
+//			if (gacPath == String.Empty)
+//				gacPath = Get...Gac (); 
+			resolvedAssemblies.Clear ();
 		}
-
-		public string GetPackageFromFullName (string fullname)
+		
+		protected override void OnUnload (EventArgs e)
 		{
-			if (!initialized)
-				Initialize ();
-					
-			if (!assemblyFullNameToPath.Contains (fullname))
-				return String.Empty;
-			
-			string path = (string)assemblyFullNameToPath[fullname];
-			if (!assemblyPathToPackage.Contains (path))
-				return String.Empty;
-			
-			return (string)assemblyPathToPackage[path];
+			gacPath = String.Empty;
 		}
-	
-		public string GetAssemblyLocation (string assemblyName)
+		
+		private string GetMonoGac ()
 		{
-			if (assemblyName == "mscorlib")
-				return typeof(object).Assembly.Location;
-
-			AssemblyLocator locator = (AssemblyLocator) Runtime.ProcessService.CreateExternalProcessObject (typeof(AssemblyLocator), true);
-			using (locator) {
-				return locator.Locate (assemblyName);
-			}
+			// Copied from gacutils
+			System.Reflection.PropertyInfo gac = typeof (System.Environment).GetProperty ("GacPath", System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.NonPublic);
+			if (gac == null)
+				return String.Empty;
+			System.Reflection.MethodInfo getGac = gac.GetGetMethod (true);
+			return System.IO.Path.Combine ((string) getGac.Invoke (null, null), "");
 		}
 		
-		new void Initialize ()
+		public string GetAssemblyLocation (string AssemblyFullName)
 		{
-			initialized = true;
-
-			//Pull up assemblies from the installed mono system.
-			string prefix = Path.GetDirectoryName (typeof (int).Assembly.Location);
-			if (prefix.IndexOf ("mono/1.0") == -1) {
-				prefix = Path.Combine (Path.Combine (prefix, "mono"), "1.0");
+			if (gacPath == String.Empty)
+				return String.Empty;
+			
+			if (!resolvedAssemblies.Contains (AssemblyFullName))
+			{
+				string[] info = AssemblyFullName.Split (',');
+				string assemblyName = info[0].Trim ();
+				string assemblyVersion = info[1].Split ('=')[1].Trim ();
+				string assemblyCulture = info[2].Split ('=')[1].Trim ();
+				if (assemblyCulture.ToLower ().Equals ("neutral"))
+					assemblyCulture = String.Empty;
+				string assemblyToken = info[3].Split ('=')[1].Trim ();
+				resolvedAssemblies[AssemblyFullName] = String.Format ("{0}{5}{1}{5}{2}_{3}_{4}{5}{1}.dll", gacPath, assemblyName, assemblyVersion, assemblyCulture, assemblyToken, Path.DirectorySeparatorChar);
 			}
-			foreach (string assembly in Directory.GetFiles (prefix, "*.dll")) {
-				AddAssembly (assembly, "MONO-SYSTEM");
-			}
-	
-			string search_dirs = Environment.GetEnvironmentVariable ("PKG_CONFIG_PATH");
-			string libpath = Environment.GetEnvironmentVariable ("PKG_CONFIG_LIBPATH");
-			if (libpath == null || libpath.Length == 0) {
-				string path_dirs = Environment.GetEnvironmentVariable ("PATH");
-				foreach (string pathdir in path_dirs.Split (':')) {
-					if (pathdir == null)
-						continue;
-					if (File.Exists (pathdir + Path.DirectorySeparatorChar + "pkg-config")) {
-						libpath = pathdir + Path.DirectorySeparatorChar + "../lib/pkgconfig/";
-						break;
-					}
-				}
-			}
-			search_dirs += ":" + libpath;
-			if (search_dirs != null && search_dirs.Length > 0) {
-				ArrayList scanDirs = new ArrayList ();
-				foreach (string potentialDir in search_dirs.Split (':')) {
-					if (!scanDirs.Contains (potentialDir))
-						scanDirs.Add (potentialDir);
-				}
-				foreach (string pcdir in scanDirs) {
-					if (pcdir == null)
-						continue;
-	
-					if (Directory.Exists (pcdir)) {
-						//try  {
-							foreach (string pcfile in Directory.GetFiles (pcdir, "*.pc")) {
-								ParsePCFile (pcfile);
-							}
-						//} catch { }
-					}
-				}
-			}
+			string location = resolvedAssemblies[AssemblyFullName] as string;
+			return location == null ? String.Empty : location;
 		}
-	
-		private void ParsePCFile (string pcfile)
+		
+		[Obsolete ("Skip this and use GetAssemblyLocation () instead.")]
+		public string GetPackageFromFullName (string reference)
 		{
-			ArrayList fullassemblies = null;
-			using (StreamReader reader = new StreamReader (pcfile)) {
-				string line;
-				while ((line = reader.ReadLine ()) != null) {
-					string lowerLine = line.ToLower ();
-					if (lowerLine.StartsWith ("libs:") && lowerLine.IndexOf (".dll") != -1) {
-						string choppedLine = line.Substring (5).Trim ();
-						if (choppedLine.IndexOf ("-lib:") != -1 || choppedLine.IndexOf ("/lib:") != -1) {
-							fullassemblies = GetAssembliesWithLibInfo (choppedLine, pcfile);
-						} else {
-							fullassemblies = GetAssembliesWithoutLibInfo (choppedLine, pcfile);
-						}
-					}
-				}
-			}
-	
-			if (fullassemblies == null)
-				return;
-	
-			foreach (string assembly in fullassemblies) {
-				AddAssembly (assembly, pcfile);
-			}
+			return "MONO-SYSTEM";
 		}
 
-		private void AddAssembly (string assemblyfile, string pcfile)
+		public string GacPath
 		{
-			if (!File.Exists (assemblyfile))
-				return;
-
-			try {
-				System.Reflection.AssemblyName an = System.Reflection.AssemblyName.GetAssemblyName (assemblyfile);
-				assemblyFullNameToPath[an.FullName] = assemblyfile;
-				assemblyPathToPackage[assemblyfile] = Path.GetFileNameWithoutExtension (pcfile);
-			} catch { 
-			}
+			get { return gacPath; }
 		}
-	
-		private ArrayList GetAssembliesWithLibInfo (string line, string file)
-		{
-			ArrayList references = new ArrayList ();
-			ArrayList libdirs = new ArrayList ();
-			ArrayList retval = new ArrayList ();
-			foreach (string piece in line.Split (' ')) {
-				if (piece.ToLower ().Trim ().StartsWith ("/r:") || piece.ToLower ().Trim ().StartsWith ("-r:")) {
-					references.Add (ProcessPiece (piece.Substring (3).Trim (), file));
-				} else if (piece.ToLower ().Trim ().StartsWith ("/lib:") || piece.ToLower ().Trim ().StartsWith ("-lib:")) {
-					libdirs.Add (ProcessPiece (piece.Substring (5).Trim (), file));
-				}
-			}
-	
-			foreach (string refrnc in references) {
-				foreach (string libdir in libdirs) {
-					if (File.Exists (libdir + Path.DirectorySeparatorChar + refrnc)) {
-						retval.Add (libdir + Path.DirectorySeparatorChar + refrnc);
-					}
-				}
-			}
-	
-			return retval;
-		}
-	
-		private ArrayList GetAssembliesWithoutLibInfo (string line, string file)
-		{
-			ArrayList references = new ArrayList ();
-			foreach (string reference in line.Split (' ')) {
-				if (reference.ToLower ().Trim ().StartsWith ("/r:") || reference.ToLower ().Trim ().StartsWith ("-r:")) {
-					string final_ref = reference.Substring (3).Trim ();
-					references.Add (ProcessPiece (final_ref, file));
-				}
-			}
-			return references;
-		}
-	
-		private string ProcessPiece (string piece, string pcfile)
-		{
-			int start = piece.IndexOf ("${");
-			if (start == -1)
-				return piece;
-	
-			int end = piece.IndexOf ("}");
-			if (end == -1)
-				return piece;
-	
-			string variable = piece.Substring (start + 2, end - start - 2);
-			string interp = GetVariableFromPkgConfig (variable, Path.GetFileNameWithoutExtension (pcfile));
-			return ProcessPiece (piece.Replace ("${" + variable + "}", interp), pcfile);
-		}
-	
-		private string GetVariableFromPkgConfig (string var, string pcfile)
-		{
-			ProcessStartInfo psi = new ProcessStartInfo ("pkg-config");
-			psi.RedirectStandardOutput = true;
-			psi.UseShellExecute = false;
-			psi.Arguments = String.Format ("--variable={0} {1}", var, pcfile);
-			Process p = new Process ();
-			p.StartInfo = psi;
-			p.Start ();
-			p.WaitForExit ();
-			string ret = p.StandardOutput.ReadToEnd ().Trim ();
-			if (ret == null || ret.Length == 0)
-				return String.Empty;
-			return ret;
-		}
 	}
-	
-	internal class AssemblyLocator: RemoteProcessObject
-	{
-		public string Locate (string assemblyName)
-		{
-			Assembly asm;
-			try {
-				asm = Assembly.Load (assemblyName);
-			}
-			catch {
-				asm = Assembly.LoadWithPartialName (assemblyName);
-			}
-			if (asm == null)
-				return null;
-			
-			return asm.Location;
-		}
-	}
 }
Index: Gui/Dialogs/ReferenceDialog/GacReferencePanel.cs
===================================================================
--- Gui/Dialogs/ReferenceDialog/GacReferencePanel.cs	(revision 2737)
+++ Gui/Dialogs/ReferenceDialog/GacReferencePanel.cs	(working copy)
@@ -27,7 +27,7 @@
 		{
 			this.selectDialog = selectDialog;
 			
-			store = new TreeStore (typeof (string), typeof (string), typeof(string), typeof(bool), typeof(string));
+			store = new TreeStore (typeof (string), typeof (string), typeof(bool), typeof(string));
 			treeView = new TreeView (store);
 
 			TreeViewColumn firstColumn = new TreeViewColumn ();
@@ -35,7 +35,7 @@
 			CellRendererToggle tog_render = new CellRendererToggle ();
 			tog_render.Toggled += new Gtk.ToggledHandler (AddReference);
 			firstColumn.PackStart (tog_render, false);
-			firstColumn.AddAttribute (tog_render, "active", 3);
+			firstColumn.AddAttribute (tog_render, "active", 2);
 
 			CellRendererText text_render = new CellRendererText ();
 			firstColumn.PackStart (text_render, true);
@@ -43,8 +43,6 @@
 			
 			treeView.AppendColumn (firstColumn);
 			treeView.AppendColumn (GettextCatalog.GetString ("Version"), new CellRendererText (), "text", 1);
-			// FIXME: this seems useless
-			//treeView.AppendColumn (GettextCatalog.GetString ("Path"), new CellRendererText (), "text", 2);
 
 			store.SetSortColumnId (0, SortType.Ascending);
 			store.SetSortFunc (0, new TreeIterCompareFunc (SortTree));
@@ -85,19 +83,40 @@
 		{
 			Gtk.TreeIter iter;
 			store.GetIterFromString (out iter, e.Path);
-			if ((bool)store.GetValue (iter, 3) == false) {
-				store.SetValue (iter, 3, true);
-				selectDialog.AddReference(ReferenceType.Gac,
-				                          (string)store.GetValue (iter, 0),
-				                          (string)store.GetValue (iter, 4));
-				
+			if ((bool)store.GetValue (iter, 2) == false) {
+				// Unselect all references with the same name, so that 2 references with different versions wouldn't get selected.
+				string assemblyName = store.GetValue (iter, 0) as string;
+				Gtk.TreeIter childIter;
+				store.GetIterFirst (out childIter);
+				do {
+					if (store.GetValue (childIter, 0) as string != assemblyName)
+						continue;
+					if ((bool) store.GetValue (childIter, 2) != true)
+						continue;
+					
+					RemoveReference (childIter);
+				} while (store.IterNext (ref childIter));
+				// Select reference
+				store.SetValue (iter, 2, true);
+				selectDialog.AddReference (
+					ReferenceType.Gac,
+					(string) store.GetValue (iter, 0),
+					(string) store.GetValue (iter, 3)
+				);
 			} else {
-				store.SetValue (iter, 3, false);
-				selectDialog.RemoveReference (ReferenceType.Gac,
-				                              (string)store.GetValue (iter, 0),
-				                              (string)store.GetValue (iter, 4));
+				RemoveReference (iter);
 			}
 		}
+		
+		private void RemoveReference (Gtk.TreeIter iter)
+		{
+			store.SetValue (iter, 2, false);
+			selectDialog.RemoveReference (
+				ReferenceType.Gac,
+				(string) store.GetValue (iter, 0),
+				(string) store.GetValue (iter, 3)
+			);
+		}
 
 		public void SignalRefChange (string refLoc, bool newstate)
 		{
@@ -108,23 +127,48 @@
 			}
 
 			do {
-				if ((string)store.GetValue (looping_iter, 4) == refLoc) {
-					store.SetValue (looping_iter, 3, newstate);
+				if ((string)store.GetValue (looping_iter, 3) == refLoc) {
+					store.SetValue (looping_iter, 2, newstate);
 					return;
 				}
 			} while (store.IterNext (ref looping_iter));
 		}
 		
-		void PrintCache()
+		private bool FillWithMono (TreeStore store)
 		{
-			foreach (string assemblyPath in Runtime.SystemAssemblyService.AssemblyPaths) {
-				try {
-					System.Reflection.AssemblyName an = System.Reflection.AssemblyName.GetAssemblyName (assemblyPath);
-					store.AppendValues (an.Name, an.Version.ToString (), System.IO.Path.GetFileName (assemblyPath), false, an.FullName);
-				}catch {
+			string gac_path = Runtime.SystemAssemblyService.GacPath;
+			if (gac_path == String.Empty)
+				return false;
+			
+			DirectoryInfo gac = new DirectoryInfo (gac_path);
+			foreach (DirectoryInfo asm in gac.GetDirectories ())
+			{
+				string assemblyName = asm.Name;
+				foreach (DirectoryInfo ver in asm.GetDirectories ())
+				{
+					string[] verData = ver.Name.Split ('_');
+					string assemblyVersion = verData[0];
+					string assemblyCulture = verData[1] == String.Empty ? "neutral" : verData[1];
+					string assemblyToken = verData[2];
+					string assemblyPath = String.Format ("{0}/{1}.dll", ver.FullName, assemblyName);
+					if (File.Exists (assemblyPath))
+					{
+						store.AppendValues (
+							assemblyName,
+							assemblyVersion,
+							false,
+							String.Format ("{0}, Version={1}, Culture={2}, PublicKeyToken={3}", assemblyName, assemblyVersion, assemblyCulture, assemblyToken)
+						);
+					}
 				}
 			}
+			return true;
 		}
+
+		void PrintCache()
+		{
+			FillWithMono (store);
+		}
 	}
 }
 
Index: Gui/Pads/ProjectPad/ProjectReferenceNodeBuilder.cs
===================================================================
--- Gui/Pads/ProjectPad/ProjectReferenceNodeBuilder.cs	(revision 2737)
+++ Gui/Pads/ProjectPad/ProjectReferenceNodeBuilder.cs	(working copy)
@@ -75,7 +75,9 @@
 					label = Path.GetFileName(pref.Reference);
 					break;
 				case ReferenceType.Gac:
-					label = pref.Reference.Split(',')[0];
+					string[] info = pref.Reference.Split(',');
+					string version = info[1].Split ('=')[1];
+					label = String.Format ("{0} ({1})", info[0], version);
 					break;
 				default:
 					throw new NotImplementedException("reference type : " + pref.ReferenceType);
Index: ChangeLog
===================================================================
--- ChangeLog	(revision 2737)
+++ ChangeLog	(working copy)
@@ -1,3 +1,15 @@
+2005-08-11  Mart Roosmaa <roosmaa@gmail.com>
+
+	* Services/SystemAssemblyService.cs: Rewrote this assembly to support
+	assemblies from GAC and removed package (.pc) stuff as this shouldn't
+	have to do anything with GAC.
+	* Gui/Dialogs/ReferenceDialog/GacReferencePanel.cs: Updated populating
+	the treeview.
+	* Gui/Pads/ProjectPad/ProjectReferenceNodeBuilder.cs: Display assembly
+	version after the name.
+	* Internal/Project/Project/ProjectReference.cs: Resolve GAC assemblies
+	better.
+
 2005-08-10  Lluis Sanchez Gual  <lluis@novell.com> 
 
 	* Internal/Project/Project/ProjectReference.cs: Find referenced projects
Index: Internal/Project/Project/ProjectReference.cs
===================================================================
--- Internal/Project/Project/ProjectReference.cs	(revision 2737)
+++ Internal/Project/Project/ProjectReference.cs	(working copy)
@@ -113,8 +113,8 @@
 					return reference;
 				
 				case ReferenceType.Gac:
-					string file = Runtime.SystemAssemblyService.GetAssemblyLocation (GetPathToGACAssembly (this));
-					return file == null ? reference : file;
+					string file = Runtime.SystemAssemblyService.GetAssemblyLocation (reference);
+					return file == String.Empty ? reference : file;
 				case ReferenceType.Project:
 					if (ownerProject != null) {
 						Combine c = ownerProject.RootCombine;
@@ -156,37 +156,6 @@
 			}
 		}
 		
-		/// <summary>
-		/// This method returns the absolute path to an GAC assembly.
-		/// </summary>
-		/// <param name ="refInfo">
-		/// The reference information containing a GAC reference information.
-		/// </param>
-		/// <returns>
-		/// the absolute path to the GAC assembly which refInfo points to.
-		/// </returns>
-		static string GetPathToGACAssembly(ProjectReference refInfo)
-		{ // HACK : Only works on windows.
-			Debug.Assert(refInfo.ReferenceType == ReferenceType.Gac);
-			string[] info = refInfo.Reference.Split(',');
-			
-			//if (info.Length < 4) {
-			return info[0];
-			//	}
-			
-			/*string aName      = info[0];
-			string aVersion   = info[1].Substring(info[1].LastIndexOf('=') + 1);
-			string aPublicKey = info[3].Substring(info[3].LastIndexOf('=') + 1);
-			
-			return System.Environment.GetFolderPath(Environment.SpecialFolder.System) + 
-			       Path.DirectorySeparatorChar + ".." +
-			       Path.DirectorySeparatorChar + "assembly" +
-			       Path.DirectorySeparatorChar + "GAC" +
-			       Path.DirectorySeparatorChar + aName +
-			       Path.DirectorySeparatorChar + aVersion + "__" + aPublicKey +
-			       Path.DirectorySeparatorChar + aName + ".dll";*/
-		}
-		
 		public object Clone()
 		{
 			return MemberwiseClone();