Index: main/src/addins/TextTemplating/MonoDevelop.TextTemplating/ChangeLog
===================================================================
--- main/src/addins/TextTemplating/MonoDevelop.TextTemplating/ChangeLog	(revision 158554)
+++ main/src/addins/TextTemplating/MonoDevelop.TextTemplating/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2010-06-06  Dale Ragan  <dale.ragan@sinesignal.com>
+
+	* TextTemplatingTool.cs: Removed ThreadAsyncOperation and 
+	  moved it to MonoDevelop.Ide.CustomTools to make it more 
+	  visible for re-use.
+
 2010-06-01  Michael Hutchinson  <mhutchinson@novell.com>
 
 	* TextTemplatingTool.cs: Make ThreadAsyncOperation public.
Index: main/src/addins/TextTemplating/MonoDevelop.TextTemplating/TextTemplatingTool.cs
===================================================================
--- main/src/addins/TextTemplating/MonoDevelop.TextTemplating/TextTemplatingTool.cs	(revision 158554)
+++ main/src/addins/TextTemplating/MonoDevelop.TextTemplating/TextTemplatingTool.cs	(working copy)
@@ -31,7 +31,6 @@
 using System.IO;
 using Mono.TextTemplating;
 using MonoDevelop.Core;
-using System.Threading;
 
 namespace MonoDevelop.TextTemplating
 {
@@ -55,63 +54,6 @@
 		}
 	}
 	
-	public class ThreadAsyncOperation : IAsyncOperation
-	{
-		Thread thread;
-		bool cancelled;
-		SingleFileCustomToolResult result;
-		Action task;
-		
-		public ThreadAsyncOperation (Action task, SingleFileCustomToolResult result)
-		{
-			if (result == null)
-				throw new ArgumentNullException ("result");
-			
-			this.task = task;
-			this.result = result;
-			thread = new Thread (Run);
-			thread.Start ();
-		}
-		
-		void Run ()
-		{
-			try {
-				task ();
-			} catch (ThreadAbortException ex) {
-				result.UnhandledException = ex;
-				Thread.ResetAbort ();
-			} catch (Exception ex) {
-				result.UnhandledException = ex;
-			}
-			if (Completed != null)
-				Completed (this);
-		}
-		
-		public event OperationHandler Completed;
-		
-		public void Cancel ()
-		{
-			thread.Abort ();
-		}
-		
-		public void WaitForCompleted ()
-		{
-			thread.Join ();
-		}
-		
-		public bool IsCompleted {
-			get { return !thread.IsAlive; }
-		}
-		
-		public bool Success {
-			get { return !cancelled && result.Success; }
-		}
-		
-		public bool SuccessWithWarnings {
-			get { return !cancelled && result.SuccessWithWarnings; }
-		}
-	}
-	
 	class MonoDevelopTemplatingHost : TemplateGenerator
 	{
 	}
Index: main/src/core/MonoDevelop.Ide/ChangeLog
===================================================================
--- main/src/core/MonoDevelop.Ide/ChangeLog	(revision 158554)
+++ main/src/core/MonoDevelop.Ide/ChangeLog	(working copy)
@@ -1,3 +1,9 @@
+2010-06-06  Dale Ragan  <dale.ragan@sinesignal.com>
+
+	* MonoDevelop.Ide.CustomTools/CustomTool.cs:
+	  Added ThreadAsyncOperation and removed it from 
+	  MonoDevelop.TextTemplating to make it more visible for re-use.
+
 2010-06-04  Lluis Sanchez Gual  <lluis@novell.com>
 
 	* MonoDevelop.Ide.Commands/ToolsCommands.cs: Use the correct
Index: main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.CustomTools/CustomTool.cs
===================================================================
--- main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.CustomTools/CustomTool.cs	(revision 158554)
+++ main/src/core/MonoDevelop.Ide/MonoDevelop.Ide.CustomTools/CustomTool.cs	(working copy)
@@ -28,6 +28,7 @@
 using MonoDevelop.Projects;
 using System.CodeDom.Compiler;
 using MonoDevelop.Core;
+using System.Threading;
 
 namespace MonoDevelop.Ide.CustomTools
 {
@@ -67,5 +68,62 @@
 			}
 		}
 	}
+	
+	public class ThreadAsyncOperation : IAsyncOperation
+	{
+		Thread thread;
+		bool cancelled;
+		SingleFileCustomToolResult result;
+		Action task;
+		
+		public ThreadAsyncOperation (Action task, SingleFileCustomToolResult result)
+		{
+			if (result == null)
+				throw new ArgumentNullException ("result");
+			
+			this.task = task;
+			this.result = result;
+			thread = new Thread (Run);
+			thread.Start ();
+		}
+		
+		void Run ()
+		{
+			try {
+				task ();
+			} catch (ThreadAbortException ex) {
+				result.UnhandledException = ex;
+				Thread.ResetAbort ();
+			} catch (Exception ex) {
+				result.UnhandledException = ex;
+			}
+			if (Completed != null)
+				Completed (this);
+		}
+		
+		public event OperationHandler Completed;
+		
+		public void Cancel ()
+		{
+			thread.Abort ();
+		}
+		
+		public void WaitForCompleted ()
+		{
+			thread.Join ();
+		}
+		
+		public bool IsCompleted {
+			get { return !thread.IsAlive; }
+		}
+		
+		public bool Success {
+			get { return !cancelled && result.Success; }
+		}
+		
+		public bool SuccessWithWarnings {
+			get { return !cancelled && result.SuccessWithWarnings; }
+		}
+	}
 }
 