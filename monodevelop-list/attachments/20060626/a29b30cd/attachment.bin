diff -ruN stetic/libstetic/AssemblyWidgetLibrary.cs stetic.clean/libstetic/AssemblyWidgetLibrary.cs
--- stetic/libstetic/AssemblyWidgetLibrary.cs	2006-06-09 22:59:49.000000000 +0200
+++ stetic.clean/libstetic/AssemblyWidgetLibrary.cs	2006-06-17 02:28:05.000000000 +0200
@@ -7,7 +7,10 @@
 	public class AssemblyWidgetLibrary: WidgetLibrary
 	{
 		Assembly assembly;
-		
+		public Assembly Asm {
+			get { return (assembly); }
+		}
+				
 		public AssemblyWidgetLibrary (Assembly assembly)
 		{
 			this.assembly = assembly;
diff -ruN stetic/libstetic/ClassDescriptor.cs stetic.clean/libstetic/ClassDescriptor.cs
--- stetic/libstetic/ClassDescriptor.cs	2006-06-09 22:59:49.000000000 +0200
+++ stetic.clean/libstetic/ClassDescriptor.cs	2006-06-24 20:46:00.000000000 +0200
@@ -9,6 +9,20 @@
 	
 	public abstract class ClassDescriptor
 	{
+		public struct ToolboxItemDefinitions
+		{
+			public string Name;
+			public string Category;
+			public string Description;
+			
+			public ToolboxItemDefinitions (string aName, string aCategory, string aDescription)
+			{
+				Name = aName;
+				Category = aCategory;
+				Description = aDescription;
+			}
+		}
+		
 		protected string label, category, cname;
 		protected bool deprecated, hexpandable, vexpandable, allowChildren = true;
 		
@@ -19,6 +33,24 @@
 		protected ItemGroup contextMenu;
 		protected ItemGroup internalChildren;
 		
+		private bool isToolboxItem = false;
+		public bool IsToolboxItem {
+			get { return (isToolboxItem); }
+			set { isToolboxItem = value; }
+		}
+
+		private System.Type widgetType = (System.Type) null;
+		public System.Type WidgetType {
+			get {
+				if (isToolboxItem == true)
+					return (widgetType);
+				return ((System.Type) null);
+			}
+			set { widgetType = value; }
+		}
+		
+		public ToolboxItemDefinitions AssemblyDefinitions;
+
 		WidgetLibrary library;
 		PropertyDescriptor[] initializationProperties;
 		static PropertyDescriptor[] emptyPropArray = new PropertyDescriptor[0];
@@ -32,14 +64,27 @@
 			else if (cname == null)
 				cname = elem.GetAttribute ("type");
 
-			label = elem.GetAttribute ("label");
+			if (IsToolboxItem == false)
+				label = elem.GetAttribute ("label");
+			else {
+				label = AssemblyDefinitions.Description;
+				if (label == "")
+					label = elem.GetAttribute ("label");
+			}
+			
 			if (label == "")
 				label = WrappedTypeName;
 			
 			if (elem.HasAttribute ("allow-children"))
 				allowChildren = elem.GetAttribute ("allow-children") == "yes";
 				
-			category = elem.GetAttribute ("palette-category");
+			if (IsToolboxItem == false)
+				category = elem.GetAttribute ("palette-category");
+			else {
+				category = AssemblyDefinitions.Category;
+				if (category == "")
+					category = elem.GetAttribute ("palette-category");
+			}
 
 			if (elem.HasAttribute ("deprecated"))
 				deprecated = true;
diff -ruN stetic/libstetic/ItemGroup.cs stetic.clean/libstetic/ItemGroup.cs
--- stetic/libstetic/ItemGroup.cs	2006-02-24 17:59:47.000000000 +0100
+++ stetic.clean/libstetic/ItemGroup.cs	2006-06-26 15:36:21.000000000 +0200
@@ -19,7 +19,7 @@
 		{
 			label = elem.GetAttribute ("label");
 			name = elem.GetAttribute ("name");
-
+			
 			XmlNodeList nodes = elem.SelectNodes ("property | command | signal");
 			for (int i = 0; i < nodes.Count; i++) {
 				XmlElement item = (XmlElement)nodes[i];
diff -ruN stetic/libstetic/Registry.cs stetic.clean/libstetic/Registry.cs
--- stetic/libstetic/Registry.cs	2006-03-15 16:40:40.000000000 +0100
+++ stetic.clean/libstetic/Registry.cs	2006-06-26 04:43:16.000000000 +0200
@@ -1,5 +1,6 @@
 using System;
 using System.Collections;
+using System.ComponentModel;
 using System.Reflection;
 using System.Xml;
 using System.Xml.Xsl;
@@ -7,15 +8,41 @@
 namespace Stetic {
 	public static class Registry {
 
+		public delegate void PaletteGroupsChanged();
+
+		public class ControlGroup {
+			public string Name;
+			public string DisplayName;
+			public int Ref;
+			
+			public ControlGroup (string name, string displayname)
+			{
+				Name = name;
+				DisplayName = displayname;
+				Ref = 1;
+			}
+		}
+		
 		static ArrayList libraries = new ArrayList ();
 		static ArrayList classes = new ArrayList ();
 		
+		private static ArrayList groups = new ArrayList ();
+		public static ArrayList Groups {
+			get { return (groups); }
+		}
+		
 		static XslTransform gladeImport, gladeExport;
 		static AssemblyWidgetLibrary coreLib;
 		
 		public static event EventHandler RegistryChanging;
 		public static event EventHandler RegistryChanged;
 
+		public static event PaletteGroupsChanged onGroupsChanged = null;
+		public static event PaletteGroupsChanged OnGroupsChanged {
+			add { onGroupsChanged += value; }
+			remove { onGroupsChanged -= value; }
+		}
+		
 		static Registry ()
 		{
 			coreLib = new AssemblyWidgetLibrary (Assembly.GetExecutingAssembly ());
@@ -26,10 +53,120 @@
 			get { return coreLib; }
 		}
 		
+		public static bool ControlGroupExists (string name)
+		{
+			foreach (ControlGroup cg in groups)
+				if (cg.Name == name)
+					return (true);
+			return (false);
+		}
+		
+		public static void AddControlGroup (string name, string displayname)
+		{
+			foreach (ControlGroup cg in groups)
+				if (cg.Name == name) {
+					cg.Ref++;
+					return;
+				}
+				
+			groups.Add (new ControlGroup (name, displayname));
+			if (onGroupsChanged != null)
+				onGroupsChanged();
+		}
+		
+		public static void RemoveControlGroup (string name)
+		{
+			ControlGroup res = (ControlGroup) null;
+			foreach (ControlGroup cg in groups)
+				if (cg.Name == name) {
+					res = cg;
+					break;
+				}
+			if (res != null) {
+				res.Ref--;
+				if (res.Ref <= 0) {
+					groups.Remove (res);
+					if (onGroupsChanged != null)
+						onGroupsChanged();
+				}
+			}
+		}
+		
+		public static void DoRegisterWidgetLibrary (WidgetLibrary library, bool register)
+		{
+			if (library is AssemblyWidgetLibrary) {
+				AssemblyWidgetLibrary asm = (AssemblyWidgetLibrary) library;
+				bool onlygroup, group = false;
+				bool ctrl, cat, desc = false;
+				string name, category, description = "";
+				foreach (System.Type type in asm.Asm.GetExportedTypes()) {
+					Attribute[] attrs = Attribute.GetCustomAttributes (type);
+					onlygroup = ((type.IsAbstract == true) || (type.IsNotPublic == true));
+					
+					ctrl = false; cat = false; desc = false; group = false;
+					name = ""; category = ""; description = "";
+					foreach (Attribute attr in attrs) {
+						if (attr is ToolboxItemAttribute) {
+							name = type.Name;
+							if (attr.Equals(ToolboxItemAttribute.Default) == true) {
+								ctrl = true;
+								if ((type.IsAbstract == true) || (type.IsNotPublic == true))
+									continue;
+							}
+							else
+								// Group specifiying class has to be abstract
+								if ((attr.Equals(ToolboxItemAttribute.None) == true) && (type.IsAbstract == true)) {
+									group = true;
+									ctrl = true;
+								}
+							if ((ctrl == false) && (group == false))
+								continue;
+						}
+						if (attr is CategoryAttribute) {
+							cat = true;
+							category = (attr as CategoryAttribute).Category;
+						}
+						if (attr is DescriptionAttribute) {
+							desc = true;
+							description = (attr as DescriptionAttribute).Description;
+						}
+					}
+
+					if (ctrl == true)
+						if (group == true) {
+							if (description == "")
+								description = category;
+							if (register == true)
+								AddControlGroup (category, description);
+							else
+								RemoveControlGroup (category);
+						}
+						else
+							if (ControlGroupExists(category) == false) {
+								category = "unsorted";
+								if (ControlGroupExists("unsorted") == false)
+									AddControlGroup ("unsorted", "[Unsorted]");
+							}
+				}
+			}
+		}
+
+		public static void RegisterWidgetLibraryGroups (WidgetLibrary library)
+		{
+			DoRegisterWidgetLibrary (library, true);
+		}
+		
+		public static void UnregisterWidgetLibraryGroups (WidgetLibrary library)
+		{
+			DoRegisterWidgetLibrary (library, false);
+		}
+
 		public static void RegisterWidgetLibrary (WidgetLibrary library)
 		{
 			NotifyChanging ();
 			
+			RegisterWidgetLibraryGroups (library);
+			
 			libraries.Add (library);
 			library.Load ();
 			classes.AddRange (library.AllClasses);
@@ -45,6 +182,8 @@
 
 			NotifyChanging ();
 
+			UnregisterWidgetLibraryGroups (library);
+
 			libraries.Remove (library);
 			InternalUpdate ();
 
diff -ruN stetic/libstetic/TypedClassDescriptor.cs stetic.clean/libstetic/TypedClassDescriptor.cs
--- stetic/libstetic/TypedClassDescriptor.cs	2006-05-19 20:32:44.000000000 +0200
+++ stetic.clean/libstetic/TypedClassDescriptor.cs	2006-06-26 21:28:06.000000000 +0200
@@ -1,5 +1,6 @@
 using System;
 using System.Collections;
+using System.ComponentModel;
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Xml;
@@ -13,6 +14,7 @@
 
 		MethodInfo ctorMethodInfo;
 		MethodInfo ctorMethodInfoWithClass;
+		MethodInfo ctorDirectMethodInfoWithClass;
 		ConstructorInfo cinfo;
 		bool useGTypeCtor;
 		Gdk.Pixbuf icon;
@@ -21,9 +23,60 @@
 		
 		static Gdk.Pixbuf missingIcon;
 
+		public bool CheckIsToolboxItem (Assembly aAssembly, string aName)
+		{
+			if (aAssembly == null)
+				return (false);
+			
+			bool ctrl, cat, desc;
+			string name, category, description;
+			foreach (System.Type type in aAssembly.GetExportedTypes()) {
+				if (type.ToString() != aName)
+					continue;
+
+				WidgetType = type;
+				
+				if (type.IsAbstract || type.IsNotPublic) 
+					return (false);
+					
+				Attribute[] attrs = Attribute.GetCustomAttributes (type);
+				
+				ctrl = false; cat = false; desc = false;
+				name = ""; category = ""; description = "";
+				foreach (Attribute attr in attrs) {						
+					if (attr is ToolboxItemAttribute) {
+						if ((attr.Equals(ToolboxItemAttribute.Default) == true) && (type.IsAbstract == false))
+							ctrl = true;
+						name = type.Name;
+					}
+					if (attr is CategoryAttribute) {
+						cat = true;
+						category = (attr as CategoryAttribute).Category;
+					}
+					if (attr is DescriptionAttribute) {
+						desc = true;
+						description = (attr as DescriptionAttribute).Description;
+					}
+				}
+
+				if ((ctrl == true) && (name.ToUpper() != "TOOLBOXITEMGROUP")) {
+					if (Registry.ControlGroupExists(category) == false) {
+						category = "unsorted";
+						if (Registry.ControlGroupExists("unsorted") == false)
+							Registry.AddControlGroup ("unsorted", "[Unsorted]");
+					}
+					AssemblyDefinitions = new ToolboxItemDefinitions (name, category, description);
+				}
+				return ((ctrl == true) && (name.ToUpper() != "TOOLBOXITEMGROUP"));
+			}
+			return (false);
+		}
+		
 		public TypedClassDescriptor (Assembly assembly, XmlElement elem)
 		{
 			wrapped = Registry.GetType (elem.GetAttribute ("type"), true);
+			IsToolboxItem = CheckIsToolboxItem(assembly, elem.GetAttribute ("type"));
+
 			if (elem.HasAttribute ("wrapper"))
 			    wrapper = Registry.GetType (elem.GetAttribute ("wrapper"), true);
 			else {
@@ -55,6 +108,11 @@
 			
 			BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly;
 						
+			// Search if type provides its own CreateWrappedInstance which will override default wrapper control
+			ctorDirectMethodInfoWithClass = null;
+			foreach (System.Reflection.MethodInfo mtd in wrapped.GetMethods())
+				if ((mtd.Name == "CreateWrappedInstance") && (mtd.IsStatic == true) && (mtd.GetParameters().Length == 1))
+					ctorDirectMethodInfoWithClass = mtd;
 
 			ctorMethodInfoWithClass = wrapper.GetMethod ("CreateInstance", flags, null, new Type[] { typeof(ClassDescriptor)}, null);
 			if (ctorMethodInfoWithClass == null) {
@@ -111,6 +169,10 @@
 		{
 			object inst;
 
+			if (ctorDirectMethodInfoWithClass != null) {
+				inst = ctorDirectMethodInfoWithClass.Invoke (null, new object[] { this });
+				if (inst != null) return inst;
+			}
 			if (ctorMethodInfoWithClass != null) {
 				inst = ctorMethodInfoWithClass.Invoke (null, new object[] { this });
 				if (inst != null) return inst;
diff -ruN stetic/libstetic/wrapper/objects.xml stetic.clean/libstetic/wrapper/objects.xml
--- stetic/libstetic/wrapper/objects.xml	2006-06-12 18:56:28.000000000 +0200
+++ stetic.clean/libstetic/wrapper/objects.xml	2006-06-26 06:27:43.000000000 +0200
@@ -1380,7 +1380,7 @@
 		<property name="Adjustment.PageSize" />
 		<property name="Adjustment.StepIncrement" />
 	    </itemgroup>
-	    <itemgroup label="Spin Button Properties" important="true">
+	    <itemgroup label="Spin Button Properties" name="SpinProperties" important="true">
 		<property name="ClimbRate" />
 		<property name="Digits" />
 		<property name="Numeric" />
diff -ruN stetic/libsteticui/Palette.cs stetic.clean/libsteticui/Palette.cs
--- stetic/libsteticui/Palette.cs	2006-06-08 14:37:25.000000000 +0200
+++ stetic.clean/libsteticui/Palette.cs	2006-06-17 01:12:30.000000000 +0200
@@ -19,21 +19,57 @@
 		public Palette () : base (false, 0)
 		{
 			groups = new Hashtable ();
-			Registry.RegistryChanged += OnRegistryChanged;
 			
-			ShowGroup ("window", "Windows");
-			ShowGroup ("widget", "Widgets");
-			ShowGroup ("container", "Containers");
+			Registry.AddControlGroup ("window", "Windows");
+			Registry.AddControlGroup  ("widget", "Widgets");
+			Registry.AddControlGroup  ("container", "Containers");
 //			ShowGroup ("toolbaritem", "Toolbar Items");
-			ShowGroup ("actions", "Actions");
+			Registry.AddControlGroup  ("actions", "Actions");
+
+			Registry.RegistryChanged += OnRegistryChanged;
+			Registry.OnGroupsChanged += OnGroupsChanged;
+			// Enforce the first time
+			OnGroupsChanged();
 		}
 		
 		public override void Dispose ()
 		{
+			Registry.OnGroupsChanged -= OnGroupsChanged;
 			Registry.RegistryChanged -= OnRegistryChanged;
 			base.Dispose ();
 		}
 		
+		internal bool GroupExists (string name)
+		{
+			foreach (string[] str in visibleGroups)
+				if (str[0] == name)
+					return (true);
+			return (false);
+		}
+		
+		internal bool RegistryGroupExists (string name)
+		{
+			foreach (Registry.ControlGroup grp in Registry.Groups)
+				if (grp.Name == name)
+					return (true);
+			return (false);
+		}
+		
+		public void OnGroupsChanged ()
+		{
+			// First show new groups
+			foreach (Registry.ControlGroup cg in Registry.Groups)
+				if (GroupExists(cg.Name) == false)
+					ShowGroup (cg.Name, cg.DisplayName);
+			// Then delete non-existant
+			if (visibleGroups.Count > 0)
+				for (int i=visibleGroups.Count-1; i>=0; i--) {
+					string[] grp = (string[]) visibleGroups[i];
+					if (RegistryGroupExists(grp[0]) == false)
+						HideGroup (grp[0]);
+				}
+		}
+		
 		public Palette (Project project): this ()
 		{
 			this.Project = project;
diff -ruN stetic/stetic/Stetic.cs stetic.clean/stetic/Stetic.cs
--- stetic/stetic/Stetic.cs	2006-06-08 14:37:25.000000000 +0200
+++ stetic.clean/stetic/Stetic.cs	2006-06-25 19:42:00.000000000 +0200
@@ -105,6 +105,9 @@
 			Glade.XML glade = new Glade.XML ("stetic.glade", null);
 			glade.Autoconnect (typeof (SteticMain));
 
+			foreach (string lib in libraries)
+				Registry.RegisterWidgetLibrary (new AssemblyWidgetLibrary (lib));
+			
 			if (ProjectView.Parent is Gtk.Viewport &&
 			    ProjectView.Parent.Parent is Gtk.ScrolledWindow) {
 				Gtk.Viewport viewport = (Gtk.Viewport)ProjectView.Parent;
