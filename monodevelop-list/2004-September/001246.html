<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] Issues with the gui thread
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:tberman%40off.net">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="001245.html">
   <LINK REL="Next"  HREF="001247.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] Issues with the gui thread
   </H1>
    <B>Todd Berman
    </B> 
    <A HREF="mailto:tberman%40off.net"
       TITLE="[MonoDevelop] Issues with the gui thread">tberman@off.net
       </A><BR>
    <I>Mon, 20 Sep 2004 16:28:03 -0700</I>
    <P><UL>
        <LI> Previous message: <A HREF="001245.html">[MonoDevelop] Issues with the gui thread
</A></li>
        <LI> Next message: <A HREF="001247.html">[MonoDevelop] Issues with the gui thread
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1246">[ date ]</a>
              <a href="thread.html#1246">[ thread ]</a>
              <a href="subject.html#1246">[ subject ]</a>
              <a href="author.html#1246">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Mon, 2004-09-20 at 23:58 +0200, Lluis Sanchez wrote:
&gt;<i> Hi!
</I>&gt;<i> 
</I>&gt;<i> One of the problems I find when writing code for MonoDevelop is that the
</I>&gt;<i> user interface can only be modified from the GUI thread. This means
</I>&gt;<i> that, for example, if I have a background thread that needs to add
</I>&gt;<i> something in the task pane, I need to do it through the DispatchService.
</I>&gt;<i> 
</I>&gt;<i> However, the fact that TaskService.AddTask (and many other methods)
</I>&gt;<i> needs to run in the gui thread is common knowledge not documented
</I>&gt;<i> anywhere, and even if it was documented, this information wouldn't be
</I>&gt;<i> reliable. For example, the TaskService itself does not modify the user
</I>&gt;<i> interface, but an OpenTaskView object is subscribed to the TaskAdded
</I>&gt;<i> event, and that one changes de UI. This makes the development of plugins
</I>&gt;<i> really hard.
</I>&gt;<i> 
</I>&gt;<i> In order to simplify the development and to make MonoDevelop more stable
</I>&gt;<i> I think we should stablish a policy like &quot;any public class that can be
</I>&gt;<i> used by a plugin must be gui-thread safe&quot; that is, no matter from which
</I>&gt;<i> thread a method is called, it should do its work, internally dispatching
</I>&gt;<i> the call through the DispatchService if needed.
</I>&gt;<i> 
</I>&gt;<i> Following this rule, the TaskService.AddTask method would not need to do
</I>&gt;<i> anything special, since it does not directly modify the gui, but
</I>&gt;<i> OpenTaskView would need to internally dispatch the TaskAdded event
</I>&gt;<i> through the DispatchService.
</I>&gt;<i> 
</I>&gt;<i> To simplify even more the development I propose to build two artifacts:
</I>&gt;<i> 
</I>&gt;<i>       * Provide a base class for classes that need access to the GUI.
</I>&gt;<i>         All method calls to objects of that class would be automatically
</I>&gt;<i>         marshalled and executed in the gui thread. This can be
</I>&gt;<i>         implemented using ContextBoundObject and the interception sinks
</I>&gt;<i>         it provides. This would be really useful for example to make the
</I>&gt;<i>         status bar service thread safe by only changing the base class. 
</I>&gt;<i> 
</I>&gt;<i>       * Provide a method for building wrapper delegates that would
</I>&gt;<i>         automatically marshall calls into the gui thread, so I could do
</I>&gt;<i>         something like:
</I>&gt;<i> 
</I>&gt;<i>         taskService.TasksChanged +=
</I>&gt;<i>         (EventHandler)DispatchService.CreateGuiDispatch (new
</I>&gt;<i>         EventHandler (ShowResults));
</I>&gt;<i>         
</I>&gt;<i>         This would generate a wrapper delegate that would queue the call
</I>&gt;<i>         into the gui thread. This would need some Reflection.Emit, but
</I>&gt;<i>         not too much.
</I>&gt;<i>         
</I>&gt;<i> Of course, we could still use the traditional DispatchService methods,
</I>&gt;<i> but I think that those &quot;artifacts&quot; would be enough for most of
</I>&gt;<i> situations.
</I>&gt;<i> 
</I>
Yes. That sounds perfect.

We had begun to implement some stuff similar to that (Where public API
was considered to be safe regardless of where it was called from), but
didn't get anywhere near completion.

One thing to keep in mind, is some code will potentially have to be
restructured.

When you dispatch something to the gui thread, you get execution back
right away, potentially before the code has done what you needed it to
do.

Case in point:

When you double click on a method node in the class browser, it was
calling OpenFile. OpenFile was changed to internally use
DispatchService. However, the rest of the code in the event handler
inside the class browser continued to run, and it attempted to operate
on the 'newly' opened window, that wasn't actually open. These sorts of
changes have to be watched for. Also, we are opening ourselves up to a
very difficult to debug situation. While I agree that this is absolutely
the right direction, debugging this new code will be far more difficult,
as you wont get a stack trace beyond the most recent gui thread
transition.

--Todd


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="001245.html">[MonoDevelop] Issues with the gui thread
</A></li>
	<LI> Next message: <A HREF="001247.html">[MonoDevelop] Issues with the gui thread
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1246">[ date ]</a>
              <a href="thread.html#1246">[ thread ]</a>
              <a href="subject.html#1246">[ subject ]</a>
              <a href="author.html#1246">[ author ]</a>
         </LI>
       </UL>
</body></html>
