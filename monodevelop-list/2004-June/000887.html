<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [MonoDevelop] Monodevelop brother
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:mike%40icsharpcode.net">
   <META NAME="robots" CONTENT="index,nofollow">
   
   <LINK REL="Previous"  HREF="000893.html">
   <LINK REL="Next"  HREF="000903.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[MonoDevelop] Monodevelop brother
   </H1>
    <B>Mike Krueger
    </B> 
    <A HREF="mailto:mike%40icsharpcode.net"
       TITLE="[MonoDevelop] Monodevelop brother">mike@icsharpcode.net
       </A><BR>
    <I>Mon, 28 Jun 2004 10:48:04 +0200</I>
    <P><UL>
        <LI> Previous message: <A HREF="000893.html">[MonoDevelop] Monodevelop brother
</A></li>
        <LI> Next message: <A HREF="000903.html">[MonoDevelop] Monodevelop brother
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#887">[ date ]</a>
              <a href="thread.html#887">[ thread ]</a>
              <a href="subject.html#887">[ subject ]</a>
              <a href="author.html#887">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is a multi-part message in MIME format.
--------------050903040900060809020804
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 8bit

Hi

Small sourcecode issues:

FileUtilityService.cs (sand):

    /// &lt;summary&gt;
        /// This method checks the file fileName if it is valid.
        /// &lt;/summary&gt;
        public bool IsValidFileName(string fileName)
        {
            // Fixme: 260 is the hardcoded maximal length for a path on 
my Windows XP system
            //        I can't find a .NET property or method for 
determining this variable.
            if (fileName == null || fileName.Length == 0 || 
fileName.Length &gt;= 260) {
                return false;
            }
           
            // platform independend : check for invalid path chars
            foreach (char invalidChar in Path.InvalidPathChars) {
                if (fileName.IndexOf(invalidChar) &gt;= 0) {
                    return false;
                }
            }
           
            // platform dependend : Check for invalid file names (DOS)
            // this routine checks for follwing bad file names :
            // CON, PRN, AUX, NUL, COM1-9 and LPT1-9
           
            string nameWithoutExtension = 
Path.GetFileNameWithoutExtension(fileName);
            if (nameWithoutExtension != null) {
                nameWithoutExtension = nameWithoutExtension.ToUpper();
            }
           
            if (nameWithoutExtension == &quot;CON&quot; ||
                nameWithoutExtension == &quot;PRN&quot; ||
                nameWithoutExtension == &quot;AUX&quot; ||
                nameWithoutExtension == &quot;NUL&quot;) {
               
                return false;
            }
               
            char ch = nameWithoutExtension.Length == 4 ? 
nameWithoutExtension[3] : '\0';
           
            return !((nameWithoutExtension.StartsWith(&quot;COM&quot;) ||
                      nameWithoutExtension.StartsWith(&quot;LPT&quot;)) &amp;&amp;
                      Char.IsDigit(ch));
        }

SharpDevelop version:
        const string fileNameRegEx = @&quot;^(([a-zA-Z]:)|.)[^:]*$&quot;;
        /// &lt;summary&gt;
        /// This method checks the file fileName if it is valid.
        /// &lt;/summary&gt;
        public bool IsValidFileName(string fileName)
        {
            // Fixme: 260 is the hardcoded maximal length for a path on 
my Windows XP system
            //        I can't find a .NET property or method for 
determining this variable.
            if (fileName == null || fileName.Length == 0 || 
fileName.Length &gt;= 260) {
                return false;
            }
           
            // platform independend : check for invalid path chars
            foreach (char invalidChar in Path.InvalidPathChars) {
                if (fileName.IndexOf(invalidChar) &gt;= 0) {
                    return false;
                }
            }
            if (fileName.IndexOf('?') &gt;= 0 || fileName.IndexOf('*') &gt;= 0) {
                return false;
            }
           
            if (!Regex.IsMatch(fileName, fileNameRegEx)) {
                return false;
            }
           
            // platform dependend : Check for invalid file names (DOS)
            // this routine checks for follwing bad file names :
            // CON, PRN, AUX, NUL, COM1-9 and LPT1-9
           
            string nameWithoutExtension = 
Path.GetFileNameWithoutExtension(fileName);
            if (nameWithoutExtension != null) {
                nameWithoutExtension = nameWithoutExtension.ToUpper();
            }
           
            if (nameWithoutExtension == &quot;CON&quot; ||
                nameWithoutExtension == &quot;PRN&quot; ||
                nameWithoutExtension == &quot;AUX&quot; ||
                nameWithoutExtension == &quot;NUL&quot;) {
                return false;
            }
               
            char ch = nameWithoutExtension.Length == 4 ? 
nameWithoutExtension[3] : '\0';
           
            return !((nameWithoutExtension.StartsWith(&quot;COM&quot;) ||
                      nameWithoutExtension.StartsWith(&quot;LPT&quot;)) &amp;&amp;
                      Char.IsDigit(ch));
        }
       

... ok we have some more bugfixes in our version (did some bugfixes 
lately, our subversion log prooves that) ... but the sand version is 
clearly a 'derived' version.

PropertyService.cs (sand):

    /// &lt;summary&gt;
        /// Expands ${xyz} style property values.
        /// &lt;/summary&gt;
        public string Parse(string input, string[,] customTags)
        {
            string output = input;
            if (input != null) {
                const string pattern = @&quot;\$\{([^\}]*)\}&quot;;
                foreach (Match m in Regex.Matches(input, pattern)) {
                    if (m.Length &gt; 0) {
                        string token         = m.ToString();
                        string propertyName  = 
m.Groups[1].Captures[0].Value;
                        string propertyValue = null;
                        switch (propertyName.ToUpper()) {
                            case &quot;DATE&quot;: // current date
                                propertyValue = 
DateTime.Today.ToShortDateString();
                                break;
                            case &quot;TIME&quot;: // current time
                                propertyValue = 
DateTime.Now.ToShortTimeString();
                                break;
                            default:
                                propertyValue = null;
                                if (customTags != null) {
                                    for (int j = 0; j &lt; 
customTags.GetLength(0); ++j) {
                                        if (propertyName.ToUpper() == 
customTags[j, 0].ToUpper()) {
                                            propertyValue = 
customTags[j, 1];
                                            break;
                                        }
                                    }
                                }
                               
                                if (propertyValue == null) {
                                    propertyValue = 
properties[propertyName.ToUpper()];
                                }
                           
                                break;
                        }
                        if (propertyValue != null) {
                            output = output.Replace(token, propertyValue);
                        }
                    }
                }
            }
            return output;
        }

StringParserService.cs (#D rev 1000, one of our contributors did some 
more corrections therefore I've taken an older version):

/// &lt;summary&gt;
        /// Expands ${xyz} style property values.
        /// &lt;/summary&gt;
        public string Parse(string input, string[,] customTags)
        {
            string output = input;
            if (input != null) {
                const string pattern = @&quot;\$\{([^\}]*)\}&quot;;
                foreach (Match m in Regex.Matches(input, pattern)) {
                    if (m.Length &gt; 0) {
                        string token         = m.ToString();
                        string propertyName  = 
m.Groups[1].Captures[0].Value;
                        string propertyValue = null;
                        switch (propertyName.ToUpper()) {
                            case &quot;USER&quot;: // current user
                                propertyValue = Environment.UserName;
                                break;
                            case &quot;DATE&quot;: // current date
                                propertyValue = 
DateTime.Today.ToShortDateString();
                                break;
                            case &quot;TIME&quot;: // current time
                                propertyValue = 
DateTime.Now.ToShortTimeString();
                                break;
                            default:
                                propertyValue = null;
                                if (customTags != null) {
                                    for (int j = 0; j &lt; 
customTags.GetLength(0); ++j) {
                                        if (propertyName.ToUpper() == 
customTags[j, 0].ToUpper()) {
                                            propertyValue = 
customTags[j, 1];
                                            break;
                                        }
                                    }
                                }
                               
                                if (propertyValue == null) {
                                    propertyValue = 
properties[propertyName.ToUpper()];
                                }
                               
                                if (propertyValue == null) {
                                    IStringTagProvider stringTagProvider 
= stringTagProviders[propertyName.ToUpper()] as IStringTagProvider;
                                    if (stringTagProvider != null) {
                                        propertyValue = 
stringTagProvider.Convert(propertyName.ToUpper());
                                    }
                                }
                               
                                if (propertyValue == null) {
                                    int k = propertyName.IndexOf(':');
                                    if (k &gt; 0) {
                                        switch 
(propertyName.Substring(0, k).ToUpper()) {
                                            case &quot;RES&quot;:
                                                IResourceService 
resourceService = 
(IResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
                                                if (resourceService != 
null) {
                                                    try {
                                                        propertyValue = 
Parse(resourceService.GetString(propertyName.Substring(k + 1)), customTags);
                                                    } catch (Exception) {
                                                        propertyValue = 
null;
                                                    }
                                                }
                                                break;
                                            case &quot;PROPERTY&quot;:
                                                PropertyService 
propertyService = 
(PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
                                                propertyValue = 
propertyService.GetProperty(propertyName.Substring(k + 1)).ToString();
                                                break;
                                        }
                                    }
                                }
                                break;
                        }
                        if (propertyValue != null) {
                            output = output.Replace(token, propertyValue);
                        }
                    }
                }
            }
            return output;
        }
    }
... our's is again more complicated ... but you can see much coincidence 
here.

Or in the Project Browser are MANY occasions where #D code shines through:

using System;
using System.IO;
using System.Windows.Forms;
using System.Diagnostics;
using System.Drawing;
using System.Collections.Specialized;

using Sand.Interface.Editor.Core.Project;
using Sand.Interface.Editor.Core;

namespace Sand.Interface.Editor.Enviromins.Common.Controls
{
    /// &lt;summary&gt;
    /// This class represents the default directory in the project browser.
    /// &lt;/summary&gt;
    public class DirectoryNode : FolderNode
    {
//        readonly static string defaultContextMenuPath = 
&quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/DefaultDirectoryNode&quot;;
               
        string folderName;
        string folderPath;
       
        /// &lt;summary&gt;
        /// This property gets the name of a directory for a
        /// 'directory' folder.
        /// &lt;/summary&gt;
        public string FolderName {
            get {
                return folderName;
            }
            set {
                folderName = value;
                canLabelEdited = true;
            }
        }
       
        public DirectoryNode(string folderName , string folderPath) : 
base(Path.GetFileName(folderName))
        {
            this.folderName = folderName;
            this.folderPath = folderPath;

            canLabelEdited  = true;

            OpenedImage = 
Sand.Interface.Editor.Core.FileSystemImages.FolderOpen;
            ClosedImage = 
Sand.Interface.Editor.Core.FileSystemImages.FolderClose;

            /*
            ResourceService resourceService = 
(ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
            OpenedImage = 
resourceService.GetBitmap(&quot;Icons.16x16.OpenFolderBitmap&quot;);
            ClosedImage = 
resourceService.GetBitmap(&quot;Icons.16x16.ClosedFolderBitmap&quot;);
            */
            /*
            FileIcon fIcon = new FileIcon (@&quot;\&quot;);

            fIcon.Flags = fIcon.Flags
                | FileIcon.SHGetFileInfoConstants.SHGFI_SMALLICON &amp;
                ~(FileIcon.SHGetFileInfoConstants.SHGFI_DISPLAYNAME | 
FileIcon.SHGetFileInfoConstants.SHGFI_TYPENAME |
                FileIcon.SHGetFileInfoConstants.SHGFI_ATTRIBUTES | 
FileIcon.SHGetFileInfoConstants.SHGFI_EXETYPE );
            fIcon.GetInfo();

            if(fIcon.ShellIcon != null)
                ClosedImage = (Image)fIcon.ShellIcon.ToBitmap();

            fIcon.Flags = fIcon.Flags
                | FileIcon.SHGetFileInfoConstants.SHGFI_SMALLICON &amp;
                ~(FileIcon.SHGetFileInfoConstants.SHGFI_DISPLAYNAME | 
FileIcon.SHGetFileInfoConstants.SHGFI_TYPENAME |
                FileIcon.SHGetFileInfoConstants.SHGFI_ATTRIBUTES | 
FileIcon.SHGetFileInfoConstants.SHGFI_EXETYPE | 
FileIcon.SHGetFileInfoConstants.SHGFI_OPENICON );
            fIcon.GetInfo();

            if(fIcon.ShellIcon != null)
                OpenedImage = (Image)fIcon.ShellIcon.ToBitmap();

            OpenedImage = 
Sand.Interface.Editor.Core.FileSystemImages.FolderOpen;
            ClosedImage = 
Sand.Interface.Editor.Core.FileSystemImages.FolderClose;
*/           
           
        }
       
        public override DragDropEffects GetDragDropEffect(IDataObject 
dataObject, DragDropEffects proposedEffect)
        {
            if (dataObject.GetDataPresent(typeof(FileNode)) &amp;&amp; 
DragDropUtil.CanDrag((FileNode)dataObject.GetData(typeof(FileNode)), 
this)) {               
                return proposedEffect;
            }
            if (dataObject.GetDataPresent(DataFormats.FileDrop)) {
                return proposedEffect;
            }
            return DragDropEffects.None;
        }
       
        public override void DoDragDrop(IDataObject dataObject, 
DragDropEffects effect)
        {
            if (dataObject.GetDataPresent(typeof(FileNode))) {
                FileNode fileNode = 
DragDropUtil.DoDrag((FileNode)dataObject.GetData(typeof(FileNode)), 
this, effect);
                DragDropUtil.DoDrop(fileNode, folderName, effect);
            } else if (dataObject.GetDataPresent(DataFormats.FileDrop)) {
                string[] files = 
(string[])dataObject.GetData(DataFormats.FileDrop);
                foreach (string file in files) {
                    try {
            //            ProjectBrowserView.MoveCopyFile(file, this, 
effect == DragDropEffects.Move, false);
                    } catch (Exception ex) {
                        Console.WriteLine(ex.ToString());
                    }
                }
            } else {
                throw new System.NotImplementedException();
            }
        }
       
        /*
        public override void AfterLabelEdit(string newName)
        {
            if (newName != null &amp;&amp; newName.Trim().Length &gt; 0) {
               
                string oldFoldername = folderName;
                string newFoldername = 
Path.GetDirectoryName(oldFoldername) + Path.DirectorySeparatorChar + 
newName;
                ResourceService resourceService = 
(ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
               
                if (oldFoldername != newFoldername) {
                    try {
                       
                        IFileService fileService = 
(IFileService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IFileService));
                        FileUtilityService fileUtilityService = 
(FileUtilityService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(FileUtilityService));
                        if 
(fileUtilityService.IsValidFileName(newFoldername)) {
                            fileService.RenameFile(oldFoldername, 
newFoldername);
                            Text       = newName;
                            folderName = newFoldername;
                        }
                    } catch (System.IO.IOException) {   // assume 
duplicate file
                        IMessageService messageService 
=(IMessageService)ServiceManager.Services.GetService(typeof(IMessageService));
                        
messageService.ShowError(&quot;${res:Gui.ProjectBrowser.FileInUseError}&quot;);
                    } catch (System.ArgumentException) { // new file 
name with wildcard (*, ?) characters in it
                        IMessageService messageService 
=(IMessageService)ServiceManager.Services.GetService(typeof(IMessageService));
                        
messageService.ShowError(&quot;${res:Gui.ProjectBrowser.IllegalCharactersInFileNameError}&quot;);
                    }
                }
            }
        }
        */
       
        /*
        /// &lt;summary&gt;
        /// Removes a folder from a project.
        /// Note : The FolderName property must be set for this method 
to work.
        /// &lt;/summary&gt;
        public override bool RemoveNode()
        {
            if (FolderName != null &amp;&amp; FolderName.Length == 0) {
                return false;
            }
            ResourceService resourceService = 
(ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
            StringParserService stringParserService = 
(StringParserService)ServiceManager.Services.GetService(typeof(StringParserService));
           
            int ret = new 
SharpMessageBox(resourceService.GetString(&quot;ProjectComponent.RemoveFolder.Title&quot;),
                                          
stringParserService.Parse(resourceService.GetString(&quot;ProjectComponent.RemoveFolder.Question&quot;), 
new string[,] { {&quot;FOLDER&quot;, Text}, {&quot;PROJECT&quot;, Project.Name}}),
                                          
resourceService.GetString(&quot;Global.RemoveButtonText&quot;),
                                          
resourceService.GetString(&quot;Global.DeleteButtonText&quot;),
                                          
resourceService.GetString(&quot;Global.CancelButtonText&quot;)).ShowMessageBox();
            IFileService fileService = 
(IFileService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IFileService));
            IProjectService projectService = 
(IProjectService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
            switch (ret) {
                case -1:
                case 2:
                    return false;
                case 0:
                    projectService.RemoveFileFromProject(FolderName);
                    break;
                case 1:
                    fileService.RemoveFile(FolderName);
                    break;
            }
            return true;
        }
        */
    }
}

Same class from #D:

    /// &lt;summary&gt;
    /// This class represents the default directory in the project browser.
    /// &lt;/summary&gt;
    public class DirectoryNode : FolderNode
    {
        readonly static string defaultContextMenuPath = 
&quot;/SharpDevelop/Views/ProjectBrowser/ContextMenu/DefaultDirectoryNode&quot;;
               
        string folderName;
       
        /// &lt;summary&gt;
        /// This property gets the name of a directory for a
        /// 'directory' folder.
        /// &lt;/summary&gt;
        public string FolderName {
            get {
                return folderName;
            }
            set {
                folderName = value;
                canLabelEdited = true;
            }
        }
       
        public DirectoryNode(string folderName) : 
base(Path.GetFileName(folderName))
        {
            this.folderName = folderName;
            canLabelEdited  = true;
            contextmenuAddinTreePath = defaultContextMenuPath;
            ResourceService resourceService = 
(ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
            OpenedImage = 
resourceService.GetBitmap(&quot;Icons.16x16.OpenFolderBitmap&quot;);
            ClosedImage = 
resourceService.GetBitmap(&quot;Icons.16x16.ClosedFolderBitmap&quot;);
        }
       
        public override DragDropEffects GetDragDropEffect(IDataObject 
dataObject, DragDropEffects proposedEffect)
        {
            if (dataObject.GetDataPresent(typeof(FileNode)) &amp;&amp; 
DragDropUtil.CanDrag((FileNode)dataObject.GetData(typeof(FileNode)), 
this)) {               
                return proposedEffect;
            }
            if (dataObject.GetDataPresent(DataFormats.FileDrop)) {
                return proposedEffect;
            }
            return DragDropEffects.None;
        }
       
        public override void DoDragDrop(IDataObject dataObject, 
DragDropEffects effect)
        {
            if (dataObject.GetDataPresent(typeof(FileNode))) {
                FileNode fileNode = 
DragDropUtil.DoDrag((FileNode)dataObject.GetData(typeof(FileNode)), 
this, effect);
                DragDropUtil.DoDrop(fileNode, folderName, effect);
            } else if (dataObject.GetDataPresent(DataFormats.FileDrop)) {
                string[] files = 
(string[])dataObject.GetData(DataFormats.FileDrop);
                foreach (string file in files) {
                    try {
                        ProjectBrowserView.MoveCopyFile(file, this, 
effect == DragDropEffects.Move, false);
                    } catch (Exception ex) {
                        Console.WriteLine(ex.ToString());
                    }
                }
            } else {
                throw new System.NotImplementedException();
            }
        }
       
       
        public override void AfterLabelEdit(string newName)
        {
            if (newName != null &amp;&amp; newName.Trim().Length &gt; 0) {
               
                string oldFoldername = folderName;
                string newFoldername = 
Path.GetDirectoryName(oldFoldername) + Path.DirectorySeparatorChar + 
newName;
                ResourceService resourceService = 
(ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
               
                if (oldFoldername != newFoldername) {
                    try {
                       
                        IFileService fileService = 
(IFileService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IFileService));
                        FileUtilityService fileUtilityService = 
(FileUtilityService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(FileUtilityService));
                        if 
(fileUtilityService.IsValidFileName(newFoldername) &amp;&amp; 
!Directory.Exists(newFoldername) &amp;&amp; !File.Exists(newFoldername)) {
                            fileService.RenameFile(oldFoldername, 
newFoldername);
                            Text       = newName;
                            folderName = newFoldername;
                        }
                    } catch (System.IO.IOException) {   // assume 
duplicate file
                        IMessageService messageService 
=(IMessageService)ServiceManager.Services.GetService(typeof(IMessageService));
                        
messageService.ShowError(&quot;${res:Gui.ProjectBrowser.FileInUseError}&quot;);
                    } catch (System.ArgumentException) { // new file 
name with wildcard (*, ?) characters in it
                        IMessageService messageService 
=(IMessageService)ServiceManager.Services.GetService(typeof(IMessageService));
                        
messageService.ShowError(&quot;${res:Gui.ProjectBrowser.IllegalCharactersInFileNameError}&quot;);
                    }
                }
            }
        }
       
        /// &lt;summary&gt;
        /// Removes a folder from a project.
        /// Note : The FolderName property must be set for this method 
to work.
        /// &lt;/summary&gt;
        public override bool RemoveNode()
        {
            if (FolderName != null &amp;&amp; FolderName.Length == 0) {
                return false;
            }
            ResourceService resourceService = 
(ResourceService)ServiceManager.Services.GetService(typeof(IResourceService));
            StringParserService stringParserService = 
(StringParserService)ServiceManager.Services.GetService(typeof(StringParserService));
           
            int ret = new 
SharpMessageBox(resourceService.GetString(&quot;ProjectComponent.RemoveFolder.Title&quot;),
                                          
stringParserService.Parse(resourceService.GetString(&quot;ProjectComponent.RemoveFolder.Question&quot;), 
new string[,] { {&quot;FOLDER&quot;, Text}, {&quot;PROJECT&quot;, Project.Name}}),
                                          
resourceService.GetString(&quot;Global.RemoveButtonText&quot;),
                                          
resourceService.GetString(&quot;Global.DeleteButtonText&quot;),
                                          
resourceService.GetString(&quot;Global.CancelButtonText&quot;)).ShowMessageBox();
            IFileService fileService = 
(IFileService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IFileService));
            IProjectService projectService = 
(IProjectService)ICSharpCode.Core.Services.ServiceManager.Services.GetService(typeof(IProjectService));
            switch (ret) {
                case -1:
                case 2:
                    return false;
                case 0:
                    projectService.RemoveFileFromProject(FolderName);
                    break;
                case 1:
                    fileService.RemoveFile(FolderName);
                    break;
            }
            return true;
        }
    }
... ok a lot code is commented out ... but anybody sees the coincidence.

btw. you forgot to take out :

#region Copyright © 2003 Fatih BOY [<A HREF="mailto:fatih@smartcoding.org">fatih@smartcoding.org</A>]
// Software Studio GUI - Graphical User Interface components for 
Software Studio project
// Copyright (C) 2003-2004 Fatih Boy
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// Fatih BOY(<A HREF="mailto:fatih@smartcoding.org">fatih@smartcoding.org</A>)
#endregion

taken from the 
Framework\Sand.Framework.SDE.Core\GUI\CommonControls\TreeView.cs file. 
I've chatted with Fatih and he DID NOT give you PERMISSION to use his 
GPL'ed code in a non GPL'ed program.

I've attached the resource services from both projects ... see yourself. 
Again is the #D one more advanced (lately we had contributors) but you 
can clearly see that's almost the same.
There are many more examples like this ... but I think that's enough to 
prove that. It's great that people think that #D code is good enough to 
use, but please follow the GPL (and nobody can take and dual license GPL 
code)..

Regards
Mike

--------------050903040900060809020804
Content-Type: text/plain;
 name=&quot;ResourceService(sand).cs&quot;
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename=&quot;ResourceService(sand).cs&quot;

using System;
using System.IO;
using System.Windows.Forms;
using System.Collections;
using System.Threading;
using System.Resources;
using System.Drawing;
using System.Diagnostics;
using System.Reflection;
using System.Xml;

namespace Sand.Interface.Editor.Core.Services
{
	/// &lt;summary&gt;
	/// This Class contains two ResourceManagers, which handle string and image resources
	/// for the application. It do handle localization strings on this level.
	/// &lt;/summary&gt;
	public class ResourceService : Service//: AbstractService, IResourceService
	{
		private readonly string stringResources  = &quot;StringResources&quot;;
		private readonly string imageResources   = &quot;BitmapResources&quot;;
		
		private readonly string resourceDirctory = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location) +
			Path.DirectorySeparatorChar + &quot;resources&quot;;
		
		ResourceManager strings = null;
		ResourceManager icon    = null;
		
		Hashtable localStrings = null;
		Hashtable localIcons   = null;

		private Color _transparentColor = Color.Fuchsia;

		public override string ServiceName { get { return &quot;Resource Service&quot;; }}

		public string Language
		{
			get { return  Thread.CurrentThread.CurrentUICulture.Name;}
		}

		public Color TransparentColor
		{
			get { return _transparentColor;}
			set { _transparentColor = value;}
		}
		
//		void ChangeProperty(object sender, PropertyEventArgs e)
//		{
//			if (e.Key == uiLanguageProperty &amp;&amp; e.OldValue != e.NewValue) 
//			{
//				LoadLanguageResources();
//			} 
//		}

		void LoadLanguageResources()
		{
//			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
//			string language = propertyService.GetProperty(uiLanguageProperty, Thread.CurrentThread.CurrentUICulture.Name);

			//string language = Thread.CurrentThread.CurrentUICulture.Name;
			
			localStrings = Load(stringResources, Language);
			if (localStrings == null &amp;&amp; Language.IndexOf('-') &gt; 0) 
			{
				localStrings = Load(stringResources, Language.Split(new char[] {'-'})[0]);
			}
			
//			localIcons = Load(imageResources, Language);
//			if (localIcons == null &amp;&amp; Language.IndexOf('-') &gt; 0) 
//			{
//				localIcons = Load(imageResources, Language.Split(new char[] {'-'})[0]);
//			}
			localIcons = CurrentAssemblyImages();
		}
		
		protected override void InitializeService()
		{
			//base.InitializeService();
			//PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
			//propertyService.PropertyChanged += new PropertyEventHandler(ChangeProperty);
			
			LoadLanguageResources();
		}
		
		// core service : Can't use Initialize, because all other stuff needs this service before initialize is called.
		public ResourceService()
		{
			strings = new ResourceManager(stringResources, Assembly.GetCallingAssembly());
			icon    = new ResourceManager(imageResources,  Assembly.GetCallingAssembly());

			LoadLanguageResources();
		}
		
		/// &lt;summary&gt;
		/// The LoadFont routines provide a safe way to load fonts.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
		/// &lt;returns&gt;
		/// The font to load or the menu font, if the requested font couldn't be loaded.
		/// &lt;/returns&gt;
		public Font LoadFont(string fontName, int size)
		{
			return LoadFont(fontName, size, FontStyle.Regular);
		}
		
		/// &lt;summary&gt;
		/// The LoadFont routines provide a safe way to load fonts.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;style&quot;&gt;The &lt;see cref=&quot;System.Drawing.FontStyle&quot;/&gt; of the font&lt;/param&gt;
		/// &lt;returns&gt;
		/// The font to load or the menu font, if the requested font couldn't be loaded.
		/// &lt;/returns&gt;
		public Font LoadFont(string fontName, int size, FontStyle style)
		{
			try 
			{
				return new Font(fontName, size, style);
			} 
			catch (Exception) 
			{
				return SystemInformation.MenuFont;
			}
		}
		
		/// &lt;summary&gt;
		/// The LoadFont routines provide a safe way to load fonts.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;unit&quot;&gt;The &lt;see cref=&quot;System.Drawing.GraphicsUnit&quot;/&gt; of the font&lt;/param&gt;
		/// &lt;returns&gt;
		/// The font to load or the menu font, if the requested font couldn't be loaded.
		/// &lt;/returns&gt;
		public Font LoadFont(string fontName, int size, GraphicsUnit unit)
		{
			return LoadFont(fontName, size, FontStyle.Regular, unit);
		}
		
		/// &lt;summary&gt;
		/// The LoadFont routines provide a safe way to load fonts.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;style&quot;&gt;The &lt;see cref=&quot;System.Drawing.FontStyle&quot;/&gt; of the font&lt;/param&gt;
		/// &lt;param name=&quot;unit&quot;&gt;The &lt;see cref=&quot;System.Drawing.GraphicsUnit&quot;/&gt; of the font&lt;/param&gt;
		/// &lt;returns&gt;
		/// The font to load or the menu font, if the requested font couldn't be loaded.
		/// &lt;/returns&gt;
		public Font LoadFont(string fontName, int size, FontStyle style, GraphicsUnit unit)
		{
			try 
			{
				return new Font(fontName, size, style, unit);
			} 
			catch (Exception) 
			{
				return SystemInformation.MenuFont;
			}
		}
		
		Hashtable Load(string name, string language)
		{
			string fname = resourceDirctory + Path.DirectorySeparatorChar + name + &quot;.&quot; + language + &quot;.resources&quot;;
			
			if (File.Exists(fname)) 
			{
				Hashtable resources = new Hashtable();
				ResourceReader rr = new ResourceReader(fname);
				foreach (DictionaryEntry entry in rr) 
				{
					resources.Add(entry.Key, entry.Value);
				}
				rr.Close();
				return resources;
			}
			return null;
		}

		Hashtable CurrentAssemblyImages()
		{
			Hashtable resources = new Hashtable();
			//ResourceReader rr = new ResourceReader(Assembly.GetAssembly(GetType()).Location.ToString());
			foreach(string resourcename in GetType().Assembly.GetManifestResourceNames())
			{
				if(resourcename.EndsWith(&quot;.bmp&quot;))
				{
					string ResourceFileName = resourcename.Replace(&quot;Sand.Interface.Editor.Core.Resources.&quot;,string.Empty);
					resources.Add(ResourceFileName, new Bitmap(GetType().Assembly.GetManifestResourceStream(resourcename)));
				}
			}
			//rr.Close();
			return resources;
		}
		
		/// &lt;summary&gt;
		/// Returns a string from the resource database, it handles localization
		/// transparent for the user.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;
		/// The string in the (localized) resource database.
		/// &lt;/returns&gt;
		/// &lt;param name=&quot;name&quot;&gt;
		/// The name of the requested resource.
		/// &lt;/param&gt;
		/// &lt;exception cref=&quot;ResourceNotFoundException&quot;&gt;
		/// Is thrown when the GlobalResource manager can't find a requested resource.
		/// &lt;/exception&gt;
		public string GetString(string name)
		{
			if (localStrings != null &amp;&amp; localStrings[name] != null) 
			{
				return localStrings[name].ToString();
			}
			
			string s = strings.GetString(name);
			
			if (s == null) 
			{
				throw new Exception(&quot;string &gt;&quot; + name + &quot;&lt;&quot;);
			}
			
			return s;
		}
		
		/// &lt;summary&gt;
		/// Returns a icon from the resource database, it handles localization
		/// transparent for the user. In the resource database can be a bitmap
		/// instead of an icon in the dabase. It is converted automatically.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;
		/// The icon in the (localized) resource database.
		/// &lt;/returns&gt;
		/// &lt;param name=&quot;name&quot;&gt;
		/// The name of the requested icon.
		/// &lt;/param&gt;
		/// &lt;exception cref=&quot;ResourceNotFoundException&quot;&gt;
		/// Is thrown when the GlobalResource manager can't find a requested resource.
		/// &lt;/exception&gt;
		public Icon GetIcon(string name)
		{
			object iconobj = null;
			
			if (localIcons != null &amp;&amp; localIcons[name] != null) 
			{
				iconobj = localIcons[name];
			} 
			else 
			{
				iconobj = icon.GetObject(name);
			}
			
			if (iconobj == null) 
			{
				return null;
			}
			
			if (iconobj is Icon) 
			{
				return (Icon)iconobj;
			} 
			else 
			{
				return Icon.FromHandle(((Bitmap)iconobj).GetHicon());
			}
		}
		
		/// &lt;summary&gt;
		/// Returns a bitmap from the resource database, it handles localization
		/// transparent for the user. 
		/// &lt;/summary&gt;
		/// &lt;returns&gt;
		/// The bitmap in the (localized) resource database.
		/// &lt;/returns&gt;
		/// &lt;param name=&quot;name&quot;&gt;
		/// The name of the requested bitmap.
		/// &lt;/param&gt;
		/// &lt;exception cref=&quot;ResourceNotFoundException&quot;&gt;
		/// Is thrown when the GlobalResource manager can't find a requested resource.
		/// &lt;/exception&gt;
		/// 
		public Bitmap GetBitmap(string name)
		{
			return GetBitmap (name , true);
		}
		
		public Icon GetIconFromImageArray (string name , int ImageNum)
		{
			return Icon.FromHandle(GetImageFromImageArray(name , ImageNum).GetHicon());
		}

		public Bitmap GetImageFromImageArray (string name , int ImageNum)
		{
			ImageList images = new ImageList();

			images.ImageSize = new Size(16, 16);
			images.Images.AddStrip ( GetBitmap(name) );

			return (Bitmap)images.Images[ImageNum];
		}

		public Bitmap GetBitmap(string name , bool transparent)
		{
			if (localIcons != null &amp;&amp; localIcons[name] != null) 
			{
				Bitmap bitmap = (Bitmap)localIcons[name];

				if(transparent)
					bitmap.MakeTransparent();

				return bitmap;
			}
			Bitmap b = (Bitmap)icon.GetObject(name);
			
			Debug.Assert(b != null, &quot;Resource &quot; + name);
			
			return b;
		}
	}
}
--------------050903040900060809020804
Content-Type: text/plain;
 name=&quot;ResourceService(SD).cs&quot;
Content-Transfer-Encoding: 8bit
Content-Disposition: inline;
 filename=&quot;ResourceService(SD).cs&quot;

// &lt;file&gt;
//     &lt;copyright see=&quot;<A HREF="prj:///doc/copyright.txt"/">prj:///doc/copyright.txt&quot;/</A>&gt;
//     &lt;license see=&quot;<A HREF="prj:///doc/license.txt"/">prj:///doc/license.txt&quot;/</A>&gt;
//     &lt;owner name=&quot;Mike Krüger&quot; email=&quot;<A HREF="mailto:mike@icsharpcode.net">mike@icsharpcode.net</A>&quot;/&gt;
//     &lt;version value=&quot;$version&quot;/&gt;
// &lt;/file&gt;

using System;
using System.IO;
using System.Windows.Forms;
using System.Collections;
using System.Threading;
using System.Resources;
using System.Drawing;
using System.Diagnostics;
using System.Reflection;
using System.Xml;

using ICSharpCode.Core.Properties;

namespace ICSharpCode.Core.Services
{
	/// &lt;summary&gt;
	/// This Class contains two ResourceManagers, which handle string and image resources
	/// for the application. It do handle localization strings on this level.
	/// &lt;/summary&gt;
	public class ResourceService : AbstractService, IResourceService
	{
		readonly static string uiLanguageProperty = &quot;CoreProperties.UILanguage&quot;;
		
		readonly static string stringResources  = &quot;StringResources&quot;;
		readonly static string imageResources   = &quot;BitmapResources&quot;;
		
		static string resourceDirctory;
		
		static ResourceService()
		{
			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
			resourceDirctory = propertyService.DataDirectory + Path.DirectorySeparatorChar + &quot;resources&quot;;
		}
		
		Hashtable userStrings = null;
		Hashtable userIcons   = null;
		Hashtable localUserStrings = null;
		Hashtable localUserIcons   = null;
		
		ArrayList strings = new ArrayList();
		ArrayList icon    = new ArrayList();
		
		Hashtable localStrings = null;
		Hashtable localIcons   = null;

		ArrayList localStringsResMgrs = new ArrayList();
		ArrayList localIconsResMgrs   = new ArrayList();

		ArrayList assemblies = new ArrayList();
		
		void ChangeProperty(object sender, PropertyEventArgs e)
		{
			if (e.Key == uiLanguageProperty &amp;&amp; e.OldValue != e.NewValue) {
			    LoadLanguageResources();
			} 
		}
		void LoadLanguageResources()
		{
			
			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
			string language = propertyService.GetProperty(uiLanguageProperty, Thread.CurrentThread.CurrentUICulture.Name);
			
			try {
				Thread.CurrentThread.CurrentUICulture = new System.Globalization.CultureInfo(language);
			} catch (Exception) {
				try {
					Thread.CurrentThread.CurrentUICulture = new System.Globalization.CultureInfo(language.Split('-')[0]);
				} catch (Exception) {}
			}

			if (System.Configuration.ConfigurationSettings.AppSettings[&quot;UserStrings&quot;] != null) {
				string resourceName = System.Configuration.ConfigurationSettings.AppSettings[&quot;UserStrings&quot;];
				resourceName = resourceName.Insert(resourceName.LastIndexOf(&quot;.resources&quot;), &quot;.&quot; + language);
				localUserStrings = Load(resourceDirctory +  Path.DirectorySeparatorChar + resourceName);
			}
			if (System.Configuration.ConfigurationSettings.AppSettings[&quot;UserIcons&quot;] != null) {
				string resourceName = System.Configuration.ConfigurationSettings.AppSettings[&quot;UserIcons&quot;];
				resourceName = resourceName.Insert(resourceName.LastIndexOf(&quot;.resources&quot;), &quot;.&quot; + language);
				localUserIcons   = Load(resourceDirctory +  Path.DirectorySeparatorChar + resourceName);
			}

			
			localStrings = Load(stringResources, language);
			if (localStrings == null &amp;&amp; language.IndexOf('-') &gt; 0) {
				localStrings = Load(stringResources, language.Split('-')[0]);
			}
			
			localIcons = Load(imageResources, language);
			if (localIcons == null &amp;&amp; language.IndexOf('-') &gt; 0) {
				localIcons = Load(imageResources, language.Split('-')[0]);
			}

			localStringsResMgrs.Clear();
			localIconsResMgrs.Clear();

			foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies()) {
				if (assemblies.Contains(assembly.FullName)) {
					if (assembly.GetManifestResourceInfo(stringResources+&quot;.resources&quot;) != null) {
						localStringsResMgrs.Add(new ResourceManager(stringResources, assembly));
					}
			
					if (assembly.GetManifestResourceInfo(imageResources+&quot;.resources&quot;) != null) {
						localIconsResMgrs.Add(new ResourceManager(imageResources, assembly));
					}
				}
			}
		}
		
		public override void InitializeService()
		{
			RegisterAssembly(Assembly.GetEntryAssembly());
			
			base.InitializeService();
			PropertyService propertyService = (PropertyService)ServiceManager.Services.GetService(typeof(PropertyService));
			propertyService.PropertyChanged += new PropertyEventHandler(ChangeProperty);
			
			LoadLanguageResources();
		}
		
		// core service : Can't use Initialize, because all other stuff needs this service before initialize is called.
		public ResourceService()
		{
			if (System.Configuration.ConfigurationSettings.AppSettings[&quot;UserStrings&quot;] != null) {
				userStrings = Load(resourceDirctory +  Path.DirectorySeparatorChar + System.Configuration.ConfigurationSettings.AppSettings[&quot;UserStrings&quot;]);
			}
			if (System.Configuration.ConfigurationSettings.AppSettings[&quot;UserIcons&quot;] != null) {
				userIcons   = Load(resourceDirctory +  Path.DirectorySeparatorChar + System.Configuration.ConfigurationSettings.AppSettings[&quot;UserIcons&quot;]);
			}
		}
		
		/// &lt;summary&gt;
		/// The LoadFont routines provide a safe way to load fonts.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
		/// &lt;returns&gt;
		/// The font to load or the menu font, if the requested font couldn't be loaded.
		/// &lt;/returns&gt;
		public Font LoadFont(string fontName, int size)
		{
			return LoadFont(fontName, size, FontStyle.Regular);
		}
		
		/// &lt;summary&gt;
		/// The LoadFont routines provide a safe way to load fonts.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;style&quot;&gt;The &lt;see cref=&quot;System.Drawing.FontStyle&quot;/&gt; of the font&lt;/param&gt;
		/// &lt;returns&gt;
		/// The font to load or the menu font, if the requested font couldn't be loaded.
		/// &lt;/returns&gt;
		public Font LoadFont(string fontName, int size, FontStyle style)
		{
			try {
				return new Font(fontName, size, style);
			} catch (Exception) {
				return SystemInformation.MenuFont;
			}
		}
		
		/// &lt;summary&gt;
		/// The LoadFont routines provide a safe way to load fonts.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;unit&quot;&gt;The &lt;see cref=&quot;System.Drawing.GraphicsUnit&quot;/&gt; of the font&lt;/param&gt;
		/// &lt;returns&gt;
		/// The font to load or the menu font, if the requested font couldn't be loaded.
		/// &lt;/returns&gt;
		public Font LoadFont(string fontName, int size, GraphicsUnit unit)
		{
			return LoadFont(fontName, size, FontStyle.Regular, unit);
		}
		
		/// &lt;summary&gt;
		/// The LoadFont routines provide a safe way to load fonts.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;fontName&quot;&gt;The name of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;size&quot;&gt;The size of the font to load.&lt;/param&gt;
		/// &lt;param name=&quot;style&quot;&gt;The &lt;see cref=&quot;System.Drawing.FontStyle&quot;/&gt; of the font&lt;/param&gt;
		/// &lt;param name=&quot;unit&quot;&gt;The &lt;see cref=&quot;System.Drawing.GraphicsUnit&quot;/&gt; of the font&lt;/param&gt;
		/// &lt;returns&gt;
		/// The font to load or the menu font, if the requested font couldn't be loaded.
		/// &lt;/returns&gt;
		public Font LoadFont(string fontName, int size, FontStyle style, GraphicsUnit unit)
		{
			try {
				return new Font(fontName, size, style, unit);
			} catch (Exception) {
				return SystemInformation.MenuFont;
			}
		}
		
		Hashtable Load(string fileName)
		{
			if (File.Exists(fileName)) {
				Hashtable resources = new Hashtable();
				ResourceReader rr = new ResourceReader(fileName);
				foreach (DictionaryEntry entry in rr) {
					resources.Add(entry.Key, entry.Value);
				}
				rr.Close();
				return resources;
			}
			return null;
		}
		Hashtable Load(string name, string language)
		{
			return Load(resourceDirctory + Path.DirectorySeparatorChar + name + &quot;.&quot; + language + &quot;.resources&quot;);
			
		}
		
		/// &lt;summary&gt;
		/// Returns a string from the resource database, it handles localization
		/// transparent for the user.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;
		/// The string in the (localized) resource database.
		/// &lt;/returns&gt;
		/// &lt;param name=&quot;name&quot;&gt;
		/// The name of the requested resource.
		/// &lt;/param&gt;
		/// &lt;exception cref=&quot;ResourceNotFoundException&quot;&gt;
		/// Is thrown when the GlobalResource manager can't find a requested resource.
		/// &lt;/exception&gt;
		public string GetString(string name)
		{
			if (this.localUserStrings != null &amp;&amp; this.localUserStrings[name] != null) {
				return localUserStrings[name].ToString();
			}
			if (this.userStrings != null &amp;&amp; this.userStrings[name] != null) {
				return userStrings[name].ToString();
			}
			if (localStrings != null &amp;&amp; localStrings[name] != null) {
				return localStrings[name].ToString();
			}
	
			string s = null;
			foreach (ResourceManager resourceManger in localStringsResMgrs) {
				s = resourceManger.GetString(name);
				if (s != null) {
					break;
				}
			}

			if (s == null) {
				foreach (ResourceManager resourceManger in strings) {
					s = resourceManger.GetString(name);
					if (s != null) {
						break;
					}
				}
			}
			if (s == null) {
				throw new ResourceNotFoundException(&quot;string &gt;&quot; + name + &quot;&lt;&quot;);
			}
			
			return s;
		}
		
		/// &lt;summary&gt;
		/// Take string/bitmap resources from an assembly and merge them in the resource service
		/// &lt;/summary&gt;
		public void RegisterAssembly(Assembly assembly)
		{
			assemblies.Add(assembly.FullName);

			if (assembly.GetManifestResourceInfo(stringResources+&quot;.resources&quot;) != null) {
				strings.Add(new ResourceManager(stringResources, assembly));
			}
			
			if (assembly.GetManifestResourceInfo(imageResources+&quot;.resources&quot;) != null) {
				icon.Add(new ResourceManager(imageResources, assembly));
			}
		}
		
		object GetImageResource(string name)
		{
			object iconobj = null;
			if (this.localUserIcons != null &amp;&amp; this.localUserIcons[name] != null) {
				iconobj = localUserIcons[name];
			} else  if (this.userIcons != null &amp;&amp; this.userIcons[name] != null) {
				iconobj = userIcons[name];
			} else  if (localIcons != null &amp;&amp; localIcons[name] != null) {
				iconobj = localIcons[name];
			} else {
				foreach (ResourceManager resourceManger in localIconsResMgrs) {
					iconobj = resourceManger.GetObject(name);
					if (iconobj != null) {
						break;
					}
				}

				if (iconobj == null) {
					foreach (ResourceManager resourceManger in icon) {
						iconobj = resourceManger.GetObject(name);
						if (iconobj != null) {
							break;
						}
					}
				}
			}
			return iconobj;
		}
		
		/// &lt;summary&gt;
		/// Returns a icon from the resource database, it handles localization
		/// transparent for the user. In the resource database can be a bitmap
		/// instead of an icon in the dabase. It is converted automatically.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;
		/// The icon in the (localized) resource database.
		/// &lt;/returns&gt;
		/// &lt;param name=&quot;name&quot;&gt;
		/// The name of the requested icon.
		/// &lt;/param&gt;
		/// &lt;exception cref=&quot;ResourceNotFoundException&quot;&gt;
		/// Is thrown when the GlobalResource manager can't find a requested resource.
		/// &lt;/exception&gt;
		public Icon GetIcon(string name)
		{
			object iconobj = GetImageResource(name);
			
			if (iconobj == null) {
				return null;
			}
			if (iconobj is Icon) {
				return (Icon)iconobj;
			} else {
				return Icon.FromHandle(((Bitmap)iconobj).GetHicon());
			}
		}
		
		/// &lt;summary&gt;
		/// Returns a bitmap from the resource database, it handles localization
		/// transparent for the user. 
		/// &lt;/summary&gt;
		/// &lt;returns&gt;
		/// The bitmap in the (localized) resource database.
		/// &lt;/returns&gt;
		/// &lt;param name=&quot;name&quot;&gt;
		/// The name of the requested bitmap.
		/// &lt;/param&gt;
		/// &lt;exception cref=&quot;ResourceNotFoundException&quot;&gt;
		/// Is thrown when the GlobalResource manager can't find a requested resource.
		/// &lt;/exception&gt;
		public Bitmap GetBitmap(string name)
		{
			Bitmap b = (Bitmap)GetImageResource(name);
			Debug.Assert(b != null, &quot;Resource &quot; + name);
			return b;
		}
	}
}

--------------050903040900060809020804--


</PRE>
<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI> Previous message: <A HREF="000893.html">[MonoDevelop] Monodevelop brother
</A></li>
	<LI> Next message: <A HREF="000903.html">[MonoDevelop] Monodevelop brother
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#887">[ date ]</a>
              <a href="thread.html#887">[ thread ]</a>
              <a href="subject.html#887">[ subject ]</a>
              <a href="author.html#887">[ author ]</a>
         </LI>
       </UL>
</body></html>
